diff --color -urN vcmi-1.5.7/test/battle/BattleHexTest.cpp vcmi/test/battle/BattleHexTest.cpp
--- vcmi-1.5.7/test/battle/BattleHexTest.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/battle/BattleHexTest.cpp	2024-12-19 15:00:22.995151946 +0100
@@ -92,16 +92,16 @@
 	possibilities.insert(119);
 	possibilities.insert(186);
 
-	EXPECT_EQ(mainHex.getClosestTile(0,mainHex,possibilities), 3);
+	EXPECT_EQ(mainHex.getClosestTile(BattleSide::ATTACKER,mainHex,possibilities), 3);
 	mainHex = 139;
-	EXPECT_EQ(mainHex.getClosestTile(1,mainHex,possibilities), 119);
+	EXPECT_EQ(mainHex.getClosestTile(BattleSide::DEFENDER,mainHex,possibilities), 119);
 	mainHex = 16;
-	EXPECT_EQ(mainHex.getClosestTile(1,mainHex,possibilities), 100);
+	EXPECT_EQ(mainHex.getClosestTile(BattleSide::DEFENDER,mainHex,possibilities), 100);
 	mainHex = 166;
-	EXPECT_EQ(mainHex.getClosestTile(0,mainHex,possibilities), 186);
+	EXPECT_EQ(mainHex.getClosestTile(BattleSide::ATTACKER,mainHex,possibilities), 186);
 	mainHex = 76;
-	EXPECT_EQ(mainHex.getClosestTile(1,mainHex,possibilities), 3);
-	EXPECT_EQ(mainHex.getClosestTile(0,mainHex,possibilities), 100);
+	EXPECT_EQ(mainHex.getClosestTile(BattleSide::DEFENDER,mainHex,possibilities), 3);
+	EXPECT_EQ(mainHex.getClosestTile(BattleSide::ATTACKER,mainHex,possibilities), 100);
 }
 
 TEST(BattleHexTest, moveEDir)
diff --color -urN vcmi-1.5.7/test/battle/battle_UnitTest.cpp vcmi/test/battle/battle_UnitTest.cpp
--- vcmi-1.5.7/test/battle/battle_UnitTest.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/battle/battle_UnitTest.cpp	2024-12-19 15:00:22.995151946 +0100
@@ -15,7 +15,7 @@
 {
 	BattleHex position(77);
 
-	auto actual = battle::Unit::getSurroundingHexes(position, false, 0);
+	auto actual = battle::Unit::getSurroundingHexes(position, false, BattleSide::ATTACKER);
 
 	EXPECT_EQ(actual, position.neighbouringTiles());
 }
@@ -24,7 +24,7 @@
 {
 	BattleHex position(34);
 
-	auto actual = battle::Unit::getSurroundingHexes(position, false, 0);
+	auto actual = battle::Unit::getSurroundingHexes(position, false, BattleSide::ATTACKER);
 
 	EXPECT_EQ(actual, position.neighbouringTiles());
 }
@@ -33,7 +33,7 @@
 {
 	BattleHex position(117);
 
-	auto actual = battle::Unit::getSurroundingHexes(position, false, 0);
+	auto actual = battle::Unit::getSurroundingHexes(position, false, BattleSide::ATTACKER);
 
 	EXPECT_EQ(actual, position.neighbouringTiles());
 }
diff --color -urN vcmi-1.5.7/test/battle/CBattleInfoCallbackTest.cpp vcmi/test/battle/CBattleInfoCallbackTest.cpp
--- vcmi-1.5.7/test/battle/CBattleInfoCallbackTest.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/battle/CBattleInfoCallbackTest.cpp	2024-12-19 15:00:22.995151946 +0100
@@ -40,11 +40,32 @@
 		bonusFake.addNewBonus(b);
 	}
 
+	void addCreatureAbility(BonusType bonusType)
+	{
+		addNewBonus(
+			std::make_shared<Bonus>(
+				BonusDuration::PERMANENT,
+				bonusType,
+				BonusSource::CREATURE_ABILITY,
+				0,
+				CreatureID(0)));
+	}
+
 	void makeAlive()
 	{
 		EXPECT_CALL(*this, alive()).WillRepeatedly(Return(true));
 	}
 
+	void setupPoisition(BattleHex pos)
+	{
+		EXPECT_CALL(*this, getPosition()).WillRepeatedly(Return(pos));
+	}
+
+	void makeDoubleWide()
+	{
+		EXPECT_CALL(*this, doubleWide()).WillRepeatedly(Return(true));
+	}
+
 	void makeWarMachine()
 	{
 		addNewBonus(std::make_shared<Bonus>(BonusDuration::PERMANENT, BonusType::SIEGE_WEAPON, BonusSource::CREATURE_ABILITY, 1, BonusSourceID()));
@@ -52,13 +73,13 @@
 
 	void redirectBonusesToFake()
 	{
-		ON_CALL(*this, getAllBonuses(_, _, _, _)).WillByDefault(Invoke(&bonusFake, &BonusBearerMock::getAllBonuses));
+		ON_CALL(*this, getAllBonuses(_, _, _)).WillByDefault(Invoke(&bonusFake, &BonusBearerMock::getAllBonuses));
 		ON_CALL(*this, getTreeVersion()).WillByDefault(Invoke(&bonusFake, &BonusBearerMock::getTreeVersion));
 	}
 
 	void expectAnyBonusSystemCall()
 	{
-		EXPECT_CALL(*this, getAllBonuses(_, _, _, _)).Times(AtLeast(0));
+		EXPECT_CALL(*this, getAllBonuses(_, _, _)).Times(AtLeast(0));
 		EXPECT_CALL(*this, getTreeVersion()).Times(AtLeast(0));
 	}
 
@@ -83,7 +104,7 @@
 public:
 	std::vector<std::shared_ptr<UnitFake>> allUnits;
 
-	UnitFake & add(ui8 side)
+	UnitFake & add(BattleSide side)
 	{
 		auto * unit = new UnitFake();
 		EXPECT_CALL(*unit, unitSide()).WillRepeatedly(Return(side));
@@ -183,6 +204,190 @@
 	}
 };
 
+class AttackableHexesTest : public CBattleInfoCallbackTest
+{
+public:
+	UnitFake & addRegularMelee(BattleHex hex, BattleSide side)
+	{
+		auto & unit = unitsFake.add(side);
+
+		unit.makeAlive();
+		unit.setDefaultState();
+		unit.setupPoisition(hex);
+		unit.redirectBonusesToFake();
+
+		return unit;
+	}
+
+	UnitFake & addDragon(BattleHex hex, BattleSide side)
+	{
+		auto & unit = addRegularMelee(hex, side);
+
+		unit.addCreatureAbility(BonusType::TWO_HEX_ATTACK_BREATH);
+		unit.makeDoubleWide();
+
+		return unit;
+	}
+
+	Units getAttackedUnits(UnitFake & attacker, UnitFake & defender, BattleHex defenderHex)
+	{
+		startBattle();
+		redirectUnitsToFake();
+
+		return subject.getAttackedBattleUnits(
+			&attacker, &defender,
+			defenderHex, false,
+			attacker.getPosition(),
+			defender.getPosition());
+	}
+};
+
+TEST_F(AttackableHexesTest, DragonRightRegular_RightHorithontalBreath)
+{
+	// X A D #
+	UnitFake & attacker = addDragon(35, BattleSide::ATTACKER);
+	UnitFake & defender = addRegularMelee(36, BattleSide::DEFENDER);
+	UnitFake & next = addRegularMelee(37, BattleSide::DEFENDER);
+
+	auto attacked = getAttackedUnits(attacker, defender, defender.getPosition());
+
+	EXPECT_TRUE(vstd::contains(attacked, &next));
+}
+
+TEST_F(AttackableHexesTest, DragonDragonBottomRightHead_BottomRightBreathFromHead)
+{
+	// X A
+	//    D X		target D
+	//     #
+	UnitFake & attacker = addDragon(35, BattleSide::ATTACKER);
+	UnitFake & defender = addDragon(attacker.getPosition().cloneInDirection(BattleHex::BOTTOM_RIGHT), BattleSide::DEFENDER);
+	UnitFake & next = addRegularMelee(defender.getPosition().cloneInDirection(BattleHex::BOTTOM_RIGHT), BattleSide::DEFENDER);
+	
+	auto attacked = getAttackedUnits(attacker, defender, defender.getPosition());
+
+	EXPECT_TRUE(vstd::contains(attacked, &next));
+}
+
+TEST_F(AttackableHexesTest, DragonDragonVerticalDownHead_VerticalDownBreathFromHead)
+{
+	// X A
+	//  D X		target D
+	//   #
+	UnitFake & attacker = addDragon(35, BattleSide::ATTACKER);
+	UnitFake & defender = addDragon(attacker.getPosition().cloneInDirection(BattleHex::BOTTOM_LEFT), BattleSide::DEFENDER);
+	UnitFake & next = addRegularMelee(defender.getPosition().cloneInDirection(BattleHex::BOTTOM_RIGHT), BattleSide::DEFENDER);
+
+	auto attacked = getAttackedUnits(attacker, defender, defender.getPosition());
+
+	EXPECT_TRUE(vstd::contains(attacked, &next));
+}
+
+TEST_F(AttackableHexesTest, DragonDragonVerticalDownHeadReverse_VerticalDownBreathFromHead)
+{
+	//  A X
+	// X D		target D
+	//  #
+	UnitFake & attacker = addDragon(36, BattleSide::DEFENDER);
+	UnitFake & defender = addDragon(attacker.getPosition().cloneInDirection(BattleHex::BOTTOM_RIGHT), BattleSide::ATTACKER);
+	UnitFake & next = addRegularMelee(defender.getPosition().cloneInDirection(BattleHex::BOTTOM_LEFT), BattleSide::ATTACKER);
+
+	auto attacked = getAttackedUnits(attacker, defender, defender.getPosition());
+
+	EXPECT_TRUE(vstd::contains(attacked, &next));
+}
+
+TEST_F(AttackableHexesTest, DragonDragonVerticalDownBack_VerticalDownBreath)
+{
+	//  X A
+	// D X		target X
+	//  #
+	UnitFake & attacker = addDragon(37, BattleSide::ATTACKER);
+	UnitFake & defender = addDragon(attacker.occupiedHex().cloneInDirection(BattleHex::BOTTOM_LEFT), BattleSide::DEFENDER);
+	UnitFake & next = addRegularMelee(defender.getPosition().cloneInDirection(BattleHex::BOTTOM_RIGHT), BattleSide::DEFENDER);
+
+	auto attacked = getAttackedUnits(attacker, defender, defender.occupiedHex());
+
+	EXPECT_TRUE(vstd::contains(attacked, &next));
+}
+
+TEST_F(AttackableHexesTest, DragonDragonHeadBottomRight_BottomRightBreathFromHead)
+{
+	//  X A
+	// D X		target D
+	//  #
+	UnitFake & attacker = addDragon(37, BattleSide::ATTACKER);
+	UnitFake & defender = addDragon(attacker.occupiedHex().cloneInDirection(BattleHex::BOTTOM_LEFT), BattleSide::DEFENDER);
+	UnitFake & next = addRegularMelee(defender.getPosition().cloneInDirection(BattleHex::BOTTOM_RIGHT), BattleSide::DEFENDER);
+
+	auto attacked = getAttackedUnits(attacker, defender, defender.getPosition());
+
+	EXPECT_TRUE(vstd::contains(attacked, &next));
+}
+
+TEST_F(AttackableHexesTest, DragonVerticalDownDragonBackReverse_VerticalDownBreath)
+{
+	// A X
+	//  X D		target X
+	//   #
+	UnitFake & attacker = addDragon(36, BattleSide::DEFENDER);
+	UnitFake & defender = addDragon(attacker.occupiedHex().cloneInDirection(BattleHex::BOTTOM_RIGHT), BattleSide::ATTACKER);
+	UnitFake & next = addRegularMelee(defender.getPosition().cloneInDirection(BattleHex::BOTTOM_LEFT), BattleSide::ATTACKER);
+
+	auto attacked = getAttackedUnits(attacker, defender, defender.occupiedHex());
+
+	EXPECT_TRUE(vstd::contains(attacked, &next));
+}
+
+TEST_F(AttackableHexesTest, DragonRightBottomDragonHeadReverse_RightBottomBreathFromHeadHex)
+{
+	// A X
+	//  X D		target D
+	UnitFake & attacker = addDragon(36, BattleSide::DEFENDER);
+	UnitFake & defender = addDragon(attacker.occupiedHex().cloneInDirection(BattleHex::BOTTOM_RIGHT), BattleSide::ATTACKER);
+	UnitFake & next = addRegularMelee(defender.getPosition().cloneInDirection(BattleHex::BOTTOM_LEFT), BattleSide::ATTACKER);
+
+	auto attacked = getAttackedUnits(attacker, defender, defender.getPosition());
+
+	EXPECT_TRUE(vstd::contains(attacked, &next));
+}
+
+TEST_F(AttackableHexesTest, DragonLeftBottomDragonBackToBack_LeftBottomBreathFromBackHex)
+{
+	//    X A
+	// D X		target X
+	//  #
+	UnitFake & attacker = addDragon(8, BattleSide::ATTACKER);
+	UnitFake & defender = addDragon(attacker.occupiedHex().cloneInDirection(BattleHex::BOTTOM_LEFT).cloneInDirection(BattleHex::LEFT), BattleSide::DEFENDER);
+	UnitFake & next = addRegularMelee(defender.getPosition().cloneInDirection(BattleHex::BOTTOM_RIGHT), BattleSide::DEFENDER);
+
+	auto attacked = getAttackedUnits(attacker, defender, defender.occupiedHex());
+
+	EXPECT_TRUE(vstd::contains(attacked, &next));
+}
+
+TEST_F(AttackableHexesTest, DefenderPositionOverride_BreathCountsHypoteticDefenderPosition)
+{
+	//  # N
+	// X D		target D
+	//  A X
+	UnitFake & attacker = addDragon(35, BattleSide::DEFENDER);
+	UnitFake & defender = addDragon(8, BattleSide::ATTACKER);
+	UnitFake & next = addDragon(2, BattleSide::ATTACKER);
+
+	startBattle();
+	redirectUnitsToFake();
+
+	auto attacked = subject.getAttackedBattleUnits(
+		&attacker,
+		&defender,
+		19,
+		false,
+		attacker.getPosition(),
+		19);
+
+	EXPECT_TRUE(vstd::contains(attacked, &next));
+}
+
 class BattleFinishedTest : public CBattleInfoCallbackTest
 {
 public:
@@ -197,10 +402,10 @@
 		auto ret = subject.battleIsFinished();
 
 		EXPECT_TRUE(ret);
-		EXPECT_EQ(*ret, 2);
+		EXPECT_EQ(*ret, BattleSide::NONE);
 	}
 
-	void expectBattleWinner(ui8 side)
+	void expectBattleWinner(BattleSide side)
 	{
 		auto ret = subject.battleIsFinished();
 
@@ -208,12 +413,12 @@
 		EXPECT_EQ(*ret, side);
 	}
 
-	void expectBattleLooser(ui8 side)
+	void expectBattleLooser(BattleSide side)
 	{
 		auto ret = subject.battleIsFinished();
 
 		EXPECT_TRUE(ret);
-		EXPECT_NE(*ret, (int)side);
+		EXPECT_NE(*ret, side);
 	}
 
 	void setDefaultExpectations()
@@ -238,21 +443,21 @@
 
 TEST_F(BattleFinishedTest, LastAliveUnitWins)
 {
-	UnitFake & unit = unitsFake.add(1);
+	UnitFake & unit = unitsFake.add(BattleSide::DEFENDER);
 	unit.makeAlive();
 	unit.setDefaultState();
 
 	setDefaultExpectations();
 	startBattle();
-	expectBattleWinner(1);
+	expectBattleWinner(BattleSide::DEFENDER);
 }
 
 TEST_F(BattleFinishedTest, TwoUnitsContinueFight)
 {
-	UnitFake & unit1 = unitsFake.add(0);
+	UnitFake & unit1 = unitsFake.add(BattleSide::ATTACKER);
 	unit1.makeAlive();
 
-	UnitFake & unit2 = unitsFake.add(1);
+	UnitFake & unit2 = unitsFake.add(BattleSide::DEFENDER);
 	unit2.makeAlive();
 
 	setDefaultExpectations();
@@ -263,7 +468,7 @@
 
 TEST_F(BattleFinishedTest, LastWarMachineNotWins)
 {
-	UnitFake & unit = unitsFake.add(0);
+	UnitFake & unit = unitsFake.add(BattleSide::ATTACKER);
 	unit.makeAlive();
 	unit.makeWarMachine();
 	unit.setDefaultState();
@@ -271,18 +476,18 @@
 	setDefaultExpectations();
 	startBattle();
 
-	expectBattleLooser(0);
+	expectBattleLooser(BattleSide::ATTACKER);
 }
 
 TEST_F(BattleFinishedTest, LastWarMachineLoose)
 {
 	try
 	{
-		UnitFake & unit1 = unitsFake.add(0);
+		UnitFake & unit1 = unitsFake.add(BattleSide::ATTACKER);
 		unit1.makeAlive();
 		unit1.setDefaultState();
 
-		UnitFake & unit2 = unitsFake.add(1);
+		UnitFake & unit2 = unitsFake.add(BattleSide::DEFENDER);
 		unit2.makeAlive();
 		unit2.makeWarMachine();
 		unit2.setDefaultState();
@@ -290,7 +495,7 @@
 		setDefaultExpectations();
 		startBattle();
 
-		expectBattleWinner(0);
+		expectBattleWinner(BattleSide::ATTACKER);
 	}
 	catch(const std::exception & e)
 	{
diff --color -urN vcmi-1.5.7/test/battle/CHealthTest.cpp vcmi/test/battle/CHealthTest.cpp
--- vcmi-1.5.7/test/battle/CHealthTest.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/battle/CHealthTest.cpp	2024-12-19 15:00:22.995151946 +0100
@@ -29,7 +29,7 @@
 
 	void setDefaultExpectations()
 	{
-		EXPECT_CALL(mock, getAllBonuses(_, _, _, _)).WillRepeatedly(Invoke(&bonusMock, &BonusBearerMock::getAllBonuses));
+		EXPECT_CALL(mock, getAllBonuses(_, _, _)).WillRepeatedly(Invoke(&bonusMock, &BonusBearerMock::getAllBonuses));
 		EXPECT_CALL(mock, getTreeVersion()).WillRepeatedly(Return(1));
 
 		bonusMock.addNewBonus(std::make_shared<Bonus>(BonusDuration::PERMANENT, BonusType::STACK_HEALTH, BonusSource::CREATURE_ABILITY, UNIT_HEALTH, BonusSourceID()));
@@ -235,7 +235,7 @@
 
 	//one Titan
 
-	EXPECT_CALL(mock, getAllBonuses(_, _, _, _)).WillRepeatedly(Invoke(&bonusMock, &BonusBearerMock::getAllBonuses));
+	EXPECT_CALL(mock, getAllBonuses(_, _, _)).WillRepeatedly(Invoke(&bonusMock, &BonusBearerMock::getAllBonuses));
 	EXPECT_CALL(mock, getTreeVersion()).WillRepeatedly(Return(1));
 
 	bonusMock.addNewBonus(std::make_shared<Bonus>(BonusDuration::PERMANENT, BonusType::STACK_HEALTH, BonusSource::CREATURE_ABILITY, 300, BonusSourceID()));
diff --color -urN vcmi-1.5.7/test/CMakeLists.txt vcmi/test/CMakeLists.txt
--- vcmi-1.5.7/test/CMakeLists.txt	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/CMakeLists.txt	2024-12-19 15:00:22.995151946 +0100
@@ -39,7 +39,7 @@
 		map/CMapFormatTest.cpp
 		map/MapComparer.cpp
 
-		netpacks/EntitiesChangedTest.cpp
+
 		netpacks/NetPackFixture.cpp
 
 		spells/AbilityCasterTest.cpp
diff --color -urN vcmi-1.5.7/test/entity/CCreatureTest.cpp vcmi/test/entity/CCreatureTest.cpp
--- vcmi-1.5.7/test/entity/CCreatureTest.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/entity/CCreatureTest.cpp	2024-12-19 15:00:22.996151987 +0100
@@ -100,7 +100,7 @@
 
 	EXPECT_EQ(subject->getFightValue(), 2420);
 	EXPECT_EQ(subject->getLevel(), 6);
-	EXPECT_EQ(subject->getFaction().getNum(), 55);
+	EXPECT_EQ(subject->getFactionID().getNum(), 55);
 	EXPECT_TRUE(subject->isDoubleWide());
 }
 
diff --color -urN vcmi-1.5.7/test/entity/CFactionTest.cpp vcmi/test/entity/CFactionTest.cpp
--- vcmi-1.5.7/test/entity/CFactionTest.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/entity/CFactionTest.cpp	2024-12-19 15:00:22.996151987 +0100
@@ -9,7 +9,8 @@
  */
 #include "StdInc.h"
 
-#include "../../lib/CTownHandler.h"
+#include "../../lib/entities/faction/CTown.h"
+#include "../../lib/entities/faction/CFaction.h"
 
 namespace test
 {
diff --color -urN vcmi-1.5.7/test/entity/CHeroClassTest.cpp vcmi/test/entity/CHeroClassTest.cpp
--- vcmi-1.5.7/test/entity/CHeroClassTest.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/entity/CHeroClassTest.cpp	2024-12-19 15:00:22.996151987 +0100
@@ -9,7 +9,7 @@
  */
 #include "StdInc.h"
 
-#include "../../lib/CHeroHandler.h"
+#include "../../lib/entities/hero/CHeroClass.h"
 
 namespace test
 {
diff --color -urN vcmi-1.5.7/test/entity/CHeroTest.cpp vcmi/test/entity/CHeroTest.cpp
--- vcmi-1.5.7/test/entity/CHeroTest.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/entity/CHeroTest.cpp	2024-12-19 15:00:22.996151987 +0100
@@ -9,7 +9,7 @@
  */
 #include "StdInc.h"
 
-#include "../../lib/CHeroHandler.h"
+#include "../../lib/entities/hero/CHero.h"
 
 namespace test
 {
diff --color -urN vcmi-1.5.7/test/erm/ERM_MF.cpp vcmi/test/erm/ERM_MF.cpp
--- vcmi-1.5.7/test/erm/ERM_MF.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/erm/ERM_MF.cpp	2024-12-19 15:00:22.997152029 +0100
@@ -53,7 +53,7 @@
 	SCOPED_TRACE("\n" + subject->code);
 	runClientServer();
 
-	EXPECT_CALL(event, getInitalDamage()).WillOnce(Return(23450));
+	EXPECT_CALL(event, getInitialDamage()).WillOnce(Return(23450));
 	EXPECT_CALL(event, setDamage(Eq(23460))).Times(1);
 
 	eventBus.executeEvent(event);
diff --color -urN vcmi-1.5.7/test/erm/ExamplesTest.cpp vcmi/test/erm/ExamplesTest.cpp
--- vcmi-1.5.7/test/erm/ExamplesTest.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/erm/ExamplesTest.cpp	2024-12-19 15:00:22.997152029 +0100
@@ -37,7 +37,7 @@
 	{
 	}
 
-	void setDefaultExpectaions()
+	void setDefaultExpectations()
 	{
 		EXPECT_CALL(infoMock, getLocalPlayer()).WillRepeatedly(Return(PlayerColor(3)));
 		EXPECT_CALL(serverMock, apply(Matcher<CPackForClient *>(_))).WillRepeatedly(Invoke(this, &ExamplesTest::onCommit));
@@ -83,7 +83,7 @@
 
 TEST_F(ExamplesTest, ALL)
 {
-	setDefaultExpectaions();
+	setDefaultExpectations();
 	auto sources = CResourceHandler::get()->getFilteredFiles([](const ResourceID & ident)
 	{
 		return ident.getType() == EResType::ERM && boost::algorithm::starts_with(ident.getName(), "SCRIPTS/TEST/ERM/");
diff --color -urN vcmi-1.5.7/test/game/CGameStateTest.cpp vcmi/test/game/CGameStateTest.cpp
--- vcmi-1.5.7/test/game/CGameStateTest.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/game/CGameStateTest.cpp	2024-12-19 15:00:22.997152029 +0100
@@ -24,6 +24,7 @@
 #include "../../lib/TerrainHandler.h"
 
 #include "../../lib/battle/BattleInfo.h"
+#include "../../lib/battle/BattleLayout.h"
 #include "../../lib/CStack.h"
 
 #include "../../lib/filesystem/ResourcePath.h"
@@ -62,42 +63,42 @@
 		return true;
 	}
 
-	void apply(CPackForClient * pack) override
+	void apply(CPackForClient & pack) override
 	{
 		gameState->apply(pack);
 	}
 
-	void apply(BattleLogMessage * pack) override
+	void apply(BattleLogMessage & pack) override
 	{
 		gameState->apply(pack);
 	}
 
-	void apply(BattleStackMoved * pack) override
+	void apply(BattleStackMoved & pack) override
 	{
 		gameState->apply(pack);
 	}
 
-	void apply(BattleUnitsChanged * pack) override
+	void apply(BattleUnitsChanged & pack) override
 	{
 		gameState->apply(pack);
 	}
 
-	void apply(SetStackEffect * pack) override
+	void apply(SetStackEffect & pack) override
 	{
 		gameState->apply(pack);
 	}
 
-	void apply(StacksInjured * pack) override
+	void apply(StacksInjured & pack) override
 	{
 		gameState->apply(pack);
 	}
 
-	void apply(BattleObstaclesChanged * pack) override
+	void apply(BattleObstaclesChanged & pack) override
 	{
 		gameState->apply(pack);
 	}
 
-	void apply(CatapultAttack * pack) override
+	void apply(CatapultAttack & pack) override
 	{
 		gameState->apply(pack);
 	}
@@ -121,6 +122,10 @@
 		return gameState.get();
 	}
 
+	void createBoat(const int3 & visitablePosition, BoatId type, PlayerColor initiator) override
+	{
+	}
+
 	bool moveHero(ObjectInstanceID hid, int3 dst, EMovementMode movementMode) override
 	{
 		return false;
@@ -142,9 +147,7 @@
 		StartInfo si;
 		si.mapname = "anything";//does not matter, map service mocked
 		si.difficulty = 0;
-		si.mapfileChecksum = 0;
 		si.mode = EStartMode::NEW_GAME;
-		si.seedToBeUsed = 42;
 
 		std::unique_ptr<CMapHeader> header = mapService.loadMapHeader(ResourcePath(si.mapname));
 
@@ -173,8 +176,6 @@
 				pset.heroNameTextId = pinfo.mainCustomHeroNameTextId;
 				pset.heroPortrait = HeroTypeID(pinfo.mainCustomHeroPortrait);
 			}
-
-			pset.handicap = PlayerSettings::NO_HANDICAP;
 		}
 
 
@@ -188,24 +189,25 @@
 
 	void startTestBattle(const CGHeroInstance * attacker, const CGHeroInstance * defender)
 	{
-		const CGHeroInstance * heroes[2] = {attacker, defender};
-		const CArmedInstance * armedInstancies[2] = {attacker, defender};
+		BattleSideArray<const CGHeroInstance *> heroes = {attacker, defender};
+		BattleSideArray<const CArmedInstance *> armedInstancies = {attacker, defender};
 
 		int3 tile(4,4,0);
 
 		const auto & t = *gameCallback->getTile(tile);
 
-		auto terrain = t.terType->getId();
+		auto terrain = t.getTerrainID();
 		BattleField terType(0);
+		BattleLayout layout = BattleLayout::createDefaultLayout(gameState->callback, attacker, defender);
 
 		//send info about battles
 
-		BattleInfo * battle = BattleInfo::setupBattle(tile, terrain, terType, armedInstancies, heroes, false, nullptr);
+		BattleInfo * battle = BattleInfo::setupBattle(tile, terrain, terType, armedInstancies, heroes, layout, nullptr);
 
 		BattleStart bs;
 		bs.info = battle;
 		ASSERT_EQ(gameState->currentBattles.size(), 0);
-		gameCallback->sendAndApply(&bs);
+		gameCallback->sendAndApply(bs);
 		ASSERT_EQ(gameState->currentBattles.size(), 1);
 	}
 
@@ -230,17 +232,11 @@
 	ASSERT_NE(attacker->tempOwner, defender->tempOwner);
 
 	{
-		CArtifactInstance * a = new CArtifactInstance();
-		a->artType = const_cast<CArtifact *>(ArtifactID(ArtifactID::BALLISTA).toArtifact());
-
 		NewArtifact na;
-		na.art = a;
-		gameCallback->sendAndApply(&na);
-
-		PutArtifact pack;
-		pack.al = ArtifactLocation(defender->id, ArtifactPosition::MACH1);
-		pack.art = a;
-		gameCallback->sendAndApply(&pack);
+		na.artHolder = defender->id;
+		na.artId = ArtifactID::BALLISTA;
+		na.pos = ArtifactPosition::MACH1;
+		gameCallback->sendAndApply(na);
 	}
 
 	startTestBattle(attacker, defender);
@@ -251,13 +247,13 @@
 		info.count = 1;
 		info.type = CreatureID(69);
 		info.side = BattleSide::ATTACKER;
-		info.position = gameState->currentBattles.front()->getAvaliableHex(info.type, info.side);
+		info.position = gameState->currentBattles.front()->getAvailableHex(info.type, info.side);
 		info.summoned = false;
 
 		BattleUnitsChanged pack;
 		pack.changedStacks.emplace_back(info.id, UnitChanges::EOperation::ADD);
 		info.save(pack.changedStacks.back().data);
-		gameCallback->sendAndApply(&pack);
+		gameCallback->sendAndApply(pack);
 	}
 
 	const CStack * att = nullptr;
@@ -324,17 +320,11 @@
 	attacker->mana = attacker->manaLimit();
 
 	{
-		CArtifactInstance * a = new CArtifactInstance();
-		a->artType = const_cast<CArtifact *>(ArtifactID(ArtifactID::SPELLBOOK).toArtifact());
-
 		NewArtifact na;
-		na.art = a;
-		gameCallback->sendAndApply(&na);
-
-		PutArtifact pack;
-		pack.al = ArtifactLocation(attacker->id, ArtifactPosition::SPELLBOOK);
-		pack.art = a;
-		gameCallback->sendAndApply(&pack);
+		na.artHolder = attacker->id;
+		na.artId = ArtifactID::SPELLBOOK;
+		na.pos = ArtifactPosition::SPELLBOOK;
+		gameCallback->sendAndApply(na);
 	}
 
 	startTestBattle(attacker, defender);
@@ -347,13 +337,13 @@
 		info.count = 10;
 		info.type = CreatureID(13);
 		info.side = BattleSide::ATTACKER;
-		info.position = gameState->currentBattles.front()->getAvaliableHex(info.type, info.side);
+		info.position = gameState->currentBattles.front()->getAvailableHex(info.type, info.side);
 		info.summoned = false;
 
 		BattleUnitsChanged pack;
 		pack.changedStacks.emplace_back(info.id, UnitChanges::EOperation::ADD);
 		info.save(pack.changedStacks.back().data);
-		gameCallback->sendAndApply(&pack);
+		gameCallback->sendAndApply(pack);
 	}
 
 	{
@@ -362,13 +352,13 @@
 		info.count = 10;
 		info.type = CreatureID(13);
 		info.side = BattleSide::DEFENDER;
-		info.position = gameState->currentBattles.front()->getAvaliableHex(info.type, info.side);
+		info.position = gameState->currentBattles.front()->getAvailableHex(info.type, info.side);
 		info.summoned = false;
 
 		BattleUnitsChanged pack;
 		pack.changedStacks.emplace_back(info.id, UnitChanges::EOperation::ADD);
 		info.save(pack.changedStacks.back().data);
-		gameCallback->sendAndApply(&pack);
+		gameCallback->sendAndApply(pack);
 	}
 
 	CStack * unit = gameState->currentBattles.front()->getStack(unitId);
@@ -411,15 +401,3 @@
 	EXPECT_EQ(unit->health.getCount(), 10);
 	EXPECT_EQ(unit->health.getResurrected(), 0);
 }
-
-TEST_F(CGameStateTest, updateEntity)
-{
-	using ::testing::SaveArg;
-	using ::testing::Eq;
-	using ::testing::_;
-
-	JsonNode actual;
-	EXPECT_CALL(services, updateEntity(Eq(Metatype::CREATURE), Eq(424242), _)).WillOnce(SaveArg<2>(&actual));
-	gameState->updateEntity(Metatype::CREATURE, 424242, JsonNode("TEST"));
-	EXPECT_EQ(actual.String(), "TEST");
-}
diff --color -urN vcmi-1.5.7/test/map/CMapEditManagerTest.cpp vcmi/test/map/CMapEditManagerTest.cpp
--- vcmi-1.5.7/test/map/CMapEditManagerTest.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/map/CMapEditManagerTest.cpp	2024-12-19 15:00:22.997152029 +0100
@@ -25,38 +25,39 @@
 	try
 	{
 		auto map = std::make_unique<CMap>(nullptr);
+		CRandomGenerator rand;
 		map->width = 52;
 		map->height = 52;
 		map->initTerrain();
 		auto editManager = map->getEditManager();
-		editManager->clearTerrain();
+		editManager->clearTerrain(&rand);
 
 		// 1x1 Blow up
 		editManager->getTerrainSelection().select(int3(5, 5, 0));
-		editManager->drawTerrain(ETerrainId::GRASS, 10);
+		editManager->drawTerrain(ETerrainId::GRASS, 10, &rand);
 		static const int3 squareCheck[] = { int3(5,5,0), int3(5,4,0), int3(4,4,0), int3(4,5,0) };
 		for(const auto & tile : squareCheck)
 		{
-			EXPECT_EQ(map->getTile(tile).terType->getId(), ETerrainId::GRASS);
+			EXPECT_EQ(map->getTile(tile).getTerrainID(), ETerrainId::GRASS);
 		}
 
 		// Concat to square
 		editManager->getTerrainSelection().select(int3(6, 5, 0));
-		editManager->drawTerrain(ETerrainId::GRASS, 10);
-		EXPECT_EQ(map->getTile(int3(6, 4, 0)).terType->getId(), ETerrainId::GRASS);
+		editManager->drawTerrain(ETerrainId::GRASS, 10, &rand);
+		EXPECT_EQ(map->getTile(int3(6, 4, 0)).getTerrainID(), ETerrainId::GRASS);
 		editManager->getTerrainSelection().select(int3(6, 5, 0));
-		editManager->drawTerrain(ETerrainId::LAVA, 10);
-		EXPECT_EQ(map->getTile(int3(4, 4, 0)).terType->getId(), ETerrainId::GRASS);
-		EXPECT_EQ(map->getTile(int3(7, 4, 0)).terType->getId(), ETerrainId::LAVA);
+		editManager->drawTerrain(ETerrainId::LAVA, 10, &rand);
+		EXPECT_EQ(map->getTile(int3(4, 4, 0)).getTerrainID(), ETerrainId::GRASS);
+		EXPECT_EQ(map->getTile(int3(7, 4, 0)).getTerrainID(), ETerrainId::LAVA);
 
 		// Special case water,rock
 		editManager->getTerrainSelection().selectRange(MapRect(int3(10, 10, 0), 10, 5));
-		editManager->drawTerrain(ETerrainId::GRASS, 10);
+		editManager->drawTerrain(ETerrainId::GRASS, 10, &rand);
 		editManager->getTerrainSelection().selectRange(MapRect(int3(15, 17, 0), 10, 5));
-		editManager->drawTerrain(ETerrainId::GRASS, 10);
+		editManager->drawTerrain(ETerrainId::GRASS, 10, &rand);
 		editManager->getTerrainSelection().select(int3(21, 16, 0));
-		editManager->drawTerrain(ETerrainId::GRASS, 10);
-		EXPECT_EQ(map->getTile(int3(20, 15, 0)).terType->getId(), ETerrainId::GRASS);
+		editManager->drawTerrain(ETerrainId::GRASS, 10, &rand);
+		EXPECT_EQ(map->getTile(int3(20, 15, 0)).getTerrainID(), ETerrainId::GRASS);
 
 		// Special case non water,rock
 		static const int3 diagonalCheck[] = { int3(31,42,0), int3(32,42,0), int3(32,43,0), int3(33,43,0), int3(33,44,0),
@@ -66,17 +67,17 @@
 		{
 			editManager->getTerrainSelection().select(tile);
 		}
-		editManager->drawTerrain(ETerrainId::GRASS, 10);
-		EXPECT_EQ(map->getTile(int3(35, 44, 0)).terType->getId(), ETerrainId::WATER);
+		editManager->drawTerrain(ETerrainId::GRASS, 10, &rand);
+		EXPECT_EQ(map->getTile(int3(35, 44, 0)).getTerrainID(), ETerrainId::WATER);
 
 		// Rock case
 		editManager->getTerrainSelection().selectRange(MapRect(int3(1, 1, 1), 15, 15));
-		editManager->drawTerrain(ETerrainId::SUBTERRANEAN, 10);
+		editManager->drawTerrain(ETerrainId::SUBTERRANEAN, 10, &rand);
 		std::vector<int3> vec({ int3(6, 6, 1), int3(7, 6, 1), int3(8, 6, 1), int3(5, 7, 1), int3(6, 7, 1), int3(7, 7, 1),
 								int3(8, 7, 1), int3(4, 8, 1), int3(5, 8, 1), int3(6, 8, 1)});
 		editManager->getTerrainSelection().setSelection(vec);
-		editManager->drawTerrain(ETerrainId::ROCK, 10);
-		EXPECT_TRUE(!map->getTile(int3(5, 6, 1)).terType->isPassable() || !map->getTile(int3(7, 8, 1)).terType->isPassable());
+		editManager->drawTerrain(ETerrainId::ROCK, 10, &rand);
+		EXPECT_TRUE(!map->getTile(int3(5, 6, 1)).getTerrain()->isPassable() || !map->getTile(int3(7, 8, 1)).getTerrain()->isPassable());
 
 		//todo: add checks here and enable, also use smaller size
 		#if 0
@@ -143,7 +144,7 @@
 				int3 pos((si32)posVector[0].Float(), (si32)posVector[1].Float(), (si32)posVector[2].Float());
 				const auto & originalTile = originalMap->getTile(pos);
 				editManager->getTerrainSelection().selectRange(MapRect(pos, 1, 1));
-				editManager->drawTerrain(originalTile.terType->getId(), 10, &gen);
+				editManager->drawTerrain(originalTile.getTerrainID(), 10, &gen);
 				const auto & tile = map->getTile(pos);
 				bool isInRange = false;
 				for(const auto & range : mapping)
diff --color -urN vcmi-1.5.7/test/map/CMapFormatTest.cpp vcmi/test/map/CMapFormatTest.cpp
--- vcmi-1.5.7/test/map/CMapFormatTest.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/map/CMapFormatTest.cpp	2024-12-19 15:00:22.997152029 +0100
@@ -95,7 +95,7 @@
 
 	auto data = archive.load(resource)->readAll();
 
-	JsonNode res(reinterpret_cast<const std::byte *>(data.first.get()), data.second);
+	JsonNode res(reinterpret_cast<const std::byte *>(data.first.get()), data.second, resource.getName());
 
 	return res;
 }
diff --color -urN vcmi-1.5.7/test/map/MapComparer.cpp vcmi/test/map/MapComparer.cpp
--- vcmi-1.5.7/test/map/MapComparer.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/map/MapComparer.cpp	2024-12-19 15:00:22.998152070 +0100
@@ -133,7 +133,7 @@
 void checkEqual(const TerrainTile & actual, const TerrainTile & expected)
 {
 	//fatal fail here on any error
-	VCMI_REQUIRE_FIELD_EQUAL(terType);
+	VCMI_REQUIRE_FIELD_EQUAL(terrainType);
 	VCMI_REQUIRE_FIELD_EQUAL(terView);
 	VCMI_REQUIRE_FIELD_EQUAL(riverType);
 	VCMI_REQUIRE_FIELD_EQUAL(riverDir);
@@ -143,9 +143,6 @@
 
 	ASSERT_EQ(actual.blockingObjects.size(), expected.blockingObjects.size());
 	ASSERT_EQ(actual.visitableObjects.size(), expected.visitableObjects.size());
-
-	VCMI_REQUIRE_FIELD_EQUAL(visitable);
-	VCMI_REQUIRE_FIELD_EQUAL(blocked);
 }
 
 //MapComparer
@@ -203,8 +200,8 @@
 	EXPECT_EQ(actual->instanceName, expected->instanceName);
 	EXPECT_EQ(typeid(actual).name(), typeid(expected).name());//todo: remove and use just comparison
 
-	std::string actualFullID = boost::str(boost::format("%s(%d)|%s(%d) %d") % actual->typeName % actual->ID % actual->subTypeName % actual->subID % actual->tempOwner);
-	std::string expectedFullID = boost::str(boost::format("%s(%d)|%s(%d) %d") % expected->typeName % expected->ID % expected->subTypeName % expected->subID % expected->tempOwner);
+	std::string actualFullID = boost::str(boost::format("(%d)|(%d) %d") % actual->ID % actual->subID % actual->tempOwner);
+	std::string expectedFullID = boost::str(boost::format("(%d)|(%d) %d") % expected->ID % expected->subID % expected->tempOwner);
 
 	EXPECT_EQ(actualFullID, expectedFullID);
 
diff --color -urN vcmi-1.5.7/test/mock/BattleFake.cpp vcmi/test/mock/BattleFake.cpp
--- vcmi-1.5.7/test/mock/BattleFake.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/mock/BattleFake.cpp	2024-12-19 15:00:22.998152070 +0100
@@ -34,17 +34,17 @@
 
 void UnitFake::redirectBonusesToFake()
 {
-	ON_CALL(*this, getAllBonuses(_, _, _, _)).WillByDefault(Invoke(&bonusFake, &BonusBearerMock::getAllBonuses));
+	ON_CALL(*this, getAllBonuses(_, _, _)).WillByDefault(Invoke(&bonusFake, &BonusBearerMock::getAllBonuses));
 	ON_CALL(*this, getTreeVersion()).WillByDefault(Invoke(&bonusFake, &BonusBearerMock::getTreeVersion));
 }
 
 void UnitFake::expectAnyBonusSystemCall()
 {
-	EXPECT_CALL(*this, getAllBonuses(_, _, _, _)).Times(AtLeast(0));
+	EXPECT_CALL(*this, getAllBonuses(_, _, _)).Times(AtLeast(0));
 	EXPECT_CALL(*this, getTreeVersion()).Times(AtLeast(0));
 }
 
-UnitFake & UnitsFake::add(ui8 side)
+UnitFake & UnitsFake::add(BattleSide side)
 {
 	auto * unit = new UnitFake();
 	ON_CALL(*unit, unitSide()).WillByDefault(Return(side));
diff --color -urN vcmi-1.5.7/test/mock/BattleFake.h vcmi/test/mock/BattleFake.h
--- vcmi-1.5.7/test/mock/BattleFake.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/mock/BattleFake.h	2024-12-19 15:00:22.998152070 +0100
@@ -52,7 +52,7 @@
 public:
 	std::vector<std::shared_ptr<UnitFake>> allUnits;
 
-	UnitFake & add(ui8 side);
+	UnitFake & add(BattleSide side);
 
 	battle::Units getUnitsIf(battle::UnitFilter predicate) const;
 
@@ -81,9 +81,9 @@
 #endif
 
 	template <typename T>
-	void accept(T * pack)
+	void accept(T & pack)
 	{
-		pack->applyBattle(this);
+		pack.applyBattle(this);
 	}
 
 	const IBattleInfo * getBattle() const override
diff --color -urN vcmi-1.5.7/test/mock/mock_battle_IBattleState.h vcmi/test/mock/mock_battle_IBattleState.h
--- vcmi-1.5.7/test/mock/mock_battle_IBattleState.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/mock/mock_battle_IBattleState.h	2024-12-19 15:00:22.999152111 +0100
@@ -11,6 +11,7 @@
 #pragma once
 
 #include "../../lib/battle/IBattleState.h"
+#include "../../lib/battle/BattleLayout.h"
 #include "../../lib/int3.h"
 
 class BattleStateMock : public IBattleState
@@ -25,20 +26,20 @@
 	MOCK_CONST_METHOD0(getDefendedTown, const CGTownInstance *());
 	MOCK_CONST_METHOD1(getWallState, EWallState(EWallPart));
 	MOCK_CONST_METHOD0(getGateState, EGateState());
-	MOCK_CONST_METHOD1(getSidePlayer, PlayerColor(ui8));
-	MOCK_CONST_METHOD1(getSideArmy, const CArmedInstance *(ui8));
-	MOCK_CONST_METHOD1(getSideHero, const CGHeroInstance *(ui8));
-	MOCK_CONST_METHOD1(getCastSpells, uint32_t(ui8));
-	MOCK_CONST_METHOD1(getEnchanterCounter, int32_t(ui8));
+	MOCK_CONST_METHOD1(getSidePlayer, PlayerColor(BattleSide));
+	MOCK_CONST_METHOD1(getSideArmy, const CArmedInstance *(BattleSide));
+	MOCK_CONST_METHOD1(getSideHero, const CGHeroInstance *(BattleSide));
+	MOCK_CONST_METHOD1(getCastSpells, uint32_t(BattleSide));
+	MOCK_CONST_METHOD1(getEnchanterCounter, int32_t(BattleSide));
 	MOCK_CONST_METHOD0(getTacticDist, ui8());
-	MOCK_CONST_METHOD0(getTacticsSide, ui8());
+	MOCK_CONST_METHOD0(getTacticsSide, BattleSide());
 	MOCK_CONST_METHOD0(getBonusBearer, const IBonusBearer *());
 	MOCK_CONST_METHOD0(nextUnitId, uint32_t());
 	MOCK_CONST_METHOD3(getActualDamage, int64_t(const DamageRange &, int32_t, vstd::RNG &));
 	MOCK_CONST_METHOD0(getBattleID, BattleID());
 	MOCK_CONST_METHOD0(getLocation, int3());
-	MOCK_CONST_METHOD0(isCreatureBank, bool());
-	MOCK_CONST_METHOD1(getUsedSpells, std::vector<SpellID>(ui8));
+	MOCK_CONST_METHOD0(getLayout, BattleLayout());
+	MOCK_CONST_METHOD1(getUsedSpells, std::vector<SpellID>(BattleSide));
 
 	MOCK_METHOD0(nextRound, void());
 	MOCK_METHOD1(nextTurn, void(uint32_t));
diff --color -urN vcmi-1.5.7/test/mock/mock_battle_Unit.h vcmi/test/mock/mock_battle_Unit.h
--- vcmi-1.5.7/test/mock/mock_battle_Unit.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/mock/mock_battle_Unit.h	2024-12-19 15:00:22.999152111 +0100
@@ -15,7 +15,7 @@
 class UnitMock : public battle::Unit
 {
 public:
-	MOCK_CONST_METHOD4(getAllBonuses, TConstBonusListPtr(const CSelector &, const CSelector &, const CBonusSystemNode *, const std::string &));
+	MOCK_CONST_METHOD3(getAllBonuses, TConstBonusListPtr(const CSelector &, const CSelector &, const std::string &));
 	MOCK_CONST_METHOD0(getTreeVersion, int64_t());
 
 	MOCK_CONST_METHOD0(getCasterUnitId, int32_t());
@@ -38,7 +38,7 @@
 
 	MOCK_CONST_METHOD0(unitBaseAmount, int32_t());
 	MOCK_CONST_METHOD0(unitId, uint32_t());
-	MOCK_CONST_METHOD0(unitSide, ui8());
+	MOCK_CONST_METHOD0(unitSide, BattleSide());
 	MOCK_CONST_METHOD0(unitOwner, PlayerColor());
 	MOCK_CONST_METHOD0(unitSlot, SlotID());
 	MOCK_CONST_METHOD0(unitType, const CCreature * ());
@@ -82,7 +82,7 @@
 	MOCK_CONST_METHOD1(willMove, bool(int));
 	MOCK_CONST_METHOD1(waited, bool(int));
 
-	MOCK_CONST_METHOD0(getFaction, FactionID());
+	MOCK_CONST_METHOD0(getFactionID, FactionID());
 
 	MOCK_CONST_METHOD1(battleQueuePhase, battle::BattlePhases::Type(int));
 
@@ -93,7 +93,7 @@
 	MOCK_METHOD1(load, void(const JsonNode &));
 
 	MOCK_METHOD1(damage, void(int64_t &));
-	MOCK_METHOD3(heal, void(int64_t &, EHealLevel, EHealPower));
+	MOCK_METHOD3(heal, battle::HealInfo(int64_t &, EHealLevel, EHealPower));
 };
 
 
diff --color -urN vcmi-1.5.7/test/mock/mock_BonusBearer.cpp vcmi/test/mock/mock_BonusBearer.cpp
--- vcmi-1.5.7/test/mock/mock_BonusBearer.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/mock/mock_BonusBearer.cpp	2024-12-19 15:00:22.998152070 +0100
@@ -25,7 +25,7 @@
 	treeVersion++;
 }
 
-TConstBonusListPtr BonusBearerMock::getAllBonuses(const CSelector & selector, const CSelector & limit, const CBonusSystemNode * root, const std::string & cachingStr) const
+TConstBonusListPtr BonusBearerMock::getAllBonuses(const CSelector & selector, const CSelector & limit, const std::string & cachingStr) const
 {
 	if(cachedLast != treeVersion)
 	{
diff --color -urN vcmi-1.5.7/test/mock/mock_BonusBearer.h vcmi/test/mock/mock_BonusBearer.h
--- vcmi-1.5.7/test/mock/mock_BonusBearer.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/mock/mock_BonusBearer.h	2024-12-19 15:00:22.998152070 +0100
@@ -23,7 +23,7 @@
 
 	void addNewBonus(const std::shared_ptr<Bonus> & b);
 
-	TConstBonusListPtr getAllBonuses(const CSelector & selector, const CSelector & limit, const CBonusSystemNode * root = nullptr, const std::string & cachingStr = "") const override;
+	TConstBonusListPtr getAllBonuses(const CSelector & selector, const CSelector & limit, const std::string & cachingStr = "") const override;
 
 	int64_t getTreeVersion() const override;
 private:
diff --color -urN vcmi-1.5.7/test/mock/mock_Creature.h vcmi/test/mock/mock_Creature.h
--- vcmi-1.5.7/test/mock/mock_Creature.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/mock/mock_Creature.h	2024-12-19 15:00:22.998152070 +0100
@@ -27,6 +27,7 @@
 	MOCK_CONST_METHOD0(getIndex, int32_t());
 	MOCK_CONST_METHOD0(getIconIndex, int32_t());
 	MOCK_CONST_METHOD0(getJsonKey, std::string ());
+	MOCK_CONST_METHOD0(getModScope, std::string ());
 	MOCK_CONST_METHOD0(getName, const std::string &());
 	MOCK_CONST_METHOD0(getId, CreatureID());
 	MOCK_CONST_METHOD0(getBonusBearer, const IBonusBearer *());
@@ -43,7 +44,7 @@
 	MOCK_CONST_METHOD0(getLevel, int32_t());
 	MOCK_CONST_METHOD0(getGrowth, int32_t());
 	MOCK_CONST_METHOD0(getHorde, int32_t());
-	MOCK_CONST_METHOD0(getFaction, FactionID());
+	MOCK_CONST_METHOD0(getFactionID, FactionID());
 
 	MOCK_CONST_METHOD0(getBaseAttack, int32_t());
 	MOCK_CONST_METHOD0(getBaseDefense, int32_t());
diff --color -urN vcmi-1.5.7/test/mock/mock_events_ApplyDamage.h vcmi/test/mock/mock_events_ApplyDamage.h
--- vcmi-1.5.7/test/mock/mock_events_ApplyDamage.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/mock/mock_events_ApplyDamage.h	2024-12-19 15:00:22.999152111 +0100
@@ -20,7 +20,7 @@
 {
 public:
 	MOCK_CONST_METHOD0(isEnabled, bool());
-	MOCK_CONST_METHOD0(getInitalDamage, int64_t());
+	MOCK_CONST_METHOD0(getInitialDamage, int64_t());
 	MOCK_CONST_METHOD0(getDamage, int64_t());
 	MOCK_METHOD1(setDamage, void(int64_t));
 	MOCK_CONST_METHOD0(getTarget, const battle::Unit *());
diff --color -urN vcmi-1.5.7/test/mock/mock_IBattleInfoCallback.h vcmi/test/mock/mock_IBattleInfoCallback.h
--- vcmi-1.5.7/test/mock/mock_IBattleInfoCallback.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/mock/mock_IBattleInfoCallback.h	2024-12-19 15:00:22.998152070 +0100
@@ -22,10 +22,10 @@
 	MOCK_CONST_METHOD0(battleTerrainType, TerrainId());
 	MOCK_CONST_METHOD0(battleGetBattlefieldType, BattleField());
 
-	MOCK_CONST_METHOD0(battleIsFinished, std::optional<int>());
+	MOCK_CONST_METHOD0(battleIsFinished, std::optional<BattleSide>());
 
 	MOCK_CONST_METHOD0(battleTacticDist, si8());
-	MOCK_CONST_METHOD0(battleGetTacticsSide, si8());
+	MOCK_CONST_METHOD0(battleGetTacticsSide, BattleSide());
 
 	MOCK_CONST_METHOD0(battleNextUnitId, uint32_t());
 
diff --color -urN vcmi-1.5.7/test/mock/mock_IGameCallback.cpp vcmi/test/mock/mock_IGameCallback.cpp
--- vcmi-1.5.7/test/mock/mock_IGameCallback.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/mock/mock_IGameCallback.cpp	2024-12-19 15:00:22.998152070 +0100
@@ -27,7 +27,12 @@
 	gs = gameState;
 }
 
-void GameCallbackMock::sendAndApply(CPackForClient * pack)
+void GameCallbackMock::sendAndApply(CPackForClient & pack)
 {
 	upperCallback->apply(pack);
 }
+
+vstd::RNG & GameCallbackMock::getRandomGenerator()
+{
+	throw std::runtime_error("Not implemented!");
+}
diff --color -urN vcmi-1.5.7/test/mock/mock_IGameCallback.h vcmi/test/mock/mock_IGameCallback.h
--- vcmi-1.5.7/test/mock/mock_IGameCallback.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/mock/mock_IGameCallback.h	2024-12-19 15:00:22.998152070 +0100
@@ -37,16 +37,21 @@
 
 	void setObjPropertyValue(ObjectInstanceID objid, ObjProperty prop, int32_t value = 0) override {}
 	void setObjPropertyID(ObjectInstanceID objid, ObjProperty prop, ObjPropertyID identifier) override {}
+	void setBankObjectConfiguration(ObjectInstanceID objid, const BankConfig & configuration) override {}
+	void setRewardableObjectConfiguration(ObjectInstanceID mapObjectID, const Rewardable::Configuration & configuration) override {}
+	void setRewardableObjectConfiguration(ObjectInstanceID townInstanceID, BuildingID buildingID, const Rewardable::Configuration & configuration) override {}
+
 	void showInfoDialog(InfoWindow * iw) override {}
 
 	void changeSpells(const CGHeroInstance * hero, bool give, const std::set<SpellID> &spells) override {}
+	void setResearchedSpells(const CGTownInstance * town, int level, const std::vector<SpellID> & spells, bool accepted) override {}
 	bool removeObject(const CGObjectInstance * obj, const PlayerColor & initiator) override {return false;}
-	void createObject(const int3 & visitablePosition, const PlayerColor & initiator, MapObjectID type, MapObjectSubID subtype) override {};
+	void createBoat(const int3 & visitablePosition, BoatId type, PlayerColor initiator) override {}
 	void setOwner(const CGObjectInstance * objid, PlayerColor owner) override {}
 	void giveExperience(const CGHeroInstance * hero, TExpType val) override {}
 	void changePrimSkill(const CGHeroInstance * hero, PrimarySkill which, si64 val, bool abs=false) override {}
 	void changeSecSkill(const CGHeroInstance * hero, SecondarySkill which, int val, bool abs=false) override {}
-	void showBlockingDialog(BlockingDialog *iw) override {}
+	void showBlockingDialog(const IObjectInterface * caller, BlockingDialog *iw) override {}
 	void showGarrisonDialog(ObjectInstanceID upobj, ObjectInstanceID hid, bool removableUnits) override {} //cb will be called when player closes garrison window
 	void showTeleportDialog(TeleportDialog *iw) override {}
 	void showObjectWindow(const CGObjectInstance * object, EOpenWindowMode window, const CGHeroInstance * visitor, bool addQuery) override {};
@@ -66,17 +71,17 @@
 
 	void removeAfterVisit(const CGObjectInstance *object) override {} //object will be destroyed when interaction is over. Do not call when interaction is not ongoing!
 
-	bool giveHeroNewArtifact(const CGHeroInstance * h, const CArtifact * artType, ArtifactPosition pos) override {return false;}
-	bool putArtifact(const ArtifactLocation & al, const CArtifactInstance * art, std::optional<bool> askAssemble) override {return false;}
+	bool giveHeroNewArtifact(const CGHeroInstance * h, const ArtifactID & artId, const ArtifactPosition & pos) override {return false;}
+	bool giveHeroNewScroll(const CGHeroInstance * h, const SpellID & spellId, const ArtifactPosition & pos) override {return false;}
+	bool putArtifact(const ArtifactLocation & al, const ArtifactInstanceID & id, std::optional<bool> askAssemble) override {return false;}
 	void removeArtifact(const ArtifactLocation &al) override {}
 	bool moveArtifact(const PlayerColor & player, const ArtifactLocation & al1, const ArtifactLocation & al2) override {return false;}
 
 	void heroVisitCastle(const CGTownInstance * obj, const CGHeroInstance * hero) override {}
 	void stopHeroVisitCastle(const CGTownInstance * obj, const CGHeroInstance * hero) override {}
 	void visitCastleObjects(const CGTownInstance * obj, const CGHeroInstance * hero) override {}
-	void startBattlePrimary(const CArmedInstance *army1, const CArmedInstance *army2, int3 tile, const CGHeroInstance *hero1, const CGHeroInstance *hero2, bool creatureBank = false, const CGTownInstance *town = nullptr) override {} //use hero=nullptr for no hero
-	void startBattleI(const CArmedInstance *army1, const CArmedInstance *army2, int3 tile, bool creatureBank = false) override {} //if any of armies is hero, hero will be used
-	void startBattleI(const CArmedInstance *army1, const CArmedInstance *army2, bool creatureBank = false) override {} //if any of armies is hero, hero will be used, visitable tile of second obj is place of battle
+	void startBattle(const CArmedInstance *army1, const CArmedInstance *army2, int3 tile, const CGHeroInstance *hero1, const CGHeroInstance *hero2, const BattleLayout & layout, const CGTownInstance *town) override {} //use hero=nullptr for no hero
+	void startBattle(const CArmedInstance *army1, const CArmedInstance *army2) override {}
 	bool moveHero(ObjectInstanceID hid, int3 dst, EMovementMode movementMode, bool transit = false, PlayerColor asker = PlayerColor::NEUTRAL) override {return false;}
 	bool swapGarrisonOnSiege(ObjectInstanceID tid) override {return false;}
 	void giveHeroBonus(GiveBonus * bonus) override {}
@@ -87,11 +92,13 @@
 	void changeObjPos(ObjectInstanceID objid, int3 newPos, const PlayerColor & initiator) override {}
 	void heroExchange(ObjectInstanceID hero1, ObjectInstanceID hero2) override {} //when two heroes meet on adventure map
 	void changeFogOfWar(int3 center, ui32 radius, PlayerColor player, ETileVisibility mode) override {}
-	void changeFogOfWar(std::unordered_set<int3> &tiles, PlayerColor player, ETileVisibility mode) override {}
+	void changeFogOfWar(const std::unordered_set<int3> &tiles, PlayerColor player, ETileVisibility mode) override {}
 	void castSpell(const spells::Caster * caster, SpellID spellID, const int3 &pos) override {}
 
 	///useful callback methods
-	void sendAndApply(CPackForClient * pack) override;
+	void sendAndApply(CPackForClient & pack) override;
+
+	vstd::RNG & getRandomGenerator() override;
 
 #if SCRIPTING_ENABLED
 	MOCK_CONST_METHOD0(getGlobalContextPool, scripting::Pool *());
diff --color -urN vcmi-1.5.7/test/mock/mock_IGameInfoCallback.h vcmi/test/mock/mock_IGameInfoCallback.h
--- vcmi-1.5.7/test/mock/mock_IGameInfoCallback.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/mock/mock_IGameInfoCallback.h	2024-12-19 15:00:22.999152111 +0100
@@ -17,6 +17,7 @@
 public:
 	//various
 	MOCK_CONST_METHOD1(getDate, int(Date));
+	MOCK_CONST_METHOD1(getStartInfo, const StartInfo *(bool));
 
 	MOCK_CONST_METHOD1(isAllowed, bool(SpellID));
 	MOCK_CONST_METHOD1(isAllowed, bool(ArtifactID));
diff --color -urN vcmi-1.5.7/test/mock/mock_ServerCallback.h vcmi/test/mock/mock_ServerCallback.h
--- vcmi-1.5.7/test/mock/mock_ServerCallback.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/mock/mock_ServerCallback.h	2024-12-19 15:00:22.999152111 +0100
@@ -20,13 +20,13 @@
 	MOCK_METHOD1(complain, void(const std::string &));
 	MOCK_METHOD0(getRNG, vstd::RNG *());
 
-	MOCK_METHOD1(apply, void(CPackForClient *));
+	MOCK_METHOD1(apply, void(CPackForClient &));
 
-	MOCK_METHOD1(apply, void(BattleLogMessage *));
-	MOCK_METHOD1(apply, void(BattleStackMoved *));
-	MOCK_METHOD1(apply, void(BattleUnitsChanged *));
-	MOCK_METHOD1(apply, void(SetStackEffect *));
-	MOCK_METHOD1(apply, void(StacksInjured *));
-	MOCK_METHOD1(apply, void(BattleObstaclesChanged *));
-	MOCK_METHOD1(apply, void(CatapultAttack *));
+	MOCK_METHOD1(apply, void(BattleLogMessage &));
+	MOCK_METHOD1(apply, void(BattleStackMoved &));
+	MOCK_METHOD1(apply, void(BattleUnitsChanged &));
+	MOCK_METHOD1(apply, void(SetStackEffect &));
+	MOCK_METHOD1(apply, void(StacksInjured &));
+	MOCK_METHOD1(apply, void(BattleObstaclesChanged &));
+	MOCK_METHOD1(apply, void(CatapultAttack &));
 };
diff --color -urN vcmi-1.5.7/test/mock/mock_Services.h vcmi/test/mock/mock_Services.h
--- vcmi-1.5.7/test/mock/mock_Services.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/mock/mock_Services.h	2024-12-19 15:00:22.999152111 +0100
@@ -28,7 +28,7 @@
 	MOCK_CONST_METHOD0(skills, const SkillService * ());
 	MOCK_CONST_METHOD0(battlefields, const BattleFieldService *());
 	MOCK_CONST_METHOD0(obstacles, const ObstacleService *());
-	MOCK_CONST_METHOD0(settings, const IGameSettings *());
+	MOCK_CONST_METHOD0(engineSettings, const IGameSettings *());
 
 	MOCK_METHOD3(updateEntity, void(Metatype, int32_t, const JsonNode &));
 
diff --color -urN vcmi-1.5.7/test/mock/mock_spells_Problem.h vcmi/test/mock/mock_spells_Problem.h
--- vcmi-1.5.7/test/mock/mock_spells_Problem.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/mock/mock_spells_Problem.h	2024-12-19 15:00:22.999152111 +0100
@@ -12,7 +12,7 @@
 
 #include <vcmi/spells/Magic.h>
 
-#include "../../lib/MetaString.h"
+#include "../../lib/texts/MetaString.h"
 
 namespace spells
 {
diff --color -urN vcmi-1.5.7/test/mock/mock_spells_Spell.h vcmi/test/mock/mock_spells_Spell.h
--- vcmi-1.5.7/test/mock/mock_spells_Spell.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/mock/mock_spells_Spell.h	2024-12-19 15:00:23.000152153 +0100
@@ -27,6 +27,7 @@
 	MOCK_CONST_METHOD0(getIndex, int32_t());
 	MOCK_CONST_METHOD0(getIconIndex, int32_t());
 	MOCK_CONST_METHOD0(getJsonKey, std::string ());
+	MOCK_CONST_METHOD0(getModScope, std::string ());
 	MOCK_CONST_METHOD0(getName, const std::string &());
 	MOCK_CONST_METHOD0(getId, SpellID());
 	MOCK_CONST_METHOD0(getLevel, int32_t());
@@ -46,6 +47,8 @@
 	MOCK_CONST_METHOD0(isSpecial, bool());
 	MOCK_CONST_METHOD0(isMagical, bool());
 	MOCK_CONST_METHOD0(canCastOnSelf, bool());
+	MOCK_CONST_METHOD0(canCastOnlyOnSelf, bool());
+	MOCK_CONST_METHOD0(canCastWithoutSkip, bool());
 	MOCK_CONST_METHOD1(hasSchool, bool(SpellSchool));
 	MOCK_CONST_METHOD1(forEachSchool, void(const SchoolCallback &));
 	MOCK_CONST_METHOD0(getCastSound, const std::string &());
diff --color -urN vcmi-1.5.7/test/mock/mock_UnitInfo.h vcmi/test/mock/mock_UnitInfo.h
--- vcmi-1.5.7/test/mock/mock_UnitInfo.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/mock/mock_UnitInfo.h	2024-12-19 15:00:22.999152111 +0100
@@ -18,7 +18,7 @@
 	MOCK_CONST_METHOD0(unitBaseAmount, int32_t());
 
 	MOCK_CONST_METHOD0(unitId, uint32_t());
-	MOCK_CONST_METHOD0(unitSide, ui8());
+	MOCK_CONST_METHOD0(unitSide, BattleSide());
 	MOCK_CONST_METHOD0(unitOwner, PlayerColor());
 
 	MOCK_CONST_METHOD0(unitSlot, SlotID());
diff --color -urN vcmi-1.5.7/test/mock/mock_vstd_RNG.h vcmi/test/mock/mock_vstd_RNG.h
--- vcmi-1.5.7/test/mock/mock_vstd_RNG.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/mock/mock_vstd_RNG.h	2024-12-19 15:00:23.000152153 +0100
@@ -18,8 +18,16 @@
 class RNGMock : public RNG
 {
 public:
-	MOCK_METHOD2(getInt64Range, TRandI64(int64_t, int64_t));
-	MOCK_METHOD2(getDoubleRange, TRand(double, double));
+	MOCK_METHOD2(nextInt, int(int lower, int upper));
+	MOCK_METHOD2(nextInt64, int64_t(int64_t lower, int64_t upper));
+	MOCK_METHOD2(nextDouble, double(double lower, double upper));
+
+	MOCK_METHOD1(nextInt, int(int upper));
+	MOCK_METHOD1(nextInt64, int64_t(int64_t upper));
+	MOCK_METHOD1(nextDouble, double(double upper));
+
+	MOCK_METHOD0(nextInt, int());
+	MOCK_METHOD2(nextBinomialInt, int(int coinsCount, double coinChance));
 };
 
 }
diff --color -urN vcmi-1.5.7/test/netpacks/EntitiesChangedTest.cpp vcmi/test/netpacks/EntitiesChangedTest.cpp
--- vcmi-1.5.7/test/netpacks/EntitiesChangedTest.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/netpacks/EntitiesChangedTest.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,47 +0,0 @@
-/*
- * EntitiesChangedTest.cpp, part of VCMI engine
- *
- * Authors: listed in file AUTHORS in main folder
- *
- * License: GNU General Public License v2.0 or later
- * Full text of license available in license.txt file, in main folder
- *
- */
-
-#include "StdInc.h"
-
-#include "NetPackFixture.h"
-#include "../../lib/networkPacks/PacksForClient.h"
-
-namespace test
-{
-using namespace ::testing;
-
-class EntitiesChanged : public Test, public NetPackFixture
-{
-public:
-	std::shared_ptr<::EntitiesChanged> subject;
-protected:
-	void SetUp() override
-	{
-		subject = std::make_shared<::EntitiesChanged>();
-		NetPackFixture::setUp();
-	}
-
-};
-
-TEST_F(EntitiesChanged, Apply)
-{
-	subject->changes.emplace_back();
-
-	EntityChanges & changes = subject->changes.back();
-	changes.metatype = Metatype::CREATURE;
-	changes.entityIndex = 424242;
-	changes.data.String() = "TEST";
-
-	EXPECT_CALL(*gameState, updateEntity(Eq(Metatype::CREATURE), Eq(424242), _));
-
-	gameState->apply(subject.get());
-}
-
-}
diff --color -urN vcmi-1.5.7/test/scripting/LuaSpellEffectAPITest.cpp vcmi/test/scripting/LuaSpellEffectAPITest.cpp
--- vcmi-1.5.7/test/scripting/LuaSpellEffectAPITest.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/scripting/LuaSpellEffectAPITest.cpp	2024-12-19 15:00:23.000152153 +0100
@@ -157,18 +157,18 @@
 	BattleStackMoved expected;
 	BattleStackMoved actual;
 
-	auto checkMove = [&](BattleStackMoved * pack)
+	auto checkMove = [&](BattleStackMoved & pack)
 	{
-		EXPECT_EQ(pack->stack, 42);
-		EXPECT_EQ(pack->teleporting, true);
-		EXPECT_EQ(pack->distance, 0);
+		EXPECT_EQ(pack.stack, 42);
+		EXPECT_EQ(pack.teleporting, true);
+		EXPECT_EQ(pack.distance, 0);
 
 		std::vector<BattleHex> toMove(1, hex2);
 
-		EXPECT_EQ(pack->tilesToMove, toMove);
+		EXPECT_EQ(pack.tilesToMove, toMove);
 	};
 
-	EXPECT_CALL(serverMock, apply(Matcher<BattleStackMoved *>(_))).WillOnce(Invoke(checkMove));
+	EXPECT_CALL(serverMock, apply(Matcher<BattleStackMoved &>(_))).WillOnce(Invoke(checkMove));
 
 	context->callGlobal(&serverMock, "apply", params);
 }
diff --color -urN vcmi-1.5.7/test/scripting/ScriptFixture.cpp vcmi/test/scripting/ScriptFixture.cpp
--- vcmi-1.5.7/test/scripting/ScriptFixture.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/scripting/ScriptFixture.cpp	2024-12-19 15:00:23.000152153 +0100
@@ -9,6 +9,7 @@
  */
 #include "StdInc.h"
 #include "lib/modding/ModScope.h"
+#include "lib/VCMI_Lib.h"
 
 #include "ScriptFixture.h"
 
diff --color -urN vcmi-1.5.7/test/spells/AbilityCasterTest.cpp vcmi/test/spells/AbilityCasterTest.cpp
--- vcmi-1.5.7/test/spells/AbilityCasterTest.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/spells/AbilityCasterTest.cpp	2024-12-19 15:00:23.000152153 +0100
@@ -33,7 +33,7 @@
 protected:
 	void SetUp() override
 	{
-		ON_CALL(actualCaster, getAllBonuses(_, _, _, _)).WillByDefault(Invoke(&casterBonuses, &BonusBearerMock::getAllBonuses));
+		ON_CALL(actualCaster, getAllBonuses(_, _, _)).WillByDefault(Invoke(&casterBonuses, &BonusBearerMock::getAllBonuses));
 		ON_CALL(actualCaster, getTreeVersion()).WillByDefault(Invoke(&casterBonuses, &BonusBearerMock::getTreeVersion));
 	}
 
@@ -57,7 +57,7 @@
 
 	casterBonuses.addNewBonus(std::make_shared<Bonus>(BonusDuration::ONE_BATTLE, BonusType::MAGIC_SCHOOL_SKILL, BonusSource::OTHER, 2, BonusSourceID(), BonusSubtypeID(SpellSchool::ANY)));
 
-	EXPECT_CALL(actualCaster, getAllBonuses(_, _, _, _)).Times(AtLeast(1));
+	EXPECT_CALL(actualCaster, getAllBonuses(_, _, _)).Times(AtLeast(1));
 	EXPECT_CALL(actualCaster, getTreeVersion()).Times(AtLeast(0));
 
 	setupSubject(1);
@@ -65,13 +65,13 @@
 	EXPECT_EQ(subject->getSpellSchoolLevel(&spellMock), 2);
 }
 
-TEST_F(AbilityCasterTest, MagicAbilityIngoresSchoolBonus)
+TEST_F(AbilityCasterTest, MagicAbilityIgnoresSchoolBonus)
 {
 	EXPECT_CALL(spellMock, getLevel()).WillRepeatedly(Return(1));
 
 	casterBonuses.addNewBonus(std::make_shared<Bonus>(BonusDuration::ONE_BATTLE, BonusType::MAGIC_SCHOOL_SKILL, BonusSource::OTHER, 2, BonusSourceID(), BonusSubtypeID(SpellSchool::AIR)));
 
-	EXPECT_CALL(actualCaster, getAllBonuses(_, _, _, _)).Times(AtLeast(1));
+	EXPECT_CALL(actualCaster, getAllBonuses(_, _, _)).Times(AtLeast(1));
 	EXPECT_CALL(actualCaster, getTreeVersion()).Times(AtLeast(0));
 
 	setupSubject(1);
diff --color -urN vcmi-1.5.7/test/spells/effects/CatapultTest.cpp vcmi/test/spells/effects/CatapultTest.cpp
--- vcmi-1.5.7/test/spells/effects/CatapultTest.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/spells/effects/CatapultTest.cpp	2024-12-19 15:00:23.001152194 +0100
@@ -14,6 +14,7 @@
 #include <vstd/RNG.h>
 
 #include "../../../lib/mapObjects/CGTownInstance.h"
+#include "../../../lib/json/JsonNode.h"
 
 
 namespace test
@@ -63,7 +64,7 @@
 TEST_F(CatapultTest, NotApplicableForDefenderIfSmart)
 {
 	auto fakeTown = std::make_shared<CGTownInstance>(nullptr);
-	fakeTown->builtBuildings.insert(BuildingID::FORT);
+	fakeTown->addBuilding(BuildingID::FORT);
 	mechanicsMock.casterSide = BattleSide::DEFENDER;
 
 	EXPECT_CALL(*battleFake, getDefendedTown()).WillRepeatedly(Return(fakeTown.get()));
@@ -77,7 +78,7 @@
 TEST_F(CatapultTest, DISABLED_ApplicableInTown)
 {
 	auto fakeTown = std::make_shared<CGTownInstance>(nullptr);
-	fakeTown->builtBuildings.insert(BuildingID::FORT);
+	fakeTown->addBuilding(BuildingID::FORT);
 
 	EXPECT_CALL(*battleFake, getDefendedTown()).WillRepeatedly(Return(fakeTown.get()));
 	EXPECT_CALL(mechanicsMock, adaptProblem(_, _)).Times(0);
@@ -107,7 +108,7 @@
 	{
 		EffectFixture::setUp();
 		fakeTown = std::make_shared<CGTownInstance>(nullptr);
-		fakeTown->builtBuildings.insert(BuildingID::FORT);
+		fakeTown->addBuilding(BuildingID::FORT);
 	}
 private:
 	std::shared_ptr<CGTownInstance> fakeTown;
@@ -133,7 +134,7 @@
 	EXPECT_CALL(*battleFake, getWallState(_)).WillRepeatedly(Return(EWallState::DESTROYED));
 	EXPECT_CALL(*battleFake, getWallState(Eq(targetPart))).WillRepeatedly(Return(EWallState::INTACT));
 	EXPECT_CALL(*battleFake, setWallState(Eq(targetPart), Eq(EWallState::DAMAGED))).Times(1);
-	EXPECT_CALL(serverMock, apply(Matcher<CatapultAttack *>(_))).Times(1);
+	EXPECT_CALL(serverMock, apply(Matcher<CatapultAttack &>(_))).Times(1);
 
     EffectTarget target;
     target.emplace_back();
diff --color -urN vcmi-1.5.7/test/spells/effects/CloneTest.cpp vcmi/test/spells/effects/CloneTest.cpp
--- vcmi-1.5.7/test/spells/effects/CloneTest.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/spells/effects/CloneTest.cpp	2024-12-19 15:00:23.001152194 +0100
@@ -148,8 +148,8 @@
 
 		battleFake->setupEmptyBattlefield();
 
-		EXPECT_CALL(serverMock, apply(Matcher<BattleUnitsChanged *>(_))).Times(2);
-		EXPECT_CALL(serverMock, apply(Matcher<SetStackEffect *>(_))).Times(1);
+		EXPECT_CALL(serverMock, apply(Matcher<BattleUnitsChanged &>(_))).Times(2);
+		EXPECT_CALL(serverMock, apply(Matcher<SetStackEffect &>(_))).Times(1);
 
 		EXPECT_CALL(mechanicsMock, getEffectDuration()).WillOnce(Return(effectDuration));
 		EXPECT_CALL(*battleFake, getUnitsIf(_)).Times(AtLeast(1));
diff --color -urN vcmi-1.5.7/test/spells/effects/DamageTest.cpp vcmi/test/spells/effects/DamageTest.cpp
--- vcmi-1.5.7/test/spells/effects/DamageTest.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/spells/effects/DamageTest.cpp	2024-12-19 15:00:23.001152194 +0100
@@ -109,7 +109,7 @@
 	targetUnitState->localInit(&unitEnvironmentMock);
 	EXPECT_CALL(targetUnit, acquireState()).WillOnce(Return(targetUnitState));
 	EXPECT_CALL(*battleFake, setUnitState(Eq(unitId),_, Lt(0))).Times(1);
-	EXPECT_CALL(serverMock, apply(Matcher<StacksInjured *>(_))).Times(1);
+	EXPECT_CALL(serverMock, apply(Matcher<StacksInjured &>(_))).Times(1);
 	EXPECT_CALL(serverMock, describeChanges()).WillRepeatedly(Return(false));
 
 	setupDefaultRNG();
@@ -174,7 +174,7 @@
 	EXPECT_CALL(targetUnit, acquireState()).WillOnce(Return(targetUnitState));
 
 	EXPECT_CALL(*battleFake, setUnitState(Eq(unitId),_, Lt(0))).Times(1);
-	EXPECT_CALL(serverMock, apply(Matcher<StacksInjured *>(_))).Times(1);
+	EXPECT_CALL(serverMock, apply(Matcher<StacksInjured &>(_))).Times(1);
 	EXPECT_CALL(serverMock, describeChanges()).WillRepeatedly(Return(false));
 
 	setupDefaultRNG();
@@ -218,7 +218,7 @@
 	EXPECT_CALL(targetUnit, acquireState()).WillOnce(Return(targetUnitState));
 
 	EXPECT_CALL(*battleFake, setUnitState(Eq(unitId), _, Lt(0))).Times(1);
-	EXPECT_CALL(serverMock, apply(Matcher<StacksInjured *>(_))).Times(1);
+	EXPECT_CALL(serverMock, apply(Matcher<StacksInjured &>(_))).Times(1);
 	EXPECT_CALL(serverMock, describeChanges()).WillRepeatedly(Return(false));
 
 	setupDefaultRNG();
diff --color -urN vcmi-1.5.7/test/spells/effects/DispelTest.cpp vcmi/test/spells/effects/DispelTest.cpp
--- vcmi-1.5.7/test/spells/effects/DispelTest.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/spells/effects/DispelTest.cpp	2024-12-19 15:00:23.001152194 +0100
@@ -34,7 +34,7 @@
 	{
 	}
 
-	void setDefaultExpectaions()
+	void setDefaultExpectations()
 	{
 		EXPECT_CALL(mechanicsMock, spells()).Times(AnyNumber());
 
@@ -82,7 +82,7 @@
 	EXPECT_CALL(mechanicsMock, isSmart()).WillOnce(Return(false));
 	EXPECT_CALL(mechanicsMock, getSpellIndex()).Times(AtLeast(1)).WillRepeatedly(Return(neutralID.toEnum()));
 
-	setDefaultExpectaions();
+	setDefaultExpectations();
 	unitsFake.setDefaultBonusExpectations();
 
 	EffectTarget target;
@@ -110,7 +110,7 @@
 	EXPECT_CALL(mechanicsMock, ownerMatches(Eq(&unit))).Times(AtMost(1)).WillRepeatedly(Return(true));
 	EXPECT_CALL(mechanicsMock, getSpellIndex()).Times(AtLeast(1)).WillRepeatedly(Return(neutralID.toEnum()));
 
-	setDefaultExpectaions();
+	setDefaultExpectations();
 	unitsFake.setDefaultBonusExpectations();
 
 	EffectTarget target;
@@ -209,10 +209,10 @@
 
 	EXPECT_CALL(mechanicsMock, getSpellIndex()).Times(AtLeast(1)).WillRepeatedly(Return(neutralID.toEnum()));
 
-	EXPECT_CALL(serverMock, apply(Matcher<SetStackEffect *>(_))).Times(1);
+	EXPECT_CALL(serverMock, apply(Matcher<SetStackEffect &>(_))).Times(1);
 	EXPECT_CALL(serverMock, describeChanges()).WillRepeatedly(Return(false));
 
-	setDefaultExpectaions();
+	setDefaultExpectations();
 	unitsFake.setDefaultBonusExpectations();
 	setupDefaultRNG();
 
diff --color -urN vcmi-1.5.7/test/spells/effects/EffectFixture.cpp vcmi/test/spells/effects/EffectFixture.cpp
--- vcmi-1.5.7/test/spells/effects/EffectFixture.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/spells/effects/EffectFixture.cpp	2024-12-19 15:00:23.001152194 +0100
@@ -92,36 +92,30 @@
 
 	ON_CALL(serverMock, getRNG()).WillByDefault(Return(&rngMock));
 
-	ON_CALL(serverMock, apply(Matcher<BattleLogMessage *>(_))).WillByDefault(Invoke(battleFake.get(),  &battle::BattleFake::accept<BattleLogMessage>));
-	ON_CALL(serverMock, apply(Matcher<BattleStackMoved *>(_))).WillByDefault(Invoke(battleFake.get(),  &battle::BattleFake::accept<BattleStackMoved>));
-	ON_CALL(serverMock, apply(Matcher<BattleUnitsChanged *>(_))).WillByDefault(Invoke(battleFake.get(),  &battle::BattleFake::accept<BattleUnitsChanged>));
-	ON_CALL(serverMock, apply(Matcher<SetStackEffect *>(_))).WillByDefault(Invoke(battleFake.get(),  &battle::BattleFake::accept<SetStackEffect>));
-	ON_CALL(serverMock, apply(Matcher<StacksInjured *>(_))).WillByDefault(Invoke(battleFake.get(),  &battle::BattleFake::accept<StacksInjured>));
-	ON_CALL(serverMock, apply(Matcher<BattleObstaclesChanged *>(_))).WillByDefault(Invoke(battleFake.get(),  &battle::BattleFake::accept<BattleObstaclesChanged>));
-	ON_CALL(serverMock, apply(Matcher<CatapultAttack *>(_))).WillByDefault(Invoke(battleFake.get(),  &battle::BattleFake::accept<CatapultAttack>));
+	ON_CALL(serverMock, apply(Matcher<BattleLogMessage &>(_))).WillByDefault(Invoke(battleFake.get(),  &battle::BattleFake::accept<BattleLogMessage>));
+	ON_CALL(serverMock, apply(Matcher<BattleStackMoved &>(_))).WillByDefault(Invoke(battleFake.get(),  &battle::BattleFake::accept<BattleStackMoved>));
+	ON_CALL(serverMock, apply(Matcher<BattleUnitsChanged &>(_))).WillByDefault(Invoke(battleFake.get(),  &battle::BattleFake::accept<BattleUnitsChanged>));
+	ON_CALL(serverMock, apply(Matcher<SetStackEffect &>(_))).WillByDefault(Invoke(battleFake.get(),  &battle::BattleFake::accept<SetStackEffect>));
+	ON_CALL(serverMock, apply(Matcher<StacksInjured &>(_))).WillByDefault(Invoke(battleFake.get(),  &battle::BattleFake::accept<StacksInjured>));
+	ON_CALL(serverMock, apply(Matcher<BattleObstaclesChanged &>(_))).WillByDefault(Invoke(battleFake.get(),  &battle::BattleFake::accept<BattleObstaclesChanged>));
+	ON_CALL(serverMock, apply(Matcher<CatapultAttack &>(_))).WillByDefault(Invoke(battleFake.get(),  &battle::BattleFake::accept<CatapultAttack>));
 }
 
-static vstd::TRandI64 getInt64RangeDef(int64_t lower, int64_t upper)
+static int64_t getInt64Range(int64_t lower, int64_t upper)
 {
-	return [=]()->int64_t
-	{
-		return (lower + upper)/2;
-	};
+	return (lower + upper)/2;
 }
 
-static vstd::TRand getDoubleRangeDef(double lower, double upper)
+static double getDoubleRange(double lower, double upper)
 {
-	return [=]()->double
-	{
-		return (lower + upper)/2;
-	};
+	return (lower + upper)/2;
 }
 
 void EffectFixture::setupDefaultRNG()
 {
 	EXPECT_CALL(serverMock, getRNG()).Times(AtLeast(0));
-	EXPECT_CALL(rngMock, getInt64Range(_,_)).WillRepeatedly(Invoke(&getInt64RangeDef));
-	EXPECT_CALL(rngMock, getDoubleRange(_,_)).WillRepeatedly(Invoke(&getDoubleRangeDef));
+	EXPECT_CALL(rngMock, nextInt64(_,_)).WillRepeatedly(Invoke(&getInt64Range));
+	EXPECT_CALL(rngMock, nextDouble(_,_)).WillRepeatedly(Invoke(&getDoubleRange));
 }
 
 }
diff --color -urN vcmi-1.5.7/test/spells/effects/HealTest.cpp vcmi/test/spells/effects/HealTest.cpp
--- vcmi-1.5.7/test/spells/effects/HealTest.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/spells/effects/HealTest.cpp	2024-12-19 15:00:23.001152194 +0100
@@ -375,8 +375,8 @@
 
 	EXPECT_CALL(actualCaster, getCasterUnitId()).WillRepeatedly(Return(-1));
 
-	EXPECT_CALL(serverMock, apply(Matcher<BattleUnitsChanged *>(_))).Times(1);
-	EXPECT_CALL(serverMock, apply(Matcher<BattleLogMessage *>(_))).Times(AtLeast(1));
+	EXPECT_CALL(serverMock, apply(Matcher<BattleUnitsChanged &>(_))).Times(1);
+	EXPECT_CALL(serverMock, apply(Matcher<BattleLogMessage &>(_))).Times(AtLeast(1));
 
 	setupDefaultRNG();
 
diff --color -urN vcmi-1.5.7/test/spells/effects/SacrificeTest.cpp vcmi/test/spells/effects/SacrificeTest.cpp
--- vcmi-1.5.7/test/spells/effects/SacrificeTest.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/spells/effects/SacrificeTest.cpp	2024-12-19 15:00:23.001152194 +0100
@@ -203,8 +203,8 @@
 
 	EXPECT_CALL(targetUnit, acquire()).WillOnce(Return(targetUnitState));
 
-	EXPECT_CALL(serverMock, apply(Matcher<BattleUnitsChanged *>(_))).Times(AtLeast(1));
-	EXPECT_CALL(serverMock, apply(Matcher<BattleLogMessage *>(_))).Times(AtLeast(1));
+	EXPECT_CALL(serverMock, apply(Matcher<BattleUnitsChanged &>(_))).Times(AtLeast(1));
+	EXPECT_CALL(serverMock, apply(Matcher<BattleLogMessage &>(_))).Times(AtLeast(1));
 
 	setupDefaultRNG();
 
diff --color -urN vcmi-1.5.7/test/spells/effects/SummonTest.cpp vcmi/test/spells/effects/SummonTest.cpp
--- vcmi-1.5.7/test/spells/effects/SummonTest.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/spells/effects/SummonTest.cpp	2024-12-19 15:00:23.001152194 +0100
@@ -164,7 +164,7 @@
 	{
 	}
 
-	void setDefaultExpectaions()
+	void setDefaultExpectations()
 	{
 		EXPECT_CALL(mechanicsMock, creatures()).Times(AnyNumber());
 		EXPECT_CALL(creatureServiceMock, getById(Eq(toSummon))).WillRepeatedly(Return(&toSummonType));
@@ -221,11 +221,11 @@
 
 TEST_P(SummonApplyTest, DISABLED_SpawnsNewUnit)
 {
-	setDefaultExpectaions();
+	setDefaultExpectations();
 
 	EXPECT_CALL(*battleFake, nextUnitId()).WillOnce(Return(unitId));
 	EXPECT_CALL(*battleFake, addUnit(Eq(unitId), _)).WillOnce(Invoke(this, &SummonApplyTest::onUnitAdded));
-	EXPECT_CALL(serverMock, apply(Matcher<BattleUnitsChanged *>(_))).Times(1);
+	EXPECT_CALL(serverMock, apply(Matcher<BattleUnitsChanged &>(_))).Times(1);
 
 	EffectTarget target;
 	target.emplace_back(unitPosition);
@@ -242,7 +242,7 @@
 
 TEST_P(SummonApplyTest, DISABLED_UpdatesOldUnit)
 {
-	setDefaultExpectaions();
+	setDefaultExpectations();
 
 	acquired = std::make_shared<battle::UnitFake>();
 	acquired->addNewBonus(std::make_shared<Bonus>(BonusDuration::PERMANENT, BonusType::STACK_HEALTH, BonusSource::CREATURE_ABILITY, unitHealth, BonusSourceID()));
@@ -261,7 +261,7 @@
 
 	EXPECT_CALL(unit, unitId()).WillOnce(Return(unitId));
 
-	EXPECT_CALL(serverMock, apply(Matcher<BattleUnitsChanged *>(_))).Times(1);
+	EXPECT_CALL(serverMock, apply(Matcher<BattleUnitsChanged &>(_))).Times(1);
 
 	unitsFake.setDefaultBonusExpectations();
 
diff --color -urN vcmi-1.5.7/test/spells/effects/TeleportTest.cpp vcmi/test/spells/effects/TeleportTest.cpp
--- vcmi-1.5.7/test/spells/effects/TeleportTest.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/spells/effects/TeleportTest.cpp	2024-12-19 15:00:23.001152194 +0100
@@ -71,7 +71,7 @@
 
 	EXPECT_CALL(*battleFake, moveUnit(Eq(unitId), Eq(destination)));
 	EXPECT_CALL(mechanicsMock, getEffectLevel()).WillRepeatedly(Return(0));
-	EXPECT_CALL(serverMock, apply(Matcher<BattleStackMoved *>(_))).Times(1);
+	EXPECT_CALL(serverMock, apply(Matcher<BattleStackMoved &>(_))).Times(1);
 
 	Target target;
 	target.emplace_back(&unit, BattleHex());
diff --color -urN vcmi-1.5.7/test/spells/effects/TimedTest.cpp vcmi/test/spells/effects/TimedTest.cpp
--- vcmi-1.5.7/test/spells/effects/TimedTest.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/spells/effects/TimedTest.cpp	2024-12-19 15:00:23.001152194 +0100
@@ -51,7 +51,7 @@
 	{
 	}
 
-	void setDefaultExpectaions()
+	void setDefaultExpectations()
 	{
 		unitsFake.setDefaultBonusExpectations();
 		EXPECT_CALL(mechanicsMock, getSpellIndex()).WillRepeatedly(Return(spellIndex));
@@ -116,9 +116,9 @@
 		EXPECT_CALL(*battleFake, updateUnitBonus(Eq(unitId),_)).WillOnce(SaveArg<1>(&actualBonus));
 	}
 
-	setDefaultExpectaions();
+	setDefaultExpectations();
 
-	EXPECT_CALL(serverMock, apply(Matcher<SetStackEffect *>(_))).Times(1);
+	EXPECT_CALL(serverMock, apply(Matcher<SetStackEffect &>(_))).Times(1);
 
 	subject->apply(&serverMock, &mechanicsMock, target);
 
diff --color -urN vcmi-1.5.7/test/spells/targetConditions/AbsoluteLevelConditionTest.cpp vcmi/test/spells/targetConditions/AbsoluteLevelConditionTest.cpp
--- vcmi-1.5.7/test/spells/targetConditions/AbsoluteLevelConditionTest.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/spells/targetConditions/AbsoluteLevelConditionTest.cpp	2024-12-19 15:00:23.001152194 +0100
@@ -24,7 +24,7 @@
 	void setDefaultExpectations()
 	{
 		EXPECT_CALL(mechanicsMock, isMagicalEffect()).WillRepeatedly(Return(true));
-		EXPECT_CALL(unitMock, getAllBonuses(_, _, _, _)).Times(AtLeast(1));
+		EXPECT_CALL(unitMock, getAllBonuses(_, _, _)).Times(AtLeast(1));
 		EXPECT_CALL(unitMock, getTreeVersion()).Times(AtLeast(0));
 	}
 
diff --color -urN vcmi-1.5.7/test/spells/targetConditions/AbsoluteSpellConditionTest.cpp vcmi/test/spells/targetConditions/AbsoluteSpellConditionTest.cpp
--- vcmi-1.5.7/test/spells/targetConditions/AbsoluteSpellConditionTest.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/spells/targetConditions/AbsoluteSpellConditionTest.cpp	2024-12-19 15:00:23.001152194 +0100
@@ -24,7 +24,7 @@
 
 	void setDefaultExpectations()
 	{
-		EXPECT_CALL(unitMock, getAllBonuses(_, _, _, _)).Times(AtLeast(1));
+		EXPECT_CALL(unitMock, getAllBonuses(_, _, _)).Times(AtLeast(1));
 		EXPECT_CALL(unitMock, getTreeVersion()).Times(AtLeast(0));
 		EXPECT_CALL(mechanicsMock, getSpellIndex()).WillRepeatedly(Return(castSpell));
 	}
diff --color -urN vcmi-1.5.7/test/spells/targetConditions/BonusConditionTest.cpp vcmi/test/spells/targetConditions/BonusConditionTest.cpp
--- vcmi-1.5.7/test/spells/targetConditions/BonusConditionTest.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/spells/targetConditions/BonusConditionTest.cpp	2024-12-19 15:00:23.001152194 +0100
@@ -21,7 +21,7 @@
 public:
 	void setDefaultExpectations()
 	{
-		EXPECT_CALL(unitMock, getAllBonuses(_, _, _, _)).Times(AtLeast(1));
+		EXPECT_CALL(unitMock, getAllBonuses(_, _, _)).Times(AtLeast(1));
 		EXPECT_CALL(unitMock, getTreeVersion()).Times(AtLeast(0));
 	}
 
diff --color -urN vcmi-1.5.7/test/spells/targetConditions/CreatureConditionTest.cpp vcmi/test/spells/targetConditions/CreatureConditionTest.cpp
--- vcmi-1.5.7/test/spells/targetConditions/CreatureConditionTest.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/spells/targetConditions/CreatureConditionTest.cpp	2024-12-19 15:00:23.002152235 +0100
@@ -21,7 +21,7 @@
 public:
 	void setDefaultExpectations()
 	{
-		EXPECT_CALL(unitMock, getAllBonuses(_, _, _, _)).Times(0);
+		EXPECT_CALL(unitMock, getAllBonuses(_, _, _)).Times(0);
 		EXPECT_CALL(unitMock, getTreeVersion()).Times(0);
 	}
 
diff --color -urN vcmi-1.5.7/test/spells/targetConditions/ElementalConditionTest.cpp vcmi/test/spells/targetConditions/ElementalConditionTest.cpp
--- vcmi-1.5.7/test/spells/targetConditions/ElementalConditionTest.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/spells/targetConditions/ElementalConditionTest.cpp	2024-12-19 15:00:23.002152235 +0100
@@ -23,7 +23,7 @@
 
 	void setDefaultExpectations()
 	{
-		EXPECT_CALL(unitMock, getAllBonuses(_, _, _, _)).Times(AtLeast(1));
+		EXPECT_CALL(unitMock, getAllBonuses(_, _, _)).Times(AtLeast(1));
 		EXPECT_CALL(unitMock, getTreeVersion()).Times(AtLeast(0));
 
 		EXPECT_CALL(mechanicsMock, getSpell()).Times(AtLeast(1)).WillRepeatedly(Return(&spellMock));
diff --color -urN vcmi-1.5.7/test/spells/targetConditions/HealthValueConditionTest.cpp vcmi/test/spells/targetConditions/HealthValueConditionTest.cpp
--- vcmi-1.5.7/test/spells/targetConditions/HealthValueConditionTest.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/spells/targetConditions/HealthValueConditionTest.cpp	2024-12-19 15:00:23.002152235 +0100
@@ -23,7 +23,7 @@
 	const int64_t EFFECT_VALUE = 101;
 	void setDefaultExpectations()
 	{
-		EXPECT_CALL(unitMock, getAllBonuses(_, _, _, _)).Times(0);
+		EXPECT_CALL(unitMock, getAllBonuses(_, _, _)).Times(0);
 		EXPECT_CALL(unitMock, getTreeVersion()).Times(0);
 		EXPECT_CALL(unitMock, getAvailableHealth()).WillOnce(Return(UNIT_HP));
 		EXPECT_CALL(mechanicsMock, getEffectValue()).WillOnce(Return(EFFECT_VALUE));
diff --color -urN vcmi-1.5.7/test/spells/targetConditions/ImmunityNegationConditionTest.cpp vcmi/test/spells/targetConditions/ImmunityNegationConditionTest.cpp
--- vcmi-1.5.7/test/spells/targetConditions/ImmunityNegationConditionTest.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/spells/targetConditions/ImmunityNegationConditionTest.cpp	2024-12-19 15:00:23.002152235 +0100
@@ -30,7 +30,7 @@
 	{
 		ownerMatches = ::testing::get<0>(GetParam());
 		isMagicalEffect = ::testing::get<1>(GetParam());
-		EXPECT_CALL(unitMock, getAllBonuses(_, _, _, _)).Times(AtLeast(0));
+		EXPECT_CALL(unitMock, getAllBonuses(_, _, _)).Times(AtLeast(0));
 		EXPECT_CALL(unitMock, getTreeVersion()).Times(AtLeast(0));
 		EXPECT_CALL(mechanicsMock, isMagicalEffect()).Times(AtLeast(0)).WillRepeatedly(Return(isMagicalEffect));
 		EXPECT_CALL(mechanicsMock, ownerMatches(Eq(&unitMock), Field(&boost::logic::tribool::value, boost::logic::tribool::false_value))).WillRepeatedly(Return(ownerMatches));
diff --color -urN vcmi-1.5.7/test/spells/targetConditions/NormalLevelConditionTest.cpp vcmi/test/spells/targetConditions/NormalLevelConditionTest.cpp
--- vcmi-1.5.7/test/spells/targetConditions/NormalLevelConditionTest.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/spells/targetConditions/NormalLevelConditionTest.cpp	2024-12-19 15:00:23.002152235 +0100
@@ -27,7 +27,7 @@
 		isMagicalEffect = GetParam();
 		EXPECT_CALL(mechanicsMock, isMagicalEffect()).WillRepeatedly(Return(isMagicalEffect));
 		if(isMagicalEffect)
-			EXPECT_CALL(unitMock, getAllBonuses(_, _, _, _)).Times(AtLeast(1));
+			EXPECT_CALL(unitMock, getAllBonuses(_, _, _)).Times(AtLeast(1));
 		EXPECT_CALL(unitMock, getTreeVersion()).Times(AtLeast(0));
 	}
 
diff --color -urN vcmi-1.5.7/test/spells/targetConditions/NormalSpellConditionTest.cpp vcmi/test/spells/targetConditions/NormalSpellConditionTest.cpp
--- vcmi-1.5.7/test/spells/targetConditions/NormalSpellConditionTest.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/spells/targetConditions/NormalSpellConditionTest.cpp	2024-12-19 15:00:23.002152235 +0100
@@ -24,7 +24,7 @@
 
 	void setDefaultExpectations()
 	{
-		EXPECT_CALL(unitMock, getAllBonuses(_, _, _, _)).Times(AtLeast(1));
+		EXPECT_CALL(unitMock, getAllBonuses(_, _, _)).Times(AtLeast(1));
 		EXPECT_CALL(unitMock, getTreeVersion()).Times(AtLeast(0));
 		EXPECT_CALL(mechanicsMock, getSpellIndex()).WillRepeatedly(Return(castSpell));
 	}
diff --color -urN vcmi-1.5.7/test/spells/targetConditions/ReceptiveFeatureConditionTest.cpp vcmi/test/spells/targetConditions/ReceptiveFeatureConditionTest.cpp
--- vcmi-1.5.7/test/spells/targetConditions/ReceptiveFeatureConditionTest.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/spells/targetConditions/ReceptiveFeatureConditionTest.cpp	2024-12-19 15:00:23.002152235 +0100
@@ -27,7 +27,7 @@
 		isPositive = ::testing::get<0>(GetParam());
 		hasBonus = ::testing::get<1>(GetParam());
 
-		EXPECT_CALL(unitMock, getAllBonuses(_, _, _, _)).Times(AtLeast(0));
+		EXPECT_CALL(unitMock, getAllBonuses(_, _, _)).Times(AtLeast(0));
 		EXPECT_CALL(unitMock, getTreeVersion()).Times(AtLeast(0));
 		EXPECT_CALL(mechanicsMock, isPositiveSpell()).WillRepeatedly(Return(isPositive));
 		if(hasBonus)
diff --color -urN vcmi-1.5.7/test/spells/targetConditions/SpellEffectConditionTest.cpp vcmi/test/spells/targetConditions/SpellEffectConditionTest.cpp
--- vcmi-1.5.7/test/spells/targetConditions/SpellEffectConditionTest.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/spells/targetConditions/SpellEffectConditionTest.cpp	2024-12-19 15:00:23.002152235 +0100
@@ -21,7 +21,7 @@
 public:
 	void setDefaultExpectations()
 	{
-		EXPECT_CALL(unitMock, getAllBonuses(_, _, _, _)).Times(AtLeast(1));
+		EXPECT_CALL(unitMock, getAllBonuses(_, _, _)).Times(AtLeast(1));
 		EXPECT_CALL(unitMock, getTreeVersion()).Times(AtLeast(0));
 	}
 
diff --color -urN vcmi-1.5.7/test/spells/targetConditions/TargetConditionItemFixture.h vcmi/test/spells/targetConditions/TargetConditionItemFixture.h
--- vcmi-1.5.7/test/spells/targetConditions/TargetConditionItemFixture.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/spells/targetConditions/TargetConditionItemFixture.h	2024-12-19 15:00:23.002152235 +0100
@@ -37,7 +37,7 @@
 	void SetUp() override
 	{
 		using namespace ::testing;
-		ON_CALL(unitMock, getAllBonuses(_, _, _, _)).WillByDefault(Invoke(&unitBonuses, &BonusBearerMock::getAllBonuses));
+		ON_CALL(unitMock, getAllBonuses(_, _, _)).WillByDefault(Invoke(&unitBonuses, &BonusBearerMock::getAllBonuses));
 		ON_CALL(unitMock, getTreeVersion()).WillByDefault(Invoke(&unitBonuses, &BonusBearerMock::getTreeVersion));
 	}
 };
diff --color -urN vcmi-1.5.7/test/Test.cbp vcmi/test/Test.cbp
--- vcmi-1.5.7/test/Test.cbp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/Test.cbp	1970-01-01 01:00:00.000000000 +0100
@@ -1,240 +0,0 @@
-<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
-<CodeBlocks_project_file>
-	<FileVersion major="1" minor="6" />
-	<Project>
-		<Option title="Test" />
-		<Option compiler="gnu_gcc_compiler_x64" />
-		<Build>
-			<Target title="Debug-win32">
-				<Option platforms="Windows;" />
-				<Option output="../VCMI_Test" prefix_auto="1" extension_auto="1" />
-				<Option working_dir="../." />
-				<Option object_output="obj/Debug/x86/" />
-				<Option type="1" />
-				<Option compiler="gcc" />
-				<Option parameters="--gtest_filter=*TM_T*" />
-				<Compiler>
-					<Add option="-Og" />
-					<Add option="-g" />
-					<Add directory="mock/" />
-				</Compiler>
-				<Linker>
-					<Add option="-lboost_filesystem$(#boost.libsuffix32)" />
-					<Add option="-lboost_system$(#boost.libsuffix32)" />
-					<Add option="-lboost_thread$(#boost.libsuffix32)" />
-					<Add directory="$(#boost.lib32)" />
-				</Linker>
-			</Target>
-			<Target title="Debug-win64">
-				<Option platforms="Windows;" />
-				<Option output="../VCMI_Test" prefix_auto="1" extension_auto="1" />
-				<Option working_dir="../." />
-				<Option object_output="obj/Debug/x64/" />
-				<Option type="1" />
-				<Option compiler="gnu_gcc_compiler_x64" />
-				<Compiler>
-					<Add option="-Og" />
-					<Add option="-g" />
-					<Add directory="mock/" />
-				</Compiler>
-				<Linker>
-					<Add option="-lboost_filesystem$(#boost.libsuffix64)" />
-					<Add option="-lboost_system$(#boost.libsuffix64)" />
-					<Add option="-lboost_thread$(#boost.libsuffix64)" />
-					<Add directory="$(#boost.lib64)" />
-				</Linker>
-			</Target>
-		</Build>
-		<Compiler>
-			<Add option="-Wextra" />
-			<Add option="-Wall" />
-			<Add option="-std=gnu++11" />
-			<Add option="-fexceptions" />
-			<Add option="-Wpointer-arith" />
-			<Add option="-Wno-switch" />
-			<Add option="-Wno-sign-compare" />
-			<Add option="-Wno-unused-parameter" />
-			<Add option="-Wno-overloaded-virtual" />
-			<Add option="-Wno-unused-local-typedefs" />
-			<Add option="-Wno-noexcept-type" />
-			<Add option="-D_WIN32_WINNT=0x0600" />
-			<Add option="-D_WIN32" />
-			<Add option="-DBOOST_ALL_DYN_LINK" />
-			<Add option="-DBOOST_ALL_NO_LIB" />
-			<Add option="-DBOOST_SYSTEM_NO_DEPRECATED" />
-			<Add option="-DVCMI_NO_EXTRA_VERSION" />
-			<Add option="-DVCMI_DUMP_TEST_SCRIPTS" />
-			<Add directory="$(#zlib.include)" />
-			<Add directory="$(#boost.include)" />
-			<Add directory="googletest/googlemock/include" />
-			<Add directory="googletest/googletest/include" />
-			<Add directory="../include" />
-			<Add directory="../AI/FuzzyLite/fuzzylite" />
-			<Add directory="googletest/googlemock" />
-			<Add directory="googletest/googletest" />
-		</Compiler>
-		<Linker>
-			<Add option="-lVCMI_lib" />
-			<Add library="../AI/VCAI.dll" />
-			<Add directory="../" />
-		</Linker>
-		<Unit filename="CMakeLists.txt" />
-		<Unit filename="CMemoryBufferTest.cpp" />
-		<Unit filename="CVcmiTestConfig.cpp" />
-		<Unit filename="CVcmiTestConfig.h" />
-		<Unit filename="JsonComparer.cpp" />
-		<Unit filename="JsonComparer.h" />
-		<Unit filename="StdInc.cpp">
-			<Option compile="0" />
-			<Option link="0" />
-			<Option weight="0" />
-		</Unit>
-		<Unit filename="StdInc.h">
-			<Option weight="0" />
-		</Unit>
-		<Unit filename="battle/BattleHexTest.cpp" />
-		<Unit filename="battle/CBattleInfoCallbackTest.cpp" />
-		<Unit filename="battle/CHealthTest.cpp" />
-		<Unit filename="battle/CUnitStateMagicTest.cpp" />
-		<Unit filename="battle/CUnitStateTest.cpp" />
-		<Unit filename="battle/battle_UnitTest.cpp" />
-		<Unit filename="entity/CArtifactTest.cpp" />
-		<Unit filename="entity/CCreatureTest.cpp" />
-		<Unit filename="entity/CFactionTest.cpp" />
-		<Unit filename="entity/CHeroClassTest.cpp" />
-		<Unit filename="entity/CHeroTest.cpp" />
-		<Unit filename="entity/CSkillTest.cpp" />
-		<Unit filename="erm/ERMPersistenceTest.cpp" />
-		<Unit filename="erm/ERM_BM.cpp" />
-		<Unit filename="erm/ERM_BU.cpp" />
-		<Unit filename="erm/ERM_FU.cpp" />
-		<Unit filename="erm/ERM_GM_T.cpp" />
-		<Unit filename="erm/ERM_MA.cpp" />
-		<Unit filename="erm/ERM_MC.cpp" />
-		<Unit filename="erm/ERM_MF.cpp" />
-		<Unit filename="erm/ERM_OB_T.cpp" />
-		<Unit filename="erm/ERM_TM_T.cpp" />
-		<Unit filename="erm/ERM_UN.cpp" />
-		<Unit filename="erm/ERM_VR.cpp" />
-		<Unit filename="erm/ExamplesTest.cpp" />
-		<Unit filename="erm/interpretter/ERM_VR.cpp" />
-		<Unit filename="erm/interpretter/ErmRunner.cpp" />
-		<Unit filename="erm/interpretter/ErmRunner.h" />
-		<Unit filename="events/ApplyDamageTest.cpp" />
-		<Unit filename="events/EventBusTest.cpp" />
-		<Unit filename="game/CGameStateTest.cpp" />
-		<Unit filename="googletest/googlemock/src/gmock-all.cc" />
-		<Unit filename="googletest/googletest/src/gtest-all.cc" />
-		<Unit filename="main.cpp" />
-		<Unit filename="map/CMapEditManagerTest.cpp" />
-		<Unit filename="map/CMapFormatTest.cpp" />
-		<Unit filename="map/MapComparer.cpp" />
-		<Unit filename="map/MapComparer.h" />
-		<Unit filename="mock/BattleFake.cpp" />
-		<Unit filename="mock/BattleFake.h" />
-		<Unit filename="mock/mock_BonusBearer.cpp" />
-		<Unit filename="mock/mock_BonusBearer.h" />
-		<Unit filename="mock/mock_CPSICallback.cpp" />
-		<Unit filename="mock/mock_CPSICallback.h" />
-		<Unit filename="mock/mock_Creature.h" />
-		<Unit filename="mock/mock_CreatureService.h" />
-		<Unit filename="mock/mock_Environment.h" />
-		<Unit filename="mock/mock_IBattleInfoCallback.h" />
-		<Unit filename="mock/mock_IGameCallback.cpp" />
-		<Unit filename="mock/mock_IGameCallback.h" />
-		<Unit filename="mock/mock_IGameEventCallback.h" />
-		<Unit filename="mock/mock_IGameInfoCallback.h" />
-		<Unit filename="mock/mock_MapService.cpp" />
-		<Unit filename="mock/mock_MapService.h" />
-		<Unit filename="mock/mock_ServerCallback.h" />
-		<Unit filename="mock/mock_Services.h" />
-		<Unit filename="mock/mock_UnitEnvironment.h" />
-		<Unit filename="mock/mock_UnitInfo.h" />
-		<Unit filename="mock/mock_battle_IBattleState.h" />
-		<Unit filename="mock/mock_battle_Unit.h" />
-		<Unit filename="mock/mock_events_ApplyDamage.h" />
-		<Unit filename="mock/mock_scripting_Context.h" />
-		<Unit filename="mock/mock_scripting_Pool.h" />
-		<Unit filename="mock/mock_scripting_Script.h" />
-		<Unit filename="mock/mock_scripting_Service.h" />
-		<Unit filename="mock/mock_spells_Mechanics.h" />
-		<Unit filename="mock/mock_spells_Problem.h" />
-		<Unit filename="mock/mock_spells_Spell.h" />
-		<Unit filename="mock/mock_spells_SpellService.h" />
-		<Unit filename="mock/mock_spells_effects_Registry.h" />
-		<Unit filename="mock/mock_vstd_CLoggerBase.h" />
-		<Unit filename="mock/mock_vstd_RNG.h" />
-		<Unit filename="netpacks/EntitiesChangedTest.cpp" />
-		<Unit filename="netpacks/NetPackFixture.cpp" />
-		<Unit filename="netpacks/NetPackFixture.h" />
-		<Unit filename="rmg/CRmgTemplateTest.cpp" />
-		<Unit filename="scripting/LuaSandboxTest.cpp" />
-		<Unit filename="scripting/LuaSpellEffectAPITest.cpp" />
-		<Unit filename="scripting/LuaSpellEffectTest.cpp" />
-		<Unit filename="scripting/PoolTest.cpp" />
-		<Unit filename="scripting/ScriptFixture.cpp" />
-		<Unit filename="scripting/ScriptFixture.h" />
-		<Unit filename="serializer/JsonUpdaterTest.cpp" />
-		<Unit filename="spells/AbilityCasterTest.cpp" />
-		<Unit filename="spells/CSpellTest.cpp" />
-		<Unit filename="spells/TargetConditionTest.cpp" />
-		<Unit filename="spells/effects/CatapultTest.cpp" />
-		<Unit filename="spells/effects/CloneTest.cpp" />
-		<Unit filename="spells/effects/DamageTest.cpp" />
-		<Unit filename="spells/effects/DispelTest.cpp" />
-		<Unit filename="spells/effects/EffectFixture.cpp" />
-		<Unit filename="spells/effects/EffectFixture.h" />
-		<Unit filename="spells/effects/HealTest.cpp" />
-		<Unit filename="spells/effects/SacrificeTest.cpp" />
-		<Unit filename="spells/effects/SummonTest.cpp" />
-		<Unit filename="spells/effects/TeleportTest.cpp" />
-		<Unit filename="spells/effects/TimedTest.cpp" />
-		<Unit filename="spells/targetConditions/AbsoluteLevelConditionTest.cpp" />
-		<Unit filename="spells/targetConditions/AbsoluteSpellConditionTest.cpp" />
-		<Unit filename="spells/targetConditions/BonusConditionTest.cpp" />
-		<Unit filename="spells/targetConditions/CreatureConditionTest.cpp" />
-		<Unit filename="spells/targetConditions/ElementalConditionTest.cpp" />
-		<Unit filename="spells/targetConditions/HealthValueConditionTest.cpp" />
-		<Unit filename="spells/targetConditions/ImmunityNegationConditionTest.cpp" />
-		<Unit filename="spells/targetConditions/NormalLevelConditionTest.cpp" />
-		<Unit filename="spells/targetConditions/NormalSpellConditionTest.cpp" />
-		<Unit filename="spells/targetConditions/ReceptiveFeatureConditionTest.cpp" />
-		<Unit filename="spells/targetConditions/SpellEffectConditionTest.cpp" />
-		<Unit filename="spells/targetConditions/TargetConditionItemFixture.cpp" />
-		<Unit filename="spells/targetConditions/TargetConditionItemFixture.h" />
-		<Unit filename="testdata/MiniTest/header.json" />
-		<Unit filename="testdata/MiniTest/objects.json" />
-		<Unit filename="testdata/MiniTest/surface_terrain.json" />
-		<Unit filename="testdata/ObjectPropertyTest/header.json" />
-		<Unit filename="testdata/ObjectPropertyTest/objects.ex.json" />
-		<Unit filename="testdata/ObjectPropertyTest/objects.json" />
-		<Unit filename="testdata/ObjectPropertyTest/surface_terrain.json" />
-		<Unit filename="testdata/ObjectPropertyTest/underground_terrain.json" />
-		<Unit filename="testdata/TerrainTest/header.json" />
-		<Unit filename="testdata/TerrainTest/objects.json" />
-		<Unit filename="testdata/TerrainTest/surface_terrain.json" />
-		<Unit filename="testdata/TerrainTest/underground_terrain.json" />
-		<Unit filename="testdata/erm/DO1.json" />
-		<Unit filename="testdata/erm/DO1.verm" />
-		<Unit filename="testdata/erm/list-manipulation.json" />
-		<Unit filename="testdata/erm/list-manipulation.verm" />
-		<Unit filename="testdata/erm/re1.json" />
-		<Unit filename="testdata/erm/re1.verm" />
-		<Unit filename="testdata/erm/std.json" />
-		<Unit filename="testdata/erm/std.verm" />
-		<Unit filename="testdata/erm/testy.json" />
-		<Unit filename="testdata/erm/testy.verm" />
-		<Unit filename="testdata/lua/SandboxTest.lua" />
-		<Unit filename="testdata/lua/SpellEffectAPIMoveUnit.lua" />
-		<Unit filename="testdata/lua/SpellEffectAPITest.lua" />
-		<Unit filename="testdata/rmg/1.json" />
-		<Unit filename="vcai/ResourceManagerTest.h" />
-		<Unit filename="vcai/ResurceManagerTest.cpp" />
-		<Unit filename="vcai/mock_ResourceManager.cpp" />
-		<Unit filename="vcai/mock_ResourceManager.h" />
-		<Unit filename="vcai/mock_VCAI.cpp" />
-		<Unit filename="vcai/mock_VCAI.h" />
-		<Unit filename="vcai/mock_VCAI_CGoal.h" />
-		<Extensions />
-	</Project>
-</CodeBlocks_project_file>
diff --color -urN vcmi-1.5.7/test/testdata/ObjectPropertyTest/objects.ex.json vcmi/test/testdata/ObjectPropertyTest/objects.ex.json
--- vcmi-1.5.7/test/testdata/ObjectPropertyTest/objects.ex.json	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/testdata/ObjectPropertyTest/objects.ex.json	2024-12-19 15:00:23.003152277 +0100
@@ -257,7 +257,7 @@
 		"x" : 6,
 		"y" : 1,
 		"options" : {
-			"text" : "Previus one have random sign"
+			"text" : "Previous one have random sign"
 		}
 	},
 	"oceanBottle_11" : {
@@ -7376,7 +7376,7 @@
 		"x" : 31,
 		"y" : 22,
 		"options" : {
-			"text" : "Arts: have spellbook, head: Admirals hat, shoulders: angel wings, right hand: armagedons blade; left hand: shield of damned; torso: armor of wonder"
+			"text" : "Arts: have spellbook, head: Admirals hat, shoulders: angel wings, right hand: armageddons blade; left hand: shield of damned; torso: armor of wonder"
 		}
 	},
 	"sign_272" : {
diff --color -urN vcmi-1.5.7/test/testdata/ObjectPropertyTest/objects.json vcmi/test/testdata/ObjectPropertyTest/objects.json
--- vcmi-1.5.7/test/testdata/ObjectPropertyTest/objects.json	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/testdata/ObjectPropertyTest/objects.json	2024-12-19 15:00:23.003152277 +0100
@@ -257,7 +257,7 @@
 		"x" : 6,
 		"y" : 1,
 		"options" : {
-			"text" : "Previus one have random sign"
+			"text" : "Previous one have random sign"
 		}
 	},
 	"oceanBottle_11" : {
@@ -7376,7 +7376,7 @@
 		"x" : 31,
 		"y" : 22,
 		"options" : {
-			"text" : "Arts: have spellbook, head: Admirals hat, shoulders: angel wings, right hand: armagedons blade; left hand: shield of damned; torso: armor of wonder"
+			"text" : "Arts: have spellbook, head: Admirals hat, shoulders: angel wings, right hand: armageddons blade; left hand: shield of damned; torso: armor of wonder"
 		}
 	},
 	"sign_272" : {
diff --color -urN vcmi-1.5.7/test/Test.vcxproj vcmi/test/Test.vcxproj
--- vcmi-1.5.7/test/Test.vcxproj	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/Test.vcxproj	1970-01-01 01:00:00.000000000 +0100
@@ -1,252 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <ItemGroup Label="ProjectConfigurations">
-    <ProjectConfiguration Include="Debug|Win32">
-      <Configuration>Debug</Configuration>
-      <Platform>Win32</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Debug|x64">
-      <Configuration>Debug</Configuration>
-      <Platform>x64</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="RD|Win32">
-      <Configuration>RD</Configuration>
-      <Platform>Win32</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="RD|x64">
-      <Configuration>RD</Configuration>
-      <Platform>x64</Platform>
-    </ProjectConfiguration>
-  </ItemGroup>
-  <PropertyGroup Label="Globals">
-    <ProjectGuid>{BA25F3F0-EB87-4164-AAB9-073C50A3557A}</ProjectGuid>
-    <RootNamespace>VCMI_client</RootNamespace>
-    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
-  </PropertyGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='RD|Win32'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <CharacterSet>Unicode</CharacterSet>
-    <WholeProgramOptimization>true</WholeProgramOptimization>
-    <PlatformToolset>v142</PlatformToolset>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='RD|x64'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <CharacterSet>Unicode</CharacterSet>
-    <WholeProgramOptimization>true</WholeProgramOptimization>
-    <PlatformToolset>v140_xp</PlatformToolset>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <CharacterSet>Unicode</CharacterSet>
-    <PlatformToolset>v140_xp</PlatformToolset>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <CharacterSet>Unicode</CharacterSet>
-    <PlatformToolset>v140_xp</PlatformToolset>
-  </PropertyGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
-  <ImportGroup Label="ExtensionSettings">
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='RD|Win32'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-    <Import Project="..\VCMI_global_release.props" />
-    <Import Project="..\VCMI_global.props" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='RD|x64'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-    <Import Project="..\VCMI_global_release.props" />
-    <Import Project="..\VCMI_global.props" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-    <Import Project="..\VCMI_global_debug.props" />
-    <Import Project="..\VCMI_global.props" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-    <Import Project="..\VCMI_global_debug.props" />
-    <Import Project="..\VCMI_global.props" />
-  </ImportGroup>
-  <PropertyGroup Label="UserMacros" />
-  <PropertyGroup>
-    <_ProjectFileVersion>10.0.30128.1</_ProjectFileVersion>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(VCMI_Out)</OutDir>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(VCMI_Out)</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(Configuration)\</IntDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(Configuration)\</IntDir>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='RD|Win32'">..</OutDir>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='RD|x64'">$(VCMI_Out)</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='RD|Win32'">$(Configuration)\</IntDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='RD|x64'">$(Configuration)\</IntDir>
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='RD|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='RD|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='RD|Win32'" />
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='RD|x64'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='RD|Win32'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='RD|x64'" />
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='RD|Win32'">
-    <IncludePath>$(SolutionDir)\AI\FuzzyLite\fuzzylite;$(SolutionDir)\test\googletest\googlemock\include;$(SolutionDir)\test\googletest\googletest\include;$(IncludePath)</IncludePath>
-  </PropertyGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
-    <ClCompile>
-      <Optimization>
-      </Optimization>
-      <DisableSpecificWarnings>4251;%(DisableSpecificWarnings)</DisableSpecificWarnings>
-      <AssemblerOutput>NoListing</AssemblerOutput>
-      <PrecompiledHeader>Use</PrecompiledHeader>
-      <PrecompiledHeaderFile>StdInc.h</PrecompiledHeaderFile>
-      <AdditionalOptions>/MP4 /Zm150</AdditionalOptions>
-    </ClCompile>
-    <Link>
-      <AdditionalDependencies>VCMI_lib.lib;%(AdditionalDependencies)</AdditionalDependencies>
-      <ShowProgress>NotSet</ShowProgress>
-      <OptimizeReferences>false</OptimizeReferences>
-      <Profile>true</Profile>
-      <AdditionalLibraryDirectories>..\..\libs</AdditionalLibraryDirectories>
-    </Link>
-    <Manifest />
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
-    <ClCompile>
-      <PreprocessToFile>false</PreprocessToFile>
-      <PreprocessSuppressLineNumbers>false</PreprocessSuppressLineNumbers>
-      <DisableSpecificWarnings>4251;%(DisableSpecificWarnings)</DisableSpecificWarnings>
-      <AssemblerOutput>NoListing</AssemblerOutput>
-      <PrecompiledHeader>Use</PrecompiledHeader>
-      <PrecompiledHeaderFile>StdInc.h</PrecompiledHeaderFile>
-      <AdditionalOptions>/MP4 /Zm150</AdditionalOptions>
-    </ClCompile>
-    <Link>
-      <AdditionalDependencies>VCMI_lib.lib;%(AdditionalDependencies)</AdditionalDependencies>
-      <ShowProgress>LinkVerbose</ShowProgress>
-      <OptimizeReferences>false</OptimizeReferences>
-      <Profile>true</Profile>
-    </Link>
-    <Manifest />
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='RD|Win32'">
-    <ClCompile>
-      <PrecompiledHeader>Use</PrecompiledHeader>
-      <PrecompiledHeaderFile>StdInc.h</PrecompiledHeaderFile>
-      <AdditionalOptions>
-      </AdditionalOptions>
-      <MultiProcessorCompilation>true</MultiProcessorCompilation>
-    </ClCompile>
-    <Link>
-      <AdditionalDependencies>VCMI_lib.lib;VCAI.lib;FuzzyLite.lib;gmock.lib;gtest.lib;%(AdditionalDependencies)</AdditionalDependencies>
-      <Driver>NotSet</Driver>
-      <LinkTimeCodeGeneration>
-      </LinkTimeCodeGeneration>
-      <ShowProgress>NotSet</ShowProgress>
-      <AdditionalLibraryDirectories>..\..\libs;..</AdditionalLibraryDirectories>
-      <AdditionalOptions>/LTCG %(AdditionalOptions)</AdditionalOptions>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='RD|x64'">
-    <ClCompile>
-      <AdditionalOptions>/MP4 /Zm150</AdditionalOptions>
-      <PrecompiledHeader>Use</PrecompiledHeader>
-      <PrecompiledHeaderFile>StdInc.h</PrecompiledHeaderFile>
-    </ClCompile>
-    <Link>
-      <AdditionalDependencies>VCMI_lib.lib;%(AdditionalDependencies)</AdditionalDependencies>
-      <Driver>NotSet</Driver>
-      <LinkTimeCodeGeneration>
-      </LinkTimeCodeGeneration>
-      <ShowProgress>NotSet</ShowProgress>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemGroup>
-    <ProjectReference Include="..\lib\VCMI_lib.vcxproj">
-      <Project>{b952ffc5-3039-4de1-9f08-90acda483d8f}</Project>
-    </ProjectReference>
-  </ItemGroup>
-  <ItemGroup>
-    <ClCompile Include="battle\BattleHexTest.cpp" />
-    <ClCompile Include="battle\battle_UnitTest.cpp" />
-    <ClCompile Include="battle\CBattleInfoCallbackTest.cpp" />
-    <ClCompile Include="battle\CHealthTest.cpp" />
-    <ClCompile Include="battle\CUnitStateMagicTest.cpp" />
-    <ClCompile Include="battle\CUnitStateTest.cpp" />
-    <ClCompile Include="CMemoryBufferTest.cpp" />
-    <ClCompile Include="CVcmiTestConfig.cpp" />
-    <ClCompile Include="game\CGameStateTest.cpp" />
-    <ClCompile Include="JsonComparer.cpp" />
-    <ClCompile Include="map\CMapEditManagerTest.cpp" />
-    <ClCompile Include="map\CMapFormatTest.cpp" />
-    <ClCompile Include="map\MapComparer.cpp" />
-    <ClCompile Include="mock\mock_BonusBearer.cpp" />
-    <ClCompile Include="mock\mock_CPSICallback.cpp" />
-    <ClCompile Include="mock\mock_IGameCallback.cpp" />
-    <ClCompile Include="mock\mock_MapService.cpp" />
-    <ClCompile Include="spells\AbilityCasterTest.cpp" />
-    <ClCompile Include="spells\effects\CatapultTest.cpp" />
-    <ClCompile Include="spells\effects\CloneTest.cpp" />
-    <ClCompile Include="spells\effects\DamageTest.cpp" />
-    <ClCompile Include="spells\effects\DispelTest.cpp" />
-    <ClCompile Include="spells\effects\EffectFixture.cpp" />
-    <ClCompile Include="spells\effects\HealTest.cpp" />
-    <ClCompile Include="spells\effects\SacrificeTest.cpp" />
-    <ClCompile Include="spells\effects\SummonTest.cpp" />
-    <ClCompile Include="spells\effects\TeleportTest.cpp" />
-    <ClCompile Include="spells\effects\TimedTest.cpp" />
-    <ClCompile Include="spells\targetConditions\AbsoluteLevelConditionTest.cpp" />
-    <ClCompile Include="spells\targetConditions\AbsoluteSpellConditionTest.cpp" />
-    <ClCompile Include="spells\targetConditions\BonusConditionTest.cpp" />
-    <ClCompile Include="spells\targetConditions\CreatureConditionTest.cpp" />
-    <ClCompile Include="spells\targetConditions\ElementalConditionTest.cpp" />
-    <ClCompile Include="spells\targetConditions\HealthValueConditionTest.cpp" />
-    <ClCompile Include="spells\targetConditions\ImmunityNegationConditionTest.cpp" />
-    <ClCompile Include="spells\targetConditions\NormalLevelConditionTest.cpp" />
-    <ClCompile Include="spells\targetConditions\NormalSpellConditionTest.cpp" />
-    <ClCompile Include="spells\targetConditions\ReceptiveFeatureConditionTest.cpp" />
-    <ClCompile Include="spells\targetConditions\SpellEffectConditionTest.cpp" />
-    <ClCompile Include="spells\targetConditions\TargetConditionItemFixture.cpp" />
-    <ClCompile Include="spells\TargetConditionTest.cpp" />
-    <ClCompile Include="StdInc.cpp">
-      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
-      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='RD|Win32'">Create</PrecompiledHeader>
-      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
-      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='RD|x64'">Create</PrecompiledHeader>
-    </ClCompile>
-    <ClCompile Include="vcai\mock_ResourceManager.cpp" />
-    <ClCompile Include="vcai\mock_VCAI.cpp" />
-    <ClCompile Include="vcai\ResurceManagerTest.cpp" />
-  </ItemGroup>
-  <ItemGroup>
-    <ClInclude Include="CVcmiTestConfig.h" />
-    <ClInclude Include="JsonComparer.h" />
-    <ClInclude Include="map\MapComparer.h" />
-    <ClInclude Include="mock\mock_battle_IBattleState.h" />
-    <ClInclude Include="mock\mock_battle_Unit.h" />
-    <ClInclude Include="mock\mock_BonusBearer.h" />
-    <ClInclude Include="mock\mock_CPSICallback.h" />
-    <ClInclude Include="mock\mock_IGameCallback.h" />
-    <ClInclude Include="mock\mock_MapService.h" />
-    <ClInclude Include="mock\mock_spells_Mechanics.h" />
-    <ClInclude Include="mock\mock_spells_Problem.h" />
-    <ClInclude Include="mock\mock_spells_Spell.h" />
-    <ClInclude Include="mock\mock_UnitEnvironment.h" />
-    <ClInclude Include="mock\mock_UnitInfo.h" />
-    <ClInclude Include="mock\mock_vstd_RNG.h" />
-    <ClInclude Include="spells\effects\EffectFixture.h" />
-    <ClInclude Include="spells\targetConditions\TargetConditionItemFixture.h" />
-    <ClInclude Include="StdInc.h" />
-    <ClInclude Include="vcai\mock_ResourceManager.h" />
-    <ClInclude Include="vcai\mock_VCAI.h" />
-    <ClInclude Include="vcai\mock_VCAI_CGoal.h" />
-    <ClInclude Include="vcai\ResourceManagerTest.h" />
-  </ItemGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
-  <ImportGroup Label="ExtensionTargets">
-  </ImportGroup>
-</Project>
\ No newline at end of file
diff --color -urN vcmi-1.5.7/test/Test.vcxproj.filters vcmi/test/Test.vcxproj.filters
--- vcmi-1.5.7/test/Test.vcxproj.filters	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/Test.vcxproj.filters	1970-01-01 01:00:00.000000000 +0100
@@ -1,220 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <ItemGroup>
-    <ClCompile Include="CVcmiTestConfig.cpp" />
-    <ClCompile Include="StdInc.cpp" />
-    <ClCompile Include="CMemoryBufferTest.cpp" />
-    <ClCompile Include="JsonComparer.cpp" />
-    <ClCompile Include="map\CMapEditManagerTest.cpp">
-      <Filter>map</Filter>
-    </ClCompile>
-    <ClCompile Include="map\CMapFormatTest.cpp">
-      <Filter>map</Filter>
-    </ClCompile>
-    <ClCompile Include="map\MapComparer.cpp">
-      <Filter>map</Filter>
-    </ClCompile>
-    <ClCompile Include="battle\battle_UnitTest.cpp">
-      <Filter>battle</Filter>
-    </ClCompile>
-    <ClCompile Include="battle\BattleHexTest.cpp">
-      <Filter>battle</Filter>
-    </ClCompile>
-    <ClCompile Include="battle\CBattleInfoCallbackTest.cpp">
-      <Filter>battle</Filter>
-    </ClCompile>
-    <ClCompile Include="battle\CHealthTest.cpp">
-      <Filter>battle</Filter>
-    </ClCompile>
-    <ClCompile Include="battle\CUnitStateMagicTest.cpp">
-      <Filter>battle</Filter>
-    </ClCompile>
-    <ClCompile Include="battle\CUnitStateTest.cpp">
-      <Filter>battle</Filter>
-    </ClCompile>
-    <ClCompile Include="game\CGameStateTest.cpp">
-      <Filter>game</Filter>
-    </ClCompile>
-    <ClCompile Include="spells\effects\CatapultTest.cpp">
-      <Filter>spells\effects</Filter>
-    </ClCompile>
-    <ClCompile Include="spells\effects\CloneTest.cpp">
-      <Filter>spells\effects</Filter>
-    </ClCompile>
-    <ClCompile Include="spells\effects\DamageTest.cpp">
-      <Filter>spells\effects</Filter>
-    </ClCompile>
-    <ClCompile Include="spells\effects\DispelTest.cpp">
-      <Filter>spells\effects</Filter>
-    </ClCompile>
-    <ClCompile Include="spells\effects\EffectFixture.cpp">
-      <Filter>spells\effects</Filter>
-    </ClCompile>
-    <ClCompile Include="spells\effects\HealTest.cpp">
-      <Filter>spells\effects</Filter>
-    </ClCompile>
-    <ClCompile Include="spells\effects\SacrificeTest.cpp">
-      <Filter>spells\effects</Filter>
-    </ClCompile>
-    <ClCompile Include="spells\effects\SummonTest.cpp">
-      <Filter>spells\effects</Filter>
-    </ClCompile>
-    <ClCompile Include="spells\effects\TeleportTest.cpp">
-      <Filter>spells\effects</Filter>
-    </ClCompile>
-    <ClCompile Include="spells\effects\TimedTest.cpp">
-      <Filter>spells\effects</Filter>
-    </ClCompile>
-    <ClCompile Include="spells\targetConditions\AbsoluteLevelConditionTest.cpp">
-      <Filter>spells\targetConditions</Filter>
-    </ClCompile>
-    <ClCompile Include="spells\targetConditions\AbsoluteSpellConditionTest.cpp">
-      <Filter>spells\targetConditions</Filter>
-    </ClCompile>
-    <ClCompile Include="spells\targetConditions\BonusConditionTest.cpp">
-      <Filter>spells\targetConditions</Filter>
-    </ClCompile>
-    <ClCompile Include="spells\targetConditions\CreatureConditionTest.cpp">
-      <Filter>spells\targetConditions</Filter>
-    </ClCompile>
-    <ClCompile Include="spells\targetConditions\ElementalConditionTest.cpp">
-      <Filter>spells\targetConditions</Filter>
-    </ClCompile>
-    <ClCompile Include="spells\targetConditions\HealthValueConditionTest.cpp">
-      <Filter>spells\targetConditions</Filter>
-    </ClCompile>
-    <ClCompile Include="spells\targetConditions\ImmunityNegationConditionTest.cpp">
-      <Filter>spells\targetConditions</Filter>
-    </ClCompile>
-    <ClCompile Include="spells\targetConditions\NormalLevelConditionTest.cpp">
-      <Filter>spells\targetConditions</Filter>
-    </ClCompile>
-    <ClCompile Include="spells\targetConditions\NormalSpellConditionTest.cpp">
-      <Filter>spells\targetConditions</Filter>
-    </ClCompile>
-    <ClCompile Include="spells\targetConditions\ReceptiveFeatureConditionTest.cpp">
-      <Filter>spells\targetConditions</Filter>
-    </ClCompile>
-    <ClCompile Include="spells\targetConditions\SpellEffectConditionTest.cpp">
-      <Filter>spells\targetConditions</Filter>
-    </ClCompile>
-    <ClCompile Include="spells\targetConditions\TargetConditionItemFixture.cpp">
-      <Filter>spells\targetConditions</Filter>
-    </ClCompile>
-    <ClCompile Include="spells\AbilityCasterTest.cpp">
-      <Filter>spells</Filter>
-    </ClCompile>
-    <ClCompile Include="spells\TargetConditionTest.cpp">
-      <Filter>spells</Filter>
-    </ClCompile>
-    <ClCompile Include="vcai\mock_ResourceManager.cpp">
-      <Filter>vcai</Filter>
-    </ClCompile>
-    <ClCompile Include="vcai\mock_VCAI.cpp">
-      <Filter>vcai</Filter>
-    </ClCompile>
-    <ClCompile Include="vcai\ResurceManagerTest.cpp">
-      <Filter>vcai</Filter>
-    </ClCompile>
-    <ClCompile Include="mock\mock_BonusBearer.cpp">
-      <Filter>mock</Filter>
-    </ClCompile>
-    <ClCompile Include="mock\mock_CPSICallback.cpp">
-      <Filter>mock</Filter>
-    </ClCompile>
-    <ClCompile Include="mock\mock_IGameCallback.cpp">
-      <Filter>mock</Filter>
-    </ClCompile>
-    <ClCompile Include="mock\mock_MapService.cpp">
-      <Filter>mock</Filter>
-    </ClCompile>
-  </ItemGroup>
-  <ItemGroup>
-    <ClInclude Include="CVcmiTestConfig.h" />
-    <ClInclude Include="StdInc.h" />
-    <ClInclude Include="JsonComparer.h" />
-    <ClInclude Include="map\MapComparer.h">
-      <Filter>map</Filter>
-    </ClInclude>
-    <ClInclude Include="spells\effects\EffectFixture.h">
-      <Filter>spells\effects</Filter>
-    </ClInclude>
-    <ClInclude Include="spells\targetConditions\TargetConditionItemFixture.h">
-      <Filter>spells\targetConditions</Filter>
-    </ClInclude>
-    <ClInclude Include="vcai\mock_ResourceManager.h">
-      <Filter>vcai</Filter>
-    </ClInclude>
-    <ClInclude Include="vcai\mock_VCAI.h">
-      <Filter>vcai</Filter>
-    </ClInclude>
-    <ClInclude Include="vcai\mock_VCAI_CGoal.h">
-      <Filter>vcai</Filter>
-    </ClInclude>
-    <ClInclude Include="vcai\ResourceManagerTest.h">
-      <Filter>vcai</Filter>
-    </ClInclude>
-    <ClInclude Include="mock\mock_battle_IBattleState.h">
-      <Filter>mock</Filter>
-    </ClInclude>
-    <ClInclude Include="mock\mock_battle_Unit.h">
-      <Filter>mock</Filter>
-    </ClInclude>
-    <ClInclude Include="mock\mock_BonusBearer.h">
-      <Filter>mock</Filter>
-    </ClInclude>
-    <ClInclude Include="mock\mock_CPSICallback.h">
-      <Filter>mock</Filter>
-    </ClInclude>
-    <ClInclude Include="mock\mock_IGameCallback.h">
-      <Filter>mock</Filter>
-    </ClInclude>
-    <ClInclude Include="mock\mock_MapService.h">
-      <Filter>mock</Filter>
-    </ClInclude>
-    <ClInclude Include="mock\mock_spells_Mechanics.h">
-      <Filter>mock</Filter>
-    </ClInclude>
-    <ClInclude Include="mock\mock_spells_Problem.h">
-      <Filter>mock</Filter>
-    </ClInclude>
-    <ClInclude Include="mock\mock_spells_Spell.h">
-      <Filter>mock</Filter>
-    </ClInclude>
-    <ClInclude Include="mock\mock_UnitEnvironment.h">
-      <Filter>mock</Filter>
-    </ClInclude>
-    <ClInclude Include="mock\mock_UnitInfo.h">
-      <Filter>mock</Filter>
-    </ClInclude>
-    <ClInclude Include="mock\mock_vstd_RNG.h">
-      <Filter>mock</Filter>
-    </ClInclude>
-  </ItemGroup>
-  <ItemGroup>
-    <Filter Include="map">
-      <UniqueIdentifier>{418ff473-dca6-4c43-bba7-d575536c5791}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="battle">
-      <UniqueIdentifier>{01a5ea57-0094-4f54-94a5-10184cb7518c}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="game">
-      <UniqueIdentifier>{db53f45d-1e4d-4e6b-9bc1-fa0e15f1def2}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="spells">
-      <UniqueIdentifier>{9b00f38e-f370-413e-ad10-644a21be00b4}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="spells\effects">
-      <UniqueIdentifier>{dc596868-45d4-4ee4-8191-34c2f76b47fc}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="spells\targetConditions">
-      <UniqueIdentifier>{ac23eabd-5463-468f-862e-38a0934b866e}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="vcai">
-      <UniqueIdentifier>{f7e35d1b-7e06-4c22-a3a3-6f7d1357e028}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="mock">
-      <UniqueIdentifier>{53399b0b-1a51-43f7-91cc-4fc47dfbad84}</UniqueIdentifier>
-    </Filter>
-  </ItemGroup>
-</Project>
\ No newline at end of file
diff --color -urN vcmi-1.5.7/test/vcai/mock_ResourceManager.cpp vcmi/test/vcai/mock_ResourceManager.cpp
--- vcmi-1.5.7/test/vcai/mock_ResourceManager.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/vcai/mock_ResourceManager.cpp	2024-12-19 15:00:23.006152401 +0100
@@ -11,9 +11,9 @@
 
 #include "mock_ResourceManager.h"
 
-void ResourceManagerMock::reserveResoures(const TResources &res, Goals::TSubgoal goal)
+void ResourceManagerMock::reserveResources(const TResources &res, Goals::TSubgoal goal)
 {
-	ResourceManager::reserveResoures(res, goal);
+	ResourceManager::reserveResources(res, goal);
 }
 
 bool ResourceManagerMock::updateGoal(Goals::TSubgoal goal)
diff --color -urN vcmi-1.5.7/test/vcai/mock_ResourceManager.h vcmi/test/vcai/mock_ResourceManager.h
--- vcmi-1.5.7/test/vcai/mock_ResourceManager.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/vcai/mock_ResourceManager.h	2024-12-19 15:00:23.006152401 +0100
@@ -22,7 +22,7 @@
 public:
 	using ResourceManager::ResourceManager;
 	//access protected members, TODO: consider other architecture?
-	void reserveResoures(const TResources &res, Goals::TSubgoal goal = Goals::TSubgoal()) override;
+	void reserveResources(const TResources &res, Goals::TSubgoal goal = Goals::TSubgoal()) override;
 	bool updateGoal(Goals::TSubgoal goal) override;
 	bool notifyGoalCompleted(Goals::TSubgoal goal) override;
 };
\ No newline at end of file
diff --color -urN vcmi-1.5.7/test/vcai/ResourceManagerTest.cpp vcmi/test/vcai/ResourceManagerTest.cpp
--- vcmi-1.5.7/test/vcai/ResourceManagerTest.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/test/vcai/ResourceManagerTest.cpp	2024-12-19 15:00:23.006152401 +0100
@@ -0,0 +1,253 @@
+/*
+* ResourceManagerTest.cpp, part of VCMI engine
+*
+* Authors: listed in file AUTHORS in main folder
+*
+* License: GNU General Public License v2.0 or later
+* Full text of license available in license.txt file, in main folder
+*
+*/
+
+#include "StdInc.h"
+#include "gtest/gtest.h"
+
+#include "../AI/VCAI/VCAI.h"
+#include "../AI/VCAI/Goals/Goals.h"
+#include "mock_VCAI_CGoal.h"
+#include "mock_VCAI.h"
+#include "mock_ResourceManager.h"
+#include "../mock/mock_CPSICallback.h"
+#include "../lib/CGameInfoCallback.h"
+
+using namespace Goals;
+using namespace ::testing;
+
+struct ResourceManagerTest : public Test//, public IResourceManager
+{
+	std::unique_ptr<ResourceManagerMock> rm;
+
+	NiceMock<CPSICallbackMock> gcm;
+	NiceMock<VCAIMock> aim;
+	TSubgoal invalidGoal, gatherArmy, buildThis, buildAny, recruitHero;
+
+	ResourceManagerTest()
+	{
+		rm = make_unique<NiceMock<ResourceManagerMock>>(&gcm, &aim);
+
+		//note: construct new goal for modifications
+		invalidGoal = sptr(StrictMock<InvalidGoalMock>());
+		gatherArmy = sptr(StrictMock<GatherArmyGoalMock>());
+		buildThis = sptr(StrictMock<BuildThis>());
+		buildAny = sptr(StrictMock<Build>());
+		recruitHero = sptr(StrictMock<RecruitHero>());
+
+		//auto AI = CDynLibHandler::getNewAI("VCAI.dll");
+		//SET_GLOBAL_STATE(AI);
+
+		//gtest couldn't deduce default return value;
+		ON_CALL(gcm, getTownsInfo(_))
+			.WillByDefault(Return(std::vector < const CGTownInstance *>()));
+
+		ON_CALL(gcm, getTownsInfo())
+			.WillByDefault(Return(std::vector < const CGTownInstance *>()));
+
+		ON_CALL(aim, getFlaggedObjects())
+			.WillByDefault(Return(std::vector < const CGObjectInstance *>()));
+
+		//enable if get unexpected exceptions
+		//ON_CALL(gcm, getResourceAmount())
+		//	.WillByDefault(Return(TResources()));
+	}
+};
+
+TEST_F(ResourceManagerTest, canAffordMaths)
+{
+	//mocking cb calls inside canAfford()
+
+	ON_CALL(gcm, getResourceAmount())
+		.WillByDefault(Return(TResources(10, 0, 11, 0, 0, 0, 12345)));
+
+	TResources buildingCost(10, 0, 10, 0, 0, 0, 5000);
+	//EXPECT_CALL(gcm, getResourceAmount()).RetiresOnSaturation();
+	//EXPECT_CALL(gcm, getTownsInfo(_)).RetiresOnSaturation();
+	EXPECT_NO_THROW(rm->canAfford(buildingCost));
+	EXPECT_TRUE(rm->canAfford(buildingCost));
+
+	TResources armyCost(0, 0, 0, 0, 0, 0, 54321);
+	EXPECT_FALSE(rm->canAfford(armyCost));
+
+	rm->reserveResources(armyCost, gatherArmy);
+	EXPECT_FALSE(rm->canAfford(buildingCost)) << "Reserved value should be subtracted from free resources";
+}
+
+TEST_F(ResourceManagerTest, notifyGoalImplemented)
+{
+	ASSERT_FALSE(rm->hasTasksLeft());
+
+	EXPECT_FALSE(rm->notifyGoalCompleted(invalidGoal));
+	EXPECT_FALSE(rm->hasTasksLeft());
+
+	TResources res(0,0,0,0,0,0,12345);
+	rm->reserveResources(res, invalidGoal);
+	ASSERT_FALSE(rm->hasTasksLeft()) << "Can't push Invalid goal";
+	EXPECT_FALSE(rm->notifyGoalCompleted(invalidGoal));
+
+	EXPECT_FALSE(rm->notifyGoalCompleted(gatherArmy)) << "Queue should be empty";
+	rm->reserveResources(res, gatherArmy);
+	EXPECT_TRUE(rm->notifyGoalCompleted(gatherArmy)) << "Not implemented"; //TODO: try it with not a copy
+	EXPECT_FALSE(rm->notifyGoalCompleted(gatherArmy)); //already completed
+}
+
+TEST_F(ResourceManagerTest, notifyFulfillsAll)
+{
+	TResources res;
+	ASSERT_TRUE(buildAny->fulfillsMe(buildThis)) << "Goal dependency implemented incorrectly"; //TODO: goal mock?
+	rm->reserveResources(res, buildAny);
+	rm->reserveResources(res, buildAny);
+	rm->reserveResources(res, buildAny);
+	ASSERT_TRUE(rm->hasTasksLeft()); //regardless if duplicates are allowed or not
+	rm->notifyGoalCompleted(buildThis);
+	ASSERT_FALSE(rm->hasTasksLeft()) << "BuildThis didn't remove Build Any!";
+}
+
+TEST_F(ResourceManagerTest, queueOrder)
+{
+	ASSERT_FALSE(rm->hasTasksLeft());
+
+	TSubgoal buildLow = sptr(StrictMock<BuildThis>());
+	TSubgoal buildBit = sptr(StrictMock<BuildThis>());
+	TSubgoal buildMed = sptr(StrictMock<BuildThis>());
+	TSubgoal buildHigh = sptr(StrictMock<BuildThis>());
+	TSubgoal buildVeryHigh = sptr(StrictMock<BuildThis>());
+	TSubgoal buildExtra = sptr(StrictMock<BuildThis>());
+	TSubgoal buildNotSoExtra = sptr(StrictMock<BuildThis>());
+
+	buildLow->setpriority(0).setbid(1);
+	buildLow->setpriority(1).setbid(2);
+	buildMed->setpriority(2).setbid(3);
+	buildHigh->setpriority(5).setbid(4);
+	buildVeryHigh->setpriority(10).setbid(5);
+
+	TResources price(0, 0, 0, 0, 0, 0, 1000);
+	rm->reserveResources(price, buildLow);
+	rm->reserveResources(price, buildHigh);
+	rm->reserveResources(price, buildMed);
+
+	ON_CALL(gcm, getResourceAmount())
+		.WillByDefault(Return(TResources(0,0,0,0,0,0,4000,0))); //we can afford 4 top goals
+
+	auto goal = rm->whatToDo();
+	EXPECT_EQ(goal->goalType, Goals::BUILD_STRUCTURE);
+	ASSERT_EQ(rm->whatToDo()->bid, 4);
+	rm->reserveResources(price, buildBit);
+	rm->reserveResources(price, buildVeryHigh);
+	goal = rm->whatToDo();
+	EXPECT_EQ(goal->goalType, Goals::BUILD_STRUCTURE);
+	ASSERT_EQ(goal->bid, 5);
+
+	buildExtra->setpriority(3).setbid(100);
+	EXPECT_EQ(rm->whatToDo(price, buildExtra)->bid, 100);
+
+	buildNotSoExtra->setpriority(0.7f).setbid(7);
+	goal = rm->whatToDo(price, buildNotSoExtra);
+	EXPECT_NE(goal->bid, 7);
+	EXPECT_EQ(goal->goalType, Goals::COLLECT_RES) << "We can't afford this goal, need to collect resources";
+	EXPECT_EQ(goal->resID, EGameResID::GOLD) << "We need to collect gold";
+
+	goal = rm->whatToDo();
+	EXPECT_NE(goal->goalType, Goals::COLLECT_RES);
+	EXPECT_EQ(goal->bid, 5) << "Should return highest-priority goal";
+}
+
+TEST_F(ResourceManagerTest, updateGoalImplemented)
+{
+	ASSERT_FALSE(rm->hasTasksLeft());
+
+	TResources res;
+	res[EGameResID::GOLD] = 12345;
+
+	buildThis->setpriority(1);
+	buildThis->bid = 666;
+
+	EXPECT_FALSE(rm->updateGoal(buildThis)); //try update with no objectives -> fail
+
+	rm->reserveResources(res, buildThis);
+	ASSERT_TRUE(rm->hasTasksLeft());
+	buildThis->setpriority(4.444f);
+
+	auto buildThis2 = sptr(StrictMock<BuildThis>());
+	buildThis2->bid = 777;
+	buildThis2->setpriority(3.33f);
+
+	EXPECT_FALSE(rm->updateGoal(buildThis2)) << "Shouldn't update with wrong goal";
+	EXPECT_TRUE(rm->updateGoal(buildThis)) << "Not implemented"; //try update with copy of reserved goal -> true
+
+	EXPECT_FALSE(rm->updateGoal(invalidGoal)) << "Can't update Invalid goal";
+}
+
+TEST_F(ResourceManagerTest, complexGoalUpdates)
+{
+	//TODO
+	ASSERT_FALSE(rm->hasTasksLeft());
+}
+
+TEST_F(ResourceManagerTest, tasksLeft)
+{
+	ASSERT_FALSE(rm->hasTasksLeft());
+}
+
+TEST_F(ResourceManagerTest, reservedResources)
+{
+	//TOOO, not worth it now
+}
+
+TEST_F(ResourceManagerTest, freeResources)
+{
+	ON_CALL(gcm, getResourceAmount()) //in case callback or gs gets crazy
+		.WillByDefault(Return(TResources(-1, 0, -13, -38763, -93764, -464, -12, -98765)));
+
+	auto res = rm->freeResources();
+	ASSERT_GE(res[EGameResID::WOOD], 0);
+	ASSERT_GE(res[EGameResID::MERCURY], 0);
+	ASSERT_GE(res[EGameResID::ORE], 0);
+	ASSERT_GE(res[EGameResID::SULFUR], 0);
+	ASSERT_GE(res[EGameResID::CRYSTAL], 0);
+	ASSERT_GE(res[EGameResID::GEMS], 0);
+	ASSERT_GE(res[EGameResID::GOLD], 0);
+	ASSERT_GE(res[EGameResID::MITHRIL], 0);
+}
+
+TEST_F(ResourceManagerTest, freeResourcesWithManyGoals)
+{
+	ON_CALL(gcm, getResourceAmount())
+		.WillByDefault(Return(TResources(20, 10, 20, 10, 10, 10, 20000, 0)));
+
+	ASSERT_EQ(rm->freeResources(), TResources(20, 10, 20, 10, 10, 10, 20000, 0));
+
+	rm->reserveResources(TResources(0, 4, 0, 0, 0, 0, 13000), gatherArmy);
+	ASSERT_EQ(rm->freeResources(), TResources(20, 6, 20, 10, 10, 10, 7000, 0));
+	rm->reserveResources(TResources(5, 4, 5, 4, 4, 4, 5000), buildThis);
+	ASSERT_EQ(rm->freeResources(), TResources(15, 2, 15, 6, 6, 6, 2000, 0));
+	rm->reserveResources(TResources(0, 0, 0, 0, 0, 0, 2500), recruitHero);
+	auto res = rm->freeResources();
+	EXPECT_EQ(res[EGameResID::GOLD], 0) << "We should have 0 gold left";
+
+	ON_CALL(gcm, getResourceAmount())
+		.WillByDefault(Return(TResources(20, 10, 20, 10, 10, 10, 30000, 0))); //+10000 gold
+
+	res = rm->freeResources();
+	EXPECT_EQ(res[EGameResID::GOLD], 9500) << "We should have extra savings now";
+}
+
+TEST_F(ResourceManagerTest, freeGold)
+{
+	ON_CALL(gcm, getResourceAmount())
+		.WillByDefault(Return(TResources(0, 0, 0, 0, 0, 0, 666)));
+
+	ASSERT_EQ(rm->freeGold(), 666);
+
+	ON_CALL(gcm, getResourceAmount())
+		.WillByDefault(Return(TResources(0, 0, 0, 0, 0, 0, -3762363)));
+
+	ASSERT_GE(rm->freeGold(), 0) << "We should never see negative savings";
+}
diff --color -urN vcmi-1.5.7/test/vcai/ResurceManagerTest.cpp vcmi/test/vcai/ResurceManagerTest.cpp
--- vcmi-1.5.7/test/vcai/ResurceManagerTest.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/test/vcai/ResurceManagerTest.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,253 +0,0 @@
-/*
-* ResourceManagerTest.cpp, part of VCMI engine
-*
-* Authors: listed in file AUTHORS in main folder
-*
-* License: GNU General Public License v2.0 or later
-* Full text of license available in license.txt file, in main folder
-*
-*/
-
-#include "StdInc.h"
-#include "gtest/gtest.h"
-
-#include "../AI/VCAI/VCAI.h"
-#include "../AI/VCAI/Goals/Goals.h"
-#include "mock_VCAI_CGoal.h"
-#include "mock_VCAI.h"
-#include "mock_ResourceManager.h"
-#include "../mock/mock_CPSICallback.h"
-#include "../lib/CGameInfoCallback.h"
-
-using namespace Goals;
-using namespace ::testing;
-
-struct ResourceManagerTest : public Test//, public IResourceManager
-{
-	std::unique_ptr<ResourceManagerMock> rm;
-
-	NiceMock<CPSICallbackMock> gcm;
-	NiceMock<VCAIMock> aim;
-	TSubgoal invalidGoal, gatherArmy, buildThis, buildAny, recruitHero;
-
-	ResourceManagerTest()
-	{
-		rm = make_unique<NiceMock<ResourceManagerMock>>(&gcm, &aim);
-
-		//note: construct new goal for modfications
-		invalidGoal = sptr(StrictMock<InvalidGoalMock>());
-		gatherArmy = sptr(StrictMock<GatherArmyGoalMock>());
-		buildThis = sptr(StrictMock<BuildThis>());
-		buildAny = sptr(StrictMock<Build>());
-		recruitHero = sptr(StrictMock<RecruitHero>());
-
-		//auto AI = CDynLibHandler::getNewAI("VCAI.dll");
-		//SET_GLOBAL_STATE(AI);
-
-		//gtest couldn't deduce default return value;
-		ON_CALL(gcm, getTownsInfo(_))
-			.WillByDefault(Return(std::vector < const CGTownInstance *>()));
-
-		ON_CALL(gcm, getTownsInfo())
-			.WillByDefault(Return(std::vector < const CGTownInstance *>()));
-
-		ON_CALL(aim, getFlaggedObjects())
-			.WillByDefault(Return(std::vector < const CGObjectInstance *>()));
-
-		//enable if get unexpected exceptions
-		//ON_CALL(gcm, getResourceAmount())
-		//	.WillByDefault(Return(TResources()));
-	}
-};
-
-TEST_F(ResourceManagerTest, canAffordMaths)
-{
-	//mocking cb calls inside canAfford()
-
-	ON_CALL(gcm, getResourceAmount())
-		.WillByDefault(Return(TResources(10, 0, 11, 0, 0, 0, 12345)));
-
-	TResources buildingCost(10, 0, 10, 0, 0, 0, 5000);
-	//EXPECT_CALL(gcm, getResourceAmount()).RetiresOnSaturation();
-	//EXPECT_CALL(gcm, getTownsInfo(_)).RetiresOnSaturation();
-	EXPECT_NO_THROW(rm->canAfford(buildingCost));
-	EXPECT_TRUE(rm->canAfford(buildingCost));
-
-	TResources armyCost(0, 0, 0, 0, 0, 0, 54321);
-	EXPECT_FALSE(rm->canAfford(armyCost));
-
-	rm->reserveResoures(armyCost, gatherArmy);
-	EXPECT_FALSE(rm->canAfford(buildingCost)) << "Reserved value should be substracted from free resources";
-}
-
-TEST_F(ResourceManagerTest, notifyGoalImplemented)
-{
-	ASSERT_FALSE(rm->hasTasksLeft());
-
-	EXPECT_FALSE(rm->notifyGoalCompleted(invalidGoal));
-	EXPECT_FALSE(rm->hasTasksLeft());
-
-	TResources res(0,0,0,0,0,0,12345);
-	rm->reserveResoures(res, invalidGoal);
-	ASSERT_FALSE(rm->hasTasksLeft()) << "Can't push Invalid goal";
-	EXPECT_FALSE(rm->notifyGoalCompleted(invalidGoal));
-
-	EXPECT_FALSE(rm->notifyGoalCompleted(gatherArmy)) << "Queue should be empty";
-	rm->reserveResoures(res, gatherArmy);
-	EXPECT_TRUE(rm->notifyGoalCompleted(gatherArmy)) << "Not implemented"; //TODO: try it with not a copy
-	EXPECT_FALSE(rm->notifyGoalCompleted(gatherArmy)); //already completed
-}
-
-TEST_F(ResourceManagerTest, notifyFulfillsAll)
-{
-	TResources res;
-	ASSERT_TRUE(buildAny->fulfillsMe(buildThis)) << "Goal dependency implemented incorrectly"; //TODO: goal mock?
-	rm->reserveResoures(res, buildAny);
-	rm->reserveResoures(res, buildAny);
-	rm->reserveResoures(res, buildAny);
-	ASSERT_TRUE(rm->hasTasksLeft()); //regardless if duplicates are allowed or not
-	rm->notifyGoalCompleted(buildThis);
-	ASSERT_FALSE(rm->hasTasksLeft()) << "BuildThis didn't remove Build Any!";
-}
-
-TEST_F(ResourceManagerTest, queueOrder)
-{
-	ASSERT_FALSE(rm->hasTasksLeft());
-
-	TSubgoal buildLow = sptr(StrictMock<BuildThis>());
-	TSubgoal buildBit = sptr(StrictMock<BuildThis>());
-	TSubgoal buildMed = sptr(StrictMock<BuildThis>());
-	TSubgoal buildHigh = sptr(StrictMock<BuildThis>());
-	TSubgoal buildVeryHigh = sptr(StrictMock<BuildThis>());
-	TSubgoal buildExtra = sptr(StrictMock<BuildThis>());
-	TSubgoal buildNotSoExtra = sptr(StrictMock<BuildThis>());
-
-	buildLow->setpriority(0).setbid(1);
-	buildLow->setpriority(1).setbid(2);
-	buildMed->setpriority(2).setbid(3);
-	buildHigh->setpriority(5).setbid(4);
-	buildVeryHigh->setpriority(10).setbid(5);
-
-	TResources price(0, 0, 0, 0, 0, 0, 1000);
-	rm->reserveResoures(price, buildLow);
-	rm->reserveResoures(price, buildHigh);
-	rm->reserveResoures(price, buildMed);
-
-	ON_CALL(gcm, getResourceAmount())
-		.WillByDefault(Return(TResources(0,0,0,0,0,0,4000,0))); //we can afford 4 top goals
-
-	auto goal = rm->whatToDo();
-	EXPECT_EQ(goal->goalType, Goals::BUILD_STRUCTURE);
-	ASSERT_EQ(rm->whatToDo()->bid, 4);
-	rm->reserveResoures(price, buildBit);
-	rm->reserveResoures(price, buildVeryHigh);
-	goal = rm->whatToDo();
-	EXPECT_EQ(goal->goalType, Goals::BUILD_STRUCTURE);
-	ASSERT_EQ(goal->bid, 5);
-
-	buildExtra->setpriority(3).setbid(100);
-	EXPECT_EQ(rm->whatToDo(price, buildExtra)->bid, 100);
-
-	buildNotSoExtra->setpriority(0.7f).setbid(7);
-	goal = rm->whatToDo(price, buildNotSoExtra);
-	EXPECT_NE(goal->bid, 7);
-	EXPECT_EQ(goal->goalType, Goals::COLLECT_RES) << "We can't afford this goal, need to collect resources";
-	EXPECT_EQ(goal->resID, EGameResID::GOLD) << "We need to collect gold";
-
-	goal = rm->whatToDo();
-	EXPECT_NE(goal->goalType, Goals::COLLECT_RES);
-	EXPECT_EQ(goal->bid, 5) << "Should return highest-priority goal";
-}
-
-TEST_F(ResourceManagerTest, updateGoalImplemented)
-{
-	ASSERT_FALSE(rm->hasTasksLeft());
-
-	TResources res;
-	res[EGameResID::GOLD] = 12345;
-
-	buildThis->setpriority(1);
-	buildThis->bid = 666;
-
-	EXPECT_FALSE(rm->updateGoal(buildThis)); //try update with no objectives -> fail
-
-	rm->reserveResoures(res, buildThis);
-	ASSERT_TRUE(rm->hasTasksLeft());
-	buildThis->setpriority(4.444f);
-
-	auto buildThis2 = sptr(StrictMock<BuildThis>());
-	buildThis2->bid = 777;
-	buildThis2->setpriority(3.33f);
-
-	EXPECT_FALSE(rm->updateGoal(buildThis2)) << "Shouldn't update with wrong goal";
-	EXPECT_TRUE(rm->updateGoal(buildThis)) << "Not implemented"; //try update with copy of reserved goal -> true
-
-	EXPECT_FALSE(rm->updateGoal(invalidGoal)) << "Can't update Invalid goal";
-}
-
-TEST_F(ResourceManagerTest, complexGoalUpdates)
-{
-	//TODO
-	ASSERT_FALSE(rm->hasTasksLeft());
-}
-
-TEST_F(ResourceManagerTest, tasksLeft)
-{
-	ASSERT_FALSE(rm->hasTasksLeft());
-}
-
-TEST_F(ResourceManagerTest, reservedResources)
-{
-	//TOOO, not worth it now
-}
-
-TEST_F(ResourceManagerTest, freeResources)
-{
-	ON_CALL(gcm, getResourceAmount()) //in case callback or gs gets crazy
-		.WillByDefault(Return(TResources(-1, 0, -13, -38763, -93764, -464, -12, -98765)));
-
-	auto res = rm->freeResources();
-	ASSERT_GE(res[EGameResID::WOOD], 0);
-	ASSERT_GE(res[EGameResID::MERCURY], 0);
-	ASSERT_GE(res[EGameResID::ORE], 0);
-	ASSERT_GE(res[EGameResID::SULFUR], 0);
-	ASSERT_GE(res[EGameResID::CRYSTAL], 0);
-	ASSERT_GE(res[EGameResID::GEMS], 0);
-	ASSERT_GE(res[EGameResID::GOLD], 0);
-	ASSERT_GE(res[EGameResID::MITHRIL], 0);
-}
-
-TEST_F(ResourceManagerTest, freeResourcesWithManyGoals)
-{
-	ON_CALL(gcm, getResourceAmount())
-		.WillByDefault(Return(TResources(20, 10, 20, 10, 10, 10, 20000, 0)));
-
-	ASSERT_EQ(rm->freeResources(), TResources(20, 10, 20, 10, 10, 10, 20000, 0));
-
-	rm->reserveResoures(TResources(0, 4, 0, 0, 0, 0, 13000), gatherArmy);
-	ASSERT_EQ(rm->freeResources(), TResources(20, 6, 20, 10, 10, 10, 7000, 0));
-	rm->reserveResoures(TResources(5, 4, 5, 4, 4, 4, 5000), buildThis);
-	ASSERT_EQ(rm->freeResources(), TResources(15, 2, 15, 6, 6, 6, 2000, 0));
-	rm->reserveResoures(TResources(0, 0, 0, 0, 0, 0, 2500), recruitHero);
-	auto res = rm->freeResources();
-	EXPECT_EQ(res[EGameResID::GOLD], 0) << "We should have 0 gold left";
-
-	ON_CALL(gcm, getResourceAmount())
-		.WillByDefault(Return(TResources(20, 10, 20, 10, 10, 10, 30000, 0))); //+10000 gold
-
-	res = rm->freeResources();
-	EXPECT_EQ(res[EGameResID::GOLD], 9500) << "We should have extra savings now";
-}
-
-TEST_F(ResourceManagerTest, freeGold)
-{
-	ON_CALL(gcm, getResourceAmount())
-		.WillByDefault(Return(TResources(0, 0, 0, 0, 0, 0, 666)));
-
-	ASSERT_EQ(rm->freeGold(), 666);
-
-	ON_CALL(gcm, getResourceAmount())
-		.WillByDefault(Return(TResources(0, 0, 0, 0, 0, 0, -3762363)));
-
-	ASSERT_GE(rm->freeGold(), 0) << "We should never see negative savings";
-}
