diff --color -urN vcmi-1.5.7/lib/ArtifactUtils.cpp vcmi/lib/ArtifactUtils.cpp
--- vcmi-1.5.7/lib/ArtifactUtils.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/ArtifactUtils.cpp	2024-12-19 15:00:22.818144632 +0100
@@ -11,23 +11,54 @@
 #include "ArtifactUtils.h"
 
 #include "CArtHandler.h"
-#include "GameSettings.h"
+#include "IGameSettings.h"
 #include "spells/CSpellHandler.h"
 
-#include "mapping/CMap.h"
 #include "mapObjects/CGHeroInstance.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
+DLL_LINKAGE bool ArtifactUtils::checkIfSlotValid(const CArtifactSet & artSet, const ArtifactPosition & slot)
+{
+	if(artSet.bearerType() == ArtBearer::HERO)
+	{
+		if(isSlotEquipment(slot) || isSlotBackpack(slot) || slot == ArtifactPosition::TRANSITION_POS)
+			return true;
+	}
+	else if(artSet.bearerType() == ArtBearer::ALTAR)
+	{
+		if(isSlotBackpack(slot))
+			return true;
+	}
+	else if(artSet.bearerType() == ArtBearer::COMMANDER)
+	{
+		if(vstd::contains(commanderSlots(), slot))
+			return true;
+	}
+	else if(artSet.bearerType() == ArtBearer::CREATURE)
+	{
+		if(slot == ArtifactPosition::CREATURE_SLOT)
+			return true;
+	}
+	return false;
+}
+
 DLL_LINKAGE ArtifactPosition ArtifactUtils::getArtAnyPosition(const CArtifactSet * target, const ArtifactID & aid)
 {
+	if(auto targetSlot = getArtEquippedPosition(target, aid); targetSlot != ArtifactPosition::PRE_FIRST)
+		return targetSlot;
+	return getArtBackpackPosition(target, aid);
+}
+
+DLL_LINKAGE ArtifactPosition ArtifactUtils::getArtEquippedPosition(const CArtifactSet * target, const ArtifactID & aid)
+{
 	const auto * art = aid.toArtifact();
 	for(const auto & slot : art->getPossibleSlots().at(target->bearerType()))
 	{
 		if(art->canBePutAt(target, slot))
 			return slot;
 	}
-	return getArtBackpackPosition(target, aid);
+	return ArtifactPosition::PRE_FIRST;
 }
 
 DLL_LINKAGE ArtifactPosition ArtifactUtils::getArtBackpackPosition(const CArtifactSet * target, const ArtifactID & aid)
@@ -153,7 +184,7 @@
 {
 	if(target->bearerType() == ArtBearer::HERO)
 	{
-		const auto backpackCap = VLC->settings()->getInteger(EGameSettings::HEROES_BACKPACK_CAP);
+		const auto backpackCap = VLC->engineSettings()->getInteger(EGameSettings::HEROES_BACKPACK_CAP);
 		if(backpackCap < 0)
 			return true;
 		else
@@ -164,93 +195,75 @@
 }
 
 DLL_LINKAGE std::vector<const CArtifact*> ArtifactUtils::assemblyPossibilities(
-	const CArtifactSet * artSet, const ArtifactID & aid)
+	const CArtifactSet * artSet, const ArtifactID & aid, const bool onlyEquiped)
 {
 	std::vector<const CArtifact*> arts;
 	const auto * art = aid.toArtifact();
 	if(art->isCombined())
 		return arts;
 
-	for(const auto artifact : art->getPartOf())
+	for(const auto combinedArt : art->getPartOf())
 	{
-		assert(artifact->isCombined());
+		assert(combinedArt->isCombined());
 		bool possible = true;
-
-		for(const auto constituent : artifact->getConstituents()) //check if all constituents are available
+		CArtifactFittingSet fittingSet(*artSet);
+		for(const auto part : combinedArt->getConstituents()) // check if all constituents are available
 		{
-			if(!artSet->hasArt(constituent->getId(), false, false, false))
+			const auto slot = fittingSet.getArtPos(part->getId(), onlyEquiped, false);
+			if(slot == ArtifactPosition::PRE_FIRST)
 			{
 				possible = false;
 				break;
 			}
+			fittingSet.lockSlot(slot);
 		}
 		if(possible)
-			arts.push_back(artifact);
+			arts.push_back(combinedArt);
 	}
 	return arts;
 }
 
-DLL_LINKAGE CArtifactInstance * ArtifactUtils::createScroll(const SpellID & sid)
+DLL_LINKAGE CArtifactInstance * ArtifactUtils::createScroll(const SpellID & spellId)
 {
-	auto ret = new CArtifactInstance(ArtifactID(ArtifactID::SPELL_SCROLL).toArtifact());
-	auto bonus = std::make_shared<Bonus>(BonusDuration::PERMANENT, BonusType::SPELL,
-		BonusSource::ARTIFACT_INSTANCE, -1, BonusSourceID(ArtifactID(ArtifactID::SPELL_SCROLL)), BonusSubtypeID(sid));
-	ret->addNewBonus(bonus);
-	return ret;
+	return ArtifactUtils::createArtifact(ArtifactID::SPELL_SCROLL, spellId);
 }
 
-DLL_LINKAGE CArtifactInstance * ArtifactUtils::createNewArtifactInstance(const CArtifact * art)
+DLL_LINKAGE CArtifactInstance * ArtifactUtils::createArtifact(const ArtifactID & artId, const SpellID & spellId)
 {
-	assert(art);
-
-	auto * artInst = new CArtifactInstance(art);
-	if(art->isCombined())
+	const std::function<CArtifactInstance*(const CArtifact*)> createArtInst =
+		[&createArtInst, &spellId](const CArtifact * art) -> CArtifactInstance*
 	{
-		for(const auto & part : art->getConstituents())
-			artInst->addPart(ArtifactUtils::createNewArtifactInstance(part), ArtifactPosition::PRE_FIRST);
-	}
-	if(art->isGrowing())
-	{
-		auto bonus = std::make_shared<Bonus>();
-		bonus->type = BonusType::LEVEL_COUNTER;
-		bonus->val = 0;
-		artInst->addNewBonus(bonus);
-	}
-	return artInst;
-}
+		assert(art);
 
-DLL_LINKAGE CArtifactInstance * ArtifactUtils::createNewArtifactInstance(const ArtifactID & aid)
-{
-	return ArtifactUtils::createNewArtifactInstance(aid.toArtifact());
-}
-
-DLL_LINKAGE CArtifactInstance * ArtifactUtils::createArtifact(CMap * map, const ArtifactID & aid, SpellID spellID)
-{
-	CArtifactInstance * art = nullptr;
-	if(aid.getNum() >= 0)
-	{
-		if(spellID == SpellID::NONE)
+		auto * artInst = new CArtifactInstance(art);
+		if(art->isCombined() && !art->isFused())
 		{
-			art = ArtifactUtils::createNewArtifactInstance(aid);
+			for(const auto & part : art->getConstituents())
+				artInst->addPart(createArtInst(part), ArtifactPosition::PRE_FIRST);
 		}
-		else
+		if(art->isGrowing())
 		{
-			art = ArtifactUtils::createScroll(spellID);
+			auto bonus = std::make_shared<Bonus>();
+			bonus->type = BonusType::LEVEL_COUNTER;
+			bonus->val = 0;
+			artInst->addNewBonus(bonus);
 		}
-	}
-	else
+		if(art->isScroll())
+		{
+			artInst->addNewBonus(std::make_shared<Bonus>(BonusDuration::PERMANENT, BonusType::SPELL,
+				BonusSource::ARTIFACT_INSTANCE, -1, BonusSourceID(ArtifactID(ArtifactID::SPELL_SCROLL)), BonusSubtypeID(spellId)));
+		}
+		return artInst;
+	};
+
+	if(artId.getNum() >= 0)
 	{
-		art = new CArtifactInstance(); // random, empty
+		return createArtInst(artId.toArtifact());
 	}
-	map->addNewArtifactInstance(art);
-	if(art->artType && art->isCombined())
+	else
 	{
-		for(auto & part : art->getPartsInfo())
-		{
-			map->addNewArtifactInstance(part.art);
-		}
+		return new CArtifactInstance(); // random, empty
 	}
-	return art;
 }
 
 DLL_LINKAGE void ArtifactUtils::insertScrrollSpellName(std::string & description, const SpellID & sid)
diff --color -urN vcmi-1.5.7/lib/ArtifactUtils.h vcmi/lib/ArtifactUtils.h
--- vcmi-1.5.7/lib/ArtifactUtils.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/ArtifactUtils.h	2024-12-19 15:00:22.819144673 +0100
@@ -21,12 +21,12 @@
 class CArtifactSet;
 class CArtifactInstance;
 struct ArtSlotInfo;
-class CMap;
 
 namespace ArtifactUtils
 {
-	// Calculates where an artifact gets placed when it gets transferred from one hero to another.
+	DLL_LINKAGE bool checkIfSlotValid(const CArtifactSet & artSet, const ArtifactPosition & slot);
 	DLL_LINKAGE ArtifactPosition getArtAnyPosition(const CArtifactSet * target, const ArtifactID & aid);
+	DLL_LINKAGE ArtifactPosition getArtEquippedPosition(const CArtifactSet * target, const ArtifactID & aid);
 	DLL_LINKAGE ArtifactPosition getArtBackpackPosition(const CArtifactSet * target, const ArtifactID & aid);
 	// TODO: Make this constexpr when the toolset is upgraded
 	DLL_LINKAGE const std::vector<ArtifactPosition> & unmovableSlots();
@@ -38,11 +38,9 @@
 	DLL_LINKAGE bool isSlotBackpack(const ArtifactPosition & slot);
 	DLL_LINKAGE bool isSlotEquipment(const ArtifactPosition & slot);
 	DLL_LINKAGE bool isBackpackFreeSlots(const CArtifactSet * target, const size_t reqSlots = 1);
-	DLL_LINKAGE std::vector<const CArtifact*> assemblyPossibilities(const CArtifactSet * artSet, const ArtifactID & aid);
-	DLL_LINKAGE CArtifactInstance * createScroll(const SpellID & sid);
-	DLL_LINKAGE CArtifactInstance * createNewArtifactInstance(const CArtifact * art);
-	DLL_LINKAGE CArtifactInstance * createNewArtifactInstance(const ArtifactID & aid);
-	DLL_LINKAGE CArtifactInstance * createArtifact(CMap * map, const ArtifactID & aid, SpellID spellID = SpellID::NONE);
+	DLL_LINKAGE std::vector<const CArtifact*> assemblyPossibilities(const CArtifactSet * artSet, const ArtifactID & aid, const bool onlyEquiped = false);
+	DLL_LINKAGE CArtifactInstance * createScroll(const SpellID & spellId);
+	DLL_LINKAGE CArtifactInstance * createArtifact(const ArtifactID & artId, const SpellID & spellId = SpellID::NONE);
 	DLL_LINKAGE void insertScrrollSpellName(std::string & description, const SpellID & sid);
 }
 
diff --color -urN vcmi-1.5.7/lib/BasicTypes.cpp vcmi/lib/BasicTypes.cpp
--- vcmi-1.5.7/lib/BasicTypes.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/BasicTypes.cpp	2024-12-19 15:00:22.819144673 +0100
@@ -12,7 +12,7 @@
 
 #include "VCMI_Lib.h"
 #include "GameConstants.h"
-#include "GameSettings.h"
+#include "IGameSettings.h"
 #include "bonuses/BonusList.h"
 #include "bonuses/Bonus.h"
 #include "bonuses/IBonusBearer.h"
@@ -38,7 +38,7 @@
 	//this code is used in the CreatureTerrainLimiter::limit to setup battle bonuses
 	//and in the CGHeroInstance::getNativeTerrain() to setup movement bonuses or/and penalties.
 	return getBonusBearer()->hasBonus(selectorNoTerrainPenalty, cachingStringNoTerrainPenalty)
-		? TerrainId::ANY_TERRAIN : VLC->factions()->getById(getFaction())->getNativeTerrain();
+			 ? TerrainId::ANY_TERRAIN : getFactionID().toEntity(VLC)->getNativeTerrain();
 }
 
 int32_t AFactionMember::magicResistance() const
@@ -86,14 +86,14 @@
 	static const std::string keyAllSkills = "type_PRIMARY_SKILL";
 	auto allSkills = getBonusBearer()->getBonuses(selectorAllSkills, keyAllSkills);
 	auto ret = allSkills->valOfBonuses(Selector::subtype()(BonusSubtypeID(id)));
-	auto minSkillValue = (id == PrimarySkill::SPELL_POWER || id == PrimarySkill::KNOWLEDGE) ? 1 : 0;
+	auto minSkillValue = VLC->engineSettings()->getVector(EGameSettings::HEROES_MINIMAL_PRIMARY_SKILLS)[id.getNum()];
 	return std::max(ret, minSkillValue); //otherwise, some artifacts may cause negative skill value effect, sp=0 works in old saves
 }
 
 int AFactionMember::moraleValAndBonusList(TConstBonusListPtr & bonusList) const
 {
-	int32_t maxGoodMorale = VLC->settings()->getVector(EGameSettings::COMBAT_GOOD_MORALE_DICE).size();
-	int32_t maxBadMorale = - (int32_t) VLC->settings()->getVector(EGameSettings::COMBAT_BAD_MORALE_DICE).size();
+	int32_t maxGoodMorale = VLC->engineSettings()->getVector(EGameSettings::COMBAT_GOOD_MORALE_DICE).size();
+	int32_t maxBadMorale = - (int32_t) VLC->engineSettings()->getVector(EGameSettings::COMBAT_BAD_MORALE_DICE).size();
 
 	if(getBonusBearer()->hasBonusOfType(BonusType::MAX_MORALE))
 	{
@@ -102,7 +102,7 @@
 		return maxGoodMorale;
 	}
 
-	static const auto unaffectedByMoraleSelector = Selector::type()(BonusType::NON_LIVING).Or(Selector::type()(BonusType::UNDEAD))
+	static const auto unaffectedByMoraleSelector = Selector::type()(BonusType::NON_LIVING).Or(Selector::type()(BonusType::MECHANICAL)).Or(Selector::type()(BonusType::UNDEAD))
 													.Or(Selector::type()(BonusType::SIEGE_WEAPON)).Or(Selector::type()(BonusType::NO_MORALE));
 
 	static const std::string cachingStrUn = "AFactionMember::unaffectedByMoraleSelector";
@@ -123,8 +123,8 @@
 
 int AFactionMember::luckValAndBonusList(TConstBonusListPtr & bonusList) const
 {
-	int32_t maxGoodLuck = VLC->settings()->getVector(EGameSettings::COMBAT_GOOD_LUCK_DICE).size();
-	int32_t maxBadLuck = - (int32_t) VLC->settings()->getVector(EGameSettings::COMBAT_BAD_LUCK_DICE).size();
+	int32_t maxGoodLuck = VLC->engineSettings()->getVector(EGameSettings::COMBAT_GOOD_LUCK_DICE).size();
+	int32_t maxBadLuck = - (int32_t) VLC->engineSettings()->getVector(EGameSettings::COMBAT_BAD_LUCK_DICE).size();
 
 	if(getBonusBearer()->hasBonusOfType(BonusType::MAX_LUCK))
 	{
@@ -187,6 +187,7 @@
 	static const std::string cachingStr = "ACreature::isLiving";
 	static const CSelector selector = Selector::type()(BonusType::UNDEAD)
 		.Or(Selector::type()(BonusType::NON_LIVING))
+		.Or(Selector::type()(BonusType::MECHANICAL))
 		.Or(Selector::type()(BonusType::GARGOYLE))
 		.Or(Selector::type()(BonusType::SIEGE_WEAPON));
 
diff --color -urN vcmi-1.5.7/lib/battle/AccessibilityInfo.cpp vcmi/lib/battle/AccessibilityInfo.cpp
--- vcmi-1.5.7/lib/battle/AccessibilityInfo.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/battle/AccessibilityInfo.cpp	2024-12-19 15:00:22.878147111 +0100
@@ -15,12 +15,22 @@
 
 VCMI_LIB_NAMESPACE_BEGIN
 
-bool AccessibilityInfo::tileAccessibleWithGate(BattleHex tile, ui8 side) const
+bool AccessibilityInfo::tileAccessibleWithGate(BattleHex tile, BattleSide side) const
 {
 	//at(otherHex) != EAccessibility::ACCESSIBLE && (at(otherHex) != EAccessibility::GATE || side != BattleSide::DEFENDER)
-	if(at(tile) != EAccessibility::ACCESSIBLE)
-		if(at(tile) != EAccessibility::GATE || side != BattleSide::DEFENDER)
+	auto accessibility = at(tile);
+
+	if(accessibility == EAccessibility::ALIVE_STACK)
+	{
+		auto destructible = destructibleEnemyTurns.find(tile);
+
+		return destructible != destructibleEnemyTurns.end();
+	}
+
+	if(accessibility != EAccessibility::ACCESSIBLE)
+		if(accessibility != EAccessibility::GATE || side != BattleSide::DEFENDER)
 			return false;
+
 	return true;
 }
 
@@ -29,7 +39,7 @@
 	return accessible(tile, stack->doubleWide(), stack->unitSide());
 }
 
-bool AccessibilityInfo::accessible(BattleHex tile, bool doubleWide, ui8 side) const
+bool AccessibilityInfo::accessible(BattleHex tile, bool doubleWide, BattleSide side) const
 {
 	// All hexes that stack would cover if standing on tile have to be accessible.
 	//do not use getHexes for speed reasons
diff --color -urN vcmi-1.5.7/lib/battle/AccessibilityInfo.h vcmi/lib/battle/AccessibilityInfo.h
--- vcmi-1.5.7/lib/battle/AccessibilityInfo.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/battle/AccessibilityInfo.h	2024-12-19 15:00:22.879147152 +0100
@@ -35,11 +35,13 @@
 
 struct DLL_LINKAGE AccessibilityInfo : TAccessibilityArray
 {
+	std::map<BattleHex, ui8> destructibleEnemyTurns;
+
 	public:
 		bool accessible(BattleHex tile, const battle::Unit * stack) const; //checks for both tiles if stack is double wide
-		bool accessible(BattleHex tile, bool doubleWide, ui8 side) const; //checks for both tiles if stack is double wide
+		bool accessible(BattleHex tile, bool doubleWide, BattleSide side) const; //checks for both tiles if stack is double wide
 	private:
-		bool tileAccessibleWithGate(BattleHex tile, ui8 side) const;
+		bool tileAccessibleWithGate(BattleHex tile, BattleSide side) const;
 };
 
 VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/battle/BattleAction.cpp vcmi/lib/battle/BattleAction.cpp
--- vcmi-1.5.7/lib/battle/BattleAction.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/battle/BattleAction.cpp	2024-12-19 15:00:22.880147194 +0100
@@ -18,7 +18,7 @@
 static const int32_t INVALID_UNIT_ID = -1000;
 
 BattleAction::BattleAction():
-	side(-1),
+	side(BattleSide::NONE),
 	stackNumber(-1),
 	actionType(EActionType::NO_ACTION)
 {
@@ -96,7 +96,7 @@
 	return ba;
 }
 
-BattleAction BattleAction::makeEndOFTacticPhase(ui8 side)
+BattleAction BattleAction::makeEndOFTacticPhase(BattleSide side)
 {
 	BattleAction ba;
 	ba.side = side;
@@ -104,7 +104,7 @@
 	return ba;
 }
 
-BattleAction BattleAction::makeSurrender(ui8 side)
+BattleAction BattleAction::makeSurrender(BattleSide side)
 {
 	BattleAction ba;
 	ba.side = side;
@@ -112,7 +112,7 @@
 	return ba;
 }
 
-BattleAction BattleAction::makeRetreat(ui8 side)
+BattleAction BattleAction::makeRetreat(BattleSide side)
 {
 	BattleAction ba;
 	ba.side = side;
diff --color -urN vcmi-1.5.7/lib/battle/BattleAction.h vcmi/lib/battle/BattleAction.h
--- vcmi-1.5.7/lib/battle/BattleAction.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/battle/BattleAction.h	2024-12-19 15:00:22.881147235 +0100
@@ -24,7 +24,7 @@
 class DLL_LINKAGE BattleAction
 {
 public:
-	ui8 side; //who made this action
+	BattleSide side; //who made this action
 	ui32 stackNumber; //stack ID, -1 left hero, -2 right hero,
 	EActionType actionType; //use ActionType enum for values
 
@@ -39,9 +39,9 @@
 	static BattleAction makeShotAttack(const battle::Unit * shooter, const battle::Unit * target);
 	static BattleAction makeCreatureSpellcast(const battle::Unit * stack, const battle::Target & target, const SpellID & spellID);
 	static BattleAction makeMove(const battle::Unit * stack, BattleHex dest);
-	static BattleAction makeEndOFTacticPhase(ui8 side);
-	static BattleAction makeRetreat(ui8 side);
-	static BattleAction makeSurrender(ui8 side);
+	static BattleAction makeEndOFTacticPhase(BattleSide side);
+	static BattleAction makeRetreat(BattleSide side);
+	static BattleAction makeSurrender(BattleSide side);
 
 	bool isTacticsAction() const;
 	bool isUnitAction() const;
diff --color -urN vcmi-1.5.7/lib/battle/BattleHex.cpp vcmi/lib/battle/BattleHex.cpp
--- vcmi-1.5.7/lib/battle/BattleHex.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/battle/BattleHex.cpp	2024-12-19 15:00:22.882147276 +0100
@@ -184,7 +184,7 @@
 		ret.push_back(tile);
 }
 
-BattleHex BattleHex::getClosestTile(ui8 side, BattleHex initialPos, std::set<BattleHex> & possibilities)
+BattleHex BattleHex::getClosestTile(BattleSide side, BattleHex initialPos, std::set<BattleHex> & possibilities)
 {
 	std::vector<BattleHex> sortedTiles (possibilities.begin(), possibilities.end()); //set can't be sorted properly :(
 	BattleHex initialHex = BattleHex(initialPos);
diff --color -urN vcmi-1.5.7/lib/battle/BattleHex.h vcmi/lib/battle/BattleHex.h
--- vcmi-1.5.7/lib/battle/BattleHex.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/battle/BattleHex.h	2024-12-19 15:00:22.883147318 +0100
@@ -9,19 +9,12 @@
  */
 #pragma once
 
+#include "BattleSide.h"
+
 VCMI_LIB_NAMESPACE_BEGIN
 
 //TODO: change to enum class
 
-namespace BattleSide
-{
-	enum Type
-	{
-		ATTACKER = 0,
-		DEFENDER = 1
-	};
-}
-
 namespace GameConstants
 {
 	const int BFIELD_WIDTH = 17;
@@ -29,8 +22,6 @@
 	const int BFIELD_SIZE = BFIELD_WIDTH * BFIELD_HEIGHT;
 }
 
-using BattleSideOpt = std::optional<ui8>;
-
 // for battle stacks' positions
 struct DLL_LINKAGE BattleHex //TODO: decide if this should be changed to class for better code design
 {
@@ -102,7 +93,7 @@
 	static EDir mutualPosition(BattleHex hex1, BattleHex hex2);
 	static uint8_t getDistance(BattleHex hex1, BattleHex hex2);
 	static void checkAndPush(BattleHex tile, std::vector<BattleHex> & ret);
-	static BattleHex getClosestTile(ui8 side, BattleHex initialPos, std::set<BattleHex> & possibilities); //TODO: vector or set? copying one to another is bad
+	static BattleHex getClosestTile(BattleSide side, BattleHex initialPos, std::set<BattleHex> & possibilities); //TODO: vector or set? copying one to another is bad
 
 	template <typename Handler>
 	void serialize(Handler &h)
diff --color -urN vcmi-1.5.7/lib/battle/BattleInfo.cpp vcmi/lib/battle/BattleInfo.cpp
--- vcmi-1.5.7/lib/battle/BattleInfo.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/battle/BattleInfo.cpp	2024-12-19 15:00:22.884147359 +0100
@@ -9,39 +9,51 @@
  */
 #include "StdInc.h"
 #include "BattleInfo.h"
+
+#include "BattleLayout.h"
 #include "CObstacleInstance.h"
 #include "bonuses/Limiters.h"
 #include "bonuses/Updaters.h"
-#include "../CRandomGenerator.h"
 #include "../CStack.h"
-#include "../CHeroHandler.h"
+#include "../entities/building/TownFortifications.h"
 #include "../filesystem/Filesystem.h"
 #include "../mapObjects/CGTownInstance.h"
-#include "../CGeneralTextHandler.h"
+#include "../texts/CGeneralTextHandler.h"
 #include "../BattleFieldHandler.h"
 #include "../ObstacleHandler.h"
 
+#include <vstd/RNG.h>
 
 //TODO: remove
 #include "../IGameCallback.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
+const SideInBattle & BattleInfo::getSide(BattleSide side) const
+{
+	return sides.at(side);
+}
+
+SideInBattle & BattleInfo::getSide(BattleSide side)
+{
+	return sides.at(side);
+}
+
 ///BattleInfo
-CStack * BattleInfo::generateNewStack(uint32_t id, const CStackInstance & base, ui8 side, const SlotID & slot, BattleHex position)
+CStack * BattleInfo::generateNewStack(uint32_t id, const CStackInstance & base, BattleSide side, const SlotID & slot, BattleHex position)
 {
-	PlayerColor owner = sides[side].color;
+	PlayerColor owner = getSide(side).color;
 	assert(!owner.isValidPlayer() || (base.armyObj && base.armyObj->tempOwner == owner));
 
 	auto * ret = new CStack(&base, owner, id, side, slot);
-	ret->initialPosition = getAvaliableHex(base.getCreatureID(), side, position); //TODO: what if no free tile on battlefield was found?
+	ret->initialPosition = getAvailableHex(base.getCreatureID(), side, position); //TODO: what if no free tile on battlefield was found?
 	stacks.push_back(ret);
 	return ret;
 }
 
-CStack * BattleInfo::generateNewStack(uint32_t id, const CStackBasicDescriptor & base, ui8 side, const SlotID & slot, BattleHex position)
+CStack * BattleInfo::generateNewStack(uint32_t id, const CStackBasicDescriptor & base, BattleSide side, const SlotID & slot, BattleHex position)
 {
-	PlayerColor owner = sides[side].color;
+	PlayerColor owner = getSide(side).color;
 	auto * ret = new CStack(&base, owner, id, side, slot);
 	ret->initialPosition = position;
 	stacks.push_back(ret);
@@ -50,7 +62,7 @@
 
 void BattleInfo::localInit()
 {
-	for(int i = 0; i < 2; i++)
+	for(BattleSide i : { BattleSide::ATTACKER, BattleSide::DEFENDER})
 	{
 		auto * armyObj = battleGetArmyObject(i);
 		armyObj->battle = this;
@@ -63,22 +75,6 @@
 	exportBonuses();
 }
 
-namespace CGH
-{
-	static void readBattlePositions(const JsonNode &node, std::vector< std::vector<int> > & dest)
-	{
-		for(const JsonNode &level : node.Vector())
-		{
-			std::vector<int> pom;
-			for(const JsonNode &value : level.Vector())
-			{
-				pom.push_back(static_cast<int>(value.Float()));
-			}
-
-			dest.push_back(pom);
-		}
-	}
-}
 
 //RNG that works like H3 one
 struct RandGen
@@ -162,62 +158,48 @@
 	std::function<int()> myRand;
 };
 
-BattleInfo * BattleInfo::setupBattle(const int3 & tile, TerrainId terrain, const BattleField & battlefieldType, const CArmedInstance * armies[2], const CGHeroInstance * heroes[2], bool creatureBank, const CGTownInstance * town)
+BattleInfo * BattleInfo::setupBattle(const int3 & tile, TerrainId terrain, const BattleField & battlefieldType, BattleSideArray<const CArmedInstance *> armies, BattleSideArray<const CGHeroInstance *> heroes, const BattleLayout & layout, const CGTownInstance * town)
 {
 	CMP_stack cmpst;
-	auto * curB = new BattleInfo();
+	auto * currentBattle = new BattleInfo(layout);
 
-	for(auto i = 0u; i < curB->sides.size(); i++)
-		curB->sides[i].init(heroes[i], armies[i]);
+	for(auto i : { BattleSide::LEFT_SIDE, BattleSide::RIGHT_SIDE})
+		currentBattle->sides[i].init(heroes[i], armies[i]);
 
+	std::vector<CStack*> & stacks = (currentBattle->stacks);
 
-	std::vector<CStack*> & stacks = (curB->stacks);
-
-	curB->tile = tile;
-	curB->battlefieldType = battlefieldType;
-	curB->round = -2;
-	curB->activeStack = -1;
-	curB->creatureBank = creatureBank;
-	curB->replayAllowed = false;
-
-	if(town)
-	{
-		curB->town = town;
-		curB->terrainType = town->getNativeTerrain();
-	}
-	else
-	{
-		curB->town = nullptr;
-		curB->terrainType = terrain;
-	}
+	currentBattle->tile = tile;
+	currentBattle->terrainType = terrain;
+	currentBattle->battlefieldType = battlefieldType;
+	currentBattle->round = -2;
+	currentBattle->activeStack = -1;
+	currentBattle->replayAllowed = false;
+	currentBattle->town = town;
 
 	//setting up siege obstacles
-	if (town && town->hasFort())
+	if (town && town->fortificationsLevel().wallsHealth != 0)
 	{
-		curB->si.gateState = EGateState::CLOSED;
+		auto fortification = town->fortificationsLevel();
+
+		currentBattle->si.gateState = EGateState::CLOSED;
 
-		curB->si.wallState[EWallPart::GATE] = EWallState::INTACT;
+		currentBattle->si.wallState[EWallPart::GATE] = EWallState::INTACT;
 
 		for(const auto wall : {EWallPart::BOTTOM_WALL, EWallPart::BELOW_GATE, EWallPart::OVER_GATE, EWallPart::UPPER_WALL})
-		{
-			if (town->hasBuilt(BuildingID::CASTLE))
-				curB->si.wallState[wall] = EWallState::REINFORCED;
-			else
-				curB->si.wallState[wall] = EWallState::INTACT;
-		}
+			currentBattle->si.wallState[wall] = static_cast<EWallState>(fortification.wallsHealth);
 
-		if (town->hasBuilt(BuildingID::CITADEL))
-			curB->si.wallState[EWallPart::KEEP] = EWallState::INTACT;
+		if (fortification.citadelHealth != 0)
+			currentBattle->si.wallState[EWallPart::KEEP] = static_cast<EWallState>(fortification.citadelHealth);
 
-		if (town->hasBuilt(BuildingID::CASTLE))
-		{
-			curB->si.wallState[EWallPart::UPPER_TOWER] = EWallState::INTACT;
-			curB->si.wallState[EWallPart::BOTTOM_TOWER] = EWallState::INTACT;
-		}
+		if (fortification.upperTowerHealth != 0)
+			currentBattle->si.wallState[EWallPart::UPPER_TOWER] = static_cast<EWallState>(fortification.upperTowerHealth);
+
+		if (fortification.lowerTowerHealth != 0)
+			currentBattle->si.wallState[EWallPart::BOTTOM_TOWER] = static_cast<EWallState>(fortification.lowerTowerHealth);
 	}
 
 	//randomize obstacles
- 	if (town == nullptr && !creatureBank) //do it only when it's not siege and not creature bank
+	if (layout.obstaclesAllowed && (!town || !town->hasFort()))
  	{
 		RandGen r{};
 		auto ourRand = [&](){ return r.rand(); };
@@ -230,12 +212,12 @@
 		auto appropriateAbsoluteObstacle = [&](int id)
 		{
 			const auto * info = Obstacle(id).getInfo();
-			return info && info->isAbsoluteObstacle && info->isAppropriate(curB->terrainType, battlefieldType);
+			return info && info->isAbsoluteObstacle && info->isAppropriate(currentBattle->terrainType, battlefieldType);
 		};
 		auto appropriateUsualObstacle = [&](int id)
 		{
 			const auto * info = Obstacle(id).getInfo();
-			return info && !info->isAbsoluteObstacle && info->isAppropriate(curB->terrainType, battlefieldType);
+			return info && !info->isAbsoluteObstacle && info->isAppropriate(currentBattle->terrainType, battlefieldType);
 		};
 
 		if(r.rand(1,100) <= 40) //put cliff-like obstacle
@@ -246,8 +228,8 @@
 				auto obstPtr = std::make_shared<CObstacleInstance>();
 				obstPtr->obstacleType = CObstacleInstance::ABSOLUTE_OBSTACLE;
 				obstPtr->ID = obidgen.getSuchNumber(appropriateAbsoluteObstacle);
-				obstPtr->uniqueID = static_cast<si32>(curB->obstacles.size());
-				curB->obstacles.push_back(obstPtr);
+				obstPtr->uniqueID = static_cast<si32>(currentBattle->obstacles.size());
+				currentBattle->obstacles.push_back(obstPtr);
 
 				for(BattleHex blocked : obstPtr->getBlockedTiles())
 					blockedTiles.push_back(blocked);
@@ -265,7 +247,7 @@
 			while(tilesToBlock > 0)
 			{
 				RangeGenerator obidgen(0, VLC->obstacleHandler->size() - 1, ourRand);
-				auto tileAccessibility = curB->getAccesibility();
+				auto tileAccessibility = currentBattle->getAccessibility();
 				const int obid = obidgen.getSuchNumber(appropriateUsualObstacle);
 				const ObstacleInfo &obi = *Obstacle(obid).getInfo();
 
@@ -299,8 +281,8 @@
 				auto obstPtr = std::make_shared<CObstacleInstance>();
 				obstPtr->ID = obid;
 				obstPtr->pos = posgenerator.getSuchNumber(validPosition);
-				obstPtr->uniqueID = static_cast<si32>(curB->obstacles.size());
-				curB->obstacles.push_back(obstPtr);
+				obstPtr->uniqueID = static_cast<si32>(currentBattle->obstacles.size());
+				currentBattle->obstacles.push_back(obstPtr);
 
 				for(BattleHex blocked : obstPtr->getBlockedTiles())
 					blockedTiles.push_back(blocked);
@@ -313,72 +295,45 @@
 		}
 	}
 
-	//reading battleStartpos - add creatures AFTER random obstacles are generated
-	//TODO: parse once to some structure
-	std::vector<std::vector<int>> looseFormations[2];
-	std::vector<std::vector<int>> tightFormations[2];
-	std::vector<std::vector<int>> creBankFormations[2];
-	std::vector<int> commanderField;
-	std::vector<int> commanderBank;
-	const JsonNode config(JsonPath::builtin("config/battleStartpos.json"));
-	const JsonVector &positions = config["battle_positions"].Vector();
-
-	CGH::readBattlePositions(positions[0]["levels"], looseFormations[0]);
-	CGH::readBattlePositions(positions[1]["levels"], looseFormations[1]);
-	CGH::readBattlePositions(positions[2]["levels"], tightFormations[0]);
-	CGH::readBattlePositions(positions[3]["levels"], tightFormations[1]);
-	CGH::readBattlePositions(positions[4]["levels"], creBankFormations[0]);
-	CGH::readBattlePositions(positions[5]["levels"], creBankFormations[1]);
-
-	for (auto position : config["commanderPositions"]["field"].Vector())
-	{
-		commanderField.push_back(static_cast<int>(position.Float()));
-	}
-	for (auto position : config["commanderPositions"]["creBank"].Vector())
-	{
-		commanderBank.push_back(static_cast<int>(position.Float()));
-	}
-
-
 	//adding war machines
-	if(!creatureBank)
+	//Checks if hero has artifact and create appropriate stack
+	auto handleWarMachine = [&](BattleSide side, const ArtifactPosition & artslot, BattleHex hex)
 	{
-		//Checks if hero has artifact and create appropriate stack
-		auto handleWarMachine = [&](int side, const ArtifactPosition & artslot, BattleHex hex)
+		const CArtifactInstance * warMachineArt = heroes[side]->getArt(artslot);
+
+		if(nullptr != warMachineArt && hex.isValid())
 		{
-			const CArtifactInstance * warMachineArt = heroes[side]->getArt(artslot);
+			CreatureID cre = warMachineArt->getType()->getWarMachine();
 
-			if(nullptr != warMachineArt)
-			{
-				CreatureID cre = warMachineArt->artType->getWarMachine();
+			if(cre != CreatureID::NONE)
+				currentBattle->generateNewStack(currentBattle->nextUnitId(), CStackBasicDescriptor(cre, 1), side, SlotID::WAR_MACHINES_SLOT, hex);
+		}
+	};
 
-				if(cre != CreatureID::NONE)
-					curB->generateNewStack(curB->nextUnitId(), CStackBasicDescriptor(cre, 1), side, SlotID::WAR_MACHINES_SLOT, hex);
-			}
-		};
+	if(heroes[BattleSide::ATTACKER])
+	{
+		auto warMachineHexes = layout.warMachines.at(BattleSide::ATTACKER);
 
-		if(heroes[0])
-		{
+		handleWarMachine(BattleSide::ATTACKER, ArtifactPosition::MACH1, warMachineHexes.at(0));
+		handleWarMachine(BattleSide::ATTACKER, ArtifactPosition::MACH2, warMachineHexes.at(1));
+		handleWarMachine(BattleSide::ATTACKER, ArtifactPosition::MACH3, warMachineHexes.at(2));
+		if(town && town->fortificationsLevel().wallsHealth > 0)
+			handleWarMachine(BattleSide::ATTACKER, ArtifactPosition::MACH4, warMachineHexes.at(3));
+	}
 
-			handleWarMachine(0, ArtifactPosition::MACH1, 52);
-			handleWarMachine(0, ArtifactPosition::MACH2, 18);
-			handleWarMachine(0, ArtifactPosition::MACH3, 154);
-			if(town && town->hasFort())
-				handleWarMachine(0, ArtifactPosition::MACH4, 120);
-		}
+	if(heroes[BattleSide::DEFENDER])
+	{
+		auto warMachineHexes = layout.warMachines.at(BattleSide::DEFENDER);
 
-		if(heroes[1])
-		{
-			if(!town) //defending hero shouldn't receive ballista (bug #551)
-				handleWarMachine(1, ArtifactPosition::MACH1, 66);
-			handleWarMachine(1, ArtifactPosition::MACH2, 32);
-			handleWarMachine(1, ArtifactPosition::MACH3, 168);
-		}
+		if(!town) //defending hero shouldn't receive ballista (bug #551)
+			handleWarMachine(BattleSide::DEFENDER, ArtifactPosition::MACH1, warMachineHexes.at(0));
+		handleWarMachine(BattleSide::DEFENDER, ArtifactPosition::MACH2, warMachineHexes.at(1));
+		handleWarMachine(BattleSide::DEFENDER, ArtifactPosition::MACH3, warMachineHexes.at(2));
 	}
 	//war machines added
 
 	//battleStartpos read
-	for(int side = 0; side < 2; side++)
+	for(BattleSide side : {BattleSide::ATTACKER, BattleSide::DEFENDER})
 	{
 		int formationNo = armies[side]->stacksCount() - 1;
 		vstd::abetween(formationNo, 0, GameConstants::ARMY_SIZE - 1);
@@ -386,45 +341,32 @@
 		int k = 0; //stack serial
 		for(auto i = armies[side]->Slots().begin(); i != armies[side]->Slots().end(); i++, k++)
 		{
-			std::vector<int> *formationVector = nullptr;
-			if(armies[side]->formation == EArmyFormation::TIGHT )
-				formationVector = &tightFormations[side][formationNo];
-			else
-				formationVector = &looseFormations[side][formationNo];
-
-			if(creatureBank)
-				formationVector = &creBankFormations[side][formationNo];
-
-			BattleHex pos = (k < formationVector->size() ? formationVector->at(k) : 0);
-			if(creatureBank && i->second->type->isDoubleWide())
-				pos += side ? BattleHex::LEFT : BattleHex::RIGHT;
+			const BattleHex & pos = layout.units.at(side).at(k);
 
-			curB->generateNewStack(curB->nextUnitId(), *i->second, side, i->first, pos);
+			if (pos.isValid())
+				currentBattle->generateNewStack(currentBattle->nextUnitId(), *i->second, side, i->first, pos);
 		}
 	}
 
 	//adding commanders
-	for (int i = 0; i < 2; ++i)
+	for(BattleSide i : {BattleSide::ATTACKER, BattleSide::DEFENDER})
 	{
 		if (heroes[i] && heroes[i]->commander && heroes[i]->commander->alive)
 		{
-			curB->generateNewStack(curB->nextUnitId(), *heroes[i]->commander, i, SlotID::COMMANDER_SLOT_PLACEHOLDER, creatureBank ? commanderBank[i] : commanderField[i]);
+			currentBattle->generateNewStack(currentBattle->nextUnitId(), *heroes[i]->commander, i, SlotID::COMMANDER_SLOT_PLACEHOLDER, layout.commanders.at(i));
 		}
-
 	}
 
-	if (curB->town && curB->town->fortLevel() >= CGTownInstance::CITADEL)
+	if (currentBattle->town)
 	{
-		// keep tower
-		curB->generateNewStack(curB->nextUnitId(), CStackBasicDescriptor(CreatureID::ARROW_TOWERS, 1), 1, SlotID::ARROW_TOWERS_SLOT, BattleHex::CASTLE_CENTRAL_TOWER);
+		if (currentBattle->town->fortificationsLevel().citadelHealth != 0)
+			currentBattle->generateNewStack(currentBattle->nextUnitId(), CStackBasicDescriptor(CreatureID::ARROW_TOWERS, 1), BattleSide::DEFENDER, SlotID::ARROW_TOWERS_SLOT, BattleHex::CASTLE_CENTRAL_TOWER);
 
-		if (curB->town->fortLevel() >= CGTownInstance::CASTLE)
-		{
-			// lower tower + upper tower
-			curB->generateNewStack(curB->nextUnitId(), CStackBasicDescriptor(CreatureID::ARROW_TOWERS, 1), 1, SlotID::ARROW_TOWERS_SLOT, BattleHex::CASTLE_UPPER_TOWER);
+		if (currentBattle->town->fortificationsLevel().upperTowerHealth != 0)
+			currentBattle->generateNewStack(currentBattle->nextUnitId(), CStackBasicDescriptor(CreatureID::ARROW_TOWERS, 1), BattleSide::DEFENDER, SlotID::ARROW_TOWERS_SLOT, BattleHex::CASTLE_UPPER_TOWER);
 
-			curB->generateNewStack(curB->nextUnitId(), CStackBasicDescriptor(CreatureID::ARROW_TOWERS, 1), 1, SlotID::ARROW_TOWERS_SLOT, BattleHex::CASTLE_BOTTOM_TOWER);
-		}
+		if (currentBattle->town->fortificationsLevel().lowerTowerHealth != 0)
+			currentBattle->generateNewStack(currentBattle->nextUnitId(), CStackBasicDescriptor(CreatureID::ARROW_TOWERS, 1), BattleSide::DEFENDER, SlotID::ARROW_TOWERS_SLOT, BattleHex::CASTLE_BOTTOM_TOWER);
 
 		//Moat generating is done on server
 	}
@@ -439,25 +381,21 @@
 
 	for(const std::shared_ptr<Bonus> & bonus : bgInfo->bonuses)
 	{
-		curB->addNewBonus(bonus);
+		currentBattle->addNewBonus(bonus);
 	}
 
 	//native terrain bonuses
 	auto nativeTerrain = std::make_shared<CreatureTerrainLimiter>();
 	
-	curB->addNewBonus(std::make_shared<Bonus>(BonusDuration::ONE_BATTLE, BonusType::STACKS_SPEED, BonusSource::TERRAIN_NATIVE, 1,  BonusSourceID())->addLimiter(nativeTerrain));
-	curB->addNewBonus(std::make_shared<Bonus>(BonusDuration::ONE_BATTLE, BonusType::PRIMARY_SKILL, BonusSource::TERRAIN_NATIVE, 1, BonusSourceID(), BonusSubtypeID(PrimarySkill::ATTACK))->addLimiter(nativeTerrain));
-	curB->addNewBonus(std::make_shared<Bonus>(BonusDuration::ONE_BATTLE, BonusType::PRIMARY_SKILL, BonusSource::TERRAIN_NATIVE, 1, BonusSourceID(), BonusSubtypeID(PrimarySkill::DEFENSE))->addLimiter(nativeTerrain));
+	currentBattle->addNewBonus(std::make_shared<Bonus>(BonusDuration::ONE_BATTLE, BonusType::STACKS_SPEED, BonusSource::TERRAIN_NATIVE, 1,  BonusSourceID())->addLimiter(nativeTerrain));
+	currentBattle->addNewBonus(std::make_shared<Bonus>(BonusDuration::ONE_BATTLE, BonusType::PRIMARY_SKILL, BonusSource::TERRAIN_NATIVE, 1, BonusSourceID(), BonusSubtypeID(PrimarySkill::ATTACK))->addLimiter(nativeTerrain));
+	currentBattle->addNewBonus(std::make_shared<Bonus>(BonusDuration::ONE_BATTLE, BonusType::PRIMARY_SKILL, BonusSource::TERRAIN_NATIVE, 1, BonusSourceID(), BonusSubtypeID(PrimarySkill::DEFENSE))->addLimiter(nativeTerrain));
 	//////////////////////////////////////////////////////////////////////////
 
 	//tactics
-	bool isTacticsAllowed = !creatureBank; //no tactics in creature banks
-
-	constexpr int sideSize = 2;
-
-	std::array<int, sideSize> battleRepositionHex = {};
-	std::array<int, sideSize> battleRepositionHexBlock = {};
-	for(int i = 0; i < sideSize; i++)
+	BattleSideArray<int> battleRepositionHex = {};
+	BattleSideArray<int> battleRepositionHexBlock = {};
+	for(auto i : {BattleSide::ATTACKER, BattleSide::DEFENDER})
 	{
 		if(heroes[i])
 		{
@@ -475,27 +413,27 @@
 	   double tactics will be implemented.
 	*/
 
-	if(isTacticsAllowed)
+	if(layout.tacticsAllowed)
 	{
 		if(tacticsSkillDiffAttacker > 0 && tacticsSkillDiffDefender > 0)
 			logGlobal->warn("Double tactics is not implemented, only attacker will have tactics!");
 		if(tacticsSkillDiffAttacker > 0)
 		{
-			curB->tacticsSide = BattleSide::ATTACKER;
+			currentBattle->tacticsSide = BattleSide::ATTACKER;
 			//bonus specifies distance you can move beyond base row; this allows 100% compatibility with HMM3 mechanics
-			curB->tacticDistance = 1 + tacticsSkillDiffAttacker;
+			currentBattle->tacticDistance = 1 + tacticsSkillDiffAttacker;
 		}
 		else if(tacticsSkillDiffDefender > 0)
 		{
-			curB->tacticsSide = BattleSide::DEFENDER;
+			currentBattle->tacticsSide = BattleSide::DEFENDER;
 			//bonus specifies distance you can move beyond base row; this allows 100% compatibility with HMM3 mechanics
-			curB->tacticDistance = 1 + tacticsSkillDiffDefender;
+			currentBattle->tacticDistance = 1 + tacticsSkillDiffDefender;
 		}
 		else
-			curB->tacticDistance = 0;
+			currentBattle->tacticDistance = 0;
 	}
 
-	return curB;
+	return currentBattle;
 }
 
 const CGHeroInstance * BattleInfo::getHero(const PlayerColor & player) const
@@ -508,14 +446,14 @@
 	return nullptr;
 }
 
-ui8 BattleInfo::whatSide(const PlayerColor & player) const
+BattleSide BattleInfo::whatSide(const PlayerColor & player) const
 {
-	for(int i = 0; i < sides.size(); i++)
+	for(auto i : {BattleSide::ATTACKER, BattleSide::DEFENDER})
 		if(sides[i].color == player)
 			return i;
 
 	logGlobal->warn("BattleInfo::whatSide: Player %s is not in battle!", player.toString());
-	return -1;
+	return BattleSide::NONE;
 }
 
 CStack * BattleInfo::getStack(int stackID, bool onlyAlive)
@@ -523,18 +461,30 @@
 	return const_cast<CStack *>(battleGetStackByID(stackID, onlyAlive));
 }
 
+BattleInfo::BattleInfo(const BattleLayout & layout):
+	BattleInfo()
+{
+	*this->layout = layout;
+}
+
 BattleInfo::BattleInfo():
+	layout(std::make_unique<BattleLayout>()),
 	round(-1),
 	activeStack(-1),
 	town(nullptr),
 	tile(-1,-1,-1),
 	battlefieldType(BattleField::NONE),
-	tacticsSide(0),
+	tacticsSide(BattleSide::NONE),
 	tacticDistance(0)
 {
 	setNodeType(BATTLE);
 }
 
+BattleLayout BattleInfo::getLayout() const
+{
+	return *layout;
+}
+
 BattleID BattleInfo::getBattleID() const
 {
 	return battleID;
@@ -555,7 +505,7 @@
 	for (auto & elem : stacks)
 		delete elem;
 
-	for(int i = 0; i < 2; i++)
+	for(auto i : {BattleSide::ATTACKER, BattleSide::DEFENDER})
 		if(auto * _armyObj = battleGetArmyObject(i))
 			_armyObj->battle = nullptr;
 }
@@ -600,27 +550,27 @@
 	return ret;
 }
 
-PlayerColor BattleInfo::getSidePlayer(ui8 side) const
+PlayerColor BattleInfo::getSidePlayer(BattleSide side) const
 {
-	return sides.at(side).color;
+	return getSide(side).color;
 }
 
-const CArmedInstance * BattleInfo::getSideArmy(ui8 side) const
+const CArmedInstance * BattleInfo::getSideArmy(BattleSide side) const
 {
-	return sides.at(side).armyObject;
+	return getSide(side).armyObject;
 }
 
-const CGHeroInstance * BattleInfo::getSideHero(ui8 side) const
+const CGHeroInstance * BattleInfo::getSideHero(BattleSide side) const
 {
-	return sides.at(side).hero;
+	return getSide(side).hero;
 }
 
-ui8 BattleInfo::getTacticDist() const
+uint8_t BattleInfo::getTacticDist() const
 {
 	return tacticDistance;
 }
 
-ui8 BattleInfo::getTacticsSide() const
+BattleSide BattleInfo::getTacticsSide() const
 {
 	return tacticsSide;
 }
@@ -640,14 +590,14 @@
 	return si.gateState;
 }
 
-uint32_t BattleInfo::getCastSpells(ui8 side) const
+uint32_t BattleInfo::getCastSpells(BattleSide side) const
 {
-	return sides.at(side).castSpellsCount;
+	return getSide(side).castSpellsCount;
 }
 
-int32_t BattleInfo::getEnchanterCounter(ui8 side) const
+int32_t BattleInfo::getEnchanterCounter(BattleSide side) const
 {
-	return sides.at(side).enchanterCounter;
+	return getSide(side).enchanterCounter;
 }
 
 const IBonusBearer * BattleInfo::getBonusBearer() const
@@ -662,10 +612,9 @@
 		int64_t sum = 0;
 
 		auto howManyToAv = std::min<int32_t>(10, attackerCount);
-		auto rangeGen = rng.getInt64Range(damage.min, damage.max);
 
 		for(int32_t g = 0; g < howManyToAv; ++g)
-			sum += rangeGen();
+			sum += rng.nextInt64(damage.min, damage.max);
 
 		return sum / howManyToAv;
 	}
@@ -680,20 +629,14 @@
 	return tile;
 }
 
-bool BattleInfo::isCreatureBank() const
-{
-	return creatureBank;
-}
-
-
-std::vector<SpellID> BattleInfo::getUsedSpells(ui8 side) const
+std::vector<SpellID> BattleInfo::getUsedSpells(BattleSide side) const
 {
-	return sides.at(side).usedSpellsHistory;
+	return getSide(side).usedSpellsHistory;
 }
 
 void BattleInfo::nextRound()
 {
-	for(int i = 0; i < 2; ++i)
+	for(auto i : {BattleSide::ATTACKER, BattleSide::DEFENDER})
 	{
 		sides.at(i).castSpellsCount = 0;
 		vstd::amax(--sides.at(i).enchanterCounter, 0);
@@ -762,7 +705,7 @@
 	if(!changedStack->alive() && healthDelta > 0)
 	{
 		//checking if we resurrect a stack that is under a living stack
-		auto accessibility = getAccesibility();
+		auto accessibility = getAccessibility();
 
 		if(!accessibility.accessible(changedStack->getPosition(), changedStack))
 		{
@@ -933,12 +876,12 @@
 	if(forceAdd || !sta->hasBonus(Selector::source(BonusSource::SPELL_EFFECT, value.sid).And(Selector::typeSubtypeValueType(value.type, value.subtype, value.valType))))
 	{
 		//no such effect or cumulative - add new
-		logBonus->trace("%s receives a new bonus: %s", sta->nodeName(), value.Description());
+		logBonus->trace("%s receives a new bonus: %s", sta->nodeName(), value.Description(nullptr));
 		sta->addNewBonus(std::make_shared<Bonus>(value));
 	}
 	else
 	{
-		logBonus->trace("%s updated bonus: %s", sta->nodeName(), value.Description());
+		logBonus->trace("%s updated bonus: %s", sta->nodeName(), value.Description(nullptr));
 
 		for(const auto & stackBonus : sta->getExportedBonusList()) //TODO: optimize
 		{
@@ -995,12 +938,12 @@
 	}
 }
 
-CArmedInstance * BattleInfo::battleGetArmyObject(ui8 side) const
+CArmedInstance * BattleInfo::battleGetArmyObject(BattleSide side) const
 {
 	return const_cast<CArmedInstance*>(CBattleInfoEssentials::battleGetArmyObject(side));
 }
 
-CGHeroInstance * BattleInfo::battleGetFightingHero(ui8 side) const
+CGHeroInstance * BattleInfo::battleGetFightingHero(BattleSide side) const
 {
 	return const_cast<CGHeroInstance*>(CBattleInfoEssentials::battleGetFightingHero(side));
 }
@@ -1010,7 +953,7 @@
 {
 	//this is real battle, use global scripting context pool
 	//TODO: make this line not ugly
-	return battleGetFightingHero(0)->cb->getGlobalContextPool();
+	return battleGetFightingHero(BattleSide::ATTACKER)->cb->getGlobalContextPool();
 }
 #endif
 
@@ -1046,7 +989,7 @@
 	return false;
 }
 
-CMP_stack::CMP_stack(int Phase, int Turn, uint8_t Side):
+CMP_stack::CMP_stack(int Phase, int Turn, BattleSide Side):
 	phase(Phase), 
 	turn(Turn), 
 	side(Side) 
diff --color -urN vcmi-1.5.7/lib/battle/BattleInfo.h vcmi/lib/battle/BattleInfo.h
--- vcmi-1.5.7/lib/battle/BattleInfo.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/battle/BattleInfo.h	2024-12-19 15:00:22.885147400 +0100
@@ -22,23 +22,19 @@
 class CStackInstance;
 class CStackBasicDescriptor;
 class BattleField;
+struct BattleLayout;
 
 class DLL_LINKAGE BattleInfo : public CBonusSystemNode, public CBattleInfoCallback, public IBattleState
 {
+	BattleSideArray<SideInBattle> sides; //sides[0] - attacker, sides[1] - defender
+	std::unique_ptr<BattleLayout> layout;
 public:
 	BattleID battleID = BattleID(0);
 
-	enum BattleSide
-	{
-		ATTACKER = 0,
-		DEFENDER
-	};
-	std::array<SideInBattle, 2> sides; //sides[0] - attacker, sides[1] - defender
 	si32 round;
 	si32 activeStack;
 	const CGTownInstance * town; //used during town siege, nullptr if this is not a siege (note that fortless town IS also a siege)
 	int3 tile; //for background and bonuses
-	bool creatureBank; //auxilary field, do not serialize
 	bool replayAllowed;
 	std::vector<CStack*> stacks;
 	std::vector<std::shared_ptr<CObstacleInstance> > obstacles;
@@ -47,7 +43,7 @@
 	BattleField battlefieldType; //like !!BA:B
 	TerrainId terrainType; //used for some stack nativity checks (not the bonus limiters though that have their own copy)
 
-	ui8 tacticsSide; //which side is requested to play tactics phase
+	BattleSide tacticsSide; //which side is requested to play tactics phase
 	ui8 tacticDistance; //how many hexes we can go forward (1 = only hexes adjacent to margin line)
 
 	template <typename Handler> void serialize(Handler &h)
@@ -70,6 +66,7 @@
 	}
 
 	//////////////////////////////////////////////////////////////////////////
+	BattleInfo(const BattleLayout & layout);
 	BattleInfo();
 	virtual ~BattleInfo();
 
@@ -92,19 +89,19 @@
 
 	ObstacleCList getAllObstacles() const override;
 
-	PlayerColor getSidePlayer(ui8 side) const override;
-	const CArmedInstance * getSideArmy(ui8 side) const override;
-	const CGHeroInstance * getSideHero(ui8 side) const override;
+	PlayerColor getSidePlayer(BattleSide side) const override;
+	const CArmedInstance * getSideArmy(BattleSide side) const override;
+	const CGHeroInstance * getSideHero(BattleSide side) const override;
 
 	ui8 getTacticDist() const override;
-	ui8 getTacticsSide() const override;
+	BattleSide getTacticsSide() const override;
 
 	const CGTownInstance * getDefendedTown() const override;
 	EWallState getWallState(EWallPart partOfWall) const override;
 	EGateState getGateState() const override;
 
-	uint32_t getCastSpells(ui8 side) const override;
-	int32_t getEnchanterCounter(ui8 side) const override;
+	uint32_t getCastSpells(BattleSide side) const override;
+	int32_t getEnchanterCounter(BattleSide side) const override;
 
 	const IBonusBearer * getBonusBearer() const override;
 
@@ -113,9 +110,9 @@
 	int64_t getActualDamage(const DamageRange & damage, int32_t attackerCount, vstd::RNG & rng) const override;
 
 	int3 getLocation() const override;
-	bool isCreatureBank() const override;
+	BattleLayout getLayout() const override;
 
-	std::vector<SpellID> getUsedSpells(ui8 side) const override;
+	std::vector<SpellID> getUsedSpells(BattleSide side) const override;
 
 	//////////////////////////////////////////////////////////////////////////
 	// IBattleState
@@ -144,19 +141,22 @@
 	//////////////////////////////////////////////////////////////////////////
 	CStack * getStack(int stackID, bool onlyAlive = true);
 	using CBattleInfoEssentials::battleGetArmyObject;
-	CArmedInstance * battleGetArmyObject(ui8 side) const;
+	CArmedInstance * battleGetArmyObject(BattleSide side) const;
 	using CBattleInfoEssentials::battleGetFightingHero;
-	CGHeroInstance * battleGetFightingHero(ui8 side) const;
+	CGHeroInstance * battleGetFightingHero(BattleSide side) const;
+
+	CStack * generateNewStack(uint32_t id, const CStackInstance & base, BattleSide side, const SlotID & slot, BattleHex position);
+	CStack * generateNewStack(uint32_t id, const CStackBasicDescriptor & base, BattleSide side, const SlotID & slot, BattleHex position);
 
-	CStack * generateNewStack(uint32_t id, const CStackInstance & base, ui8 side, const SlotID & slot, BattleHex position);
-	CStack * generateNewStack(uint32_t id, const CStackBasicDescriptor & base, ui8 side, const SlotID & slot, BattleHex position);
+	const SideInBattle & getSide(BattleSide side) const;
+	SideInBattle & getSide(BattleSide side);
 
 	const CGHeroInstance * getHero(const PlayerColor & player) const; //returns fighting hero that belongs to given player
 
 	void localInit();
-	static BattleInfo * setupBattle(const int3 & tile, TerrainId, const BattleField & battlefieldType, const CArmedInstance * armies[2], const CGHeroInstance * heroes[2], bool creatureBank, const CGTownInstance * town);
+	static BattleInfo * setupBattle(const int3 & tile, TerrainId, const BattleField & battlefieldType, BattleSideArray<const CArmedInstance *> armies, BattleSideArray<const CGHeroInstance *> heroes, const BattleLayout & layout, const CGTownInstance * town);
 
-	ui8 whatSide(const PlayerColor & player) const;
+	BattleSide whatSide(const PlayerColor & player) const;
 
 protected:
 #if SCRIPTING_ENABLED
@@ -169,10 +169,10 @@
 {
 	int phase; //rules of which phase will be used
 	int turn;
-	uint8_t side;
+	BattleSide side;
 public:
 	bool operator()(const battle::Unit * a, const battle::Unit * b) const;
-	CMP_stack(int Phase = 1, int Turn = 0, uint8_t Side = BattleSide::ATTACKER);
+	CMP_stack(int Phase = 1, int Turn = 0, BattleSide Side = BattleSide::ATTACKER);
 };
 
 VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/battle/BattleLayout.cpp vcmi/lib/battle/BattleLayout.cpp
--- vcmi-1.5.7/lib/battle/BattleLayout.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/battle/BattleLayout.cpp	2024-12-19 15:00:22.886147442 +0100
@@ -0,0 +1,81 @@
+/*
+ * BattleLayout.cpp, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#include "StdInc.h"
+#include "BattleLayout.h"
+
+#include "../GameSettings.h"
+#include "../IGameCallback.h"
+#include "../VCMI_Lib.h"
+#include "../json/JsonNode.h"
+#include "../mapObjects/CArmedInstance.h"
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+BattleLayout BattleLayout::createDefaultLayout(IGameCallback * cb, const CArmedInstance * attacker, const CArmedInstance * defender)
+{
+	return createLayout(cb, "default", attacker, defender);
+}
+
+BattleLayout BattleLayout::createLayout(IGameCallback * cb, const std::string & layoutName, const CArmedInstance * attacker, const CArmedInstance * defender)
+{
+	const auto & loadHex = [](const JsonNode & node)
+	{
+		if (node.isNull())
+			return BattleHex();
+		else
+			return BattleHex(node.Integer());
+	};
+
+	const auto & loadUnits = [](const JsonNode & node)
+	{
+		UnitsArrayType::value_type result;
+		for (size_t i = 0; i < GameConstants::ARMY_SIZE; ++i)
+		{
+			if (!node[i].isNull())
+				result[i] = BattleHex(node[i].Integer());
+		}
+		return result;
+	};
+
+	const JsonNode & configRoot = cb->getSettings().getValue(EGameSettings::COMBAT_LAYOUTS);
+	const JsonNode & config = configRoot[layoutName];
+
+	BattleLayout result;
+
+	result.commanders[BattleSide::ATTACKER] = loadHex(config["attackerCommander"]);
+	result.commanders[BattleSide::DEFENDER] = loadHex(config["defenderCommander"]);
+
+	for (size_t i = 0; i < 4; ++i)
+		result.warMachines[BattleSide::ATTACKER][i] = loadHex(config["attackerWarMachines"][i]);
+
+	for (size_t i = 0; i < 4; ++i)
+		result.warMachines[BattleSide::DEFENDER][i] = loadHex(config["defenderWarMachines"][i]);
+
+	if (attacker->formation == EArmyFormation::LOOSE && !config["attackerUnitsLoose"].isNull())
+		result.units[BattleSide::ATTACKER] = loadUnits(config["attackerUnitsLoose"][attacker->stacksCount() - 1]);
+	else if (attacker->formation == EArmyFormation::TIGHT && !config["attackerUnitsTight"].isNull())
+		result.units[BattleSide::ATTACKER] = loadUnits(config["attackerUnitsTight"][attacker->stacksCount() - 1]);
+	else
+		result.units[BattleSide::ATTACKER] = loadUnits(config["attackerUnits"]);
+
+	if (defender->formation == EArmyFormation::LOOSE && !config["defenderUnitsLoose"].isNull())
+		result.units[BattleSide::DEFENDER] = loadUnits(config["defenderUnitsLoose"][defender->stacksCount() - 1]);
+	else if (defender->formation == EArmyFormation::TIGHT && !config["defenderUnitsTight"].isNull())
+		result.units[BattleSide::DEFENDER] = loadUnits(config["defenderUnitsTight"][defender->stacksCount() - 1]);
+	else
+		result.units[BattleSide::DEFENDER] = loadUnits(config["defenderUnits"]);
+
+	result.obstaclesAllowed = config["obstaclesAllowed"].Bool();
+	result.tacticsAllowed = config["tacticsAllowed"].Bool();
+
+	return result;
+}
+
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/battle/BattleLayout.h vcmi/lib/battle/BattleLayout.h
--- vcmi-1.5.7/lib/battle/BattleLayout.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/battle/BattleLayout.h	2024-12-19 15:00:22.886147442 +0100
@@ -0,0 +1,39 @@
+/*
+ * BattleLayout.h, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#pragma once
+
+#include "BattleHex.h"
+#include "BattleSide.h"
+#include "../constants/NumericConstants.h"
+#include "../constants/Enumerations.h"
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+class CArmedInstance;
+class IGameCallback;
+
+struct DLL_EXPORT BattleLayout
+{
+	using UnitsArrayType = BattleSideArray<std::array<BattleHex, GameConstants::ARMY_SIZE>>;
+	using MachinesArrayType = BattleSideArray<std::array<BattleHex, 4>>;
+	using CommanderArrayType = BattleSideArray<BattleHex>;
+
+	UnitsArrayType units;
+	MachinesArrayType warMachines;
+	CommanderArrayType commanders;
+
+	bool tacticsAllowed = false;
+	bool obstaclesAllowed = false;
+
+	static BattleLayout createDefaultLayout(IGameCallback * cb, const CArmedInstance * attacker, const CArmedInstance * defender);
+	static BattleLayout createLayout(IGameCallback * cb, const std::string & layoutName, const CArmedInstance * attacker, const CArmedInstance * defender);
+};
+
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/battle/BattleProxy.cpp vcmi/lib/battle/BattleProxy.cpp
--- vcmi-1.5.7/lib/battle/BattleProxy.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/battle/BattleProxy.cpp	2024-12-19 15:00:22.886147442 +0100
@@ -65,17 +65,17 @@
 	return subject->battleGetAllObstacles();
 }
 
-PlayerColor BattleProxy::getSidePlayer(ui8 side) const
+PlayerColor BattleProxy::getSidePlayer(BattleSide side) const
 {
 	return subject->sideToPlayer(side);
 }
 
-const CArmedInstance * BattleProxy::getSideArmy(ui8 side) const
+const CArmedInstance * BattleProxy::getSideArmy(BattleSide side) const
 {
 	return subject->battleGetArmyObject(side);
 }
 
-const CGHeroInstance * BattleProxy::getSideHero(ui8 side) const
+const CGHeroInstance * BattleProxy::getSideHero(BattleSide side) const
 {
 	return subject->battleGetFightingHero(side);
 }
@@ -85,7 +85,7 @@
 	return subject->battleTacticDist();
 }
 
-ui8 BattleProxy::getTacticsSide() const
+BattleSide BattleProxy::getTacticsSide() const
 {
 	return subject->battleGetTacticsSide();
 }
@@ -105,12 +105,12 @@
 	return subject->battleGetGateState();
 }
 
-uint32_t BattleProxy::getCastSpells(ui8 side) const
+uint32_t BattleProxy::getCastSpells(BattleSide side) const
 {
 	return subject->battleCastSpells(side);
 }
 
-int32_t BattleProxy::getEnchanterCounter(ui8 side) const
+int32_t BattleProxy::getEnchanterCounter(BattleSide side) const
 {
 	return subject->battleGetEnchanterCounter(side);
 }
diff --color -urN vcmi-1.5.7/lib/battle/BattleProxy.h vcmi/lib/battle/BattleProxy.h
--- vcmi-1.5.7/lib/battle/BattleProxy.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/battle/BattleProxy.h	2024-12-19 15:00:22.887147483 +0100
@@ -38,19 +38,19 @@
 
 	ObstacleCList getAllObstacles() const override;
 
-	PlayerColor getSidePlayer(ui8 side) const override;
-	const CArmedInstance * getSideArmy(ui8 side) const override;
-	const CGHeroInstance * getSideHero(ui8 side) const override;
+	PlayerColor getSidePlayer(BattleSide side) const override;
+	const CArmedInstance * getSideArmy(BattleSide side) const override;
+	const CGHeroInstance * getSideHero(BattleSide side) const override;
 
 	ui8 getTacticDist() const override;
-	ui8 getTacticsSide() const override;
+	BattleSide getTacticsSide() const override;
 
 	const CGTownInstance * getDefendedTown() const override;
 	EWallState getWallState(EWallPart partOfWall) const override;
 	EGateState getGateState() const override;
 
-	uint32_t getCastSpells(ui8 side) const override;
-	int32_t getEnchanterCounter(ui8 side) const override;
+	uint32_t getCastSpells(BattleSide side) const override;
+	int32_t getEnchanterCounter(BattleSide side) const override;
 
 	const IBonusBearer * getBonusBearer() const override;
 protected:
diff --color -urN vcmi-1.5.7/lib/battle/BattleSide.h vcmi/lib/battle/BattleSide.h
--- vcmi-1.5.7/lib/battle/BattleSide.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/battle/BattleSide.h	2024-12-19 15:00:22.887147483 +0100
@@ -0,0 +1,53 @@
+/*
+ * BattleSide.h, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#pragma once
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+enum class BattleSide : int8_t
+{
+	NONE = -1,
+	INVALID = -2,
+	ALL_KNOWING = -3,
+
+	ATTACKER = 0,
+	DEFENDER = 1,
+
+	// Aliases for convenience
+	LEFT_SIDE = ATTACKER,
+	RIGHT_SIDE = DEFENDER,
+};
+
+template<typename T>
+class BattleSideArray : public std::array<T, 2>
+{
+public:
+	const T & at(BattleSide side) const
+	{
+		return std::array<T, 2>::at(static_cast<int>(side));
+	}
+
+	T & at(BattleSide side)
+	{
+		return std::array<T, 2>::at(static_cast<int>(side));
+	}
+
+	const T & operator[](BattleSide side) const
+	{
+		return std::array<T, 2>::at(static_cast<int>(side));
+	}
+
+	T & operator[](BattleSide side)
+	{
+		return std::array<T, 2>::at(static_cast<int>(side));
+	}
+};
+
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/battle/BattleStateInfoForRetreat.cpp vcmi/lib/battle/BattleStateInfoForRetreat.cpp
--- vcmi-1.5.7/lib/battle/BattleStateInfoForRetreat.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/battle/BattleStateInfoForRetreat.cpp	2024-12-19 15:00:22.887147483 +0100
@@ -23,7 +23,7 @@
 	isLastTurnBeforeDie(false),
 	ourHero(nullptr),
 	enemyHero(nullptr),
-	ourSide(-1)
+	ourSide(BattleSide::NONE)
 {
 }
 
diff --color -urN vcmi-1.5.7/lib/battle/BattleStateInfoForRetreat.h vcmi/lib/battle/BattleStateInfoForRetreat.h
--- vcmi-1.5.7/lib/battle/BattleStateInfoForRetreat.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/battle/BattleStateInfoForRetreat.h	2024-12-19 15:00:22.887147483 +0100
@@ -9,6 +9,8 @@
  */
 #pragma once
 
+#include "BattleSide.h"
+
 VCMI_LIB_NAMESPACE_BEGIN
 
 namespace battle
@@ -24,7 +26,7 @@
 	bool canFlee;
 	bool canSurrender;
 	bool isLastTurnBeforeDie;
-	ui8 ourSide;
+	BattleSide ourSide;
 	std::vector<const battle::Unit *> ourStacks;
 	std::vector<const battle::Unit *> enemyStacks;
 	const CGHeroInstance * ourHero;
diff --color -urN vcmi-1.5.7/lib/battle/CBattleInfoCallback.cpp vcmi/lib/battle/CBattleInfoCallback.cpp
--- vcmi-1.5.7/lib/battle/CBattleInfoCallback.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/battle/CBattleInfoCallback.cpp	2024-12-19 15:00:22.889147566 +0100
@@ -11,12 +11,15 @@
 #include "CBattleInfoCallback.h"
 
 #include <vcmi/scripting/Service.h>
+#include <vstd/RNG.h>
 
 #include "../CStack.h"
 #include "BattleInfo.h"
 #include "CObstacleInstance.h"
 #include "DamageCalculator.h"
+#include "IGameSettings.h"
 #include "PossiblePlayerBattleAction.h"
+#include "../entities/building/TownFortifications.h"
 #include "../spells/ObstacleCasterProxy.h"
 #include "../spells/ISpellMechanics.h"
 #include "../spells/Problem.h"
@@ -25,7 +28,6 @@
 #include "../networkPacks/PacksForClientBattle.h"
 #include "../BattleFieldHandler.h"
 #include "../Rect.h"
-#include "../CRandomGenerator.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
@@ -50,6 +52,12 @@
 	return stackLeft == destLeft;
 }
 
+static bool isInsideWalls(BattleHex pos)
+{
+	const int wallInStackLine = lineToWallHex(pos.getY());
+	return wallInStackLine < pos;
+}
+
 // parts of wall
 static const std::pair<int, EWallPart> wallParts[] =
 {
@@ -104,9 +112,9 @@
 	}
 	const PlayerColor player = caster->getCasterOwner();
 	const auto side = playerToSide(player);
-	if(!side)
+	if(side == BattleSide::NONE)
 		return ESpellCastProblem::INVALID;
-	if(!battleDoWeKnowAbout(side.value()))
+	if(!battleDoWeKnowAbout(side))
 	{
 		logGlobal->warn("You can't check if enemy can cast given spell!");
 		return ESpellCastProblem::INVALID;
@@ -119,7 +127,7 @@
 	{
 	case spells::Mode::HERO:
 	{
-		if(battleCastSpells(side.value()) > 0)
+		if(battleCastSpells(side) > 0)
 			return ESpellCastProblem::CASTS_PER_TURN_LIMIT;
 
 		const auto * hero = dynamic_cast<const CGHeroInstance *>(caster);
@@ -128,6 +136,8 @@
 			return ESpellCastProblem::NO_HERO_TO_CAST_SPELL;
 		if(hero->hasBonusOfType(BonusType::BLOCK_ALL_MAGIC))
 			return ESpellCastProblem::MAGIC_IS_BLOCKED;
+		if(!hero->hasSpellbook())
+			return ESpellCastProblem::NO_SPELLBOOK;
 	}
 		break;
 	default:
@@ -158,8 +168,16 @@
 	return std::make_pair(path, reachability.distances[dest]);
 }
 
+bool CBattleInfoCallback::battleIsInsideWalls(BattleHex from) const
+{
+	return isInsideWalls(from);
+}
+
 bool CBattleInfoCallback::battleHasPenaltyOnLine(BattleHex from, BattleHex dest, bool checkWall, bool checkMoat) const
 {
+	if (!from.isAvailable() || !dest.isAvailable())
+		throw std::runtime_error("Invalid hex (" + std::to_string(from.hex) + " and " + std::to_string(dest.hex) + ") received in battleHasPenaltyOnLine!" );
+
 	auto isTileBlocked = [&](BattleHex tile)
 	{
 		EWallPart wallPart = battleHexToWallPart(tile);
@@ -221,7 +239,7 @@
 bool CBattleInfoCallback::battleHasWallPenalty(const IBonusBearer * shooter, BattleHex shooterPosition, BattleHex destHex) const
 {
 	RETURN_IF_NOT_BATTLE(false);
-	if(!battleGetSiegeLevel())
+	if(battleGetFortifications().wallsHealth == 0)
 		return false;
 
 	const std::string cachingStrNoWallPenalty = "type_NO_WALL_PENALTY";
@@ -272,7 +290,7 @@
 			allowedActionList.push_back(PossiblePlayerBattleAction::MOVE_STACK);
 
 		const auto * siegedTown = battleGetDefendedTown();
-		if(siegedTown && siegedTown->hasFort() && stack->hasBonusOfType(BonusType::CATAPULT)) //TODO: check shots
+		if(siegedTown && siegedTown->fortificationsLevel().wallsHealth > 0 && stack->hasBonusOfType(BonusType::CATAPULT)) //TODO: check shots
 			allowedActionList.push_back(PossiblePlayerBattleAction::CATAPULT);
 		if(stack->hasBonusOfType(BonusType::HEALER))
 			allowedActionList.push_back(PossiblePlayerBattleAction::HEAL);
@@ -360,7 +378,7 @@
 	});
 }
 
-battle::Units CBattleInfoCallback::battleAliveUnits(ui8 side) const
+battle::Units CBattleInfoCallback::battleAliveUnits(BattleSide side) const
 {
 	return battleGetUnitsIf([=](const battle::Unit * unit)
 	{
@@ -372,7 +390,7 @@
 
 //T is battle::Unit descendant
 template <typename T>
-const T * takeOneUnit(std::vector<const T*> & allUnits, const int turn, int8_t & sideThatLastMoved, int phase)
+const T * takeOneUnit(std::vector<const T*> & allUnits, const int turn, BattleSide & sideThatLastMoved, int phase)
 {
 	const T * returnedUnit = nullptr;
 	size_t currentUnitIndex = 0;
@@ -401,13 +419,13 @@
 			}
 			else if(currentUnitInitiative == returnedUnitInitiative)
 			{
-				if(sideThatLastMoved == -1 && turn <= 0 && currentUnit->unitSide() == BattleSide::ATTACKER
+				if(sideThatLastMoved == BattleSide::NONE && turn <= 0 && currentUnit->unitSide() == BattleSide::ATTACKER
 					&& !(returnedUnit->unitSide() == currentUnit->unitSide() && returnedUnit->unitSlot() < currentUnit->unitSlot())) // Turn 0 attacker priority
 				{
 					returnedUnit = currentUnit;
 					currentUnitIndex = i;
 				}
-				else if(sideThatLastMoved != -1 && currentUnit->unitSide() != sideThatLastMoved
+				else if(sideThatLastMoved != BattleSide::NONE && currentUnit->unitSide() != sideThatLastMoved
 					&& !(returnedUnit->unitSide() == currentUnit->unitSide() && returnedUnit->unitSlot() < currentUnit->unitSlot())) // Alternate equal speeds units
 				{
 					returnedUnit = currentUnit;
@@ -422,7 +440,7 @@
 				returnedUnit = currentUnit;
 				currentUnitIndex = i;
 			}
-			else if(currentUnitInitiative == returnedUnitInitiative && sideThatLastMoved != -1 && currentUnit->unitSide() != sideThatLastMoved
+			else if(currentUnitInitiative == returnedUnitInitiative && sideThatLastMoved != BattleSide::NONE && currentUnit->unitSide() != sideThatLastMoved
 				&& !(returnedUnit->unitSide() == currentUnit->unitSide() && returnedUnit->unitSlot() < currentUnit->unitSlot())) // Alternate equal speeds units
 			{
 				returnedUnit = currentUnit;
@@ -442,7 +460,7 @@
 	return returnedUnit;
 }
 
-void CBattleInfoCallback::battleGetTurnOrder(std::vector<battle::Units> & turns, const size_t maxUnits, const int maxTurns, const int turn, int8_t sideThatLastMoved) const
+void CBattleInfoCallback::battleGetTurnOrder(std::vector<battle::Units> & turns, const size_t maxUnits, const int maxTurns, const int turn, BattleSide sideThatLastMoved) const
 {
 	RETURN_IF_NOT_BATTLE();
 
@@ -475,7 +493,7 @@
 	if(activeUnit)
 	{
 		//its first turn and active unit hasn't taken any action yet - must be placed at the beginning of queue, no matter what
-		if(turn == 0 && activeUnit->willMove() && !activeUnit->waited())
+		if(turn == 0 && activeUnit->willMove())
 		{
 			turns.back().push_back(activeUnit);
 			if(turnsIsFull())
@@ -484,7 +502,7 @@
 
 		//its first or current turn, turn priority for active stack side
 		//TODO: what if active stack mind-controlled?
-		if(turn <= 0 && sideThatLastMoved < 0)
+		if(turn <= 0 && sideThatLastMoved == BattleSide::NONE)
 			sideThatLastMoved = activeUnit->unitSide();
 	}
 
@@ -544,7 +562,7 @@
 		}
 	}
 
-	if(sideThatLastMoved < 0)
+	if(sideThatLastMoved == BattleSide::NONE)
 		sideThatLastMoved = BattleSide::ATTACKER;
 
 	if(!turnsIsFull() && (maxTurns == 0 || turns.size() < maxTurns))
@@ -668,6 +686,9 @@
 	if (!stack || !target)
 		return false;
 
+	if(target->hasBonusOfType(BonusType::INVINCIBLE))
+		return false;
+
 	if(!battleMatchOwner(stack, target))
 		return false;
 
@@ -705,15 +726,49 @@
 			|| attacker->hasBonusOfType(BonusType::FREE_SHOOTING));
 }
 
+bool CBattleInfoCallback::battleCanTargetEmptyHex(const battle::Unit * attacker) const
+{
+	RETURN_IF_NOT_BATTLE(false);
+
+	if(!VLC->engineSettings()->getBoolean(EGameSettings::COMBAT_AREA_SHOT_CAN_TARGET_EMPTY_HEX))
+		return false;
+
+	if(attacker->hasBonusOfType(BonusType::SPELL_LIKE_ATTACK))
+	{
+		auto bonus = attacker->getBonus(Selector::type()(BonusType::SPELL_LIKE_ATTACK));
+		const CSpell * spell = bonus->subtype.as<SpellID>().toSpell();
+		spells::BattleCast cast(this, attacker, spells::Mode::SPELL_LIKE_ATTACK, spell);
+		BattleHex dummySpellTarget = BattleHex(50); //check arbitrary hex for general spell range since currently there is no general way to access amount of hexes
+
+		if(spell->battleMechanics(&cast)->rangeInHexes(dummySpellTarget).size() > 1)
+		{
+			return true;
+		}
+	}
+
+	return false;
+}
+
 bool CBattleInfoCallback::battleCanShoot(const battle::Unit * attacker, BattleHex dest) const
 {
 	RETURN_IF_NOT_BATTLE(false);
 
 	const battle::Unit * defender = battleGetUnitByPos(dest);
-	if(!attacker || !defender)
+	if(!attacker)
 		return false;
 
-	if(battleMatchOwner(attacker, defender) && defender->alive())
+	bool emptyHexAreaAttack = battleCanTargetEmptyHex(attacker);
+
+	if(!emptyHexAreaAttack)
+	{
+		if(!defender)
+			return false;
+
+		if(defender->hasBonusOfType(BonusType::INVINCIBLE))
+			return false;
+	}
+
+	if(emptyHexAreaAttack || (battleMatchOwner(attacker, defender) && defender->alive()))
 	{
 		if(battleCanShoot(attacker))
 		{
@@ -724,7 +779,11 @@
 			}
 
 			int shootingRange = limitedRangeBonus->val;
-			return isEnemyUnitWithinSpecifiedRange(attacker->getPosition(), defender, shootingRange);
+
+			if(defender)
+				return isEnemyUnitWithinSpecifiedRange(attacker->getPosition(), defender, shootingRange);
+			else
+				return isHexWithinSpecifiedRange(attacker->getPosition(), dest, shootingRange);
 		}
 	}
 
@@ -771,7 +830,7 @@
 	if (!bai.defender->ableToRetaliate())
 		return ret;
 
-	if (bai.attacker->hasBonusOfType(BonusType::BLOCKS_RETALIATION))
+	if (bai.attacker->hasBonusOfType(BonusType::BLOCKS_RETALIATION) || bai.attacker->hasBonusOfType(BonusType::INVINCIBLE))
 		return ret;
 
 	//TODO: rewrite using boost::numeric::interval
@@ -868,10 +927,10 @@
 				bocp.battleID = getBattle()->getBattleID();
 				bocp.changes.emplace_back(spellObstacle.uniqueID, operation);
 				changedObstacle.toInfo(bocp.changes.back(), operation);
-				spellEnv.apply(&bocp);
+				spellEnv.apply(bocp);
 			};
 			const auto side = unit.unitSide();
-			auto shouldReveal = !spellObstacle->hidden || !battleIsObstacleVisibleForSide(*obstacle, (BattlePerspective::BattlePerspective)side);
+			auto shouldReveal = !spellObstacle->hidden || !battleIsObstacleVisibleForSide(*obstacle, side);
 			const auto * hero = battleGetFightingHero(spellObstacle->casterSide);
 			auto caster = spells::ObstacleCasterProxy(getBattle()->getSidePlayer(spellObstacle->casterSide), hero, *spellObstacle);
 
@@ -903,7 +962,7 @@
 	return unit.alive() && !movementStopped;
 }
 
-AccessibilityInfo CBattleInfoCallback::getAccesibility() const
+AccessibilityInfo CBattleInfoCallback::getAccessibility() const
 {
 	AccessibilityInfo ret;
 	ret.fill(EAccessibility::ACCESSIBLE);
@@ -927,20 +986,20 @@
 	}
 
 	//gate -> should be before stacks
-	if(battleGetSiegeLevel() > 0)
+	if(battleGetFortifications().wallsHealth > 0)
 	{
-		EAccessibility accessability = EAccessibility::ACCESSIBLE;
+		EAccessibility accessibility = EAccessibility::ACCESSIBLE;
 		switch(battleGetGateState())
 		{
 		case EGateState::CLOSED:
-			accessability = EAccessibility::GATE;
+			accessibility = EAccessibility::GATE;
 			break;
 
 		case EGateState::BLOCKED:
-			accessability = EAccessibility::UNAVAILABLE;
+			accessibility = EAccessibility::UNAVAILABLE;
 			break;
 		}
-		ret[BattleHex::GATE_OUTER] = ret[BattleHex::GATE_INNER] = accessability;
+		ret[BattleHex::GATE_OUTER] = ret[BattleHex::GATE_INNER] = accessibility;
 	}
 
 	//tiles occupied by standing stacks
@@ -959,7 +1018,7 @@
 	}
 
 	//walls
-	if(battleGetSiegeLevel() > 0)
+	if(battleGetFortifications().wallsHealth > 0)
 	{
 		static const int permanentlyLocked[] = {12, 45, 62, 112, 147, 165};
 		for(auto hex : permanentlyLocked)
@@ -985,14 +1044,14 @@
 	return ret;
 }
 
-AccessibilityInfo CBattleInfoCallback::getAccesibility(const battle::Unit * stack) const
+AccessibilityInfo CBattleInfoCallback::getAccessibility(const battle::Unit * stack) const
 {
-	return getAccesibility(battle::Unit::getHexes(stack->getPosition(), stack->doubleWide(), stack->unitSide()));
+	return getAccessibility(battle::Unit::getHexes(stack->getPosition(), stack->doubleWide(), stack->unitSide()));
 }
 
-AccessibilityInfo CBattleInfoCallback::getAccesibility(const std::vector<BattleHex> & accessibleHexes) const
+AccessibilityInfo CBattleInfoCallback::getAccessibility(const std::vector<BattleHex> & accessibleHexes) const
 {
-	auto ret = getAccesibility();
+	auto ret = getAccessibility();
 	for(auto hex : accessibleHexes)
 		if(hex.isValid())
 			ret[hex] = EAccessibility::ACCESSIBLE;
@@ -1036,16 +1095,29 @@
 			continue;
 
 		const int costToNeighbour = ret.distances.at(curHex.hex) + 1;
+
 		for(BattleHex neighbour : BattleHex::neighbouringTilesCache[curHex.hex])
 		{
 			if(neighbour.isValid())
 			{
+				auto additionalCost = 0;
+
+				if(params.bypassEnemyStacks)
+				{
+					auto enemyToBypass = params.destructibleEnemyTurns.find(neighbour);
+
+					if(enemyToBypass != params.destructibleEnemyTurns.end())
+					{
+						additionalCost = enemyToBypass->second;
+					}
+				}
+
 				const int costFoundSoFar = ret.distances[neighbour.hex];
 
-				if(accessibleCache[neighbour.hex] && costToNeighbour < costFoundSoFar)
+				if(accessibleCache[neighbour.hex] && costToNeighbour + additionalCost < costFoundSoFar)
 				{
 					hexq.push(neighbour);
-					ret.distances[neighbour.hex] = costToNeighbour;
+					ret.distances[neighbour.hex] = costToNeighbour + additionalCost;
 					ret.predecessors[neighbour.hex] = curHex;
 				}
 			}
@@ -1082,7 +1154,7 @@
 	return false;
 }
 
-std::set<BattleHex> CBattleInfoCallback::getStoppers(BattlePerspective::BattlePerspective whichSidePerspective) const
+std::set<BattleHex> CBattleInfoCallback::getStoppers(BattleSide whichSidePerspective) const
 {
 	std::set<BattleHex> ret;
 	RETURN_IF_NOT_BATTLE(ret);
@@ -1145,7 +1217,7 @@
 		return std::make_pair<const battle::Unit * , BattleHex>(nullptr, BattleHex::INVALID);
 }
 
-BattleHex CBattleInfoCallback::getAvaliableHex(const CreatureID & creID, ui8 side, int initialPos) const
+BattleHex CBattleInfoCallback::getAvailableHex(const CreatureID & creID, BattleSide side, int initialPos) const
 {
 	bool twoHex = VLC->creatures()->getById(creID)->isDoubleWide();
 
@@ -1160,7 +1232,7 @@
  			pos = GameConstants::BFIELD_WIDTH - 1; //top right
  	}
 
-	auto accessibility = getAccesibility();
+	auto accessibility = getAccessibility();
 
 	std::set<BattleHex> occupyable;
 	for(int i = 0; i < accessibility.size(); i++)
@@ -1192,8 +1264,13 @@
 	auto side = battleGetTacticsSide();
 	auto dist = battleGetTacticDist();
 
-	return ((!side && dest.getX() > 0 && dest.getX() <= dist)
-			|| (side && dest.getX() < GameConstants::BFIELD_WIDTH - 1 && dest.getX() >= GameConstants::BFIELD_WIDTH - dist - 1));
+	if (side == BattleSide::ATTACKER && dest.getX() > 0 && dest.getX() <= dist)
+		return true;
+
+	if (side == BattleSide::DEFENDER && dest.getX() < GameConstants::BFIELD_WIDTH - 1 && dest.getX() >= GameConstants::BFIELD_WIDTH - dist - 1)
+		return true;
+
+	return false;
 }
 
 ReachabilityInfo CBattleInfoCallback::getReachability(const battle::Unit * unit) const
@@ -1215,13 +1292,19 @@
 	if(params.flying)
 		return getFlyingReachability(params);
 	else
-		return makeBFS(getAccesibility(params.knownAccessible), params);
+	{
+		auto accessibility = getAccessibility(params.knownAccessible);
+
+		accessibility.destructibleEnemyTurns = params.destructibleEnemyTurns;
+
+		return makeBFS(accessibility, params);
+	}
 }
 
 ReachabilityInfo CBattleInfoCallback::getFlyingReachability(const ReachabilityInfo::Parameters &params) const
 {
 	ReachabilityInfo ret;
-	ret.accessibility = getAccesibility(params.knownAccessible);
+	ret.accessibility = getAccessibility(params.knownAccessible);
 
 	for(int i = 0; i < GameConstants::BFIELD_SIZE; i++)
 	{
@@ -1235,19 +1318,40 @@
 	return ret;
 }
 
-AttackableTiles CBattleInfoCallback::getPotentiallyAttackableHexes(const battle::Unit* attacker, BattleHex destinationTile, BattleHex attackerPos) const
+AttackableTiles CBattleInfoCallback::getPotentiallyAttackableHexes(
+	const battle::Unit * attacker,
+	BattleHex destinationTile,
+	BattleHex attackerPos) const
+{
+	const auto * defender = battleGetUnitByPos(destinationTile, true);
+
+	if(!defender)
+		return AttackableTiles(); // can't attack thin air
+
+	return getPotentiallyAttackableHexes(
+		attacker,
+		defender,
+		destinationTile,
+		attackerPos,
+		defender->getPosition());
+}
+
+AttackableTiles CBattleInfoCallback::getPotentiallyAttackableHexes(
+	const battle::Unit* attacker,
+	const battle::Unit * defender,
+	BattleHex destinationTile,
+	BattleHex attackerPos,
+	BattleHex defenderPos) const
 {
 	//does not return hex attacked directly
 	AttackableTiles at;
 	RETURN_IF_NOT_BATTLE(at);
 
 	BattleHex attackOriginHex = (attackerPos != BattleHex::INVALID) ? attackerPos : attacker->getPosition(); //real or hypothetical (cursor) position
-
-	const auto * defender = battleGetUnitByPos(destinationTile, true);
-	if (!defender)
-		return at; // can't attack thin air
-
-	bool reverse = isToReverse(attacker, defender);
+	
+	defenderPos = (defenderPos != BattleHex::INVALID) ? defenderPos : defender->getPosition(); //real or hypothetical (cursor) position
+	
+	bool reverse = isToReverse(attacker, defender, attackerPos, defenderPos);
 	if(reverse && attacker->doubleWide())
 	{
 		attackOriginHex = attacker->occupiedHex(attackOriginHex); //the other hex stack stands on
@@ -1288,32 +1392,51 @@
 				at.friendlyCreaturePositions.insert(tile);
 		}
 	}
-	else if(attacker->hasBonusOfType(BonusType::TWO_HEX_ATTACK_BREATH))
+	else if(attacker->hasBonusOfType(BonusType::TWO_HEX_ATTACK_BREATH) || attacker->hasBonusOfType(BonusType::PRISM_HEX_ATTACK_BREATH))
 	{
 		auto direction = BattleHex::mutualPosition(attackOriginHex, destinationTile);
-		if(direction != BattleHex::NONE) //only adjacent hexes are subject of dragon breath calculation
+		
+		if(direction == BattleHex::NONE
+			&& defender->doubleWide()
+			&& attacker->doubleWide()
+			&& defenderPos == destinationTile)
 		{
-			BattleHex nextHex = destinationTile.cloneInDirection(direction, false);
+			direction = BattleHex::mutualPosition(attackOriginHex, defender->occupiedHex(defenderPos));
+		}
 
-			if ( defender->doubleWide() )
+		for(int i = 0; i < 3; i++)
+		{
+			if(direction != BattleHex::NONE) //only adjacent hexes are subject of dragon breath calculation
 			{
-				auto secondHex = destinationTile == defender->getPosition() ?
-					defender->occupiedHex():
-					defender->getPosition();
+				BattleHex nextHex = destinationTile.cloneInDirection(direction, false);
 
-				// if targeted double-wide creature is attacked from above or below ( -> second hex is also adjacent to attack origin)
-				// then dragon breath should target tile on the opposite side of targeted creature
-				if (BattleHex::mutualPosition(attackOriginHex, secondHex) != BattleHex::NONE)
-					nextHex = secondHex.cloneInDirection(direction, false);
-			}
+				if ( defender->doubleWide() )
+				{
+					auto secondHex = destinationTile == defenderPos ? defender->occupiedHex(defenderPos) : defenderPos;
 
-			if (nextHex.isValid())
-			{
-				//friendly stacks can also be damaged by Dragon Breath
-				const auto * st = battleGetUnitByPos(nextHex, true);
-				if(st != nullptr)
-					at.friendlyCreaturePositions.insert(nextHex);
+					// if targeted double-wide creature is attacked from above or below ( -> second hex is also adjacent to attack origin)
+					// then dragon breath should target tile on the opposite side of targeted creature
+					if(BattleHex::mutualPosition(attackOriginHex, secondHex) != BattleHex::NONE)
+						nextHex = secondHex.cloneInDirection(direction, false);
+				}
+
+				if (nextHex.isValid())
+				{
+					//friendly stacks can also be damaged by Dragon Breath
+					const auto * st = battleGetUnitByPos(nextHex, true);
+					if(st != nullptr && st != attacker) //but not unit itself (doublewide + prism attack)
+						at.friendlyCreaturePositions.insert(nextHex);
+				}
 			}
+
+			if(!attacker->hasBonusOfType(BonusType::PRISM_HEX_ATTACK_BREATH))
+				break;
+
+			// only needed for prism
+			int tmpDirection = static_cast<int>(direction) + 2;
+			if(tmpDirection > static_cast<int>(BattleHex::EDir::LEFT))
+				tmpDirection -= static_cast<int>(BattleHex::EDir::TOP);
+			direction = static_cast<BattleHex::EDir>(tmpDirection);
 		}
 	}
 	return at;
@@ -1335,17 +1458,29 @@
 	return at;
 }
 
-std::vector<const battle::Unit*> CBattleInfoCallback::getAttackedBattleUnits(const battle::Unit* attacker, BattleHex destinationTile, bool rangedAttack, BattleHex attackerPos) const
+std::vector<const battle::Unit*> CBattleInfoCallback::getAttackedBattleUnits(
+	const battle::Unit * attacker,
+	const  battle::Unit * defender,
+	BattleHex destinationTile,
+	bool rangedAttack,
+	BattleHex attackerPos,
+	BattleHex defenderPos) const
 {
 	std::vector<const battle::Unit*> units;
 	RETURN_IF_NOT_BATTLE(units);
 
+	if(attackerPos == BattleHex::INVALID)
+		attackerPos = attacker->getPosition();
+
+	if(defenderPos == BattleHex::INVALID)
+		defenderPos = defender->getPosition();
+
 	AttackableTiles at;
 
 	if (rangedAttack)
 		at = getPotentiallyShootableHexes(attacker, destinationTile, attackerPos);
 	else
-		at = getPotentiallyAttackableHexes(attacker, destinationTile, attackerPos);
+		at = getPotentiallyAttackableHexes(attacker, defender, destinationTile, attackerPos, defenderPos);
 
 	units = battleGetUnitsIf([=](const battle::Unit * unit)
 	{
@@ -1371,7 +1506,7 @@
 	RETURN_IF_NOT_BATTLE(attackedCres);
 
 	AttackableTiles at;
-
+	
 	if(rangedAttack)
 		at = getPotentiallyShootableHexes(attacker, destinationTile, attackerPos);
 	else
@@ -1396,7 +1531,7 @@
 	return attackedCres;
 }
 
-static bool isHexInFront(BattleHex hex, BattleHex testHex, BattleSide::Type side )
+static bool isHexInFront(BattleHex hex, BattleHex testHex, BattleSide side )
 {
 	static const std::set<BattleHex::EDir> rightDirs { BattleHex::BOTTOM_RIGHT, BattleHex::TOP_RIGHT, BattleHex::RIGHT };
 	static const std::set<BattleHex::EDir> leftDirs  { BattleHex::BOTTOM_LEFT, BattleHex::TOP_LEFT, BattleHex::LEFT };
@@ -1410,26 +1545,36 @@
 }
 
 //TODO: this should apply also to mechanics and cursor interface
-bool CBattleInfoCallback::isToReverse(const battle::Unit * attacker, const battle::Unit * defender) const
+bool CBattleInfoCallback::isToReverse(const battle::Unit * attacker, const battle::Unit * defender, BattleHex attackerHex, BattleHex defenderHex) const
 {
-	BattleHex attackerHex = attacker->getPosition();
-	BattleHex defenderHex = defender->getPosition();
+	if(!defenderHex.isValid())
+		defenderHex = defender->getPosition();
+
+	if(!attackerHex.isValid())
+		attackerHex = attacker->getPosition();
 
 	if (attackerHex < 0 ) //turret
 		return false;
 
-	if(isHexInFront(attackerHex, defenderHex, static_cast<BattleSide::Type>(attacker->unitSide())))
+	if(isHexInFront(attackerHex, defenderHex, attacker->unitSide()))
 		return false;
 
+	auto defenderOtherHex = defenderHex;
+	auto attackerOtherHex = defenderHex;
+
 	if (defender->doubleWide())
 	{
-		if(isHexInFront(attackerHex, defender->occupiedHex(), static_cast<BattleSide::Type>(attacker->unitSide())))
+		defenderOtherHex = battle::Unit::occupiedHex(defenderHex, true, defender->unitSide());
+
+		if(isHexInFront(attackerHex, defenderOtherHex, attacker->unitSide()))
 			return false;
 	}
 
 	if (attacker->doubleWide())
 	{
-		if(isHexInFront(attacker->occupiedHex(), defenderHex, static_cast<BattleSide::Type>(attacker->unitSide())))
+		attackerOtherHex = battle::Unit::occupiedHex(attackerHex, true, attacker->unitSide());
+
+		if(isHexInFront(attackerOtherHex, defenderHex, attacker->unitSide()))
 			return false;
 	}
 
@@ -1437,7 +1582,7 @@
 	// but this is how H3 handles it which is important, e.g. for direction of dragon breath attacks
 	if (attacker->doubleWide() && defender->doubleWide())
 	{
-		if(isHexInFront(attacker->occupiedHex(), defender->occupiedHex(), static_cast<BattleSide::Type>(attacker->unitSide())))
+		if(isHexInFront(attackerOtherHex, defenderOtherHex, attacker->unitSide()))
 			return false;
 	}
 	return true;
@@ -1496,6 +1641,14 @@
 	return false;
 }
 
+bool CBattleInfoCallback::isHexWithinSpecifiedRange(BattleHex attackerPosition, BattleHex targetPosition, unsigned int range) const
+{
+	if(BattleHex::getDistance(attackerPosition, targetPosition) <= range)
+		return true;
+
+	return false;
+}
+
 BattleHex CBattleInfoCallback::wallPartToBattleHex(EWallPart part) const
 {
 	RETURN_IF_NOT_BATTLE(BattleHex::INVALID);
@@ -1522,7 +1675,7 @@
 	if(isWallPartPotentiallyAttackable(wallPart))
 	{
 		auto wallState = battleGetWallState(wallPart);
-		return (wallState == EWallState::REINFORCED || wallState == EWallState::INTACT || wallState == EWallState::DAMAGED);
+		return (wallState != EWallState::NONE && wallState != EWallState::DESTROYED);
 	}
 	return false;
 }
@@ -1602,7 +1755,7 @@
 	return ret;
 }
 
-SpellID CBattleInfoCallback::getRandomBeneficialSpell(CRandomGenerator & rand, const battle::Unit * caster, const battle::Unit * subject) const
+SpellID CBattleInfoCallback::getRandomBeneficialSpell(vstd::RNG & rand, const battle::Unit * caster, const battle::Unit * subject) const
 {
 	RETURN_IF_NOT_BATTLE(SpellID::NONE);
 	//This is complete list. No spells from mods.
@@ -1696,7 +1849,7 @@
 		case SpellID::PROTECTION_FROM_FIRE:
 		case SpellID::PROTECTION_FROM_WATER:
 		{
-			const ui8 enemySide = 1 - subject->unitSide();
+			const BattleSide enemySide = otherSide(subject->unitSide());
 			//todo: only if enemy has spellbook
 			if (!battleHasHero(enemySide)) //only if there is enemy hero
 				continue;
@@ -1748,7 +1901,7 @@
 	}
 }
 
-SpellID CBattleInfoCallback::getRandomCastedSpell(CRandomGenerator & rand,const CStack * caster) const
+SpellID CBattleInfoCallback::getRandomCastedSpell(vstd::RNG & rand,const CStack * caster) const
 {
 	RETURN_IF_NOT_BATTLE(SpellID::NONE);
 
@@ -1787,10 +1940,9 @@
 	if(!battleCanSurrender(Player))
 		return -1;
 
-	const auto sideOpt = playerToSide(Player);
-	if(!sideOpt)
+	const BattleSide side = playerToSide(Player);
+	if(side == BattleSide::NONE)
 		return -1;
-	const auto side = sideOpt.value();
 
 	int ret = 0;
 	double discount = 0;
@@ -1806,7 +1958,7 @@
 	return ret;
 }
 
-si8 CBattleInfoCallback::battleMinSpellLevel(ui8 side) const
+si8 CBattleInfoCallback::battleMinSpellLevel(BattleSide side) const
 {
 	const IBonusBearer * node = nullptr;
 	if(const CGHeroInstance * h = battleGetFightingHero(side))
@@ -1824,7 +1976,7 @@
 	return 0;
 }
 
-si8 CBattleInfoCallback::battleMaxSpellLevel(ui8 side) const
+si8 CBattleInfoCallback::battleMaxSpellLevel(BattleSide side) const
 {
 	const IBonusBearer *node = nullptr;
 	if(const CGHeroInstance * h = battleGetFightingHero(side))
@@ -1843,21 +1995,21 @@
 	return GameConstants::SPELL_LEVELS;
 }
 
-std::optional<int> CBattleInfoCallback::battleIsFinished() const
+std::optional<BattleSide> CBattleInfoCallback::battleIsFinished() const
 {
 	auto units = battleGetUnitsIf([=](const battle::Unit * unit)
 	{
 		return unit->alive() && !unit->isTurret() && !unit->hasBonusOfType(BonusType::SIEGE_WEAPON);
 	});
 
-	std::array<bool, 2> hasUnit = {false, false}; //index is BattleSide
+	BattleSideArray<bool> hasUnit = {false, false}; //index is BattleSide
 
 	for(auto & unit : units)
 	{
 		//todo: move SIEGE_WEAPON check to Unit state
 		hasUnit.at(unit->unitSide()) = true;
 
-		if(hasUnit[0] && hasUnit[1])
+		if(hasUnit[BattleSide::ATTACKER] && hasUnit[BattleSide::DEFENDER])
 			return std::nullopt;
 	}
 	
@@ -1871,12 +2023,12 @@
 		}
 	}
 
-	if(!hasUnit[0] && !hasUnit[1])
-		return 2;
-	if(!hasUnit[1])
-		return 0;
+	if(!hasUnit[BattleSide::ATTACKER] && !hasUnit[BattleSide::DEFENDER])
+		return BattleSide::NONE;
+	if(!hasUnit[BattleSide::DEFENDER])
+		return BattleSide::ATTACKER;
 	else
-		return 1;
+		return BattleSide::DEFENDER;
 }
 
 VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/battle/CBattleInfoCallback.h vcmi/lib/battle/CBattleInfoCallback.h
--- vcmi-1.5.7/lib/battle/CBattleInfoCallback.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/battle/CBattleInfoCallback.h	2024-12-19 15:00:22.889147566 +0100
@@ -23,9 +23,13 @@
 class CSpell;
 struct CObstacleInstance;
 class IBonusBearer;
-class CRandomGenerator;
 class PossiblePlayerBattleAction;
 
+namespace vstd
+{
+class RNG;
+}
+
 namespace spells
 {
 	class Caster;
@@ -52,7 +56,7 @@
 class DLL_LINKAGE CBattleInfoCallback : public virtual CBattleInfoEssentials
 {
 public:
-	std::optional<int> battleIsFinished() const override; //return none if battle is ongoing; otherwise the victorious side (0/1) or 2 if it is a draw
+	std::optional<BattleSide> battleIsFinished() const override; //return none if battle is ongoing; otherwise the victorious side (0/1) or 2 if it is a draw
 
 	std::vector<std::shared_ptr<const CObstacleInstance>> battleGetAllObstaclesOnPos(BattleHex tile, bool onlyBlocking = true) const override;
 	std::vector<std::shared_ptr<const CObstacleInstance>> getAllAffectedObstaclesByStack(const battle::Unit * unit, const std::set<BattleHex> & passed) const override;
@@ -66,9 +70,9 @@
 	///returns all alive units excluding turrets
 	battle::Units battleAliveUnits() const;
 	///returns all alive units from particular side excluding turrets
-	battle::Units battleAliveUnits(ui8 side) const;
+	battle::Units battleAliveUnits(BattleSide side) const;
 
-	void battleGetTurnOrder(std::vector<battle::Units> & out, const size_t maxUnits, const int maxTurns, const int turn = 0, int8_t lastMoved = -1) const;
+	void battleGetTurnOrder(std::vector<battle::Units> & out, const size_t maxUnits, const int maxTurns, const int turn = 0, BattleSide lastMoved = BattleSide::NONE) const;
 
 	///returns reachable hexes (valid movement destinations), DOES contain stack current position
 	std::vector<BattleHex> battleGetAvailableHexes(const battle::Unit * unit, bool obtainMovementRange, bool addOccupiable, std::vector<BattleHex> * attackable) const;
@@ -82,9 +86,11 @@
 	ReachabilityInfo::TDistances battleGetDistances(const battle::Unit * unit, BattleHex assumedPosition) const;
 	std::set<BattleHex> battleGetAttackedHexes(const battle::Unit * attacker, BattleHex destinationTile, BattleHex attackerPos = BattleHex::INVALID) const;
 	bool isEnemyUnitWithinSpecifiedRange(BattleHex attackerPosition, const battle::Unit * defenderUnit, unsigned int range) const;
+	bool isHexWithinSpecifiedRange(BattleHex attackerPosition, BattleHex targetPosition, unsigned int range) const;
 
 	std::pair< std::vector<BattleHex>, int > getPath(BattleHex start, BattleHex dest, const battle::Unit * stack) const;
 
+	bool battleCanTargetEmptyHex(const battle::Unit * attacker) const; //determines of stack with given ID can target empty hex to attack - currently used only for SPELL_LIKE_ATTACK shooting
 	bool battleCanAttack(const battle::Unit * stack, const battle::Unit * target, BattleHex dest) const; //determines if stack with given ID can attack target at the selected destination
 	bool battleCanShoot(const battle::Unit * attacker, BattleHex dest) const; //determines if stack with given ID shoot at the selected destination
 	bool battleCanShoot(const battle::Unit * attacker) const; //determines if stack with given ID shoot in principle
@@ -100,6 +106,7 @@
 	DamageEstimation battleEstimateDamage(const battle::Unit * attacker, const battle::Unit * defender, BattleHex attackerPosition, DamageEstimation * retaliationDmg = nullptr) const;
 	DamageEstimation battleEstimateDamage(const battle::Unit * attacker, const battle::Unit * defender, int getMovementRange, DamageEstimation * retaliationDmg = nullptr) const;
 
+	bool battleIsInsideWalls(BattleHex from) const;
 	bool battleHasPenaltyOnLine(BattleHex from, BattleHex dest, bool checkWall, bool checkMoat) const;
 	bool battleHasDistancePenalty(const IBonusBearer * shooter, BattleHex shooterPosition, BattleHex destHex) const;
 	bool battleHasWallPenalty(const IBonusBearer * shooter, BattleHex shooterPosition, BattleHex destHex) const;
@@ -111,13 +118,13 @@
 	bool isWallPartAttackable(EWallPart wallPart) const; // returns true if the wall part is actually attackable, false if not
 	std::vector<BattleHex> getAttackableBattleHexes() const;
 
-	si8 battleMinSpellLevel(ui8 side) const; //calculates maximum spell level possible to be cast on battlefield - takes into account artifacts of both heroes; if no effects are set, 0 is returned
-	si8 battleMaxSpellLevel(ui8 side) const; //calculates minimum spell level possible to be cast on battlefield - takes into account artifacts of both heroes; if no effects are set, 0 is returned
+	si8 battleMinSpellLevel(BattleSide side) const; //calculates maximum spell level possible to be cast on battlefield - takes into account artifacts of both heroes; if no effects are set, 0 is returned
+	si8 battleMaxSpellLevel(BattleSide side) const; //calculates minimum spell level possible to be cast on battlefield - takes into account artifacts of both heroes; if no effects are set, 0 is returned
 	int32_t battleGetSpellCost(const spells::Spell * sp, const CGHeroInstance * caster) const; //returns cost of given spell
 	ESpellCastProblem battleCanCastSpell(const spells::Caster * caster, spells::Mode mode) const; //returns true if there are no general issues preventing from casting a spell
 
-	SpellID getRandomBeneficialSpell(CRandomGenerator & rand, const battle::Unit * caster, const battle::Unit * target) const;
-	SpellID getRandomCastedSpell(CRandomGenerator & rand, const CStack * caster) const; //called at the beginning of turn for Faerie Dragon
+	SpellID getRandomBeneficialSpell(vstd::RNG & rand, const battle::Unit * caster, const battle::Unit * target) const;
+	SpellID getRandomCastedSpell(vstd::RNG & rand, const CStack * caster) const; //called at the beginning of turn for Faerie Dragon
 
 	std::vector<PossiblePlayerBattleAction> getClientActionsForStack(const CStack * stack, const BattleClientInterfaceData & data);
 	PossiblePlayerBattleAction getCasterAction(const CSpell * spell, const spells::Caster * caster, spells::Mode mode) const;
@@ -126,25 +133,44 @@
 	bool isInTacticRange(BattleHex dest) const;
 	si8 battleGetTacticDist() const; //returns tactic distance for calling player or 0 if this player is not in tactic phase (for ALL_KNOWING actual distance for tactic side)
 
-	AttackableTiles getPotentiallyAttackableHexes(const  battle::Unit* attacker, BattleHex destinationTile, BattleHex attackerPos) const; //TODO: apply rotation to two-hex attacker
+	AttackableTiles getPotentiallyAttackableHexes(
+		const  battle::Unit* attacker,
+		const  battle::Unit* defender,
+		BattleHex destinationTile,
+		BattleHex attackerPos,
+		BattleHex defenderPos) const; //TODO: apply rotation to two-hex attacker
+
+	AttackableTiles getPotentiallyAttackableHexes(
+		const  battle::Unit * attacker,
+		BattleHex destinationTile,
+		BattleHex attackerPos) const;
+
 	AttackableTiles getPotentiallyShootableHexes(const  battle::Unit* attacker, BattleHex destinationTile, BattleHex attackerPos) const;
-	std::vector<const battle::Unit *> getAttackedBattleUnits(const battle::Unit* attacker, BattleHex destinationTile, bool rangedAttack, BattleHex attackerPos = BattleHex::INVALID) const; //calculates range of multi-hex attacks
+
+	std::vector<const battle::Unit *> getAttackedBattleUnits(
+		const battle::Unit* attacker,
+		const  battle::Unit * defender,
+		BattleHex destinationTile,
+		bool rangedAttack,
+		BattleHex attackerPos = BattleHex::INVALID,
+		BattleHex defenderPos = BattleHex::INVALID) const; //calculates range of multi-hex attacks
+	
 	std::set<const CStack*> getAttackedCreatures(const CStack* attacker, BattleHex destinationTile, bool rangedAttack, BattleHex attackerPos = BattleHex::INVALID) const; //calculates range of multi-hex attacks
-	bool isToReverse(const battle::Unit * attacker, const battle::Unit * defender) const; //determines if attacker standing at attackerHex should reverse in order to attack defender
+	bool isToReverse(const battle::Unit * attacker, const battle::Unit * defender, BattleHex attackerHex = BattleHex::INVALID, BattleHex defenderHex = BattleHex::INVALID) const; //determines if attacker standing at attackerHex should reverse in order to attack defender
 
 	ReachabilityInfo getReachability(const battle::Unit * unit) const;
 	ReachabilityInfo getReachability(const ReachabilityInfo::Parameters & params) const;
-	AccessibilityInfo getAccesibility() const;
-	AccessibilityInfo getAccesibility(const battle::Unit * stack) const; //Hexes ocupied by stack will be marked as accessible.
-	AccessibilityInfo getAccesibility(const std::vector<BattleHex> & accessibleHexes) const; //given hexes will be marked as accessible
+	AccessibilityInfo getAccessibility() const;
+	AccessibilityInfo getAccessibility(const battle::Unit * stack) const; //Hexes occupied by stack will be marked as accessible.
+	AccessibilityInfo getAccessibility(const std::vector<BattleHex> & accessibleHexes) const; //given hexes will be marked as accessible
 	std::pair<const battle::Unit *, BattleHex> getNearestStack(const battle::Unit * closest) const;
 
-	BattleHex getAvaliableHex(const CreatureID & creID, ui8 side, int initialPos = -1) const; //find place for adding new stack
+	BattleHex getAvailableHex(const CreatureID & creID, BattleSide side, int initialPos = -1) const; //find place for adding new stack
 protected:
 	ReachabilityInfo getFlyingReachability(const ReachabilityInfo::Parameters & params) const;
 	ReachabilityInfo makeBFS(const AccessibilityInfo & accessibility, const ReachabilityInfo::Parameters & params) const;
 	bool isInObstacle(BattleHex hex, const std::set<BattleHex> & obstacles, const ReachabilityInfo::Parameters & params) const;
-	std::set<BattleHex> getStoppers(BattlePerspective::BattlePerspective whichSidePerspective) const; //get hexes with stopping obstacles (quicksands)
+	std::set<BattleHex> getStoppers(BattleSide whichSidePerspective) const; //get hexes with stopping obstacles (quicksands)
 };
 
 VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/battle/CBattleInfoEssentials.cpp vcmi/lib/battle/CBattleInfoEssentials.cpp
--- vcmi-1.5.7/lib/battle/CBattleInfoEssentials.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/battle/CBattleInfoEssentials.cpp	2024-12-19 15:00:22.890147607 +0100
@@ -9,12 +9,15 @@
  */
 #include "StdInc.h"
 #include "CBattleInfoEssentials.h"
+
 #include "../CStack.h"
 #include "BattleInfo.h"
 #include "CObstacleInstance.h"
-#include "../mapObjects/CGTownInstance.h"
-#include "../gameState/InfoAboutArmy.h"
+
 #include "../constants/EntityIdentifiers.h"
+#include "../entities/building/TownFortifications.h"
+#include "../gameState/InfoAboutArmy.h"
+#include "../mapObjects/CGTownInstance.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
@@ -35,13 +38,13 @@
 	return getBattle()->getBattlefieldType();
 }
 
-int32_t CBattleInfoEssentials::battleGetEnchanterCounter(ui8 side) const
+int32_t CBattleInfoEssentials::battleGetEnchanterCounter(BattleSide side) const
 {
 	RETURN_IF_NOT_BATTLE(0);
 	return getBattle()->getEnchanterCounter(side);
 }
 
-std::vector<std::shared_ptr<const CObstacleInstance>> CBattleInfoEssentials::battleGetAllObstacles(std::optional<BattlePerspective::BattlePerspective> perspective) const
+std::vector<std::shared_ptr<const CObstacleInstance>> CBattleInfoEssentials::battleGetAllObstacles(std::optional<BattleSide> perspective) const
 {
 	std::vector<std::shared_ptr<const CObstacleInstance> > ret;
 	RETURN_IF_NOT_BATTLE(ret);
@@ -82,13 +85,13 @@
 	return std::shared_ptr<const CObstacleInstance>();
 }
 
-bool CBattleInfoEssentials::battleIsObstacleVisibleForSide(const CObstacleInstance & coi, BattlePerspective::BattlePerspective side) const
+bool CBattleInfoEssentials::battleIsObstacleVisibleForSide(const CObstacleInstance & coi, BattleSide side) const
 {
 	RETURN_IF_NOT_BATTLE(false);
-	return side == BattlePerspective::ALL_KNOWING || coi.visibleForSide(side, battleHasNativeStack(side));
+	return side == BattleSide::ALL_KNOWING || coi.visibleForSide(side, battleHasNativeStack(side));
 }
 
-bool CBattleInfoEssentials::battleHasNativeStack(ui8 side) const
+bool CBattleInfoEssentials::battleHasNativeStack(BattleSide side) const
 {
 	RETURN_IF_NOT_BATTLE(false);
 
@@ -160,18 +163,18 @@
 	return getBattle()->getDefendedTown();
 }
 
-BattlePerspective::BattlePerspective CBattleInfoEssentials::battleGetMySide() const
+BattleSide CBattleInfoEssentials::battleGetMySide() const
 {
-	RETURN_IF_NOT_BATTLE(BattlePerspective::INVALID);
+	RETURN_IF_NOT_BATTLE(BattleSide::INVALID);
 	if(!getPlayerID() || getPlayerID()->isSpectator())
-		return BattlePerspective::ALL_KNOWING;
+		return BattleSide::ALL_KNOWING;
 	if(*getPlayerID() == getBattle()->getSidePlayer(BattleSide::ATTACKER))
-		return BattlePerspective::LEFT_SIDE;
+		return BattleSide::LEFT_SIDE;
 	if(*getPlayerID() == getBattle()->getSidePlayer(BattleSide::DEFENDER))
-		return BattlePerspective::RIGHT_SIDE;
+		return BattleSide::RIGHT_SIDE;
 
 	logGlobal->error("Cannot find player %s in battle!", getPlayerID()->toString());
-	return BattlePerspective::INVALID;
+	return BattleSide::INVALID;
 }
 
 const CStack* CBattleInfoEssentials::battleGetStackByID(int ID, bool onlyAlive) const
@@ -189,11 +192,11 @@
 		return stacks[0];
 }
 
-bool CBattleInfoEssentials::battleDoWeKnowAbout(ui8 side) const
+bool CBattleInfoEssentials::battleDoWeKnowAbout(BattleSide side) const
 {
 	RETURN_IF_NOT_BATTLE(false);
 	auto p = battleGetMySide();
-	return p == BattlePerspective::ALL_KNOWING || p == side;
+	return p == BattleSide::ALL_KNOWING || p == side;
 }
 
 si8 CBattleInfoEssentials::battleTacticDist() const
@@ -202,16 +205,16 @@
 	return getBattle()->getTacticDist();
 }
 
-si8 CBattleInfoEssentials::battleGetTacticsSide() const
+BattleSide CBattleInfoEssentials::battleGetTacticsSide() const
 {
-	RETURN_IF_NOT_BATTLE(-1);
+	RETURN_IF_NOT_BATTLE(BattleSide::NONE);
 	return getBattle()->getTacticsSide();
 }
 
-const CGHeroInstance * CBattleInfoEssentials::battleGetFightingHero(ui8 side) const
+const CGHeroInstance * CBattleInfoEssentials::battleGetFightingHero(BattleSide side) const
 {
 	RETURN_IF_NOT_BATTLE(nullptr);
-	if(side > 1)
+	if(side != BattleSide::DEFENDER && side != BattleSide::ATTACKER)
 	{
 		logGlobal->error("FIXME: %s wrong argument!", __FUNCTION__);
 		return nullptr;
@@ -226,10 +229,10 @@
 	return getBattle()->getSideHero(side);
 }
 
-const CArmedInstance * CBattleInfoEssentials::battleGetArmyObject(ui8 side) const
+const CArmedInstance * CBattleInfoEssentials::battleGetArmyObject(BattleSide side) const
 {
 	RETURN_IF_NOT_BATTLE(nullptr);
-	if(side > 1)
+	if(side != BattleSide::DEFENDER && side != BattleSide::ATTACKER)
 	{
 		logGlobal->error("FIXME: %s wrong argument!", __FUNCTION__);
 		return nullptr;
@@ -242,7 +245,7 @@
 	return getBattle()->getSideArmy(side);
 }
 
-InfoAboutHero CBattleInfoEssentials::battleGetHeroInfo(ui8 side) const
+InfoAboutHero CBattleInfoEssentials::battleGetHeroInfo(BattleSide side) const
 {
 	const auto * hero = getBattle()->getSideHero(side);
 	if(!hero)
@@ -253,7 +256,7 @@
 	return InfoAboutHero(hero, infoLevel);
 }
 
-uint32_t CBattleInfoEssentials::battleCastSpells(ui8 side) const
+uint32_t CBattleInfoEssentials::battleCastSpells(BattleSide side) const
 {
 	RETURN_IF_NOT_BATTLE(-1);
 	return getBattle()->getCastSpells(side);
@@ -268,10 +271,10 @@
 {
 	RETURN_IF_NOT_BATTLE(false);
 	const auto side = playerToSide(player);
-	if(!side)
+	if(side == BattleSide::NONE)
 		return false;
 
-	const CGHeroInstance * myHero = battleGetFightingHero(side.value());
+	const CGHeroInstance * myHero = battleGetFightingHero(side);
 
 	//current player have no hero
 	if(!myHero)
@@ -292,28 +295,28 @@
 	return true;
 }
 
-BattleSideOpt CBattleInfoEssentials::playerToSide(const PlayerColor & player) const
+BattleSide CBattleInfoEssentials::playerToSide(const PlayerColor & player) const
 {
-	RETURN_IF_NOT_BATTLE(std::nullopt);
+	RETURN_IF_NOT_BATTLE(BattleSide::NONE);
 
 	if(getBattle()->getSidePlayer(BattleSide::ATTACKER) == player)
-		return BattleSideOpt(BattleSide::ATTACKER);
+		return BattleSide::ATTACKER;
 
 	if(getBattle()->getSidePlayer(BattleSide::DEFENDER) == player)
-		return BattleSideOpt(BattleSide::DEFENDER);
+		return BattleSide::DEFENDER;
 
 	logGlobal->warn("Cannot find side for player %s", player.toString());
 
-	return std::nullopt;
+	return BattleSide::INVALID;
 }
 
-PlayerColor CBattleInfoEssentials::sideToPlayer(ui8 side) const
+PlayerColor CBattleInfoEssentials::sideToPlayer(BattleSide side) const
 {
 	RETURN_IF_NOT_BATTLE(PlayerColor::CANNOT_DETERMINE);
     return getBattle()->getSidePlayer(side);
 }
 
-ui8 CBattleInfoEssentials::otherSide(ui8 side) const
+BattleSide CBattleInfoEssentials::otherSide(BattleSide side)
 {
 	if(side == BattleSide::ATTACKER)
 		return BattleSide::DEFENDER;
@@ -326,43 +329,43 @@
 	RETURN_IF_NOT_BATTLE(PlayerColor::CANNOT_DETERMINE);
 
 	auto side = playerToSide(player);
-    if(!side)
+	if(side == BattleSide::NONE)
 		return PlayerColor::CANNOT_DETERMINE;
 
-	return getBattle()->getSidePlayer(otherSide(side.value()));
+	return getBattle()->getSidePlayer(otherSide(side));
 }
 
 bool CBattleInfoEssentials::playerHasAccessToHeroInfo(const PlayerColor & player, const CGHeroInstance * h) const
 {
 	RETURN_IF_NOT_BATTLE(false);
 	const auto side = playerToSide(player);
-	if(side)
+	if(side != BattleSide::NONE)
 	{
-		auto opponentSide = otherSide(side.value());
+		auto opponentSide = otherSide(side);
 		if(getBattle()->getSideHero(opponentSide) == h)
 			return true;
 	}
 	return false;
 }
 
-ui8 CBattleInfoEssentials::battleGetSiegeLevel() const
+TownFortifications CBattleInfoEssentials::battleGetFortifications() const
 {
-	RETURN_IF_NOT_BATTLE(CGTownInstance::NONE);
-	return getBattle()->getDefendedTown() ? getBattle()->getDefendedTown()->fortLevel() : CGTownInstance::NONE;
+	RETURN_IF_NOT_BATTLE(TownFortifications());
+	return getBattle()->getDefendedTown() ? getBattle()->getDefendedTown()->fortificationsLevel() : TownFortifications();
 }
 
 bool CBattleInfoEssentials::battleCanSurrender(const PlayerColor & player) const
 {
 	RETURN_IF_NOT_BATTLE(false);
 	const auto side = playerToSide(player);
-	if(!side)
+	if(side == BattleSide::NONE)
 		return false;
-	bool iAmSiegeDefender = (side.value() == BattleSide::DEFENDER && getBattle()->getDefendedTown() != nullptr);
+	bool iAmSiegeDefender = (side == BattleSide::DEFENDER && getBattle()->getDefendedTown() != nullptr);
 	//conditions like for fleeing (except escape tunnel presence) + enemy must have a hero
-	return battleCanFlee(player) && !iAmSiegeDefender && battleHasHero(otherSide(side.value()));
+	return battleCanFlee(player) && !iAmSiegeDefender && battleHasHero(otherSide(side));
 }
 
-bool CBattleInfoEssentials::battleHasHero(ui8 side) const
+bool CBattleInfoEssentials::battleHasHero(BattleSide side) const
 {
 	RETURN_IF_NOT_BATTLE(false);
 	return getBattle()->getSideHero(side) != nullptr;
@@ -371,7 +374,7 @@
 EWallState CBattleInfoEssentials::battleGetWallState(EWallPart partOfWall) const
 {
 	RETURN_IF_NOT_BATTLE(EWallState::NONE);
-	if(battleGetSiegeLevel() == CGTownInstance::NONE)
+	if(battleGetFortifications().wallsHealth == 0)
 		return EWallState::NONE;
 
 	return getBattle()->getWallState(partOfWall);
@@ -380,7 +383,7 @@
 EGateState CBattleInfoEssentials::battleGetGateState() const
 {
 	RETURN_IF_NOT_BATTLE(EGateState::NONE);
-	if(battleGetSiegeLevel() == CGTownInstance::NONE)
+	if(battleGetFortifications().wallsHealth == 0)
 		return EGateState::NONE;
 
 	return getBattle()->getGateState();
@@ -389,7 +392,7 @@
 bool CBattleInfoEssentials::battleIsGatePassable() const
 {
 	RETURN_IF_NOT_BATTLE(true);
-	if(battleGetSiegeLevel() == CGTownInstance::NONE)
+	if(battleGetFortifications().wallsHealth == 0)
 		return true;
 
 	return battleGetGateState() == EGateState::OPENED || battleGetGateState() == EGateState::DESTROYED; 
@@ -413,9 +416,9 @@
 {
 	RETURN_IF_NOT_BATTLE(nullptr);
 	const auto side = playerToSide(battleGetOwner(unit));
-	if(!side)
+	if(side == BattleSide::NONE)
 		return nullptr;
-	return getBattle()->getSideHero(side.value());
+	return getBattle()->getSideHero(side);
 }
 
 bool CBattleInfoEssentials::battleMatchOwner(const battle::Unit * attacker, const battle::Unit * defender, const boost::logic::tribool positivness) const
diff --color -urN vcmi-1.5.7/lib/battle/CBattleInfoEssentials.h vcmi/lib/battle/CBattleInfoEssentials.h
--- vcmi-1.5.7/lib/battle/CBattleInfoEssentials.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/battle/CBattleInfoEssentials.h	2024-12-19 15:00:22.890147607 +0100
@@ -9,6 +9,7 @@
  */
 #pragma once
 #include "IBattleInfoCallback.h"
+#include "BattleSide.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
@@ -17,26 +18,16 @@
 class CStack;
 class IBonusBearer;
 struct InfoAboutHero;
+struct TownFortifications;
 class CArmedInstance;
 
 using TStacks = std::vector<const CStack *>;
 using TStackFilter = std::function<bool (const CStack *)>;
 
-namespace BattlePerspective
-{
-	enum BattlePerspective
-	{
-		INVALID = -2,
-		ALL_KNOWING = -1,
-		LEFT_SIDE,
-		RIGHT_SIDE
-	};
-}
-
 class DLL_LINKAGE CBattleInfoEssentials : public IBattleInfoCallback
 {
 protected:
-	bool battleDoWeKnowAbout(ui8 side) const;
+	bool battleDoWeKnowAbout(BattleSide side) const;
 
 public:
 	enum EStackOwnership
@@ -45,14 +36,14 @@
 	};
 
 	bool duringBattle() const;
-	BattlePerspective::BattlePerspective battleGetMySide() const;
+	BattleSide battleGetMySide() const;
 	const IBonusBearer * getBonusBearer() const override;
 
 	TerrainId battleTerrainType() const override;
 	BattleField battleGetBattlefieldType() const override;
-	int32_t battleGetEnchanterCounter(ui8 side) const;
+	int32_t battleGetEnchanterCounter(BattleSide side) const;
 
-	std::vector<std::shared_ptr<const CObstacleInstance>> battleGetAllObstacles(std::optional<BattlePerspective::BattlePerspective> perspective = std::nullopt) const; //returns all obstacles on the battlefield
+	std::vector<std::shared_ptr<const CObstacleInstance>> battleGetAllObstacles(std::optional<BattleSide> perspective = std::nullopt) const; //returns all obstacles on the battlefield
 
 	std::shared_ptr<const CObstacleInstance> battleGetObstacleByID(uint32_t ID) const;
 
@@ -70,27 +61,27 @@
 
 	uint32_t battleNextUnitId() const override;
 
-	bool battleHasNativeStack(ui8 side) const;
+	bool battleHasNativeStack(BattleSide side) const;
 	const CGTownInstance * battleGetDefendedTown() const; //returns defended town if current battle is a siege, nullptr instead
 
 	si8 battleTacticDist() const override; //returns tactic distance in current tactics phase; 0 if not in tactics phase
-	si8 battleGetTacticsSide() const override; //returns which side is in tactics phase, undefined if none (?)
+	BattleSide battleGetTacticsSide() const override; //returns which side is in tactics phase, undefined if none (?)
 
 	bool battleCanFlee(const PlayerColor & player) const;
 	bool battleCanSurrender(const PlayerColor & player) const;
 
-	ui8 otherSide(ui8 side) const;
+	static BattleSide otherSide(BattleSide side);
 	PlayerColor otherPlayer(const PlayerColor & player) const;
 
-	BattleSideOpt playerToSide(const PlayerColor & player) const;
-	PlayerColor sideToPlayer(ui8 side) const;
+	BattleSide playerToSide(const PlayerColor & player) const;
+	PlayerColor sideToPlayer(BattleSide side) const;
 	bool playerHasAccessToHeroInfo(const PlayerColor & player, const CGHeroInstance * h) const;
-	ui8 battleGetSiegeLevel() const; //returns 0 when there is no siege, 1 if fort, 2 is citadel, 3 is castle
-	bool battleHasHero(ui8 side) const;
-	uint32_t battleCastSpells(ui8 side) const; //how many spells has given side cast
-	const CGHeroInstance * battleGetFightingHero(ui8 side) const; //deprecated for players callback, easy to get wrong
-	const CArmedInstance * battleGetArmyObject(ui8 side) const;
-	InfoAboutHero battleGetHeroInfo(ui8 side) const;
+	TownFortifications battleGetFortifications() const;
+	bool battleHasHero(BattleSide side) const;
+	uint32_t battleCastSpells(BattleSide side) const; //how many spells has given side cast
+	const CGHeroInstance * battleGetFightingHero(BattleSide side) const; //deprecated for players callback, easy to get wrong
+	const CArmedInstance * battleGetArmyObject(BattleSide side) const;
+	InfoAboutHero battleGetHeroInfo(BattleSide side) const;
 
 	// for determining state of a part of the wall; format: parameter [0] - keep, [1] - bottom tower, [2] - bottom wall,
 	// [3] - below gate, [4] - over gate, [5] - upper wall, [6] - uppert tower, [7] - gate; returned value: 1 - intact, 2 - damaged, 3 - destroyed; 0 - no battle
@@ -103,7 +94,7 @@
 	TStacks battleGetAllStacks(bool includeTurrets = false) const;
 
 	const CStack * battleGetStackByID(int ID, bool onlyAlive = true) const; //returns stack info by given ID
-	bool battleIsObstacleVisibleForSide(const CObstacleInstance & coi, BattlePerspective::BattlePerspective side) const;
+	bool battleIsObstacleVisibleForSide(const CObstacleInstance & coi, BattleSide side) const;
 
 	///returns player that controls given stack; mind control included
 	PlayerColor battleGetOwner(const battle::Unit * unit) const;
diff --color -urN vcmi-1.5.7/lib/battle/CObstacleInstance.cpp vcmi/lib/battle/CObstacleInstance.cpp
--- vcmi-1.5.7/lib/battle/CObstacleInstance.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/battle/CObstacleInstance.cpp	2024-12-19 15:00:22.890147607 +0100
@@ -9,8 +9,6 @@
  */
 #include "StdInc.h"
 #include "CObstacleInstance.h"
-#include "../CHeroHandler.h"
-#include "../CTownHandler.h"
 #include "../ObstacleHandler.h"
 #include "../VCMI_Lib.h"
 
@@ -53,7 +51,7 @@
 	}
 }
 
-bool CObstacleInstance::visibleForSide(ui8 side, bool hasNativeStack) const
+bool CObstacleInstance::visibleForSide(BattleSide side, bool hasNativeStack) const
 {
 	//by default obstacle is visible for everyone
 	return true;
@@ -107,7 +105,6 @@
 
 void CObstacleInstance::serializeJson(JsonSerializeFormat & handler)
 {
-	auto obstacleInfo = getInfo();
 	auto hidden = false;
 	auto needAnimationOffsetFix = obstacleType == CObstacleInstance::USUAL;
 	int animationYOffset = 0;
@@ -117,11 +114,7 @@
 
 	//We need only a subset of obstacle info for correct render
 	handler.serializeInt("position", pos);
-	handler.serializeStruct("appearSound", obstacleInfo.appearSound);
-	handler.serializeStruct("appearAnimation", obstacleInfo.appearAnimation);
-	handler.serializeStruct("animation", obstacleInfo.animation);
 	handler.serializeInt("animationYOffset", animationYOffset);
-
 	handler.serializeBool("hidden", hidden);
 	handler.serializeBool("needAnimationOffsetFix", needAnimationOffsetFix);
 }
@@ -140,7 +133,7 @@
 	: turnsRemaining(-1),
 	casterSpellPower(0),
 	spellLevel(0),
-	casterSide(0),
+	casterSide(BattleSide::NONE),
 	hidden(false),
 	passable(false),
 	trigger(false),
@@ -154,7 +147,7 @@
 	obstacleType = SPELL_CREATED;
 }
 
-bool SpellCreatedObstacle::visibleForSide(ui8 side, bool hasNativeStack) const
+bool SpellCreatedObstacle::visibleForSide(BattleSide side, bool hasNativeStack) const
 {
 	//we hide mines and not discovered quicksands
 	//quicksands are visible to the caster or if owned unit stepped into that particular patch
diff --color -urN vcmi-1.5.7/lib/battle/CObstacleInstance.h vcmi/lib/battle/CObstacleInstance.h
--- vcmi-1.5.7/lib/battle/CObstacleInstance.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/battle/CObstacleInstance.h	2024-12-19 15:00:22.890147607 +0100
@@ -9,9 +9,11 @@
  */
 #pragma once
 #include "BattleHex.h"
+
+#include "../constants/EntityIdentifiers.h"
 #include "../filesystem/ResourcePath.h"
 #include "../networkPacks/BattleChanges.h"
-#include "../constants/EntityIdentifiers.h"
+#include "../serializer/Serializeable.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
@@ -20,7 +22,7 @@
 class JsonSerializeFormat;
 class SpellID;
 
-struct DLL_LINKAGE CObstacleInstance
+struct DLL_LINKAGE CObstacleInstance : public Serializeable
 {
 	enum EObstacleType : ui8
 	{
@@ -48,7 +50,7 @@
 	virtual SpellID getTrigger() const;
 
 	virtual std::vector<BattleHex> getAffectedTiles() const;
-	virtual bool visibleForSide(ui8 side, bool hasNativeStack) const; //0 attacker
+	virtual bool visibleForSide(BattleSide side, bool hasNativeStack) const; //0 attacker
 
 	virtual void battleTurnPassed(){};
 
@@ -78,7 +80,7 @@
 	int32_t casterSpellPower;
 	int32_t spellLevel;
 	int32_t minimalDamage; //How many damage should it do regardless of power and level of caster
-	si8 casterSide; //0 - obstacle created by attacker; 1 - by defender
+	BattleSide casterSide;
 
 	SpellID trigger;
 
@@ -100,7 +102,7 @@
 	SpellCreatedObstacle();
 
 	std::vector<BattleHex> getAffectedTiles() const override;
-	bool visibleForSide(ui8 side, bool hasNativeStack) const override;
+	bool visibleForSide(BattleSide side, bool hasNativeStack) const override;
 
 	bool blocksTiles() const override;
 	bool stopsMovement() const override;
diff --color -urN vcmi-1.5.7/lib/battle/CPlayerBattleCallback.cpp vcmi/lib/battle/CPlayerBattleCallback.cpp
--- vcmi-1.5.7/lib/battle/CPlayerBattleCallback.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/battle/CPlayerBattleCallback.cpp	2024-12-19 15:00:22.890147607 +0100
@@ -76,7 +76,7 @@
 
 InfoAboutHero CPlayerBattleCallback::battleGetEnemyHero() const
 {
-	return battleGetHeroInfo(!battleGetMySide());
+	return battleGetHeroInfo(otherSide(battleGetMySide()));
 }
 
 
diff --color -urN vcmi-1.5.7/lib/battle/CUnitState.cpp vcmi/lib/battle/CUnitState.cpp
--- vcmi-1.5.7/lib/battle/CUnitState.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/battle/CUnitState.cpp	2024-12-19 15:00:22.890147607 +0100
@@ -14,7 +14,6 @@
 #include <vcmi/spells/Spell.h>
 
 #include "../CCreatureHandler.h"
-#include "../MetaString.h"
 
 #include "../serializer/JsonDeserializer.h"
 #include "../serializer/JsonSerializer.h"
@@ -140,7 +139,7 @@
 	if(noRetaliation.getHasBonus())
 		return 0;
 
-	//after dispell bonus should remain during current round
+	//after dispel bonus should remain during current round
 	int32_t val = 1 + totalProxy->totalValue();
 	vstd::amax(totalCache, val);
 	return totalCache;
@@ -228,7 +227,7 @@
 	addResurrected(getCount() - oldCount);
 }
 
-void CHealth::heal(int64_t & amount, EHealLevel level, EHealPower power)
+HealInfo CHealth::heal(int64_t & amount, EHealLevel level, EHealPower power)
 {
 	const int32_t unitHealth = owner->getMaxHealth();
 	const int32_t oldCount = getCount();
@@ -252,7 +251,7 @@
 	vstd::abetween(amount, int64_t(0), maxHeal);
 
 	if(amount == 0)
-		return;
+		return {};
 
 	int64_t availableHealth = available();
 
@@ -263,6 +262,8 @@
 		addResurrected(getCount() - oldCount);
 	else
 		assert(power == EHealPower::PERMANENT);
+
+	return HealInfo(amount, getCount() - oldCount);
 }
 
 void CHealth::setFromTotal(const int64_t totalHealth)
@@ -329,6 +330,7 @@
 	drainedMana(false),
 	fear(false),
 	hadMorale(false),
+	castSpellThisTurn(false),
 	ghost(false),
 	ghostPending(false),
 	movedThisRound(false),
@@ -361,6 +363,7 @@
 	drainedMana = other.drainedMana;
 	fear = other.fear;
 	hadMorale = other.hadMorale;
+	castSpellThisTurn = other.castSpellThisTurn;
 	ghost = other.ghost;
 	ghostPending = other.ghostPending;
 	movedThisRound = other.movedThisRound;
@@ -413,9 +416,9 @@
 	return unitType()->getIconIndex();
 }
 
-FactionID CUnitState::getFaction() const
+FactionID CUnitState::getFactionID() const
 {
-	return unitType()->getFaction();
+	return unitType()->getFactionID();
 }
 
 int32_t CUnitState::getCasterUnitId() const
@@ -531,7 +534,7 @@
 
 bool CUnitState::canCast() const
 {
-	return casts.canUse(1);//do not check specific cast abilities here
+	return casts.canUse(1) && !castSpellThisTurn;//do not check specific cast abilities here
 }
 
 bool CUnitState::isCaster() const
@@ -747,6 +750,7 @@
 	handler.serializeBool("drainedMana", drainedMana);
 	handler.serializeBool("fear", fear);
 	handler.serializeBool("hadMorale", hadMorale);
+	handler.serializeBool("castSpellThisTurn", castSpellThisTurn);
 	handler.serializeBool("ghost", ghost);
 	handler.serializeBool("ghostPending", ghostPending);
 	handler.serializeBool("moved", movedThisRound);
@@ -781,6 +785,7 @@
 	drainedMana = false;
 	fear = false;
 	hadMorale = false;
+	castSpellThisTurn = false;
 	ghost = false;
 	ghostPending = false;
 	movedThisRound = false;
@@ -830,18 +835,21 @@
 		health.damage(amount);
 	}
 
-	if(health.available() <= 0 && (cloned || summoned))
+	bool disintegrate = hasBonusOfType(BonusType::DISINTEGRATE);
+	if(health.available() <= 0 && (cloned || summoned || disintegrate))
 		ghostPending = true;
 }
 
-void CUnitState::heal(int64_t & amount, EHealLevel level, EHealPower power)
+HealInfo CUnitState::heal(int64_t & amount, EHealLevel level, EHealPower power)
 {
 	if(level == EHealLevel::HEAL && power == EHealPower::ONE_BATTLE)
 		logGlobal->error("Heal for one battle does not make sense");
 	else if(cloned)
 		logGlobal->error("Attempt to heal clone");
 	else
-		health.heal(amount, level, power);
+		return health.heal(amount, level, power);
+
+	return {};
 }
 
 void CUnitState::afterAttack(bool ranged, bool counter)
@@ -860,6 +868,7 @@
 	waitedThisTurn = false;
 	movedThisRound = false;
 	hadMorale = false;
+	castSpellThisTurn = false;
 	fear = false;
 	drainedMana = false;
 	counterAttacks.reset();
@@ -897,9 +906,9 @@
 {
 }
 
-TConstBonusListPtr CUnitStateDetached::getAllBonuses(const CSelector & selector, const CSelector & limit, const CBonusSystemNode * root, const std::string & cachingStr) const
+TConstBonusListPtr CUnitStateDetached::getAllBonuses(const CSelector & selector, const CSelector & limit, const std::string & cachingStr) const
 {
-	return bonus->getAllBonuses(selector, limit, root, cachingStr);
+	return bonus->getAllBonuses(selector, limit, cachingStr);
 }
 
 int64_t CUnitStateDetached::getTreeVersion() const
@@ -918,7 +927,7 @@
 	return unit->unitId();
 }
 
-ui8 CUnitStateDetached::unitSide() const
+BattleSide CUnitStateDetached::unitSide() const
 {
 	return unit->unitSide();
 }
diff --color -urN vcmi-1.5.7/lib/battle/CUnitState.h vcmi/lib/battle/CUnitState.h
--- vcmi-1.5.7/lib/battle/CUnitState.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/battle/CUnitState.h	2024-12-19 15:00:22.891147648 +0100
@@ -107,7 +107,7 @@
 	void reset();
 
 	void damage(int64_t & amount);
-	void heal(int64_t & amount, EHealLevel level, EHealPower power);
+	HealInfo heal(int64_t & amount, EHealLevel level, EHealPower power);
 
 	int32_t getCount() const;
 	int32_t getFirstHPleft() const;
@@ -141,6 +141,7 @@
 	bool drainedMana;
 	bool fear;
 	bool hadMorale;
+	bool castSpellThisTurn;
 	bool ghost;
 	bool ghostPending;
 	bool movedThisRound;
@@ -247,12 +248,12 @@
 	void load(const JsonNode & data) override;
 
 	void damage(int64_t & amount) override;
-	void heal(int64_t & amount, EHealLevel level, EHealPower power) override;
+	HealInfo heal(int64_t & amount, EHealLevel level, EHealPower power) override;
 
 	void localInit(const IUnitEnvironment * env_);
 	void serializeJson(JsonSerializeFormat & handler);
 
-	FactionID getFaction() const override;
+	FactionID getFactionID() const override;
 
 	void afterAttack(bool ranged, bool counter);
 
@@ -282,14 +283,14 @@
 	explicit CUnitStateDetached(const IUnitInfo * unit_, const IBonusBearer * bonus_);
 
 	TConstBonusListPtr getAllBonuses(const CSelector & selector, const CSelector & limit,
-		const CBonusSystemNode * root = nullptr, const std::string & cachingStr = "") const override;
+		const std::string & cachingStr = "") const override;
 
 	int64_t getTreeVersion() const override;
 
 	CUnitStateDetached & operator= (const CUnitState & other);
 
 	uint32_t unitId() const override;
-	ui8 unitSide() const override;
+	BattleSide unitSide() const override;
 
 	const CCreature * unitType() const override;
 	PlayerColor unitOwner() const override;
diff --color -urN vcmi-1.5.7/lib/battle/DamageCalculator.cpp vcmi/lib/battle/DamageCalculator.cpp
--- vcmi-1.5.7/lib/battle/DamageCalculator.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/battle/DamageCalculator.cpp	2024-12-19 15:00:22.891147648 +0100
@@ -17,7 +17,7 @@
 #include "../bonuses/Bonus.h"
 #include "../mapObjects/CGTownInstance.h"
 #include "../spells/CSpellHandler.h"
-#include "../GameSettings.h"
+#include "../IGameSettings.h"
 #include "../VCMI_Lib.h"
 
 
@@ -145,7 +145,8 @@
 
 	if(multAttackReductionPercent > 0)
 	{
-		int reduction = (getActorAttackBase() * multAttackReductionPercent + 49) / 100; //using ints so 1.5 for 5 attack is rounded down as in HotA / h3assist etc. (keep in mind h3assist 1.2 shows wrong value for 15 attack points and unupg. nix)
+		//using ints so 1.5 for 5 attack is rounded down as in HotA / h3assist etc. (keep in mind h3assist 1.2 shows wrong value for 15 attack points and unupg. nix)
+		int reduction = vstd::divideAndRound( getActorAttackBase() * multAttackReductionPercent, 100);
 		return -std::min(reduction, getActorAttackBase());
 	}
 	return 0;
@@ -211,8 +212,9 @@
 
 	if(attackAdvantage > 0)
 	{
-		const double attackMultiplier = VLC->settings()->getDouble(EGameSettings::COMBAT_ATTACK_POINT_DAMAGE_FACTOR);
-		const double attackMultiplierCap = VLC->settings()->getDouble(EGameSettings::COMBAT_ATTACK_POINT_DAMAGE_FACTOR_CAP);
+		// FIXME: use cb to acquire these settings
+		const double attackMultiplier = VLC->engineSettings()->getDouble(EGameSettings::COMBAT_ATTACK_POINT_DAMAGE_FACTOR);
+		const double attackMultiplierCap = VLC->engineSettings()->getDouble(EGameSettings::COMBAT_ATTACK_POINT_DAMAGE_FACTOR_CAP);
 		const double attackFactor = std::min(attackMultiplier * attackAdvantage, attackMultiplierCap);
 
 		return attackFactor;
@@ -311,8 +313,9 @@
 	//bonus from attack/defense skills
 	if(defenseAdvantage > 0) //decreasing dmg
 	{
-		const double defenseMultiplier = VLC->settings()->getDouble(EGameSettings::COMBAT_DEFENSE_POINT_DAMAGE_FACTOR);
-		const double defenseMultiplierCap = VLC->settings()->getDouble(EGameSettings::COMBAT_DEFENSE_POINT_DAMAGE_FACTOR_CAP);
+		// FIXME: use cb to acquire these settings
+		const double defenseMultiplier = VLC->engineSettings()->getDouble(EGameSettings::COMBAT_DEFENSE_POINT_DAMAGE_FACTOR);
+		const double defenseMultiplierCap = VLC->engineSettings()->getDouble(EGameSettings::COMBAT_DEFENSE_POINT_DAMAGE_FACTOR_CAP);
 
 		const double dec = std::min(defenseMultiplier * defenseAdvantage, defenseMultiplierCap);
 		return dec;
diff --color -urN vcmi-1.5.7/lib/battle/IBattleInfoCallback.h vcmi/lib/battle/IBattleInfoCallback.h
--- vcmi-1.5.7/lib/battle/IBattleInfoCallback.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/battle/IBattleInfoCallback.h	2024-12-19 15:00:22.891147648 +0100
@@ -65,10 +65,10 @@
 	virtual BattleField battleGetBattlefieldType() const = 0;
 
 	///return none if battle is ongoing; otherwise the victorious side (0/1) or 2 if it is a draw
-	virtual std::optional<int> battleIsFinished() const = 0;
+	virtual std::optional<BattleSide> battleIsFinished() const = 0;
 
 	virtual si8 battleTacticDist() const = 0; //returns tactic distance in current tactics phase; 0 if not in tactics phase
-	virtual si8 battleGetTacticsSide() const = 0; //returns which side is in tactics phase, undefined if none (?)
+	virtual BattleSide battleGetTacticsSide() const = 0; //returns which side is in tactics phase, undefined if none (?)
 
 	virtual uint32_t battleNextUnitId() const = 0;
 
diff --color -urN vcmi-1.5.7/lib/battle/IBattleState.h vcmi/lib/battle/IBattleState.h
--- vcmi-1.5.7/lib/battle/IBattleState.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/battle/IBattleState.h	2024-12-19 15:00:22.891147648 +0100
@@ -16,6 +16,7 @@
 class ObstacleChanges;
 class UnitChanges;
 struct Bonus;
+struct BattleLayout;
 class JsonNode;
 class JsonSerializeFormat;
 class BattleField;
@@ -55,24 +56,24 @@
 	virtual EWallState getWallState(EWallPart partOfWall) const = 0;
 	virtual EGateState getGateState() const = 0;
 
-	virtual PlayerColor getSidePlayer(ui8 side) const = 0;
-	virtual const CArmedInstance * getSideArmy(ui8 side) const = 0;
-	virtual const CGHeroInstance * getSideHero(ui8 side) const = 0;
+	virtual PlayerColor getSidePlayer(BattleSide side) const = 0;
+	virtual const CArmedInstance * getSideArmy(BattleSide side) const = 0;
+	virtual const CGHeroInstance * getSideHero(BattleSide side) const = 0;
 	/// Returns list of all spells used by specified side (and that can be learned by opposite hero)
-	virtual std::vector<SpellID> getUsedSpells(ui8 side) const = 0;
+	virtual std::vector<SpellID> getUsedSpells(BattleSide side) const = 0;
 
-	virtual uint32_t getCastSpells(ui8 side) const = 0;
-	virtual int32_t getEnchanterCounter(ui8 side) const = 0;
+	virtual uint32_t getCastSpells(BattleSide side) const = 0;
+	virtual int32_t getEnchanterCounter(BattleSide side) const = 0;
 
 	virtual ui8 getTacticDist() const = 0;
-	virtual ui8 getTacticsSide() const = 0;
+	virtual BattleSide getTacticsSide() const = 0;
 
 	virtual uint32_t nextUnitId() const = 0;
 
 	virtual int64_t getActualDamage(const DamageRange & damage, int32_t attackerCount, vstd::RNG & rng) const = 0;
 
 	virtual int3 getLocation() const = 0;
-	virtual bool isCreatureBank() const = 0;
+	virtual BattleLayout getLayout() const = 0;
 };
 
 class DLL_LINKAGE IBattleState : public IBattleInfo
diff --color -urN vcmi-1.5.7/lib/battle/IUnitInfo.h vcmi/lib/battle/IUnitInfo.h
--- vcmi-1.5.7/lib/battle/IUnitInfo.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/battle/IUnitInfo.h	2024-12-19 15:00:22.891147648 +0100
@@ -11,6 +11,7 @@
 #pragma once
 
 #include "../GameConstants.h"
+#include "BattleSide.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
@@ -35,7 +36,7 @@
 	virtual int32_t unitBaseAmount() const = 0;
 
 	virtual uint32_t unitId() const = 0;
-	virtual ui8 unitSide() const = 0;
+	virtual BattleSide unitSide() const = 0;
 	virtual PlayerColor unitOwner() const = 0;
 	virtual SlotID unitSlot() const = 0;
 
diff --color -urN vcmi-1.5.7/lib/battle/ReachabilityInfo.cpp vcmi/lib/battle/ReachabilityInfo.cpp
--- vcmi-1.5.7/lib/battle/ReachabilityInfo.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/battle/ReachabilityInfo.cpp	2024-12-19 15:00:22.891147648 +0100
@@ -15,7 +15,7 @@
 VCMI_LIB_NAMESPACE_BEGIN
 
 ReachabilityInfo::Parameters::Parameters(const battle::Unit * Stack, BattleHex StartPosition):
-	perspective(static_cast<BattlePerspective::BattlePerspective>(Stack->unitSide())),
+	perspective(static_cast<BattleSide>(Stack->unitSide())),
 	startPosition(StartPosition),
 	doubleWide(Stack->doubleWide()),
 	side(Stack->unitSide()),
@@ -66,9 +66,25 @@
 
 	if(attacker->doubleWide())
 	{
-		vstd::concatenate(attackableHexes, battle::Unit::getHexes(defender->occupiedHex(), true, attacker->unitSide()));
+		if(defender->doubleWide())
+		{
+			// It can be back to back attack  o==o  or head to head  =oo=.
+			// In case of back-to-back the distance between heads (unit positions) may be up to 3 tiles
+			vstd::concatenate(attackableHexes, battle::Unit::getHexes(defender->occupiedHex(), true, defender->unitSide()));
+		}
+		else
+		{
+			vstd::concatenate(attackableHexes, battle::Unit::getHexes(defender->getPosition(), true, defender->unitSide()));
+		}
 	}
 
+	vstd::removeDuplicates(attackableHexes);
+
+	vstd::erase_if(attackableHexes, [defender](BattleHex h) -> bool
+		{
+			return h.getY() != defender->getPosition().getY() || !h.isAvailable();
+		});
+
 	return distToNearestNeighbour(attackableHexes, chosenHex);
 }
 
diff --color -urN vcmi-1.5.7/lib/battle/ReachabilityInfo.h vcmi/lib/battle/ReachabilityInfo.h
--- vcmi-1.5.7/lib/battle/ReachabilityInfo.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/battle/ReachabilityInfo.h	2024-12-19 15:00:22.891147648 +0100
@@ -15,7 +15,7 @@
 VCMI_LIB_NAMESPACE_BEGIN
 
 // Reachability info is result of BFS calculation. It's dependent on stack (it's owner, whether it's flying),
-// startPosition and perpective.
+// startPosition and perspective.
 struct DLL_LINKAGE ReachabilityInfo
 {
 	using TDistances = std::array<uint32_t, GameConstants::BFIELD_SIZE>;
@@ -25,14 +25,16 @@
 
 	struct DLL_LINKAGE Parameters
 	{
-		ui8 side = 0;
+		BattleSide side = BattleSide::NONE;
 		bool doubleWide = false;
 		bool flying = false;
 		bool ignoreKnownAccessible = false; //Ignore obstacles if it is in accessible hexes
+		bool bypassEnemyStacks = false; // in case of true will count amount of turns needed to kill enemy and thus move forward
 		std::vector<BattleHex> knownAccessible; //hexes that will be treated as accessible, even if they're occupied by stack (by default - tiles occupied by stack we do reachability for, so it doesn't block itself)
+		std::map<BattleHex, ui8> destructibleEnemyTurns; // hom many turns it is needed to kill enemy on specific hex
 
 		BattleHex startPosition; //assumed position of stack
-		BattlePerspective::BattlePerspective perspective = BattlePerspective::ALL_KNOWING; //some obstacles (eg. quicksands) may be invisible for some side
+		BattleSide perspective = BattleSide::ALL_KNOWING; //some obstacles (eg. quicksands) may be invisible for some side
 
 		Parameters() = default;
 		Parameters(const battle::Unit * Stack, BattleHex StartPosition);
diff --color -urN vcmi-1.5.7/lib/battle/Unit.cpp vcmi/lib/battle/Unit.cpp
--- vcmi-1.5.7/lib/battle/Unit.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/battle/Unit.cpp	2024-12-19 15:00:22.892147690 +0100
@@ -12,8 +12,7 @@
 #include "Unit.h"
 
 #include "../VCMI_Lib.h"
-#include "../CGeneralTextHandler.h"
-#include "../MetaString.h"
+#include "../texts/CGeneralTextHandler.h"
 
 #include "../serializer/JsonDeserializer.h"
 #include "../serializer/JsonSerializer.h"
@@ -42,7 +41,7 @@
 std::string Unit::getDescription() const
 {
 	boost::format fmt("Unit %d of side %d");
-	fmt % unitId() % unitSide();
+	fmt % unitId() % static_cast<int>(unitSide());
 	return fmt.str();
 }
 
@@ -59,7 +58,7 @@
 	return getSurroundingHexes(hex, doubleWide(), unitSide());
 }
 
-std::vector<BattleHex> Unit::getSurroundingHexes(BattleHex position, bool twoHex, ui8 side)
+std::vector<BattleHex> Unit::getSurroundingHexes(BattleHex position, bool twoHex, BattleSide side)
 {
 	std::vector<BattleHex> hexes;
 	if(twoHex)
@@ -136,7 +135,7 @@
 	return getHexes(assumedPos, doubleWide(), unitSide());
 }
 
-std::vector<BattleHex> Unit::getHexes(BattleHex assumedPos, bool twoHex, ui8 side)
+std::vector<BattleHex> Unit::getHexes(BattleHex assumedPos, bool twoHex, BattleSide side)
 {
 	std::vector<BattleHex> hexes;
 	hexes.push_back(assumedPos);
@@ -157,7 +156,7 @@
 	return occupiedHex(assumedPos, doubleWide(), unitSide());
 }
 
-BattleHex Unit::occupiedHex(BattleHex assumedPos, bool twoHex, ui8 side)
+BattleHex Unit::occupiedHex(BattleHex assumedPos, bool twoHex, BattleSide side)
 {
 	if(twoHex)
 	{
diff --color -urN vcmi-1.5.7/lib/battle/Unit.h vcmi/lib/battle/Unit.h
--- vcmi-1.5.7/lib/battle/Unit.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/battle/Unit.h	2024-12-19 15:00:22.892147690 +0100
@@ -41,6 +41,25 @@
 	};
 }
 
+// Healed HP (also drained life) and resurrected units info
+struct HealInfo
+{
+	HealInfo() = default;
+	HealInfo(int64_t healedHP, int32_t resurrected)
+		: healedHealthPoints(healedHP), resurrectedCount(resurrected)
+	{ }
+
+	int64_t healedHealthPoints = 0;
+	int32_t resurrectedCount = 0;
+
+	HealInfo & operator+=(const HealInfo & other)
+	{
+		healedHealthPoints += other.healedHealthPoints;
+		resurrectedCount += other.resurrectedCount;
+		return *this;
+	}
+};
+
 class CUnitState;
 
 class DLL_LINKAGE Unit : public IUnitInfo, public spells::Caster, public virtual IBonusBearer, public ACreature
@@ -110,17 +129,17 @@
 
 	std::vector<BattleHex> getSurroundingHexes(BattleHex assumedPosition = BattleHex::INVALID) const; // get six or 8 surrounding hexes depending on creature size
 	std::vector<BattleHex> getAttackableHexes(const Unit * attacker) const;
-	static std::vector<BattleHex> getSurroundingHexes(BattleHex position, bool twoHex, ui8 side);
+	static std::vector<BattleHex> getSurroundingHexes(BattleHex position, bool twoHex, BattleSide side);
 
 	bool coversPos(BattleHex position) const; //checks also if unit is double-wide
 
 	std::vector<BattleHex> getHexes() const; //up to two occupied hexes, starting from front
 	std::vector<BattleHex> getHexes(BattleHex assumedPos) const; //up to two occupied hexes, starting from front
-	static std::vector<BattleHex> getHexes(BattleHex assumedPos, bool twoHex, ui8 side);
+	static std::vector<BattleHex> getHexes(BattleHex assumedPos, bool twoHex, BattleSide side);
 
 	BattleHex occupiedHex() const; //returns number of occupied hex (not the position) if stack is double wide; otherwise -1
 	BattleHex occupiedHex(BattleHex assumedPos) const; //returns number of occupied hex (not the position) if stack is double wide and would stand on assumedPos; otherwise -1
-	static BattleHex occupiedHex(BattleHex assumedPos, bool twoHex, ui8 side);
+	static BattleHex occupiedHex(BattleHex assumedPos, bool twoHex, BattleSide side);
 
 	///MetaStrings
 	void addText(MetaString & text, EMetaText type, int32_t serial, const boost::logic::tribool & plural = boost::logic::indeterminate) const;
@@ -138,7 +157,7 @@
 	virtual void load(const JsonNode & data) = 0;
 
 	virtual void damage(int64_t & amount) = 0;
-	virtual void heal(int64_t & amount, EHealLevel level, EHealPower power) = 0;
+	virtual HealInfo heal(int64_t & amount, EHealLevel level, EHealPower power) = 0;
 };
 
 class DLL_LINKAGE UnitInfo
@@ -147,7 +166,7 @@
     uint32_t id = 0;
 	TQuantity count = 0;
 	CreatureID type;
-	ui8 side = 0;
+	BattleSide side = BattleSide::NONE;
 	BattleHex position;
 	bool summoned = false;
 
diff --color -urN vcmi-1.5.7/lib/BattleFieldHandler.cpp vcmi/lib/BattleFieldHandler.cpp
--- vcmi-1.5.7/lib/BattleFieldHandler.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/BattleFieldHandler.cpp	2024-12-19 15:00:22.820144714 +0100
@@ -15,11 +15,11 @@
 
 VCMI_LIB_NAMESPACE_BEGIN
 
-BattleFieldInfo * BattleFieldHandler::loadFromJson(const std::string & scope, const JsonNode & json, const std::string & identifier, size_t index)
+std::shared_ptr<BattleFieldInfo> BattleFieldHandler::loadFromJson(const std::string & scope, const JsonNode & json, const std::string & identifier, size_t index)
 {
 	assert(identifier.find(':') == std::string::npos);
 
-	auto * info = new BattleFieldInfo(BattleField(index), identifier);
+	auto info = std::make_shared<BattleFieldInfo>(BattleField(index), identifier);
 
 	info->modScope = scope;
 	info->graphics = ImagePath::fromJson(json["graphics"]);
@@ -40,6 +40,9 @@
 	for(auto node : json["impassableHexes"].Vector())
 		info->impassableHexes.emplace_back(node.Integer());
 
+	info->openingSoundFilename = AudioPath::fromJson(json["openingSound"]);
+	info->musicFilename = AudioPath::fromJson(json["music"]);
+
 	return info;
 }
 
@@ -70,6 +73,11 @@
 	return modScope + ':' + identifier;
 }
 
+std::string BattleFieldInfo::getModScope() const
+{
+	return modScope;
+}
+
 std::string BattleFieldInfo::getNameTextID() const
 {
 	return name;
diff --color -urN vcmi-1.5.7/lib/BattleFieldHandler.h vcmi/lib/BattleFieldHandler.h
--- vcmi-1.5.7/lib/BattleFieldHandler.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/BattleFieldHandler.h	2024-12-19 15:00:22.821144755 +0100
@@ -32,6 +32,8 @@
 	std::string icon;
 	si32 iconIndex;
 	std::vector<BattleHex> impassableHexes;
+	AudioPath openingSoundFilename;
+	AudioPath musicFilename;
 
 	BattleFieldInfo() 
 		: BattleFieldInfo(BattleField::NONE, "")
@@ -50,6 +52,7 @@
 	int32_t getIndex() const override;
 	int32_t getIconIndex() const override;
 	std::string getJsonKey() const override;
+	std::string getModScope() const override;
 	std::string getNameTextID() const override;
 	std::string getNameTranslated() const override;
 	void registerIcons(const IconRegistar & cb) const override;
@@ -64,7 +67,7 @@
 class BattleFieldHandler : public CHandlerBase<BattleField, BattleFieldInfo, BattleFieldInfo, BattleFieldService>
 {
 public:
-	virtual BattleFieldInfo * loadFromJson(
+	std::shared_ptr<BattleFieldInfo> loadFromJson(
 		const std::string & scope,
 		const JsonNode & json,
 		const std::string & identifier,
diff --color -urN vcmi-1.5.7/lib/bonuses/Bonus.cpp vcmi/lib/bonuses/Bonus.cpp
--- vcmi-1.5.7/lib/bonuses/Bonus.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/bonuses/Bonus.cpp	2024-12-19 15:00:22.892147690 +0100
@@ -14,19 +14,21 @@
 #include "Updaters.h"
 #include "Propagators.h"
 
-#include "../VCMI_Lib.h"
-#include "../spells/CSpellHandler.h"
+#include "../CArtHandler.h"
 #include "../CCreatureHandler.h"
 #include "../CCreatureSet.h"
-#include "../CHeroHandler.h"
-#include "../CTownHandler.h"
-#include "../CGeneralTextHandler.h"
 #include "../CSkillHandler.h"
-#include "../CArtHandler.h"
+#include "../IGameCallback.h"
 #include "../TerrainHandler.h"
-#include "../constants/StringConstants.h"
+#include "../VCMI_Lib.h"
+#include "../mapObjects/CGObjectInstance.h"
+#include "../mapObjectConstructors/CObjectClassesHandler.h"
 #include "../battle/BattleInfo.h"
+#include "../constants/StringConstants.h"
+#include "../entities/hero/CHero.h"
 #include "../modding/ModUtility.h"
+#include "../spells/CSpellHandler.h"
+#include "../texts/CGeneralTextHandler.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
@@ -88,7 +90,7 @@
 		return node;
 	}
 }
-std::string Bonus::Description(std::optional<si32> customValue) const
+std::string Bonus::Description(const IGameInfoCallback * cb, std::optional<si32> customValue) const
 {
 	MetaString descriptionHelper = description;
 	auto valueToShow = customValue.value_or(val);
@@ -113,13 +115,17 @@
 			case BonusSource::HERO_SPECIAL:
 				descriptionHelper.appendTextID(sid.as<HeroTypeID>().toEntity(VLC)->getNameTextID());
 				break;
+			case BonusSource::OBJECT_INSTANCE:
+				const auto * object = cb->getObj(sid.as<ObjectInstanceID>());
+				if (object)
+					descriptionHelper.appendTextID(VLC->objtypeh->getObjectName(object->ID, object->subID));
 		}
 	}
 
 	if(descriptionHelper.empty())
 	{
 		// still no description - try to generate one based on duration
-		if ((duration & BonusDuration::ONE_BATTLE).any())
+		if ((duration & BonusDuration::ONE_BATTLE) != 0)
 		{
 			if (val > 0)
 				descriptionHelper.appendTextID("core.arraytxt.110"); //+%d Temporary until next battle"
@@ -248,7 +254,7 @@
 #define printField(field) out << "\t" #field ": " << (int)bonus.field << "\n"
 	printField(val);
 	out << "\tSubtype: " << bonus.subtype.toString() << "\n";
-	printField(duration.to_ulong());
+	printField(duration);
 	printField(source);
 	out << "\tSource ID: " << bonus.sid.toString() << "\n";
 	if(bonus.additionalInfo != CAddInfo::NONE)
diff --color -urN vcmi-1.5.7/lib/bonuses/BonusEnum.cpp vcmi/lib/bonuses/BonusEnum.cpp
--- vcmi-1.5.7/lib/bonuses/BonusEnum.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/bonuses/BonusEnum.cpp	2024-12-19 15:00:22.892147690 +0100
@@ -60,10 +60,11 @@
 	JsonNode toJson(const Type & duration)
 	{
 		std::vector<std::string> durationNames;
-		for(auto durBit = 0; durBit < duration.size(); durBit++)
+		for(size_t durBit = 0; durBit < Size; durBit++)
 		{
-			if(duration[durBit])
-				durationNames.push_back(vstd::findKey(bonusDurationMap, duration & Type().set(durBit)));
+			Type value = duration & (1 << durBit);
+			if(value)
+				durationNames.push_back(vstd::findKey(bonusDurationMap, value));
 		}
 		if(durationNames.size() == 1)
 		{
diff --color -urN vcmi-1.5.7/lib/bonuses/BonusEnum.h vcmi/lib/bonuses/BonusEnum.h
--- vcmi-1.5.7/lib/bonuses/BonusEnum.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/bonuses/BonusEnum.h	2024-12-19 15:00:22.893147731 +0100
@@ -33,7 +33,7 @@
 	BONUS_NAME(NEGATE_ALL_NATURAL_IMMUNITIES) \
 	BONUS_NAME(STACK_HEALTH) \
 	BONUS_NAME(GENERATE_RESOURCE) /*daily value, uses subtype (resource type)*/  \
-	BONUS_NAME(CREATURE_GROWTH) /*for legion artifacts: value - week growth bonus, subtype - monster level if aplicable*/  \
+	BONUS_NAME(CREATURE_GROWTH) /*for legion artifacts: value - week growth bonus, subtype - monster level if applicable*/  \
 	BONUS_NAME(WHIRLPOOL_PROTECTION) /*hero won't lose army when teleporting through whirlpool*/  \
 	BONUS_NAME(SPELL) /*hero knows spell, val - skill level (0 - 3), subtype - spell id*/  \
 	BONUS_NAME(SPELLS_OF_LEVEL) /*hero knows all spells of given level, val - skill level; subtype - level*/  \
@@ -150,7 +150,7 @@
 	BONUS_NAME(GARGOYLE) /* gargoyle is special than NON_LIVING, cannot be rised or healed */ \
 	BONUS_NAME(SPECIAL_ADD_VALUE_ENCHANT) /*specialty spell like Aenin has, increased effect of spell, additionalInfo = value to add*/\
 	BONUS_NAME(SPECIAL_FIXED_VALUE_ENCHANT) /*specialty spell like Melody has, constant spell effect (i.e. 3 luck), additionalInfo = value to fix.*/\
-	BONUS_NAME(TOWN_MAGIC_WELL) /*one-time pseudo-bonus to implement Magic Well in the town*/\
+	BONUS_NAME(THIEVES_GUILD_ACCESS) \
 	BONUS_NAME(LIMITED_SHOOTING_RANGE) /*limits range of shooting creatures, doesn't adjust any other mechanics (half vs full damage etc). val - range in hexes, additional info - optional new range for broken arrow mechanic */\
 	BONUS_NAME(LEARN_BATTLE_SPELL_CHANCE) /*skill-agnostic eagle eye chance. subtype = 0 - from enemy, 1 - TODO: from entire battlefield*/\
 	BONUS_NAME(LEARN_BATTLE_SPELL_LEVEL_LIMIT) /*skill-agnostic eagle eye limit, subtype - school (-1 for all), others TODO*/\
@@ -177,7 +177,11 @@
 	BONUS_NAME(ENEMY_ATTACK_REDUCTION) /*in % (value) eg. Nix (HotA)*/ \
 	BONUS_NAME(REVENGE) /*additional damage based on how many units in stack died - formula: sqrt((number of creatures at battle start + 1) * creature health) / (total health now + 1 creature health) - 1) * 100% */ \
 	BONUS_NAME(RESOURCES_CONSTANT_BOOST) /*Bonus that does not account for propagation and gives extra resources per day. val - resource amount, subtype - resource type*/ \
-	BONUS_NAME(RESOURCES_TOWN_MULTIPLYING_BOOST) /*Bonus that does not account for propagation and gives extra resources per day with amount multiplied by number of owned towns. val - base resource amount to be multipled times number of owned towns, subtype - resource type*/ \
+	BONUS_NAME(RESOURCES_TOWN_MULTIPLYING_BOOST) /*Bonus that does not account for propagation and gives extra resources per day with amount multiplied by number of owned towns. val - base resource amount to be multiplied times number of owned towns, subtype - resource type*/ \
+	BONUS_NAME(DISINTEGRATE) /* after death no corpse remains */ \
+	BONUS_NAME(INVINCIBLE) /* cannot be target of attacks or spells */ \
+	BONUS_NAME(MECHANICAL) /*eg. factory creatures, cannot be rised or healed, only neutral morale, repairable by engineer */ \
+	BONUS_NAME(PRISM_HEX_ATTACK_BREATH) /*eg. dragons*/	\
 	/* end of list */
 
 
@@ -212,7 +216,7 @@
 	BONUS_VALUE(INDEPENDENT_MIN) //used for SECONDARY_SKILL_PREMY bonus
 
 
-enum class BonusType
+enum class BonusType : uint8_t
 {
 #define BONUS_NAME(x) x,
     BONUS_LIST
@@ -220,21 +224,27 @@
 };
 namespace BonusDuration  //when bonus is automatically removed
 {
-	using Type = std::bitset<11>;
+	// We use uint16_t directly because std::bitset<11> eats whole 8 byte word.
+	using Type = uint16_t;
+	constexpr size_t Size = 11;
+
+	enum BonusDuration : Type {
+		PERMANENT = 1 << 0,
+		ONE_BATTLE = 1 << 1, //at the end of battle
+		ONE_DAY = 1 << 2,   //at the end of day
+		ONE_WEEK = 1 << 3, //at the end of week (bonus lasts till the end of week, thats NOT 7 days
+		N_TURNS = 1 << 4, //used during battles, after battle bonus is always removed
+		N_DAYS = 1 << 5,
+		UNTIL_BEING_ATTACKED = 1 << 6, /*removed after attack and counterattacks are performed*/
+		UNTIL_ATTACK = 1 << 7, /*removed after attack and counterattacks are performed*/
+		STACK_GETS_TURN = 1 << 8, /*removed when stack gets its turn - used for defensive stance*/
+		COMMANDER_KILLED = 1 << 9,
+		UNTIL_OWN_ATTACK = 1 << 10 /*removed after attack is performed (not counterattack)*/,
+	};
+
 	extern JsonNode toJson(const Type & duration);
-	constexpr Type PERMANENT = 1 << 0;
-	constexpr Type ONE_BATTLE = 1 << 1; //at the end of battle
-	constexpr Type ONE_DAY = 1 << 2;   //at the end of day
-	constexpr Type ONE_WEEK = 1 << 3; //at the end of week (bonus lasts till the end of week, thats NOT 7 days
-	constexpr Type N_TURNS = 1 << 4; //used during battles, after battle bonus is always removed
-	constexpr Type N_DAYS = 1 << 5;
-	constexpr Type UNTIL_BEING_ATTACKED = 1 << 6; /*removed after attack and counterattacks are performed*/
-	constexpr Type UNTIL_ATTACK = 1 << 7; /*removed after attack and counterattacks are performed*/
-	constexpr Type STACK_GETS_TURN = 1 << 8; /*removed when stack gets its turn - used for defensive stance*/
-	constexpr Type COMMANDER_KILLED = 1 << 9;
-	constexpr Type UNTIL_OWN_ATTACK = 1 << 10; /*removed after attack is performed (not counterattack)*/;
 };
-enum class BonusSource
+enum class BonusSource : uint8_t
 {
 #define BONUS_SOURCE(x) x,
     BONUS_SOURCE_LIST
@@ -242,13 +252,13 @@
     NUM_BONUS_SOURCE /*This is a dummy value, which will be always last*/
 };
 
-enum class BonusLimitEffect
+enum class BonusLimitEffect : uint8_t
 {
     NO_LIMIT = 0,
     ONLY_DISTANCE_FIGHT=1, ONLY_MELEE_FIGHT, //used to mark bonuses for attack/defense primary skills from spells like Precision (distance only)
 };
 
-enum class BonusValueType
+enum class BonusValueType : uint8_t
 {
 #define BONUS_VALUE(x) x,
     BONUS_VALUE_LIST
diff --color -urN vcmi-1.5.7/lib/bonuses/Bonus.h vcmi/lib/bonuses/Bonus.h
--- vcmi-1.5.7/lib/bonuses/Bonus.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/bonuses/Bonus.h	2024-12-19 15:00:22.892147690 +0100
@@ -13,7 +13,8 @@
 #include "BonusCustomTypes.h"
 #include "../constants/VariantIdentifier.h"
 #include "../constants/EntityIdentifiers.h"
-#include "../MetaString.h"
+#include "../serializer/Serializeable.h"
+#include "../texts/MetaString.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
@@ -25,6 +26,7 @@
 class IUpdater;
 class BonusList;
 class CSelector;
+class IGameInfoCallback;
 
 using BonusSubtypeID = VariantIdentifier<BonusCustomSubtype, SpellID, CreatureID, PrimarySkill, TerrainId, GameResID, SpellSchool>;
 using BonusSourceID = VariantIdentifier<BonusCustomSource, SpellID, CreatureID, ArtifactID, CampaignScenarioID, SecondarySkill, HeroTypeID, Obj, ObjectInstanceID, BuildingTypeUniqueID, BattleField>;
@@ -52,26 +54,27 @@
 	JsonNode toJsonNode() const;
 };
 
-#define BONUS_TREE_DESERIALIZATION_FIX if(!h.saving && h.smartPointerSerialization) deserializationFix();
+#define BONUS_TREE_DESERIALIZATION_FIX if(!h.saving && h.loadingGamestate) deserializationFix();
 
 /// Struct for handling bonuses of several types. Can be transferred to any hero
-struct DLL_LINKAGE Bonus : public std::enable_shared_from_this<Bonus>
+struct DLL_LINKAGE Bonus : public std::enable_shared_from_this<Bonus>, public Serializeable
 {
-	BonusDuration::Type duration = BonusDuration::PERMANENT; //uses BonusDuration values
+	BonusDuration::Type duration = BonusDuration::PERMANENT; //uses BonusDuration values - 2 bytes
 	si16 turnsRemain = 0; //used if duration is N_TURNS, N_DAYS or ONE_WEEK
+	si32 val = 0;
 
+	BonusValueType valType = BonusValueType::ADDITIVE_VALUE; // 1 byte
+	BonusSource source = BonusSource::OTHER; //source type" uses BonusSource values - what gave that bonus - 1 byte
+	BonusSource targetSourceType = BonusSource::OTHER;//Bonuses of what origin this amplifies, uses BonusSource values. Needed for PERCENT_TO_TARGET_TYPE. - 1 byte
 	BonusType type = BonusType::NONE; //uses BonusType values - says to what is this bonus - 1 byte
-	BonusSubtypeID subtype;
+	BonusLimitEffect effectRange = BonusLimitEffect::NO_LIMIT; // 1 byte
+	// 3 bytes padding
 
-	BonusSource source = BonusSource::OTHER; //source type" uses BonusSource values - what gave that bonus
-	BonusSource targetSourceType = BonusSource::OTHER;//Bonuses of what origin this amplifies, uses BonusSource values. Needed for PERCENT_TO_TARGET_TYPE.
-	si32 val = 0;
+	BonusSubtypeID subtype;
 	BonusSourceID sid; //source id: id of object/artifact/spell
-	BonusValueType valType = BonusValueType::ADDITIVE_VALUE;
 	std::string stacking; // bonuses with the same stacking value don't stack (e.g. Angel/Archangel morale bonus)
 
 	CAddInfo additionalInfo;
-	BonusLimitEffect effectRange = BonusLimitEffect::NO_LIMIT;
 
 	TLimiterPtr limiter;
 	TPropagatorPtr propagator;
@@ -93,15 +96,7 @@
 		h & source;
 		h & val;
 		h & sid;
-		if (h.version < Handler::Version::BONUS_META_STRING)
-		{
-			std::string oldDescription;
-			h & oldDescription;
-			description = MetaString::createFromRawString(oldDescription);
-		}
-		else
-			h & description;
-
+		h & description;
 		h & additionalInfo;
 		h & turnsRemain;
 		h & valType;
@@ -112,11 +107,6 @@
 		h & updater;
 		h & propagationUpdater;
 		h & targetSourceType;
-		if (h.version < Handler::Version::MANA_LIMIT && type == BonusType::MANA_PER_KNOWLEDGE_PERCENTAGE)
-		{
-			if (valType == BonusValueType::ADDITIVE_VALUE || valType == BonusValueType::BASE_NUMBER)
-				val *= 100;
-		}
 	}
 
 	template <typename Ptr>
@@ -127,57 +117,57 @@
 	static bool NDays(const Bonus *hb)
 	{
 		auto set = hb->duration & BonusDuration::N_DAYS;
-		return set.any();
+		return set != 0;
 	}
 	static bool NTurns(const Bonus *hb)
 	{
 		auto set = hb->duration & BonusDuration::N_TURNS;
-		return set.any();
+		return set != 0;
 	}
 	static bool OneDay(const Bonus *hb)
 	{
 		auto set = hb->duration & BonusDuration::ONE_DAY;
-		return set.any();
+		return set != 0;
 	}
 	static bool OneWeek(const Bonus *hb)
 	{
 		auto set = hb->duration & BonusDuration::ONE_WEEK;
-		return set.any();
+		return set != 0;
 	}
 	static bool OneBattle(const Bonus *hb)
 	{
 		auto set = hb->duration & BonusDuration::ONE_BATTLE;
-		return set.any();
+		return set != 0;
 	}
 	static bool Permanent(const Bonus *hb)
 	{
 		auto set = hb->duration & BonusDuration::PERMANENT;
-		return set.any();
+		return set != 0;
 	}
 	static bool UntilGetsTurn(const Bonus *hb)
 	{
 		auto set = hb->duration & BonusDuration::STACK_GETS_TURN;
-		return set.any();
+		return set != 0;
 	}
 	static bool UntilAttack(const Bonus *hb)
 	{
 		auto set = hb->duration & BonusDuration::UNTIL_ATTACK;
-		return set.any();
+		return set != 0;
 	}
 	static bool UntilBeingAttacked(const Bonus *hb)
 	{
 		auto set = hb->duration & BonusDuration::UNTIL_BEING_ATTACKED;
-		return set.any();
+		return set != 0;
 	}
 	static bool UntilCommanderKilled(const Bonus *hb)
 	{
 		auto set = hb->duration & BonusDuration::COMMANDER_KILLED;
-		return set.any();
+		return set != 0;
 	}
 	static bool UntilOwnAttack(const Bonus *hb)
 	{
 		auto set = hb->duration & BonusDuration::UNTIL_OWN_ATTACK;
-		return set.any();
+		return set != 0;
 	}
 	inline bool operator == (const BonusType & cf) const
 	{
@@ -188,7 +178,7 @@
 		val += Val;
 	}
 
-	std::string Description(std::optional<si32> customValue = {}) const;
+	std::string Description(const IGameInfoCallback * cb, std::optional<si32> customValue = {}) const;
 	JsonNode toJsonNode() const;
 
 	std::shared_ptr<Bonus> addLimiter(const TLimiterPtr & Limiter); //returns this for convenient chain-calls
diff --color -urN vcmi-1.5.7/lib/bonuses/BonusList.cpp vcmi/lib/bonuses/BonusList.cpp
--- vcmi-1.5.7/lib/bonuses/BonusList.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/bonuses/BonusList.cpp	2024-12-19 15:00:22.893147731 +0100
@@ -99,13 +99,13 @@
 		int indepMax = std::numeric_limits<int>::min();
 	};
 
-	auto percent = [](int base, int percent) -> int {
+	auto applyPercentage = [](int base, int percent) -> int {
 		return (static_cast<int64_t>(base) * (100 + percent)) / 100;
 	};
 
 	BonusCollection accumulated;
-	bool hasIndepMax = false;
-	bool hasIndepMin = false;
+	int indexMaxCount = 0;
+	int indexMinCount = 0;
 
 	std::array<int, vstd::to_underlying(BonusSource::NUM_BONUS_SOURCE)> percentToSource = {};
 
@@ -125,7 +125,7 @@
 	for(const auto & b : bonuses)
 	{
 		int sourceIndex = vstd::to_underlying(b->source);
-		int valModified	= percent(b->val, percentToSource[sourceIndex]);
+		int valModified	= applyPercentage(b->val, percentToSource[sourceIndex]);
 
 		switch(b->valType)
 		{
@@ -141,33 +141,36 @@
 		case BonusValueType::ADDITIVE_VALUE:
 			accumulated.additive += valModified;
 			break;
-		case BonusValueType::INDEPENDENT_MAX:
-			hasIndepMax = true;
+		case BonusValueType::INDEPENDENT_MAX: // actual meaning: at least this value
+			indexMaxCount++;
 			vstd::amax(accumulated.indepMax, valModified);
 			break;
-		case BonusValueType::INDEPENDENT_MIN:
-			hasIndepMin = true;
+		case BonusValueType::INDEPENDENT_MIN: // actual meaning: at most this value
+			indexMinCount++;
 			vstd::amin(accumulated.indepMin, valModified);
 			break;
 		}
 	}
 
-	accumulated.base = percent(accumulated.base, accumulated.percentToBase);
+	accumulated.base = applyPercentage(accumulated.base, accumulated.percentToBase);
 	accumulated.base += accumulated.additive;
-	auto valFirst = percent(accumulated.base ,accumulated.percentToAll);
+	auto valFirst = applyPercentage(accumulated.base ,accumulated.percentToAll);
 
-	if(hasIndepMin && hasIndepMax && accumulated.indepMin < accumulated.indepMax)
+	if(indexMinCount && indexMaxCount && accumulated.indepMin < accumulated.indepMax)
 		accumulated.indepMax = accumulated.indepMin;
 
-	const int notIndepBonuses = static_cast<int>(std::count_if(bonuses.cbegin(), bonuses.cend(), [](const std::shared_ptr<Bonus>& b)
-	{
-		return b->valType != BonusValueType::INDEPENDENT_MAX && b->valType != BonusValueType::INDEPENDENT_MIN;
-	}));
+	const int notIndepBonuses = bonuses.size() - indexMaxCount - indexMinCount;
 
 	if(notIndepBonuses)
 		return std::clamp(valFirst, accumulated.indepMax, accumulated.indepMin);
 
-	return hasIndepMin ? accumulated.indepMin : hasIndepMax ? accumulated.indepMax : 0;
+	if (indexMinCount)
+		return accumulated.indepMin;
+
+	if (indexMaxCount)
+		return accumulated.indepMax;
+
+	return 0;
 }
 
 std::shared_ptr<Bonus> BonusList::getFirst(const CSelector &select)
diff --color -urN vcmi-1.5.7/lib/bonuses/CBonusSystemNode.cpp vcmi/lib/bonuses/CBonusSystemNode.cpp
--- vcmi-1.5.7/lib/bonuses/CBonusSystemNode.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/bonuses/CBonusSystemNode.cpp	2024-12-19 15:00:22.894147772 +0100
@@ -107,10 +107,9 @@
 	}
 }
 
-TConstBonusListPtr CBonusSystemNode::getAllBonuses(const CSelector &selector, const CSelector &limit, const CBonusSystemNode *root, const std::string &cachingStr) const
+TConstBonusListPtr CBonusSystemNode::getAllBonuses(const CSelector &selector, const CSelector &limit, const std::string &cachingStr) const
 {
-	bool limitOnUs = (!root || root == this); //caching won't work when we want to limit bonuses against an external node
-	if (CBonusSystemNode::cachingEnabled && limitOnUs)
+	if (CBonusSystemNode::cachingEnabled)
 	{
 		// Exclusive access for one thread
 		boost::lock_guard<boost::mutex> lock(sync);
@@ -157,11 +156,11 @@
 	}
 	else
 	{
-		return getAllBonusesWithoutCaching(selector, limit, root);
+		return getAllBonusesWithoutCaching(selector, limit);
 	}
 }
 
-TConstBonusListPtr CBonusSystemNode::getAllBonusesWithoutCaching(const CSelector &selector, const CSelector &limit, const CBonusSystemNode *root) const
+TConstBonusListPtr CBonusSystemNode::getAllBonusesWithoutCaching(const CSelector &selector, const CSelector &limit) const
 {
 	auto ret = std::make_shared<BonusList>();
 
@@ -169,29 +168,7 @@
 	BonusList beforeLimiting;
 	BonusList afterLimiting;
 	getAllBonusesRec(beforeLimiting, selector);
-
-	if(!root || root == this)
-	{
-		limitBonuses(beforeLimiting, afterLimiting);
-	}
-	else if(root)
-	{
-		//We want to limit our query against an external node. We get all its bonuses,
-		// add the ones we're considering and see if they're cut out by limiters
-		BonusList rootBonuses;
-		BonusList limitedRootBonuses;
-		getAllBonusesRec(rootBonuses, selector);
-
-		for(const auto & b : beforeLimiting)
-			rootBonuses.push_back(b);
-
-		root->limitBonuses(rootBonuses, limitedRootBonuses);
-
-		for(const auto & b : beforeLimiting)
-			if(vstd::contains(limitedRootBonuses, b))
-				afterLimiting.push_back(b);
-
-	}
+	limitBonuses(beforeLimiting, afterLimiting);
 	afterLimiting.getBonuses(*ret, selector, limit);
 	ret->stackBonuses();
 	return ret;
@@ -401,7 +378,7 @@
 			? source.getUpdatedBonus(b, b->propagationUpdater)
 			: b;
 		bonuses.push_back(propagated);
-		logBonus->trace("#$# %s #propagated to# %s",  propagated->Description(), nodeName());
+		logBonus->trace("#$# %s #propagated to# %s",  propagated->Description(nullptr), nodeName());
 	}
 
 	TNodes lchildren;
@@ -415,9 +392,9 @@
 	if(b->propagator->shouldBeAttached(this))
 	{
 		if (bonuses -= b)
-			logBonus->trace("#$# %s #is no longer propagated to# %s",  b->Description(), nodeName());
+			logBonus->trace("#$# %s #is no longer propagated to# %s",  b->Description(nullptr), nodeName());
 		else
-			logBonus->warn("Attempt to remove #$# %s, which is not propagated to %s", b->Description(), nodeName());
+			logBonus->warn("Attempt to remove #$# %s, which is not propagated to %s", b->Description(nullptr), nodeName());
 
 		bonuses.remove_if([b](const auto & bonus)
 		{
@@ -648,13 +625,6 @@
 	}
 }
 
-TBonusListPtr CBonusSystemNode::limitBonuses(const BonusList &allBonuses) const
-{
-	auto ret = std::make_shared<BonusList>();
-	limitBonuses(allBonuses, *ret);
-	return ret;
-}
-
 void CBonusSystemNode::treeHasChanged()
 {
 	treeChanged++;
diff --color -urN vcmi-1.5.7/lib/bonuses/CBonusSystemNode.h vcmi/lib/bonuses/CBonusSystemNode.h
--- vcmi-1.5.7/lib/bonuses/CBonusSystemNode.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/bonuses/CBonusSystemNode.h	2024-12-19 15:00:22.894147772 +0100
@@ -9,11 +9,11 @@
  */
 #pragma once
 
-#include "GameConstants.h"
-
 #include "BonusList.h"
 #include "IBonusBearer.h"
 
+#include "../serializer/Serializeable.h"
+
 VCMI_LIB_NAMESPACE_BEGIN
 
 using TNodes = std::set<CBonusSystemNode *>;
@@ -21,7 +21,7 @@
 using TNodesVector = std::vector<CBonusSystemNode *>;
 using TCNodesVector = std::vector<const CBonusSystemNode *>;
 
-class DLL_LINKAGE CBonusSystemNode : public virtual IBonusBearer, public boost::noncopyable
+class DLL_LINKAGE CBonusSystemNode : public virtual IBonusBearer, public virtual Serializeable, public boost::noncopyable
 {
 public:
 	enum ENodeTypes
@@ -47,14 +47,15 @@
 	static std::atomic<int64_t> treeChanged;
 
 	// Setting a value to cachingStr before getting any bonuses caches the result for later requests.
-	// This string needs to be unique, that's why it has to be setted in the following manner:
+	// This string needs to be unique, that's why it has to be set in the following manner:
 	// [property key]_[value] => only for selector
 	mutable std::map<std::string, TBonusListPtr > cachedRequests;
 	mutable boost::mutex sync;
 
 	void getAllBonusesRec(BonusList &out, const CSelector & selector) const;
-	TConstBonusListPtr getAllBonusesWithoutCaching(const CSelector &selector, const CSelector &limit, const CBonusSystemNode *root = nullptr) const;
+	TConstBonusListPtr getAllBonusesWithoutCaching(const CSelector &selector, const CSelector &limit) const;
 	std::shared_ptr<Bonus> getUpdatedBonus(const std::shared_ptr<Bonus> & b, const TUpdaterPtr & updater) const;
+	void limitBonuses(const BonusList &allBonuses, BonusList &out) const; //out will bo populed with bonuses that are not limited here
 
 	void getRedParents(TCNodes &out) const;  //retrieves list of red parent nodes (nodes bonuses propagate from)
 	void getRedAncestors(TCNodes &out) const;
@@ -84,9 +85,7 @@
 	explicit CBonusSystemNode(ENodeTypes NodeType);
 	virtual ~CBonusSystemNode();
 
-	void limitBonuses(const BonusList &allBonuses, BonusList &out) const; //out will bo populed with bonuses that are not limited here
-	TBonusListPtr limitBonuses(const BonusList &allBonuses) const; //same as above, returns out by val for convienence
-	TConstBonusListPtr getAllBonuses(const CSelector &selector, const CSelector &limit, const CBonusSystemNode *root = nullptr, const std::string &cachingStr = "") const override;
+	TConstBonusListPtr getAllBonuses(const CSelector &selector, const CSelector &limit, const std::string &cachingStr = "") const override;
 	void getParents(TCNodes &out) const;  //retrieves list of parent nodes (nodes to inherit bonuses from),
 
 	/// Returns first bonus matching selector
diff --color -urN vcmi-1.5.7/lib/bonuses/IBonusBearer.cpp vcmi/lib/bonuses/IBonusBearer.cpp
--- vcmi-1.5.7/lib/bonuses/IBonusBearer.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/bonuses/IBonusBearer.cpp	2024-12-19 15:00:22.894147772 +0100
@@ -17,7 +17,7 @@
 
 int IBonusBearer::valOfBonuses(const CSelector &selector, const std::string &cachingStr) const
 {
-	TConstBonusListPtr hlp = getAllBonuses(selector, nullptr, nullptr, cachingStr);
+	TConstBonusListPtr hlp = getAllBonuses(selector, nullptr, cachingStr);
 	return hlp->totalValue();
 }
 
@@ -34,12 +34,12 @@
 
 TConstBonusListPtr IBonusBearer::getBonuses(const CSelector &selector, const std::string &cachingStr) const
 {
-	return getAllBonuses(selector, nullptr, nullptr, cachingStr);
+	return getAllBonuses(selector, nullptr, cachingStr);
 }
 
 TConstBonusListPtr IBonusBearer::getBonuses(const CSelector &selector, const CSelector &limit, const std::string &cachingStr) const
 {
-	return getAllBonuses(selector, limit, nullptr, cachingStr);
+	return getAllBonuses(selector, limit, cachingStr);
 }
 
 int IBonusBearer::valOfBonuses(BonusType type) const
@@ -84,11 +84,9 @@
 
 bool IBonusBearer::hasBonusFrom(BonusSource source, BonusSourceID sourceID) const
 {
-	boost::format fmt("source_%did_%s");
-	fmt % static_cast<int>(source) % sourceID.toString();
-
-	return hasBonus(Selector::source(source,sourceID), fmt.str());
+	return hasBonus(Selector::source(source,sourceID));
 }
+
 std::shared_ptr<const Bonus> IBonusBearer::getBonus(const CSelector &selector) const
 {
 	auto bonuses = getAllBonuses(selector, Selector::all);
diff --color -urN vcmi-1.5.7/lib/bonuses/IBonusBearer.h vcmi/lib/bonuses/IBonusBearer.h
--- vcmi-1.5.7/lib/bonuses/IBonusBearer.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/bonuses/IBonusBearer.h	2024-12-19 15:00:22.894147772 +0100
@@ -17,12 +17,10 @@
 {
 public:
 	//new bonusing node interface
-	// * selector is predicate that tests if HeroBonus matches our criteria
-	// * root is node on which call was made (nullptr will be replaced with this)
-	//interface
+	// * selector is predicate that tests if Bonus matches our criteria
 	IBonusBearer() = default;
 	virtual ~IBonusBearer() = default;
-	virtual TConstBonusListPtr getAllBonuses(const CSelector &selector, const CSelector &limit, const CBonusSystemNode *root = nullptr, const std::string &cachingStr = "") const = 0;
+	virtual TConstBonusListPtr getAllBonuses(const CSelector &selector, const CSelector &limit, const std::string &cachingStr = "") const = 0;
 	int valOfBonuses(const CSelector &selector, const std::string &cachingStr = "") const;
 	bool hasBonus(const CSelector &selector, const std::string &cachingStr = "") const;
 	bool hasBonus(const CSelector &selector, const CSelector &limit, const std::string &cachingStr = "") const;
diff --color -urN vcmi-1.5.7/lib/bonuses/Limiters.cpp vcmi/lib/bonuses/Limiters.cpp
--- vcmi-1.5.7/lib/bonuses/Limiters.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/bonuses/Limiters.cpp	2024-12-19 15:00:22.894147772 +0100
@@ -12,12 +12,12 @@
 #include "Limiters.h"
 
 #include "../VCMI_Lib.h"
+#include "../entities/faction/CFaction.h"
+#include "../entities/faction/CTownHandler.h"
 #include "../spells/CSpellHandler.h"
 #include "../CCreatureHandler.h"
 #include "../CCreatureSet.h"
-#include "../CHeroHandler.h"
-#include "../CTownHandler.h"
-#include "../CGeneralTextHandler.h"
+#include "../texts/CGeneralTextHandler.h"
 #include "../CSkillHandler.h"
 #include "../CStack.h"
 #include "../CArtHandler.h"
@@ -75,7 +75,7 @@
 	default:
 		const CStackInstance * csi = retrieveStackInstance(node);
 		if(csi)
-			return csi->type;
+			return csi->getCreature();
 		return nullptr;
 	}
 }
@@ -103,25 +103,25 @@
 	if(!c)
 		return ILimiter::EDecision::DISCARD;
 	
-	auto accept =  c->getId() == creature->getId() || (includeUpgrades && creature->isMyUpgrade(c));
+	auto accept =  c->getId() == creatureID || (includeUpgrades && creatureID.toCreature()->isMyUpgrade(c));
 	return accept ? ILimiter::EDecision::ACCEPT : ILimiter::EDecision::DISCARD;
 	//drop bonus if it's not our creature and (we don`t check upgrades or its not our upgrade)
 }
 
 CCreatureTypeLimiter::CCreatureTypeLimiter(const CCreature & creature_, bool IncludeUpgrades)
-	: creature(&creature_), includeUpgrades(IncludeUpgrades)
+	: creatureID(creature_.getId()), includeUpgrades(IncludeUpgrades)
 {
 }
 
 void CCreatureTypeLimiter::setCreature(const CreatureID & id)
 {
-	creature = id.toCreature();
+	creatureID = id;
 }
 
 std::string CCreatureTypeLimiter::toString() const
 {
 	boost::format fmt("CCreatureTypeLimiter(creature=%s, includeUpgrades=%s)");
-	fmt % creature->getJsonKey() % (includeUpgrades ? "true" : "false");
+	fmt % creatureID.toEntity(VLC)->getJsonKey() % (includeUpgrades ? "true" : "false");
 	return fmt.str();
 }
 
@@ -130,7 +130,7 @@
 	JsonNode root;
 
 	root["type"].String() = "CREATURE_TYPE_LIMITER";
-	root["parameters"].Vector().emplace_back(creature->getJsonKey());
+	root["parameters"].Vector().emplace_back(creatureID.toEntity(VLC)->getJsonKey());
 	root["parameters"].Vector().emplace_back(includeUpgrades);
 
 	return root;
@@ -299,15 +299,15 @@
 	if(bearer)
 	{
 		if(faction != FactionID::DEFAULT)
-			return bearer->getFaction() == faction ? ILimiter::EDecision::ACCEPT : ILimiter::EDecision::DISCARD;
+			return bearer->getFactionID() == faction ? ILimiter::EDecision::ACCEPT : ILimiter::EDecision::DISCARD;
 
 		switch(context.b.source)
 		{
 			case BonusSource::CREATURE_ABILITY:
-				return bearer->getFaction() == context.b.sid.as<CreatureID>().toCreature()->getFaction() ? ILimiter::EDecision::ACCEPT : ILimiter::EDecision::DISCARD;
+				return bearer->getFactionID() == context.b.sid.as<CreatureID>().toCreature()->getFactionID() ? ILimiter::EDecision::ACCEPT : ILimiter::EDecision::DISCARD;
 			
 			case BonusSource::TOWN_STRUCTURE:
-				return bearer->getFaction() == context.b.sid.as<BuildingTypeUniqueID>().getFaction() ? ILimiter::EDecision::ACCEPT : ILimiter::EDecision::DISCARD;
+				return bearer->getFactionID() == context.b.sid.as<BuildingTypeUniqueID>().getFaction() ? ILimiter::EDecision::ACCEPT : ILimiter::EDecision::DISCARD;
 
 			//TODO: other sources of bonuses
 		}
diff --color -urN vcmi-1.5.7/lib/bonuses/Limiters.h vcmi/lib/bonuses/Limiters.h
--- vcmi-1.5.7/lib/bonuses/Limiters.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/bonuses/Limiters.h	2024-12-19 15:00:22.895147814 +0100
@@ -10,8 +10,9 @@
 
 #include "Bonus.h"
 
-#include "../GameConstants.h"
 #include "../battle/BattleHex.h"
+#include "../serializer/Serializeable.h"
+#include "../constants/Enumerations.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
@@ -27,7 +28,7 @@
 	const BonusList & stillUndecided;
 };
 
-class DLL_LINKAGE ILimiter
+class DLL_LINKAGE ILimiter : public Serializeable
 {
 public:
 	enum class EDecision : uint8_t {ACCEPT, DISCARD, NOT_SURE};
@@ -93,7 +94,7 @@
 class DLL_LINKAGE CCreatureTypeLimiter : public ILimiter //affect only stacks of given creature (and optionally it's upgrades)
 {
 public:
-	const CCreature * creature = nullptr;
+	CreatureID creatureID;
 	bool includeUpgrades = false;
 
 	CCreatureTypeLimiter() = default;
@@ -107,7 +108,16 @@
 	template <typename Handler> void serialize(Handler &h)
 	{
 		h & static_cast<ILimiter&>(*this);
-		h & creature;
+
+		if (h.version < Handler::Version::REMOVE_TOWN_PTR)
+		{
+			bool isNull = false;
+			h & isNull;
+			if(!isNull)
+				h & creatureID;
+		}
+		else
+			h & creatureID;
 		h & includeUpgrades;
 	}
 };
diff --color -urN vcmi-1.5.7/lib/bonuses/Propagators.h vcmi/lib/bonuses/Propagators.h
--- vcmi-1.5.7/lib/bonuses/Propagators.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/bonuses/Propagators.h	2024-12-19 15:00:22.895147814 +0100
@@ -12,11 +12,13 @@
 #include "Bonus.h"
 #include "CBonusSystemNode.h"
 
+#include "../serializer/Serializeable.h"
+
 VCMI_LIB_NAMESPACE_BEGIN
 
 extern DLL_LINKAGE const std::map<std::string, TPropagatorPtr> bonusPropagatorMap;
 
-class DLL_LINKAGE IPropagator
+class DLL_LINKAGE IPropagator : public Serializeable
 {
 public:
 	virtual ~IPropagator() = default;
@@ -42,4 +44,4 @@
 	}
 };
 
-VCMI_LIB_NAMESPACE_END
\ No newline at end of file
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/bonuses/Updaters.cpp vcmi/lib/bonuses/Updaters.cpp
--- vcmi-1.5.7/lib/bonuses/Updaters.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/bonuses/Updaters.cpp	2024-12-19 15:00:22.895147814 +0100
@@ -145,7 +145,7 @@
 }
 std::shared_ptr<Bonus> TimesStackLevelUpdater::createUpdatedBonus(const std::shared_ptr<Bonus> & b, const CBonusSystemNode & context) const
 {
-	if(context.getNodeType() == CBonusSystemNode::STACK_INSTANCE)
+	if(context.getNodeType() == CBonusSystemNode::STACK_INSTANCE || context.getNodeType() == CBonusSystemNode::COMMANDER)
 	{
 		int level = dynamic_cast<const CStackInstance &>(context).getLevel();
 		auto newBonus = std::make_shared<Bonus>(*b);
@@ -155,14 +155,21 @@
 	else if(context.getNodeType() == CBonusSystemNode::STACK_BATTLE)
 	{
 		const auto & stack = dynamic_cast<const CStack &>(context);
-		//only update if stack doesn't have an instance (summons, war machines)
-		//otherwise we'd end up multiplying twice
+		//update if stack doesn't have an instance (summons, war machines)
 		if(stack.base == nullptr)
 		{
 			int level = stack.unitType()->getLevel();
 			auto newBonus = std::make_shared<Bonus>(*b);
 			newBonus->val *= level;
 			return newBonus;
+		}
+		// If these are not handled here, the final outcome may potentially be incorrect.
+		else
+		{
+			int level = dynamic_cast<const CStackInstance*>(stack.base)->getLevel();
+			auto newBonus = std::make_shared<Bonus>(*b);
+			newBonus->val *= level;
+			return newBonus;
 		}
 	}
 	return b;
diff --color -urN vcmi-1.5.7/lib/bonuses/Updaters.h vcmi/lib/bonuses/Updaters.h
--- vcmi-1.5.7/lib/bonuses/Updaters.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/bonuses/Updaters.h	2024-12-19 15:00:22.895147814 +0100
@@ -10,12 +10,13 @@
 #pragma once
 
 #include "Bonus.h"
+#include "../serializer/Serializeable.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
 // observers for updating bonuses based on certain events (e.g. hero gaining level)
 
-class DLL_LINKAGE IUpdater
+class DLL_LINKAGE IUpdater : public Serializeable
 {
 public:
 	virtual ~IUpdater() = default;
diff --color -urN vcmi-1.5.7/lib/campaign/CampaignConstants.h vcmi/lib/campaign/CampaignConstants.h
--- vcmi-1.5.7/lib/campaign/CampaignConstants.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/campaign/CampaignConstants.h	2024-12-19 15:00:22.895147814 +0100
@@ -18,7 +18,7 @@
 	AB = 5,
 	SoD = 6,
 	WoG = 6,
-	//		Chr = 7, // Heroes Chronicles, likely identical to SoD, untested
+	Chr = 7,
 
 	VCMI = 1,
 	VCMI_MIN = 1,
diff --color -urN vcmi-1.5.7/lib/campaign/CampaignHandler.cpp vcmi/lib/campaign/CampaignHandler.cpp
--- vcmi-1.5.7/lib/campaign/CampaignHandler.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/campaign/CampaignHandler.cpp	2024-12-19 15:00:22.895147814 +0100
@@ -16,16 +16,16 @@
 #include "../filesystem/CCompressedStream.h"
 #include "../filesystem/CMemoryStream.h"
 #include "../filesystem/CBinaryReader.h"
-#include "../modding/IdentifierStorage.h"
+#include "../filesystem/CZipLoader.h"
 #include "../VCMI_Lib.h"
-#include "../CGeneralTextHandler.h"
-#include "../TextOperations.h"
-#include "../Languages.h"
 #include "../constants/StringConstants.h"
 #include "../mapping/CMapHeader.h"
 #include "../mapping/CMapService.h"
 #include "../modding/CModHandler.h"
+#include "../modding/IdentifierStorage.h"
 #include "../modding/ModScope.h"
+#include "../texts/CGeneralTextHandler.h"
+#include "../texts/TextOperations.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
@@ -37,16 +37,18 @@
 		CBinaryReader reader(&stream);
 
 		readHeaderFromMemory(*ret, reader, filename, modName, encoding);
+		ret->overrideCampaign();
 
 		for(int g = 0; g < ret->numberOfScenarios; ++g)
 		{
 			auto scenarioID = static_cast<CampaignScenarioID>(ret->scenarios.size());
 			ret->scenarios[scenarioID] = readScenarioFromMemory(reader, *ret);
 		}
+		ret->overrideCampaignScenarios();
 	}
 	else // text format (json)
 	{
-		JsonNode jsonCampaign(reinterpret_cast<const std::byte*>(input.data()), input.size());
+		JsonNode jsonCampaign(reinterpret_cast<const std::byte*>(input.data()), input.size(), filename);
 		readHeaderFromJson(*ret, jsonCampaign, filename, modName, encoding);
 
 		for(auto & scenario : jsonCampaign["scenarios"].Vector())
@@ -61,8 +63,7 @@
 {
 	ResourcePath resourceID(name, EResType::CAMPAIGN);
 	std::string modName = VLC->modh->findResourceOrigin(resourceID);
-	std::string language = VLC->modh->getModLanguage(modName);
-	std::string encoding = Languages::getLanguageOptions(language).encoding;
+	std::string encoding = VLC->modh->findResourceEncoding(resourceID);
 	
 	auto ret = std::make_unique<Campaign>();
 	auto fileStream = CResourceHandler::get(modName)->load(resourceID);
@@ -77,8 +78,7 @@
 {
 	ResourcePath resourceID(name, EResType::CAMPAIGN);
 	std::string modName = VLC->modh->findResourceOrigin(resourceID);
-	std::string language = VLC->modh->getModLanguage(modName);
-	std::string encoding = Languages::getLanguageOptions(language).encoding;
+	std::string encoding = VLC->modh->findResourceEncoding(resourceID);
 	
 	auto ret = std::make_unique<CampaignState>();
 	
@@ -126,14 +126,19 @@
 
 std::string CampaignHandler::readLocalizedString(CampaignHeader & target, CBinaryReader & reader, std::string filename, std::string modName, std::string encoding, std::string identifier)
 {
-	TextIdentifier stringID( "campaign", convertMapName(filename), identifier);
-
 	std::string input = TextOperations::toUnicode(reader.readBaseString(), encoding);
 
-	if (input.empty())
+	return readLocalizedString(target, input, filename, modName, identifier);
+}
+
+std::string CampaignHandler::readLocalizedString(CampaignHeader & target, std::string text, std::string filename, std::string modName, std::string identifier)
+{
+	TextIdentifier stringID( "campaign", convertMapName(filename), identifier);
+
+	if (text.empty())
 		return "";
 
-	target.getTexts().registerString(modName, stringID, input);
+	target.getTexts().registerString(modName, stringID, text);
 	return stringID.get();
 }
 
@@ -149,13 +154,21 @@
 	ret.version = CampaignVersion::VCMI;
 	ret.campaignRegions = CampaignRegions::fromJson(reader["regions"]);
 	ret.numberOfScenarios = reader["scenarios"].Vector().size();
-	ret.name.appendTextID(reader["name"].String());
-	ret.description.appendTextID(reader["description"].String());
-	ret.difficultyChoosenByPlayer = reader["allowDifficultySelection"].Bool();
+	ret.name.appendTextID(readLocalizedString(ret, reader["name"].String(), filename, modName, "name"));
+	ret.description.appendTextID(readLocalizedString(ret, reader["description"].String(), filename, modName, "description"));
+	ret.author.appendRawString(reader["author"].String());
+	ret.authorContact.appendRawString(reader["authorContact"].String());
+	ret.campaignVersion.appendRawString(reader["campaignVersion"].String());
+	ret.creationDateTime = reader["creationDateTime"].Integer();
+	ret.difficultyChosenByPlayer = reader["allowDifficultySelection"].Bool();
 	ret.music = AudioPath::fromJson(reader["music"]);
 	ret.filename = filename;
 	ret.modName = modName;
 	ret.encoding = encoding;
+	ret.loadingBackground = ImagePath::fromJson(reader["loadingBackground"]);
+	ret.videoRim = ImagePath::fromJson(reader["videoRim"]);
+	ret.introVideo = VideoPath::fromJson(reader["introVideo"]);
+	ret.outroVideo = VideoPath::fromJson(reader["outroVideo"]);
 }
 
 CampaignScenario CampaignHandler::readScenarioFromJson(JsonNode & reader)
@@ -382,13 +395,18 @@
 {
 	ret.version = static_cast<CampaignVersion>(reader.readUInt32());
 	ui8 campId = reader.readUInt8() - 1;//change range of it from [1, 20] to [0, 19]
-	ret.loadLegacyData(campId);
+	if(ret.version != CampaignVersion::Chr) // For chronicles: Will be overridden later; Chronicles uses own logic (reusing OH3 ID's)
+		ret.loadLegacyData(campId);
 	ret.name.appendTextID(readLocalizedString(ret, reader, filename, modName, encoding, "name"));
 	ret.description.appendTextID(readLocalizedString(ret, reader, filename, modName, encoding, "description"));
+	ret.author.appendRawString("");
+	ret.authorContact.appendRawString("");
+	ret.campaignVersion.appendRawString("");
+	ret.creationDateTime = 0;
 	if (ret.version > CampaignVersion::RoE)
-		ret.difficultyChoosenByPlayer = reader.readInt8();
+		ret.difficultyChosenByPlayer = reader.readInt8();
 	else
-		ret.difficultyChoosenByPlayer = false;
+		ret.difficultyChosenByPlayer = false;
 
 	ret.music = prologMusicName(reader.readInt8());
 	ret.filename = filename;
@@ -580,32 +598,69 @@
 
 std::vector< std::vector<ui8> > CampaignHandler::getFile(std::unique_ptr<CInputStream> file, const std::string & filename, bool headerOnly)
 {
-	CCompressedStream stream(std::move(file), true);
+	std::array<ui8, 2> magic;
+	file->read(magic.data(), magic.size());
+	file->seek(0);
 
 	std::vector< std::vector<ui8> > ret;
 
-	try
+	static const std::array<ui8, 2> zipHeaderMagic{0x50, 0x4B};
+	if (magic == zipHeaderMagic) // ZIP archive - assume VCMP format
 	{
-		do
-		{
-			std::vector<ui8> block(stream.getSize());
-			stream.read(block.data(), block.size());
-			ret.push_back(block);
-			ret.back().shrink_to_fit();
+		CInputStream * buffer(file.get());
+		auto ioApi = std::make_shared<CProxyROIOApi>(buffer);
+		CZipLoader loader("", "_", ioApi);
+
+		// load header
+		JsonPath jsonPath = JsonPath::builtin(VCMP_HEADER_FILE_NAME);
+		if(!loader.existsResource(jsonPath))
+			throw std::runtime_error(jsonPath.getName() + " not found in " + filename);
+		auto data = loader.load(jsonPath)->readAll();
+		ret.emplace_back(data.first.get(), data.first.get() + data.second);
+
+		if(headerOnly)
+			return ret;
+
+		// load scenarios
+		JsonNode header(reinterpret_cast<const std::byte*>(data.first.get()), data.second, VCMP_HEADER_FILE_NAME);
+		for(auto scenario : header["scenarios"].Vector())
+		{
+			ResourcePath mapPath(scenario["map"].String(), EResType::MAP);
+			if(!loader.existsResource(mapPath))
+				throw std::runtime_error(mapPath.getName() + " not found in " + filename);
+			auto data = loader.load(mapPath)->readAll();
+			ret.emplace_back(data.first.get(), data.first.get() + data.second);
 		}
-		while (!headerOnly && stream.getNextBlock());
+
+		return ret;
 	}
-	catch (const DecompressionException & e)
+	else // H3C
 	{
-		// Some campaigns in French version from gog.com have trailing garbage bytes
-		// For example, slayer.h3c consist from 5 parts: header + 4 maps
-		// However file also contains ~100 "extra" bytes after those 5 parts are decompressed that do not represent gzip stream
-		// leading to exception "Incorrect header check"
-		// Since H3 handles these files correctly, simply log this as warning and proceed
-		logGlobal->warn("Failed to read file %s. Encountered error during decompression: %s", filename, e.what());
-	}
+		CCompressedStream stream(std::move(file), true);
 
-	return ret;
+		try
+		{
+			do
+			{
+				std::vector<ui8> block(stream.getSize());
+				stream.read(block.data(), block.size());
+				ret.push_back(block);
+				ret.back().shrink_to_fit();
+			}
+			while (!headerOnly && stream.getNextBlock());
+		}
+		catch (const DecompressionException & e)
+		{
+			// Some campaigns in French version from gog.com have trailing garbage bytes
+			// For example, slayer.h3c consist from 5 parts: header + 4 maps
+			// However file also contains ~100 "extra" bytes after those 5 parts are decompressed that do not represent gzip stream
+			// leading to exception "Incorrect header check"
+			// Since H3 handles these files correctly, simply log this as warning and proceed
+			logGlobal->warn("Failed to read file %s. Encountered error during decompression: %s", filename, e.what());
+		}
+
+		return ret;
+	}
 }
 
 VideoPath CampaignHandler::prologVideoName(ui8 index)
diff --color -urN vcmi-1.5.7/lib/campaign/CampaignHandler.h vcmi/lib/campaign/CampaignHandler.h
--- vcmi-1.5.7/lib/campaign/CampaignHandler.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/campaign/CampaignHandler.h	2024-12-19 15:00:22.896147855 +0100
@@ -17,6 +17,7 @@
 class DLL_LINKAGE CampaignHandler
 {
 	static std::string readLocalizedString(CampaignHeader & target, CBinaryReader & reader, std::string filename, std::string modName, std::string encoding, std::string identifier);
+	static std::string readLocalizedString(CampaignHeader & target, std::string text, std::string filename, std::string modName, std::string identifier);
 
 	static void readCampaign(Campaign * target, const std::vector<ui8> & stream, std::string filename, std::string modName, std::string encoding);
 
@@ -37,6 +38,7 @@
 	static AudioPath prologMusicName(ui8 index);
 	static AudioPath prologVoiceName(ui8 index);
 
+	static constexpr auto VCMP_HEADER_FILE_NAME = "header.json";
 public:
 	static std::unique_ptr<Campaign> getHeader( const std::string & name); //name - name of appropriate file
 
diff --color -urN vcmi-1.5.7/lib/campaign/CampaignScenarioPrologEpilog.h vcmi/lib/campaign/CampaignScenarioPrologEpilog.h
--- vcmi-1.5.7/lib/campaign/CampaignScenarioPrologEpilog.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/campaign/CampaignScenarioPrologEpilog.h	2024-12-19 15:00:22.896147855 +0100
@@ -10,7 +10,7 @@
 #pragma once
 
 #include "../filesystem/ResourcePath.h"
-#include "../MetaString.h"
+#include "../texts/MetaString.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
diff --color -urN vcmi-1.5.7/lib/campaign/CampaignState.cpp vcmi/lib/campaign/CampaignState.cpp
--- vcmi-1.5.7/lib/campaign/CampaignState.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/campaign/CampaignState.cpp	2024-12-19 15:00:22.896147855 +0100
@@ -13,13 +13,14 @@
 #include "../Point.h"
 #include "../filesystem/ResourcePath.h"
 #include "../VCMI_Lib.h"
-#include "../CGeneralTextHandler.h"
+#include "../texts/CGeneralTextHandler.h"
 #include "../mapping/CMapService.h"
 #include "../mapping/CMapInfo.h"
 #include "../mapping/CMap.h"
 #include "../mapObjects/CGHeroInstance.h"
 #include "../serializer/JsonDeserializer.h"
 #include "../serializer/JsonSerializer.h"
+#include "../json/JsonUtils.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
@@ -36,8 +37,11 @@
 {
 	CampaignRegions::RegionDescription rd;
 	rd.infix = node["infix"].String();
-	rd.xpos = static_cast<int>(node["x"].Float());
-	rd.ypos = static_cast<int>(node["y"].Float());
+	rd.pos = Point(static_cast<int>(node["x"].Float()), static_cast<int>(node["y"].Float()));
+	if(!node["labelPos"].isNull())
+		rd.labelPos = Point(static_cast<int>(node["labelPos"]["x"].Float()), static_cast<int>(node["labelPos"]["y"].Float()));
+	else
+		rd.labelPos = std::nullopt;
 	return rd;
 }
 
@@ -45,7 +49,9 @@
 {
 	CampaignRegions cr;
 	cr.campPrefix = node["prefix"].String();
-	cr.colorSuffixLength = static_cast<int>(node["color_suffix_length"].Float());
+	cr.colorSuffixLength = static_cast<int>(node["colorSuffixLength"].Float());
+	cr.campSuffix = node["suffix"].isNull() ? std::vector<std::string>() : std::vector<std::string>{node["suffix"].Vector()[0].String(), node["suffix"].Vector()[1].String(), node["suffix"].Vector()[2].String()};
+	cr.campBackground = node["background"].isNull() ? "" : node["background"].String();
 
 	for(const JsonNode & desc : node["desc"].Vector())
 		cr.regions.push_back(CampaignRegions::RegionDescription::fromJson(desc));
@@ -68,43 +74,61 @@
 
 ImagePath CampaignRegions::getBackgroundName() const
 {
-	return ImagePath::builtin(campPrefix + "_BG.BMP");
+	if(campBackground.empty())
+		return ImagePath::builtin(campPrefix + "_BG.BMP");
+	else
+		return ImagePath::builtin(campBackground);
 }
 
 Point CampaignRegions::getPosition(CampaignScenarioID which) const
 {
 	auto const & region = regions[which.getNum()];
-	return Point(region.xpos, region.ypos);
+	return region.pos;
+}
+
+std::optional<Point> CampaignRegions::getLabelPosition(CampaignScenarioID which) const
+{
+	auto const & region = regions[which.getNum()];
+	return region.labelPos;
 }
 
 ImagePath CampaignRegions::getNameFor(CampaignScenarioID which, int colorIndex, std::string type) const
 {
 	auto const & region = regions[which.getNum()];
 
-	static const std::string colors[2][8] =
-	{
-		{"R", "B", "N", "G", "O", "V", "T", "P"},
-		{"Re", "Bl", "Br", "Gr", "Or", "Vi", "Te", "Pi"}
-	};
+	static const std::array<std::array<std::string, 8>, 3> colors = {{
+		{ "", "", "", "", "", "", "", "" },
+		{ "R", "B", "N", "G", "O", "V", "T", "P" },
+		{ "Re", "Bl", "Br", "Gr", "Or", "Vi", "Te", "Pi" }
+	}};
 
-	std::string color = colors[colorSuffixLength - 1][colorIndex];
+	std::string color = colors[colorSuffixLength][colorIndex];
 
 	return ImagePath::builtin(campPrefix + region.infix + "_" + type + color + ".BMP");
 }
 
 ImagePath CampaignRegions::getAvailableName(CampaignScenarioID which, int color) const
 {
-	return getNameFor(which, color, "En");
+	if(campSuffix.empty())
+		return getNameFor(which, color, "En");
+	else
+		return getNameFor(which, color, campSuffix[0]);
 }
 
 ImagePath CampaignRegions::getSelectedName(CampaignScenarioID which, int color) const
 {
-	return getNameFor(which, color, "Se");
+	if(campSuffix.empty())
+		return getNameFor(which, color, "Se");
+	else
+		return getNameFor(which, color, campSuffix[1]);
 }
 
 ImagePath CampaignRegions::getConqueredName(CampaignScenarioID which, int color) const
 {
-	return getNameFor(which, color, "Co");
+	if(campSuffix.empty())
+		return getNameFor(which, color, "Co");
+	else
+		return getNameFor(which, color, campSuffix[2]);
 }
 
 
@@ -124,9 +148,15 @@
 	numberOfScenarios = VLC->generaltexth->getCampaignLength(campId);
 }
 
+void CampaignHeader::loadLegacyData(CampaignRegions regions, int numOfScenario)
+{
+	campaignRegions = regions;
+	numberOfScenarios = numOfScenario;
+}
+
 bool CampaignHeader::playerSelectedDifficulty() const
 {
-	return difficultyChoosenByPlayer;
+	return difficultyChosenByPlayer;
 }
 
 bool CampaignHeader::formatVCMI() const
@@ -144,6 +174,26 @@
 	return name.toString();
 }
 
+std::string CampaignHeader::getAuthor() const
+{
+	return authorContact.toString();
+}
+
+std::string CampaignHeader::getAuthorContact() const
+{
+	return authorContact.toString();
+}
+
+std::string CampaignHeader::getCampaignVersion() const
+{
+	return campaignVersion.toString();
+}
+
+time_t CampaignHeader::getCreationDateTime() const
+{
+	return creationDateTime;
+}
+
 std::string CampaignHeader::getFilename() const
 {
 	return filename;
@@ -164,6 +214,26 @@
 	return music;
 }
 
+ImagePath CampaignHeader::getLoadingBackground() const
+{
+	return loadingBackground;
+}
+
+ImagePath CampaignHeader::getVideoRim() const
+{
+	return videoRim;
+}
+
+VideoPath CampaignHeader::getIntroVideo() const
+{
+	return introVideo;
+}
+
+VideoPath CampaignHeader::getOutroVideo() const
+{
+	return outroVideo;
+}
+
 const CampaignRegions & CampaignHeader::getRegions() const
 {
 	return campaignRegions;
@@ -269,7 +339,7 @@
 {
 	range::sort(heroes, [](const CGHeroInstance * a, const CGHeroInstance * b)
 	{
-		return a->getHeroStrength() > b->getHeroStrength();
+		return a->getHeroStrengthForCampaign() > b->getHeroStrengthForCampaign();
 	});
 
 	logGlobal->info("Scenario %d of campaign %s (%s) has been completed", currentMap->getNum(), getFilename(), getNameTranslated());
@@ -281,14 +351,14 @@
 	{
 		JsonNode node = CampaignState::crossoverSerialize(hero);
 
-		if (reservedHeroes.count(hero->getHeroType()))
+		if (reservedHeroes.count(hero->getHeroTypeID()))
 		{
-			logGlobal->info("Hero crossover: %d (%s) exported to global pool", hero->getHeroType(), hero->getNameTranslated());
-			globalHeroPool[hero->getHeroType()] = node;
+			logGlobal->info("Hero crossover: %d (%s) exported to global pool", hero->getHeroTypeID(), hero->getNameTranslated());
+			globalHeroPool[hero->getHeroTypeID()] = node;
 		}
 		else
 		{
-			logGlobal->info("Hero crossover: %d (%s) exported to scenario pool", hero->getHeroType(), hero->getNameTranslated());
+			logGlobal->info("Hero crossover: %d (%s) exported to scenario pool", hero->getHeroTypeID(), hero->getNameTranslated());
 			scenarioHeroPool[*currentMap].push_back(node);
 		}
 	}
@@ -373,7 +443,10 @@
 	hero->ID = Obj::HERO;
 	hero->serializeJsonOptions(handler);
 	if (map)
-		hero->serializeJsonArtifacts(handler, "artifacts", map);
+	{
+		hero->serializeJsonArtifacts(handler, "artifacts");
+		map->addNewArtifactInstance(*hero);
+	}
 	return hero;
 }
 
@@ -421,6 +494,47 @@
 	return result;
 }
 
+void Campaign::overrideCampaign()
+{
+	const JsonNode node = JsonUtils::assembleFromFiles("config/campaignOverrides.json");
+	for (auto & entry : node.Struct())
+		if(filename == entry.first)
+		{
+			if(!entry.second["regions"].isNull() && !entry.second["scenarioCount"].isNull())
+				loadLegacyData(CampaignRegions::fromJson(entry.second["regions"]), entry.second["scenarioCount"].Integer());
+			if(!entry.second["loadingBackground"].isNull())
+				loadingBackground = ImagePath::builtin(entry.second["loadingBackground"].String());
+			if(!entry.second["videoRim"].isNull())
+				videoRim = ImagePath::builtin(entry.second["videoRim"].String());
+			if(!entry.second["introVideo"].isNull())
+				introVideo = VideoPath::builtin(entry.second["introVideo"].String());
+			if(!entry.second["outroVideo"].isNull())
+				outroVideo = VideoPath::builtin(entry.second["outroVideo"].String());
+		}
+}
+
+void Campaign::overrideCampaignScenarios()
+{
+	const JsonNode node = JsonUtils::assembleFromFiles("config/campaignOverrides.json");
+	for (auto & entry : node.Struct())
+		if(filename == entry.first)
+		{
+			if(!entry.second["scenarios"].isNull())
+			{
+				auto sc = entry.second["scenarios"].Vector();
+				for(int i = 0; i < sc.size(); i++)
+				{
+					auto it = scenarios.begin();
+					std::advance(it, i);
+					if(!sc.at(i)["voiceProlog"].isNull())
+						it->second.prolog.prologVoice = AudioPath::builtin(sc.at(i)["voiceProlog"].String());
+					if(!sc.at(i)["voiceEpilog"].isNull())
+						it->second.epilog.prologVoice = AudioPath::builtin(sc.at(i)["voiceEpilog"].String());
+				}
+			}
+		}
+}
+
 int Campaign::scenariosCount() const
 {
 	return allScenarios().size();
diff --color -urN vcmi-1.5.7/lib/campaign/CampaignState.h vcmi/lib/campaign/CampaignState.h
--- vcmi-1.5.7/lib/campaign/CampaignState.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/campaign/CampaignState.h	2024-12-19 15:00:22.896147855 +0100
@@ -10,11 +10,13 @@
 #pragma once
 
 #include "../GameConstants.h"
-#include "../MetaString.h"
 #include "../filesystem/ResourcePath.h"
-#include "../CGeneralTextHandler.h"
+#include "../serializer/Serializeable.h"
+#include "../texts/TextLocalizationContainer.h"
 #include "CampaignConstants.h"
 #include "CampaignScenarioPrologEpilog.h"
+#include "../gameState/HighScore.h"
+#include "../Point.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
@@ -26,25 +28,34 @@
 class CMapHeader;
 class CMapInfo;
 class JsonNode;
-class Point;
 class IGameCallback;
 
 class DLL_LINKAGE CampaignRegions
 {
 	std::string campPrefix;
+	std::vector<std::string> campSuffix;
+	std::string campBackground;
 	int colorSuffixLength;
 
 	struct DLL_LINKAGE RegionDescription
 	{
 		std::string infix;
-		int xpos;
-		int ypos;
+		Point pos;
+		std::optional<Point> labelPos;
 
 		template <typename Handler> void serialize(Handler &h)
 		{
 			h & infix;
-			h & xpos;
-			h & ypos;
+			if (h.version >= Handler::Version::REGION_LABEL)
+			{
+				h & pos;
+				h & labelPos;
+			}
+			else
+			{
+				h & pos.x;
+				h & pos.y;
+			}
 		}
 
 		static CampaignRegions::RegionDescription fromJson(const JsonNode & node);
@@ -57,6 +68,7 @@
 public:
 	ImagePath getBackgroundName() const;
 	Point getPosition(CampaignScenarioID which) const;
+	std::optional<Point> getLabelPosition(CampaignScenarioID which) const;
 	ImagePath getAvailableName(CampaignScenarioID which, int color) const;
 	ImagePath getSelectedName(CampaignScenarioID which, int color) const;
 	ImagePath getConqueredName(CampaignScenarioID which, int color) const;
@@ -66,6 +78,11 @@
 		h & campPrefix;
 		h & colorSuffixLength;
 		h & regions;
+		if (h.version >= Handler::Version::CAMPAIGN_REGIONS)
+		{
+			h & campSuffix;
+			h & campBackground;
+		}
 	}
 
 	static CampaignRegions fromJson(const JsonNode & node);
@@ -75,20 +92,30 @@
 class DLL_LINKAGE CampaignHeader : public boost::noncopyable
 {
 	friend class CampaignHandler;
+	friend class Campaign;
 
 	CampaignVersion version = CampaignVersion::NONE;
 	CampaignRegions campaignRegions;
 	MetaString name;
 	MetaString description;
+	MetaString author;
+	MetaString authorContact;
+	MetaString campaignVersion;
+	std::time_t creationDateTime;
 	AudioPath music;
 	std::string filename;
 	std::string modName;
 	std::string encoding;
+	ImagePath loadingBackground;
+	ImagePath videoRim;
+	VideoPath introVideo;
+	VideoPath outroVideo;
 
 	int numberOfScenarios = 0;
-	bool difficultyChoosenByPlayer = false;
+	bool difficultyChosenByPlayer = false;
 
 	void loadLegacyData(ui8 campId);
+	void loadLegacyData(CampaignRegions regions, int numOfScenario);
 
 	TextContainerRegistrable textContainer;
 
@@ -98,10 +125,18 @@
 
 	std::string getDescriptionTranslated() const;
 	std::string getNameTranslated() const;
+	std::string getAuthor() const;
+	std::string getAuthorContact() const;
+	std::string getCampaignVersion() const;
+	time_t getCreationDateTime() const;
 	std::string getFilename() const;
 	std::string getModName() const;
 	std::string getEncoding() const;
 	AudioPath getMusic() const;
+	ImagePath getLoadingBackground() const;
+	ImagePath getVideoRim() const;
+	VideoPath getIntroVideo() const;
+	VideoPath getOutroVideo() const;
 
 	const CampaignRegions & getRegions() const;
 	TextContainerRegistrable & getTexts();
@@ -113,13 +148,27 @@
 		h & numberOfScenarios;
 		h & name;
 		h & description;
-		h & difficultyChoosenByPlayer;
+		if (h.version >= Handler::Version::MAP_FORMAT_ADDITIONAL_INFOS)
+		{
+			h & author;
+			h & authorContact;
+			h & campaignVersion;
+			h & creationDateTime;
+		}
+		h & difficultyChosenByPlayer;
 		h & filename;
 		h & modName;
 		h & music;
 		h & encoding;
-		if (h.version >= Handler::Version::RELEASE_143)
-			h & textContainer;
+		h & textContainer;
+		if (h.version >= Handler::Version::CHRONICLES_SUPPORT)
+		{
+			h & loadingBackground;
+			h & videoRim;
+			h & introVideo;
+		}
+		if (h.version >= Handler::Version::CAMPAIGN_OUTRO_SUPPORT)
+			h & outroVideo;
 	}
 };
 
@@ -214,7 +263,7 @@
 };
 
 /// Class that represents loaded campaign information
-class DLL_LINKAGE Campaign : public CampaignHeader
+class DLL_LINKAGE Campaign : public CampaignHeader, public Serializeable
 {
 	friend class CampaignHandler;
 
@@ -225,6 +274,9 @@
 	std::set<CampaignScenarioID> allScenarios() const;
 	int scenariosCount() const;
 
+	void overrideCampaign();
+	void overrideCampaignScenarios();
+
 	template <typename Handler> void serialize(Handler &h)
 	{
 		h & static_cast<CampaignHeader&>(*this);
@@ -307,6 +359,8 @@
 
 	std::string campaignSet;
 
+	std::vector<HighScoreParameter> highscoreParameters;
+
 	template <typename Handler> void serialize(Handler &h)
 	{
 		h & static_cast<Campaign&>(*this);
@@ -317,8 +371,9 @@
 		h & currentMap;
 		h & chosenCampaignBonuses;
 		h & campaignSet;
-		if (h.version >= Handler::Version::CAMPAIGN_MAP_TRANSLATIONS)
-			h & mapTranslations;
+		h & mapTranslations;
+		if (h.version >= Handler::Version::HIGHSCORE_PARAMETERS)
+			h & highscoreParameters;
 	}
 };
 
diff --color -urN vcmi-1.5.7/lib/CArtHandler.cpp vcmi/lib/CArtHandler.cpp
--- vcmi-1.5.7/lib/CArtHandler.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/CArtHandler.cpp	2024-12-19 15:00:22.823144838 +0100
@@ -11,15 +11,16 @@
 #include "StdInc.h"
 
 #include "ArtifactUtils.h"
-#include "CGeneralTextHandler.h"
 #include "ExceptionsCommon.h"
-#include "GameSettings.h"
+#include "IGameSettings.h"
 #include "mapObjects/MapObjects.h"
 #include "constants/StringConstants.h"
 #include "json/JsonBonus.h"
 #include "mapObjectConstructors/AObjectTypeHandler.h"
 #include "mapObjectConstructors/CObjectClassesHandler.h"
 #include "serializer/JsonSerializeFormat.h"
+#include "texts/CGeneralTextHandler.h"
+#include "texts/CLegacyConfigParser.h"
 
 // Note: list must match entries in ArtTraits.txt
 #define ART_POS_LIST    \
@@ -55,11 +56,26 @@
 	return constituents;
 }
 
-const std::vector<const CArtifact*> & CCombinedArtifact::getPartOf() const
+const std::set<const CArtifact*> & CCombinedArtifact::getPartOf() const
 {
 	return partOf;
 }
 
+void CCombinedArtifact::setFused(bool isFused)
+{
+	fused = isFused;
+}
+
+bool CCombinedArtifact::isFused() const
+{
+	return fused;
+}
+
+bool CCombinedArtifact::hasParts() const
+{
+	return isCombined() && !isFused();
+}
+
 bool CScrollArtifact::isScroll() const
 {
 	return static_cast<const CArtifact*>(this)->getId() == ArtifactID::SPELL_SCROLL;
@@ -105,6 +121,11 @@
 	return modScope + ':' + identifier;
 }
 
+std::string CArtifact::getModScope() const
+{
+	return modScope;
+}
+
 void CArtifact::registerIcons(const IconRegistar & cb) const
 {
 	cb(getIconIndex(), 0, "ARTIFACT", image);
@@ -171,7 +192,6 @@
 	switch(id.toEnum())
 	{
 	case ArtifactID::SPELLBOOK:
-	case ArtifactID::GRAIL:
 		return false;
 	default:
 		return !isBig();
@@ -197,7 +217,7 @@
 
 	auto artCanBePutAt = [this, simpleArtCanBePutAt](const CArtifactSet * artSet, ArtifactPosition slot, bool assumeDestRemoved) -> bool
 	{
-		if(isCombined())
+		if(hasParts())
 		{
 			if(!simpleArtCanBePutAt(artSet, slot, assumeDestRemoved))
 				return false;
@@ -214,7 +234,7 @@
 				auto possibleSlot = ArtifactUtils::getArtAnyPosition(&fittingSet, art->getId());
 				if(ArtifactUtils::isSlotEquipment(possibleSlot))
 				{
-					fittingSet.setNewArtSlot(possibleSlot, nullptr, true);
+					fittingSet.lockSlot(possibleSlot);
 				}
 				else
 				{
@@ -321,7 +341,7 @@
 
 std::vector<JsonNode> CArtHandler::loadLegacyData()
 {
-	size_t dataSize = VLC->settings()->getInteger(EGameSettings::TEXTS_ARTIFACT);
+	size_t dataSize = VLC->engineSettings()->getInteger(EGameSettings::TEXTS_ARTIFACT);
 
 	objects.resize(dataSize);
 	std::vector<JsonNode> h3Data;
@@ -373,7 +393,7 @@
 
 void CArtHandler::loadObject(std::string scope, std::string name, const JsonNode & data)
 {
-	auto * object = loadFromJson(scope, data, name, objects.size());
+	auto object = loadFromJson(scope, data, name, objects.size());
 
 	object->iconIndex = object->getIndex() + 5;
 
@@ -384,7 +404,7 @@
 
 void CArtHandler::loadObject(std::string scope, std::string name, const JsonNode & data, size_t index)
 {
-	auto * object = loadFromJson(scope, data, name, index);
+	auto object = loadFromJson(scope, data, name, index);
 
 	object->iconIndex = object->getIndex();
 
@@ -400,12 +420,12 @@
 	return typeNames;
 }
 
-CArtifact * CArtHandler::loadFromJson(const std::string & scope, const JsonNode & node, const std::string & identifier, size_t index)
+std::shared_ptr<CArtifact> CArtHandler::loadFromJson(const std::string & scope, const JsonNode & node, const std::string & identifier, size_t index)
 {
 	assert(identifier.find(':') == std::string::npos);
 	assert(!scope.empty());
 
-	CArtifact * art = new CArtifact();
+	auto art = std::make_shared<CArtifact>();
 	if(!node["growing"].isNull())
 	{
 		for(auto bonus : node["growing"]["bonusesPerLevel"].Vector())
@@ -425,9 +445,9 @@
 
 	const JsonNode & text = node["text"];
 
-	VLC->generaltexth->registerString(scope, art->getNameTextID(), text["name"].String());
-	VLC->generaltexth->registerString(scope, art->getDescriptionTextID(), text["description"].String());
-	VLC->generaltexth->registerString(scope, art->getEventTextID(), text["event"].String());
+	VLC->generaltexth->registerString(scope, art->getNameTextID(), text["name"]);
+	VLC->generaltexth->registerString(scope, art->getDescriptionTextID(), text["description"]);
+	VLC->generaltexth->registerString(scope, art->getEventTextID(), text["event"]);
 
 	const JsonNode & graphics = node["graphics"];
 	art->image = graphics["image"].String();
@@ -442,10 +462,10 @@
 	art->price = static_cast<ui32>(node["value"].Float());
 	art->onlyOnWaterMap = node["onlyOnWaterMap"].Bool();
 
-	loadSlots(art, node);
-	loadClass(art, node);
-	loadType(art, node);
-	loadComponents(art, node);
+	loadSlots(art.get(), node);
+	loadClass(art.get(), node);
+	loadType(art.get(), node);
+	loadComponents(art.get(), node);
 
 	for(const auto & b : node["bonuses"].Vector())
 	{
@@ -454,7 +474,7 @@
 	}
 
 	const JsonNode & warMachine = node["warMachine"];
-	if(warMachine.getType() == JsonNode::JsonType::DATA_STRING && !warMachine.String().empty())
+	if(!warMachine.isNull())
 	{
 		VLC->identifiers()->requestIdentifier("creature", warMachine, [=](si32 id)
 		{
@@ -600,19 +620,21 @@
 
 void CArtHandler::loadComponents(CArtifact * art, const JsonNode & node)
 {
-	if (!node["components"].isNull())
+	if(!node["components"].isNull())
 	{
 		for(const auto & component : node["components"].Vector())
 		{
-			VLC->identifiers()->requestIdentifier("artifact", component, [=](si32 id)
+			VLC->identifiers()->requestIdentifier("artifact", component, [this, art](int32_t id)
 			{
 				// when this code is called both combinational art as well as component are loaded
 				// so it is safe to access any of them
 				art->constituents.push_back(ArtifactID(id).toArtifact());
-				objects[id]->partOf.push_back(art);
+				objects[id]->partOf.insert(art);
 			});
 		}
 	}
+	if(!node["fusedComponents"].isNull())
+		art->setFused(node["fusedComponents"].Bool());
 }
 
 void CArtHandler::makeItCreatureArt(CArtifact * a, bool onlyCreature)
@@ -650,10 +672,10 @@
 	if(art->possibleSlots.count(ArtBearer::HERO) && !art->possibleSlots.at(ArtBearer::HERO).empty())
 		return true;
 
-	if(art->possibleSlots.count(ArtBearer::CREATURE) && !art->possibleSlots.at(ArtBearer::CREATURE).empty() && VLC->settings()->getBoolean(EGameSettings::MODULE_STACK_ARTIFACT))
+	if(art->possibleSlots.count(ArtBearer::CREATURE) && !art->possibleSlots.at(ArtBearer::CREATURE).empty() && VLC->engineSettings()->getBoolean(EGameSettings::MODULE_STACK_ARTIFACT))
 		return true;
 
-	if(art->possibleSlots.count(ArtBearer::COMMANDER) && !art->possibleSlots.at(ArtBearer::COMMANDER).empty() && VLC->settings()->getBoolean(EGameSettings::MODULE_COMMANDERS))
+	if(art->possibleSlots.count(ArtBearer::COMMANDER) && !art->possibleSlots.at(ArtBearer::COMMANDER).empty() && VLC->engineSettings()->getBoolean(EGameSettings::MODULE_COMMANDERS))
 		return true;
 
 	return false;
@@ -663,7 +685,7 @@
 {
 	std::set<ArtifactID> allowedArtifacts;
 
-	for (auto artifact : objects)
+	for (const auto & artifact : objects)
 	{
 		if (!artifact->isCombined())
 			allowedArtifacts.insert(artifact->getId());
@@ -685,9 +707,7 @@
 	CBonusSystemNode::treeHasChanged();
 }
 
-CArtifactSet::~CArtifactSet() = default;
-
-const CArtifactInstance * CArtifactSet::getArt(const ArtifactPosition & pos, bool excludeLocked) const
+CArtifactInstance * CArtifactSet::getArt(const ArtifactPosition & pos, bool excludeLocked) const
 {
 	if(const ArtSlotInfo * si = getSlot(pos))
 	{
@@ -698,80 +718,45 @@
 	return nullptr;
 }
 
-CArtifactInstance * CArtifactSet::getArt(const ArtifactPosition & pos, bool excludeLocked)
-{
-	return const_cast<CArtifactInstance*>((const_cast<const CArtifactSet*>(this))->getArt(pos, excludeLocked));
-}
-
 ArtifactPosition CArtifactSet::getArtPos(const ArtifactID & aid, bool onlyWorn, bool allowLocked) const
 {
-	const auto result = getAllArtPositions(aid, onlyWorn, allowLocked, false);
-	return result.empty() ? ArtifactPosition{ArtifactPosition::PRE_FIRST} : result[0];
-}
-
-std::vector<ArtifactPosition> CArtifactSet::getAllArtPositions(const ArtifactID & aid, bool onlyWorn, bool allowLocked, bool getAll) const
-{
-	std::vector<ArtifactPosition> result;
-	for(const auto & slotInfo : artifactsWorn)
-		if(slotInfo.second.artifact->getTypeId() == aid && (allowLocked || !slotInfo.second.locked))
-			result.push_back(slotInfo.first);
-
-	if(onlyWorn)
-		return result;
-	if(!getAll && !result.empty())
-		return result;
-
-	auto backpackPositions = getBackpackArtPositions(aid);
-	result.insert(result.end(), backpackPositions.begin(), backpackPositions.end());
-	return result;
-}
-
-std::vector<ArtifactPosition> CArtifactSet::getBackpackArtPositions(const ArtifactID & aid) const
-{
-	std::vector<ArtifactPosition> result;
-
-	si32 backpackPosition = ArtifactPosition::BACKPACK_START;
-	for(const auto & artInfo : artifactsInBackpack)
+	for(const auto & [slot, slotInfo] : artifactsWorn)
 	{
-		const auto * art = artInfo.getArt();
-		if(art && art->artType->getId() == aid)
-			result.emplace_back(backpackPosition);
-		backpackPosition++;
+		if(slotInfo.artifact->getTypeId() == aid && (allowLocked || !slotInfo.locked))
+			return slot;
+	}
+	if(!onlyWorn)
+	{
+		size_t backpackPositionIdx = ArtifactPosition::BACKPACK_START;
+		for(const auto & artInfo : artifactsInBackpack)
+		{
+			const auto art = artInfo.getArt();
+			if(art && art->getType()->getId() == aid)
+				return ArtifactPosition(backpackPositionIdx);
+			backpackPositionIdx++;
+		}
 	}
-	return result;
-}
-
-ArtifactPosition CArtifactSet::getArtPos(const CArtifactInstance *art) const
-{
-	for(auto i : artifactsWorn)
-		if(i.second.artifact == art)
-			return i.first;
-
-	for(int i = 0; i < artifactsInBackpack.size(); i++)
-		if(artifactsInBackpack[i].artifact == art)
-			return ArtifactPosition::BACKPACK_START + i;
-
 	return ArtifactPosition::PRE_FIRST;
 }
 
 const CArtifactInstance * CArtifactSet::getArtByInstanceId(const ArtifactInstanceID & artInstId) const
 {
-	for(auto i : artifactsWorn)
+	for(const auto & i : artifactsWorn)
 		if(i.second.artifact->getId() == artInstId)
 			return i.second.artifact;
 
-	for(auto i : artifactsInBackpack)
+	for(const auto & i : artifactsInBackpack)
 		if(i.artifact->getId() == artInstId)
 			return i.artifact;
 
 	return nullptr;
 }
 
-const ArtifactPosition CArtifactSet::getSlotByInstance(const CArtifactInstance * artInst) const
+ArtifactPosition CArtifactSet::getArtPos(const CArtifactInstance * artInst) const
 {
 	if(artInst)
 	{
-		for(const auto & slot : artInst->artType->getPossibleSlots().at(bearerType()))
+		for(const auto & slot : artInst->getType()->getPossibleSlots().at(bearerType()))
 			if(getArt(slot) == artInst)
 				return slot;
 
@@ -786,38 +771,44 @@
 	return ArtifactPosition::PRE_FIRST;
 }
 
-bool CArtifactSet::hasArt(const ArtifactID & aid, bool onlyWorn, bool searchBackpackAssemblies, bool allowLocked) const
-{
-	return getArtPosCount(aid, onlyWorn, searchBackpackAssemblies, allowLocked) > 0;
-}
-
-bool CArtifactSet::hasArtBackpack(const ArtifactID & aid) const
+bool CArtifactSet::hasArt(const ArtifactID & aid, bool onlyWorn, bool searchCombinedParts) const
 {
-	return !getBackpackArtPositions(aid).empty();
-}
-
-unsigned CArtifactSet::getArtPosCount(const ArtifactID & aid, bool onlyWorn, bool searchBackpackAssemblies, bool allowLocked) const
-{
-	const auto allPositions = getAllArtPositions(aid, onlyWorn, allowLocked, true);
-	if(!allPositions.empty())
-		return allPositions.size();
-
-	if(searchBackpackAssemblies && getHiddenArt(aid))
-		return 1;
-
-	return 0;
+	if(searchCombinedParts && getCombinedArtWithPart(aid))
+		return true;
+	if(getArtPos(aid, onlyWorn, searchCombinedParts) != ArtifactPosition::PRE_FIRST)
+		return true;
+	return false;
 }
 
-CArtifactSet::ArtPlacementMap CArtifactSet::putArtifact(ArtifactPosition slot, CArtifactInstance * art)
+CArtifactSet::ArtPlacementMap CArtifactSet::putArtifact(const ArtifactPosition & slot, CArtifactInstance * art)
 {
 	ArtPlacementMap resArtPlacement;
+	const auto putToSlot = [this](const ArtifactPosition & targetSlot, CArtifactInstance * targetArt, bool locked)
+	{
+		ArtSlotInfo * slotInfo;
+		if(targetSlot == ArtifactPosition::TRANSITION_POS)
+		{
+			slotInfo = &artifactsTransitionPos;
+		}
+		else if(ArtifactUtils::isSlotEquipment(targetSlot))
+		{
+			slotInfo = &artifactsWorn[targetSlot];
+		}
+		else
+		{
+			auto position = artifactsInBackpack.begin() + targetSlot - ArtifactPosition::BACKPACK_START;
+			slotInfo = &(*artifactsInBackpack.emplace(position));
+		}
+		slotInfo->artifact = targetArt;
+		slotInfo->locked = locked;
+	};
 
-	setNewArtSlot(slot, art, false);
-	if(art->artType->isCombined() && ArtifactUtils::isSlotEquipment(slot))
+	putToSlot(slot, art, false);
+	if(art->getType()->isCombined() && ArtifactUtils::isSlotEquipment(slot))
 	{
 		const CArtifactInstance * mainPart = nullptr;
 		for(const auto & part : art->getPartsInfo())
-			if(vstd::contains(part.art->artType->getPossibleSlots().at(bearerType()), slot)
+			if(vstd::contains(part.art->getType()->getPossibleSlots().at(bearerType()), slot)
 				&& (part.slot == ArtifactPosition::PRE_FIRST))
 			{
 				mainPart = part.art;
@@ -829,24 +820,43 @@
 			if(part.art != mainPart)
 			{
 				auto partSlot = part.slot;
-				if(!part.art->artType->canBePutAt(this, partSlot))
+				if(!part.art->getType()->canBePutAt(this, partSlot))
 					partSlot = ArtifactUtils::getArtAnyPosition(this, part.art->getTypeId());
 
 				assert(ArtifactUtils::isSlotEquipment(partSlot));
-				setNewArtSlot(partSlot, part.art, true);
-				resArtPlacement.emplace(std::make_pair(part.art, partSlot));
+				putToSlot(partSlot, part.art, true);
+				resArtPlacement.emplace(part.art, partSlot);
 			}
 			else
 			{
-				resArtPlacement.emplace(std::make_pair(part.art, part.slot));
+				resArtPlacement.emplace(part.art, part.slot);
 			}
 		}
 	}
 	return resArtPlacement;
 }
 
-void CArtifactSet::removeArtifact(ArtifactPosition slot)
+void CArtifactSet::removeArtifact(const ArtifactPosition & slot)
 {
+	const auto eraseArtSlot = [this](const ArtifactPosition & slotForErase)
+	{
+		if(slotForErase == ArtifactPosition::TRANSITION_POS)
+		{
+			artifactsTransitionPos.artifact = nullptr;
+		}
+		else if(ArtifactUtils::isSlotBackpack(slotForErase))
+		{
+			auto backpackSlot = ArtifactPosition(slotForErase - ArtifactPosition::BACKPACK_START);
+
+			assert(artifactsInBackpack.begin() + backpackSlot < artifactsInBackpack.end());
+			artifactsInBackpack.erase(artifactsInBackpack.begin() + backpackSlot);
+		}
+		else
+		{
+			artifactsWorn.erase(slotForErase);
+		}
+	};
+
 	if(const auto art = getArt(slot, false))
 	{
 		if(art->isCombined())
@@ -865,7 +875,7 @@
 	}
 }
 
-std::pair<const CArtifactInstance *, const CArtifactInstance *> CArtifactSet::searchForConstituent(const ArtifactID & aid) const
+const CArtifactInstance * CArtifactSet::getCombinedArtWithPart(const ArtifactID & partId) const
 {
 	for(const auto & slot : artifactsInBackpack)
 	{
@@ -874,36 +884,18 @@
 		{
 			for(auto & ci : art->getPartsInfo())
 			{
-				if(ci.art->getTypeId() == aid)
-				{
-					return {art, ci.art};
-				}
+				if(ci.art->getTypeId() == partId)
+					return art;
 			}
 		}
 	}
-	return {nullptr, nullptr};
-}
-
-const CArtifactInstance * CArtifactSet::getHiddenArt(const ArtifactID & aid) const
-{
-	return searchForConstituent(aid).second;
-}
-
-const CArtifactInstance * CArtifactSet::getAssemblyByConstituent(const ArtifactID & aid) const
-{
-	return searchForConstituent(aid).first;
+	return nullptr;
 }
 
 const ArtSlotInfo * CArtifactSet::getSlot(const ArtifactPosition & pos) const
 {
 	if(pos == ArtifactPosition::TRANSITION_POS)
-	{
-		// Always add to the end. Always take from the beginning.
-		if(artifactsTransitionPos.empty())
-			return nullptr;
-		else
-			return &(*artifactsTransitionPos.begin());
-	}
+		return &artifactsTransitionPos;
 	if(vstd::contains(artifactsWorn, pos))
 		return &artifactsWorn.at(pos);
 	if(ArtifactUtils::isSlotBackpack(pos))
@@ -918,6 +910,19 @@
 	return nullptr;
 }
 
+void CArtifactSet::lockSlot(const ArtifactPosition & pos)
+{
+	if(pos == ArtifactPosition::TRANSITION_POS)
+		artifactsTransitionPos.locked = true;
+	else if(ArtifactUtils::isSlotEquipment(pos))
+		artifactsWorn[pos].locked = true;
+	else
+	{
+		assert(artifactsInBackpack.size() > pos - ArtifactPosition::BACKPACK_START);
+		(artifactsInBackpack.begin() + pos - ArtifactPosition::BACKPACK_START)->locked = true;
+	}
+}
+
 bool CArtifactSet::isPositionFree(const ArtifactPosition & pos, bool onlyLockCheck) const
 {
 	if(bearerType() == ArtBearer::ALTAR)
@@ -929,50 +934,6 @@
 	return true; //no slot means not used
 }
 
-void CArtifactSet::setNewArtSlot(const ArtifactPosition & slot, ConstTransitivePtr<CArtifactInstance> art, bool locked)
-{
-	assert(!vstd::contains(artifactsWorn, slot));
-
-	ArtSlotInfo * slotInfo;
-	if(slot == ArtifactPosition::TRANSITION_POS)
-	{
-		// Always add to the end. Always take from the beginning.
-		artifactsTransitionPos.emplace_back();
-		slotInfo = &artifactsTransitionPos.back();
-	}
-	else if(ArtifactUtils::isSlotEquipment(slot))
-	{
-		slotInfo =  &artifactsWorn[slot];
-	}
-	else
-	{
-		auto position = artifactsInBackpack.begin() + slot - ArtifactPosition::BACKPACK_START;
-		slotInfo = &(*artifactsInBackpack.emplace(position, ArtSlotInfo()));
-	}
-	slotInfo->artifact = art;
-	slotInfo->locked = locked;
-}
-
-void CArtifactSet::eraseArtSlot(const ArtifactPosition & slot)
-{
-	if(slot == ArtifactPosition::TRANSITION_POS)
-	{
-		assert(!artifactsTransitionPos.empty());
-		artifactsTransitionPos.erase(artifactsTransitionPos.begin());
-	}
-	else if(ArtifactUtils::isSlotBackpack(slot))
-	{
-		auto backpackSlot = ArtifactPosition(slot - ArtifactPosition::BACKPACK_START);
-
-		assert(artifactsInBackpack.begin() + backpackSlot < artifactsInBackpack.end());
-		artifactsInBackpack.erase(artifactsInBackpack.begin() + backpackSlot);
-	}
-	else
-	{
-		artifactsWorn.erase(slot);
-	}
-}
-
 void CArtifactSet::artDeserializationFix(CBonusSystemNode *node)
 {
 	for(auto & elem : artifactsWorn)
@@ -980,7 +941,7 @@
 			node->attachTo(*elem.second.artifact);
 }
 
-void CArtifactSet::serializeJsonArtifacts(JsonSerializeFormat & handler, const std::string & fieldName, CMap * map)
+void CArtifactSet::serializeJsonArtifacts(JsonSerializeFormat & handler, const std::string & fieldName)
 {
 	//todo: creature and commander artifacts
 	if(handler.saving && artifactsInBackpack.empty() && artifactsWorn.empty())
@@ -988,7 +949,6 @@
 
 	if(!handler.saving)
 	{
-		assert(map);
 		artifactsInBackpack.clear();
 		artifactsWorn.clear();
 	}
@@ -998,13 +958,13 @@
 	switch(bearerType())
 	{
 	case ArtBearer::HERO:
-		serializeJsonHero(handler, map);
+		serializeJsonHero(handler);
 		break;
 	case ArtBearer::CREATURE:
-		serializeJsonCreature(handler, map);
+		serializeJsonCreature(handler);
 		break;
 	case ArtBearer::COMMANDER:
-		serializeJsonCommander(handler, map);
+		serializeJsonCommander(handler);
 		break;
 	default:
 		assert(false);
@@ -1012,11 +972,11 @@
 	}
 }
 
-void CArtifactSet::serializeJsonHero(JsonSerializeFormat & handler, CMap * map)
+void CArtifactSet::serializeJsonHero(JsonSerializeFormat & handler)
 {
 	for(const auto & slot : ArtifactUtils::allWornSlots())
 	{
-		serializeJsonSlot(handler, slot, map);
+		serializeJsonSlot(handler, slot);
 	}
 
 	std::vector<ArtifactID> backpackTemp;
@@ -1032,9 +992,9 @@
 	{
 		for(const ArtifactID & artifactID : backpackTemp)
 		{
-			auto * artifact = ArtifactUtils::createArtifact(map, artifactID);
+			auto * artifact = ArtifactUtils::createArtifact(artifactID);
 			auto slot = ArtifactPosition::BACKPACK_START + artifactsInBackpack.size();
-			if(artifact->artType->canBePutAt(this, slot))
+			if(artifact->getType()->canBePutAt(this, slot))
 			{
 				auto artsMap = putArtifact(slot, artifact);
 				artifact->addPlacementMap(artsMap);
@@ -1043,17 +1003,17 @@
 	}
 }
 
-void CArtifactSet::serializeJsonCreature(JsonSerializeFormat & handler, CMap * map)
+void CArtifactSet::serializeJsonCreature(JsonSerializeFormat & handler)
 {
 	logGlobal->error("CArtifactSet::serializeJsonCreature not implemented");
 }
 
-void CArtifactSet::serializeJsonCommander(JsonSerializeFormat & handler, CMap * map)
+void CArtifactSet::serializeJsonCommander(JsonSerializeFormat & handler)
 {
 	logGlobal->error("CArtifactSet::serializeJsonCommander not implemented");
 }
 
-void CArtifactSet::serializeJsonSlot(JsonSerializeFormat & handler, const ArtifactPosition & slot, CMap * map)
+void CArtifactSet::serializeJsonSlot(JsonSerializeFormat & handler, const ArtifactPosition & slot)
 {
 	ArtifactID artifactID;
 
@@ -1073,9 +1033,9 @@
 
 		if(artifactID != ArtifactID::NONE)
 		{
-			auto * artifact = ArtifactUtils::createArtifact(map, artifactID.toEnum());
+			auto * artifact = ArtifactUtils::createArtifact(artifactID.toEnum());
 
-			if(artifact->artType->canBePutAt(this, slot))
+			if(artifact->getType()->canBePutAt(this, slot))
 			{
 				auto artsMap = putArtifact(slot, artifact);
 				artifact->addPlacementMap(artsMap);
@@ -1088,8 +1048,8 @@
 	}
 }
 
-CArtifactFittingSet::CArtifactFittingSet(ArtBearer::ArtBearer Bearer):
-	Bearer(Bearer)
+CArtifactFittingSet::CArtifactFittingSet(ArtBearer::ArtBearer bearer)
+	: bearer(bearer)
 {
 }
 
@@ -1103,7 +1063,7 @@
 
 ArtBearer::ArtBearer CArtifactFittingSet::bearerType() const
 {
-	return this->Bearer;
+	return this->bearer;
 }
 
 VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/CArtHandler.h vcmi/lib/CArtHandler.h
--- vcmi-1.5.7/lib/CArtHandler.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/CArtHandler.h	2024-12-19 15:00:22.824144879 +0100
@@ -14,8 +14,10 @@
 
 #include "bonuses/Bonus.h"
 #include "bonuses/CBonusSystemNode.h"
+#include "ConstTransitivePtr.h"
 #include "GameConstants.h"
 #include "IHandlerBase.h"
+#include "serializer/Serializeable.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
@@ -23,8 +25,6 @@
 class CGHeroInstance;
 class CArtifactSet;
 class CArtifactInstance;
-class CRandomGenerator;
-class CMap;
 class JsonSerializeFormat;
 
 #define ART_BEARER_LIST \
@@ -46,14 +46,19 @@
 class DLL_LINKAGE CCombinedArtifact
 {
 protected:
-	CCombinedArtifact() = default;
+	CCombinedArtifact() : fused(false) {};
 
 	std::vector<const CArtifact*> constituents; // Artifacts IDs a combined artifact consists of, or nullptr.
-	std::vector<const CArtifact*> partOf; // Reverse map of constituents - combined arts that include this art
+	std::set<const CArtifact*> partOf; // Reverse map of constituents - combined arts that include this art
+	bool fused;
+
 public:
 	bool isCombined() const;
 	const std::vector<const CArtifact*> & getConstituents() const;
-	const std::vector<const CArtifact*> & getPartOf() const;
+	const std::set<const CArtifact*> & getPartOf() const;
+	void setFused(bool isFused);
+	bool isFused() const;
+	bool hasParts() const;
 };
 
 class DLL_LINKAGE CScrollArtifact
@@ -105,6 +110,7 @@
 	int32_t getIndex() const override;
 	int32_t getIconIndex() const override;
 	std::string getJsonKey() const override;
+	std::string getModScope() const override;
 	void registerIcons(const IconRegistar & cb) const override;
 	ArtifactID getId() const override;
 	const IBonusBearer * getBonusBearer() const override;
@@ -162,7 +168,7 @@
 
 protected:
 	const std::vector<std::string> & getTypeNames() const override;
-	CArtifact * loadFromJson(const std::string & scope, const JsonNode & json, const std::string & identifier, size_t index) override;
+	std::shared_ptr<CArtifact> loadFromJson(const std::string & scope, const JsonNode & json, const std::string & identifier, size_t index) override;
 
 private:
 	void addSlot(CArtifact * art, const std::string & slotID) const;
@@ -174,10 +180,10 @@
 
 struct DLL_LINKAGE ArtSlotInfo
 {
-	ConstTransitivePtr<CArtifactInstance> artifact;
-	ui8 locked; //if locked, then artifact points to the combined artifact
+	CArtifactInstance * artifact;
+	bool locked; //if locked, then artifact points to the combined artifact
 
-	ArtSlotInfo() : locked(false) {}
+	ArtSlotInfo() : artifact(nullptr), locked(false) {}
 	const CArtifactInstance * getArt() const;
 
 	template <typename Handler> void serialize(Handler & h)
@@ -187,42 +193,29 @@
 	}
 };
 
-class DLL_LINKAGE CArtifactSet
+class DLL_LINKAGE CArtifactSet : public virtual Serializeable
 {
 public:
 	using ArtPlacementMap = std::map<CArtifactInstance*, ArtifactPosition>;
 
 	std::vector<ArtSlotInfo> artifactsInBackpack; //hero's artifacts from bag
 	std::map<ArtifactPosition, ArtSlotInfo> artifactsWorn; //map<position,artifact_id>; positions: 0 - head; 1 - shoulders; 2 - neck; 3 - right hand; 4 - left hand; 5 - torso; 6 - right ring; 7 - left ring; 8 - feet; 9 - misc1; 10 - misc2; 11 - misc3; 12 - misc4; 13 - mach1; 14 - mach2; 15 - mach3; 16 - mach4; 17 - spellbook; 18 - misc5
-	std::vector<ArtSlotInfo> artifactsTransitionPos; // Used as transition position for dragAndDrop artifact exchange
-
-	void setNewArtSlot(const ArtifactPosition & slot, ConstTransitivePtr<CArtifactInstance> art, bool locked);
-	void eraseArtSlot(const ArtifactPosition & slot);
+	ArtSlotInfo artifactsTransitionPos; // Used as transition position for dragAndDrop artifact exchange
 
 	const ArtSlotInfo * getSlot(const ArtifactPosition & pos) const;
-	const CArtifactInstance * getArt(const ArtifactPosition & pos, bool excludeLocked = true) const; //nullptr - no artifact
-	CArtifactInstance * getArt(const ArtifactPosition & pos, bool excludeLocked = true); //nullptr - no artifact
-	/// Looks for equipped artifact with given ID and returns its slot ID or -1 if none
-	/// (if more than one such artifact lower ID is returned)
+	void lockSlot(const ArtifactPosition & pos);
+	CArtifactInstance * getArt(const ArtifactPosition & pos, bool excludeLocked = true) const;
+	/// Looks for first artifact with given ID
 	ArtifactPosition getArtPos(const ArtifactID & aid, bool onlyWorn = true, bool allowLocked = true) const;
-	ArtifactPosition getArtPos(const CArtifactInstance *art) const;
-	std::vector<ArtifactPosition> getAllArtPositions(const ArtifactID & aid, bool onlyWorn, bool allowLocked, bool getAll) const;
-	std::vector<ArtifactPosition> getBackpackArtPositions(const ArtifactID & aid) const;
+	ArtifactPosition getArtPos(const CArtifactInstance * art) const;
 	const CArtifactInstance * getArtByInstanceId(const ArtifactInstanceID & artInstId) const;
-	const ArtifactPosition getSlotByInstance(const CArtifactInstance * artInst) const;
-	/// Search for constituents of assemblies in backpack which do not have an ArtifactPosition
-	const CArtifactInstance * getHiddenArt(const ArtifactID & aid) const;
-	const CArtifactInstance * getAssemblyByConstituent(const ArtifactID & aid) const;
-	/// Checks if hero possess artifact of given id (either in backack or worn)
-	bool hasArt(const ArtifactID & aid, bool onlyWorn = false, bool searchBackpackAssemblies = false, bool allowLocked = true) const;
-	bool hasArtBackpack(const ArtifactID & aid) const;
+	bool hasArt(const ArtifactID & aid, bool onlyWorn = false, bool searchCombinedParts = false) const;
 	bool isPositionFree(const ArtifactPosition & pos, bool onlyLockCheck = false) const;
-	unsigned getArtPosCount(const ArtifactID & aid, bool onlyWorn = true, bool searchBackpackAssemblies = true, bool allowLocked = true) const;
 
 	virtual ArtBearer::ArtBearer bearerType() const = 0;
-	virtual ArtPlacementMap putArtifact(ArtifactPosition slot, CArtifactInstance * art);
-	virtual void removeArtifact(ArtifactPosition slot);
-	virtual ~CArtifactSet();
+	virtual ArtPlacementMap putArtifact(const ArtifactPosition & slot, CArtifactInstance * art);
+	virtual void removeArtifact(const ArtifactPosition & slot);
+	virtual ~CArtifactSet() = default;
 
 	template <typename Handler> void serialize(Handler &h)
 	{
@@ -232,16 +225,15 @@
 
 	void artDeserializationFix(CBonusSystemNode *node);
 
-	void serializeJsonArtifacts(JsonSerializeFormat & handler, const std::string & fieldName, CMap * map);
-protected:
-	std::pair<const CArtifactInstance *, const CArtifactInstance *> searchForConstituent(const ArtifactID & aid) const;
+	void serializeJsonArtifacts(JsonSerializeFormat & handler, const std::string & fieldName);
+	const CArtifactInstance * getCombinedArtWithPart(const ArtifactID & partId) const;
 
 private:
-	void serializeJsonHero(JsonSerializeFormat & handler, CMap * map);
-	void serializeJsonCreature(JsonSerializeFormat & handler, CMap * map);
-	void serializeJsonCommander(JsonSerializeFormat & handler, CMap * map);
+	void serializeJsonHero(JsonSerializeFormat & handler);
+	void serializeJsonCreature(JsonSerializeFormat & handler);
+	void serializeJsonCommander(JsonSerializeFormat & handler);
 
-	void serializeJsonSlot(JsonSerializeFormat & handler, const ArtifactPosition & slot, CMap * map);//normal slots
+	void serializeJsonSlot(JsonSerializeFormat & handler, const ArtifactPosition & slot);//normal slots
 };
 
 // Used to try on artifacts before the claimed changes have been applied
@@ -253,7 +245,7 @@
 	ArtBearer::ArtBearer bearerType() const override;
 
 protected:
-	ArtBearer::ArtBearer Bearer;
+	ArtBearer::ArtBearer bearer;
 };
 
 VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/CArtifactInstance.cpp vcmi/lib/CArtifactInstance.cpp
--- vcmi-1.5.7/lib/CArtifactInstance.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/CArtifactInstance.cpp	2024-12-19 15:00:22.825144921 +0100
@@ -20,12 +20,12 @@
 void CCombinedArtifactInstance::addPart(CArtifactInstance * art, const ArtifactPosition & slot)
 {
 	auto artInst = static_cast<CArtifactInstance*>(this);
-	assert(vstd::contains_if(artInst->artType->getConstituents(),
+	assert(vstd::contains_if(artInst->getType()->getConstituents(),
 		[=](const CArtifact * partType)
 		{
 			return partType->getId() == art->getTypeId();
 		}));
-	assert(art->getParentNodes().size() == 1  &&  art->getParentNodes().front() == art->artType);
+	assert(art->getParentNodes().size() == 1  &&  art->getParentNodes().front() == art->getType());
 	partsInfo.emplace_back(art, slot);
 	artInst->attachTo(*art);
 }
@@ -44,18 +44,23 @@
 	return false;
 }
 
+bool CCombinedArtifactInstance::hasParts() const
+{
+	return !partsInfo.empty();
+}
+
 const std::vector<CCombinedArtifactInstance::PartInfo> & CCombinedArtifactInstance::getPartsInfo() const
 {
 	return partsInfo;
 }
 
-void CCombinedArtifactInstance::addPlacementMap(CArtifactSet::ArtPlacementMap & placementMap)
+void CCombinedArtifactInstance::addPlacementMap(const CArtifactSet::ArtPlacementMap & placementMap)
 {
 	if(!placementMap.empty())
 		for(auto & part : partsInfo)
 		{
-			assert(placementMap.find(part.art) != placementMap.end());
-			part.slot = placementMap.at(part.art);
+			if(placementMap.find(part.art) != placementMap.end())
+				part.slot = placementMap.at(part.art);
 		}
 }
 
@@ -72,7 +77,7 @@
 {
 	auto artInst = static_cast<CArtifactInstance*>(this);
 	
-	if(artInst->artType->isGrowing())
+	if(artInst->getType()->isGrowing())
 	{
 
 		auto bonus = std::make_shared<Bonus>();
@@ -81,7 +86,7 @@
 		bonus->duration = BonusDuration::COMMANDER_KILLED;
 		artInst->accumulateBonus(bonus);
 
-		for(const auto & bonus : artInst->artType->getBonusesPerLevel())
+		for(const auto & bonus : artInst->getType()->getBonusesPerLevel())
 		{
 			// Every n levels
 			if(artInst->valOfBonuses(BonusType::LEVEL_COUNTER) % bonus.first == 0)
@@ -89,7 +94,7 @@
 				artInst->accumulateBonus(std::make_shared<Bonus>(bonus.second));
 			}
 		}
-		for(const auto & bonus : artInst->artType->getThresholdBonuses())
+		for(const auto & bonus : artInst->getType()->getThresholdBonuses())
 		{
 			// At n level
 			if(artInst->valOfBonuses(BonusType::LEVEL_COUNTER) == bonus.first)
@@ -120,26 +125,23 @@
 
 void CArtifactInstance::setType(const CArtifact * art)
 {
-	artType = art;
+	artTypeID = art->getId();
 	attachToSource(*art);
 }
 
 std::string CArtifactInstance::nodeName() const
 {
-	return "Artifact instance of " + (artType ? artType->getJsonKey() : std::string("uninitialized")) + " type";
+	return "Artifact instance of " + (getType() ? getType()->getJsonKey() : std::string("uninitialized")) + " type";
 }
 
-std::string CArtifactInstance::getDescription() const
+ArtifactID CArtifactInstance::getTypeId() const
 {
-	std::string text = artType->getDescriptionTranslated();
-	if(artType->isScroll())
-		ArtifactUtils::insertScrrollSpellName(text, getScrollSpellID());
-	return text;
+	return artTypeID;
 }
 
-ArtifactID CArtifactInstance::getTypeId() const
+const CArtifact * CArtifactInstance::getType() const
 {
-	return artType->getId();
+	return artTypeID.hasValue() ? artTypeID.toArtifact() : nullptr;
 }
 
 ArtifactInstanceID CArtifactInstance::getId() const
@@ -154,44 +156,22 @@
 
 bool CArtifactInstance::canBePutAt(const CArtifactSet * artSet, ArtifactPosition slot, bool assumeDestRemoved) const
 {
-	return artType->canBePutAt(artSet, slot, assumeDestRemoved);
+	return getType()->canBePutAt(artSet, slot, assumeDestRemoved);
 }
 
 bool CArtifactInstance::isCombined() const
 {
-	return artType->isCombined();
+	return getType()->isCombined();
 }
 
 bool CArtifactInstance::isScroll() const
 {
-	return artType->isScroll();
-}
-
-void CArtifactInstance::putAt(CArtifactSet & set, const ArtifactPosition slot)
-{
-	auto placementMap = set.putArtifact(slot, this);
-	addPlacementMap(placementMap);
-}
-
-void CArtifactInstance::removeFrom(CArtifactSet & set, const ArtifactPosition slot)
-{
-	set.removeArtifact(slot);
-	for(auto & part : partsInfo)
-	{
-		if(part.slot != ArtifactPosition::PRE_FIRST)
-			part.slot = ArtifactPosition::PRE_FIRST;
-	}
-}
-
-void CArtifactInstance::move(CArtifactSet & srcSet, const ArtifactPosition srcSlot, CArtifactSet & dstSet, const ArtifactPosition dstSlot)
-{
-	removeFrom(srcSet, srcSlot);
-	putAt(dstSet, dstSlot);
+	return getType()->isScroll();
 }
 
 void CArtifactInstance::deserializationFix()
 {
-	setType(artType);
+	setType(artTypeID.toArtifact());
 	for(PartInfo & part : partsInfo)
 		attachTo(*part.art);
 }
diff --color -urN vcmi-1.5.7/lib/CArtifactInstance.h vcmi/lib/CArtifactInstance.h
--- vcmi-1.5.7/lib/CArtifactInstance.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/CArtifactInstance.h	2024-12-19 15:00:22.825144921 +0100
@@ -25,7 +25,7 @@
 public:
 	struct PartInfo
 	{
-		ConstTransitivePtr<CArtifactInstance> art;
+		CArtifactInstance * art;
 		ArtifactPosition slot;
 		template <typename Handler> void serialize(Handler & h)
 		{
@@ -38,8 +38,9 @@
 	void addPart(CArtifactInstance * art, const ArtifactPosition & slot);
 	// Checks if supposed part inst is part of this combined art inst
 	bool isPart(const CArtifactInstance * supposedPart) const;
+	bool hasParts() const;
 	const std::vector<PartInfo> & getPartsInfo() const;
-	void addPlacementMap(CArtifactSet::ArtPlacementMap & placementMap);
+	void addPlacementMap(const CArtifactSet::ArtPlacementMap & placementMap);
 
 	template <typename Handler> void serialize(Handler & h)
 	{
@@ -72,15 +73,15 @@
 	void init();
 
 	ArtifactInstanceID id;
+	ArtifactID artTypeID;
 public:
-	const CArtifact * artType = nullptr;
 
 	CArtifactInstance(const CArtifact * art);
 	CArtifactInstance();
 	void setType(const CArtifact * art);
 	std::string nodeName() const override;
-	std::string getDescription() const;
 	ArtifactID getTypeId() const;
+	const CArtifact * getType() const;
 	ArtifactInstanceID getId() const;
 	void setId(ArtifactInstanceID id);
 
@@ -88,16 +89,23 @@
 		bool assumeDestRemoved = false) const;
 	bool isCombined() const;
 	bool isScroll() const;
-	void putAt(CArtifactSet & set, const ArtifactPosition slot);
-	void removeFrom(CArtifactSet & set, const ArtifactPosition slot);
-	void move(CArtifactSet & srcSet, const ArtifactPosition srcSlot, CArtifactSet & dstSet, const ArtifactPosition dstSlot);
 	
 	void deserializationFix();
 	template <typename Handler> void serialize(Handler & h)
 	{
 		h & static_cast<CBonusSystemNode&>(*this);
 		h & static_cast<CCombinedArtifactInstance&>(*this);
-		h & artType;
+		if (h.version >= Handler::Version::REMOVE_VLC_POINTERS)
+		{
+			h & artTypeID;
+		}
+		else
+		{
+			bool isNull = false;
+			h & isNull;
+			if (!isNull)
+				h & artTypeID;
+		}
 		h & id;
 		BONUS_TREE_DESERIALIZATION_FIX
 	}
diff --color -urN vcmi-1.5.7/lib/CBonusTypeHandler.cpp vcmi/lib/CBonusTypeHandler.cpp
--- vcmi-1.5.7/lib/CBonusTypeHandler.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/CBonusTypeHandler.cpp	2024-12-19 15:00:22.826144962 +0100
@@ -15,11 +15,13 @@
 
 #include "filesystem/Filesystem.h"
 
-#include "GameConstants.h"
 #include "CCreatureHandler.h"
-#include "CGeneralTextHandler.h"
-#include "json/JsonUtils.h"
+#include "GameConstants.h"
+#include "VCMI_Lib.h"
+#include "modding/ModScope.h"
 #include "spells/CSpellHandler.h"
+#include "texts/CGeneralTextHandler.h"
+#include "json/JsonUtils.h"
 
 template class std::vector<VCMI_LIB_WRAP_NAMESPACE(CBonusType)>;
 
@@ -199,8 +201,10 @@
 
 void CBonusTypeHandler::load()
 {
-	const JsonNode gameConf(JsonPath::builtin("config/gameConfig.json"));
-	const JsonNode config(JsonUtils::assembleFromFiles(gameConf["bonuses"].convertTo<std::vector<std::string>>()));
+	JsonNode gameConf(JsonPath::builtin("config/gameConfig.json"));
+	gameConf.setModScope(ModScope::scopeBuiltin());
+	JsonNode config(JsonUtils::assembleFromFiles(gameConf["bonuses"]));
+	config.setModScope("vcmi");
 	load(config);
 }
 
@@ -239,8 +243,8 @@
 
 	if (!dest.hidden)
 	{
-		VLC->generaltexth->registerString( "vcmi", dest.getNameTextID(), source["name"].String());
-		VLC->generaltexth->registerString( "vcmi", dest.getDescriptionTextID(), source["description"].String());
+		VLC->generaltexth->registerString( "vcmi", dest.getNameTextID(), source["name"]);
+		VLC->generaltexth->registerString( "vcmi", dest.getDescriptionTextID(), source["description"]);
 	}
 
 	const JsonNode & graphics = source["graphics"];
diff --color -urN vcmi-1.5.7/lib/CBuildingHandler.cpp vcmi/lib/CBuildingHandler.cpp
--- vcmi-1.5.7/lib/CBuildingHandler.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/CBuildingHandler.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,85 +0,0 @@
-/*
- * CBuildingHandler.cpp, part of VCMI engine
- *
- * Authors: listed in file AUTHORS in main folder
- *
- * License: GNU General Public License v2.0 or later
- * Full text of license available in license.txt file, in main folder
- *
- */
-#include "StdInc.h"
-#include "CBuildingHandler.h"
-
-VCMI_LIB_NAMESPACE_BEGIN
-
-BuildingID CBuildingHandler::campToERMU(int camp, FactionID townType, const std::set<BuildingID> & builtBuildings)
-{
-	static const std::vector<BuildingID> campToERMU = 
-	{
-		BuildingID::TOWN_HALL, BuildingID::CITY_HALL,
-		BuildingID::CAPITOL, BuildingID::FORT, BuildingID::CITADEL, BuildingID::CASTLE, BuildingID::TAVERN,
-		BuildingID::BLACKSMITH, BuildingID::MARKETPLACE, BuildingID::RESOURCE_SILO, BuildingID::NONE,
-		BuildingID::MAGES_GUILD_1, BuildingID::MAGES_GUILD_2, BuildingID::MAGES_GUILD_3, BuildingID::MAGES_GUILD_4,
-		BuildingID::MAGES_GUILD_5,
-		BuildingID::SHIPYARD, BuildingID::GRAIL,
-		BuildingID::SPECIAL_1, BuildingID::SPECIAL_2, BuildingID::SPECIAL_3, BuildingID::SPECIAL_4	
-	}; //creature generators with banks - handled separately
-	
-	if (camp < campToERMU.size())
-	{
-		return campToERMU[camp];
-	}
-
-	static const std::vector<int> hordeLvlsPerTType[GameConstants::F_NUMBER] = 
-	{
-		{2}, {1}, {1,4}, {0,2},	{0}, {0}, {0}, {0}, {0}
-	};
-
-	int curPos = static_cast<int>(campToERMU.size());
-	for (int i=0; i<GameConstants::CREATURES_PER_TOWN; ++i)
-	{
-		if(camp == curPos) //non-upgraded
-			return BuildingID(30 + i);
-		curPos++;
-		if(camp == curPos) //upgraded
-			return BuildingID(37 + i);
-		curPos++;
-
-		if (i < 5) // last two levels don't have reserved horde ID. Yet another H3C weirdeness
-		{
-			if (vstd::contains(hordeLvlsPerTType[townType.getNum()], i))
-			{
-				if (camp == curPos)
-				{
-					if (hordeLvlsPerTType[townType.getNum()][0] == i)
-					{
-						BuildingID dwellingID(BuildingID::DWELL_UP_FIRST + hordeLvlsPerTType[townType.getNum()][0]);
-
-						if(vstd::contains(builtBuildings, dwellingID)) //if upgraded dwelling is built
-							return BuildingID::HORDE_1_UPGR;
-						else //upgraded dwelling not presents
-							return BuildingID::HORDE_1;
-					}
-					else
-					{
-						if(hordeLvlsPerTType[townType.getNum()].size() > 1)
-						{
-							BuildingID dwellingID(BuildingID::DWELL_UP_FIRST + hordeLvlsPerTType[townType.getNum()][1]);
-
-							if(vstd::contains(builtBuildings, dwellingID)) //if upgraded dwelling is built
-								return BuildingID::HORDE_2_UPGR;
-							else //upgraded dwelling not presents
-								return BuildingID::HORDE_2;
-						}
-					}
-				}
-			}
-			curPos++;
-		}
-	}
-	assert(0);
-	return BuildingID::NONE; //not found
-}
-
-
-VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/CBuildingHandler.h vcmi/lib/CBuildingHandler.h
--- vcmi-1.5.7/lib/CBuildingHandler.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/CBuildingHandler.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,22 +0,0 @@
-/*
- * CBuildingHandler.h, part of VCMI engine
- *
- * Authors: listed in file AUTHORS in main folder
- *
- * License: GNU General Public License v2.0 or later
- * Full text of license available in license.txt file, in main folder
- *
- */
-#pragma once
-
-#include "GameConstants.h"
-
-VCMI_LIB_NAMESPACE_BEGIN
-
-class DLL_LINKAGE CBuildingHandler
-{
-public:
-	static BuildingID campToERMU(int camp, FactionID townType, const std::set<BuildingID> & builtBuildings);
-};
-
-VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/CConsoleHandler.cpp vcmi/lib/CConsoleHandler.cpp
--- vcmi-1.5.7/lib/CConsoleHandler.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/CConsoleHandler.cpp	2024-12-19 15:00:22.829145086 +0100
@@ -13,6 +13,8 @@
 
 #include "CThreadHelper.h"
 
+#include <boost/stacktrace.hpp>
+
 VCMI_LIB_NAMESPACE_BEGIN
 
 std::mutex CConsoleHandler::smx;
@@ -138,11 +140,36 @@
 			| MiniDumpWithThreadInfo);
 	}
 
-	MiniDumpWriteDump(GetCurrentProcess(), GetCurrentProcessId(), dfile, dumpType, meinfo, 0, 0);
+	MiniDumpWriteDump(GetCurrentProcess(), GetCurrentProcessId(), dfile, dumpType, meinfo, nullptr, nullptr);
 	MessageBoxA(0, "VCMI has crashed. We are sorry. File with information about encountered problem has been created.", "VCMI Crashhandler", MB_OK | MB_ICONERROR);
 }
 
-static void onTerminate()
+LONG WINAPI onUnhandledException(EXCEPTION_POINTERS* exception)
+{
+	logGlobal->error("Disaster happened.");
+
+	PEXCEPTION_RECORD einfo = exception->ExceptionRecord;
+	logGlobal->error("Reason: 0x%x - %s at %04x:%x", einfo->ExceptionCode, exceptionName(einfo->ExceptionCode), exception->ContextRecord->SegCs, (void*)einfo->ExceptionAddress);
+
+	if (einfo->ExceptionCode == EXCEPTION_ACCESS_VIOLATION)
+	{
+		logGlobal->error("Attempt to %s 0x%8x", (einfo->ExceptionInformation[0] == 1 ? "write to" : "read from"), (void*)einfo->ExceptionInformation[1]);
+	}
+	const DWORD threadId = ::GetCurrentThreadId();
+	logGlobal->error("Thread ID: %d", threadId);
+
+	//exception info to be placed in the dump
+	MINIDUMP_EXCEPTION_INFORMATION meinfo = {threadId, exception, TRUE};
+
+	createMemoryDump(&meinfo);
+
+	return EXCEPTION_EXECUTE_HANDLER;
+}
+
+#endif
+
+#ifdef NDEBUG
+[[noreturn]] static void onTerminate()
 {
 	logGlobal->error("Disaster happened.");
 	try
@@ -166,37 +193,21 @@
 		logGlobal->error("Reason: unknown exception!");
 	}
 
+	logGlobal->error("Call stack information:");
+	std::stringstream stream;
+	stream << boost::stacktrace::stacktrace();
+	logGlobal->error("%s", stream.str());
+
+#ifdef VCMI_WINDOWS
 	const DWORD threadId = ::GetCurrentThreadId();
 	logGlobal->error("Thread ID: %d", threadId);
 
 	createMemoryDump(nullptr);
+#endif
 	std::abort();
 }
-
-LONG WINAPI onUnhandledException(EXCEPTION_POINTERS* exception)
-{
-	logGlobal->error("Disaster happened.");
-
-	PEXCEPTION_RECORD einfo = exception->ExceptionRecord;
-	logGlobal->error("Reason: 0x%x - %s at %04x:%x", einfo->ExceptionCode, exceptionName(einfo->ExceptionCode), exception->ContextRecord->SegCs, (void*)einfo->ExceptionAddress);
-
-	if (einfo->ExceptionCode == EXCEPTION_ACCESS_VIOLATION)
-	{
-		logGlobal->error("Attempt to %s 0x%8x", (einfo->ExceptionInformation[0] == 1 ? "write to" : "read from"), (void*)einfo->ExceptionInformation[1]);
-	}
-	const DWORD threadId = ::GetCurrentThreadId();
-	logGlobal->error("Thread ID: %d", threadId);
-
-	//exception info to be placed in the dump
-	MINIDUMP_EXCEPTION_INFORMATION meinfo = {threadId, exception, TRUE};
-
-	createMemoryDump(&meinfo);
-
-	return EXCEPTION_EXECUTE_HANDLER;
-}
 #endif
 
-
 void CConsoleHandler::setColor(EConsoleTextColor::EConsoleTextColor color)
 {
 	TColor colorCode;
@@ -287,13 +298,16 @@
 
 	GetConsoleScreenBufferInfo(handleErr, &csbi);
 	defErrColor = csbi.wAttributes;
-#ifndef _DEBUG
+#ifdef NDEBUG
 	SetUnhandledExceptionFilter(onUnhandledException);
-	std::set_terminate(onTerminate);
 #endif
 #else
 	defColor = "\x1b[0m";
 #endif
+
+#ifdef NDEBUG
+	std::set_terminate(onTerminate);
+#endif
 }
 CConsoleHandler::~CConsoleHandler()
 {
diff --color -urN vcmi-1.5.7/lib/CConsoleHandler.h vcmi/lib/CConsoleHandler.h
--- vcmi-1.5.7/lib/CConsoleHandler.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/CConsoleHandler.h	2024-12-19 15:00:22.830145127 +0100
@@ -85,7 +85,7 @@
 
 	static void setColor(EConsoleTextColor::EConsoleTextColor color); //sets color of text appropriate for given logging level
 
-	/// FIXME: Implement CConsoleHandler as singleton, move some logic into CLogConsoleTarget, etc... needs to be disussed:)
+	/// FIXME: Implement CConsoleHandler as singleton, move some logic into CLogConsoleTarget, etc... needs to be discussed:)
 	/// Without static, application will crash complaining about mutex deleted. In short: CConsoleHandler gets deleted before
 	/// the logging system.
 	static std::mutex smx;
diff --color -urN vcmi-1.5.7/lib/CCreatureHandler.cpp vcmi/lib/CCreatureHandler.cpp
--- vcmi-1.5.7/lib/CCreatureHandler.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/CCreatureHandler.cpp	2024-12-19 15:00:22.833145251 +0100
@@ -10,24 +10,27 @@
 #include "StdInc.h"
 #include "CCreatureHandler.h"
 
-#include "CGeneralTextHandler.h"
 #include "ResourceSet.h"
+#include "entities/faction/CFaction.h"
+#include "entities/faction/CTownHandler.h"
 #include "filesystem/Filesystem.h"
 #include "VCMI_Lib.h"
-#include "CRandomGenerator.h"
-#include "CTownHandler.h"
-#include "GameSettings.h"
+#include "IGameSettings.h"
 #include "constants/StringConstants.h"
 #include "bonuses/Limiters.h"
 #include "bonuses/Updaters.h"
 #include "json/JsonBonus.h"
 #include "serializer/JsonDeserializer.h"
 #include "serializer/JsonUpdater.h"
+#include "texts/CGeneralTextHandler.h"
+#include "texts/CLegacyConfigParser.h"
 #include "mapObjectConstructors/AObjectTypeHandler.h"
 #include "mapObjectConstructors/CObjectClassesHandler.h"
 #include "modding/CModHandler.h"
 #include "ExceptionsCommon.h"
 
+#include <vstd/RNG.h>
+
 VCMI_LIB_NAMESPACE_BEGIN
 
 const std::map<CCreature::CreatureQuantityId, std::string> CCreature::creatureQuantityRanges =
@@ -58,6 +61,11 @@
 	return modScope + ':' + identifier;
 }
 
+std::string CCreature::getModScope() const
+{
+	return modScope;
+}
+
 void CCreature::registerIcons(const IconRegistar & cb) const
 {
 	cb(getIconIndex(), 0, "CPRSMALL", smallIconName);
@@ -109,7 +117,7 @@
 	return hordeGrowth;
 }
 
-FactionID CCreature::getFaction() const
+FactionID CCreature::getFactionID() const
 {
 	return FactionID(faction);
 }
@@ -335,11 +343,6 @@
 	return vstd::contains(upgrades, anotherCre->getId());
 }
 
-bool CCreature::valid() const
-{
-	return this == (*VLC->creh)[idNumber];
-}
-
 std::string CCreature::nodeName() const
 {
 	return "\"" + getNamePluralTextID() + "\"";
@@ -459,59 +462,9 @@
 	}
 }
 
-void CCreatureHandler::loadBonuses(JsonNode & creature, std::string bonuses) const
-{
-	auto makeBonusNode = [&](const std::string & type, double val = 0) -> JsonNode
-	{
-		JsonNode ret;
-		ret["type"].String() = type;
-		ret["val"].Float() = val;
-		return ret;
-	};
-
-	static const std::map<std::string, JsonNode> abilityMap =
-	{
-		{"FLYING_ARMY",            makeBonusNode("FLYING")},
-		{"SHOOTING_ARMY",          makeBonusNode("SHOOTER")},
-		{"SIEGE_WEAPON",           makeBonusNode("SIEGE_WEAPON")},
-		{"const_free_attack",      makeBonusNode("BLOCKS_RETALIATION")},
-		{"IS_UNDEAD",              makeBonusNode("UNDEAD")},
-		{"const_no_melee_penalty", makeBonusNode("NO_MELEE_PENALTY")},
-		{"const_jousting",         makeBonusNode("JOUSTING", 5)},
-		{"KING_1",                 makeBonusNode("KING")}, // Slayer with no expertise
-		{"KING_2",                 makeBonusNode("KING", 2)}, // Advanced Slayer or better
-		{"KING_3",                 makeBonusNode("KING", 3)}, // Expert Slayer only
-		{"const_no_wall_penalty",  makeBonusNode("NO_WALL_PENALTY")},
-		{"MULTI_HEADED",           makeBonusNode("ATTACKS_ALL_ADJACENT")},
-		{"IMMUNE_TO_MIND_SPELLS",  makeBonusNode("MIND_IMMUNITY")},
-		{"HAS_EXTENDED_ATTACK",    makeBonusNode("TWO_HEX_ATTACK_BREATH")}
-	};
-
-	auto hasAbility = [&](const std::string & name) -> bool 
-	{
-		return boost::algorithm::find_first(bonuses, name);
-	};
-
-	for(const auto & a : abilityMap)
-	{
-		if(hasAbility(a.first))
-			creature["abilities"][a.first] = a.second;
-	}
-	if(hasAbility("DOUBLE_WIDE"))
-		creature["doubleWide"].Bool() = true;
-
-	if(hasAbility("const_raises_morale"))
-	{
-		JsonNode node = makeBonusNode("MORALE");
-		node["val"].Float() = 1;
-		node["propagator"].String() = "HERO";
-		creature["abilities"]["const_raises_morale"] = node;
-	}
-}
-
 std::vector<JsonNode> CCreatureHandler::loadLegacyData()
 {
-	size_t dataSize = VLC->settings()->getInteger(EGameSettings::TEXTS_CREATURE);
+	size_t dataSize = VLC->engineSettings()->getInteger(EGameSettings::TEXTS_CREATURE);
 
 	objects.resize(dataSize);
 	std::vector<JsonNode> h3Data;
@@ -578,7 +531,7 @@
 
 		// unused - ability text, not used since we no longer have original creature window
 		parser.readString();
-		loadBonuses(data, parser.readString()); //Attributes
+		parser.readString(); // unused - abilities, not used since we load them all from json configs
 
 		h3Data.push_back(data);
 	}
@@ -588,12 +541,12 @@
 	return h3Data;
 }
 
-CCreature * CCreatureHandler::loadFromJson(const std::string & scope, const JsonNode & node, const std::string & identifier, size_t index)
+std::shared_ptr<CCreature> CCreatureHandler::loadFromJson(const std::string & scope, const JsonNode & node, const std::string & identifier, size_t index)
 {
 	assert(identifier.find(':') == std::string::npos);
 	assert(!scope.empty());
 
-	auto * cre = new CCreature();
+	auto cre = std::make_shared<CCreature>();
 
 	if(node["hasDoubleWeek"].Bool())
 	{
@@ -609,9 +562,9 @@
 
 	cre->cost = ResourceSet(node["cost"]);
 
-	VLC->generaltexth->registerString(scope, cre->getNameSingularTextID(), node["name"]["singular"].String());
-	VLC->generaltexth->registerString(scope, cre->getNamePluralTextID(), node["name"]["plural"].String());
-	VLC->generaltexth->registerString(scope, cre->getDescriptionTextID(), node["description"].String());
+	VLC->generaltexth->registerString(scope, cre->getNameSingularTextID(), node["name"]["singular"]);
+	VLC->generaltexth->registerString(scope, cre->getNamePluralTextID(), node["name"]["plural"]);
+	VLC->generaltexth->registerString(scope, cre->getDescriptionTextID(), node["description"]);
 
 	cre->addBonus(node["hitPoints"].Integer(), BonusType::STACK_HEALTH);
 	cre->addBonus(node["speed"].Integer(), BonusType::STACKS_SPEED);
@@ -636,9 +589,9 @@
 	if(!node["shots"].isNull())
 		cre->addBonus(node["shots"].Integer(), BonusType::SHOTS);
 
-	loadStackExperience(cre, node["stackExperience"]);
-	loadJsonAnimation(cre, node["graphics"]);
-	loadCreatureJson(cre, node);
+	loadStackExperience(cre.get(), node["stackExperience"]);
+	loadJsonAnimation(cre.get(), node["graphics"]);
+	loadCreatureJson(cre.get(), node);
 
 	for(const auto & extraName : node["extraNames"].Vector())
 	{
@@ -696,7 +649,7 @@
 
 void CCreatureHandler::loadCrExpMod()
 {
-	if (VLC->settings()->getBoolean(EGameSettings::MODULE_STACK_EXPERIENCE)) 	//reading default stack experience values
+	if (VLC->engineSettings()->getBoolean(EGameSettings::MODULE_STACK_EXPERIENCE)) 	//reading default stack experience values
 	{
 		//Calculate rank exp values, formula appears complicated bu no parsing needed
 		expRanks.resize(8);
@@ -746,7 +699,7 @@
 
 void CCreatureHandler::loadCrExpBon(CBonusSystemNode & globalEffects)
 {
-	if (VLC->settings()->getBoolean(EGameSettings::MODULE_STACK_EXPERIENCE)) 	//reading default stack experience bonuses
+	if (VLC->engineSettings()->getBoolean(EGameSettings::MODULE_STACK_EXPERIENCE)) 	//reading default stack experience bonuses
 	{
 		logGlobal->debug("\tLoading stack experience bonuses");
 		auto addBonusForAllCreatures = [&](std::shared_ptr<Bonus> b) {
@@ -757,7 +710,7 @@
 		auto addBonusForTier = [&](int tier, std::shared_ptr<Bonus> b) {
 			assert(vstd::iswithin(tier, 1, 7));
 			//bonuses from level 7 are given to high-level creatures too
-			auto max = tier == GameConstants::CREATURES_PER_TOWN ? std::numeric_limits<int>::max() : tier + 1;
+			auto max = tier == 7 ? std::numeric_limits<int>::max() : tier + 1;
 			auto limiter = std::make_shared<CreatureLevelLimiter>(tier, max);
 			b->addLimiter(limiter);
 			globalEffects.addNewBonus(b);
@@ -825,7 +778,7 @@
 	parser.endLine(); // header
 	parser.endLine();
 
-	for(int dd = 0; dd < VLC->settings()->getInteger(EGameSettings::TEXTS_CREATURE); ++dd)
+	for(int dd = 0; dd < VLC->engineSettings()->getInteger(EGameSettings::TEXTS_CREATURE); ++dd)
 	{
 		while (parser.isNextEntryEmpty() && parser.endLine()) // skip empty lines
 			;
@@ -884,15 +837,15 @@
 
 	const JsonNode & missile = graphics["missile"];
 	const JsonNode & offsets = missile["offset"];
-	cre->animation.upperRightMissleOffsetX = static_cast<int>(offsets["upperX"].Float());
-	cre->animation.upperRightMissleOffsetY = static_cast<int>(offsets["upperY"].Float());
-	cre->animation.rightMissleOffsetX =      static_cast<int>(offsets["middleX"].Float());
-	cre->animation.rightMissleOffsetY =      static_cast<int>(offsets["middleY"].Float());
-	cre->animation.lowerRightMissleOffsetX = static_cast<int>(offsets["lowerX"].Float());
-	cre->animation.lowerRightMissleOffsetY = static_cast<int>(offsets["lowerY"].Float());
+	cre->animation.upperRightMissileOffsetX = static_cast<int>(offsets["upperX"].Float());
+	cre->animation.upperRightMissileOffsetY = static_cast<int>(offsets["upperY"].Float());
+	cre->animation.rightMissileOffsetX =      static_cast<int>(offsets["middleX"].Float());
+	cre->animation.rightMissileOffsetY =      static_cast<int>(offsets["middleY"].Float());
+	cre->animation.lowerRightMissileOffsetX = static_cast<int>(offsets["lowerX"].Float());
+	cre->animation.lowerRightMissileOffsetY = static_cast<int>(offsets["lowerY"].Float());
 
 	cre->animation.attackClimaxFrame = static_cast<int>(missile["attackClimaxFrame"].Float());
-	cre->animation.missleFrameAngles = missile["frameAngles"].convertTo<std::vector<double> >();
+	cre->animation.missileFrameAngles = missile["frameAngles"].convertTo<std::vector<double> >();
 
 	cre->smallIconName = graphics["iconSmall"].String();
 	cre->largeIconName = graphics["iconLarge"].String();
@@ -1166,7 +1119,7 @@
 				b.subtype = BonusSubtypeID(SpellID(SpellID::METEOR_SHOWER));
 				b.additionalInfo = 0;//normal immunity
 				break;
-			case 'N': //dispell beneficial spells
+			case 'N': //dispel beneficial spells
 				b.type = BonusType::SPELL_IMMUNITY;
 				b.subtype = BonusSubtypeID(SpellID(SpellID::DISPEL_HELPFUL_SPELLS));
 				b.additionalInfo = 0;//normal immunity
@@ -1362,7 +1315,7 @@
 		p.first = nullptr;
 }
 
-CreatureID CCreatureHandler::pickRandomMonster(CRandomGenerator & rand, int tier) const
+CreatureID CCreatureHandler::pickRandomMonster(vstd::RNG & rand, int tier) const
 {
 	std::vector<CreatureID> allowed;
 	for(const auto & creature : objects)
diff --color -urN vcmi-1.5.7/lib/CCreatureHandler.h vcmi/lib/CCreatureHandler.h
--- vcmi-1.5.7/lib/CCreatureHandler.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/CCreatureHandler.h	2024-12-19 15:00:22.834145293 +0100
@@ -23,11 +23,15 @@
 
 VCMI_LIB_NAMESPACE_BEGIN
 
+namespace vstd
+{
+class RNG;
+}
+
 class CLegacyConfigParser;
 class CCreatureHandler;
 class CCreature;
 class JsonSerializeFormat;
-class CRandomGenerator;
 
 class DLL_LINKAGE CCreature : public Creature, public CBonusSystemNode
 {
@@ -91,10 +95,10 @@
 
 		double timeBetweenFidgets, idleAnimationTime,
 			   walkAnimationTime, attackAnimationTime;
-		int upperRightMissleOffsetX, rightMissleOffsetX, lowerRightMissleOffsetX,
-		    upperRightMissleOffsetY, rightMissleOffsetY, lowerRightMissleOffsetY;
+		int upperRightMissileOffsetX, rightMissileOffsetX, lowerRightMissileOffsetX,
+		    upperRightMissileOffsetY, rightMissileOffsetY, lowerRightMissileOffsetY;
 
-		std::vector<double> missleFrameAngles;
+		std::vector<double> missileFrameAngles;
 		int attackClimaxFrame;
 
 		AnimationPath projectileImageName;
@@ -123,10 +127,11 @@
 	std::string getNamePluralTextID() const override;
 	std::string getNameSingularTextID() const override;
 
-	FactionID getFaction() const override;
+	FactionID getFactionID() const override;
 	int32_t getIndex() const override;
 	int32_t getIconIndex() const override;
 	std::string getJsonKey() const override;
+	std::string getModScope() const override;
 	void registerIcons(const IconRegistar & cb) const override;
 	CreatureID getId() const override;
 	const IBonusBearer * getBonusBearer() const override;
@@ -161,8 +166,6 @@
 	static int estimateCreatureCount(ui32 countID); //reverse version of above function, returns middle of range
 	bool isMyUpgrade(const CCreature *anotherCre) const;
 
-	bool valid() const;
-
 	void addBonus(int val, BonusType type);
 	void addBonus(int val, BonusType type, BonusSubtypeID subtype);
 	std::string nodeName() const override;
@@ -192,8 +195,6 @@
 	void loadStackExperience(CCreature * creature, const JsonNode & input) const;
 	void loadCreatureJson(CCreature * creature, const JsonNode & config) const;
 
-	/// adding abilities from ZCRTRAIT.TXT
-	void loadBonuses(JsonNode & creature, std::string bonuses) const;
 	/// load all creatures from H3 files
 	void load();
 	void loadCommanders();
@@ -210,7 +211,7 @@
 
 protected:
 	const std::vector<std::string> & getTypeNames() const override;
-	CCreature * loadFromJson(const std::string & scope, const JsonNode & node, const std::string & identifier, size_t index) override;
+	std::shared_ptr<CCreature> loadFromJson(const std::string & scope, const JsonNode & node, const std::string & identifier, size_t index) override;
 
 public:
 	std::set<CreatureID> doubledCreatures; //they get double week
@@ -225,7 +226,7 @@
 	std::vector< std::vector <ui8> > skillLevels; //how much of a bonus will be given to commander with every level. SPELL_POWER also gives CASTS and RESISTANCE
 	std::vector <std::pair <std::shared_ptr<Bonus>, std::pair <ui8, ui8> > > skillRequirements; // first - Bonus, second - which two skills are needed to use it
 
-	CreatureID pickRandomMonster(CRandomGenerator & rand, int tier = -1) const; //tier <1 - CREATURES_PER_TOWN> or -1 for any
+	CreatureID pickRandomMonster(vstd::RNG & rand, int tier = -1) const; //tier <1 - CREATURES_PER_TOWN> or -1 for any
 
 	CCreatureHandler();
 	~CCreatureHandler();
diff --color -urN vcmi-1.5.7/lib/CCreatureSet.cpp vcmi/lib/CCreatureSet.cpp
--- vcmi-1.5.7/lib/CCreatureSet.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/CCreatureSet.cpp	2024-12-19 15:00:22.835145334 +0100
@@ -14,13 +14,13 @@
 #include "CConfigHandler.h"
 #include "CCreatureHandler.h"
 #include "VCMI_Lib.h"
-#include "GameSettings.h"
+#include "IGameSettings.h"
+#include "entities/hero/CHeroHandler.h"
 #include "mapObjects/CGHeroInstance.h"
 #include "modding/ModScope.h"
 #include "IGameCallback.h"
-#include "CGeneralTextHandler.h"
+#include "texts/CGeneralTextHandler.h"
 #include "spells/CSpellHandler.h"
-#include "CHeroHandler.h"
 #include "IBonusTypeHandler.h"
 #include "serializer/JsonSerializeFormat.h"
 
@@ -48,7 +48,7 @@
 {
 	auto i = stacks.find(slot);
 	if (i != stacks.end())
-		return i->second->type;
+		return i->second->getCreature();
 	else
 		return nullptr;
 }
@@ -84,11 +84,10 @@
 
 SlotID CCreatureSet::getSlotFor(const CCreature *c, ui32 slotsAmount) const
 {
-	assert(c && c->valid());
+	assert(c);
 	for(const auto & elem : stacks)
 	{
-		assert(elem.second->type->valid());
-		if(elem.second->type == c)
+		if(elem.second->getType() == c)
 		{
 			return elem.first; //if there is already such creature we return its slot id
 		}
@@ -98,18 +97,16 @@
 
 bool CCreatureSet::hasCreatureSlots(const CCreature * c, const SlotID & exclude) const
 {
-	assert(c && c->valid());
+	assert(c);
 	for(const auto & elem : stacks) // elem is const
 	{
 		if(elem.first == exclude) // Check slot
 			continue;
 
-		if(!elem.second || !elem.second->type) // Check creature
+		if(!elem.second || !elem.second->getType()) // Check creature
 			continue;
 
-		assert(elem.second->type->valid());
-
-		if(elem.second->type == c)
+		if(elem.second->getType() == c)
 			return true;
 	}
 	return false;
@@ -117,7 +114,7 @@
 
 std::vector<SlotID> CCreatureSet::getCreatureSlots(const CCreature * c, const SlotID & exclude, TQuantity ignoreAmount) const
 {
-	assert(c && c->valid());
+	assert(c);
 	std::vector<SlotID> result;
 
 	for(const auto & elem : stacks)
@@ -125,13 +122,12 @@
 		if(elem.first == exclude)
 			continue;
 
-		if(!elem.second || !elem.second->type || elem.second->type != c)
+		if(!elem.second || !elem.second->getType() || elem.second->getType() != c)
 			continue;
 
 		if(elem.second->count == ignoreAmount || elem.second->count < 1)
 			continue;
 
-		assert(elem.second->type->valid());
 		result.push_back(elem.first);
 	}
 	return result;
@@ -139,13 +135,13 @@
 
 bool CCreatureSet::isCreatureBalanced(const CCreature * c, TQuantity ignoreAmount) const
 {
-	assert(c && c->valid());
+	assert(c);
 	TQuantity max = 0;
 	auto min = std::numeric_limits<TQuantity>::max();
 
 	for(const auto & elem : stacks)
 	{
-		if(!elem.second || !elem.second->type || elem.second->type != c)
+		if(!elem.second || !elem.second->getType() || elem.second->getType() != c)
 			continue;
 
 		const auto count = elem.second->count;
@@ -153,7 +149,6 @@
 		if(count == ignoreAmount || count < 1)
 			continue;
 
-		assert(elem.second->type->valid());
 
 		if(count > max)
 			max = count;
@@ -214,7 +209,7 @@
 	// https://www.cplusplus.com/reference/map/map/key_comp/
 	for(const auto & pair : stacks)
 	{
-		const auto * creature = pair.second->type;
+		const auto * creature = pair.second->getCreature();
 		auto slot = pair.first;
 		auto lb = creatureMap.lower_bound(creature);
 
@@ -234,7 +229,7 @@
 	{
 		if(pair.first == exclude)
 			continue;
-		creatureQueue.push(std::make_pair(pair.second->type, pair.first));
+		creatureQueue.push(std::make_pair(pair.second->getCreature(), pair.first));
 	}
 	return creatureQueue;
 }
@@ -257,15 +252,15 @@
 		return 0; //TODO? consider issuing a warning
 }
 
-bool CCreatureSet::mergableStacks(std::pair<SlotID, SlotID> & out, const SlotID & preferable) const /*looks for two same stacks, returns slot positions */
+bool CCreatureSet::mergeableStacks(std::pair<SlotID, SlotID> & out, const SlotID & preferable) const /*looks for two same stacks, returns slot positions */
 {
 	//try to match creature to our preferred stack
 	if(preferable.validSlot() &&  vstd::contains(stacks, preferable))
 	{
-		const CCreature *cr = stacks.find(preferable)->second->type;
+		const CCreature *cr = stacks.find(preferable)->second->getCreature();
 		for(const auto & elem : stacks)
 		{
-			if(cr == elem.second->type && elem.first != preferable)
+			if(cr == elem.second->getType() && elem.first != preferable)
 			{
 				out.first = preferable;
 				out.second = elem.first;
@@ -278,7 +273,7 @@
 	{
 		for(const auto & elem : stacks)
 		{
-			if(stack.second->type == elem.second->type && stack.first != elem.first)
+			if(stack.second->getType() == elem.second->getType() && stack.first != elem.first)
 			{
 				out.first = stack.first;
 				out.second = elem.first;
@@ -328,7 +323,7 @@
 	{
 		putStack(slot, stack);
 	}
-	else if(allowMerging && stack->type == getCreature(slot))
+	else if(allowMerging && stack->getType() == getCreature(slot))
 	{
 		joinStack(slot, stack);
 	}
@@ -366,6 +361,14 @@
 	return ret;
 }
 
+ui64 CCreatureSet::getArmyCost() const
+{
+	ui64 ret = 0;
+	for (const auto& elem : stacks)
+		ret += elem.second->getMarketValue();
+	return ret;
+}
+
 ui64 CCreatureSet::getPower(const SlotID & slot) const
 {
 	return getStack(slot).getPower();
@@ -424,7 +427,7 @@
 {
 	assert(hasStackAtSlot(slot));
 	assert(stacks[slot]->count + count > 0);
-	if (VLC->settings()->getBoolean(EGameSettings::MODULE_STACK_EXPERIENCE) && count > stacks[slot]->count)
+	if (count > stacks[slot]->count)
 		stacks[slot]->experience = static_cast<TExpType>(stacks[slot]->experience * (count / static_cast<double>(stacks[slot]->count)));
 	stacks[slot]->count = count;
 	armyChanged();
@@ -514,7 +517,7 @@
 void CCreatureSet::joinStack(const SlotID & slot, CStackInstance * stack)
 {
 	[[maybe_unused]] const CCreature *c = getCreature(slot);
-	assert(c == stack->type);
+	assert(c == stack->getType());
 	assert(c);
 
 	//TODO move stuff
@@ -577,9 +580,9 @@
 		std::set<const CCreature*> cresToAdd;
 		for(const auto & elem : cs.stacks)
 		{
-			SlotID dest = getSlotFor(elem.second->type);
+			SlotID dest = getSlotFor(elem.second->getCreature());
 			if(!dest.validSlot() || hasStackAtSlot(dest))
-				cresToAdd.insert(elem.second->type);
+				cresToAdd.insert(elem.second->getCreature());
 		}
 		return cresToAdd.size() <= freeSlots;
 	}
@@ -590,13 +593,13 @@
 
 		//get types of creatures that need their own slot
 		for(const auto & elem : cs.stacks)
-			if ((j = cres.getSlotFor(elem.second->type)).validSlot())
-				cres.addToSlot(j, elem.second->type->getId(), 1, true);  //merge if possible
+			if ((j = cres.getSlotFor(elem.second->getCreature())).validSlot())
+				cres.addToSlot(j, elem.second->getId(), 1, true);  //merge if possible
 			//cres.addToSlot(elem.first, elem.second->type->getId(), 1, true);
 		for(const auto & elem : stacks)
 		{
-			if ((j = cres.getSlotFor(elem.second->type)).validSlot())
-				cres.addToSlot(j, elem.second->type->getId(), 1, true);  //merge if possible
+			if ((j = cres.getSlotFor(elem.second->getCreature())).validSlot())
+				cres.addToSlot(j, elem.second->getId(), 1, true);  //merge if possible
 			else
 				return false; //no place found
 		}
@@ -693,7 +696,7 @@
 {
 	experience = 0;
 	count = 0;
-	type = nullptr;
+	setType(nullptr);
 	_armyObj = nullptr;
 	setNodeType(STACK_INSTANCE);
 }
@@ -705,9 +708,9 @@
 
 int CStackInstance::getExpRank() const
 {
-	if (!VLC->settings()->getBoolean(EGameSettings::MODULE_STACK_EXPERIENCE))
+	if (!VLC->engineSettings()->getBoolean(EGameSettings::MODULE_STACK_EXPERIENCE))
 		return 0;
-	int tier = type->getLevel();
+	int tier = getType()->getLevel();
 	if (vstd::iswithin(tier, 1, 7))
 	{
 		for(int i = static_cast<int>(VLC->creh->expRanks[tier].size()) - 2; i > -1; --i) //sic!
@@ -730,12 +733,12 @@
 
 int CStackInstance::getLevel() const
 {
-	return std::max(1, static_cast<int>(type->getLevel()));
+	return std::max(1, getType()->getLevel());
 }
 
 void CStackInstance::giveStackExp(TExpType exp)
 {
-	int level = type->getLevel();
+	int level = getType()->getLevel();
 	if (!vstd::iswithin(level, 1, 7))
 		level = 0;
 
@@ -756,17 +759,17 @@
 
 void CStackInstance::setType(const CCreature *c)
 {
-	if(type)
+	if(getCreature())
 	{
-		detachFromSource(*type);
-		if (type->isMyUpgrade(c) && VLC->settings()->getBoolean(EGameSettings::MODULE_STACK_EXPERIENCE))
+		detachFromSource(*getCreature());
+		if (getCreature()->isMyUpgrade(c) && VLC->engineSettings()->getBoolean(EGameSettings::MODULE_STACK_EXPERIENCE))
 			experience = static_cast<TExpType>(experience * VLC->creh->expAfterUpgrade / 100.0);
 	}
 
 	CStackBasicDescriptor::setType(c);
 
-	if(type)
-		attachToSource(*type);
+	if(getCreature())
+		attachToSource(*getCreature());
 }
 std::string CStackInstance::bonusToString(const std::shared_ptr<Bonus>& bonus, bool description) const
 {
@@ -808,7 +811,7 @@
 {
 	if(!randomStack)
 	{
-		return (type && type == type->getId().toEntity(VLC));
+		return (getType() && getType() == getId().toEntity(VLC));
 	}
 	else
 		return allowUnrandomized;
@@ -818,8 +821,8 @@
 {
 	std::ostringstream oss;
 	oss << "Stack of " << count << " of ";
-	if(type)
-		oss << type->getNamePluralTextID();
+	if(getType())
+		oss << getType()->getNamePluralTextID();
 	else
 		oss << "[UNDEFINED TYPE]";
 
@@ -841,21 +844,27 @@
 
 CreatureID CStackInstance::getCreatureID() const
 {
-	if(type)
-		return type->getId();
+	if(getType())
+		return getType()->getId();
 	else
 		return CreatureID::NONE;
 }
 
 std::string CStackInstance::getName() const
 {
-	return (count > 1) ? type->getNamePluralTranslated() : type->getNameSingularTranslated();
+	return (count > 1) ? getType()->getNamePluralTranslated() : getType()->getNameSingularTranslated();
 }
 
 ui64 CStackInstance::getPower() const
 {
-	assert(type);
-	return type->getAIValue() * count;
+	assert(getType());
+	return static_cast<ui64>(getType()->getAIValue()) * count;
+}
+
+ui64 CStackInstance::getMarketValue() const
+{
+	assert(getType());
+	return getType()->getFullRecruitCost().marketValue() * count;
 }
 
 ArtBearer::ArtBearer CStackInstance::bearerType() const
@@ -863,7 +872,7 @@
 	return ArtBearer::CREATURE;
 }
 
-CStackInstance::ArtPlacementMap CStackInstance::putArtifact(ArtifactPosition pos, CArtifactInstance * art)
+CStackInstance::ArtPlacementMap CStackInstance::putArtifact(const ArtifactPosition & pos, CArtifactInstance * art)
 {
 	assert(!getArt(pos));
 	assert(art->canBePutAt(this, pos));
@@ -872,7 +881,7 @@
 	return CArtifactSet::putArtifact(pos, art);
 }
 
-void CStackInstance::removeArtifact(ArtifactPosition pos)
+void CStackInstance::removeArtifact(const ArtifactPosition & pos)
 {
 	assert(getArt(pos));
 
@@ -899,7 +908,7 @@
 	else
 	{
 		//type set by CStackBasicDescriptor::serializeJson
-		if(type == nullptr)
+		if(getType() == nullptr)
 		{
 			uint8_t level = 0;
 			uint8_t upgrade = 0;
@@ -912,10 +921,10 @@
 	}
 }
 
-FactionID CStackInstance::getFaction() const
+FactionID CStackInstance::getFactionID() const
 {
-	if(type)
-		return type->getFaction();
+	if(getType())
+		return getType()->getFactionID();
 		
 	return FactionID::NEUTRAL;
 }
@@ -943,7 +952,7 @@
 	experience = 0;
 	level = 1;
 	count = 1;
-	type = nullptr;
+	setType(nullptr);
 	_armyObj = nullptr;
 	setNodeType (CBonusSystemNode::COMMANDER);
 	secondarySkills.resize (ECommander::SPELL_POWER + 1);
@@ -998,24 +1007,29 @@
 CStackBasicDescriptor::CStackBasicDescriptor() = default;
 
 CStackBasicDescriptor::CStackBasicDescriptor(const CreatureID & id, TQuantity Count):
-	type(id.toCreature()),
+	typeID(id),
 	count(Count)
 {
 }
 
 CStackBasicDescriptor::CStackBasicDescriptor(const CCreature *c, TQuantity Count)
-	: type(c), count(Count)
+	: typeID(c ? c->getId() : CreatureID()), count(Count)
 {
 }
 
+const CCreature * CStackBasicDescriptor::getCreature() const
+{
+	return typeID.hasValue() ? typeID.toCreature() : nullptr;
+}
+
 const Creature * CStackBasicDescriptor::getType() const
 {
-	return type;
+	return typeID.hasValue() ? typeID.toEntity(VLC) : nullptr;
 }
 
 CreatureID CStackBasicDescriptor::getId() const
 {
-	return type->getId();
+	return typeID;
 }
 
 TQuantity CStackBasicDescriptor::getCount() const
@@ -1023,18 +1037,14 @@
 	return count;
 }
 
-
 void CStackBasicDescriptor::setType(const CCreature * c)
 {
-	type = c;
+	typeID = c ? c->getId() : CreatureID();
 }
 
 bool operator== (const CStackBasicDescriptor & l, const CStackBasicDescriptor & r)
 {
-	return (!l.type && !r.type)
-	|| (l.type && r.type
-		&& l.type->getId() == r.type->getId()
-		&& l.count == r.count);
+	return l.typeID == r.typeID && l.count == r.count;
 }
 
 void CStackBasicDescriptor::serializeJson(JsonSerializeFormat & handler)
@@ -1043,9 +1053,9 @@
 
 	if(handler.saving)
 	{
-		if(type)
+		if(typeID.hasValue())
 		{
-			std::string typeName = type->getJsonKey();
+			std::string typeName = typeID.toEntity(VLC)->getJsonKey();
 			handler.serializeString("type", typeName);
 		}
 	}
diff --color -urN vcmi-1.5.7/lib/CCreatureSet.h vcmi/lib/CCreatureSet.h
--- vcmi-1.5.7/lib/CCreatureSet.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/CCreatureSet.h	2024-12-19 15:00:22.836145375 +0100
@@ -11,10 +11,12 @@
 
 #include "bonuses/Bonus.h"
 #include "bonuses/CBonusSystemNode.h"
+#include "serializer/Serializeable.h"
 #include "GameConstants.h"
 #include "CArtHandler.h"
 #include "CArtifactInstance.h"
 #include "CCreatureHandler.h"
+#include "VCMI_Lib.h"
 
 #include <vcmi/Entity.h>
 
@@ -29,8 +31,8 @@
 
 class DLL_LINKAGE CStackBasicDescriptor
 {
+	CreatureID typeID;
 public:
-	const CCreature *type = nullptr;
 	TQuantity count = -1; //exact quantity or quantity ID from CCreature::getQuantityID when getting info about enemy army
 
 	CStackBasicDescriptor();
@@ -39,29 +41,27 @@
 	virtual ~CStackBasicDescriptor() = default;
 
 	const Creature * getType() const;
+	const CCreature * getCreature() const;
 	CreatureID getId() const;
 	TQuantity getCount() const;
 
 	virtual void setType(const CCreature * c);
-	
+
 	friend bool operator== (const CStackBasicDescriptor & l, const CStackBasicDescriptor & r);
 
 	template <typename Handler> void serialize(Handler &h)
 	{
 		if(h.saving)
 		{
-			auto idNumber = type ? type->getId() : CreatureID(CreatureID::NONE);
-			h & idNumber;
+			h & typeID;
 		}
 		else
 		{
-			CreatureID idNumber;
-			h & idNumber;
-			if(idNumber != CreatureID::NONE)
-				setType(dynamic_cast<const CCreature*>(VLC->creatures()->getById(idNumber)));
-			else
-				type = nullptr;
+			CreatureID creatureID;
+			h & creatureID;
+			setType(creatureID.toCreature());
 		}
+
 		h & count;
 	}
 
@@ -104,9 +104,11 @@
 	//IConstBonusProvider
 	const IBonusBearer* getBonusBearer() const override;
 	//INativeTerrainProvider
-	FactionID getFaction() const override;
+	FactionID getFactionID() const override;
 
 	virtual ui64 getPower() const;
+	/// Returns total market value of resources needed to recruit this unit
+	virtual ui64 getMarketValue() const;
 	CCreature::CreatureQuantityId getQuantityID() const;
 	std::string getQuantityTXT(bool capitalized = true) const;
 	virtual int getExpRank() const;
@@ -124,8 +126,8 @@
 	void setArmyObj(const CArmedInstance *ArmyObj);
 	virtual void giveStackExp(TExpType exp);
 	bool valid(bool allowUnrandomized) const;
-	ArtPlacementMap putArtifact(ArtifactPosition pos, CArtifactInstance * art) override;//from CArtifactSet
-	void removeArtifact(ArtifactPosition pos) override;
+	ArtPlacementMap putArtifact(const ArtifactPosition & pos, CArtifactInstance * art) override;//from CArtifactSet
+	void removeArtifact(const ArtifactPosition & pos) override;
 	ArtBearer::ArtBearer bearerType() const override; //from CArtifactSet
 	std::string nodeName() const override; //from CBonusSystemnode
 	void deserializationFix();
@@ -208,7 +210,7 @@
 	static const std::vector<std::string> names{ "wide", "tight" };
 }
 
-class DLL_LINKAGE CCreatureSet : public IArmyDescriptor //seven combined creatures
+class DLL_LINKAGE CCreatureSet : public IArmyDescriptor, public virtual Serializeable //seven combined creatures
 {
 	CCreatureSet(const CCreatureSet &) = delete;
 	CCreatureSet &operator=(const CCreatureSet&);
@@ -266,12 +268,13 @@
 	TMapCreatureSlot getCreatureMap() const;
 	TCreatureQueue getCreatureQueue(const SlotID & exclude) const;
 
-	bool mergableStacks(std::pair<SlotID, SlotID> & out, const SlotID & preferable = SlotID()) const; //looks for two same stacks, returns slot positions;
+	bool mergeableStacks(std::pair<SlotID, SlotID> & out, const SlotID & preferable = SlotID()) const; //looks for two same stacks, returns slot positions;
 	bool validTypes(bool allowUnrandomized = false) const; //checks if all types of creatures are set properly
 	bool slotEmpty(const SlotID & slot) const;
 	int stacksCount() const;
 	virtual bool needsLastStack() const; //true if last stack cannot be taken
 	ui64 getArmyStrength() const; //sum of AI values of creatures
+	ui64 getArmyCost() const; //sum of cost of creatures
 	ui64 getPower(const SlotID & slot) const; //value of specific stack
 	std::string getRoughAmount(const SlotID & slot, int mode = 0) const; //rough size of specific stack
 	std::string getArmyDescription() const;
diff --color -urN vcmi-1.5.7/lib/CGameInfoCallback.cpp vcmi/lib/CGameInfoCallback.cpp
--- vcmi-1.5.7/lib/CGameInfoCallback.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/CGameInfoCallback.cpp	2024-12-19 15:00:22.838145458 +0100
@@ -10,6 +10,7 @@
 #include "StdInc.h"
 #include "CGameInfoCallback.h"
 
+#include "entities/building/CBuilding.h"
 #include "gameState/CGameState.h"
 #include "gameState/InfoAboutArmy.h"
 #include "gameState/SThievesGuildInfo.h"
@@ -19,10 +20,10 @@
 #include "mapObjects/CGTownInstance.h"
 #include "mapObjects/MiscObjects.h"
 #include "networkPacks/ArtifactLocation.h"
-#include "CGeneralTextHandler.h"
+#include "texts/CGeneralTextHandler.h"
 #include "StartInfo.h" // for StartInfo
 #include "battle/BattleInfo.h" // for BattleInfo
-#include "GameSettings.h"
+#include "IGameSettings.h"
 #include "TerrainHandler.h"
 #include "spells/CSpellHandler.h"
 #include "mapping/CMap.h"
@@ -82,7 +83,7 @@
 
 const PlayerState * CGameInfoCallback::getPlayerState(PlayerColor color, bool verbose) const
 {
-	//funtion written from scratch since it's accessed A LOT by AI
+	//function written from scratch since it's accessed A LOT by AI
 
 	if(!color.isValidPlayer())
 	{
@@ -173,6 +174,15 @@
 		return nullptr;
 }
 
+const IMarket * CGameInfoCallback::getMarket(ObjectInstanceID objid) const
+{
+	const CGObjectInstance * obj = getObj(objid, false);
+	if(obj)
+		return dynamic_cast<const IMarket*>(obj);
+	else
+		return nullptr;
+}
+
 void CGameInfoCallback::fillUpgradeInfo(const CArmedInstance *obj, SlotID stackPos, UpgradeInfo &out) const
 {
 	//boost::shared_lock<boost::shared_mutex> lock(*gs->mx);
@@ -226,15 +236,7 @@
 
 	if(obj->ID == Obj::TOWN || obj->ID == Obj::TAVERN)
 	{
-		int taverns = 0;
-		for(auto town : gs->players[*getPlayerID()].towns)
-		{
-			if(town->hasBuilt(BuildingID::TAVERN))
-				taverns++;
-			
-			if(town->hasBuilt(BuildingSubID::THIEVES_GUILD))
-				taverns += 2;
-		}
+		int taverns = gs->players[*getPlayerID()].valOfBonuses(BonusType::THIEVES_GUILD_ACCESS);
 		gs->obtainPlayersStats(thi, taverns);
 	}
 	else if(obj->ID == Obj::DEN_OF_THIEVES)
@@ -246,7 +248,7 @@
 int CGameInfoCallback::howManyTowns(PlayerColor Player) const
 {
 	ERROR_RET_VAL_IF(!hasAccess(Player), "Access forbidden!", -1);
-	return static_cast<int>(gs->players[Player].towns.size());
+	return static_cast<int>(gs->players[Player].getTowns().size());
 }
 
 bool CGameInfoCallback::getTownInfo(const CGObjectInstance * town, InfoAboutTown & dest, const CGObjectInstance * selectedObject) const
@@ -272,6 +274,11 @@
 	return true;
 }
 
+const IGameSettings & CGameInfoCallback::getSettings() const
+{
+	return gs->getSettings();
+}
+
 int3 CGameInfoCallback::guardingCreaturePosition (int3 pos) const //FIXME: redundant?
 {
 	ERROR_RET_VAL_IF(!isVisible(pos), "Tile is not visible!", int3(-1,-1,-1));
@@ -338,10 +345,10 @@
 
 			for(auto & elem : info.army)
 			{
-				if(static_cast<int>(elem.second.type->getAIValue()) > maxAIValue)
+				if(static_cast<int>(elem.second.getCreature()->getAIValue()) > maxAIValue)
 				{
-					maxAIValue = elem.second.type->getAIValue();
-					mostStrong = elem.second.type;
+					maxAIValue = elem.second.getCreature()->getAIValue();
+					mostStrong = elem.second.getCreature();
 				}
 			}
 
@@ -350,7 +357,7 @@
 			else
 				for(auto & elem : info.army)
 				{
-					elem.second.type = mostStrong;
+					elem.second.setType(mostStrong);
 				}
 		};
 
@@ -372,9 +379,9 @@
 			int maxAIValue = 0;
 			const CCreature * mostStrong = nullptr;
 
-			for(auto creature : VLC->creh->objects)
+			for(const auto & creature : VLC->creh->objects)
 			{
-				if(creature->getFaction() == factionIndex && static_cast<int>(creature->getAIValue()) > maxAIValue)
+				if(creature->getFactionID() == factionIndex && static_cast<int>(creature->getAIValue()) > maxAIValue)
 				{
 					maxAIValue = creature->getAIValue();
 					mostStrong = creature.get();
@@ -383,7 +390,7 @@
 
 			if(nullptr != mostStrong) //possible, faction may have no creatures at all
 				for(auto & elem : info.army)
-					elem.second.type = mostStrong;
+					elem.second.setType(mostStrong);
 		};
 
 
@@ -472,6 +479,17 @@
 
 	return ret;
 }
+
+std::vector<ConstTransitivePtr<CGObjectInstance>> CGameInfoCallback::getAllVisitableObjs() const
+{
+	std::vector<ConstTransitivePtr<CGObjectInstance>> ret;
+	for(auto & obj : gs->map->objects)
+		if(obj && obj->isVisitable() && obj->ID != Obj::EVENT && isVisible(obj))
+			ret.push_back(obj);
+
+	return ret;
+}
+
 const CGObjectInstance * CGameInfoCallback::getTopObj (int3 pos) const
 {
 	return vstd::backOrNull(getVisitableObjs(pos));
@@ -532,7 +550,7 @@
 
 	for(const auto & object : gs->map->objects)
 	{
-		if(object && object->ID == Obj::HOLE && object->pos == tile)
+		if(object && object->ID == Obj::HOLE && object->anchorPos() == tile)
 			return EDiggingStatus::TILE_OCCUPIED;
 	}
 	return getTile(tile)->getDiggingStatus();
@@ -555,7 +573,7 @@
 		for(tile.x = 0; tile.x < width; tile.x++)
 			for(tile.y = 0; tile.y < height; tile.y++)
 			{
-				if ((*team->fogOfWarMap)[tile.z][tile.x][tile.y])
+				if (team->fogOfWarMap[tile.z][tile.x][tile.y])
 					(*ptr)[tile.z][tile.x][tile.y] = &gs->map->getTile(tile);
 				else
 					(*ptr)[tile.z][tile.x][tile.y] = nullptr;
@@ -568,10 +586,10 @@
 {
 	ERROR_RET_VAL_IF(!canGetFullInfo(t), "Town is not owned!", EBuildingState::TOWN_NOT_OWNED);
 
-	if(!t->town->buildings.count(ID))
+	if(!t->getTown()->buildings.count(ID))
 		return EBuildingState::BUILDING_ERROR;
 
-	const CBuilding * building = t->town->buildings.at(ID);
+	const CBuilding * building = t->getTown()->buildings.at(ID);
 
 
 	if(t->hasBuilt(ID))	//already built
@@ -599,7 +617,7 @@
 		const PlayerState *ps = getPlayerState(t->tempOwner, false);
 		if(ps)
 		{
-			for(const CGTownInstance *town : ps->towns)
+			for(const CGTownInstance *town : ps->getTowns())
 			{
 				if(town->hasBuilt(BuildingID::CAPITOL))
 				{
@@ -612,7 +630,7 @@
 	{
 		const TerrainTile *tile = getTile(t->bestLocation(), false);
 
-		if(!tile || !tile->terType->isWater())
+		if(!tile || !tile->isWater())
 			return EBuildingState::NO_WATER; //lack of water
 	}
 
@@ -624,7 +642,7 @@
 	if (!t->genBuildingRequirements(ID).test(buildTest))
 		return EBuildingState::PREREQUIRES;
 
-	if(t->builded >= VLC->settings()->getInteger(EGameSettings::TOWNS_BUILDINGS_PER_TURN_CAP))
+	if(t->built >= getSettings().getInteger(EGameSettings::TOWNS_BUILDINGS_PER_TURN_CAP))
 		return EBuildingState::CANT_BUILD_TODAY; //building limit
 
 	//checking resources
@@ -658,11 +676,11 @@
 	text.appendLocalString(EMetaText::GENERAL_TXT, 216);
 	
 	std::string extraText;
-	if(gs->rumor.type == RumorState::TYPE_NONE)
+	if(gs->currentRumor.type == RumorState::TYPE_NONE)
 		return text.toString();
 
-	auto rumor = gs->rumor.last[gs->rumor.type];
-	switch(gs->rumor.type)
+	auto rumor = gs->currentRumor.last[gs->currentRumor.type];
+	switch(gs->currentRumor.type)
 	{
 	case RumorState::TYPE_SPECIAL:
 		text.replaceLocalString(EMetaText::GENERAL_TXT, rumor.first);
@@ -701,9 +719,9 @@
 	ERROR_RET_VAL_IF(!p, "No such player!", -1);
 
 	if(includeGarrisoned)
-		return static_cast<int>(p->heroes.size());
+		return static_cast<int>(p->getHeroes().size());
 	else
-		for(const auto & elem : p->heroes)
+		for(const auto & elem : p->getHeroes())
 			if(!elem->inTownGarrison)
 				ret++;
 	return ret;
@@ -715,7 +733,7 @@
 		return true;
 
 	const TerrainTile *t = getTile(obj->visitablePos()); //get entrance tile
-	const CGObjectInstance *visitor = t->visitableObjects.back(); //visitong hero if present or the obejct itself at last
+	const CGObjectInstance *visitor = t->visitableObjects.back(); //visitong hero if present or the object itself at last
 	return visitor->ID == Obj::HERO && canGetFullInfo(visitor); //owned or allied hero is a visitor
 }
 
@@ -747,7 +765,7 @@
 	auto ret = std::vector < const CGTownInstance *>();
 	for(const auto & i : gs->players)
 	{
-		for(const auto & town : i.second.towns)
+		for(const auto & town : i.second.getTowns())
 		{
 			if(i.first == getPlayerID() || (!onlyOur && isVisible(town, getPlayerID())))
 			{
@@ -779,14 +797,14 @@
 		return -1;
 
 	size_t index = 0;
-	auto & heroes = gs->players[*getPlayerID()].heroes;
+	const auto & heroes = gs->players[*getPlayerID()].getHeroes();
 
-	for (auto & heroe : heroes)
+	for (auto & possibleHero : heroes)
 	{
-		if (includeGarrisoned || !(heroe)->inTownGarrison)
+		if (includeGarrisoned || !(possibleHero)->inTownGarrison)
 			index++;
 
-		if (heroe == hero)
+		if (possibleHero == hero)
 			return static_cast<int>(index);
 	}
 	return -1;
@@ -812,34 +830,12 @@
 
 std::vector < const CGObjectInstance * > CPlayerSpecificInfoCallback::getMyObjects() const
 {
-	std::vector < const CGObjectInstance * > ret;
-	for(const CGObjectInstance * obj : gs->map->objects)
-	{
-		if(obj && obj->tempOwner == getPlayerID())
-			ret.push_back(obj);
-	}
-	return ret;
-}
-
-std::vector < const CGDwelling * > CPlayerSpecificInfoCallback::getMyDwellings() const
-{
-	ASSERT_IF_CALLED_WITH_PLAYER
-	std::vector < const CGDwelling * > ret;
-	for(CGDwelling * dw : gs->getPlayerState(*getPlayerID())->dwellings)
-	{
-		ret.push_back(dw);
-	}
-	return ret;
+	return gs->getPlayerState(*getPlayerID())->getOwnedObjects();
 }
 
 std::vector <QuestInfo> CPlayerSpecificInfoCallback::getMyQuests() const
 {
-	std::vector <QuestInfo> ret;
-	for(const auto & quest : gs->getPlayerState(*getPlayerID())->quests)
-	{
-		ret.push_back (quest);
-	}
-	return ret;
+	return gs->getPlayerState(*getPlayerID())->quests;
 }
 
 int CPlayerSpecificInfoCallback::howManyHeroes(bool includeGarrisoned) const
@@ -857,12 +853,12 @@
 
 	if (!includeGarrisoned)
 	{
-		for(ui32 i = 0; i < p->heroes.size() && static_cast<int>(i) <= serialId; i++)
-			if(p->heroes[i]->inTownGarrison)
+		for(ui32 i = 0; i < p->getHeroes().size() && static_cast<int>(i) <= serialId; i++)
+			if(p->getHeroes()[i]->inTownGarrison)
 				serialId++;
 	}
-	ERROR_RET_VAL_IF(serialId < 0 || serialId >= p->heroes.size(), "No player info", nullptr);
-	return p->heroes[serialId];
+	ERROR_RET_VAL_IF(serialId < 0 || serialId >= p->getHeroes().size(), "No player info", nullptr);
+	return p->getHeroes()[serialId];
 }
 
 const CGTownInstance* CPlayerSpecificInfoCallback::getTownBySerial(int serialId) const
@@ -870,8 +866,8 @@
 	ASSERT_IF_CALLED_WITH_PLAYER
 	const PlayerState *p = getPlayerState(*getPlayerID());
 	ERROR_RET_VAL_IF(!p, "No player info", nullptr);
-	ERROR_RET_VAL_IF(serialId < 0 || serialId >= p->towns.size(), "No player info", nullptr);
-	return p->towns[serialId];
+	ERROR_RET_VAL_IF(serialId < 0 || serialId >= p->getTowns().size(), "No player info", nullptr);
+	return p->getTowns()[serialId];
 }
 
 int CPlayerSpecificInfoCallback::getResourceAmount(GameResID type) const
@@ -961,12 +957,12 @@
 
 const CArtifactInstance * CGameInfoCallback::getArtInstance( ArtifactInstanceID aid ) const
 {
-	return gs->map->artInstances[aid.num];
+	return gs->map->artInstances.at(aid.num);
 }
 
 const CGObjectInstance * CGameInfoCallback::getObjInstance( ObjectInstanceID oid ) const
 {
-	return gs->map->objects[oid.num];
+	return gs->map->objects.at(oid.num);
 }
 
 const CArtifactSet * CGameInfoCallback::getArtSet(const ArtifactLocation & loc) const
@@ -979,12 +975,12 @@
 	vstd::erase_if(ids, [&](const ObjectInstanceID & id) -> bool
 	{
 		const auto * obj = getObj(id, false);
-		return player != PlayerColor::UNFLAGGABLE && (!obj || !isVisible(obj->pos, player));
+		return player != PlayerColor::UNFLAGGABLE && (!obj || !isVisible(obj->visitablePos(), player));
 	});
 	return ids;
 }
 
-std::vector<ObjectInstanceID> CGameInfoCallback::getTeleportChannelEntraces(TeleportChannelID id, PlayerColor player) const
+std::vector<ObjectInstanceID> CGameInfoCallback::getTeleportChannelEntrances(TeleportChannelID id, PlayerColor player) const
 {
 	return getVisibleTeleportObjects(gs->map->teleportChannels[id]->entrances, player);
 }
@@ -996,7 +992,7 @@
 
 ETeleportChannelType CGameInfoCallback::getTeleportChannelType(TeleportChannelID id, PlayerColor player) const
 {
-	std::vector<ObjectInstanceID> entrances = getTeleportChannelEntraces(id, player);
+	std::vector<ObjectInstanceID> entrances = getTeleportChannelEntrances(id, player);
 	std::vector<ObjectInstanceID> exits = getTeleportChannelExits(id, player);
 	if((entrances.empty() || exits.empty()) // impassable if exits or entrances list are empty
 	   || (entrances.size() == 1 && entrances == exits)) // impassable if only entrance and only exit is same object. e.g bidirectional monolith
diff --color -urN vcmi-1.5.7/lib/CGameInfoCallback.h vcmi/lib/CGameInfoCallback.h
--- vcmi-1.5.7/lib/CGameInfoCallback.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/CGameInfoCallback.h	2024-12-19 15:00:22.839145499 +0100
@@ -11,6 +11,7 @@
 
 #include "int3.h"
 #include "ResourceSet.h" // for Res
+#include "ConstTransitivePtr.h"
 
 #define ASSERT_IF_CALLED_WITH_PLAYER if(!getPlayerID()) {logGlobal->error(BOOST_CURRENT_FUNCTION); assert(0);}
 
@@ -18,12 +19,13 @@
 
 class Player;
 class Team;
+class IGameSettings;
 
 struct InfoWindow;
 struct PlayerSettings;
 struct CPackForClient;
 struct TerrainTile;
-struct PlayerState;
+class PlayerState;
 class CTown;
 struct StartInfo;
 struct CPathsInfo;
@@ -48,6 +50,7 @@
 class CGDwelling;
 class CGTeleport;
 class CGTownInstance;
+class IMarket;
 
 class DLL_LINKAGE IGameInfoCallback : boost::noncopyable
 {
@@ -56,7 +59,7 @@
 
 //	//various
 	virtual int getDate(Date mode=Date::DAY) const = 0; //mode=0 - total days in game, mode=1 - day of week, mode=2 - current week, mode=3 - current month
-//	const StartInfo * getStartInfo(bool beforeRandomization = false)const;
+	virtual const StartInfo * getStartInfo(bool beforeRandomization = false) const = 0;
 	virtual bool isAllowed(SpellID id) const = 0;
 	virtual bool isAllowed(ArtifactID id) const = 0;
 	virtual bool isAllowed(SecondarySkill id) const = 0;
@@ -119,7 +122,7 @@
 
 	//teleport
 //	std::vector<ObjectInstanceID> getVisibleTeleportObjects(std::vector<ObjectInstanceID> ids, PlayerColor player)  const;
-//	std::vector<ObjectInstanceID> getTeleportChannelEntraces(TeleportChannelID id, PlayerColor Player = PlayerColor::UNFLAGGABLE) const;
+//	std::vector<ObjectInstanceID> getTeleportChannelEntrances(TeleportChannelID id, PlayerColor Player = PlayerColor::UNFLAGGABLE) const;
 //	std::vector<ObjectInstanceID> getTeleportChannelExits(TeleportChannelID id, PlayerColor Player = PlayerColor::UNFLAGGABLE) const;
 //	ETeleportChannelType getTeleportChannelType(TeleportChannelID id, PlayerColor player = PlayerColor::UNFLAGGABLE) const;
 //	bool isTeleportChannelImpassable(TeleportChannelID id, PlayerColor player = PlayerColor::UNFLAGGABLE) const;
@@ -143,10 +146,11 @@
 public:
 	//various
 	int getDate(Date mode=Date::DAY)const override; //mode=0 - total days in game, mode=1 - day of week, mode=2 - current week, mode=3 - current month
-	virtual const StartInfo * getStartInfo(bool beforeRandomization = false)const;
+	const StartInfo * getStartInfo(bool beforeRandomization = false) const override;
 	bool isAllowed(SpellID id) const override;
 	bool isAllowed(ArtifactID id) const override;
 	bool isAllowed(SecondarySkill id) const override;
+	const IGameSettings & getSettings() const;
 
 	//player
 	std::optional<PlayerColor> getPlayerID() const override;
@@ -186,9 +190,11 @@
 	const CGObjectInstance * getObj(ObjectInstanceID objid, bool verbose = true) const override;
 	virtual std::vector <const CGObjectInstance * > getBlockingObjs(int3 pos)const;
 	std::vector <const CGObjectInstance * > getVisitableObjs(int3 pos, bool verbose = true) const override;
+	std::vector<ConstTransitivePtr<CGObjectInstance>> getAllVisitableObjs() const;
 	virtual std::vector <const CGObjectInstance * > getFlaggableObjects(int3 pos) const;
 	virtual const CGObjectInstance * getTopObj (int3 pos) const;
 	virtual PlayerColor getOwner(ObjectInstanceID heroID) const;
+	virtual const IMarket * getMarket(ObjectInstanceID objid) const;
 
 	//map
 	virtual int3 guardingCreaturePosition (int3 pos) const;
@@ -221,7 +227,7 @@
 
 	//teleport
 	virtual std::vector<ObjectInstanceID> getVisibleTeleportObjects(std::vector<ObjectInstanceID> ids, PlayerColor player)  const;
-	virtual std::vector<ObjectInstanceID> getTeleportChannelEntraces(TeleportChannelID id, PlayerColor Player = PlayerColor::UNFLAGGABLE) const;
+	virtual std::vector<ObjectInstanceID> getTeleportChannelEntrances(TeleportChannelID id, PlayerColor Player = PlayerColor::UNFLAGGABLE) const;
 	virtual std::vector<ObjectInstanceID> getTeleportChannelExits(TeleportChannelID id, PlayerColor Player = PlayerColor::UNFLAGGABLE) const;
 	virtual ETeleportChannelType getTeleportChannelType(TeleportChannelID id, PlayerColor player = PlayerColor::UNFLAGGABLE) const;
 	virtual bool isTeleportChannelImpassable(TeleportChannelID id, PlayerColor player = PlayerColor::UNFLAGGABLE) const;
@@ -245,7 +251,6 @@
 	virtual const CGTownInstance* getTownBySerial(int serialId) const; // serial id is [0, number of towns)
 	virtual const CGHeroInstance* getHeroBySerial(int serialId, bool includeGarrisoned=true) const; // serial id is [0, number of heroes)
 	virtual std::vector <const CGHeroInstance *> getHeroesInfo(bool onlyOur = true) const; //true -> only owned; false -> all visible
-	virtual std::vector <const CGDwelling *> getMyDwellings() const; //returns all dwellings that belong to player
 	virtual std::vector <const CGObjectInstance * > getMyObjects() const; //returns all objects flagged by belonging player
 	virtual std::vector <QuestInfo> getMyQuests() const;
 
diff --color -urN vcmi-1.5.7/lib/CGameInterface.cpp vcmi/lib/CGameInterface.cpp
--- vcmi-1.5.7/lib/CGameInterface.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/CGameInterface.cpp	2024-12-19 15:00:22.839145499 +0100
@@ -13,9 +13,6 @@
 #include "CStack.h"
 #include "VCMIDirs.h"
 
-#include "serializer/BinaryDeserializer.h"
-#include "serializer/BinarySerializer.h"
-
 #ifdef STATIC_AI
 # include "AI/VCAI/VCAI.h"
 # include "AI/Nullkiller/AIGateway.h"
@@ -168,7 +165,7 @@
 }
 
 void CAdventureAI::battleStart(const BattleID & battleID, const CCreatureSet * army1, const CCreatureSet * army2, int3 tile,
-							   const CGHeroInstance * hero1, const CGHeroInstance * hero2, bool side, bool replayAllowed)
+							   const CGHeroInstance * hero1, const CGHeroInstance * hero2, BattleSide side, bool replayAllowed)
 {
 	assert(!battleAI);
 	assert(cbc);
@@ -243,28 +240,4 @@
 	battleAI->yourTacticPhase(battleID, distance);
 }
 
-void CAdventureAI::saveGame(BinarySerializer & h) /*saving */
-{
-	bool hasBattleAI = static_cast<bool>(battleAI);
-	h & hasBattleAI;
-	if(hasBattleAI)
-	{
-		h & battleAI->dllName;
-	}
-}
-
-void CAdventureAI::loadGame(BinaryDeserializer & h) /*loading */
-{
-	bool hasBattleAI = false;
-	h & hasBattleAI;
-	if(hasBattleAI)
-	{
-		std::string dllName;
-		h & dllName;
-		battleAI = CDynLibHandler::getNewBattleAI(dllName);
-		assert(cbc); //it should have been set by the one who new'ed us
-		battleAI->initBattleInterface(env, cbc);
-	}
-}
-
 VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/CGameInterface.h vcmi/lib/CGameInterface.h
--- vcmi-1.5.7/lib/CGameInterface.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/CGameInterface.h	2024-12-19 15:00:22.840145541 +0100
@@ -53,8 +53,6 @@
 class CCreature;
 class CLoadFile;
 class CSaveFile;
-class BinaryDeserializer;
-class BinarySerializer;
 class BattleStateInfo;
 struct ArtifactLocation;
 class BattleStateInfoForRetreat;
@@ -110,9 +108,6 @@
 	virtual void showWorldViewEx(const std::vector<ObjectPosInfo> & objectPositions, bool showTerrain){};
 
 	virtual std::optional<BattleAction> makeSurrenderRetreatDecision(const BattleID & battleID, const BattleStateInfoForRetreat & battleState) = 0;
-
-	virtual void saveGame(BinarySerializer & h) = 0;
-	virtual void loadGame(BinaryDeserializer & h) = 0;
 };
 
 class DLL_LINKAGE CDynLibHandler
@@ -149,7 +144,7 @@
 
 	void battleNewRound(const BattleID & battleID) override;
 	void battleCatapultAttacked(const BattleID & battleID, const CatapultAttack & ca) override;
-	void battleStart(const BattleID & battleID, const CCreatureSet *army1, const CCreatureSet *army2, int3 tile, const CGHeroInstance *hero1, const CGHeroInstance *hero2, bool side, bool replayAllowed) override;
+	void battleStart(const BattleID & battleID, const CCreatureSet *army1, const CCreatureSet *army2, int3 tile, const CGHeroInstance *hero1, const CGHeroInstance *hero2, BattleSide side, bool replayAllowed) override;
 	void battleStacksAttacked(const BattleID & battleID, const std::vector<BattleStackAttacked> & bsa, bool ranged) override;
 	void actionStarted(const BattleID & battleID, const BattleAction &action) override;
 	void battleNewRoundFirst(const BattleID & battleID) override;
@@ -161,9 +156,6 @@
 	void battleSpellCast(const BattleID & battleID, const BattleSpellCast *sc) override;
 	void battleEnd(const BattleID & battleID, const BattleResult *br, QueryID queryID) override;
 	void battleUnitsChanged(const BattleID & battleID, const std::vector<UnitChanges> & units) override;
-
-	void saveGame(BinarySerializer & h) override;
-	void loadGame(BinaryDeserializer & h) override;
 };
 
 VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/CGeneralTextHandler.cpp vcmi/lib/CGeneralTextHandler.cpp
--- vcmi-1.5.7/lib/CGeneralTextHandler.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/CGeneralTextHandler.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,750 +0,0 @@
-/*
- * CGeneralTextHandler.cpp, part of VCMI engine
- *
- * Authors: listed in file AUTHORS in main folder
- *
- * License: GNU General Public License v2.0 or later
- * Full text of license available in license.txt file, in main folder
- *
- */
-#include "StdInc.h"
-#include "CGeneralTextHandler.h"
-
-#include "CConfigHandler.h"
-#include "GameSettings.h"
-#include "Languages.h"
-#include "TextOperations.h"
-#include "VCMIDirs.h"
-#include "VCMI_Lib.h"
-#include "filesystem/Filesystem.h"
-#include "mapObjects/CQuest.h"
-#include "modding/CModHandler.h"
-#include "serializer/JsonSerializeFormat.h"
-
-VCMI_LIB_NAMESPACE_BEGIN
-
-std::recursive_mutex TextLocalizationContainer::globalTextMutex;
-
-/// Detects language and encoding of H3 text files based on matching against pregenerated footprints of H3 file
-void CGeneralTextHandler::detectInstallParameters()
-{
-	using LanguageFootprint = std::array<double, 16>;
-
-	static const std::array<LanguageFootprint, 7> knownFootprints =
-	{ {
-		{ { 0.1602, 0.0000, 0.0357, 0.0054, 0.0038, 0.0017, 0.0077, 0.0214, 0.0000, 0.0000, 0.1264, 0.1947, 0.2012, 0.1406, 0.0480, 0.0532 } },
-		{ { 0.0559, 0.0000, 0.1983, 0.0051, 0.0222, 0.0183, 0.4596, 0.2405, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000 } },
-		{ { 0.0493, 0.0000, 0.1926, 0.0047, 0.0230, 0.0121, 0.4133, 0.2780, 0.0002, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0259, 0.0008 } },
-		{ { 0.0534, 0.0000, 0.1705, 0.0047, 0.0418, 0.0208, 0.4775, 0.2191, 0.0001, 0.0000, 0.0000, 0.0000, 0.0000, 0.0005, 0.0036, 0.0080 } },
-		{ { 0.0534, 0.0000, 0.1701, 0.0067, 0.0157, 0.0133, 0.4328, 0.2540, 0.0001, 0.0043, 0.0000, 0.0244, 0.0000, 0.0000, 0.0181, 0.0071 } },
-		{ { 0.0548, 0.0000, 0.1744, 0.0061, 0.0031, 0.0009, 0.0046, 0.0136, 0.0000, 0.0004, 0.0000, 0.0000, 0.0227, 0.0061, 0.4882, 0.2252 } },
-		{ { 0.0559, 0.0000, 0.1807, 0.0059, 0.0036, 0.0013, 0.0046, 0.0134, 0.0000, 0.0004, 0.0000, 0.0487, 0.0209, 0.0060, 0.4615, 0.1972 } },
-	} };
-
-	static const std::array<std::string, 7> knownLanguages =
-	{ {
-		"chinese",
-		"english",
-		"french",
-		"german",
-		"polish",
-		"russian",
-		"ukrainian"
-	} };
-
-	if(!CResourceHandler::get("core")->existsResource(TextPath::builtin("DATA/GENRLTXT.TXT")))
-	{
-		Settings language = settings.write["session"]["language"];
-		language->String() = "english";
-
-		Settings confidence = settings.write["session"]["languageDeviation"];
-		confidence->Float() = 1.0;
-
-		Settings encoding = settings.write["session"]["encoding"];
-		encoding->String() = Languages::getLanguageOptions("english").encoding;
-
-		return;
-	}
-
-	// load file that will be used for footprint generation
-	// this is one of the most text-heavy files in game and consists solely from translated texts
-	auto resource = CResourceHandler::get("core")->load(TextPath::builtin("DATA/GENRLTXT.TXT"));
-
-	std::array<size_t, 256> charCount{};
-	std::array<double, 16> footprint{};
-	std::array<double, 6> deviations{};
-
-	auto data = resource->readAll();
-
-	// compute how often each character occurs in input file
-	for (si64 i = 0; i < data.second; ++i)
-		charCount[data.first[i]] += 1;
-
-	// and convert computed data into weights
-	// to reduce amount of data, group footprint data into 16-char blocks.
-	// While this will reduce precision, it should not affect output
-	// since we expect only tiny differences compared to reference footprints
-	for (size_t i = 0; i < 256; ++i)
-		footprint[i/16] += static_cast<double>(charCount[i]) / data.second;
-
-	logGlobal->debug("Language footprint: %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f",
-			footprint[0], footprint[1], footprint[2],  footprint[3],  footprint[4],  footprint[5],  footprint[6],  footprint[7],
-			footprint[8], footprint[9], footprint[10], footprint[11], footprint[12], footprint[13], footprint[14], footprint[15]
-		);
-
-	for (size_t i = 0; i < deviations.size(); ++i)
-	{
-		for (size_t j = 0; j < footprint.size(); ++j)
-			deviations[i] += std::abs((footprint[j] - knownFootprints[i][j]));
-	}
-
-	size_t bestIndex = boost::range::min_element(deviations) - deviations.begin();
-
-	for (size_t i = 0; i < deviations.size(); ++i)
-		logGlobal->debug("Comparing to %s: %f", knownLanguages[i], deviations[i]);
-
-	Settings language = settings.write["session"]["language"];
-	language->String() = knownLanguages[bestIndex];
-
-	Settings confidence = settings.write["session"]["languageDeviation"];
-	confidence->Float() = deviations[bestIndex];
-
-	Settings encoding = settings.write["session"]["encoding"];
-	encoding->String() =  Languages::getLanguageOptions(knownLanguages[bestIndex]).encoding;
-}
-
-//Helper for string -> float conversion
-class LocaleWithComma: public std::numpunct<char>
-{
-protected:
-	char do_decimal_point() const override
-	{
-		return ',';
-	}
-};
-
-CLegacyConfigParser::CLegacyConfigParser(const TextPath & resource)
-{
-	auto input = CResourceHandler::get()->load(resource);
-	std::string modName = VLC->modh->findResourceOrigin(resource);
-	std::string language = VLC->modh->getModLanguage(modName);
-	fileEncoding = Languages::getLanguageOptions(language).encoding;
-
-	data.reset(new char[input->getSize()]);
-	input->read(reinterpret_cast<uint8_t*>(data.get()), input->getSize());
-
-	curr = data.get();
-	end = curr + input->getSize();
-}
-
-std::string CLegacyConfigParser::extractQuotedPart()
-{
-	assert(*curr == '\"');
-
-	curr++; // skip quote
-	char * begin = curr;
-
-	while (curr != end && *curr != '\"' && *curr != '\t')
-		curr++;
-
-	return std::string(begin, curr++); //increment curr to close quote
-}
-
-std::string CLegacyConfigParser::extractQuotedString()
-{
-	assert(*curr == '\"');
-
-	std::string ret;
-	while (true)
-	{
-		ret += extractQuotedPart();
-
-		// double quote - add it to string and continue quoted part
-		if (curr < end && *curr == '\"')
-		{
-			ret += '\"';
-		}
-		//extract normal part
-		else if(curr < end && *curr != '\t' && *curr != '\r')
-		{
-			char * begin = curr;
-
-			while (curr < end && *curr != '\t' && *curr != '\r' && *curr != '\"')//find end of string or next quoted part start
-				curr++;
-
-			ret += std::string(begin, curr);
-
-			if(curr>=end || *curr != '\"')
-				return ret;
-		}
-		else // end of string
-			return ret;
-	}
-}
-
-std::string CLegacyConfigParser::extractNormalString()
-{
-	char * begin = curr;
-
-	while (curr < end && *curr != '\t' && *curr != '\r')//find end of string
-		curr++;
-
-	return std::string(begin, curr);
-}
-
-std::string CLegacyConfigParser::readRawString()
-{
-	if (curr >= end || *curr == '\n')
-		return "";
-
-	std::string ret;
-
-	if (*curr == '\"')
-		ret = extractQuotedString();// quoted text - find closing quote
-	else
-		ret = extractNormalString();//string without quotes - copy till \t or \r
-
-	curr++;
-	return ret;
-}
-
-std::string CLegacyConfigParser::readString()
-{
-	// do not convert strings that are already in ASCII - this will only slow down loading process
-	std::string str = readRawString();
-	if (TextOperations::isValidASCII(str))
-		return str;
-	return TextOperations::toUnicode(str, fileEncoding);
-}
-
-float CLegacyConfigParser::readNumber()
-{
-	std::string input = readRawString();
-
-	std::istringstream stream(input);
-
-	if(input.find(',') != std::string::npos) // code to handle conversion with comma as decimal separator
-		stream.imbue(std::locale(std::locale(), new LocaleWithComma()));
-
-	float result;
-	if ( !(stream >> result) )
-		return 0;
-	return result;
-}
-
-bool CLegacyConfigParser::isNextEntryEmpty() const
-{
-	char * nextSymbol = curr;
-	while (nextSymbol < end && *nextSymbol == ' ')
-		nextSymbol++; //find next meaningfull symbol
-
-	return nextSymbol >= end || *nextSymbol == '\n' || *nextSymbol == '\r' || *nextSymbol == '\t';
-}
-
-bool CLegacyConfigParser::endLine()
-{
-	while (curr < end && *curr !=  '\n')
-		readString();
-
-	curr++;
-
-	return curr < end;
-}
-
-void TextLocalizationContainer::registerStringOverride(const std::string & modContext, const std::string & language, const TextIdentifier & UID, const std::string & localized)
-{
-	std::lock_guard<std::recursive_mutex> globalLock(globalTextMutex);
-
-	assert(!modContext.empty());
-	assert(!language.empty());
-
-	// NOTE: implicitly creates entry, intended - strings added by maps, campaigns, vcmi and potentially - UI mods are not registered anywhere at the moment
-	auto & entry = stringsLocalizations[UID.get()];
-
-	entry.overrideLanguage = language;
-	entry.overrideValue = localized;
-	if (entry.modContext.empty())
-		entry.modContext = modContext;
-}
-
-void TextLocalizationContainer::addSubContainer(const TextLocalizationContainer & container)
-{
-	std::lock_guard<std::recursive_mutex> globalLock(globalTextMutex);
-
-	assert(!vstd::contains(subContainers, &container));
-	subContainers.push_back(&container);
-}
-
-void TextLocalizationContainer::removeSubContainer(const TextLocalizationContainer & container)
-{
-	std::lock_guard<std::recursive_mutex> globalLock(globalTextMutex);
-
-	assert(vstd::contains(subContainers, &container));
-
-	subContainers.erase(std::remove(subContainers.begin(), subContainers.end(), &container), subContainers.end());
-}
-
-const std::string & TextLocalizationContainer::deserialize(const TextIdentifier & identifier) const
-{
-	std::lock_guard<std::recursive_mutex> globalLock(globalTextMutex);
-
-	if(stringsLocalizations.count(identifier.get()) == 0)
-	{
-		for(auto containerIter = subContainers.rbegin(); containerIter != subContainers.rend(); ++containerIter)
-			if((*containerIter)->identifierExists(identifier))
-				return (*containerIter)->deserialize(identifier);
-		
-		logGlobal->error("Unable to find localization for string '%s'", identifier.get());
-		return identifier.get();
-	}
-
-	const auto & entry = stringsLocalizations.at(identifier.get());
-
-	if (!entry.overrideValue.empty())
-		return entry.overrideValue;
-	return entry.baseValue;
-}
-
-void TextLocalizationContainer::registerString(const std::string & modContext, const TextIdentifier & UID, const std::string & localized, const std::string & language)
-{
-	std::lock_guard<std::recursive_mutex> globalLock(globalTextMutex);
-
-	assert(!modContext.empty());
-	assert(!Languages::getLanguageOptions(language).identifier.empty());
-	assert(UID.get().find("..") == std::string::npos); // invalid identifier - there is section that was evaluated to empty string
-	//assert(stringsLocalizations.count(UID.get()) == 0); // registering already registered string?
-
-	if(stringsLocalizations.count(UID.get()) > 0)
-	{
-		auto & value = stringsLocalizations[UID.get()];
-		value.baseLanguage = language;
-		value.baseValue = localized;
-	}
-	else
-	{
-		StringState value;
-		value.baseLanguage = language;
-		value.baseValue = localized;
-		value.modContext = modContext;
-
-		stringsLocalizations[UID.get()] = value;
-	}
-}
-
-void TextLocalizationContainer::registerString(const std::string & modContext, const TextIdentifier & UID, const std::string & localized)
-{
-	assert(!getModLanguage(modContext).empty());
-	registerString(modContext, UID, localized, getModLanguage(modContext));
-}
-
-bool TextLocalizationContainer::validateTranslation(const std::string & language, const std::string & modContext, const JsonNode & config) const
-{
-	std::lock_guard<std::recursive_mutex> globalLock(globalTextMutex);
-
-	bool allPresent = true;
-
-	for(const auto & string : stringsLocalizations)
-	{
-		if (string.second.modContext != modContext)
-			continue; // Not our mod
-
-		if (string.second.overrideLanguage == language)
-			continue; // Already translated
-
-		if (string.second.baseLanguage == language && !string.second.baseValue.empty())
-			continue; // Base string already uses our language
-
-		if (string.second.baseLanguage.empty())
-			continue; // String added in localization, not present in base language (e.g. maps/campaigns)
-
-		if (config.Struct().count(string.first) > 0)
-			continue;
-
-		if (allPresent)
-			logMod->warn("Translation into language '%s' in mod '%s' is incomplete! Missing lines:", language, modContext);
-
-		std::string currentText;
-		if (string.second.overrideValue.empty())
-			currentText = string.second.baseValue;
-		else
-			currentText = string.second.overrideValue;
-
-		logMod->warn(R"(    "%s" : "%s",)", string.first, TextOperations::escapeString(currentText));
-		allPresent = false;
-	}
-
-	bool allFound = true;
-
-//	for(const auto & string : config.Struct())
-//	{
-//		if (stringsLocalizations.count(string.first) > 0)
-//			continue;
-//
-//		if (allFound)
-//			logMod->warn("Translation into language '%s' in mod '%s' has unused lines:", language, modContext);
-//
-//		logMod->warn(R"(    "%s" : "%s",)", string.first, TextOperations::escapeString(string.second.String()));
-//		allFound = false;
-//	}
-
-	return allPresent && allFound;
-}
-
-void TextLocalizationContainer::loadTranslationOverrides(const std::string & language, const std::string & modContext, const JsonNode & config)
-{
-	for(const auto & node : config.Struct())
-		registerStringOverride(modContext, language, node.first, node.second.String());
-}
-
-bool TextLocalizationContainer::identifierExists(const TextIdentifier & UID) const
-{
-	std::lock_guard<std::recursive_mutex> globalLock(globalTextMutex);
-
-	return stringsLocalizations.count(UID.get());
-}
-
-void TextLocalizationContainer::exportAllTexts(std::map<std::string, std::map<std::string, std::string>> & storage) const
-{
-	std::lock_guard<std::recursive_mutex> globalLock(globalTextMutex);
-
-	for (auto const & subContainer : subContainers)
-		subContainer->exportAllTexts(storage);
-
-	for (auto const & entry : stringsLocalizations)
-	{
-		std::string textToWrite;
-		std::string modName = entry.second.modContext;
-
-		if (modName.find('.') != std::string::npos)
-			modName = modName.substr(0, modName.find('.'));
-
-		if (!entry.second.overrideValue.empty())
-			textToWrite = entry.second.overrideValue;
-		else
-			textToWrite = entry.second.baseValue;
-
-		storage[modName][entry.first] = textToWrite;
-	}
-}
-
-std::string TextLocalizationContainer::getModLanguage(const std::string & modContext)
-{
-	if (modContext == "core")
-		return CGeneralTextHandler::getInstalledLanguage();
-	return VLC->modh->getModLanguage(modContext);
-}
-
-void TextLocalizationContainer::jsonSerialize(JsonNode & dest) const
-{
-	std::lock_guard<std::recursive_mutex> globalLock(globalTextMutex);
-
-	for(auto & s : stringsLocalizations)
-	{
-		dest.Struct()[s.first].String() = s.second.baseValue;
-		if(!s.second.overrideValue.empty())
-			dest.Struct()[s.first].String() = s.second.overrideValue;
-	}
-}
-
-TextContainerRegistrable::TextContainerRegistrable()
-{
-	VLC->generaltexth->addSubContainer(*this);
-}
-
-TextContainerRegistrable::~TextContainerRegistrable()
-{
-	VLC->generaltexth->removeSubContainer(*this);
-}
-
-TextContainerRegistrable::TextContainerRegistrable(const TextContainerRegistrable & other)
-	: TextLocalizationContainer(other)
-{
-	VLC->generaltexth->addSubContainer(*this);
-}
-
-TextContainerRegistrable::TextContainerRegistrable(TextContainerRegistrable && other) noexcept
-	:TextLocalizationContainer(other)
-{
-	VLC->generaltexth->addSubContainer(*this);
-}
-
-void CGeneralTextHandler::readToVector(const std::string & sourceID, const std::string & sourceName)
-{
-	CLegacyConfigParser parser(TextPath::builtin(sourceName));
-	size_t index = 0;
-	do
-	{
-		registerString( "core", {sourceID, index}, parser.readString());
-		index += 1;
-	}
-	while (parser.endLine());
-}
-
-CGeneralTextHandler::CGeneralTextHandler():
-	victoryConditions(*this, "core.vcdesc"   ),
-	lossCondtions    (*this, "core.lcdesc"   ),
-	colors           (*this, "core.plcolors" ),
-	tcommands        (*this, "core.tcommand" ),
-	hcommands        (*this, "core.hallinfo" ),
-	fcommands        (*this, "core.castinfo" ),
-	advobtxt         (*this, "core.advevent" ),
-	restypes         (*this, "core.restypes" ),
-	randsign         (*this, "core.randsign" ),
-	overview         (*this, "core.overview" ),
-	arraytxt         (*this, "core.arraytxt" ),
-	primarySkillNames(*this, "core.priskill" ),
-	jktexts          (*this, "core.jktext"   ),
-	tavernInfo       (*this, "core.tvrninfo" ),
-	tavernRumors     (*this, "core.randtvrn" ),
-	turnDurations    (*this, "core.turndur"  ),
-	heroscrn         (*this, "core.heroscrn" ),
-	tentColors       (*this, "core.tentcolr" ),
-	levels           (*this, "core.skilllev" ),
-	zelp             (*this, "core.help"     ),
-	allTexts         (*this, "core.genrltxt" ),
-	// pseudo-array, that don't have H3 file with same name
-	seerEmpty        (*this, "core.seerhut.empty"  ),
-	seerNames        (*this, "core.seerhut.names"  ),
-	capColors        (*this, "vcmi.capitalColors"  ),
-	znpc00           (*this, "vcmi.znpc00"  ), // technically - wog
-	qeModCommands    (*this, "vcmi.quickExchange" )
-{
-	readToVector("core.vcdesc",   "DATA/VCDESC.TXT"   );
-	readToVector("core.lcdesc",   "DATA/LCDESC.TXT"   );
-	readToVector("core.tcommand", "DATA/TCOMMAND.TXT" );
-	readToVector("core.hallinfo", "DATA/HALLINFO.TXT" );
-	readToVector("core.castinfo", "DATA/CASTINFO.TXT" );
-	readToVector("core.advevent", "DATA/ADVEVENT.TXT" );
-	readToVector("core.restypes", "DATA/RESTYPES.TXT" );
-	readToVector("core.randsign", "DATA/RANDSIGN.TXT" );
-	readToVector("core.overview", "DATA/OVERVIEW.TXT" );
-	readToVector("core.arraytxt", "DATA/ARRAYTXT.TXT" );
-	readToVector("core.priskill", "DATA/PRISKILL.TXT" );
-	readToVector("core.plcolors", "DATA/PLCOLORS.TXT" );
-	readToVector("core.jktext",   "DATA/JKTEXT.TXT"   );
-	readToVector("core.tvrninfo", "DATA/TVRNINFO.TXT" );
-	readToVector("core.turndur",  "DATA/TURNDUR.TXT"  );
-	readToVector("core.heroscrn", "DATA/HEROSCRN.TXT" );
-	readToVector("core.tentcolr", "DATA/TENTCOLR.TXT" );
-	readToVector("core.skilllev", "DATA/SKILLLEV.TXT" );
-	readToVector("core.cmpmusic", "DATA/CMPMUSIC.TXT" );
-	readToVector("core.minename", "DATA/MINENAME.TXT" );
-	readToVector("core.mineevnt", "DATA/MINEEVNT.TXT" );
-	readToVector("core.xtrainfo", "DATA/XTRAINFO.TXT" );
-
-	static const std::string QE_MOD_COMMANDS = "DATA/QECOMMANDS.TXT";
-	if (CResourceHandler::get()->existsResource(TextPath::builtin(QE_MOD_COMMANDS)))
-		readToVector("vcmi.quickExchange", QE_MOD_COMMANDS);
-
-	{
-		CLegacyConfigParser parser(TextPath::builtin("DATA/RANDTVRN.TXT"));
-		parser.endLine();
-		size_t index = 0;
-		do
-		{
-			std::string line = parser.readString();
-			if(!line.empty())
-			{
-				registerString("core", {"core.randtvrn", index}, line);
-				index += 1;
-			}
-		}
-		while (parser.endLine());
-	}
-	{
-		CLegacyConfigParser parser(TextPath::builtin("DATA/GENRLTXT.TXT"));
-		parser.endLine();
-		size_t index = 0;
-		do
-		{
-			registerString("core", {"core.genrltxt", index}, parser.readString());
-			index += 1;
-		}
-		while (parser.endLine());
-	}
-	{
-		CLegacyConfigParser parser(TextPath::builtin("DATA/HELP.TXT"));
-		size_t index = 0;
-		do
-		{
-			std::string first = parser.readString();
-			std::string second = parser.readString();
-			registerString("core", "core.help." + std::to_string(index) + ".hover", first);
-			registerString("core", "core.help." + std::to_string(index) + ".help",  second);
-			index += 1;
-		}
-		while (parser.endLine());
-	}
-	{
-		CLegacyConfigParser parser(TextPath::builtin("DATA/SEERHUT.TXT"));
-
-		//skip header
-		parser.endLine();
-
-		for (size_t i = 0; i < 6; ++i)
-		{
-			registerString("core", {"core.seerhut.empty", i}, parser.readString());
-		}
-		parser.endLine();
-
-		for (size_t i = 0; i < 9; ++i) //9 types of quests
-		{
-			EQuestMission missionID = static_cast<EQuestMission>(i+1);
-
-			std::string questName = CQuest::missionName(missionID);
-
-			for (size_t j = 0; j < 5; ++j)
-			{
-				std::string questState = CQuest::missionState(j);
-
-				parser.readString(); //front description
-				for (size_t k = 0; k < 6; ++k)
-				{
-					registerString("core", {"core.seerhut.quest", questName, questState, k}, parser.readString());
-				}
-				parser.endLine();
-			}
-		}
-
-		for (size_t k = 0; k < 6; ++k) //Time limit
-		{
-			registerString("core", {"core.seerhut.time", k}, parser.readString());
-		}
-		parser.endLine();
-
-		parser.endLine(); // empty line
-		parser.endLine(); // header
-
-		for (size_t i = 0; i < 48; ++i)
-		{
-			registerString("core", {"core.seerhut.names", i}, parser.readString());
-			parser.endLine();
-		}
-	}
-	{
-		CLegacyConfigParser parser(TextPath::builtin("DATA/CAMPTEXT.TXT"));
-
-		//skip header
-		parser.endLine();
-
-		std::string text;
-		size_t campaignsCount = 0;
-		do
-		{
-			text = parser.readString();
-			if (!text.empty())
-			{
-				registerString("core", {"core.camptext.names", campaignsCount}, text);
-				campaignsCount += 1;
-			}
-		}
-		while (parser.endLine() && !text.empty());
-
-		for (size_t campaign=0; campaign<campaignsCount; campaign++)
-		{
-			size_t region = 0;
-
-			do // skip empty space and header
-			{
-				text = parser.readString();
-			}
-			while (parser.endLine() && text.empty());
-
-			do
-			{
-				text = parser.readString();
-				if (!text.empty())
-				{
-					registerString("core", {"core.camptext.regions", std::to_string(campaign), region}, text);
-					region += 1;
-				}
-			}
-			while (parser.endLine() && !text.empty());
-
-			scenariosCountPerCampaign.push_back(region);
-		}
-	}
-	if (VLC->settings()->getBoolean(EGameSettings::MODULE_COMMANDERS))
-	{
-		if(CResourceHandler::get()->existsResource(TextPath::builtin("DATA/ZNPC00.TXT")))
-			readToVector("vcmi.znpc00", "DATA/ZNPC00.TXT" );
-	}
-}
-
-int32_t CGeneralTextHandler::pluralText(const int32_t textIndex, const int32_t count) const
-{
-	if(textIndex == 0)
-		return 0;
-	if(textIndex < 0)
-		return -textIndex;
-	if(count == 1)
-		return textIndex;
-
-	return textIndex + 1;
-}
-
-size_t CGeneralTextHandler::getCampaignLength(size_t campaignID) const
-{
-	assert(campaignID < scenariosCountPerCampaign.size());
-
-	if(campaignID < scenariosCountPerCampaign.size())
-		return scenariosCountPerCampaign[campaignID];
-	return 0;
-}
-
-std::string CGeneralTextHandler::getPreferredLanguage()
-{
-	assert(!settings["general"]["language"].String().empty());
-	return settings["general"]["language"].String();
-}
-
-std::string CGeneralTextHandler::getInstalledLanguage()
-{
-	assert(!settings["session"]["language"].String().empty());
-	return settings["session"]["language"].String();
-}
-
-std::string CGeneralTextHandler::getInstalledEncoding()
-{
-	assert(!settings["session"]["encoding"].String().empty());
-	return settings["session"]["encoding"].String();
-}
-
-std::vector<std::string> CGeneralTextHandler::findStringsWithPrefix(const std::string & prefix)
-{
-	std::lock_guard<std::recursive_mutex> globalLock(globalTextMutex);
-	std::vector<std::string> result;
-
-	for(const auto & entry : stringsLocalizations)
-	{
-		if(boost::algorithm::starts_with(entry.first, prefix))
-			result.push_back(entry.first);
-	}
-
-	return result;
-}
-
-LegacyTextContainer::LegacyTextContainer(CGeneralTextHandler & owner, std::string basePath):
-	owner(owner),
-	basePath(std::move(basePath))
-{}
-
-std::string LegacyTextContainer::operator[](size_t index) const
-{
-	return owner.translate(basePath, index);
-}
-
-LegacyHelpContainer::LegacyHelpContainer(CGeneralTextHandler & owner, std::string basePath):
-	owner(owner),
-	basePath(std::move(basePath))
-{}
-
-std::pair<std::string, std::string> LegacyHelpContainer::operator[](size_t index) const
-{
-	return {
-		owner.translate(basePath + "." + std::to_string(index) + ".hover"),
-		owner.translate(basePath + "." + std::to_string(index) + ".help")
-	};
-}
-
-VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/CGeneralTextHandler.h vcmi/lib/CGeneralTextHandler.h
--- vcmi-1.5.7/lib/CGeneralTextHandler.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/CGeneralTextHandler.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,316 +0,0 @@
-/*
- * CGeneralTextHandler.h, part of VCMI engine
- *
- * Authors: listed in file AUTHORS in main folder
- *
- * License: GNU General Public License v2.0 or later
- * Full text of license available in license.txt file, in main folder
- *
- */
-#pragma once
-
-#include "filesystem/ResourcePath.h"
-
-VCMI_LIB_NAMESPACE_BEGIN
-
-class CInputStream;
-class JsonNode;
-class JsonSerializeFormat;
-
-/// Parser for any text files from H3
-class DLL_LINKAGE CLegacyConfigParser
-{
-	std::string fileEncoding;
-
-	std::unique_ptr<char[]> data;
-	char * curr;
-	char * end;
-
-	/// extracts part of quoted string.
-	std::string extractQuotedPart();
-
-	/// extracts quoted string. Any end of lines are ignored, double-quote is considered as "escaping"
-	std::string extractQuotedString();
-
-	/// extracts non-quoted string
-	std::string extractNormalString();
-
-	/// reads "raw" string without encoding conversion
-	std::string readRawString();
-
-public:
-	/// read one entry from current line. Return ""/0 if end of line reached
-	std::string readString();
-	float readNumber();
-
-	template <typename numeric>
-	std::vector<numeric> readNumArray(size_t size)
-	{
-		std::vector<numeric> ret;
-		ret.reserve(size);
-		while (size--)
-			ret.push_back((numeric)readNumber());
-		return ret;
-	}
-
-	/// returns true if next entry is empty
-	bool isNextEntryEmpty() const;
-
-	/// end current line
-	bool endLine();
-
-	explicit CLegacyConfigParser(const TextPath & URI);
-};
-
-class CGeneralTextHandler;
-
-/// Small wrapper that provides text access API compatible with old code
-class DLL_LINKAGE LegacyTextContainer
-{
-	CGeneralTextHandler & owner;
-	std::string basePath;
-
-public:
-	LegacyTextContainer(CGeneralTextHandler & owner, std::string basePath);
-	std::string operator [](size_t index) const;
-};
-
-/// Small wrapper that provides help text access API compatible with old code
-class DLL_LINKAGE LegacyHelpContainer
-{
-	CGeneralTextHandler & owner;
-	std::string basePath;
-
-public:
-	LegacyHelpContainer(CGeneralTextHandler & owner, std::string basePath);
-	std::pair<std::string, std::string> operator[](size_t index) const;
-};
-
-class TextIdentifier
-{
-	std::string identifier;
-public:
-	const std::string & get() const 
-	{
-		return identifier;
-	}
-
-	TextIdentifier(const char * id):
-		identifier(id)
-	{}
-
-	TextIdentifier(const std::string & id):
-		identifier(id) 
-	{}
-
-	template<typename... T>
-	TextIdentifier(const std::string & id, size_t index, T... rest):
-		TextIdentifier(id + '.' + std::to_string(index), rest...)
-	{}
-
-	template<typename... T>
-	TextIdentifier(const std::string & id, const std::string & id2, T... rest):
-		TextIdentifier(id + '.' + id2, rest...)
-	{}
-};
-
-class DLL_LINKAGE TextLocalizationContainer
-{
-protected:
-	static std::recursive_mutex globalTextMutex;
-
-	struct StringState
-	{
-		/// Human-readable string that was added on registration
-		std::string baseValue;
-
-		/// Language of base string
-		std::string baseLanguage;
-
-		/// Translated human-readable string
-		std::string overrideValue;
-
-		/// Language of the override string
-		std::string overrideLanguage;
-
-		/// ID of mod that created this string
-		std::string modContext;
-		
-		template <typename Handler>
-		void serialize(Handler & h)
-		{
-			h & baseValue;
-			h & baseLanguage;
-			h & modContext;
-		}
-	};
-	
-	/// map identifier -> localization
-	std::unordered_map<std::string, StringState> stringsLocalizations;
-	
-	std::vector<const TextLocalizationContainer *> subContainers;
-	
-	/// add selected string to internal storage as high-priority strings
-	void registerStringOverride(const std::string & modContext, const std::string & language, const TextIdentifier & UID, const std::string & localized);
-	
-	std::string getModLanguage(const std::string & modContext);
-	
-	// returns true if identifier with such name was registered, even if not translated to current language
-	bool identifierExists(const TextIdentifier & UID) const;
-
-public:
-	/// validates translation of specified language for specified mod
-	/// returns true if localization is valid and complete
-	/// any error messages will be written to log file
-	bool validateTranslation(const std::string & language, const std::string & modContext, JsonNode const & file) const;
-
-	/// Loads translation from provided json
-	/// Any entries loaded by this will have priority over texts registered normally
-	void loadTranslationOverrides(const std::string & language, const std::string & modContext, JsonNode const & file);
-
-	/// add selected string to internal storage
-	void registerString(const std::string & modContext, const TextIdentifier & UID, const std::string & localized);
-	void registerString(const std::string & modContext, const TextIdentifier & UID, const std::string & localized, const std::string & language);
-	
-	/// returns translated version of a string that can be displayed to user
-	template<typename  ... Args>
-	std::string translate(std::string arg1, Args ... args) const
-	{
-		TextIdentifier id(arg1, args ...);
-		return deserialize(id);
-	}
-
-	/// converts identifier into user-readable string
-	const std::string & deserialize(const TextIdentifier & identifier) const;
-	
-	/// Debug method, returns all currently stored texts
-	/// Format: [mod ID][string ID] -> human-readable text
-	void exportAllTexts(std::map<std::string, std::map<std::string, std::string>> & storage) const;
-	
-	/// Add or override subcontainer which can store identifiers
-	void addSubContainer(const TextLocalizationContainer & container);
-	
-	/// Remove subcontainer with give name
-	void removeSubContainer(const TextLocalizationContainer & container);
-	
-	void jsonSerialize(JsonNode & dest) const;
-	
-	template <typename Handler>
-	void serialize(Handler & h)
-	{
-		std::lock_guard<std::recursive_mutex> globalLock(globalTextMutex);
-
-		std::string key;
-		auto sz = stringsLocalizations.size();
-
-		if (h.version >= Handler::Version::REMOVE_TEXT_CONTAINER_SIZE_T)
-		{
-			int64_t size = sz;
-			h & size;
-			sz = size;
-		}
-		else
-		{
-			h & sz;
-		}
-
-		if(h.saving)
-		{
-			for(auto s : stringsLocalizations)
-			{
-				key = s.first;
-				h & key;
-				h & s.second;
-			}
-		}
-		else
-		{
-			for(size_t i = 0; i < sz; ++i)
-			{
-				h & key;
-				h & stringsLocalizations[key];
-			}
-		}
-	}
-};
-
-class DLL_LINKAGE TextContainerRegistrable : public TextLocalizationContainer
-{
-public:
-	TextContainerRegistrable();
-	~TextContainerRegistrable();
-
-	TextContainerRegistrable(const TextContainerRegistrable & other);
-	TextContainerRegistrable(TextContainerRegistrable && other) noexcept;
-
-	TextContainerRegistrable& operator=(const TextContainerRegistrable & b) = default;
-};
-
-/// Handles all text-related data in game
-class DLL_LINKAGE CGeneralTextHandler: public TextLocalizationContainer
-{
-	void readToVector(const std::string & sourceID, const std::string & sourceName);
-
-	/// number of scenarios in specific campaign. TODO: move to a better location
-	std::vector<size_t> scenariosCountPerCampaign;
-
-public:
-	LegacyTextContainer allTexts;
-
-	LegacyTextContainer arraytxt;
-	LegacyTextContainer primarySkillNames;
-	LegacyTextContainer jktexts;
-	LegacyTextContainer heroscrn;
-	LegacyTextContainer overview;//text for Kingdom Overview window
-	LegacyTextContainer colors; //names of player colors ("red",...)
-	LegacyTextContainer capColors; //names of player colors with first letter capitalized ("Red",...)
-	LegacyTextContainer turnDurations; //turn durations for pregame (1 Minute ... Unlimited)
-
-	//towns
-	LegacyTextContainer tcommands, hcommands, fcommands; //texts for town screen, town hall screen and fort screen
-	LegacyTextContainer tavernInfo;
-	LegacyTextContainer tavernRumors;
-
-	LegacyTextContainer qeModCommands;
-
-	LegacyHelpContainer zelp;
-	LegacyTextContainer lossCondtions;
-	LegacyTextContainer victoryConditions;
-
-	//objects
-	LegacyTextContainer advobtxt;
-	LegacyTextContainer restypes; //names of resources
-	LegacyTextContainer randsign;
-	LegacyTextContainer seerEmpty;
-	LegacyTextContainer seerNames;
-	LegacyTextContainer tentColors;
-
-	//sec skills
-	LegacyTextContainer levels;
-	//commanders
-	LegacyTextContainer znpc00; //more or less useful content of that file
-
-	std::vector<std::string> findStringsWithPrefix(const std::string & prefix);
-
-	int32_t pluralText(int32_t textIndex, int32_t count) const;
-
-	size_t getCampaignLength(size_t campaignID) const;
-
-	CGeneralTextHandler();
-	CGeneralTextHandler(const CGeneralTextHandler&) = delete;
-	CGeneralTextHandler operator=(const CGeneralTextHandler&) = delete;
-
-	/// Attempts to detect encoding & language of H3 files
-	static void detectInstallParameters();
-
-	/// Returns name of language preferred by user
-	static std::string getPreferredLanguage();
-
-	/// Returns name of language of Heroes III text files
-	static std::string getInstalledLanguage();
-
-	/// Returns name of encoding of Heroes III text files
-	static std::string getInstalledEncoding();
-};
-
-VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/CHeroHandler.cpp vcmi/lib/CHeroHandler.cpp
--- vcmi-1.5.7/lib/CHeroHandler.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/CHeroHandler.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,816 +0,0 @@
-/*
- * CHeroHandler.cpp, part of VCMI engine
- *
- * Authors: listed in file AUTHORS in main folder
- *
- * License: GNU General Public License v2.0 or later
- * Full text of license available in license.txt file, in main folder
- *
- */
-#include "StdInc.h"
-#include "CHeroHandler.h"
-
-#include "CGeneralTextHandler.h"
-#include "filesystem/Filesystem.h"
-#include "VCMI_Lib.h"
-#include "constants/StringConstants.h"
-#include "battle/BattleHex.h"
-#include "CCreatureHandler.h"
-#include "GameSettings.h"
-#include "CRandomGenerator.h"
-#include "CTownHandler.h"
-#include "CSkillHandler.h"
-#include "BattleFieldHandler.h"
-#include "bonuses/Limiters.h"
-#include "bonuses/Updaters.h"
-#include "json/JsonBonus.h"
-#include "json/JsonUtils.h"
-#include "mapObjectConstructors/AObjectTypeHandler.h"
-#include "mapObjectConstructors/CObjectClassesHandler.h"
-#include "modding/IdentifierStorage.h"
-
-VCMI_LIB_NAMESPACE_BEGIN
-
-CHero::CHero() = default;
-CHero::~CHero() = default;
-
-int32_t CHero::getIndex() const
-{
-	return ID.getNum();
-}
-
-int32_t CHero::getIconIndex() const
-{
-	return imageIndex;
-}
-
-std::string CHero::getJsonKey() const
-{
-	return modScope + ':' + identifier;
-}
-
-HeroTypeID CHero::getId() const
-{
-	return ID;
-}
-
-std::string CHero::getNameTranslated() const
-{
-	return VLC->generaltexth->translate(getNameTextID());
-}
-
-std::string CHero::getBiographyTranslated() const
-{
-	return VLC->generaltexth->translate(getBiographyTextID());
-}
-
-std::string CHero::getSpecialtyNameTranslated() const
-{
-	return VLC->generaltexth->translate(getSpecialtyNameTextID());
-}
-
-std::string CHero::getSpecialtyDescriptionTranslated() const
-{
-	return VLC->generaltexth->translate(getSpecialtyDescriptionTextID());
-}
-
-std::string CHero::getSpecialtyTooltipTranslated() const
-{
-	return VLC->generaltexth->translate(getSpecialtyTooltipTextID());
-}
-
-std::string CHero::getNameTextID() const
-{
-	return TextIdentifier("hero", modScope, identifier, "name").get();
-}
-
-std::string CHero::getBiographyTextID() const
-{
-	return TextIdentifier("hero", modScope, identifier, "biography").get();
-}
-
-std::string CHero::getSpecialtyNameTextID() const
-{
-	return TextIdentifier("hero", modScope, identifier, "specialty", "name").get();
-}
-
-std::string CHero::getSpecialtyDescriptionTextID() const
-{
-	return TextIdentifier("hero", modScope, identifier, "specialty", "description").get();
-}
-
-std::string CHero::getSpecialtyTooltipTextID() const
-{
-	return TextIdentifier("hero", modScope, identifier, "specialty", "tooltip").get();
-}
-
-void CHero::registerIcons(const IconRegistar & cb) const
-{
-	cb(getIconIndex(), 0, "UN32", iconSpecSmall);
-	cb(getIconIndex(), 0, "UN44", iconSpecLarge);
-	cb(getIconIndex(), 0, "PORTRAITSLARGE", portraitLarge);
-	cb(getIconIndex(), 0, "PORTRAITSSMALL", portraitSmall);
-}
-
-void CHero::updateFrom(const JsonNode & data)
-{
-	//todo: CHero::updateFrom
-}
-
-void CHero::serializeJson(JsonSerializeFormat & handler)
-{
-
-}
-
-
-SecondarySkill CHeroClass::chooseSecSkill(const std::set<SecondarySkill> & possibles, CRandomGenerator & rand) const //picks secondary skill out from given possibilities
-{
-	assert(!possibles.empty());
-
-	if (possibles.size() == 1)
-		return *possibles.begin();
-
-	int totalProb = 0;
-	for(const auto & possible : possibles)
-		if (secSkillProbability.count(possible) != 0)
-			totalProb += secSkillProbability.at(possible);
-
-	if (totalProb == 0) // may trigger if set contains only banned skills (0 probability)
-		return *RandomGeneratorUtil::nextItem(possibles, rand);
-
-	auto ran = rand.nextInt(totalProb - 1);
-	for(const auto & possible : possibles)
-	{
-		if (secSkillProbability.count(possible) != 0)
-			ran -= secSkillProbability.at(possible);
-
-		if(ran < 0)
-			return possible;
-	}
-
-	assert(0); // should not be possible
-	return *possibles.begin();
-}
-
-bool CHeroClass::isMagicHero() const
-{
-	return affinity == MAGIC;
-}
-
-int CHeroClass::tavernProbability(FactionID targetFaction) const
-{
-	auto it = selectionProbability.find(targetFaction);
-	if (it != selectionProbability.end())
-		return it->second;
-	return 0;
-}
-
-EAlignment CHeroClass::getAlignment() const
-{
-	return VLC->factions()->getById(faction)->getAlignment();
-}
-
-int32_t CHeroClass::getIndex() const
-{
-	return id.getNum();
-}
-
-int32_t CHeroClass::getIconIndex() const
-{
-	return getIndex();
-}
-
-std::string CHeroClass::getJsonKey() const
-{
-	return modScope + ':' + identifier;
-}
-
-HeroClassID CHeroClass::getId() const
-{
-	return id;
-}
-
-void CHeroClass::registerIcons(const IconRegistar & cb) const
-{
-
-}
-
-std::string CHeroClass::getNameTranslated() const
-{
-	return VLC->generaltexth->translate(getNameTextID());
-}
-
-std::string CHeroClass::getNameTextID() const
-{
-	return TextIdentifier("heroClass", modScope, identifier, "name").get();
-}
-
-void CHeroClass::updateFrom(const JsonNode & data)
-{
-	//TODO: CHeroClass::updateFrom
-}
-
-void CHeroClass::serializeJson(JsonSerializeFormat & handler)
-{
-
-}
-
-CHeroClass::CHeroClass():
-	faction(0),
-	affinity(0),
-	defaultTavernChance(0)
-{
-}
-
-void CHeroClassHandler::fillPrimarySkillData(const JsonNode & node, CHeroClass * heroClass, PrimarySkill pSkill) const
-{
-	const auto & skillName = NPrimarySkill::names[pSkill.getNum()];
-	auto currentPrimarySkillValue = static_cast<int>(node["primarySkills"][skillName].Integer());
-	//minimal value is 0 for attack and defense and 1 for spell power and knowledge
-	auto primarySkillLegalMinimum = (pSkill == PrimarySkill::ATTACK || pSkill == PrimarySkill::DEFENSE) ? 0 : 1;
-
-	if(currentPrimarySkillValue < primarySkillLegalMinimum)
-	{
-		logMod->error("Hero class '%s' has incorrect initial value '%d' for skill '%s'. Value '%d' will be used instead.",
-			heroClass->getNameTranslated(), currentPrimarySkillValue, skillName, primarySkillLegalMinimum);
-		currentPrimarySkillValue = primarySkillLegalMinimum;
-	}
-	heroClass->primarySkillInitial.push_back(currentPrimarySkillValue);
-	heroClass->primarySkillLowLevel.push_back(static_cast<int>(node["lowLevelChance"][skillName].Float()));
-	heroClass->primarySkillHighLevel.push_back(static_cast<int>(node["highLevelChance"][skillName].Float()));
-}
-
-const std::vector<std::string> & CHeroClassHandler::getTypeNames() const
-{
-	static const std::vector<std::string> typeNames = { "heroClass" };
-	return typeNames;
-}
-
-CHeroClass * CHeroClassHandler::loadFromJson(const std::string & scope, const JsonNode & node, const std::string & identifier, size_t index)
-{
-	assert(identifier.find(':') == std::string::npos);
-	assert(!scope.empty());
-
-	std::string affinityStr[2] = { "might", "magic" };
-
-	auto * heroClass = new CHeroClass();
-
-	heroClass->id = HeroClassID(index);
-	heroClass->identifier = identifier;
-	heroClass->modScope = scope;
-	heroClass->imageBattleFemale = AnimationPath::fromJson(node["animation"]["battle"]["female"]);
-	heroClass->imageBattleMale   = AnimationPath::fromJson(node["animation"]["battle"]["male"]);
-	//MODS COMPATIBILITY FOR 0.96
-	heroClass->imageMapFemale    = node["animation"]["map"]["female"].String();
-	heroClass->imageMapMale      = node["animation"]["map"]["male"].String();
-
-	VLC->generaltexth->registerString(scope, heroClass->getNameTextID(), node["name"].String());
-
-	if (vstd::contains(affinityStr, node["affinity"].String()))
-	{
-		heroClass->affinity = vstd::find_pos(affinityStr, node["affinity"].String());
-	}
-	else
-	{
-		logGlobal->error("Mod '%s', hero class '%s': invalid affinity '%s'! Expected 'might' or 'magic'!", scope, identifier, node["affinity"].String());
-		heroClass->affinity = CHeroClass::MIGHT;
-	}
-
-	fillPrimarySkillData(node, heroClass, PrimarySkill::ATTACK);
-	fillPrimarySkillData(node, heroClass, PrimarySkill::DEFENSE);
-	fillPrimarySkillData(node, heroClass, PrimarySkill::SPELL_POWER);
-	fillPrimarySkillData(node, heroClass, PrimarySkill::KNOWLEDGE);
-
-	auto percentSumm = std::accumulate(heroClass->primarySkillLowLevel.begin(), heroClass->primarySkillLowLevel.end(), 0);
-	if(percentSumm <= 0)
-		logMod->error("Hero class %s has wrong lowLevelChance values: must be above zero!", heroClass->identifier, percentSumm);
-
-	percentSumm = std::accumulate(heroClass->primarySkillHighLevel.begin(), heroClass->primarySkillHighLevel.end(), 0);
-	if(percentSumm <= 0)
-		logMod->error("Hero class %s has wrong highLevelChance values: must be above zero!", heroClass->identifier, percentSumm);
-
-	for(auto skillPair : node["secondarySkills"].Struct())
-	{
-		int probability = static_cast<int>(skillPair.second.Integer());
-		VLC->identifiers()->requestIdentifier(skillPair.second.getModScope(), "skill", skillPair.first, [heroClass, probability](si32 skillID)
-		{
-			heroClass->secSkillProbability[skillID] = probability;
-		});
-	}
-
-	VLC->identifiers()->requestIdentifier ("creature", node["commander"],
-	[=](si32 commanderID)
-	{
-		heroClass->commander = CreatureID(commanderID);
-	});
-
-	heroClass->defaultTavernChance = static_cast<ui32>(node["defaultTavern"].Float());
-	for(const auto & tavern : node["tavern"].Struct())
-	{
-		int value = static_cast<int>(tavern.second.Float());
-
-		VLC->identifiers()->requestIdentifier(tavern.second.getModScope(), "faction", tavern.first,
-		[=](si32 factionID)
-		{
-			heroClass->selectionProbability[FactionID(factionID)] = value;
-		});
-	}
-
-	VLC->identifiers()->requestIdentifier("faction", node["faction"],
-	[=](si32 factionID)
-	{
-		heroClass->faction.setNum(factionID);
-	});
-
-	VLC->identifiers()->requestIdentifier(scope, "object", "hero", [=](si32 index)
-	{
-		JsonNode classConf = node["mapObject"];
-		classConf["heroClass"].String() = identifier;
-		if (!node["compatibilityIdentifiers"].isNull())
-			classConf["compatibilityIdentifiers"] = node["compatibilityIdentifiers"];
-		classConf.setModScope(scope);
-		VLC->objtypeh->loadSubObject(identifier, classConf, index, heroClass->getIndex());
-	});
-
-	return heroClass;
-}
-
-std::vector<JsonNode> CHeroClassHandler::loadLegacyData()
-{
-	size_t dataSize = VLC->settings()->getInteger(EGameSettings::TEXTS_HERO_CLASS);
-
-	objects.resize(dataSize);
-	std::vector<JsonNode> h3Data;
-	h3Data.reserve(dataSize);
-
-	CLegacyConfigParser parser(TextPath::builtin("DATA/HCTRAITS.TXT"));
-
-	parser.endLine(); // header
-	parser.endLine();
-
-	for (size_t i=0; i<dataSize; i++)
-	{
-		JsonNode entry;
-
-		entry["name"].String() = parser.readString();
-
-		parser.readNumber(); // unused aggression
-
-		for(const auto & name : NPrimarySkill::names)
-			entry["primarySkills"][name].Float() = parser.readNumber();
-
-		for(const auto & name : NPrimarySkill::names)
-			entry["lowLevelChance"][name].Float() = parser.readNumber();
-
-		for(const auto & name : NPrimarySkill::names)
-			entry["highLevelChance"][name].Float() = parser.readNumber();
-
-		for(const auto & name : NSecondarySkill::names)
-			entry["secondarySkills"][name].Float() = parser.readNumber();
-
-		for(const auto & name : NFaction::names)
-			entry["tavern"][name].Float() = parser.readNumber();
-
-		parser.endLine();
-		h3Data.push_back(entry);
-	}
-	return h3Data;
-}
-
-void CHeroClassHandler::afterLoadFinalization()
-{
-	// for each pair <class, town> set selection probability if it was not set before in tavern entries
-	for(auto & heroClass : objects)
-	{
-		for(auto & faction : VLC->townh->objects)
-		{
-			if (!faction->town)
-				continue;
-			if (heroClass->selectionProbability.count(faction->getId()))
-				continue;
-
-			auto chance = static_cast<float>(heroClass->defaultTavernChance * faction->town->defaultTavernChance);
-			heroClass->selectionProbability[faction->getId()] = static_cast<int>(sqrt(chance) + 0.5); //FIXME: replace with std::round once MVS supports it
-		}
-
-		// set default probabilities for gaining secondary skills where not loaded previously
-		for(int skillID = 0; skillID < VLC->skillh->size(); skillID++)
-		{
-			if(heroClass->secSkillProbability.count(skillID) == 0)
-			{
-				const CSkill * skill = (*VLC->skillh)[SecondarySkill(skillID)];
-				logMod->trace("%s: no probability for %s, using default", heroClass->identifier, skill->getJsonKey());
-				heroClass->secSkillProbability[skillID] = skill->gainChance[heroClass->affinity];
-			}
-		}
-	}
-
-	for(const auto & hc : objects)
-	{
-		if(!hc->imageMapMale.empty())
-		{
-			JsonNode templ;
-			templ["animation"].String() = hc->imageMapMale;
-			VLC->objtypeh->getHandlerFor(Obj::HERO, hc->getIndex())->addTemplate(templ);
-		}
-	}
-}
-
-CHeroClassHandler::~CHeroClassHandler() = default;
-
-CHeroHandler::~CHeroHandler() = default;
-
-CHeroHandler::CHeroHandler()
-{
-	loadExperience();
-}
-
-const std::vector<std::string> & CHeroHandler::getTypeNames() const
-{
-	static const std::vector<std::string> typeNames = { "hero" };
-	return typeNames;
-}
-
-CHero * CHeroHandler::loadFromJson(const std::string & scope, const JsonNode & node, const std::string & identifier, size_t index)
-{
-	assert(identifier.find(':') == std::string::npos);
-	assert(!scope.empty());
-
-	auto * hero = new CHero();
-	hero->ID = HeroTypeID(index);
-	hero->identifier = identifier;
-	hero->modScope = scope;
-	hero->gender = node["female"].Bool() ? EHeroGender::FEMALE : EHeroGender::MALE;
-	hero->special = node["special"].Bool();
-	//Default - both false
-	hero->onlyOnWaterMap = node["onlyOnWaterMap"].Bool();
-	hero->onlyOnMapWithoutWater = node["onlyOnMapWithoutWater"].Bool();
-
-	VLC->generaltexth->registerString(scope, hero->getNameTextID(), node["texts"]["name"].String());
-	VLC->generaltexth->registerString(scope, hero->getBiographyTextID(), node["texts"]["biography"].String());
-	VLC->generaltexth->registerString(scope, hero->getSpecialtyNameTextID(), node["texts"]["specialty"]["name"].String());
-	VLC->generaltexth->registerString(scope, hero->getSpecialtyTooltipTextID(), node["texts"]["specialty"]["tooltip"].String());
-	VLC->generaltexth->registerString(scope, hero->getSpecialtyDescriptionTextID(), node["texts"]["specialty"]["description"].String());
-
-	hero->iconSpecSmall = node["images"]["specialtySmall"].String();
-	hero->iconSpecLarge = node["images"]["specialtyLarge"].String();
-	hero->portraitSmall = node["images"]["small"].String();
-	hero->portraitLarge = node["images"]["large"].String();
-	hero->battleImage = AnimationPath::fromJson(node["battleImage"]);
-
-	loadHeroArmy(hero, node);
-	loadHeroSkills(hero, node);
-	loadHeroSpecialty(hero, node);
-
-	VLC->identifiers()->requestIdentifier("heroClass", node["class"],
-	[=](si32 classID)
-	{
-		hero->heroClass = HeroClassID(classID).toHeroClass();
-	});
-
-	return hero;
-}
-
-void CHeroHandler::loadHeroArmy(CHero * hero, const JsonNode & node) const
-{
-	assert(node["army"].Vector().size() <= 3); // anything bigger is useless - army initialization uses up to 3 slots
-
-	hero->initialArmy.resize(node["army"].Vector().size());
-
-	for (size_t i=0; i< hero->initialArmy.size(); i++)
-	{
-		const JsonNode & source = node["army"].Vector()[i];
-
-		hero->initialArmy[i].minAmount = static_cast<ui32>(source["min"].Float());
-		hero->initialArmy[i].maxAmount = static_cast<ui32>(source["max"].Float());
-
-		if (hero->initialArmy[i].minAmount > hero->initialArmy[i].maxAmount)
-		{
-			logMod->error("Hero %s has minimal army size (%d) greater than maximal size (%d)!", hero->getJsonKey(), hero->initialArmy[i].minAmount, hero->initialArmy[i].maxAmount);
-			std::swap(hero->initialArmy[i].minAmount, hero->initialArmy[i].maxAmount);
-		}
-
-		VLC->identifiers()->requestIdentifier("creature", source["creature"], [=](si32 creature)
-		{
-			hero->initialArmy[i].creature = CreatureID(creature);
-		});
-	}
-}
-
-void CHeroHandler::loadHeroSkills(CHero * hero, const JsonNode & node) const
-{
-	for(const JsonNode &set : node["skills"].Vector())
-	{
-		int skillLevel = static_cast<int>(boost::range::find(NSecondarySkill::levels, set["level"].String()) - std::begin(NSecondarySkill::levels));
-		if (skillLevel < MasteryLevel::LEVELS_SIZE)
-		{
-			size_t currentIndex = hero->secSkillsInit.size();
-			hero->secSkillsInit.emplace_back(SecondarySkill(-1), skillLevel);
-
-			VLC->identifiers()->requestIdentifier("skill", set["skill"], [=](si32 id)
-			{
-				hero->secSkillsInit[currentIndex].first = SecondarySkill(id);
-			});
-		}
-		else
-		{
-			logMod->error("Unknown skill level: %s", set["level"].String());
-		}
-	}
-
-	// spellbook is considered present if hero have "spellbook" entry even when this is an empty set (0 spells)
-	hero->haveSpellBook = !node["spellbook"].isNull();
-
-	for(const JsonNode & spell : node["spellbook"].Vector())
-	{
-		VLC->identifiers()->requestIdentifier("spell", spell,
-		[=](si32 spellID)
-		{
-			hero->spells.insert(SpellID(spellID));
-		});
-	}
-}
-
-/// creates standard H3 hero specialty for creatures
-static std::vector<std::shared_ptr<Bonus>> createCreatureSpecialty(CreatureID baseCreatureID)
-{
-	std::vector<std::shared_ptr<Bonus>> result;
-	std::set<CreatureID> targets;
-	targets.insert(baseCreatureID);
-
-	// go through entire upgrade chain and collect all creatures to which baseCreatureID can be upgraded
-	for (;;)
-	{
-		std::set<CreatureID> oldTargets = targets;
-
-		for(const auto & upgradeSourceID : oldTargets)
-		{
-			const CCreature * upgradeSource = upgradeSourceID.toCreature();
-			targets.insert(upgradeSource->upgrades.begin(), upgradeSource->upgrades.end());
-		}
-
-		if (oldTargets.size() == targets.size())
-			break;
-	}
-
-	for(CreatureID cid : targets)
-	{
-		const auto & specCreature = *cid.toCreature();
-		int stepSize = specCreature.getLevel() ? specCreature.getLevel() : 5;
-
-		{
-			auto bonus = std::make_shared<Bonus>();
-			bonus->limiter.reset(new CCreatureTypeLimiter(specCreature, false));
-			bonus->type = BonusType::STACKS_SPEED;
-			bonus->val = 1;
-			result.push_back(bonus);
-		}
-
-		{
-			auto bonus = std::make_shared<Bonus>();
-			bonus->type = BonusType::PRIMARY_SKILL;
-			bonus->subtype = BonusSubtypeID(PrimarySkill::ATTACK);
-			bonus->val = 0;
-			bonus->limiter.reset(new CCreatureTypeLimiter(specCreature, false));
-			bonus->updater.reset(new GrowsWithLevelUpdater(specCreature.getAttack(false), stepSize));
-			result.push_back(bonus);
-		}
-
-		{
-			auto bonus = std::make_shared<Bonus>();
-			bonus->type = BonusType::PRIMARY_SKILL;
-			bonus->subtype = BonusSubtypeID(PrimarySkill::DEFENSE);
-			bonus->val = 0;
-			bonus->limiter.reset(new CCreatureTypeLimiter(specCreature, false));
-			bonus->updater.reset(new GrowsWithLevelUpdater(specCreature.getDefense(false), stepSize));
-			result.push_back(bonus);
-		}
-	}
-
-	return result;
-}
-
-void CHeroHandler::beforeValidate(JsonNode & object)
-{
-	//handle "base" specialty info
-	JsonNode & specialtyNode = object["specialty"];
-	if(specialtyNode.getType() == JsonNode::JsonType::DATA_STRUCT)
-	{
-		const JsonNode & base = specialtyNode["base"];
-		if(!base.isNull())
-		{
-			if(specialtyNode["bonuses"].isNull())
-			{
-				logMod->warn("specialty has base without bonuses");
-			}
-			else
-			{
-				JsonMap & bonuses = specialtyNode["bonuses"].Struct();
-				for(std::pair<std::string, JsonNode> keyValue : bonuses)
-					JsonUtils::inherit(bonuses[keyValue.first], base);
-			}
-		}
-	}
-}
-
-void CHeroHandler::afterLoadFinalization()
-{
-	for(const auto & functor : callAfterLoadFinalization)
-		functor();
-
-	callAfterLoadFinalization.clear();
-}
-
-void CHeroHandler::loadHeroSpecialty(CHero * hero, const JsonNode & node)
-{
-	auto prepSpec = [=](std::shared_ptr<Bonus> bonus)
-	{
-		bonus->duration = BonusDuration::PERMANENT;
-		bonus->source = BonusSource::HERO_SPECIAL;
-		bonus->sid = BonusSourceID(hero->getId());
-		return bonus;
-	};
-
-	//new format, using bonus system
-	const JsonNode & specialtyNode = node["specialty"];
-	if(specialtyNode.getType() != JsonNode::JsonType::DATA_STRUCT)
-	{
-		logMod->error("Unsupported speciality format for hero %s!", hero->getNameTranslated());
-		return;
-	}
-
-	//creature specialty - alias for simplicity
-	if(!specialtyNode["creature"].isNull())
-	{
-		JsonNode creatureNode = specialtyNode["creature"];
-
-		std::function<void()> specialtyLoader = [creatureNode, hero, prepSpec]
-		{
-			VLC->identifiers()->requestIdentifier("creature", creatureNode, [hero, prepSpec](si32 creature)
-			{
-				for (const auto & bonus : createCreatureSpecialty(CreatureID(creature)))
-					hero->specialty.push_back(prepSpec(bonus));
-			});
-		};
-
-		callAfterLoadFinalization.push_back(specialtyLoader);
-	}
-
-	for(const auto & keyValue : specialtyNode["bonuses"].Struct())
-		hero->specialty.push_back(prepSpec(JsonUtils::parseBonus(keyValue.second)));
-}
-
-void CHeroHandler::loadExperience()
-{
-	expPerLevel.push_back(0);
-	expPerLevel.push_back(1000);
-	expPerLevel.push_back(2000);
-	expPerLevel.push_back(3200);
-	expPerLevel.push_back(4600);
-	expPerLevel.push_back(6200);
-	expPerLevel.push_back(8000);
-	expPerLevel.push_back(10000);
-	expPerLevel.push_back(12200);
-	expPerLevel.push_back(14700);
-	expPerLevel.push_back(17500);
-	expPerLevel.push_back(20600);
-	expPerLevel.push_back(24320);
-	expPerLevel.push_back(28784);
-	expPerLevel.push_back(34140);
-
-	for (;;)
-	{
-		auto i = expPerLevel.size() - 1;
-		auto currExp = expPerLevel[i];
-		auto prevExp = expPerLevel[i-1];
-		auto prevDiff = currExp - prevExp;
-		auto nextDiff = prevDiff + prevDiff / 5;
-		auto maxExp = std::numeric_limits<decltype(currExp)>::max();
-
-		if (currExp > maxExp - nextDiff)
-			break; // overflow point reached
-
-		expPerLevel.push_back (currExp + nextDiff);
-	}
-}
-
-/// convert h3-style ID (e.g. Gobin Wolf Rider) to vcmi (e.g. goblinWolfRider)
-static std::string genRefName(std::string input)
-{
-	boost::algorithm::replace_all(input, " ", ""); //remove spaces
-	input[0] = std::tolower(input[0]); // to camelCase
-	return input;
-}
-
-std::vector<JsonNode> CHeroHandler::loadLegacyData()
-{
-	size_t dataSize = VLC->settings()->getInteger(EGameSettings::TEXTS_HERO);
-
-	objects.resize(dataSize);
-	std::vector<JsonNode> h3Data;
-	h3Data.reserve(dataSize);
-
-	CLegacyConfigParser specParser(TextPath::builtin("DATA/HEROSPEC.TXT"));
-	CLegacyConfigParser bioParser(TextPath::builtin("DATA/HEROBIOS.TXT"));
-	CLegacyConfigParser parser(TextPath::builtin("DATA/HOTRAITS.TXT"));
-
-	parser.endLine(); //ignore header
-	parser.endLine();
-
-	specParser.endLine(); //ignore header
-	specParser.endLine();
-
-	for (int i=0; i<GameConstants::HEROES_QUANTITY; i++)
-	{
-		JsonNode heroData;
-
-		heroData["texts"]["name"].String() = parser.readString();
-		heroData["texts"]["biography"].String() = bioParser.readString();
-		heroData["texts"]["specialty"]["name"].String() = specParser.readString();
-		heroData["texts"]["specialty"]["tooltip"].String() = specParser.readString();
-		heroData["texts"]["specialty"]["description"].String() = specParser.readString();
-
-		for(int x=0;x<3;x++)
-		{
-			JsonNode armySlot;
-			armySlot["min"].Float() = parser.readNumber();
-			armySlot["max"].Float() = parser.readNumber();
-			armySlot["creature"].String() = genRefName(parser.readString());
-
-			heroData["army"].Vector().push_back(armySlot);
-		}
-		parser.endLine();
-		specParser.endLine();
-		bioParser.endLine();
-
-		h3Data.push_back(heroData);
-	}
-	return h3Data;
-}
-
-void CHeroHandler::loadObject(std::string scope, std::string name, const JsonNode & data)
-{
-	size_t index = objects.size();
-	static const int specialFramesCount = 2; // reserved for 2 special frames
-	auto * object = loadFromJson(scope, data, name, index);
-	object->imageIndex = static_cast<si32>(index) + specialFramesCount;
-
-	objects.emplace_back(object);
-
-	registerObject(scope, "hero", name, object->getIndex());
-
-	for(const auto & compatID : data["compatibilityIdentifiers"].Vector())
-		registerObject(scope, "hero", compatID.String(), object->getIndex());
-}
-
-void CHeroHandler::loadObject(std::string scope, std::string name, const JsonNode & data, size_t index)
-{
-	auto * object = loadFromJson(scope, data, name, index);
-	object->imageIndex = static_cast<si32>(index);
-
-	assert(objects[index] == nullptr); // ensure that this id was not loaded before
-	objects[index] = object;
-
-	registerObject(scope, "hero", name, object->getIndex());
-	for(const auto & compatID : data["compatibilityIdentifiers"].Vector())
-		registerObject(scope, "hero", compatID.String(), object->getIndex());
-}
-
-ui32 CHeroHandler::level (TExpType experience) const
-{
-	return static_cast<ui32>(boost::range::upper_bound(expPerLevel, experience) - std::begin(expPerLevel));
-}
-
-TExpType CHeroHandler::reqExp (ui32 level) const
-{
-	if(!level)
-		return 0;
-
-	if (level <= expPerLevel.size())
-	{
-		return expPerLevel[level-1];
-	}
-	else
-	{
-		logGlobal->warn("A hero has reached unsupported amount of experience");
-		return expPerLevel[expPerLevel.size()-1];
-	}
-}
-
-ui32 CHeroHandler::maxSupportedLevel() const
-{
-	return expPerLevel.size();
-}
-
-std::set<HeroTypeID> CHeroHandler::getDefaultAllowed() const
-{
-	std::set<HeroTypeID> result;
-
-	for(auto & hero : objects)
-		if (hero && !hero->special)
-			result.insert(hero->getId());
-
-	return result;
-}
-
-VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/CHeroHandler.h vcmi/lib/CHeroHandler.h
--- vcmi-1.5.7/lib/CHeroHandler.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/CHeroHandler.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,215 +0,0 @@
-/*
- * CHeroHandler.h, part of VCMI engine
- *
- * Authors: listed in file AUTHORS in main folder
- *
- * License: GNU General Public License v2.0 or later
- * Full text of license available in license.txt file, in main folder
- *
- */
-#pragma once
-
-#include <vcmi/HeroClass.h>
-#include <vcmi/HeroClassService.h>
-#include <vcmi/HeroType.h>
-#include <vcmi/HeroTypeService.h>
-
-#include "ConstTransitivePtr.h"
-#include "GameConstants.h"
-#include "bonuses/Bonus.h"
-#include "bonuses/BonusList.h"
-#include "IHandlerBase.h"
-#include "filesystem/ResourcePath.h"
-
-VCMI_LIB_NAMESPACE_BEGIN
-
-class CHeroClass;
-class CGHeroInstance;
-struct BattleHex;
-class JsonNode;
-class CRandomGenerator;
-class JsonSerializeFormat;
-class BattleField;
-
-enum class EHeroGender : int8_t
-{
-	DEFAULT = -1, // from h3m, instance has same gender as hero type
-	MALE = 0,
-	FEMALE = 1,
-};
-
-class DLL_LINKAGE CHero : public HeroType
-{
-	friend class CHeroHandler;
-
-	HeroTypeID ID;
-	std::string identifier;
-	std::string modScope;
-
-public:
-	struct InitialArmyStack
-	{
-		ui32 minAmount;
-		ui32 maxAmount;
-		CreatureID creature;
-	};
-	si32 imageIndex = 0;
-
-	std::vector<InitialArmyStack> initialArmy;
-
-	const CHeroClass * heroClass = nullptr;
-	std::vector<std::pair<SecondarySkill, ui8> > secSkillsInit; //initial secondary skills; first - ID of skill, second - level of skill (1 - basic, 2 - adv., 3 - expert)
-	BonusList specialty;
-	std::set<SpellID> spells;
-	bool haveSpellBook = false;
-	bool special = false; // hero is special and won't be placed in game (unless preset on map), e.g. campaign heroes
-	bool onlyOnWaterMap; // hero will be placed only if the map contains water
-	bool onlyOnMapWithoutWater; // hero will be placed only if the map does not contain water
-	EHeroGender gender = EHeroGender::MALE; // default sex: 0=male, 1=female
-
-	/// Graphics
-	std::string iconSpecSmall;
-	std::string iconSpecLarge;
-	std::string portraitSmall;
-	std::string portraitLarge;
-	AnimationPath battleImage;
-
-	CHero();
-	virtual ~CHero();
-
-	int32_t getIndex() const override;
-	int32_t getIconIndex() const override;
-	std::string getJsonKey() const override;
-	HeroTypeID getId() const override;
-	void registerIcons(const IconRegistar & cb) const override;
-
-	std::string getNameTranslated() const override;
-	std::string getBiographyTranslated() const override;
-	std::string getSpecialtyNameTranslated() const override;
-	std::string getSpecialtyDescriptionTranslated() const override;
-	std::string getSpecialtyTooltipTranslated() const override;
-
-	std::string getNameTextID() const override;
-	std::string getBiographyTextID() const override;
-	std::string getSpecialtyNameTextID() const override;
-	std::string getSpecialtyDescriptionTextID() const override;
-	std::string getSpecialtyTooltipTextID() const override;
-
-	void updateFrom(const JsonNode & data);
-	void serializeJson(JsonSerializeFormat & handler);
-};
-
-class DLL_LINKAGE CHeroClass : public HeroClass
-{
-	friend class CHeroClassHandler;
-	HeroClassID id; // use getId instead
-	std::string modScope;
-	std::string identifier; // use getJsonKey instead
-
-public:
-	enum EClassAffinity
-	{
-		MIGHT,
-		MAGIC
-	};
-
-	//double aggression; // not used in vcmi.
-	FactionID faction;
-	ui8 affinity; // affinity, using EClassAffinity enum
-
-	// default chance for hero of specific class to appear in tavern, if field "tavern" was not set
-	// resulting chance = sqrt(town.chance * heroClass.chance)
-	ui32 defaultTavernChance;
-
-	CreatureID commander;
-
-	std::vector<int> primarySkillInitial;  // initial primary skills
-	std::vector<int> primarySkillLowLevel; // probability (%) of getting point of primary skill when getting level
-	std::vector<int> primarySkillHighLevel;// same for high levels (> 10)
-
-	std::map<SecondarySkill, int> secSkillProbability; //probabilities of gaining secondary skills (out of 112), in id order
-
-	std::map<FactionID, int> selectionProbability; //probability of selection in towns
-
-	AnimationPath imageBattleMale;
-	AnimationPath imageBattleFemale;
-	std::string imageMapMale;
-	std::string imageMapFemale;
-
-	CHeroClass();
-
-	int32_t getIndex() const override;
-	int32_t getIconIndex() const override;
-	std::string getJsonKey() const override;
-	HeroClassID getId() const override;
-	void registerIcons(const IconRegistar & cb) const override;
-
-	std::string getNameTranslated() const override;
-	std::string getNameTextID() const override;
-
-	bool isMagicHero() const;
-	SecondarySkill chooseSecSkill(const std::set<SecondarySkill> & possibles, CRandomGenerator & rand) const; //picks secondary skill out from given possibilities
-
-	void updateFrom(const JsonNode & data);
-	void serializeJson(JsonSerializeFormat & handler);
-
-	EAlignment getAlignment() const;
-
-	int tavernProbability(FactionID faction) const;
-};
-
-class DLL_LINKAGE CHeroClassHandler : public CHandlerBase<HeroClassID, HeroClass, CHeroClass, HeroClassService>
-{
-	void fillPrimarySkillData(const JsonNode & node, CHeroClass * heroClass, PrimarySkill pSkill) const;
-
-public:
-	std::vector<JsonNode> loadLegacyData() override;
-
-	void afterLoadFinalization() override;
-
-	~CHeroClassHandler();
-
-protected:
-	const std::vector<std::string> & getTypeNames() const override;
-	CHeroClass * loadFromJson(const std::string & scope, const JsonNode & node, const std::string & identifier, size_t index) override;
-
-};
-
-class DLL_LINKAGE CHeroHandler : public CHandlerBase<HeroTypeID, HeroType, CHero, HeroTypeService>
-{
-	/// expPerLEvel[i] is amount of exp needed to reach level i;
-	/// consists of 196 values. Any higher levels require experience larger that TExpType can hold
-	std::vector<TExpType> expPerLevel;
-
-	/// helpers for loading to avoid huge load functions
-	void loadHeroArmy(CHero * hero, const JsonNode & node) const;
-	void loadHeroSkills(CHero * hero, const JsonNode & node) const;
-	void loadHeroSpecialty(CHero * hero, const JsonNode & node);
-
-	void loadExperience();
-
-	std::vector<std::function<void()>> callAfterLoadFinalization;
-
-public:
-	ui32 level(TExpType experience) const; //calculates level corresponding to given experience amount
-	TExpType reqExp(ui32 level) const; //calculates experience required for given level
-	ui32 maxSupportedLevel() const;
-
-	std::vector<JsonNode> loadLegacyData() override;
-
-	void beforeValidate(JsonNode & object) override;
-	void loadObject(std::string scope, std::string name, const JsonNode & data) override;
-	void loadObject(std::string scope, std::string name, const JsonNode & data, size_t index) override;
-	void afterLoadFinalization() override;
-
-	CHeroHandler();
-	~CHeroHandler();
-
-	std::set<HeroTypeID> getDefaultAllowed() const;
-
-protected:
-	const std::vector<std::string> & getTypeNames() const override;
-	CHero * loadFromJson(const std::string & scope, const JsonNode & node, const std::string & identifier, size_t index) override;
-};
-
-VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/CMakeLists.txt vcmi/lib/CMakeLists.txt
--- vcmi-1.5.7/lib/CMakeLists.txt	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/CMakeLists.txt	2024-12-19 15:00:22.841145582 +0100
@@ -30,13 +30,14 @@
 	network/NetworkHandler.cpp
 	network/NetworkServer.cpp
 
+	texts/TextOperations.cpp
+
 	vstd/DateUtils.cpp
 	vstd/StringUtils.cpp
 
 	CConfigHandler.cpp
 	CConsoleHandler.cpp
 	CThreadHelper.cpp
-	TextOperations.cpp
 	VCMIDirs.cpp
 )
 
@@ -47,6 +48,7 @@
 	battle/BattleAttackInfo.cpp
 	battle/BattleHex.cpp
 	battle/BattleInfo.cpp
+	battle/BattleLayout.cpp
 	battle/BattleProxy.cpp
 	battle/BattleStateInfoForRetreat.cpp
 	battle/CBattleInfoCallback.cpp
@@ -80,6 +82,16 @@
 
 	constants/EntityIdentifiers.cpp
 
+	entities/building/CBuilding.cpp
+	entities/building/CBuildingHandler.cpp
+	entities/faction/CFaction.cpp
+	entities/faction/CTown.cpp
+	entities/faction/CTownHandler.cpp
+	entities/hero/CHero.cpp
+	entities/hero/CHeroClass.cpp
+	entities/hero/CHeroClassHandler.cpp
+	entities/hero/CHeroHandler.cpp
+
 	events/ApplyDamage.cpp
 	events/GameResumed.cpp
 	events/ObjectVisitEnded.cpp
@@ -92,8 +104,11 @@
 
 	gameState/CGameState.cpp
 	gameState/CGameStateCampaign.cpp
+	gameState/HighScore.cpp
 	gameState/InfoAboutArmy.cpp
+	gameState/RumorState.cpp
 	gameState/TavernHeroesPool.cpp
+	gameState/GameStatistics.cpp
 
 	mapObjectConstructors/AObjectTypeHandler.cpp
 	mapObjectConstructors/CBankInstanceConstructor.cpp
@@ -101,6 +116,7 @@
 	mapObjectConstructors/CommonConstructors.cpp
 	mapObjectConstructors/CRewardableConstructor.cpp
 	mapObjectConstructors/DwellingInstanceConstructor.cpp
+	mapObjectConstructors/FlaggableInstanceConstructor.cpp
 	mapObjectConstructors/HillFortInstanceConstructor.cpp
 	mapObjectConstructors/ShipyardInstanceConstructor.cpp
 
@@ -112,11 +128,12 @@
 	mapObjects/CGMarket.cpp
 	mapObjects/CGObjectInstance.cpp
 	mapObjects/CGPandoraBox.cpp
-	mapObjects/CGTownBuilding.cpp
+	mapObjects/TownBuildingInstance.cpp
 	mapObjects/CGTownInstance.cpp
 	mapObjects/CObjectHandler.cpp
 	mapObjects/CQuest.cpp
 	mapObjects/CRewardableObject.cpp
+	mapObjects/FlaggableMapObject.cpp
 	mapObjects/IMarket.cpp
 	mapObjects/IObjectInterface.cpp
 	mapObjects/MiscObjects.cpp
@@ -140,10 +157,11 @@
 
 	modding/ActiveModsInSaveList.cpp
 	modding/CModHandler.cpp
-	modding/CModInfo.cpp
 	modding/CModVersion.cpp
 	modding/ContentTypeHandler.cpp
 	modding/IdentifierStorage.cpp
+	modding/ModDescription.cpp
+	modding/ModManager.cpp
 	modding/ModUtility.cpp
 	modding/ModVerificationInfo.cpp
 
@@ -173,6 +191,8 @@
 	rmg/TileInfo.cpp
 	rmg/Zone.cpp
 	rmg/Functions.cpp
+	rmg/ObjectInfo.cpp
+	rmg/ObjectConfig.cpp
 	rmg/RmgMap.cpp
 	rmg/PenroseTiling.cpp
 	rmg/modificators/Modificator.cpp
@@ -207,6 +227,7 @@
 	serializer/JsonSerializeFormat.cpp
 	serializer/JsonSerializer.cpp
 	serializer/JsonUpdater.cpp
+	serializer/SerializerReflection.cpp
 
 	spells/AbilityCaster.cpp
 	spells/AdventureSpellMechanics.cpp
@@ -240,6 +261,11 @@
 	spells/effects/RemoveObstacle.cpp
 	spells/effects/Sacrifice.cpp
 
+	texts/CGeneralTextHandler.cpp
+	texts/CLegacyConfigParser.cpp
+	texts/MetaString.cpp
+	texts/TextLocalizationContainer.cpp
+
 	ArtifactUtils.cpp
 	BasicTypes.cpp
 	BattleFieldHandler.cpp
@@ -247,25 +273,20 @@
 	CArtHandler.cpp
 	CArtifactInstance.cpp
 	CBonusTypeHandler.cpp
-	CBuildingHandler.cpp
 	CCreatureHandler.cpp
 	CCreatureSet.cpp
 	CGameInfoCallback.cpp
 	CGameInterface.cpp
-	CGeneralTextHandler.cpp
-	CHeroHandler.cpp
 	CPlayerState.cpp
 	CRandomGenerator.cpp
 	CScriptingModule.cpp
 	CSkillHandler.cpp
 	CStack.cpp
-	CTownHandler.cpp
 	GameSettings.cpp
 	IGameCallback.cpp
 	IHandlerBase.cpp
 	LoadProgress.cpp
 	LogicalExpression.cpp
-	MetaString.cpp
 	ObstacleHandler.cpp
 	StartInfo.cpp
 	ResourceSet.cpp
@@ -334,10 +355,11 @@
 	network/NetworkInterface.h
 	network/NetworkServer.h
 
+	texts/TextOperations.h
+
 	CConfigHandler.h
 	CConsoleHandler.h
 	CThreadHelper.h
-	TextOperations.h
 	VCMIDirs.h
 )
 
@@ -391,6 +413,8 @@
 	battle/BattleAttackInfo.h
 	battle/BattleHex.h
 	battle/BattleInfo.h
+	battle/BattleLayout.h
+	battle/BattleSide.h
 	battle/BattleStateInfoForRetreat.h
 	battle/BattleProxy.h
 	battle/CBattleInfoCallback.h
@@ -434,6 +458,18 @@
 	constants/NumericConstants.h
 	constants/StringConstants.h
 
+	entities/building/CBuilding.h
+	entities/building/CBuildingHandler.h
+	entities/building/TownFortifications.h
+	entities/faction/CFaction.h
+	entities/faction/CTown.h
+	entities/faction/CTownHandler.h
+	entities/hero/CHero.h
+	entities/hero/CHeroClass.h
+	entities/hero/CHeroClassHandler.h
+	entities/hero/CHeroHandler.h
+	entities/hero/EHeroGender.h
+
 	events/ApplyDamage.h
 	events/GameResumed.h
 	events/ObjectVisitEnded.h
@@ -447,9 +483,12 @@
 	gameState/CGameState.h
 	gameState/CGameStateCampaign.h
 	gameState/EVictoryLossCheckResult.h
+	gameState/HighScore.h
 	gameState/InfoAboutArmy.h
+	gameState/RumorState.h
 	gameState/SThievesGuildInfo.h
 	gameState/TavernHeroesPool.h
+	gameState/GameStatistics.h
 	gameState/TavernSlot.h
 	gameState/QuestInfo.h
 
@@ -461,6 +500,7 @@
 	mapObjectConstructors/CRewardableConstructor.h
 	mapObjectConstructors/DwellingInstanceConstructor.h
 	mapObjectConstructors/HillFortInstanceConstructor.h
+	mapObjectConstructors/FlaggableInstanceConstructor.h
 	mapObjectConstructors/IObjectInfo.h
 	mapObjectConstructors/RandomMapInfo.h
 	mapObjectConstructors/ShipyardInstanceConstructor.h
@@ -474,15 +514,18 @@
 	mapObjects/CGMarket.h
 	mapObjects/CGObjectInstance.h
 	mapObjects/CGPandoraBox.h
-	mapObjects/CGTownBuilding.h
+	mapObjects/TownBuildingInstance.h
 	mapObjects/CGTownInstance.h
 	mapObjects/CObjectHandler.h
 	mapObjects/CQuest.h
 	mapObjects/CRewardableObject.h
+	mapObjects/FlaggableMapObject.h
 	mapObjects/IMarket.h
 	mapObjects/IObjectInterface.h
+	mapObjects/IOwnableObject.h
 	mapObjects/MapObjects.h
 	mapObjects/MiscObjects.h
+	mapObjects/CompoundMapObjectID.h
 	mapObjects/ObjectTemplate.h
 	mapObjects/ObstacleSetHandler.h
 
@@ -505,11 +548,12 @@
 
 	modding/ActiveModsInSaveList.h
 	modding/CModHandler.h
-	modding/CModInfo.h
 	modding/CModVersion.h
 	modding/ContentTypeHandler.h
 	modding/IdentifierStorage.h
+	modding/ModDescription.h
 	modding/ModIncompatibility.h
+	modding/ModManager.h
 	modding/ModScope.h
 	modding/ModUtility.h
 	modding/ModVerificationInfo.h
@@ -527,7 +571,9 @@
 	networkPacks/PacksForClientBattle.h
 	networkPacks/PacksForLobby.h
 	networkPacks/PacksForServer.h
+	networkPacks/SetRewardableConfiguration.h
 	networkPacks/SetStackEffect.h
+	networkPacks/SaveLocalState.h
 	networkPacks/StackLocation.h
 	networkPacks/TradeItem.h
 
@@ -540,12 +586,6 @@
 	pathfinder/PathfindingRules.h
 	pathfinder/TurnInfo.h
 
-	registerTypes/RegisterTypes.h
-	registerTypes/RegisterTypesClientPacks.h
-	registerTypes/RegisterTypesLobbyPacks.h
-	registerTypes/RegisterTypesMapObjects.h
-	registerTypes/RegisterTypesServerPacks.h
-
 	rewardable/Configuration.h
 	rewardable/Info.h
 	rewardable/Interface.h
@@ -565,6 +605,8 @@
 	rmg/RmgMap.h
 	rmg/float3.h
 	rmg/Functions.h
+	rmg/ObjectInfo.h
+	rmg/ObjectConfig.h
 	rmg/PenroseTiling.h
 	rmg/modificators/Modificator.h
 	rmg/modificators/ObjectManager.h
@@ -600,8 +642,10 @@
 	serializer/JsonSerializeFormat.h
 	serializer/JsonSerializer.h
 	serializer/JsonUpdater.h
-	serializer/Cast.h
 	serializer/ESerializationVersion.h
+	serializer/RegisterTypes.h
+	serializer/Serializeable.h
+	serializer/SerializerReflection.h
 
 	spells/AbilityCaster.h
 	spells/AdventureSpellMechanics.h
@@ -635,6 +679,13 @@
 	spells/effects/RemoveObstacle.h
 	spells/effects/Sacrifice.h
 
+	texts/CGeneralTextHandler.h
+	texts/Languages.h
+	texts/CLegacyConfigParser.h
+	texts/MetaString.h
+	texts/TextIdentifier.h
+	texts/TextLocalizationContainer.h
+
 	AI_Base.h
 	ArtifactUtils.h
 	BattleFieldHandler.h
@@ -642,13 +693,10 @@
 	CArtHandler.h
 	CArtifactInstance.h
 	CBonusTypeHandler.h
-	CBuildingHandler.h
 	CCreatureHandler.h
 	CCreatureSet.h
 	CGameInfoCallback.h
 	CGameInterface.h
-	CGeneralTextHandler.h
-	CHeroHandler.h
 	ConstTransitivePtr.h
 	Color.h
 	CPlayerState.h
@@ -658,7 +706,6 @@
 	CSoundBase.h
 	CStack.h
 	CStopWatch.h
-	CTownHandler.h
 	ExceptionsCommon.h
 	ExtraOptionsInfo.h
 	FunctionList.h
@@ -668,12 +715,11 @@
 	IBonusTypeHandler.h
 	IGameCallback.h
 	IGameEventsReceiver.h
+	IGameSettings.h
 	IHandlerBase.h
 	int3.h
-	Languages.h
 	LoadProgress.h
 	LogicalExpression.h
-	MetaString.h
 	ObstacleHandler.h
 	Point.h
 	Rect.h
@@ -705,7 +751,7 @@
 
 set_target_properties(vcmi PROPERTIES COMPILE_DEFINITIONS "VCMI_DLL=1")
 target_link_libraries(vcmi PUBLIC
-	minizip::minizip ZLIB::ZLIB
+	minizip::minizip ZLIB::ZLIB TBB::tbb
 	${SYSTEM_LIBS} Boost::boost Boost::thread Boost::filesystem Boost::program_options Boost::locale Boost::date_time
 )
 
@@ -746,6 +792,16 @@
 	)
 endif()
 
+# Use '-Wa,-mbig-obj' for files that generate very large object files
+# when compiling with MinGW lest you get "too many sections" assembler errors
+if(MINGW AND CMAKE_BUILD_TYPE STREQUAL "Debug")
+	set_source_files_properties(
+		serializer/SerializerReflection.cpp
+		IGameCallback.cpp
+		PROPERTIES
+		COMPILE_OPTIONS "-Wa,-mbig-obj")
+endif()
+
 vcmi_set_output_dir(vcmi "")
 
 enable_pch(vcmi)
@@ -770,6 +826,8 @@
 endif()
 
 if(APPLE_IOS AND NOT USING_CONAN)
+	install(IMPORTED_RUNTIME_ARTIFACTS TBB::tbb LIBRARY DESTINATION ${LIB_DIR}) # CMake 3.21+
+
 	get_target_property(LINKED_LIBS vcmi LINK_LIBRARIES)
 	foreach(LINKED_LIB IN LISTS LINKED_LIBS)
 		if(NOT TARGET ${LINKED_LIB})
diff --color -urN vcmi-1.5.7/lib/Color.h vcmi/lib/Color.h
--- vcmi-1.5.7/lib/Color.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/Color.h	2024-12-19 15:00:22.850145954 +0100
@@ -57,6 +57,11 @@
 		h & b;
 		h & a;
 	}
+
+	bool operator==(ColorRGBA const& rhs) const
+	{
+		return r == rhs.r && g == rhs.g && b == rhs.b && a == rhs.a;
+	}
 };
 
 VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/constants/EntityIdentifiers.cpp vcmi/lib/constants/EntityIdentifiers.cpp
--- vcmi-1.5.7/lib/constants/EntityIdentifiers.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/constants/EntityIdentifiers.cpp	2024-12-19 15:00:22.896147855 +0100
@@ -29,20 +29,21 @@
 #include "modding/IdentifierStorage.h"
 #include "modding/ModScope.h"
 #include "VCMI_Lib.h"
-#include "CHeroHandler.h"
 #include "CArtHandler.h"//todo: remove
 #include "CCreatureHandler.h"//todo: remove
 #include "spells/CSpellHandler.h" //todo: remove
 #include "CSkillHandler.h"//todo: remove
+#include "entities/faction/CFaction.h"
+#include "entities/hero/CHero.h"
+#include "entities/hero/CHeroClass.h"
 #include "mapObjectConstructors/AObjectTypeHandler.h"
 #include "constants/StringConstants.h"
-#include "CGeneralTextHandler.h"
+#include "texts/CGeneralTextHandler.h"
 #include "TerrainHandler.h" //TODO: remove
 #include "RiverHandler.h"
 #include "RoadHandler.h"
 #include "BattleFieldHandler.h"
 #include "ObstacleHandler.h"
-#include "CTownHandler.h"
 #include "mapObjectConstructors/CObjectClassesHandler.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
@@ -125,6 +126,25 @@
 #endif
 }
 
+BuildingTypeUniqueID::BuildingTypeUniqueID(FactionID factionID, BuildingID buildingID ):
+	BuildingTypeUniqueID(factionID.getNum() * 0x10000 + buildingID.getNum())
+{
+	assert(factionID.getNum() >= 0);
+	assert(factionID.getNum() < 0x10000);
+	assert(buildingID.getNum() >= 0);
+	assert(buildingID.getNum() < 0x10000);
+}
+
+BuildingID BuildingTypeUniqueID::getBuilding() const
+{
+	return BuildingID(getNum() % 0x10000);
+}
+
+FactionID BuildingTypeUniqueID::getFaction() const
+{
+	return FactionID(getNum() / 0x10000);
+}
+
 int32_t IdentifierBase::resolveIdentifier(const std::string & entityType, const std::string identifier)
 {
 	if (identifier.empty())
diff --color -urN vcmi-1.5.7/lib/constants/EntityIdentifiers.h vcmi/lib/constants/EntityIdentifiers.h
--- vcmi-1.5.7/lib/constants/EntityIdentifiers.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/constants/EntityIdentifiers.h	2024-12-19 15:00:22.896147855 +0100
@@ -280,6 +280,7 @@
 	enum Type
 	{
 		DEFAULT = -50,
+		HORDE_PLACEHOLDER8 = -37,
 		HORDE_PLACEHOLDER7 = -36,
 		HORDE_PLACEHOLDER6 = -35,
 		HORDE_PLACEHOLDER5 = -34,
@@ -297,7 +298,7 @@
 		HORDE_2_UPGR,   GRAIL,         EXTRA_TOWN_HALL,   EXTRA_CITY_HALL, EXTRA_CAPITOL,
 		DWELL_FIRST=30, DWELL_LVL_2, DWELL_LVL_3, DWELL_LVL_4, DWELL_LVL_5, DWELL_LVL_6, DWELL_LAST=36,
 		DWELL_UP_FIRST=37,  DWELL_LVL_2_UP, DWELL_LVL_3_UP, DWELL_LVL_4_UP, DWELL_LVL_5_UP,
-		DWELL_LVL_6_UP, DWELL_UP_LAST=43,
+		DWELL_LVL_6_UP, DWELL_UP_LAST=43, DWELL_LVL_8=150, DWELL_LVL_8_UP=151, //150-154 reserved for 8. creature with potential upgrades
 
 		DWELL_LVL_1 = DWELL_FIRST,
 		DWELL_LVL_7 = DWELL_LAST,
@@ -313,6 +314,58 @@
 
 	};
 
+private:
+	static std::vector<std::vector<Type>> getDwellings()
+	{
+		std::vector<Type> dwellings = { DWELL_LVL_1, DWELL_LVL_2, DWELL_LVL_3, DWELL_LVL_4, DWELL_LVL_5, DWELL_LVL_6, DWELL_LVL_7, DWELL_LVL_8 };
+		std::vector<Type> dwellingsUp = { DWELL_LVL_1_UP, DWELL_LVL_2_UP, DWELL_LVL_3_UP, DWELL_LVL_4_UP, DWELL_LVL_5_UP, DWELL_LVL_6_UP, DWELL_LVL_7_UP, DWELL_LVL_8_UP };
+		return {dwellings, dwellingsUp};
+	}
+
+public:
+	static Type getDwellingFromLevel(int level, int upgradeIndex)
+	{
+		return getDwellings()[upgradeIndex][level];
+	}
+
+	static int getLevelFromDwelling(BuildingIDBase dwelling)
+	{
+		for(int i = 0; i < 2; i++)
+		{
+			auto tmp = getDwellings()[i];
+			auto it = std::find(tmp.begin(), tmp.end(), dwelling);
+			if (it != tmp.end())
+				return std::distance(tmp.begin(), it);
+		}
+		if(dwelling >= BuildingIDBase::DWELL_LVL_8 && dwelling < BuildingIDBase::DWELL_LVL_8 + 5)
+			return 7;
+		else
+			return (dwelling - DWELL_FIRST) % (GameConstants::CREATURES_PER_TOWN - 1);
+	}
+
+	static int getUpgradedFromDwelling(BuildingIDBase dwelling)
+	{
+		for(int i = 0; i < 2; i++)
+		{
+			auto tmp = getDwellings()[i];
+			auto it = std::find(tmp.begin(), tmp.end(), dwelling);
+			if (it != tmp.end())
+				return i;
+		}
+		if(dwelling >= BuildingIDBase::DWELL_LVL_8 && dwelling < BuildingIDBase::DWELL_LVL_8 + 5)
+			return dwelling - BuildingIDBase::DWELL_LVL_8;
+		else
+			return (dwelling - DWELL_FIRST) / (GameConstants::CREATURES_PER_TOWN - 1);
+	}
+
+	static void advanceDwelling(BuildingIDBase & dwelling)
+	{
+		if(dwelling >= BuildingIDBase::DWELL_LVL_8 && dwelling < BuildingIDBase::DWELL_LVL_8 + 5)
+			dwelling.advance(1);
+		else
+			dwelling.advance(GameConstants::CREATURES_PER_TOWN - 1);
+	}
+
 	bool IsSpecialOrGrail() const
 	{
 		return num == SPECIAL_1 || num == SPECIAL_2 || num == SPECIAL_3 || num == SPECIAL_4 || num == GRAIL;
diff --color -urN vcmi-1.5.7/lib/constants/Enumerations.h vcmi/lib/constants/Enumerations.h
--- vcmi-1.5.7/lib/constants/Enumerations.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/constants/Enumerations.h	2024-12-19 15:00:22.896147855 +0100
@@ -25,34 +25,13 @@
 	{
 		DEFAULT = -50,
 		NONE = -1,
-		STABLES,
-		BROTHERHOOD_OF_SWORD,
 		CASTLE_GATE,
-		CREATURE_TRANSFORMER,
 		MYSTIC_POND,
-		FOUNTAIN_OF_FORTUNE,
-		ARTIFACT_MERCHANT,
-		LOOKOUT_TOWER,
 		LIBRARY,
-		MANA_VORTEX,
 		PORTAL_OF_SUMMONING,
 		ESCAPE_TUNNEL,
-		FREELANCERS_GUILD,
-		BALLISTA_YARD,
-		ATTACK_VISITING_BONUS,
-		MAGIC_UNIVERSITY,
-		SPELL_POWER_GARRISON_BONUS,
-		ATTACK_GARRISON_BONUS,
-		DEFENSE_GARRISON_BONUS,
-		DEFENSE_VISITING_BONUS,
-		SPELL_POWER_VISITING_BONUS,
-		KNOWLEDGE_VISITING_BONUS,
-		EXPERIENCE_VISITING_BONUS,
-		LIGHTHOUSE,
 		TREASURY,
-		THIEVES_GUILD,
-		CUSTOM_VISITING_BONUS,
-		CUSTOM_VISITING_REWARD
+		BANK
 	};
 }
 
@@ -263,4 +242,21 @@
 	TOWN_PORTAL,
 };
 
+enum class EMapLevel : int8_t
+{
+	ANY = -1,
+	SURFACE = 0,
+	UNDERGROUND = 1
+};
+
+enum class EWeekType : int8_t
+{
+	FIRST_WEEK,
+	NORMAL,
+	DOUBLE_GROWTH,
+	BONUS_GROWTH,
+	DEITYOFFIRE,
+	PLAGUE
+};
+
 VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/constants/NumericConstants.h vcmi/lib/constants/NumericConstants.h
--- vcmi-1.5.7/lib/constants/NumericConstants.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/constants/NumericConstants.h	2024-12-19 15:00:22.897147896 +0100
@@ -22,7 +22,7 @@
 
 	constexpr int ALL_PLAYERS = 255; //bitfield
 
-	constexpr int CREATURES_PER_TOWN = 7; //without upgrades
+	constexpr int CREATURES_PER_TOWN = 8; //without upgrades
 	constexpr int SPELL_LEVELS = 5;
 	constexpr int SPELL_SCHOOL_LEVELS = 4;
 	constexpr int DEFAULT_SCHOOLS = 4;
@@ -54,6 +54,7 @@
 	constexpr int ALTAR_ARTIFACTS_SLOTS = 22;
 	constexpr int TOURNAMENT_RULES_DD_MAP_TILES_THRESHOLD = 144*144*2; //map tiles count threshold for 2 dimension door casts with tournament rules
 	constexpr int KINGDOM_WINDOW_HEROES_SLOTS = 4;
+	constexpr int INFO_WINDOW_ARTIFACTS_MAX_ITEMS = 14;
 }
 
 VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/constants/StringConstants.h vcmi/lib/constants/StringConstants.h
--- vcmi-1.5.7/lib/constants/StringConstants.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/constants/StringConstants.h	2024-12-19 15:00:22.897147896 +0100
@@ -56,7 +56,7 @@
 
 namespace EBuildingType
 {
-	const std::string names [44] =
+	const std::string names [46] =
 	{
 		"mageGuild1",       "mageGuild2",       "mageGuild3",       "mageGuild4",       "mageGuild5",       //  5
 		"tavern",           "shipyard",         "fort",             "citadel",          "castle",           // 10
@@ -66,7 +66,8 @@
 		"horde2Upgr",       "grail",            "extraTownHall",    "extraCityHall",    "extraCapitol",     // 30
 		"dwellingLvl1",     "dwellingLvl2",     "dwellingLvl3",     "dwellingLvl4",     "dwellingLvl5",     // 35
 		"dwellingLvl6",     "dwellingLvl7",     "dwellingUpLvl1",   "dwellingUpLvl2",   "dwellingUpLvl3",   // 40
-		"dwellingUpLvl4",   "dwellingUpLvl5",   "dwellingUpLvl6",   "dwellingUpLvl7"
+		"dwellingUpLvl4",   "dwellingUpLvl5",   "dwellingUpLvl6",   "dwellingUpLvl7",   "dwellingLvl8",
+		"dwellingUpLvl8"
 	};
 }
 
@@ -163,6 +164,7 @@
 		{ "dwellingLvl5", BuildingID::DWELL_LVL_5 },
 		{ "dwellingLvl6", BuildingID::DWELL_LVL_6 },
 		{ "dwellingLvl7", BuildingID::DWELL_LVL_7 },
+		{ "dwellingLvl8", BuildingID::DWELL_LVL_8 },
 		{ "dwellingUpLvl1", BuildingID::DWELL_LVL_1_UP },
 		{ "dwellingUpLvl2", BuildingID::DWELL_LVL_2_UP },
 		{ "dwellingUpLvl3", BuildingID::DWELL_LVL_3_UP },
@@ -170,36 +172,18 @@
 		{ "dwellingUpLvl5", BuildingID::DWELL_LVL_5_UP },
 		{ "dwellingUpLvl6", BuildingID::DWELL_LVL_6_UP },
 		{ "dwellingUpLvl7", BuildingID::DWELL_LVL_7_UP },
+		{ "dwellingUpLvl8", BuildingID::DWELL_LVL_8_UP },
 	};
 
 	static const std::map<std::string, BuildingSubID::EBuildingSubID> SPECIAL_BUILDINGS =
 	{
 		{ "mysticPond", BuildingSubID::MYSTIC_POND },
-		{ "artifactMerchant", BuildingSubID::ARTIFACT_MERCHANT },
-		{ "freelancersGuild", BuildingSubID::FREELANCERS_GUILD },
-		{ "magicUniversity", BuildingSubID::MAGIC_UNIVERSITY },
 		{ "castleGate", BuildingSubID::CASTLE_GATE },
-		{ "creatureTransformer", BuildingSubID::CREATURE_TRANSFORMER },//only skeleton transformer yet
 		{ "portalOfSummoning", BuildingSubID::PORTAL_OF_SUMMONING },
-		{ "ballistaYard", BuildingSubID::BALLISTA_YARD },
-		{ "stables", BuildingSubID::STABLES },
-		{ "manaVortex", BuildingSubID::MANA_VORTEX },
-		{ "lookoutTower", BuildingSubID::LOOKOUT_TOWER },
 		{ "library", BuildingSubID::LIBRARY },
-		{ "brotherhoodOfSword", BuildingSubID::BROTHERHOOD_OF_SWORD },//morale garrison bonus
-		{ "fountainOfFortune", BuildingSubID::FOUNTAIN_OF_FORTUNE },//luck garrison bonus
-		{ "spellPowerGarrisonBonus", BuildingSubID::SPELL_POWER_GARRISON_BONUS },//such as 'stormclouds', but this name is not ok for good towns
-		{ "attackGarrisonBonus", BuildingSubID::ATTACK_GARRISON_BONUS },
-		{ "defenseGarrisonBonus", BuildingSubID::DEFENSE_GARRISON_BONUS },
 		{ "escapeTunnel", BuildingSubID::ESCAPE_TUNNEL },
-		{ "attackVisitingBonus", BuildingSubID::ATTACK_VISITING_BONUS },
-		{ "defenceVisitingBonus", BuildingSubID::DEFENSE_VISITING_BONUS },
-		{ "spellPowerVisitingBonus", BuildingSubID::SPELL_POWER_VISITING_BONUS },
-		{ "knowledgeVisitingBonus", BuildingSubID::KNOWLEDGE_VISITING_BONUS },
-		{ "experienceVisitingBonus", BuildingSubID::EXPERIENCE_VISITING_BONUS },
-		{ "lighthouse", BuildingSubID::LIGHTHOUSE },
 		{ "treasury", BuildingSubID::TREASURY },
-		{ "thievesGuild", BuildingSubID::THIEVES_GUILD }
+		{ "bank", BuildingSubID::BANK }
 	};
 
 	static const std::map<std::string, EMarketMode> MARKET_NAMES_TO_TYPES =
diff --color -urN vcmi-1.5.7/lib/CPlayerState.cpp vcmi/lib/CPlayerState.cpp
--- vcmi-1.5.7/lib/CPlayerState.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/CPlayerState.cpp	2024-12-19 15:00:22.841145582 +0100
@@ -10,15 +10,24 @@
 #include "StdInc.h"
 
 #include "CPlayerState.h"
+#include "json/JsonNode.h"
+#include "mapObjects/CGDwelling.h"
+#include "mapObjects/CGTownInstance.h"
+#include "mapObjects/CGHeroInstance.h"
 #include "gameState/QuestInfo.h"
-#include "CGeneralTextHandler.h"
+#include "texts/CGeneralTextHandler.h"
 #include "VCMI_Lib.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
 PlayerState::PlayerState()
- : color(-1), human(false), cheated(false), enteredWinningCheatCode(false),
-   enteredLosingCheatCode(false), status(EPlayerStatus::INGAME)
+	: color(-1)
+	, human(false)
+	, cheated(false)
+	, playerLocalSettings(std::make_unique<JsonNode>())
+	, enteredWinningCheatCode(false)
+	, enteredLosingCheatCode(false)
+	, status(EPlayerStatus::INGAME)
 {
 	setNodeType(PLAYER);
 }
@@ -50,6 +59,11 @@
 	return color.toString();
 }
 
+std::string PlayerState::getModScope() const
+{
+	return "core";
+}
+
 std::string PlayerState::getNameTranslated() const
 {
 	return VLC->generaltexth->translate(getNameTextID());
@@ -85,4 +99,54 @@
 	return vstd::atOrDefault(resources, static_cast<size_t>(type), 0);
 }
 
+template<typename T>
+std::vector<T> PlayerState::getObjectsOfType() const
+{
+	std::vector<T> result;
+	for (auto const & object : ownedObjects)
+	{
+		auto casted = dynamic_cast<T>(object);
+		if (casted)
+			result.push_back(casted);
+	}
+	return result;
+}
+
+std::vector<const CGHeroInstance *> PlayerState::getHeroes() const
+{
+	return getObjectsOfType<const CGHeroInstance *>();
+}
+
+std::vector<const CGTownInstance *> PlayerState::getTowns() const
+{
+	return getObjectsOfType<const CGTownInstance *>();
+}
+
+std::vector<CGHeroInstance *> PlayerState::getHeroes()
+{
+	return getObjectsOfType<CGHeroInstance *>();
+}
+
+std::vector<CGTownInstance *> PlayerState::getTowns()
+{
+	return getObjectsOfType<CGTownInstance *>();
+}
+
+std::vector<const CGObjectInstance *> PlayerState::getOwnedObjects() const
+{
+	return {ownedObjects.begin(), ownedObjects.end()};
+}
+
+void PlayerState::addOwnedObject(CGObjectInstance * object)
+{
+	assert(object->asOwnable() != nullptr);
+	ownedObjects.push_back(object);
+}
+
+void PlayerState::removeOwnedObject(CGObjectInstance * object)
+{
+	vstd::erase(ownedObjects, object);
+}
+
+
 VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/CPlayerState.h vcmi/lib/CPlayerState.h
--- vcmi-1.5.7/lib/CPlayerState.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/CPlayerState.h	2024-12-19 15:00:22.841145582 +0100
@@ -16,16 +16,16 @@
 #include "bonuses/CBonusSystemNode.h"
 #include "ResourceSet.h"
 #include "TurnTimerInfo.h"
-#include "ConstTransitivePtr.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
+class CGObjectInstance;
 class CGHeroInstance;
 class CGTownInstance;
 class CGDwelling;
 struct QuestInfo;
 
-struct DLL_LINKAGE PlayerState : public CBonusSystemNode, public Player
+class DLL_LINKAGE PlayerState : public CBonusSystemNode, public Player
 {
 	struct VisitedObjectGlobal
 	{
@@ -47,6 +47,11 @@
 		}
 	};
 
+	std::vector<CGObjectInstance*> ownedObjects;
+
+	template<typename T>
+	std::vector<T> getObjectsOfType() const;
+
 public:
 	PlayerColor color;
 	bool human; //true if human controlled player, false for AI
@@ -55,15 +60,12 @@
 
 	/// list of objects that were "destroyed" by player, either via simple pick-up (e.g. resources) or defeated heroes or wandering monsters
 	std::set<ObjectInstanceID> destroyedObjects;
-
 	std::set<ObjectInstanceID> visitedObjects; // as a std::set, since most accesses here will be from visited status checks
 	std::set<VisitedObjectGlobal> visitedObjectsGlobal;
-	std::vector<ConstTransitivePtr<CGHeroInstance> > heroes;
-	std::vector<ConstTransitivePtr<CGTownInstance> > towns;
-	std::vector<ConstTransitivePtr<CGDwelling> > dwellings; //used for town growth
 	std::vector<QuestInfo> quests; //store info about all received quests
 	std::vector<Bonus> battleBonuses; //additional bonuses to be added during battle with neutrals
 	std::map<uint32_t, std::map<ArtifactPosition, ArtifactID>> costumesArtifacts;
+	std::unique_ptr<JsonNode> playerLocalSettings; // Json with client-defined data, such as order of heroes or current hero paths. Not used by client/lib
 
 	bool cheated;
 	bool enteredWinningCheatCode, enteredLosingCheatCode; //if true, this player has entered cheat codes for loss / victory
@@ -85,13 +87,24 @@
 	int32_t getIndex() const override;
 	int32_t getIconIndex() const override;
 	std::string getJsonKey() const override;
+	std::string getModScope() const override;
 	std::string getNameTranslated() const override;
 	std::string getNameTextID() const override;
 	void registerIcons(const IconRegistar & cb) const override;
 
+	std::vector<const CGHeroInstance* > getHeroes() const;
+	std::vector<const CGTownInstance* > getTowns() const;
+	std::vector<CGHeroInstance* > getHeroes();
+	std::vector<CGTownInstance* > getTowns();
+
+	std::vector<const CGObjectInstance* > getOwnedObjects() const;
+
+	void addOwnedObject(CGObjectInstance * object);
+	void removeOwnedObject(CGObjectInstance * object);
+
 	bool checkVanquished() const
 	{
-		return heroes.empty() && towns.empty();
+		return getHeroes().empty() && getTowns().empty();
 	}
 
 	template <typename Handler> void serialize(Handler &h)
@@ -102,9 +115,24 @@
 		h & resources;
 		h & status;
 		h & turnTimer;
-		h & heroes;
-		h & towns;
-		h & dwellings;
+
+		if (h.version >= Handler::Version::LOCAL_PLAYER_STATE_DATA)
+			h & *playerLocalSettings;
+
+		if (h.version >= Handler::Version::PLAYER_STATE_OWNED_OBJECTS)
+		{
+			h & ownedObjects;
+		}
+		else
+		{
+			std::vector<const CGObjectInstance* > heroes;
+			std::vector<const CGObjectInstance* > towns;
+			std::vector<const CGObjectInstance* > dwellings;
+
+			h & heroes;
+			h & towns;
+			h & dwellings;
+		}
 		h & quests;
 		h & visitedObjects;
 		h & visitedObjectsGlobal;
@@ -112,13 +140,11 @@
 		h & daysWithoutCastle;
 		h & cheated;
 		h & battleBonuses;
-		if (h.version >= Handler::Version::ARTIFACT_COSTUMES)
-			h & costumesArtifacts;
+		h & costumesArtifacts;
 		h & enteredLosingCheatCode;
 		h & enteredWinningCheatCode;
 		h & static_cast<CBonusSystemNode&>(*this);
-		if (h.version >= Handler::Version::DESTROYED_OBJECTS)
-			h & destroyedObjects;
+		h & destroyedObjects;
 	}
 };
 
@@ -128,7 +154,9 @@
 	TeamID id; //position in gameState::teams
 	std::set<PlayerColor> players; // members of this team
 	//TODO: boost::array, bool if possible
-	std::unique_ptr<boost::multi_array<ui8, 3>> fogOfWarMap; //[z][x][y] true - visible, false - hidden
+	boost::multi_array<ui8, 3> fogOfWarMap; //[z][x][y] true - visible, false - hidden
+
+	std::set<ObjectInstanceID> scoutedObjects;
 
 	TeamState();
 
@@ -136,8 +164,23 @@
 	{
 		h & id;
 		h & players;
+		if (h.version < Handler::Version::REMOVE_FOG_OF_WAR_POINTER)
+		{
+			struct Helper : public Serializeable
+			{
+				void serialize(Handler &h) const
+				{}
+			};
+			Helper helper;
+			auto ptrHelper = &helper;
+			h & ptrHelper;
+		}
+
 		h & fogOfWarMap;
 		h & static_cast<CBonusSystemNode&>(*this);
+
+		if (h.version >= Handler::Version::REWARDABLE_BANKS)
+			h & scoutedObjects;
 	}
 
 };
diff --color -urN vcmi-1.5.7/lib/CRandomGenerator.cpp vcmi/lib/CRandomGenerator.cpp
--- vcmi-1.5.7/lib/CRandomGenerator.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/CRandomGenerator.cpp	2024-12-19 15:00:22.842145623 +0100
@@ -15,76 +15,87 @@
 
 CRandomGenerator::CRandomGenerator()
 {
+	logRng->trace("CRandomGenerator constructed");
 	resetSeed();
 }
 
 CRandomGenerator::CRandomGenerator(int seed)
 {
+	logRng->trace("CRandomGenerator constructed (%d)", seed);
 	setSeed(seed);
 }
 
 void CRandomGenerator::setSeed(int seed)
 {
+	logRng->trace("CRandomGenerator::setSeed (%d)", seed);
 	rand.seed(seed);
 }
 
 void CRandomGenerator::resetSeed()
 {
+	logRng->trace("CRandomGenerator::resetSeed");
 	boost::hash<std::string> stringHash;
 	auto threadIdHash = stringHash(boost::lexical_cast<std::string>(boost::this_thread::get_id()));
 	setSeed(static_cast<int>(threadIdHash * std::time(nullptr)));
 }
 
-TRandI CRandomGenerator::getIntRange(int lower, int upper)
+int CRandomGenerator::nextInt(int upper)
 {
-	if (lower <= upper)
-		return std::bind(TIntDist(lower, upper), std::ref(rand));
-	throw std::runtime_error("Invalid range provided: " + std::to_string(lower) + " ... " + std::to_string(upper));
+	logRng->trace("CRandomGenerator::nextInt (%d)", upper);
+	return nextInt(0, upper);
 }
 
-vstd::TRandI64 CRandomGenerator::getInt64Range(int64_t lower, int64_t upper)
+int64_t CRandomGenerator::nextInt64(int64_t upper)
 {
-	if(lower <= upper)
-		return std::bind(TInt64Dist(lower, upper), std::ref(rand));
-	throw std::runtime_error("Invalid range provided: " + std::to_string(lower) + " ... " + std::to_string(upper));
-}
-
-int CRandomGenerator::nextInt(int upper)
-{
-	return getIntRange(0, upper)();
+	logRng->trace("CRandomGenerator::nextInt64 (%d)", upper);
+	return nextInt64(0, upper);
 }
 
 int CRandomGenerator::nextInt(int lower, int upper)
 {
-	return getIntRange(lower, upper)();
+	logRng->trace("CRandomGenerator::nextInt64 (%d, %d)", lower, upper);
+
+	if (lower > upper)
+		throw std::runtime_error("Invalid range provided: " + std::to_string(lower) + " ... " + std::to_string(upper));
+
+	return TIntDist(lower, upper)(rand);
 }
 
 int CRandomGenerator::nextInt()
 {
+	logRng->trace("CRandomGenerator::nextInt64");
 	return TIntDist()(rand);
 }
 
-vstd::TRand CRandomGenerator::getDoubleRange(double lower, double upper)
+int CRandomGenerator::nextBinomialInt(int coinsCount, double coinChance)
 {
-	if(lower <= upper)
-		return std::bind(TRealDist(lower, upper), std::ref(rand));
-	throw std::runtime_error("Invalid range provided: " + std::to_string(lower) + " ... " + std::to_string(upper));
+	logRng->trace("CRandomGenerator::nextBinomialInt (%d, %f)", coinsCount, coinChance);
+	std::binomial_distribution<> distribution(coinsCount, coinChance);
+	return distribution(rand);
+}
+
+int64_t CRandomGenerator::nextInt64(int64_t lower, int64_t upper)
+{
+	logRng->trace("CRandomGenerator::nextInt64 (%d, %d)", lower, upper);
+	if (lower > upper)
+		throw std::runtime_error("Invalid range provided: " + std::to_string(lower) + " ... " + std::to_string(upper));
 
+	return TInt64Dist(lower, upper)(rand);
 }
 
 double CRandomGenerator::nextDouble(double upper)
 {
-	return getDoubleRange(0, upper)();
+	logRng->trace("CRandomGenerator::nextDouble (%f)", upper);
+	return nextDouble(0, upper);
 }
 
 double CRandomGenerator::nextDouble(double lower, double upper)
 {
-	return getDoubleRange(lower, upper)();
-}
+	logRng->trace("CRandomGenerator::nextDouble (%f, %f)", lower, upper);
+	if(lower > upper)
+		throw std::runtime_error("Invalid range provided: " + std::to_string(lower) + " ... " + std::to_string(upper));
 
-double CRandomGenerator::nextDouble()
-{
-	return TRealDist()(rand);
+	return TRealDist(lower, upper)(rand);
 }
 
 CRandomGenerator & CRandomGenerator::getDefault()
@@ -93,9 +104,5 @@
 	return defaultRand;
 }
 
-TGenerator & CRandomGenerator::getStdGenerator()
-{
-	return rand;
-}
 
 VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/CRandomGenerator.h vcmi/lib/CRandomGenerator.h
--- vcmi-1.5.7/lib/CRandomGenerator.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/CRandomGenerator.h	2024-12-19 15:00:22.842145623 +0100
@@ -11,9 +11,11 @@
 #pragma once
 
 #include <vstd/RNG.h>
+#include "serializer/Serializeable.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
+
 /// Generator to use for all randomization in game
 /// minstd_rand is selected due to following reasons:
 /// 1. Its randomization quality is below mt_19937 however this is unlikely to be noticeable in game
@@ -22,12 +24,11 @@
 using TIntDist = std::uniform_int_distribution<int>;
 using TInt64Dist = std::uniform_int_distribution<int64_t>;
 using TRealDist = std::uniform_real_distribution<double>;
-using TRandI = std::function<int()>;
 
 /// The random generator randomly generates integers and real numbers("doubles") between
 /// a given range. This is a header only class and mainly a wrapper for
 /// convenient usage of the standard random API. An instance of this RNG is not thread safe.
-class DLL_LINKAGE CRandomGenerator : public vstd::RNG, boost::noncopyable
+class DLL_LINKAGE CRandomGenerator final : public vstd::RNG, boost::noncopyable, public Serializeable
 {
 public:
 	/// Seeds the generator by default with the product of the current time in milliseconds and the
@@ -43,45 +44,33 @@
 	/// current thread ID.
 	void resetSeed();
 
-	/// Generate several integer numbers within the same range.
-	/// e.g.: auto a = gen.getIntRange(0,10); a(); a(); a();
-	/// requires: lower <= upper
-	TRandI getIntRange(int lower, int upper);
-
-	vstd::TRandI64 getInt64Range(int64_t lower, int64_t upper) override;
-
 	/// Generates an integer between 0 and upper.
 	/// requires: 0 <= upper
-	int nextInt(int upper);
+	int nextInt(int upper) override;
+	int64_t nextInt64(int64_t upper) override;
 
 	/// requires: lower <= upper
-	int nextInt(int lower, int upper);
+	int nextInt(int lower, int upper) override;
+	int64_t nextInt64(int64_t lower, int64_t upper) override;
 
 	/// Generates an integer between 0 and the maximum value it can hold.
-	int nextInt();
+	int nextInt() override;
+
+	///
+	int nextBinomialInt(int coinsCount, double coinChance) override;
 
-	/// Generate several double/real numbers within the same range.
-	/// e.g.: auto a = gen.getDoubleRange(4.5,10.2); a(); a(); a();
-	/// requires: lower <= upper
-	vstd::TRand getDoubleRange(double lower, double upper) override;
 
 	/// Generates a double between 0 and upper.
 	/// requires: 0 <= upper
-	double nextDouble(double upper);
+	double nextDouble(double upper) override;
 
 	/// requires: lower <= upper
-	double nextDouble(double lower, double upper);
-
-	/// Generates a double between 0.0 and 1.0.
-	double nextDouble();
+	double nextDouble(double lower, double upper) override;
 
 	/// Gets a globally accessible RNG which will be constructed once per thread. For the
 	/// seed a combination of the thread ID and current time in milliseconds will be used.
 	static CRandomGenerator & getDefault();
 
-	/// Provide method so that this RNG can be used with legacy std:: API
-	TGenerator & getStdGenerator();
-
 private:
 	TGenerator rand;
 
diff --color -urN vcmi-1.5.7/lib/CSkillHandler.cpp vcmi/lib/CSkillHandler.cpp
--- vcmi-1.5.7/lib/CSkillHandler.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/CSkillHandler.cpp	2024-12-19 15:00:22.844145706 +0100
@@ -14,14 +14,17 @@
 
 #include "CSkillHandler.h"
 
-#include "CGeneralTextHandler.h"
+#include "constants/StringConstants.h"
 #include "filesystem/Filesystem.h"
 #include "json/JsonBonus.h"
 #include "json/JsonUtils.h"
 #include "modding/IdentifierStorage.h"
 #include "modding/ModUtility.h"
 #include "modding/ModScope.h"
-#include "constants/StringConstants.h"
+#include "texts/CGeneralTextHandler.h"
+#include "texts/CLegacyConfigParser.h"
+#include "texts/TextOperations.h"
+#include "VCMI_Lib.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
@@ -29,7 +32,9 @@
 	id(id),
 	identifier(std::move(identifier)),
 	obligatoryMajor(obligatoryMajor),
-	obligatoryMinor(obligatoryMinor)
+	obligatoryMinor(obligatoryMinor),
+	special(false),
+	onlyOnWaterMap(false)
 {
 	gainChance[0] = gainChance[1] = 0; //affects CHeroClassHandler::afterLoadFinalization()
 	levels.resize(NSecondarySkill::levels.size() - 1);
@@ -42,7 +47,12 @@
 
 int32_t CSkill::getIconIndex() const
 {
-	return getIndex(); //TODO: actual value with skill level
+	return getIndex() * 3 + 3; // Base master level
+}
+
+int32_t CSkill::getIconIndex(uint8_t skillMasterLevel) const
+{
+	return getIconIndex() + skillMasterLevel;
 }
 
 std::string CSkill::getNameTextID() const
@@ -61,6 +71,11 @@
 	return modScope + ':' + identifier;
 }
 
+std::string CSkill::getModScope() const
+{
+	return modScope;
+}
+
 std::string CSkill::getDescriptionTextID(int level) const
 {
 	TextIdentifier id("skill", modScope, identifier, "description", NSecondarySkill::levels[level]);
@@ -114,7 +129,7 @@
 DLL_LINKAGE std::ostream & operator<<(std::ostream & out, const CSkill::LevelInfo & info)
 {
 	for(int i=0; i < info.effects.size(); i++)
-		out << (i ? "," : "") << info.effects[i]->Description();
+		out << (i ? "," : "") << info.effects[i]->Description(nullptr);
 	return out << "])";
 }
 
@@ -190,7 +205,7 @@
 	return typeNames;
 }
 
-CSkill * CSkillHandler::loadFromJson(const std::string & scope, const JsonNode & json, const std::string & identifier, size_t index)
+std::shared_ptr<CSkill> CSkillHandler::loadFromJson(const std::string & scope, const JsonNode & json, const std::string & identifier, size_t index)
 {
 	assert(identifier.find(':') == std::string::npos);
 	assert(!scope.empty());
@@ -199,12 +214,13 @@
 
 	major = json["obligatoryMajor"].Bool();
 	minor = json["obligatoryMinor"].Bool();
-	auto * skill = new CSkill(SecondarySkill((si32)index), identifier, major, minor);
+	auto skill = std::make_shared<CSkill>(SecondarySkill(index), identifier, major, minor);
 	skill->modScope = scope;
 
 	skill->onlyOnWaterMap = json["onlyOnWaterMap"].Bool();
+	skill->special = json["special"].Bool();
 
-	VLC->generaltexth->registerString(scope, skill->getNameTextID(), json["name"].String());
+	VLC->generaltexth->registerString(scope, skill->getNameTextID(), json["name"]);
 	switch(json["gainChance"].getType())
 	{
 	case JsonNode::JsonType::DATA_INTEGER:
@@ -229,7 +245,7 @@
 			skill->addNewBonus(bonus, level);
 		}
 		CSkill::LevelInfo & skillAtLevel = skill->at(level);
-		VLC->generaltexth->registerString(scope, skill->getDescriptionTextID(level), levelNode["description"].String());
+		VLC->generaltexth->registerString(scope, skill->getDescriptionTextID(level), levelNode["description"]);
 		skillAtLevel.iconSmall = levelNode["images"]["small"].String();
 		skillAtLevel.iconMedium = levelNode["images"]["medium"].String();
 		skillAtLevel.iconLarge = levelNode["images"]["large"].String();
@@ -262,7 +278,8 @@
 	std::set<SecondarySkill> result;
 
 	for (auto const & skill : objects)
-		result.insert(skill->getId());
+		if (!skill->special)
+			result.insert(skill->getId());
 
 	return result;
 }
diff --color -urN vcmi-1.5.7/lib/CSkillHandler.h vcmi/lib/CSkillHandler.h
--- vcmi-1.5.7/lib/CSkillHandler.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/CSkillHandler.h	2024-12-19 15:00:22.844145706 +0100
@@ -34,6 +34,7 @@
 private:
 	std::vector<LevelInfo> levels; // bonuses provided by basic, advanced and expert level
 	void addNewBonus(const std::shared_ptr<Bonus> & b, int level);
+	int32_t getIconIndex() const override;
 
 	SecondarySkill id;
 	std::string modScope;
@@ -50,8 +51,9 @@
 	};
 
 	int32_t getIndex() const override;
-	int32_t getIconIndex() const override;
+	int32_t getIconIndex(uint8_t skillMasterLevel) const;
 	std::string getJsonKey() const override;
+	std::string getModScope() const override;
 	void registerIcons(const IconRegistar & cb) const override;
 	SecondarySkill getId() const override;
 
@@ -73,6 +75,7 @@
 	void serializeJson(JsonSerializeFormat & handler);
 
 	bool onlyOnWaterMap;
+	bool special;
 
 	friend class CSkillHandler;
 	friend DLL_LINKAGE std::ostream & operator<<(std::ostream & out, const CSkill & skill);
@@ -94,7 +97,7 @@
 
 protected:
 	const std::vector<std::string> & getTypeNames() const override;
-	CSkill * loadFromJson(const std::string & scope, const JsonNode & json, const std::string & identifier, size_t index) override;
+	std::shared_ptr<CSkill> loadFromJson(const std::string & scope, const JsonNode & json, const std::string & identifier, size_t index) override;
 };
 
 VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/CSoundBase.h vcmi/lib/CSoundBase.h
--- vcmi-1.5.7/lib/CSoundBase.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/CSoundBase.h	2024-12-19 15:00:22.847145830 +0100
@@ -184,7 +184,7 @@
 VCMI_SOUND_NAME(CGORKill) VCMI_SOUND_FILE(CGORKILL.wav) \
 VCMI_SOUND_NAME(CGORMove) VCMI_SOUND_FILE(CGORMOVE.wav) \
 VCMI_SOUND_NAME(CGORWNCE) VCMI_SOUND_FILE(CGORWNCE.wav) \
-VCMI_SOUND_NAME(chainLigthning) VCMI_SOUND_FILE(CHAINLTE.wav) \
+VCMI_SOUND_NAME(chainLightning) VCMI_SOUND_FILE(CHAINLTE.wav) \
 VCMI_SOUND_NAME(chat) VCMI_SOUND_FILE(CHAT.wav) \
 VCMI_SOUND_NAME(chest) VCMI_SOUND_FILE(CHEST.wav) \
 VCMI_SOUND_NAME(CHMPAttack) VCMI_SOUND_FILE(CHMPATTK.wav) \
@@ -259,7 +259,7 @@
 VCMI_SOUND_NAME(DIPMAGK) VCMI_SOUND_FILE(DIPMAGK.wav) \
 VCMI_SOUND_NAME(DISEASE) VCMI_SOUND_FILE(DISEASE.wav) \
 VCMI_SOUND_NAME(DISGUISE) VCMI_SOUND_FILE(DISGUISE.wav) \
-VCMI_SOUND_NAME(DISPELL) VCMI_SOUND_FILE(DISPELL.wav) \
+VCMI_SOUND_NAME(DISPEL) VCMI_SOUND_FILE(DISPELL.wav) \
 VCMI_SOUND_NAME(DISRUPTR) VCMI_SOUND_FILE(DISRUPTR.wav) \
 VCMI_SOUND_NAME(dragonHall) VCMI_SOUND_FILE(DRAGON.wav) \
 VCMI_SOUND_NAME(DRAINLIF) VCMI_SOUND_FILE(DRAINLIF.wav) \
@@ -817,7 +817,7 @@
 VCMI_SOUND_NAME(PLIZWNCE) VCMI_SOUND_FILE(PLIZWNCE.wav) \
 VCMI_SOUND_NAME(POISON) VCMI_SOUND_FILE(POISON.wav) \
 VCMI_SOUND_NAME(PRAYER) VCMI_SOUND_FILE(PRAYER.wav) \
-VCMI_SOUND_NAME(PRECISON) VCMI_SOUND_FILE(PRECISON.wav) \
+VCMI_SOUND_NAME(PRECISION) VCMI_SOUND_FILE(PRECION.wav) \
 VCMI_SOUND_NAME(PROTECTA) VCMI_SOUND_FILE(PROTECTA.wav) \
 VCMI_SOUND_NAME(PROTECTE) VCMI_SOUND_FILE(PROTECTE.wav) \
 VCMI_SOUND_NAME(PROTECTF) VCMI_SOUND_FILE(PROTECTF.wav) \
@@ -842,7 +842,7 @@
 VCMI_SOUND_NAME(RDDRWNCE) VCMI_SOUND_FILE(RDDRWNCE.wav) \
 VCMI_SOUND_NAME(REGENER) VCMI_SOUND_FILE(REGENER.wav) \
 VCMI_SOUND_NAME(REMoveOB) VCMI_SOUND_FILE(REMOVEOB.wav) \
-VCMI_SOUND_NAME(RESURECT) VCMI_SOUND_FILE(RESURECT.wav) \
+VCMI_SOUND_NAME(RESURRECT) VCMI_SOUND_FILE(RESURECT.wav) \
 VCMI_SOUND_NAME(RGRFAttack) VCMI_SOUND_FILE(RGRFATTK.wav) \
 VCMI_SOUND_NAME(RGRFDefend) VCMI_SOUND_FILE(RGRFDFND.wav) \
 VCMI_SOUND_NAME(RGRFKill) VCMI_SOUND_FILE(RGRFKILL.wav) \
diff --color -urN vcmi-1.5.7/lib/CStack.cpp vcmi/lib/CStack.cpp
--- vcmi-1.5.7/lib/CStack.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/CStack.cpp	2024-12-19 15:00:22.848145871 +0100
@@ -15,7 +15,7 @@
 #include <vcmi/Entity.h>
 #include <vcmi/ServerCallback.h>
 
-#include "CGeneralTextHandler.h"
+#include "texts/CGeneralTextHandler.h"
 #include "battle/BattleInfo.h"
 #include "spells/CSpellHandler.h"
 #include "networkPacks/PacksForClientBattle.h"
@@ -24,11 +24,11 @@
 
 
 ///CStack
-CStack::CStack(const CStackInstance * Base, const PlayerColor & O, int I, ui8 Side, const SlotID & S):
+CStack::CStack(const CStackInstance * Base, const PlayerColor & O, int I, BattleSide Side, const SlotID & S):
 	CBonusSystemNode(STACK_BATTLE),
 	base(Base),
 	ID(I),
-	type(Base->type),
+	typeID(Base->getId()),
 	baseAmount(Base->count),
 	owner(O),
 	slot(S),
@@ -45,10 +45,10 @@
 {
 }
 
-CStack::CStack(const CStackBasicDescriptor * stack, const PlayerColor & O, int I, ui8 Side, const SlotID & S):
+CStack::CStack(const CStackBasicDescriptor * stack, const PlayerColor & O, int I, BattleSide Side, const SlotID & S):
 	CBonusSystemNode(STACK_BATTLE),
 	ID(I),
-	type(stack->type),
+	typeID(stack->getId()),
 	baseAmount(stack->count),
 	owner(O),
 	slot(S),
@@ -60,7 +60,7 @@
 void CStack::localInit(BattleInfo * battleInfo)
 {
 	battle = battleInfo;
-	assert(type);
+	assert(typeID.hasValue());
 
 	exportBonuses();
 	if(base) //stack originating from "real" stack in garrison -> attach to it
@@ -72,7 +72,7 @@
 		CArmedInstance * army = battle->battleGetArmyObject(side);
 		assert(army);
 		attachTo(*army);
-		attachToSource(*type);
+		attachToSource(*typeID.toCreature());
 	}
 	nativeTerrain = getNativeTerrain(); //save nativeTerrain in the variable on the battle start to avoid dead lock
 	CUnitState::localInit(this); //it causes execution of the CStack::isOnNativeTerrain where nativeTerrain will be considered
@@ -164,8 +164,8 @@
 	std::ostringstream oss;
 	oss << owner.toString();
 	oss << " battle stack [" << ID << "]: " << getCount() << " of ";
-	if(type)
-		oss << type->getNamePluralTextID();
+	if(typeID.hasValue())
+		oss << typeID.toEntity(VLC)->getNamePluralTextID();
 	else
 		oss << "[UNDEFINED TYPE]";
 
@@ -212,11 +212,9 @@
 
 			auto resurrectedAdd = static_cast<int32_t>(baseAmount - (resurrectedCount / resurrectFactor));
 
-			auto rangeGen = rand.getInt64Range(0, 99);
-
 			for(int32_t i = 0; i < resurrectedAdd; i++)
 			{
-				if(resurrectValue > rangeGen())
+				if(resurrectValue > rand.nextInt(0, 99))
 					resurrectedCount += 1;
 			}
 
@@ -298,12 +296,15 @@
 
 bool CStack::isMeleeAttackPossible(const battle::Unit * attacker, const battle::Unit * defender, BattleHex attackerPos, BattleHex defenderPos)
 {
+	if(defender->hasBonusOfType(BonusType::INVINCIBLE))
+		return false;
+		
 	return !meleeAttackHexes(attacker, defender, attackerPos, defenderPos).empty();
 }
 
 std::string CStack::getName() const
 {
-	return (getCount() == 1) ? type->getNameSingularTranslated() : type->getNamePluralTranslated(); //War machines can't use base
+	return (getCount() == 1) ? typeID.toEntity(VLC)->getNameSingularTranslated() : typeID.toEntity(VLC)->getNamePluralTranslated(); //War machines can't use base
 }
 
 bool CStack::canBeHealed() const
@@ -325,7 +326,7 @@
 
 const CCreature * CStack::unitType() const
 {
-	return type;
+	return typeID.toCreature();
 }
 
 int32_t CStack::unitBaseAmount() const
@@ -351,7 +352,7 @@
 	const auto * ownerHero = battle->battleGetOwnerHero(unit);
 	if(ownerHero && ownerHero->artifactsWorn.find(ArtifactPosition::MACH2) != ownerHero->artifactsWorn.end())
 	{
-		if(battle->battleGetOwnerHero(unit)->artifactsWorn.at(ArtifactPosition::MACH2).artifact->artType->getId() == ArtifactID::AMMO_CART)
+		if(battle->battleGetOwnerHero(unit)->artifactsWorn.at(ArtifactPosition::MACH2).artifact->getTypeId() == ArtifactID::AMMO_CART)
 		{
 			return true;
 		}
@@ -369,7 +370,7 @@
 	return ID;
 }
 
-ui8 CStack::unitSide() const
+BattleSide CStack::unitSide() const
 {
 	return side;
 }
@@ -400,7 +401,7 @@
 	ssp.which = BattleSetStackProperty::CASTS;
 	ssp.val = -spellCost;
 	ssp.absolute = false;
-	server->apply(&ssp);
+	server->apply(ssp);
 }
 
 VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/CStack.h vcmi/lib/CStack.h
--- vcmi-1.5.7/lib/CStack.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/CStack.h	2024-12-19 15:00:22.848145871 +0100
@@ -27,12 +27,12 @@
 {
 private:
 	ui32 ID = -1; //unique ID of stack
-	const CCreature * type = nullptr;
+	CreatureID typeID;
 	TerrainId nativeTerrain; //tmp variable to save native terrain value on battle init
 	ui32 baseAmount = -1;
 
 	PlayerColor owner; //owner - player color (255 for neutrals)
-	ui8 side = 1;
+	BattleSide side = BattleSide::NONE;
 
 	SlotID slot;  //slot - position in garrison (may be 255 for neutrals/called creatures)
 
@@ -41,8 +41,8 @@
 	
 	BattleHex initialPosition; //position on battlefield; -2 - keep, -3 - lower tower, -4 - upper tower
 
-	CStack(const CStackInstance * base, const PlayerColor & O, int I, ui8 Side, const SlotID & S);
-	CStack(const CStackBasicDescriptor * stack, const PlayerColor & O, int I, ui8 Side, const SlotID & S = SlotID(255));
+	CStack(const CStackInstance * base, const PlayerColor & O, int I, BattleSide Side, const SlotID & S);
+	CStack(const CStackBasicDescriptor * stack, const PlayerColor & O, int I, BattleSide Side, const SlotID & S = SlotID(255));
 	CStack();
 	~CStack();
 
@@ -65,16 +65,16 @@
 
 	BattleHex::EDir destShiftDir() const;
 
-	void prepareAttacked(BattleStackAttacked & bsa, vstd::RNG & rand) const; //requires bsa.damageAmout filled
+	void prepareAttacked(BattleStackAttacked & bsa, vstd::RNG & rand) const; //requires bsa.damageAmount filled
 	static void prepareAttacked(BattleStackAttacked & bsa,
 								vstd::RNG & rand,
-								const std::shared_ptr<battle::CUnitState> & customState); //requires bsa.damageAmout filled
+								const std::shared_ptr<battle::CUnitState> & customState); //requires bsa.damageAmount filled
 
 	const CCreature * unitType() const override;
 	int32_t unitBaseAmount() const override;
 
 	uint32_t unitId() const override;
-	ui8 unitSide() const override;
+	BattleSide unitSide() const override;
 	PlayerColor unitOwner() const override;
 	SlotID unitSlot() const override;
 
@@ -98,7 +98,7 @@
 		//stackState is not serialized here
 		assert(isIndependentNode());
 		h & static_cast<CBonusSystemNode&>(*this);
-		h & type;
+		h & typeID;
 		h & ID;
 		h & baseAmount;
 		h & owner;
@@ -133,7 +133,7 @@
 			else if(!army || extSlot == SlotID() || !army->hasStackAtSlot(extSlot))
 			{
 				base = nullptr;
-				logGlobal->warn("%s doesn't have a base stack!", type->getNameSingularTranslated());
+				logGlobal->warn("%s doesn't have a base stack!", typeID.toEntity(VLC)->getNameSingularTranslated());
 			}
 			else
 			{
diff --color -urN vcmi-1.5.7/lib/CTownHandler.cpp vcmi/lib/CTownHandler.cpp
--- vcmi-1.5.7/lib/CTownHandler.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/CTownHandler.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,1290 +0,0 @@
-/*
- * CTownHandler.cpp, part of VCMI engine
- *
- * Authors: listed in file AUTHORS in main folder
- *
- * License: GNU General Public License v2.0 or later
- * Full text of license available in license.txt file, in main folder
- *
- */
-#include "StdInc.h"
-#include "CTownHandler.h"
-
-#include "VCMI_Lib.h"
-#include "CGeneralTextHandler.h"
-#include "constants/StringConstants.h"
-#include "CCreatureHandler.h"
-#include "CHeroHandler.h"
-#include "CArtHandler.h"
-#include "GameSettings.h"
-#include "TerrainHandler.h"
-#include "spells/CSpellHandler.h"
-#include "filesystem/Filesystem.h"
-#include "bonuses/Bonus.h"
-#include "bonuses/Propagators.h"
-#include "json/JsonBonus.h"
-#include "ResourceSet.h"
-#include "mapObjectConstructors/AObjectTypeHandler.h"
-#include "mapObjectConstructors/CObjectClassesHandler.h"
-#include "modding/IdentifierStorage.h"
-#include "modding/ModScope.h"
-
-VCMI_LIB_NAMESPACE_BEGIN
-
-const int NAMES_PER_TOWN=16; // number of town names per faction in H3 files. Json can define any number
-
-const std::map<std::string, CBuilding::EBuildMode> CBuilding::MODES =
-{
-	{ "normal", CBuilding::BUILD_NORMAL },
-	{ "auto", CBuilding::BUILD_AUTO },
-	{ "special", CBuilding::BUILD_SPECIAL },
-	{ "grail", CBuilding::BUILD_GRAIL }
-};
-
-const std::map<std::string, CBuilding::ETowerHeight> CBuilding::TOWER_TYPES =
-{
-	{ "low", CBuilding::HEIGHT_LOW },
-	{ "average", CBuilding::HEIGHT_AVERAGE },
-	{ "high", CBuilding::HEIGHT_HIGH },
-	{ "skyship", CBuilding::HEIGHT_SKYSHIP }
-};
-
-BuildingTypeUniqueID::BuildingTypeUniqueID(FactionID factionID, BuildingID buildingID ):
-	BuildingTypeUniqueID(factionID.getNum() * 0x10000 + buildingID.getNum())
-{
-	assert(factionID.getNum() >= 0);
-	assert(factionID.getNum() < 0x10000);
-	assert(buildingID.getNum() >= 0);
-	assert(buildingID.getNum() < 0x10000);
-}
-
-BuildingID BuildingTypeUniqueID::getBuilding() const
-{
-	return BuildingID(getNum() % 0x10000);
-}
-
-FactionID BuildingTypeUniqueID::getFaction() const
-{
-	return FactionID(getNum() / 0x10000);
-}
-
-const BuildingTypeUniqueID CBuilding::getUniqueTypeID() const
-{
-	return BuildingTypeUniqueID(town->faction->getId(), bid);
-}
-
-std::string CBuilding::getJsonKey() const
-{
-	return modScope + ':' + identifier;
-}
-
-std::string CBuilding::getNameTranslated() const
-{
-	return VLC->generaltexth->translate(getNameTextID());
-}
-
-std::string CBuilding::getDescriptionTranslated() const
-{
-	return VLC->generaltexth->translate(getDescriptionTextID());
-}
-
-std::string CBuilding::getBaseTextID() const
-{
-	return TextIdentifier("building", modScope, town->faction->identifier, identifier).get();
-}
-
-std::string CBuilding::getNameTextID() const
-{
-	return TextIdentifier(getBaseTextID(), "name").get();
-}
-
-std::string CBuilding::getDescriptionTextID() const
-{
-	return TextIdentifier(getBaseTextID(), "description").get();
-}
-
-BuildingID CBuilding::getBase() const
-{
-	const CBuilding * build = this;
-	while (build->upgrade != BuildingID::NONE)
-	{
-		build = build->town->buildings.at(build->upgrade);
-	}
-
-	return build->bid;
-}
-
-si32 CBuilding::getDistance(const BuildingID & buildID) const
-{
-	const CBuilding * build = town->buildings.at(buildID);
-	int distance = 0;
-	while (build->upgrade != BuildingID::NONE && build != this)
-	{
-		build = build->town->buildings.at(build->upgrade);
-		distance++;
-	}
-	if (build == this)
-		return distance;
-	return -1;
-}
-
-void CBuilding::addNewBonus(const std::shared_ptr<Bonus> & b, BonusList & bonusList) const
-{
-	bonusList.push_back(b);
-}
-
-CFaction::~CFaction()
-{
-	if (town)
-	{
-		delete town;
-		town = nullptr;
-	}
-}
-
-int32_t CFaction::getIndex() const
-{
-	return index.getNum();
-}
-
-int32_t CFaction::getIconIndex() const
-{
-	return index.getNum(); //???
-}
-
-std::string CFaction::getJsonKey() const
-{
-	return modScope + ':' + identifier;
-}
-
-void CFaction::registerIcons(const IconRegistar & cb) const
-{
-	if(town)
-	{
-		auto & info = town->clientInfo;
-		cb(info.icons[0][0], 0, "ITPT", info.iconLarge[0][0]);
-		cb(info.icons[0][1], 0, "ITPT", info.iconLarge[0][1]);
-		cb(info.icons[1][0], 0, "ITPT", info.iconLarge[1][0]);
-		cb(info.icons[1][1], 0, "ITPT", info.iconLarge[1][1]);
-
-		cb(info.icons[0][0] + 2, 0, "ITPA", info.iconSmall[0][0]);
-		cb(info.icons[0][1] + 2, 0, "ITPA", info.iconSmall[0][1]);
-		cb(info.icons[1][0] + 2, 0, "ITPA", info.iconSmall[1][0]);
-		cb(info.icons[1][1] + 2, 0, "ITPA", info.iconSmall[1][1]);
-
-		cb(index.getNum(), 1, "CPRSMALL", info.towerIconSmall);
-		cb(index.getNum(), 1, "TWCRPORT", info.towerIconLarge);
-
-	}
-}
-
-std::string CFaction::getNameTranslated() const
-{
-	return VLC->generaltexth->translate(getNameTextID());
-}
-
-std::string CFaction::getNameTextID() const
-{
-	return TextIdentifier("faction", modScope, identifier, "name").get();
-}
-
-std::string CFaction::getDescriptionTranslated() const
-{
-	return VLC->generaltexth->translate(getDescriptionTextID());
-}
-
-std::string CFaction::getDescriptionTextID() const
-{
-	return TextIdentifier("faction", modScope, identifier, "description").get();
-}
-
-FactionID CFaction::getId() const
-{
-	return FactionID(index);
-}
-
-FactionID CFaction::getFaction() const
-{
-	return FactionID(index);
-}
-
-bool CFaction::hasTown() const
-{
-	return town != nullptr;
-}
-
-EAlignment CFaction::getAlignment() const
-{
-	return alignment;
-}
-
-BoatId CFaction::getBoatType() const
-{
-	return boatType;
-}
-
-TerrainId CFaction::getNativeTerrain() const
-{
-	return nativeTerrain;
-}
-
-void CFaction::updateFrom(const JsonNode & data)
-{
-
-}
-
-void CFaction::serializeJson(JsonSerializeFormat & handler)
-{
-
-}
-
-
-CTown::CTown()
-	: faction(nullptr), mageLevel(0), primaryRes(0), moatAbility(SpellID::NONE), defaultTavernChance(0)
-{
-}
-
-CTown::~CTown()
-{
-	for(auto & build : buildings)
-		build.second.dellNull();
-
-	for(auto & str : clientInfo.structures)
-		str.dellNull();
-}
-
-std::string CTown::getRandomNameTextID(size_t index) const
-{
-	return TextIdentifier("faction", faction->modScope, faction->identifier, "randomName", index).get();
-}
-
-size_t CTown::getRandomNamesCount() const
-{
-	return namesCount;
-}
-
-std::string CTown::getBuildingScope() const
-{
-	if(faction == nullptr)
-		//no faction == random faction
-		return "building";
-	else
-		return "building." + faction->getJsonKey();
-}
-
-std::set<si32> CTown::getAllBuildings() const
-{
-	std::set<si32> res;
-
-	for(const auto & b : buildings)
-	{
-		res.insert(b.first.num);
-	}
-
-	return res;
-}
-
-const CBuilding * CTown::getSpecialBuilding(BuildingSubID::EBuildingSubID subID) const
-{
-	for(const auto & kvp : buildings)
-	{
-		if(kvp.second->subId == subID)
-			return buildings.at(kvp.first);
-	}
-	return nullptr;
-}
-
-BuildingID CTown::getBuildingType(BuildingSubID::EBuildingSubID subID) const
-{
-	const auto * building = getSpecialBuilding(subID);
-	return building == nullptr ? BuildingID::NONE : building->bid.num;
-}
-
-std::string CTown::getGreeting(BuildingSubID::EBuildingSubID subID) const
-{
-	return CTownHandler::getMappedValue<const std::string, BuildingSubID::EBuildingSubID>(subID, std::string(), specialMessages, false);
-}
-
-void CTown::setGreeting(BuildingSubID::EBuildingSubID subID, const std::string & message) const
-{
-	specialMessages.insert(std::pair<BuildingSubID::EBuildingSubID, const std::string>(subID, message));
-}
-
-CTownHandler::CTownHandler():
-	randomTown(new CTown()),
-	randomFaction(new CFaction())
-{
-	randomFaction->town = randomTown;
-	randomTown->faction = randomFaction;
-	randomFaction->identifier = "random";
-	randomFaction->modScope = "core";
-}
-
-CTownHandler::~CTownHandler()
-{
-	delete randomFaction; // will also delete randomTown
-}
-
-JsonNode readBuilding(CLegacyConfigParser & parser)
-{
-	JsonNode ret;
-	JsonNode & cost = ret["cost"];
-
-	//note: this code will try to parse mithril as well but wil always return 0 for it
-	for(const std::string & resID : GameConstants::RESOURCE_NAMES)
-		cost[resID].Float() = parser.readNumber();
-
-	cost.Struct().erase("mithril"); // erase mithril to avoid confusing validator
-
-	parser.endLine();
-
-	return ret;
-}
-
-const TPropagatorPtr & CTownHandler::emptyPropagator()
-{
-	static const TPropagatorPtr emptyProp(nullptr);
-	return emptyProp;
-}
-
-std::vector<JsonNode> CTownHandler::loadLegacyData()
-{
-	size_t dataSize = VLC->settings()->getInteger(EGameSettings::TEXTS_FACTION);
-
-	std::vector<JsonNode> dest(dataSize);
-	objects.resize(dataSize);
-
-	auto getBuild = [&](size_t town, size_t building) -> JsonNode &
-	{
-		return dest[town]["town"]["buildings"][EBuildingType::names[building]];
-	};
-
-	CLegacyConfigParser parser(TextPath::builtin("DATA/BUILDING.TXT"));
-
-	parser.endLine(); // header
-	parser.endLine();
-
-	//Unique buildings
-	for (size_t town=0; town<dataSize; town++)
-	{
-		parser.endLine(); //header
-		parser.endLine();
-
-		int buildID = 17;
-		do
-		{
-			getBuild(town, buildID) = readBuilding(parser);
-			buildID++;
-		}
-		while (!parser.isNextEntryEmpty());
-	}
-
-	// Common buildings
-	parser.endLine(); // header
-	parser.endLine();
-	parser.endLine();
-
-	int buildID = 0;
-	do
-	{
-		JsonNode building = readBuilding(parser);
-
-		for (size_t town=0; town<dataSize; town++)
-			getBuild(town, buildID) = building;
-
-		buildID++;
-	}
-	while (!parser.isNextEntryEmpty());
-
-	parser.endLine(); //header
-	parser.endLine();
-
-	//Dwellings
-	for (size_t town=0; town<dataSize; town++)
-	{
-		parser.endLine(); //header
-		parser.endLine();
-
-		for (size_t i=0; i<14; i++)
-		{
-			getBuild(town, 30+i) = readBuilding(parser);
-		}
-	}
-	{
-		CLegacyConfigParser parser(TextPath::builtin("DATA/BLDGNEUT.TXT"));
-
-		for(int building=0; building<15; building++)
-		{
-			std::string name  = parser.readString();
-			std::string descr = parser.readString();
-			parser.endLine();
-
-			for(int j=0; j<dataSize; j++)
-			{
-				getBuild(j, building)["name"].String() = name;
-				getBuild(j, building)["description"].String() = descr;
-			}
-		}
-		parser.endLine(); // silo
-		parser.endLine(); // blacksmith  //unused entries
-		parser.endLine(); // moat
-
-		//shipyard with the ship
-		std::string name  = parser.readString();
-		std::string descr = parser.readString();
-		parser.endLine();
-
-		for(int town=0; town<dataSize; town++)
-		{
-			getBuild(town, 20)["name"].String() = name;
-			getBuild(town, 20)["description"].String() = descr;
-		}
-
-		//blacksmith
-		for(int town=0; town<dataSize; town++)
-		{
-			getBuild(town, 16)["name"].String() =  parser.readString();
-			getBuild(town, 16)["description"].String() = parser.readString();
-			parser.endLine();
-		}
-	}
-	{
-		CLegacyConfigParser parser(TextPath::builtin("DATA/BLDGSPEC.TXT"));
-
-		for(int town=0; town<dataSize; town++)
-		{
-			for(int build=0; build<9; build++)
-			{
-				getBuild(town, 17 + build)["name"].String() =  parser.readString();
-				getBuild(town, 17 + build)["description"].String() = parser.readString();
-				parser.endLine();
-			}
-			getBuild(town, 26)["name"].String() =  parser.readString(); // Grail
-			getBuild(town, 26)["description"].String() = parser.readString();
-			parser.endLine();
-
-			getBuild(town, 15)["name"].String() =  parser.readString(); // Resource silo
-			getBuild(town, 15)["description"].String() = parser.readString();
-			parser.endLine();
-		}
-	}
-	{
-		CLegacyConfigParser parser(TextPath::builtin("DATA/DWELLING.TXT"));
-
-		for(int town=0; town<dataSize; town++)
-		{
-			for(int build=0; build<14; build++)
-			{
-				getBuild(town, 30 + build)["name"].String() =  parser.readString();
-				getBuild(town, 30 + build)["description"].String() = parser.readString();
-				parser.endLine();
-			}
-		}
-	}
-	{
-		CLegacyConfigParser typeParser(TextPath::builtin("DATA/TOWNTYPE.TXT"));
-		CLegacyConfigParser nameParser(TextPath::builtin("DATA/TOWNNAME.TXT"));
-		size_t townID=0;
-		do
-		{
-			dest[townID]["name"].String() = typeParser.readString();
-
-			for (int i=0; i<NAMES_PER_TOWN; i++)
-			{
-				JsonNode name;
-				name.String() = nameParser.readString();
-				dest[townID]["town"]["names"].Vector().push_back(name);
-				nameParser.endLine();
-			}
-			townID++;
-		}
-		while (typeParser.endLine());
-	}
-	return dest;
-}
-
-void CTownHandler::loadBuildingRequirements(CBuilding * building, const JsonNode & source, std::vector<BuildingRequirementsHelper> & bidsToLoad) const
-{
-	if (source.isNull())
-		return;
-
-	BuildingRequirementsHelper hlp;
-	hlp.building = building;
-	hlp.town = building->town;
-	hlp.json = source;
-	bidsToLoad.push_back(hlp);
-}
-
-template<typename R, typename K>
-R CTownHandler::getMappedValue(const K key, const R defval, const std::map<K, R> & map, bool required)
-{
-	auto it = map.find(key);
-
-	if(it != map.end())
-		return it->second;
-
-	if(required)
-		logMod->warn("Warning: Property: '%s' is unknown. Correct the typo or update VCMI.", key);
-	return defval;
-}
-
-template<typename R>
-R CTownHandler::getMappedValue(const JsonNode & node, const R defval, const std::map<std::string, R> & map, bool required)
-{
-	if(!node.isNull() && node.getType() == JsonNode::JsonType::DATA_STRING)
-		return getMappedValue<R, std::string>(node.String(), defval, map, required);
-	return defval;
-}
-
-void CTownHandler::addBonusesForVanilaBuilding(CBuilding * building) const
-{
-	std::shared_ptr<Bonus> b;
-	static const TPropagatorPtr playerPropagator = std::make_shared<CPropagatorNodeType>(CBonusSystemNode::ENodeTypes::PLAYER);
-
-	if(building->bid == BuildingID::TAVERN)
-	{
-		b = createBonus(building, BonusType::MORALE, +1);
-	}
-
-	switch(building->subId)
-	{
-	case BuildingSubID::BROTHERHOOD_OF_SWORD:
-		b = createBonus(building, BonusType::MORALE, +2);
-		building->overrideBids.insert(BuildingID::TAVERN);
-		break;
-	case BuildingSubID::FOUNTAIN_OF_FORTUNE:
-		b = createBonus(building, BonusType::LUCK, +2);
-		break;
-	case BuildingSubID::SPELL_POWER_GARRISON_BONUS:
-		b = createBonus(building, BonusType::PRIMARY_SKILL, +2, BonusSubtypeID(PrimarySkill::SPELL_POWER));
-		break;
-	case BuildingSubID::ATTACK_GARRISON_BONUS:
-		b = createBonus(building, BonusType::PRIMARY_SKILL, +2, BonusSubtypeID(PrimarySkill::ATTACK));
-		break;
-	case BuildingSubID::DEFENSE_GARRISON_BONUS:
-		b = createBonus(building, BonusType::PRIMARY_SKILL, +2, BonusSubtypeID(PrimarySkill::DEFENSE));
-		break;
-	case BuildingSubID::LIGHTHOUSE:
-		b = createBonus(building, BonusType::MOVEMENT, +500, BonusCustomSubtype::heroMovementSea, playerPropagator);
-		break;
-	}
-
-	if(b)
-		building->addNewBonus(b, building->buildingBonuses);
-}
-
-std::shared_ptr<Bonus> CTownHandler::createBonus(CBuilding * build, BonusType type, int val) const
-{
-	return createBonus(build, type, val, BonusSubtypeID(), emptyPropagator());
-}
-
-std::shared_ptr<Bonus> CTownHandler::createBonus(CBuilding * build, BonusType type, int val, BonusSubtypeID subtype) const
-{
-	return createBonus(build, type, val, subtype, emptyPropagator());
-}
-
-std::shared_ptr<Bonus> CTownHandler::createBonus(CBuilding * build, BonusType type, int val, BonusSubtypeID subtype, const TPropagatorPtr & prop) const
-{
-	auto b = std::make_shared<Bonus>(BonusDuration::PERMANENT, type, BonusSource::TOWN_STRUCTURE, val, build->getUniqueTypeID(), subtype);
-
-	b->description.appendTextID(build->getNameTextID());
-
-	if(prop)
-		b->addPropagator(prop);
-
-	return b;
-}
-
-void CTownHandler::loadSpecialBuildingBonuses(const JsonNode & source, BonusList & bonusList, CBuilding * building)
-{
-	for(const auto & b : source.Vector())
-	{
-		auto bonus = std::make_shared<Bonus>(BonusDuration::PERMANENT, BonusType::NONE, BonusSource::TOWN_STRUCTURE, 0, BonusSourceID(building->getUniqueTypeID()));
-
-		if(!JsonUtils::parseBonus(b, bonus.get()))
-			continue;
-
-		bonus->description.appendTextID(building->getNameTextID());
-
-		//JsonUtils::parseBuildingBonus produces UNKNOWN type propagator instead of empty.
-		if(bonus->propagator != nullptr
-			&& bonus->propagator->getPropagatorType() == CBonusSystemNode::ENodeTypes::UNKNOWN)
-				bonus->addPropagator(emptyPropagator());
-		building->addNewBonus(bonus, bonusList);
-	}
-}
-
-void CTownHandler::loadBuilding(CTown * town, const std::string & stringID, const JsonNode & source)
-{
-	assert(stringID.find(':') == std::string::npos);
-	assert(!source.getModScope().empty());
-
-	auto * ret = new CBuilding();
-	ret->bid = getMappedValue<BuildingID, std::string>(stringID, BuildingID::NONE, MappedKeys::BUILDING_NAMES_TO_TYPES, false);
-	ret->subId = BuildingSubID::NONE;
-
-	if(ret->bid == BuildingID::NONE && !source["id"].isNull())
-	{
-		// FIXME: A lot of false-positives with no clear way to handle them in mods
-		//logMod->warn("Building %s: id field is deprecated", stringID);
-		ret->bid = source["id"].isNull() ? BuildingID(BuildingID::NONE) : BuildingID(source["id"].Float());
-	}
-
-	if (ret->bid == BuildingID::NONE)
-		logMod->error("Building '%s' isn't recognized and won't work properly. Correct the typo or update VCMI.", stringID);
-
-	ret->mode = ret->bid == BuildingID::GRAIL
-		? CBuilding::BUILD_GRAIL
-		: getMappedValue<CBuilding::EBuildMode>(source["mode"], CBuilding::BUILD_NORMAL, CBuilding::MODES);
-
-	ret->height = getMappedValue<CBuilding::ETowerHeight>(source["height"], CBuilding::HEIGHT_NO_TOWER, CBuilding::TOWER_TYPES);
-
-	ret->identifier = stringID;
-	ret->modScope = source.getModScope();
-	ret->town = town;
-
-	VLC->generaltexth->registerString(source.getModScope(), ret->getNameTextID(), source["name"].String());
-	VLC->generaltexth->registerString(source.getModScope(), ret->getDescriptionTextID(), source["description"].String());
-
-	ret->resources = TResources(source["cost"]);
-	ret->produce =   TResources(source["produce"]);
-
-	if(ret->bid == BuildingID::TAVERN)
-		addBonusesForVanilaBuilding(ret);
-	else if(ret->bid.IsSpecialOrGrail())
-	{
-		loadSpecialBuildingBonuses(source["bonuses"], ret->buildingBonuses, ret);
-
-		if(ret->buildingBonuses.empty())
-		{
-			ret->subId = getMappedValue<BuildingSubID::EBuildingSubID>(source["type"], BuildingSubID::NONE, MappedKeys::SPECIAL_BUILDINGS);
-			addBonusesForVanilaBuilding(ret);
-		}
-
-		loadSpecialBuildingBonuses(source["onVisitBonuses"], ret->onVisitBonuses, ret);
-
-		if(!ret->onVisitBonuses.empty())
-		{
-			if(ret->subId == BuildingSubID::NONE)
-				ret->subId = BuildingSubID::CUSTOM_VISITING_BONUS;
-
-			for(auto & bonus : ret->onVisitBonuses)
-				bonus->sid = BonusSourceID(ret->getUniqueTypeID());
-		}
-		
-		if(source["type"].String() == "configurable" && ret->subId == BuildingSubID::NONE)
-		{
-			ret->subId = BuildingSubID::CUSTOM_VISITING_REWARD;
-			ret->rewardableObjectInfo.init(source, ret->getBaseTextID());
-		}
-	}
-	//MODS COMPATIBILITY FOR 0.96
-	if(!ret->produce.nonZero())
-	{
-		switch (ret->bid.toEnum()) {
-			break; case BuildingID::VILLAGE_HALL: ret->produce[EGameResID::GOLD] = 500;
-			break; case BuildingID::TOWN_HALL :   ret->produce[EGameResID::GOLD] = 1000;
-			break; case BuildingID::CITY_HALL :   ret->produce[EGameResID::GOLD] = 2000;
-			break; case BuildingID::CAPITOL :     ret->produce[EGameResID::GOLD] = 4000;
-			break; case BuildingID::GRAIL :       ret->produce[EGameResID::GOLD] = 5000;
-			break; case BuildingID::RESOURCE_SILO :
-			{
-				switch (ret->town->primaryRes.toEnum())
-				{
-					case EGameResID::GOLD:
-						ret->produce[ret->town->primaryRes] = 500;
-						break;
-					case EGameResID::WOOD_AND_ORE:
-						ret->produce[EGameResID::WOOD] = 1;
-						ret->produce[EGameResID::ORE] = 1;
-						break;
-					default:
-						ret->produce[ret->town->primaryRes] = 1;
-						break;
-				}
-			}
-		}
-	}
-	loadBuildingRequirements(ret, source["requires"], requirementsToLoad);
-
-	if(ret->bid.IsSpecialOrGrail())
-		loadBuildingRequirements(ret, source["overrides"], overriddenBidsToLoad);
-
-	if (!source["upgrades"].isNull())
-	{
-		// building id and upgrades can't be the same
-		if(stringID == source["upgrades"].String())
-		{
-			throw std::runtime_error(boost::str(boost::format("Building with ID '%s' of town '%s' can't be an upgrade of the same building.") %
-												stringID % ret->town->faction->getNameTranslated()));
-		}
-
-		VLC->identifiers()->requestIdentifier(ret->town->getBuildingScope(), source["upgrades"], [=](si32 identifier)
-		{
-			ret->upgrade = BuildingID(identifier);
-		});
-	}
-	else
-		ret->upgrade = BuildingID::NONE;
-
-	ret->town->buildings[ret->bid] = ret;
-
-	registerObject(source.getModScope(), ret->town->getBuildingScope(), ret->identifier, ret->bid.getNum());
-}
-
-void CTownHandler::loadBuildings(CTown * town, const JsonNode & source)
-{
-	if(source.isStruct())
-	{
-		for(const auto & node : source.Struct())
-		{
-			if (!node.second.isNull())
-				loadBuilding(town, node.first, node.second);
-		}
-	}
-}
-
-void CTownHandler::loadStructure(CTown &town, const std::string & stringID, const JsonNode & source) const
-{
-	auto * ret = new CStructure();
-
-	ret->building = nullptr;
-	ret->buildable = nullptr;
-
-	VLC->identifiers()->tryRequestIdentifier( source.getModScope(), "building." + town.faction->getJsonKey(), stringID, [=, &town](si32 identifier) mutable
-	{
-		ret->building = town.buildings[BuildingID(identifier)];
-	});
-
-	if (source["builds"].isNull())
-	{
-		VLC->identifiers()->tryRequestIdentifier( source.getModScope(), "building." + town.faction->getJsonKey(), stringID, [=, &town](si32 identifier) mutable
-		{
-			ret->building = town.buildings[BuildingID(identifier)];
-		});
-	}
-	else
-	{
-		VLC->identifiers()->requestIdentifier("building." + town.faction->getJsonKey(), source["builds"], [=, &town](si32 identifier) mutable
-		{
-			ret->buildable = town.buildings[BuildingID(identifier)];
-		});
-	}
-
-	ret->identifier = stringID;
-	ret->pos.x = static_cast<si32>(source["x"].Float());
-	ret->pos.y = static_cast<si32>(source["y"].Float());
-	ret->pos.z = static_cast<si32>(source["z"].Float());
-
-	ret->hiddenUpgrade = source["hidden"].Bool();
-	ret->defName = AnimationPath::fromJson(source["animation"]);
-	ret->borderName = ImagePath::fromJson(source["border"]);
-	ret->areaName = ImagePath::fromJson(source["area"]);
-
-	town.clientInfo.structures.emplace_back(ret);
-}
-
-void CTownHandler::loadStructures(CTown &town, const JsonNode & source) const
-{
-	for(const auto & node : source.Struct())
-	{
-		if (!node.second.isNull())
-			loadStructure(town, node.first, node.second);
-	}
-}
-
-void CTownHandler::loadTownHall(CTown &town, const JsonNode & source) const
-{
-	auto & dstSlots = town.clientInfo.hallSlots;
-	const auto & srcSlots = source.Vector();
-	dstSlots.resize(srcSlots.size());
-
-	for(size_t i=0; i<dstSlots.size(); i++)
-	{
-		auto & dstRow = dstSlots[i];
-		const auto & srcRow = srcSlots[i].Vector();
-		dstRow.resize(srcRow.size());
-
-		for(size_t j=0; j < dstRow.size(); j++)
-		{
-			auto & dstBox = dstRow[j];
-			const auto & srcBox = srcRow[j].Vector();
-			dstBox.resize(srcBox.size());
-
-			for(size_t k=0; k<dstBox.size(); k++)
-			{
-				auto & dst = dstBox[k];
-				const auto & src = srcBox[k];
-
-				VLC->identifiers()->requestIdentifier("building." + town.faction->getJsonKey(), src, [&](si32 identifier)
-				{
-					dst = BuildingID(identifier);
-				});
-			}
-		}
-	}
-}
-
-Point JsonToPoint(const JsonNode & node)
-{
-	if(!node.isStruct())
-		return Point::makeInvalid();
-
-	Point ret;
-	ret.x = static_cast<si32>(node["x"].Float());
-	ret.y = static_cast<si32>(node["y"].Float());
-	return ret;
-}
-
-void CTownHandler::loadSiegeScreen(CTown &town, const JsonNode & source) const
-{
-	town.clientInfo.siegePrefix = source["imagePrefix"].String();
-	town.clientInfo.towerIconSmall = source["towerIconSmall"].String();
-	town.clientInfo.towerIconLarge = source["towerIconLarge"].String();
-
-	VLC->identifiers()->requestIdentifier("creature", source["shooter"], [&town](si32 creature)
-	{
-		auto crId = CreatureID(creature);
-		if((*VLC->creh)[crId]->animation.missleFrameAngles.empty())
-			logMod->error("Mod '%s' error: Creature '%s' on the Archer's tower is not a shooter. Mod should be fixed. Siege will not work properly!"
-				, town.faction->getNameTranslated()
-				, (*VLC->creh)[crId]->getNameSingularTranslated());
-
-		town.clientInfo.siegeShooter = crId;
-	});
-
-	auto & pos = town.clientInfo.siegePositions;
-	pos.resize(21);
-
-	pos[8]  = JsonToPoint(source["towers"]["top"]["tower"]);
-	pos[17] = JsonToPoint(source["towers"]["top"]["battlement"]);
-	pos[20] = JsonToPoint(source["towers"]["top"]["creature"]);
-
-	pos[2]  = JsonToPoint(source["towers"]["keep"]["tower"]);
-	pos[15] = JsonToPoint(source["towers"]["keep"]["battlement"]);
-	pos[18] = JsonToPoint(source["towers"]["keep"]["creature"]);
-
-	pos[3]  = JsonToPoint(source["towers"]["bottom"]["tower"]);
-	pos[16] = JsonToPoint(source["towers"]["bottom"]["battlement"]);
-	pos[19] = JsonToPoint(source["towers"]["bottom"]["creature"]);
-
-	pos[9]  = JsonToPoint(source["gate"]["gate"]);
-	pos[10]  = JsonToPoint(source["gate"]["arch"]);
-
-	pos[7]  = JsonToPoint(source["walls"]["upper"]);
-	pos[6]  = JsonToPoint(source["walls"]["upperMid"]);
-	pos[5]  = JsonToPoint(source["walls"]["bottomMid"]);
-	pos[4]  = JsonToPoint(source["walls"]["bottom"]);
-
-	pos[13] = JsonToPoint(source["moat"]["moat"]);
-	pos[14] = JsonToPoint(source["moat"]["bank"]);
-
-	pos[11] = JsonToPoint(source["static"]["bottom"]);
-	pos[12] = JsonToPoint(source["static"]["top"]);
-	pos[1]  = JsonToPoint(source["static"]["background"]);
-}
-
-static void readIcon(JsonNode source, std::string & small, std::string & large)
-{
-	if (source.getType() == JsonNode::JsonType::DATA_STRUCT) // don't crash on old format
-	{
-		small = source["small"].String();
-		large = source["large"].String();
-	}
-}
-
-void CTownHandler::loadClientData(CTown &town, const JsonNode & source) const
-{
-	CTown::ClientInfo & info = town.clientInfo;
-
-	readIcon(source["icons"]["village"]["normal"], info.iconSmall[0][0], info.iconLarge[0][0]);
-	readIcon(source["icons"]["village"]["built"], info.iconSmall[0][1], info.iconLarge[0][1]);
-	readIcon(source["icons"]["fort"]["normal"], info.iconSmall[1][0], info.iconLarge[1][0]);
-	readIcon(source["icons"]["fort"]["built"], info.iconSmall[1][1], info.iconLarge[1][1]);
-
-	info.hallBackground = ImagePath::fromJson(source["hallBackground"]);
-	info.musicTheme = AudioPath::fromJson(source["musicTheme"]);
-	info.townBackground = ImagePath::fromJson(source["townBackground"]);
-	info.guildWindow = ImagePath::fromJson(source["guildWindow"]);
-	info.buildingsIcons = AnimationPath::fromJson(source["buildingsIcons"]);
-
-	info.guildBackground = ImagePath::fromJson(source["guildBackground"]);
-	info.tavernVideo = VideoPath::fromJson(source["tavernVideo"]);
-
-	loadTownHall(town,   source["hallSlots"]);
-	loadStructures(town, source["structures"]);
-	loadSiegeScreen(town, source["siege"]);
-}
-
-void CTownHandler::loadTown(CTown * town, const JsonNode & source)
-{
-	const auto * resIter = boost::find(GameConstants::RESOURCE_NAMES, source["primaryResource"].String());
-	if(resIter == std::end(GameConstants::RESOURCE_NAMES))
-		town->primaryRes = GameResID(EGameResID::WOOD_AND_ORE); //Wood + Ore
-	else
-		town->primaryRes = GameResID(resIter - std::begin(GameConstants::RESOURCE_NAMES));
-
-	warMachinesToLoad[town] = source["warMachine"];
-
-	town->mageLevel = static_cast<ui32>(source["mageGuild"].Float());
-
-	town->namesCount = 0;
-	for(const auto & name : source["names"].Vector())
-	{
-		VLC->generaltexth->registerString(town->faction->modScope, town->getRandomNameTextID(town->namesCount), name.String());
-		town->namesCount += 1;
-	}
-
-	if (!source["moatAbility"].isNull()) // VCMI 1.2 compatibility code
-	{
-		VLC->identifiers()->requestIdentifier( "spell", source["moatAbility"], [=](si32 ability)
-		{
-			town->moatAbility = SpellID(ability);
-		});
-	}
-	else
-	{
-		VLC->identifiers()->requestIdentifier( source.getModScope(), "spell", "castleMoat", [=](si32 ability)
-		{
-			town->moatAbility = SpellID(ability);
-		});
-	}
-
-	//  Horde building creature level
-	for(const JsonNode &node : source["horde"].Vector())
-		town->hordeLvl[static_cast<int>(town->hordeLvl.size())] = static_cast<int>(node.Float());
-
-	// town needs to have exactly 2 horde entries. Validation will take care of 2+ entries
-	// but anything below 2 must be handled here
-	for (size_t i=source["horde"].Vector().size(); i<2; i++)
-		town->hordeLvl[static_cast<int>(i)] = -1;
-
-	const JsonVector & creatures = source["creatures"].Vector();
-
-	town->creatures.resize(creatures.size());
-
-	for (size_t i=0; i< creatures.size(); i++)
-	{
-		const JsonVector & level = creatures[i].Vector();
-
-		town->creatures[i].resize(level.size());
-
-		for (size_t j=0; j<level.size(); j++)
-		{
-			VLC->identifiers()->requestIdentifier("creature", level[j], [=](si32 creature)
-			{
-				town->creatures[i][j] = CreatureID(creature);
-			});
-		}
-	}
-
-	town->defaultTavernChance = static_cast<ui32>(source["defaultTavern"].Float());
-	/// set chance of specific hero class to appear in this town
-	for(const auto & node : source["tavern"].Struct())
-	{
-		int chance = static_cast<int>(node.second.Float());
-
-		VLC->identifiers()->requestIdentifier(node.second.getModScope(), "heroClass",node.first, [=](si32 classID)
-		{
-			VLC->heroclassesh->objects[classID]->selectionProbability[town->faction->getId()] = chance;
-		});
-	}
-
-	for(const auto & node : source["guildSpells"].Struct())
-	{
-		int chance = static_cast<int>(node.second.Float());
-
-		VLC->identifiers()->requestIdentifier(node.second.getModScope(), "spell", node.first, [=](si32 spellID)
-		{
-			VLC->spellh->objects.at(spellID)->probabilities[town->faction->getId()] = chance;
-		});
-	}
-
-	for(const JsonNode & d : source["adventureMap"]["dwellings"].Vector())
-	{
-		town->dwellings.push_back(d["graphics"].String());
-		town->dwellingNames.push_back(d["name"].String());
-	}
-
-	loadBuildings(town, source["buildings"]);
-	loadClientData(*town, source);
-}
-
-void CTownHandler::loadPuzzle(CFaction &faction, const JsonNode &source) const
-{
-	faction.puzzleMap.reserve(GameConstants::PUZZLE_MAP_PIECES);
-
-	std::string prefix = source["prefix"].String();
-	for(const JsonNode &piece : source["pieces"].Vector())
-	{
-		size_t index = faction.puzzleMap.size();
-		SPuzzleInfo spi;
-
-		spi.x = static_cast<si16>(piece["x"].Float());
-		spi.y = static_cast<si16>(piece["y"].Float());
-		spi.whenUncovered = static_cast<ui16>(piece["index"].Float());
-		spi.number = static_cast<ui16>(index);
-
-		// filename calculation
-		std::ostringstream suffix;
-		suffix << std::setfill('0') << std::setw(2) << index;
-
-		spi.filename = ImagePath::builtinTODO(prefix + suffix.str());
-
-		faction.puzzleMap.push_back(spi);
-	}
-	assert(faction.puzzleMap.size() == GameConstants::PUZZLE_MAP_PIECES);
-}
-
-CFaction * CTownHandler::loadFromJson(const std::string & scope, const JsonNode & source, const std::string & identifier, size_t index)
-{
-	assert(identifier.find(':') == std::string::npos);
-
-	auto * faction = new CFaction();
-
-	faction->index = static_cast<FactionID>(index);
-	faction->modScope = scope;
-	faction->identifier = identifier;
-
-	VLC->generaltexth->registerString(scope, faction->getNameTextID(), source["name"].String());
-	VLC->generaltexth->registerString(scope, faction->getDescriptionTranslated(), source["description"].String());
-
-	faction->creatureBg120 = ImagePath::fromJson(source["creatureBackground"]["120px"]);
-	faction->creatureBg130 = ImagePath::fromJson(source["creatureBackground"]["130px"]);
-
-	faction->boatType = BoatId::CASTLE; //Do not crash
-	if (!source["boat"].isNull())
-	{
-		VLC->identifiers()->requestIdentifier("core:boat", source["boat"], [=](int32_t boatTypeID)
-		{
-			faction->boatType = BoatId(boatTypeID);
-		});
-	}
-
-	int alignment = vstd::find_pos(GameConstants::ALIGNMENT_NAMES, source["alignment"].String());
-	if (alignment == -1)
-		faction->alignment = EAlignment::NEUTRAL;
-	else
-		faction->alignment = static_cast<EAlignment>(alignment);
-	
-	auto preferUndergound = source["preferUndergroundPlacement"];
-	faction->preferUndergroundPlacement = preferUndergound.isNull() ? false : preferUndergound.Bool();
-	faction->special = source["special"].Bool();
-
-	// NOTE: semi-workaround - normally, towns are supposed to have native terrains.
-	// Towns without one are exceptions. So, vcmi requires nativeTerrain to be defined
-	// But allows it to be defined with explicit value of "none" if town should not have native terrain
-	// This is better than allowing such terrain-less towns silently, leading to issues with RMG
-	faction->nativeTerrain = ETerrainId::NONE;
-	if ( !source["nativeTerrain"].isNull() && source["nativeTerrain"].String() != "none")
-	{
-		VLC->identifiers()->requestIdentifier("terrain", source["nativeTerrain"], [=](int32_t index){
-			faction->nativeTerrain = TerrainId(index);
-
-			auto const & terrain = VLC->terrainTypeHandler->getById(faction->nativeTerrain);
-
-			if (!terrain->isSurface() && !terrain->isUnderground())
-				logMod->warn("Faction %s has terrain %s as native, but terrain is not suitable for either surface or subterranean layers!", faction->getJsonKey(), terrain->getJsonKey());
-		});
-	}
-
-	if (!source["town"].isNull())
-	{
-		faction->town = new CTown();
-		faction->town->faction = faction;
-		loadTown(faction->town, source["town"]);
-	}
-	else
-		faction->town = nullptr;
-
-	if (!source["puzzleMap"].isNull())
-		loadPuzzle(*faction, source["puzzleMap"]);
-
-	return faction;
-}
-
-void CTownHandler::loadObject(std::string scope, std::string name, const JsonNode & data)
-{
-	auto * object = loadFromJson(scope, data, name, objects.size());
-
-	objects.emplace_back(object);
-
-	if (object->town)
-	{
-		auto & info = object->town->clientInfo;
-		info.icons[0][0] = 8 + object->index.getNum() * 4 + 0;
-		info.icons[0][1] = 8 + object->index.getNum() * 4 + 1;
-		info.icons[1][0] = 8 + object->index.getNum() * 4 + 2;
-		info.icons[1][1] = 8 + object->index.getNum() * 4 + 3;
-
-		VLC->identifiers()->requestIdentifier(scope, "object", "town", [=](si32 index)
-		{
-			// register town once objects are loaded
-			JsonNode config = data["town"]["mapObject"];
-			config["faction"].String() = name;
-			config["faction"].setModScope(scope, false);
-			if (config.getModScope().empty())// MODS COMPATIBILITY FOR 0.96
-				config.setModScope(scope, false);
-			VLC->objtypeh->loadSubObject(object->identifier, config, index, object->index);
-
-			// MODS COMPATIBILITY FOR 0.96
-			const auto & advMap = data["town"]["adventureMap"];
-			if (!advMap.isNull())
-			{
-				logMod->warn("Outdated town mod. Will try to generate valid templates out of fort");
-				JsonNode config;
-				config["animation"] = advMap["castle"];
-				VLC->objtypeh->getHandlerFor(index, object->index)->addTemplate(config);
-			}
-		});
-	}
-
-	registerObject(scope, "faction", name, object->index.getNum());
-}
-
-void CTownHandler::loadObject(std::string scope, std::string name, const JsonNode & data, size_t index)
-{
-	auto * object = loadFromJson(scope, data, name, index);
-
-	if (objects.size() > index)
-		assert(objects[index] == nullptr); // ensure that this id was not loaded before
-	else
-		objects.resize(index + 1);
-	objects[index] = object;
-
-	if (object->town)
-	{
-		auto & info = object->town->clientInfo;
-		info.icons[0][0] = (GameConstants::F_NUMBER + object->index.getNum()) * 2 + 0;
-		info.icons[0][1] = (GameConstants::F_NUMBER + object->index.getNum()) * 2 + 1;
-		info.icons[1][0] = object->index.getNum() * 2 + 0;
-		info.icons[1][1] = object->index.getNum() * 2 + 1;
-
-		VLC->identifiers()->requestIdentifier(scope, "object", "town", [=](si32 index)
-		{
-			// register town once objects are loaded
-			JsonNode config = data["town"]["mapObject"];
-			config["faction"].String() = name;
-			config["faction"].setModScope(scope, false);
-			VLC->objtypeh->loadSubObject(object->identifier, config, index, object->index);
-		});
-	}
-
-	registerObject(scope, "faction", name, object->index.getNum());
-}
-
-void CTownHandler::loadRandomFaction()
-{
-	JsonNode randomFactionJson(JsonPath::builtin("config/factions/random.json"));
-	randomFactionJson.setModScope(ModScope::scopeBuiltin(), true);
-	loadBuildings(randomTown, randomFactionJson["random"]["town"]["buildings"]);
-}
-
-void CTownHandler::loadCustom()
-{
-	loadRandomFaction();
-}
-
-void CTownHandler::afterLoadFinalization()
-{
-	initializeRequirements();
-	initializeOverridden();
-	initializeWarMachines();
-}
-
-void CTownHandler::initializeRequirements()
-{
-	// must be done separately after all ID's are known
-	for (auto & requirement : requirementsToLoad)
-	{
-		requirement.building->requirements = CBuilding::TRequired(requirement.json, [&](const JsonNode & node) -> BuildingID
-		{
-			if (node.Vector().size() > 1)
-			{
-				logMod->error("Unexpected length of town buildings requirements: %d", node.Vector().size());
-				logMod->error("Entry contains: ");
-				logMod->error(node.toString());
-			}
-
-			auto index = VLC->identifiers()->getIdentifier(requirement.town->getBuildingScope(), node[0]);
-
-			if (!index.has_value())
-			{
-				logMod->error("Unknown building in town buildings: %s", node[0].String());
-				return BuildingID::NONE;
-			}
-			return BuildingID(index.value());
-		});
-	}
-	requirementsToLoad.clear();
-}
-
-void CTownHandler::initializeOverridden()
-{
-	for(auto & bidHelper : overriddenBidsToLoad)
-	{
-		auto jsonNode = bidHelper.json;
-		auto scope = bidHelper.town->getBuildingScope();
-
-		for(const auto & b : jsonNode.Vector())
-		{
-			auto bid = BuildingID(VLC->identifiers()->getIdentifier(scope, b).value());
-			bidHelper.building->overrideBids.insert(bid);
-		}
-	}
-	overriddenBidsToLoad.clear();
-}
-
-void CTownHandler::initializeWarMachines()
-{
-	// must be done separately after all objects are loaded
-	for(auto & p : warMachinesToLoad)
-	{
-		CTown * t = p.first;
-		JsonNode creatureKey = p.second;
-
-		auto ret = VLC->identifiers()->getIdentifier("creature", creatureKey, false);
-
-		if(ret)
-		{
-			const CCreature * creature = CreatureID(*ret).toCreature();
-
-			t->warMachine = creature->warMachine;
-		}
-	}
-
-	warMachinesToLoad.clear();
-}
-
-std::set<FactionID> CTownHandler::getDefaultAllowed() const
-{
-	std::set<FactionID> allowedFactions;
-
-	for(auto town : objects)
-		if (town->town != nullptr && !town->special)
-			allowedFactions.insert(town->getId());
-
-	return allowedFactions;
-}
-
-std::set<FactionID> CTownHandler::getAllowedFactions(bool withTown) const
-{
-	if (withTown)
-		return getDefaultAllowed();
-
-	std::set<FactionID> result;
-	for(auto town : objects)
-		result.insert(town->getId());
-
-	return result;
-
-}
-
-const std::vector<std::string> & CTownHandler::getTypeNames() const
-{
-	static const std::vector<std::string> typeNames = { "faction", "town" };
-	return typeNames;
-}
-
-
-VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/CTownHandler.h vcmi/lib/CTownHandler.h
--- vcmi-1.5.7/lib/CTownHandler.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/CTownHandler.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,358 +0,0 @@
-/*
- * CTownHandler.h, part of VCMI engine
- *
- * Authors: listed in file AUTHORS in main folder
- *
- * License: GNU General Public License v2.0 or later
- * Full text of license available in license.txt file, in main folder
- *
- */
-#pragma once
-
-#include <vcmi/Faction.h>
-#include <vcmi/FactionService.h>
-
-#include "ConstTransitivePtr.h"
-#include "ResourceSet.h"
-#include "int3.h"
-#include "GameConstants.h"
-#include "IHandlerBase.h"
-#include "LogicalExpression.h"
-#include "battle/BattleHex.h"
-#include "bonuses/Bonus.h"
-#include "bonuses/BonusList.h"
-#include "Point.h"
-#include "rewardable/Info.h"
-#include "filesystem/ResourcePath.h"
-
-VCMI_LIB_NAMESPACE_BEGIN
-
-class CLegacyConfigParser;
-class JsonNode;
-class CTown;
-class CFaction;
-struct BattleHex;
-class JsonSerializeFormat;
-
-/// a typical building encountered in every castle ;]
-/// this is structure available to both client and server
-/// contains all mechanics-related data about town structures
-class DLL_LINKAGE CBuilding
-{
-	std::string modScope;
-	std::string identifier;
-
-public:
-	using TRequired = LogicalExpression<BuildingID>;
-
-	CTown * town; // town this building belongs to
-	TResources resources;
-	TResources produce;
-	TRequired requirements;
-
-	BuildingID bid; //structure ID
-	BuildingID upgrade; /// indicates that building "upgrade" can be improved by this, -1 = empty
-	BuildingSubID::EBuildingSubID subId; /// subtype for special buildings, -1 = the building is not special
-	std::set<BuildingID> overrideBids; /// the building which bonuses should be overridden with bonuses of the current building
-	BonusList buildingBonuses;
-	BonusList onVisitBonuses;
-	
-	Rewardable::Info rewardableObjectInfo; ///configurable rewards for special buildings
-
-	enum EBuildMode
-	{
-		BUILD_NORMAL,  // 0 - normal, default
-		BUILD_AUTO,    // 1 - auto - building appears when all requirements are built
-		BUILD_SPECIAL, // 2 - special - building can not be built normally
-		BUILD_GRAIL    // 3 - grail - building reqires grail to be built
-	} mode;
-
-	enum ETowerHeight // for lookup towers and some grails
-	{
-		HEIGHT_NO_TOWER = 5, // building has not 'lookout tower' ability
-		HEIGHT_LOW = 10,     // low lookout tower, but castle without lookout tower gives radius 5
-		HEIGHT_AVERAGE = 15,
-		HEIGHT_HIGH = 20,    // such tower is in the Tower town
-		HEIGHT_SKYSHIP = std::numeric_limits<int>::max()  // grail, open entire map
-	} height;
-
-	static const std::map<std::string, CBuilding::EBuildMode> MODES;
-	static const std::map<std::string, CBuilding::ETowerHeight> TOWER_TYPES;
-
-	CBuilding() : town(nullptr), mode(BUILD_NORMAL) {};
-
-	const BuildingTypeUniqueID getUniqueTypeID() const;
-
-	std::string getJsonKey() const;
-
-	std::string getNameTranslated() const;
-	std::string getDescriptionTranslated() const;
-
-	std::string getBaseTextID() const;
-	std::string getNameTextID() const;
-	std::string getDescriptionTextID() const;
-
-	//return base of upgrade(s) or this
-	BuildingID getBase() const;
-
-	// returns how many times build has to be upgraded to become build
-	si32 getDistance(const BuildingID & build) const;
-
-	STRONG_INLINE
-	bool IsTradeBuilding() const
-	{
-		return bid == BuildingID::MARKETPLACE || subId == BuildingSubID::ARTIFACT_MERCHANT || subId == BuildingSubID::FREELANCERS_GUILD;
-	}
-
-	STRONG_INLINE
-	bool IsWeekBonus() const
-	{
-		return subId == BuildingSubID::STABLES || subId == BuildingSubID::MANA_VORTEX;
-	}
-
-	STRONG_INLINE
-	bool IsVisitingBonus() const
-	{
-		return subId == BuildingSubID::ATTACK_VISITING_BONUS ||
-			subId == BuildingSubID::DEFENSE_VISITING_BONUS ||
-			subId == BuildingSubID::SPELL_POWER_VISITING_BONUS ||
-			subId == BuildingSubID::KNOWLEDGE_VISITING_BONUS ||
-			subId == BuildingSubID::EXPERIENCE_VISITING_BONUS ||
-			subId == BuildingSubID::CUSTOM_VISITING_BONUS;
-	}
-
-	void addNewBonus(const std::shared_ptr<Bonus> & b, BonusList & bonusList) const;
-
-	friend class CTownHandler;
-};
-
-/// This is structure used only by client
-/// Consists of all gui-related data about town structures
-/// Should be moved from lib to client
-struct DLL_LINKAGE CStructure
-{
-	CBuilding * building;  // base building. If null - this structure will be always present on screen
-	CBuilding * buildable; // building that will be used to determine built building and visible cost. Usually same as "building"
-
-	int3 pos;
-	AnimationPath defName;
-	ImagePath borderName;
-	ImagePath areaName;
-	std::string identifier;
-
-	bool hiddenUpgrade; // used only if "building" is upgrade, if true - structure on town screen will behave exactly like parent (mouse clicks, hover texts, etc)
-};
-
-struct DLL_LINKAGE SPuzzleInfo
-{
-	ui16 number; //type of puzzle
-	si16 x, y; //position
-	ui16 whenUncovered; //determines the sequnce of discovering (the lesser it is the sooner puzzle will be discovered)
-	ImagePath filename; //file with graphic of this puzzle
-};
-
-class DLL_LINKAGE CFaction : public Faction
-{
-	friend class CTownHandler;
-	friend class CBuilding;
-	friend class CTown;
-
-	std::string modScope;
-	std::string identifier;
-
-	FactionID index = FactionID::NEUTRAL;
-
-	FactionID getFaction() const override; //This function should not be used
-
-public:
-	TerrainId nativeTerrain;
-	EAlignment alignment = EAlignment::NEUTRAL;
-	bool preferUndergroundPlacement = false;
-	bool special = false;
-
-	/// Boat that will be used by town shipyard (if any)
-	/// and for placing heroes directly on boat (in map editor, water prisons & taverns)
-	BoatId boatType = BoatId::CASTLE;
-
-	CTown * town = nullptr; //NOTE: can be null
-
-	ImagePath creatureBg120;
-	ImagePath creatureBg130;
-
-	std::vector<SPuzzleInfo> puzzleMap;
-
-	CFaction() = default;
-	~CFaction();
-
-	int32_t getIndex() const override;
-	int32_t getIconIndex() const override;
-	std::string getJsonKey() const override;
-	void registerIcons(const IconRegistar & cb) const override;
-	FactionID getId() const override;
-
-	std::string getNameTranslated() const override;
-	std::string getNameTextID() const override;
-	std::string getDescriptionTranslated() const;
-	std::string getDescriptionTextID() const;
-
-	bool hasTown() const override;
-	TerrainId getNativeTerrain() const override;
-	EAlignment getAlignment() const override;
-	BoatId getBoatType() const override;
-
-	void updateFrom(const JsonNode & data);
-	void serializeJson(JsonSerializeFormat & handler);
-};
-
-class DLL_LINKAGE CTown
-{
-	friend class CTownHandler;
-	size_t namesCount = 0;
-
-public:
-	CTown();
-	~CTown();
-
-	std::string getBuildingScope() const;
-	std::set<si32> getAllBuildings() const;
-	const CBuilding * getSpecialBuilding(BuildingSubID::EBuildingSubID subID) const;
-	std::string getGreeting(BuildingSubID::EBuildingSubID subID) const;
-	void setGreeting(BuildingSubID::EBuildingSubID subID, const std::string & message) const; //may affect only mutable field
-	BuildingID getBuildingType(BuildingSubID::EBuildingSubID subID) const;
-
-	std::string getRandomNameTextID(size_t index) const;
-	size_t getRandomNamesCount() const;
-
-	CFaction * faction;
-
-	/// level -> list of creatures on this tier
-	// TODO: replace with pointers to CCreature
-	std::vector<std::vector<CreatureID> > creatures;
-
-	std::map<BuildingID, ConstTransitivePtr<CBuilding> > buildings;
-
-	std::vector<std::string> dwellings; //defs for adventure map dwellings for new towns, [0] means tier 1 creatures etc.
-	std::vector<std::string> dwellingNames;
-
-	// should be removed at least from configs in favor of auto-detection
-	std::map<int,int> hordeLvl; //[0] - first horde building creature level; [1] - second horde building (-1 if not present)
-	ui32 mageLevel; //max available mage guild level
-	GameResID primaryRes;
-	ArtifactID warMachine;
-	SpellID moatAbility;
-
-	// default chance for hero of specific class to appear in tavern, if field "tavern" was not set
-	// resulting chance = sqrt(town.chance * heroClass.chance)
-	ui32 defaultTavernChance;
-
-	// Client-only data. Should be moved away from lib
-	struct ClientInfo
-	{
-		//icons [fort is present?][build limit reached?] -> index of icon in def files
-		int icons[2][2];
-		std::string iconSmall[2][2]; /// icon names used during loading
-		std::string iconLarge[2][2];
-		VideoPath tavernVideo;
-		AudioPath musicTheme;
-		ImagePath townBackground;
-		ImagePath guildBackground;
-		ImagePath guildWindow;
-		AnimationPath buildingsIcons;
-		ImagePath hallBackground;
-		/// vector[row][column] = list of buildings in this slot
-		std::vector< std::vector< std::vector<BuildingID> > > hallSlots;
-
-		/// list of town screen structures.
-		/// NOTE: index in vector is meaningless. Vector used instead of list for a bit faster access
-		std::vector<ConstTransitivePtr<CStructure> > structures;
-
-		std::string siegePrefix;
-		std::vector<Point> siegePositions;
-		CreatureID siegeShooter; // shooter creature ID
-		std::string towerIconSmall;
-		std::string towerIconLarge;
-
-	} clientInfo;
-	
-private:
-	///generated bonusing buildings messages for all towns of this type.
-	mutable std::map<BuildingSubID::EBuildingSubID, const std::string> specialMessages; //may be changed by CGTownBuilding::getVisitingBonusGreeting() const
-};
-
-class DLL_LINKAGE CTownHandler : public CHandlerBase<FactionID, Faction, CFaction, FactionService>
-{
-	struct BuildingRequirementsHelper
-	{
-		JsonNode json;
-		CBuilding * building;
-		CTown * town;
-	};
-
-	std::map<CTown *, JsonNode> warMachinesToLoad;
-	std::vector<BuildingRequirementsHelper> requirementsToLoad;
-	std::vector<BuildingRequirementsHelper> overriddenBidsToLoad; //list of buildings, which bonuses should be overridden.
-
-	static const TPropagatorPtr & emptyPropagator();
-
-	void initializeRequirements();
-	void initializeOverridden();
-	void initializeWarMachines();
-
-	/// loads CBuilding's into town
-	void loadBuildingRequirements(CBuilding * building, const JsonNode & source, std::vector<BuildingRequirementsHelper> & bidsToLoad) const;
-	void loadBuilding(CTown * town, const std::string & stringID, const JsonNode & source);
-	void loadBuildings(CTown * town, const JsonNode & source);
-
-	std::shared_ptr<Bonus> createBonus(CBuilding * build, BonusType type, int val) const;
-	std::shared_ptr<Bonus> createBonus(CBuilding * build, BonusType type, int val, BonusSubtypeID subtype) const;
-	std::shared_ptr<Bonus> createBonus(CBuilding * build, BonusType type, int val, BonusSubtypeID subtype, const TPropagatorPtr & prop) const;
-
-	/// loads CStructure's into town
-	void loadStructure(CTown & town, const std::string & stringID, const JsonNode & source) const;
-	void loadStructures(CTown & town, const JsonNode & source) const;
-
-	/// loads town hall vector (hallSlots)
-	void loadTownHall(CTown & town, const JsonNode & source) const;
-	void loadSiegeScreen(CTown & town, const JsonNode & source) const;
-
-	void loadClientData(CTown & town, const JsonNode & source) const;
-
-	void loadTown(CTown * town, const JsonNode & source);
-
-	void loadPuzzle(CFaction & faction, const JsonNode & source) const;
-
-	void loadRandomFaction();
-
-
-public:
-	template<typename R, typename K>
-	static R getMappedValue(const K key, const R defval, const std::map<K, R> & map, bool required = true);
-	template<typename R>
-	static R getMappedValue(const JsonNode & node, const R defval, const std::map<std::string, R> & map, bool required = true);
-
-	CTown * randomTown;
-	CFaction * randomFaction;
-
-	CTownHandler();
-	~CTownHandler();
-
-	std::vector<JsonNode> loadLegacyData() override;
-
-	void loadObject(std::string scope, std::string name, const JsonNode & data) override;
-	void loadObject(std::string scope, std::string name, const JsonNode & data, size_t index) override;
-	void addBonusesForVanilaBuilding(CBuilding * building) const;
-
-	void loadCustom() override;
-	void afterLoadFinalization() override;
-
-	std::set<FactionID> getDefaultAllowed() const;
-	std::set<FactionID> getAllowedFactions(bool withTown = true) const;
-
-	static void loadSpecialBuildingBonuses(const JsonNode & source, BonusList & bonusList, CBuilding * building);
-
-protected:
-	const std::vector<std::string> & getTypeNames() const override;
-	CFaction * loadFromJson(const std::string & scope, const JsonNode & data, const std::string & identifier, size_t index) override;
-};
-
-VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/entities/building/CBuilding.cpp vcmi/lib/entities/building/CBuilding.cpp
--- vcmi-1.5.7/lib/entities/building/CBuilding.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/entities/building/CBuilding.cpp	2024-12-19 15:00:22.897147896 +0100
@@ -0,0 +1,101 @@
+/*
+ * CBuilding.cpp, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#include "StdInc.h"
+#include "CBuilding.h"
+
+#include "../../VCMI_Lib.h"
+#include "../../texts/CGeneralTextHandler.h"
+#include "../faction/CFaction.h"
+#include "../faction/CTown.h"
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+const std::map<std::string, CBuilding::EBuildMode> CBuilding::MODES =
+	{
+		{ "normal", CBuilding::BUILD_NORMAL },
+		{ "auto", CBuilding::BUILD_AUTO },
+		{ "special", CBuilding::BUILD_SPECIAL },
+		{ "grail", CBuilding::BUILD_GRAIL }
+};
+
+const std::map<std::string, CBuilding::ETowerHeight> CBuilding::TOWER_TYPES =
+	{
+		{ "low", CBuilding::HEIGHT_LOW },
+		{ "average", CBuilding::HEIGHT_AVERAGE },
+		{ "high", CBuilding::HEIGHT_HIGH },
+		{ "skyship", CBuilding::HEIGHT_SKYSHIP }
+};
+
+BuildingTypeUniqueID CBuilding::getUniqueTypeID() const
+{
+	return BuildingTypeUniqueID(town->faction->getId(), bid);
+}
+
+std::string CBuilding::getJsonKey() const
+{
+	return modScope + ':' + identifier;
+}
+
+std::string CBuilding::getNameTranslated() const
+{
+	return VLC->generaltexth->translate(getNameTextID());
+}
+
+std::string CBuilding::getDescriptionTranslated() const
+{
+	return VLC->generaltexth->translate(getDescriptionTextID());
+}
+
+std::string CBuilding::getBaseTextID() const
+{
+	return TextIdentifier("building", modScope, town->faction->identifier, identifier).get();
+}
+
+std::string CBuilding::getNameTextID() const
+{
+	return TextIdentifier(getBaseTextID(), "name").get();
+}
+
+std::string CBuilding::getDescriptionTextID() const
+{
+	return TextIdentifier(getBaseTextID(), "description").get();
+}
+
+BuildingID CBuilding::getBase() const
+{
+	const CBuilding * build = this;
+	while (build->upgrade != BuildingID::NONE)
+	{
+		build = build->town->buildings.at(build->upgrade);
+	}
+
+	return build->bid;
+}
+
+si32 CBuilding::getDistance(const BuildingID & buildID) const
+{
+	const CBuilding * build = town->buildings.at(buildID);
+	int distance = 0;
+	while (build->upgrade != BuildingID::NONE && build != this)
+	{
+		build = build->town->buildings.at(build->upgrade);
+		distance++;
+	}
+	if (build == this)
+		return distance;
+	return -1;
+}
+
+void CBuilding::addNewBonus(const std::shared_ptr<Bonus> & b, BonusList & bonusList) const
+{
+	bonusList.push_back(b);
+}
+
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/entities/building/CBuilding.h vcmi/lib/entities/building/CBuilding.h
--- vcmi-1.5.7/lib/entities/building/CBuilding.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/entities/building/CBuilding.h	2024-12-19 15:00:22.897147896 +0100
@@ -0,0 +1,102 @@
+/*
+ * CBuilding.h, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#pragma once
+
+#include "TownFortifications.h"
+
+#include "../../constants/EntityIdentifiers.h"
+#include "../../LogicalExpression.h"
+#include "../../ResourceSet.h"
+#include "../../bonuses/BonusList.h"
+#include "../../rewardable/Info.h"
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+class CTown;
+
+/// a typical building encountered in every castle ;]
+/// this is structure available to both client and server
+/// contains all mechanics-related data about town structures
+class DLL_LINKAGE CBuilding
+{
+	std::string modScope;
+	std::string identifier;
+
+public:
+	using TRequired = LogicalExpression<BuildingID>;
+
+	CTown * town; // town this building belongs to
+	TResources resources;
+	TResources produce;
+	TRequired requirements;
+	ArtifactID warMachine;
+	TownFortifications fortifications;
+	std::set<EMarketMode> marketModes;
+
+	BuildingID bid; //structure ID
+	BuildingID upgrade; /// indicates that building "upgrade" can be improved by this, -1 = empty
+	BuildingSubID::EBuildingSubID subId; /// subtype for special buildings, -1 = the building is not special
+	bool upgradeReplacesBonuses = false;
+	bool manualHeroVisit = false;
+	BonusList buildingBonuses;
+
+	Rewardable::Info rewardableObjectInfo; ///configurable rewards for special buildings
+
+	enum EBuildMode
+	{
+		BUILD_NORMAL,  // 0 - normal, default
+		BUILD_AUTO,    // 1 - auto - building appears when all requirements are built
+		BUILD_SPECIAL, // 2 - special - building can not be built normally
+		BUILD_GRAIL    // 3 - grail - building requires grail to be built
+	} mode;
+
+	enum ETowerHeight // for lookup towers and some grails
+	{
+		HEIGHT_NO_TOWER = 5, // building has not 'lookout tower' ability
+		HEIGHT_LOW = 10,     // low lookout tower, but castle without lookout tower gives radius 5
+		HEIGHT_AVERAGE = 15,
+		HEIGHT_HIGH = 20,    // such tower is in the Tower town
+		HEIGHT_SKYSHIP = std::numeric_limits<int>::max()  // grail, open entire map
+	} height;
+
+	static const std::map<std::string, CBuilding::EBuildMode> MODES;
+	static const std::map<std::string, CBuilding::ETowerHeight> TOWER_TYPES;
+
+	CBuilding() : town(nullptr), mode(BUILD_NORMAL) {};
+
+	BuildingTypeUniqueID getUniqueTypeID() const;
+
+	std::string getJsonKey() const;
+
+	std::string getNameTranslated() const;
+	std::string getDescriptionTranslated() const;
+
+	std::string getBaseTextID() const;
+	std::string getNameTextID() const;
+	std::string getDescriptionTextID() const;
+
+	//return base of upgrade(s) or this
+	BuildingID getBase() const;
+
+	// returns how many times build has to be upgraded to become build
+	si32 getDistance(const BuildingID & build) const;
+
+	STRONG_INLINE
+		bool IsTradeBuilding() const
+	{
+		return !marketModes.empty();
+	}
+
+	void addNewBonus(const std::shared_ptr<Bonus> & b, BonusList & bonusList) const;
+
+	friend class CTownHandler;
+};
+
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/entities/building/CBuildingHandler.cpp vcmi/lib/entities/building/CBuildingHandler.cpp
--- vcmi-1.5.7/lib/entities/building/CBuildingHandler.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/entities/building/CBuildingHandler.cpp	2024-12-19 15:00:22.897147896 +0100
@@ -0,0 +1,87 @@
+/*
+ * CBuildingHandler.cpp, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#include "StdInc.h"
+#include "CBuildingHandler.h"
+#include "VCMI_Lib.h"
+#include "../faction/CTown.h"
+#include "../faction/CTownHandler.h"
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+BuildingID CBuildingHandler::campToERMU(int camp, FactionID townType, const std::set<BuildingID> & builtBuildings)
+{
+	static const std::vector<BuildingID> campToERMU = 
+	{
+		BuildingID::TOWN_HALL, BuildingID::CITY_HALL,
+		BuildingID::CAPITOL, BuildingID::FORT, BuildingID::CITADEL, BuildingID::CASTLE, BuildingID::TAVERN,
+		BuildingID::BLACKSMITH, BuildingID::MARKETPLACE, BuildingID::RESOURCE_SILO, BuildingID::NONE,
+		BuildingID::MAGES_GUILD_1, BuildingID::MAGES_GUILD_2, BuildingID::MAGES_GUILD_3, BuildingID::MAGES_GUILD_4,
+		BuildingID::MAGES_GUILD_5,
+		BuildingID::SHIPYARD, BuildingID::GRAIL,
+		BuildingID::SPECIAL_1, BuildingID::SPECIAL_2, BuildingID::SPECIAL_3, BuildingID::SPECIAL_4	
+	}; //creature generators with banks - handled separately
+	
+	if (camp < campToERMU.size())
+	{
+		return campToERMU[camp];
+	}
+
+	static const std::vector<int> hordeLvlsPerTType[GameConstants::F_NUMBER] = 
+	{
+		{2}, {1}, {1,4}, {0,2},	{0}, {0}, {0}, {0}, {0}
+	};
+
+	int curPos = static_cast<int>(campToERMU.size());
+	for (int i=0; i<(*VLC->townh)[townType]->town->creatures.size(); ++i)
+	{
+		if(camp == curPos) //non-upgraded
+			return BuildingID(30 + i);
+		curPos++;
+		if(camp == curPos) //upgraded
+			return BuildingID(37 + i);
+		curPos++;
+
+		if (i < 5) // last two levels don't have reserved horde ID. Yet another H3C weirdeness
+		{
+			if (vstd::contains(hordeLvlsPerTType[townType.getNum()], i))
+			{
+				if (camp == curPos)
+				{
+					if (hordeLvlsPerTType[townType.getNum()][0] == i)
+					{
+						BuildingID dwellingID(BuildingID::getDwellingFromLevel(hordeLvlsPerTType[townType.getNum()][0], 1));
+
+						if(vstd::contains(builtBuildings, dwellingID)) //if upgraded dwelling is built
+							return BuildingID::HORDE_1_UPGR;
+						else //upgraded dwelling not presents
+							return BuildingID::HORDE_1;
+					}
+					else
+					{
+						if(hordeLvlsPerTType[townType.getNum()].size() > 1)
+						{
+							BuildingID dwellingID(BuildingID::getDwellingFromLevel(hordeLvlsPerTType[townType.getNum()][1], 1));
+
+							if(vstd::contains(builtBuildings, dwellingID)) //if upgraded dwelling is built
+								return BuildingID::HORDE_2_UPGR;
+							else //upgraded dwelling not presents
+								return BuildingID::HORDE_2;
+						}
+					}
+				}
+			}
+			curPos++;
+		}
+	}
+	assert(0);
+	return BuildingID::NONE; //not found
+}
+
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/entities/building/CBuildingHandler.h vcmi/lib/entities/building/CBuildingHandler.h
--- vcmi-1.5.7/lib/entities/building/CBuildingHandler.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/entities/building/CBuildingHandler.h	2024-12-19 15:00:22.897147896 +0100
@@ -0,0 +1,22 @@
+/*
+ * CBuildingHandler.h, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#pragma once
+
+#include "../../constants/EntityIdentifiers.h"
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+class DLL_LINKAGE CBuildingHandler
+{
+public:
+	static BuildingID campToERMU(int camp, FactionID townType, const std::set<BuildingID> & builtBuildings);
+};
+
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/entities/building/TownFortifications.h vcmi/lib/entities/building/TownFortifications.h
--- vcmi-1.5.7/lib/entities/building/TownFortifications.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/entities/building/TownFortifications.h	2024-12-19 15:00:22.898147938 +0100
@@ -0,0 +1,49 @@
+/*
+ * TownFortifications.h, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#pragma once
+
+#include "../../constants/EntityIdentifiers.h"
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+struct TownFortifications
+{
+	CreatureID citadelShooter;
+	CreatureID upperTowerShooter;
+	CreatureID lowerTowerShooter;
+	SpellID moatSpell;
+
+	int8_t wallsHealth = 0;
+	int8_t citadelHealth = 0;
+	int8_t upperTowerHealth = 0;
+	int8_t lowerTowerHealth = 0;
+	bool hasMoat = false;
+
+	const TownFortifications & operator +=(const TownFortifications & other)
+	{
+		if (other.citadelShooter.hasValue())
+			citadelShooter = other.citadelShooter;
+		if (other.upperTowerShooter.hasValue())
+			upperTowerShooter = other.upperTowerShooter;
+		if (other.lowerTowerShooter.hasValue())
+			lowerTowerShooter = other.lowerTowerShooter;
+		if (other.moatSpell.hasValue())
+			moatSpell = other.moatSpell;
+
+		wallsHealth = std::max(wallsHealth, other.wallsHealth);
+		citadelHealth = std::max(citadelHealth, other.citadelHealth);
+		upperTowerHealth = std::max(upperTowerHealth, other.upperTowerHealth);
+		lowerTowerHealth = std::max(lowerTowerHealth, other.lowerTowerHealth);
+		hasMoat = hasMoat || other.hasMoat;
+		return *this;
+	}
+};
+
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/entities/faction/CFaction.cpp vcmi/lib/entities/faction/CFaction.cpp
--- vcmi-1.5.7/lib/entities/faction/CFaction.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/entities/faction/CFaction.cpp	2024-12-19 15:00:22.898147938 +0100
@@ -0,0 +1,130 @@
+/*
+ * CFaction.cpp, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#include "StdInc.h"
+#include "CFaction.h"
+
+#include "CTown.h"
+
+#include "../../VCMI_Lib.h"
+#include "../../texts/CGeneralTextHandler.h"
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+CFaction::~CFaction()
+{
+	if (town)
+	{
+		delete town;
+		town = nullptr;
+	}
+}
+
+int32_t CFaction::getIndex() const
+{
+	return index.getNum();
+}
+
+int32_t CFaction::getIconIndex() const
+{
+	return index.getNum(); //???
+}
+
+std::string CFaction::getJsonKey() const
+{
+	return modScope + ':' + identifier;
+}
+
+std::string CFaction::getModScope() const
+{
+	return modScope;
+}
+
+void CFaction::registerIcons(const IconRegistar & cb) const
+{
+	if(town)
+	{
+		auto & info = town->clientInfo;
+		cb(info.icons[0][0], 0, "ITPT", info.iconLarge[0][0]);
+		cb(info.icons[0][1], 0, "ITPT", info.iconLarge[0][1]);
+		cb(info.icons[1][0], 0, "ITPT", info.iconLarge[1][0]);
+		cb(info.icons[1][1], 0, "ITPT", info.iconLarge[1][1]);
+
+		cb(info.icons[0][0] + 2, 0, "ITPA", info.iconSmall[0][0]);
+		cb(info.icons[0][1] + 2, 0, "ITPA", info.iconSmall[0][1]);
+		cb(info.icons[1][0] + 2, 0, "ITPA", info.iconSmall[1][0]);
+		cb(info.icons[1][1] + 2, 0, "ITPA", info.iconSmall[1][1]);
+
+		cb(index.getNum(), 1, "CPRSMALL", info.towerIconSmall);
+		cb(index.getNum(), 1, "TWCRPORT", info.towerIconLarge);
+
+	}
+}
+
+std::string CFaction::getNameTranslated() const
+{
+	return VLC->generaltexth->translate(getNameTextID());
+}
+
+std::string CFaction::getNameTextID() const
+{
+	return TextIdentifier("faction", modScope, identifier, "name").get();
+}
+
+std::string CFaction::getDescriptionTranslated() const
+{
+	return VLC->generaltexth->translate(getDescriptionTextID());
+}
+
+std::string CFaction::getDescriptionTextID() const
+{
+	return TextIdentifier("faction", modScope, identifier, "description").get();
+}
+
+FactionID CFaction::getId() const
+{
+	return FactionID(index);
+}
+
+FactionID CFaction::getFactionID() const
+{
+	return FactionID(index);
+}
+
+bool CFaction::hasTown() const
+{
+	return town != nullptr;
+}
+
+EAlignment CFaction::getAlignment() const
+{
+	return alignment;
+}
+
+BoatId CFaction::getBoatType() const
+{
+	return boatType;
+}
+
+TerrainId CFaction::getNativeTerrain() const
+{
+	return nativeTerrain;
+}
+
+void CFaction::updateFrom(const JsonNode & data)
+{
+
+}
+
+void CFaction::serializeJson(JsonSerializeFormat & handler)
+{
+
+}
+
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/entities/faction/CFaction.h vcmi/lib/entities/faction/CFaction.h
--- vcmi-1.5.7/lib/entities/faction/CFaction.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/entities/faction/CFaction.h	2024-12-19 15:00:22.898147938 +0100
@@ -0,0 +1,85 @@
+/*
+ * CFaction.h, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#pragma once
+
+#include <vcmi/Faction.h>
+
+#include "../../Point.h"
+#include "../../constants/EntityIdentifiers.h"
+#include "../../constants/Enumerations.h"
+#include "../../filesystem/ResourcePath.h"
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+class CTown;
+
+struct DLL_LINKAGE SPuzzleInfo
+{
+	Point position;
+	ui16 number; //type of puzzle
+	ui16 whenUncovered; //determines the sequence of discovering (the lesser it is the sooner puzzle will be discovered)
+	ImagePath filename; //file with graphic of this puzzle
+};
+
+class DLL_LINKAGE CFaction : public Faction
+{
+	friend class CTownHandler;
+	friend class CBuilding;
+	friend class CTown;
+
+	std::string modScope;
+	std::string identifier;
+
+	FactionID index = FactionID::NEUTRAL;
+
+	FactionID getFactionID() const override; //This function should not be used
+
+public:
+	TerrainId nativeTerrain;
+	EAlignment alignment = EAlignment::NEUTRAL;
+	bool preferUndergroundPlacement = false;
+	bool special = false;
+
+	/// Boat that will be used by town shipyard (if any)
+	/// and for placing heroes directly on boat (in map editor, water prisons & taverns)
+	BoatId boatType = BoatId::CASTLE;
+
+	CTown * town = nullptr; //NOTE: can be null
+
+	ImagePath creatureBg120;
+	ImagePath creatureBg130;
+
+	std::vector<SPuzzleInfo> puzzleMap;
+
+	CFaction() = default;
+	~CFaction();
+
+	int32_t getIndex() const override;
+	int32_t getIconIndex() const override;
+	std::string getJsonKey() const override;
+	std::string getModScope() const override;
+	void registerIcons(const IconRegistar & cb) const override;
+	FactionID getId() const override;
+
+	std::string getNameTranslated() const override;
+	std::string getNameTextID() const override;
+	std::string getDescriptionTranslated() const;
+	std::string getDescriptionTextID() const;
+
+	bool hasTown() const override;
+	TerrainId getNativeTerrain() const override;
+	EAlignment getAlignment() const override;
+	BoatId getBoatType() const override;
+
+	void updateFrom(const JsonNode & data);
+	void serializeJson(JsonSerializeFormat & handler);
+};
+
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/entities/faction/CTown.cpp vcmi/lib/entities/faction/CTown.cpp
--- vcmi-1.5.7/lib/entities/faction/CTown.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/entities/faction/CTown.cpp	2024-12-19 15:00:22.898147938 +0100
@@ -0,0 +1,81 @@
+/*
+ * CTownHandler.cpp, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#include "StdInc.h"
+#include "CTown.h"
+
+#include "CFaction.h"
+#include "CTownHandler.h"
+#include "../building/CBuilding.h"
+#include "../../texts/TextIdentifier.h"
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+CTown::CTown()
+	: faction(nullptr), mageLevel(0), primaryRes(0), defaultTavernChance(0)
+{
+}
+
+CTown::~CTown()
+{
+	for(auto & build : buildings)
+		build.second.dellNull();
+
+	for(auto & str : clientInfo.structures)
+		str.dellNull();
+}
+
+std::string CTown::getRandomNameTextID(size_t index) const
+{
+	return TextIdentifier("faction", faction->modScope, faction->identifier, "randomName", index).get();
+}
+
+size_t CTown::getRandomNamesCount() const
+{
+	return namesCount;
+}
+
+std::string CTown::getBuildingScope() const
+{
+	if(faction == nullptr)
+		//no faction == random faction
+		return "building";
+	else
+		return "building." + faction->getJsonKey();
+}
+
+std::set<si32> CTown::getAllBuildings() const
+{
+	std::set<si32> res;
+
+	for(const auto & b : buildings)
+	{
+		res.insert(b.first.num);
+	}
+
+	return res;
+}
+
+const CBuilding * CTown::getSpecialBuilding(BuildingSubID::EBuildingSubID subID) const
+{
+	for(const auto & kvp : buildings)
+	{
+		if(kvp.second->subId == subID)
+			return buildings.at(kvp.first);
+	}
+	return nullptr;
+}
+
+BuildingID CTown::getBuildingType(BuildingSubID::EBuildingSubID subID) const
+{
+	const auto * building = getSpecialBuilding(subID);
+	return building == nullptr ? BuildingID::NONE : building->bid.num;
+}
+
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/entities/faction/CTown.h vcmi/lib/entities/faction/CTown.h
--- vcmi-1.5.7/lib/entities/faction/CTown.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/entities/faction/CTown.h	2024-12-19 15:00:22.898147938 +0100
@@ -0,0 +1,112 @@
+/*
+ * CTown.h, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#pragma once
+
+#include "../building/TownFortifications.h"
+#include "../../ConstTransitivePtr.h"
+#include "../../Point.h"
+#include "../../constants/EntityIdentifiers.h"
+#include "../../constants/Enumerations.h"
+#include "../../filesystem/ResourcePath.h"
+#include "../../int3.h"
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+class CBuilding;
+
+/// This is structure used only by client
+/// Consists of all gui-related data about town structures
+/// Should be moved from lib to client
+struct DLL_LINKAGE CStructure
+{
+	CBuilding * building;  // base building. If null - this structure will be always present on screen
+	CBuilding * buildable; // building that will be used to determine built building and visible cost. Usually same as "building"
+
+	int3 pos;
+	AnimationPath defName;
+	ImagePath borderName;
+	ImagePath areaName;
+	std::string identifier;
+
+	bool hiddenUpgrade; // used only if "building" is upgrade, if true - structure on town screen will behave exactly like parent (mouse clicks, hover texts, etc)
+};
+
+class DLL_LINKAGE CTown
+{
+	friend class CTownHandler;
+	size_t namesCount = 0;
+
+public:
+	CTown();
+	~CTown();
+
+	std::string getBuildingScope() const;
+	std::set<si32> getAllBuildings() const;
+	const CBuilding * getSpecialBuilding(BuildingSubID::EBuildingSubID subID) const;
+	BuildingID getBuildingType(BuildingSubID::EBuildingSubID subID) const;
+
+	std::string getRandomNameTextID(size_t index) const;
+	size_t getRandomNamesCount() const;
+
+	CFaction * faction;
+
+	/// level -> list of creatures on this tier
+	// TODO: replace with pointers to CCreature
+	std::vector<std::vector<CreatureID> > creatures;
+
+	std::map<BuildingID, ConstTransitivePtr<CBuilding> > buildings;
+
+	std::vector<std::string> dwellings; //defs for adventure map dwellings for new towns, [0] means tier 1 creatures etc.
+	std::vector<std::string> dwellingNames;
+
+	// should be removed at least from configs in favor of auto-detection
+	std::map<int,int> hordeLvl; //[0] - first horde building creature level; [1] - second horde building (-1 if not present)
+	ui32 mageLevel; //max available mage guild level
+	GameResID primaryRes;
+	CreatureID warMachineDeprecated;
+
+	/// Base state of fortifications for empty town.
+	/// Used to define shooter units and moat spell ID
+	TownFortifications fortifications;
+
+	// default chance for hero of specific class to appear in tavern, if field "tavern" was not set
+	// resulting chance = sqrt(town.chance * heroClass.chance)
+	ui32 defaultTavernChance;
+
+	// Client-only data. Should be moved away from lib
+	struct ClientInfo
+	{
+		//icons [fort is present?][build limit reached?] -> index of icon in def files
+		int icons[2][2];
+		std::string iconSmall[2][2]; /// icon names used during loading
+		std::string iconLarge[2][2];
+		VideoPath tavernVideo;
+		std::vector<AudioPath> musicTheme;
+		ImagePath townBackground;
+		ImagePath guildBackground;
+		ImagePath guildWindow;
+		AnimationPath buildingsIcons;
+		ImagePath hallBackground;
+		/// vector[row][column] = list of buildings in this slot
+		std::vector< std::vector< std::vector<BuildingID> > > hallSlots;
+
+		/// list of town screen structures.
+		/// NOTE: index in vector is meaningless. Vector used instead of list for a bit faster access
+		std::vector<ConstTransitivePtr<CStructure> > structures;
+
+		std::string siegePrefix;
+		std::vector<Point> siegePositions;
+		std::string towerIconSmall;
+		std::string towerIconLarge;
+
+	} clientInfo;
+};
+
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/entities/faction/CTownHandler.cpp vcmi/lib/entities/faction/CTownHandler.cpp
--- vcmi-1.5.7/lib/entities/faction/CTownHandler.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/entities/faction/CTownHandler.cpp	2024-12-19 15:00:22.898147938 +0100
@@ -0,0 +1,953 @@
+/*
+ * CTownHandler.cpp, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#include "StdInc.h"
+#include "CTownHandler.h"
+
+#include "CTown.h"
+#include "CFaction.h"
+#include "../building/CBuilding.h"
+#include "../hero/CHeroClassHandler.h"
+
+#include "../../CCreatureHandler.h"
+#include "../../IGameSettings.h"
+#include "../../TerrainHandler.h"
+#include "../../VCMI_Lib.h"
+
+#include "../../bonuses/Propagators.h"
+#include "../../constants/StringConstants.h"
+#include "../../mapObjectConstructors/AObjectTypeHandler.h"
+#include "../../mapObjectConstructors/CObjectClassesHandler.h"
+#include "../../modding/IdentifierStorage.h"
+#include "../../modding/ModScope.h"
+#include "../../spells/CSpellHandler.h"
+#include "../../texts/CGeneralTextHandler.h"
+#include "../../texts/CLegacyConfigParser.h"
+#include "../../json/JsonBonus.h"
+#include "../../json/JsonUtils.h"
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+const int NAMES_PER_TOWN=16; // number of town names per faction in H3 files. Json can define any number
+
+CTownHandler::CTownHandler()
+	: buildingsLibrary(JsonPath::builtin("config/buildingsLibrary"))
+	, randomTown(new CTown())
+	, randomFaction(new CFaction())
+{
+	randomFaction->town = randomTown;
+	randomTown->faction = randomFaction;
+	randomFaction->identifier = "random";
+	randomFaction->modScope = "core";
+}
+
+CTownHandler::~CTownHandler()
+{
+	delete randomFaction; // will also delete randomTown
+}
+
+JsonNode readBuilding(CLegacyConfigParser & parser)
+{
+	JsonNode ret;
+	JsonNode & cost = ret["cost"];
+
+	//note: this code will try to parse mithril as well but wil always return 0 for it
+	for(const std::string & resID : GameConstants::RESOURCE_NAMES)
+		cost[resID].Float() = parser.readNumber();
+
+	cost.Struct().erase("mithril"); // erase mithril to avoid confusing validator
+
+	parser.endLine();
+
+	return ret;
+}
+
+const TPropagatorPtr & CTownHandler::emptyPropagator()
+{
+	static const TPropagatorPtr emptyProp(nullptr);
+	return emptyProp;
+}
+
+std::vector<JsonNode> CTownHandler::loadLegacyData()
+{
+	size_t dataSize = VLC->engineSettings()->getInteger(EGameSettings::TEXTS_FACTION);
+
+	std::vector<JsonNode> dest(dataSize);
+	objects.resize(dataSize);
+
+	auto getBuild = [&](size_t town, size_t building) -> JsonNode &
+	{
+		return dest[town]["town"]["buildings"][EBuildingType::names[building]];
+	};
+
+	CLegacyConfigParser parser(TextPath::builtin("DATA/BUILDING.TXT"));
+
+	parser.endLine(); // header
+	parser.endLine();
+
+	//Unique buildings
+	for (size_t town=0; town<dataSize; town++)
+	{
+		parser.endLine(); //header
+		parser.endLine();
+
+		int buildID = 17;
+		do
+		{
+			getBuild(town, buildID) = readBuilding(parser);
+			buildID++;
+		}
+		while (!parser.isNextEntryEmpty());
+	}
+
+	// Common buildings
+	parser.endLine(); // header
+	parser.endLine();
+	parser.endLine();
+
+	int buildID = 0;
+	do
+	{
+		JsonNode building = readBuilding(parser);
+
+		for (size_t town=0; town<dataSize; town++)
+			getBuild(town, buildID) = building;
+
+		buildID++;
+	}
+	while (!parser.isNextEntryEmpty());
+
+	parser.endLine(); //header
+	parser.endLine();
+
+	//Dwellings
+	for (size_t town=0; town<dataSize; town++)
+	{
+		parser.endLine(); //header
+		parser.endLine();
+
+		for (size_t i=0; i<14; i++)
+		{
+			getBuild(town, 30+i) = readBuilding(parser);
+		}
+	}
+	{
+		CLegacyConfigParser parser(TextPath::builtin("DATA/BLDGNEUT.TXT"));
+
+		for(int building=0; building<15; building++)
+		{
+			std::string name  = parser.readString();
+			std::string descr = parser.readString();
+			parser.endLine();
+
+			for(int j=0; j<dataSize; j++)
+			{
+				getBuild(j, building)["name"].String() = name;
+				getBuild(j, building)["description"].String() = descr;
+			}
+		}
+		parser.endLine(); // silo
+		parser.endLine(); // blacksmith  //unused entries
+		parser.endLine(); // moat
+
+		//shipyard with the ship
+		std::string name  = parser.readString();
+		std::string descr = parser.readString();
+		parser.endLine();
+
+		for(int town=0; town<dataSize; town++)
+		{
+			getBuild(town, 20)["name"].String() = name;
+			getBuild(town, 20)["description"].String() = descr;
+		}
+
+		//blacksmith
+		for(int town=0; town<dataSize; town++)
+		{
+			getBuild(town, 16)["name"].String() =  parser.readString();
+			getBuild(town, 16)["description"].String() = parser.readString();
+			parser.endLine();
+		}
+	}
+	{
+		CLegacyConfigParser parser(TextPath::builtin("DATA/BLDGSPEC.TXT"));
+
+		for(int town=0; town<dataSize; town++)
+		{
+			for(int build=0; build<9; build++)
+			{
+				getBuild(town, 17 + build)["name"].String() =  parser.readString();
+				getBuild(town, 17 + build)["description"].String() = parser.readString();
+				parser.endLine();
+			}
+			getBuild(town, 26)["name"].String() =  parser.readString(); // Grail
+			getBuild(town, 26)["description"].String() = parser.readString();
+			parser.endLine();
+
+			getBuild(town, 15)["name"].String() =  parser.readString(); // Resource silo
+			getBuild(town, 15)["description"].String() = parser.readString();
+			parser.endLine();
+		}
+	}
+	{
+		CLegacyConfigParser parser(TextPath::builtin("DATA/DWELLING.TXT"));
+
+		for(int town=0; town<dataSize; town++)
+		{
+			for(int build=0; build<14; build++)
+			{
+				getBuild(town, 30 + build)["name"].String() =  parser.readString();
+				getBuild(town, 30 + build)["description"].String() = parser.readString();
+				parser.endLine();
+			}
+		}
+	}
+	{
+		CLegacyConfigParser typeParser(TextPath::builtin("DATA/TOWNTYPE.TXT"));
+		CLegacyConfigParser nameParser(TextPath::builtin("DATA/TOWNNAME.TXT"));
+		size_t townID=0;
+		do
+		{
+			dest[townID]["name"].String() = typeParser.readString();
+
+			for (int i=0; i<NAMES_PER_TOWN; i++)
+			{
+				JsonNode name;
+				name.String() = nameParser.readString();
+				dest[townID]["town"]["names"].Vector().push_back(name);
+				nameParser.endLine();
+			}
+			townID++;
+		}
+		while (typeParser.endLine());
+	}
+	return dest;
+}
+
+void CTownHandler::loadBuildingRequirements(CBuilding * building, const JsonNode & source, std::vector<BuildingRequirementsHelper> & bidsToLoad) const
+{
+	if (source.isNull())
+		return;
+
+	BuildingRequirementsHelper hlp;
+	hlp.building = building;
+	hlp.town = building->town;
+	hlp.json = source;
+	bidsToLoad.push_back(hlp);
+}
+
+void CTownHandler::loadBuildingBonuses(const JsonNode & source, BonusList & bonusList, CBuilding * building) const
+{
+	for(const auto & b : source.Vector())
+	{
+		auto bonus = std::make_shared<Bonus>(BonusDuration::PERMANENT, BonusType::NONE, BonusSource::TOWN_STRUCTURE, 0, BonusSourceID(building->getUniqueTypeID()));
+
+		if(!JsonUtils::parseBonus(b, bonus.get()))
+			continue;
+
+		bonus->description.appendTextID(building->getNameTextID());
+
+		//JsonUtils::parseBuildingBonus produces UNKNOWN type propagator instead of empty.
+		assert(bonus->propagator == nullptr || bonus->propagator->getPropagatorType() != CBonusSystemNode::ENodeTypes::UNKNOWN);
+
+		if(bonus->propagator != nullptr
+			&& bonus->propagator->getPropagatorType() == CBonusSystemNode::ENodeTypes::UNKNOWN)
+				bonus->addPropagator(emptyPropagator());
+		building->addNewBonus(bonus, bonusList);
+	}
+}
+
+void CTownHandler::loadBuilding(CTown * town, const std::string & stringID, const JsonNode & source)
+{
+	assert(stringID.find(':') == std::string::npos);
+	assert(!source.getModScope().empty());
+
+	auto * ret = new CBuilding();
+	ret->bid = vstd::find_or(MappedKeys::BUILDING_NAMES_TO_TYPES, stringID, BuildingID::NONE);
+	ret->subId = BuildingSubID::NONE;
+
+	if(ret->bid == BuildingID::NONE && !source["id"].isNull())
+	{
+		// FIXME: A lot of false-positives with no clear way to handle them in mods
+		//logMod->warn("Building %s: id field is deprecated", stringID);
+		ret->bid = source["id"].isNull() ? BuildingID(BuildingID::NONE) : BuildingID(source["id"].Float());
+	}
+
+	if (ret->bid == BuildingID::NONE)
+		logMod->error("Building '%s' isn't recognized and won't work properly. Correct the typo or update VCMI.", stringID);
+
+	ret->mode = ret->bid == BuildingID::GRAIL
+		? CBuilding::BUILD_GRAIL
+		: vstd::find_or(CBuilding::MODES, source["mode"].String(), CBuilding::BUILD_NORMAL);
+
+	ret->height = vstd::find_or(CBuilding::TOWER_TYPES, source["height"].String(), CBuilding::HEIGHT_NO_TOWER);
+
+	ret->identifier = stringID;
+	ret->modScope = source.getModScope();
+	ret->town = town;
+
+	VLC->generaltexth->registerString(source.getModScope(), ret->getNameTextID(), source["name"]);
+	VLC->generaltexth->registerString(source.getModScope(), ret->getDescriptionTextID(), source["description"]);
+
+	ret->subId = vstd::find_or(MappedKeys::SPECIAL_BUILDINGS, source["type"].String(), BuildingSubID::NONE);
+	ret->resources = TResources(source["cost"]);
+	ret->produce =   TResources(source["produce"]);
+
+	ret->manualHeroVisit = source["manualHeroVisit"].Bool();
+	ret->upgradeReplacesBonuses = source["upgradeReplacesBonuses"].Bool();
+
+	const JsonNode & fortifications = source["fortifications"];
+	if (!fortifications.isNull())
+	{
+		VLC->identifiers()->requestIdentifierOptional("creature", fortifications["citadelShooter"], [=](si32 identifier)
+		{
+			ret->fortifications.citadelShooter = CreatureID(identifier);
+		});
+
+		VLC->identifiers()->requestIdentifierOptional("creature", fortifications["upperTowerShooter"], [=](si32 identifier)
+		{
+			ret->fortifications.upperTowerShooter = CreatureID(identifier);
+		});
+
+		VLC->identifiers()->requestIdentifierOptional("creature", fortifications["lowerTowerShooter"], [=](si32 identifier)
+		{
+			ret->fortifications.lowerTowerShooter = CreatureID(identifier);
+		});
+
+		ret->fortifications.wallsHealth = fortifications["wallsHealth"].Integer();
+		ret->fortifications.citadelHealth = fortifications["citadelHealth"].Integer();
+		ret->fortifications.upperTowerHealth = fortifications["upperTowerHealth"].Integer();
+		ret->fortifications.lowerTowerHealth = fortifications["lowerTowerHealth"].Integer();
+		ret->fortifications.hasMoat = fortifications["hasMoat"].Bool();
+	}
+
+	loadBuildingBonuses(source["bonuses"], ret->buildingBonuses, ret);
+
+	if(!source["configuration"].isNull())
+		ret->rewardableObjectInfo.init(source["configuration"], ret->getBaseTextID());
+
+	//MODS COMPATIBILITY FOR pre-1.6
+	if(ret->produce.empty() && ret->bid == BuildingID::RESOURCE_SILO)
+	{
+		logGlobal->warn("Resource silo in town '%s' does not produces any resources!", ret->town->faction->getJsonKey());
+		switch (ret->town->primaryRes.toEnum())
+		{
+			case EGameResID::GOLD:
+				ret->produce[ret->town->primaryRes] = 500;
+				break;
+			case EGameResID::WOOD_AND_ORE:
+				ret->produce[EGameResID::WOOD] = 1;
+				ret->produce[EGameResID::ORE] = 1;
+				break;
+			default:
+				ret->produce[ret->town->primaryRes] = 1;
+				break;
+		}
+	}
+	loadBuildingRequirements(ret, source["requires"], requirementsToLoad);
+
+	if (!source["warMachine"].isNull())
+	{
+		VLC->identifiers()->requestIdentifier("artifact", source["warMachine"], [=](si32 identifier)
+		{
+			ret->warMachine = ArtifactID(identifier);
+		});
+	}
+
+	if (!source["upgrades"].isNull())
+	{
+		// building id and upgrades can't be the same
+		if(stringID == source["upgrades"].String())
+		{
+			throw std::runtime_error(boost::str(boost::format("Building with ID '%s' of town '%s' can't be an upgrade of the same building.") %
+												stringID % ret->town->faction->getNameTranslated()));
+		}
+
+		VLC->identifiers()->requestIdentifier(ret->town->getBuildingScope(), source["upgrades"], [=](si32 identifier)
+		{
+			ret->upgrade = BuildingID(identifier);
+		});
+	}
+	else
+		ret->upgrade = BuildingID::NONE;
+
+	ret->town->buildings[ret->bid] = ret;
+	for(const auto & element : source["marketModes"].Vector())
+	{
+		if(MappedKeys::MARKET_NAMES_TO_TYPES.count(element.String()))
+			ret->marketModes.insert(MappedKeys::MARKET_NAMES_TO_TYPES.at(element.String()));
+	}
+
+	registerObject(source.getModScope(), ret->town->getBuildingScope(), ret->identifier, ret->bid.getNum());
+}
+
+void CTownHandler::loadBuildings(CTown * town, const JsonNode & source)
+{
+	if(source.isStruct())
+	{
+		for(const auto & node : source.Struct())
+		{
+			if (!node.second.isNull())
+				loadBuilding(town, node.first, node.second);
+		}
+	}
+}
+
+void CTownHandler::loadStructure(CTown &town, const std::string & stringID, const JsonNode & source) const
+{
+	auto * ret = new CStructure();
+
+	ret->building = nullptr;
+	ret->buildable = nullptr;
+
+	VLC->identifiers()->tryRequestIdentifier( source.getModScope(), "building." + town.faction->getJsonKey(), stringID, [=, &town](si32 identifier) mutable
+	{
+		ret->building = town.buildings[BuildingID(identifier)];
+	});
+
+	if (source["builds"].isNull())
+	{
+		VLC->identifiers()->tryRequestIdentifier( source.getModScope(), "building." + town.faction->getJsonKey(), stringID, [=, &town](si32 identifier) mutable
+		{
+			ret->building = town.buildings[BuildingID(identifier)];
+		});
+	}
+	else
+	{
+		VLC->identifiers()->requestIdentifier("building." + town.faction->getJsonKey(), source["builds"], [=, &town](si32 identifier) mutable
+		{
+			ret->buildable = town.buildings[BuildingID(identifier)];
+		});
+	}
+
+	ret->identifier = stringID;
+	ret->pos.x = static_cast<si32>(source["x"].Float());
+	ret->pos.y = static_cast<si32>(source["y"].Float());
+	ret->pos.z = static_cast<si32>(source["z"].Float());
+
+	ret->hiddenUpgrade = source["hidden"].Bool();
+	ret->defName = AnimationPath::fromJson(source["animation"]);
+	ret->borderName = ImagePath::fromJson(source["border"]);
+	ret->areaName = ImagePath::fromJson(source["area"]);
+
+	town.clientInfo.structures.emplace_back(ret);
+}
+
+void CTownHandler::loadStructures(CTown &town, const JsonNode & source) const
+{
+	for(const auto & node : source.Struct())
+	{
+		if (!node.second.isNull())
+			loadStructure(town, node.first, node.second);
+	}
+}
+
+void CTownHandler::loadTownHall(CTown &town, const JsonNode & source) const
+{
+	auto & dstSlots = town.clientInfo.hallSlots;
+	const auto & srcSlots = source.Vector();
+	dstSlots.resize(srcSlots.size());
+
+	for(size_t i=0; i<dstSlots.size(); i++)
+	{
+		auto & dstRow = dstSlots[i];
+		const auto & srcRow = srcSlots[i].Vector();
+		dstRow.resize(srcRow.size());
+
+		for(size_t j=0; j < dstRow.size(); j++)
+		{
+			auto & dstBox = dstRow[j];
+			const auto & srcBox = srcRow[j].Vector();
+			dstBox.resize(srcBox.size());
+
+			for(size_t k=0; k<dstBox.size(); k++)
+			{
+				auto & dst = dstBox[k];
+				const auto & src = srcBox[k];
+
+				VLC->identifiers()->requestIdentifier("building." + town.faction->getJsonKey(), src, [&](si32 identifier)
+				{
+					dst = BuildingID(identifier);
+				});
+			}
+		}
+	}
+}
+
+Point JsonToPoint(const JsonNode & node)
+{
+	if(!node.isStruct())
+		return Point::makeInvalid();
+
+	Point ret;
+	ret.x = static_cast<si32>(node["x"].Float());
+	ret.y = static_cast<si32>(node["y"].Float());
+	return ret;
+}
+
+void CTownHandler::loadSiegeScreen(CTown &town, const JsonNode & source) const
+{
+	town.clientInfo.siegePrefix = source["imagePrefix"].String();
+	town.clientInfo.towerIconSmall = source["towerIconSmall"].String();
+	town.clientInfo.towerIconLarge = source["towerIconLarge"].String();
+
+	VLC->identifiers()->requestIdentifier("creature", source["shooter"], [&town](si32 creature)
+	{
+		auto crId = CreatureID(creature);
+		if((*VLC->creh)[crId]->animation.missileFrameAngles.empty())
+			logMod->error("Mod '%s' error: Creature '%s' on the Archer's tower is not a shooter. Mod should be fixed. Siege will not work properly!"
+				, town.faction->getNameTranslated()
+				, (*VLC->creh)[crId]->getNameSingularTranslated());
+
+		town.fortifications.citadelShooter = crId;
+		town.fortifications.upperTowerShooter = crId;
+		town.fortifications.lowerTowerShooter = crId;
+	});
+
+	auto & pos = town.clientInfo.siegePositions;
+	pos.resize(21);
+
+	pos[8]  = JsonToPoint(source["towers"]["top"]["tower"]);
+	pos[17] = JsonToPoint(source["towers"]["top"]["battlement"]);
+	pos[20] = JsonToPoint(source["towers"]["top"]["creature"]);
+
+	pos[2]  = JsonToPoint(source["towers"]["keep"]["tower"]);
+	pos[15] = JsonToPoint(source["towers"]["keep"]["battlement"]);
+	pos[18] = JsonToPoint(source["towers"]["keep"]["creature"]);
+
+	pos[3]  = JsonToPoint(source["towers"]["bottom"]["tower"]);
+	pos[16] = JsonToPoint(source["towers"]["bottom"]["battlement"]);
+	pos[19] = JsonToPoint(source["towers"]["bottom"]["creature"]);
+
+	pos[9]  = JsonToPoint(source["gate"]["gate"]);
+	pos[10]  = JsonToPoint(source["gate"]["arch"]);
+
+	pos[7]  = JsonToPoint(source["walls"]["upper"]);
+	pos[6]  = JsonToPoint(source["walls"]["upperMid"]);
+	pos[5]  = JsonToPoint(source["walls"]["bottomMid"]);
+	pos[4]  = JsonToPoint(source["walls"]["bottom"]);
+
+	pos[13] = JsonToPoint(source["moat"]["moat"]);
+	pos[14] = JsonToPoint(source["moat"]["bank"]);
+
+	pos[11] = JsonToPoint(source["static"]["bottom"]);
+	pos[12] = JsonToPoint(source["static"]["top"]);
+	pos[1]  = JsonToPoint(source["static"]["background"]);
+}
+
+static void readIcon(JsonNode source, std::string & small, std::string & large)
+{
+	if (source.getType() == JsonNode::JsonType::DATA_STRUCT) // don't crash on old format
+	{
+		small = source["small"].String();
+		large = source["large"].String();
+	}
+}
+
+void CTownHandler::loadClientData(CTown &town, const JsonNode & source) const
+{
+	CTown::ClientInfo & info = town.clientInfo;
+
+	readIcon(source["icons"]["village"]["normal"], info.iconSmall[0][0], info.iconLarge[0][0]);
+	readIcon(source["icons"]["village"]["built"], info.iconSmall[0][1], info.iconLarge[0][1]);
+	readIcon(source["icons"]["fort"]["normal"], info.iconSmall[1][0], info.iconLarge[1][0]);
+	readIcon(source["icons"]["fort"]["built"], info.iconSmall[1][1], info.iconLarge[1][1]);
+
+	if (source["musicTheme"].isVector())
+	{
+		for (auto const & entry : source["musicTheme"].Vector())
+			info.musicTheme.push_back(AudioPath::fromJson(entry));
+	}
+	else
+	{
+		info.musicTheme.push_back(AudioPath::fromJson(source["musicTheme"]));
+	}
+
+	info.hallBackground = ImagePath::fromJson(source["hallBackground"]);
+	info.townBackground = ImagePath::fromJson(source["townBackground"]);
+	info.guildWindow = ImagePath::fromJson(source["guildWindow"]);
+	info.buildingsIcons = AnimationPath::fromJson(source["buildingsIcons"]);
+
+	info.guildBackground = ImagePath::fromJson(source["guildBackground"]);
+	info.tavernVideo = VideoPath::fromJson(source["tavernVideo"]);
+
+	loadTownHall(town,   source["hallSlots"]);
+	loadStructures(town, source["structures"]);
+	loadSiegeScreen(town, source["siege"]);
+}
+
+void CTownHandler::loadTown(CTown * town, const JsonNode & source)
+{
+	const auto * resIter = boost::find(GameConstants::RESOURCE_NAMES, source["primaryResource"].String());
+	if(resIter == std::end(GameConstants::RESOURCE_NAMES))
+		town->primaryRes = GameResID(EGameResID::WOOD_AND_ORE); //Wood + Ore
+	else
+		town->primaryRes = GameResID(resIter - std::begin(GameConstants::RESOURCE_NAMES));
+
+	if (!source["warMachine"].isNull())
+	{
+		VLC->identifiers()->requestIdentifier( "creature", source["warMachine"], [=](si32 creatureID)
+		{
+			town->warMachineDeprecated = creatureID;
+		});
+	}
+
+	town->mageLevel = static_cast<ui32>(source["mageGuild"].Float());
+
+	town->namesCount = 0;
+	for(const auto & name : source["names"].Vector())
+	{
+		VLC->generaltexth->registerString(town->faction->modScope, town->getRandomNameTextID(town->namesCount), name);
+		town->namesCount += 1;
+	}
+
+	if (!source["moatAbility"].isNull()) // VCMI 1.2 compatibility code
+	{
+		VLC->identifiers()->requestIdentifier( "spell", source["moatAbility"], [=](si32 ability)
+		{
+			town->fortifications.moatSpell = SpellID(ability);
+		});
+	}
+	else
+	{
+		VLC->identifiers()->requestIdentifier( source.getModScope(), "spell", "castleMoat", [=](si32 ability)
+		{
+			town->fortifications.moatSpell = SpellID(ability);
+		});
+	}
+
+	//  Horde building creature level
+	for(const JsonNode &node : source["horde"].Vector())
+		town->hordeLvl[static_cast<int>(town->hordeLvl.size())] = static_cast<int>(node.Float());
+
+	// town needs to have exactly 2 horde entries. Validation will take care of 2+ entries
+	// but anything below 2 must be handled here
+	for (size_t i=source["horde"].Vector().size(); i<2; i++)
+		town->hordeLvl[static_cast<int>(i)] = -1;
+
+	const JsonVector & creatures = source["creatures"].Vector();
+
+	town->creatures.resize(creatures.size());
+
+	for (size_t i=0; i< creatures.size(); i++)
+	{
+		const JsonVector & level = creatures[i].Vector();
+
+		town->creatures[i].resize(level.size());
+
+		for (size_t j=0; j<level.size(); j++)
+		{
+			VLC->identifiers()->requestIdentifier("creature", level[j], [=](si32 creature)
+			{
+				town->creatures[i][j] = CreatureID(creature);
+			});
+		}
+	}
+
+	town->defaultTavernChance = static_cast<ui32>(source["defaultTavern"].Float());
+	/// set chance of specific hero class to appear in this town
+	for(const auto & node : source["tavern"].Struct())
+	{
+		int chance = static_cast<int>(node.second.Float());
+
+		VLC->identifiers()->requestIdentifier(node.second.getModScope(), "heroClass",node.first, [=](si32 classID)
+		{
+			VLC->heroclassesh->objects[classID]->selectionProbability[town->faction->getId()] = chance;
+		});
+	}
+
+	for(const auto & node : source["guildSpells"].Struct())
+	{
+		int chance = static_cast<int>(node.second.Float());
+
+		VLC->identifiers()->requestIdentifier(node.second.getModScope(), "spell", node.first, [=](si32 spellID)
+		{
+			VLC->spellh->objects.at(spellID)->probabilities[town->faction->getId()] = chance;
+		});
+	}
+
+	for(const JsonNode & d : source["adventureMap"]["dwellings"].Vector())
+	{
+		town->dwellings.push_back(d["graphics"].String());
+		town->dwellingNames.push_back(d["name"].String());
+	}
+
+	loadBuildings(town, source["buildings"]);
+	loadClientData(*town, source);
+}
+
+void CTownHandler::loadPuzzle(CFaction &faction, const JsonNode &source) const
+{
+	faction.puzzleMap.reserve(GameConstants::PUZZLE_MAP_PIECES);
+
+	std::string prefix = source["prefix"].String();
+	for(const JsonNode &piece : source["pieces"].Vector())
+	{
+		size_t index = faction.puzzleMap.size();
+		SPuzzleInfo spi;
+
+		spi.position.x = static_cast<si16>(piece["x"].Float());
+		spi.position.y = static_cast<si16>(piece["y"].Float());
+		spi.whenUncovered = static_cast<ui16>(piece["index"].Float());
+		spi.number = static_cast<ui16>(index);
+
+		// filename calculation
+		std::ostringstream suffix;
+		suffix << std::setfill('0') << std::setw(2) << index;
+
+		spi.filename = ImagePath::builtinTODO(prefix + suffix.str());
+
+		faction.puzzleMap.push_back(spi);
+	}
+	assert(faction.puzzleMap.size() == GameConstants::PUZZLE_MAP_PIECES);
+}
+
+std::shared_ptr<CFaction> CTownHandler::loadFromJson(const std::string & scope, const JsonNode & source, const std::string & identifier, size_t index)
+{
+	assert(identifier.find(':') == std::string::npos);
+
+	auto faction = std::make_shared<CFaction>();
+
+	faction->index = static_cast<FactionID>(index);
+	faction->modScope = scope;
+	faction->identifier = identifier;
+
+	VLC->generaltexth->registerString(scope, faction->getNameTextID(), source["name"]);
+	VLC->generaltexth->registerString(scope, faction->getDescriptionTextID(), source["description"]);
+
+	faction->creatureBg120 = ImagePath::fromJson(source["creatureBackground"]["120px"]);
+	faction->creatureBg130 = ImagePath::fromJson(source["creatureBackground"]["130px"]);
+
+	faction->boatType = BoatId::CASTLE; //Do not crash
+	if (!source["boat"].isNull())
+	{
+		VLC->identifiers()->requestIdentifier("core:boat", source["boat"], [=](int32_t boatTypeID)
+		{
+			faction->boatType = BoatId(boatTypeID);
+		});
+	}
+
+	int alignment = vstd::find_pos(GameConstants::ALIGNMENT_NAMES, source["alignment"].String());
+	if (alignment == -1)
+		faction->alignment = EAlignment::NEUTRAL;
+	else
+		faction->alignment = static_cast<EAlignment>(alignment);
+	
+	auto preferUndergound = source["preferUndergroundPlacement"];
+	faction->preferUndergroundPlacement = preferUndergound.isNull() ? false : preferUndergound.Bool();
+	faction->special = source["special"].Bool();
+
+	// NOTE: semi-workaround - normally, towns are supposed to have native terrains.
+	// Towns without one are exceptions. So, vcmi requires nativeTerrain to be defined
+	// But allows it to be defined with explicit value of "none" if town should not have native terrain
+	// This is better than allowing such terrain-less towns silently, leading to issues with RMG
+	faction->nativeTerrain = ETerrainId::NONE;
+	if ( !source["nativeTerrain"].isNull() && source["nativeTerrain"].String() != "none")
+	{
+		VLC->identifiers()->requestIdentifier("terrain", source["nativeTerrain"], [=](int32_t index){
+			faction->nativeTerrain = TerrainId(index);
+
+			auto const & terrain = VLC->terrainTypeHandler->getById(faction->nativeTerrain);
+
+			if (!terrain->isSurface() && !terrain->isUnderground())
+				logMod->warn("Faction %s has terrain %s as native, but terrain is not suitable for either surface or subterranean layers!", faction->getJsonKey(), terrain->getJsonKey());
+		});
+	}
+
+	if (!source["town"].isNull())
+	{
+		faction->town = new CTown();
+		faction->town->faction = faction.get();
+		loadTown(faction->town, source["town"]);
+	}
+	else
+		faction->town = nullptr;
+
+	if (!source["puzzleMap"].isNull())
+		loadPuzzle(*faction, source["puzzleMap"]);
+
+	return faction;
+}
+
+void CTownHandler::loadObject(std::string scope, std::string name, const JsonNode & data)
+{
+	auto object = loadFromJson(scope, data, name, objects.size());
+
+	objects.emplace_back(object);
+
+	if (object->town)
+	{
+		auto & info = object->town->clientInfo;
+		info.icons[0][0] = 8 + object->index.getNum() * 4 + 0;
+		info.icons[0][1] = 8 + object->index.getNum() * 4 + 1;
+		info.icons[1][0] = 8 + object->index.getNum() * 4 + 2;
+		info.icons[1][1] = 8 + object->index.getNum() * 4 + 3;
+
+		VLC->identifiers()->requestIdentifier(scope, "object", "town", [=](si32 index)
+		{
+			// register town once objects are loaded
+			JsonNode config = data["town"]["mapObject"];
+			config["faction"].String() = name;
+			config["faction"].setModScope(scope, false);
+			if (config.getModScope().empty())// MODS COMPATIBILITY FOR 0.96
+				config.setModScope(scope, false);
+			VLC->objtypeh->loadSubObject(object->identifier, config, index, object->index);
+
+			// MODS COMPATIBILITY FOR 0.96
+			const auto & advMap = data["town"]["adventureMap"];
+			if (!advMap.isNull())
+			{
+				logMod->warn("Outdated town mod. Will try to generate valid templates out of fort");
+				JsonNode config;
+				config["animation"] = advMap["castle"];
+				VLC->objtypeh->getHandlerFor(index, object->index)->addTemplate(config);
+			}
+		});
+	}
+
+	registerObject(scope, "faction", name, object->index.getNum());
+}
+
+void CTownHandler::loadObject(std::string scope, std::string name, const JsonNode & data, size_t index)
+{
+	auto object = loadFromJson(scope, data, name, index);
+
+	if (objects.size() > index)
+		assert(objects[index] == nullptr); // ensure that this id was not loaded before
+	else
+		objects.resize(index + 1);
+	objects[index] = object;
+
+	if (object->town)
+	{
+		auto & info = object->town->clientInfo;
+		info.icons[0][0] = (GameConstants::F_NUMBER + object->index.getNum()) * 2 + 0;
+		info.icons[0][1] = (GameConstants::F_NUMBER + object->index.getNum()) * 2 + 1;
+		info.icons[1][0] = object->index.getNum() * 2 + 0;
+		info.icons[1][1] = object->index.getNum() * 2 + 1;
+
+		VLC->identifiers()->requestIdentifier(scope, "object", "town", [=](si32 index)
+		{
+			// register town once objects are loaded
+			JsonNode config = data["town"]["mapObject"];
+			config["faction"].String() = name;
+			config["faction"].setModScope(scope, false);
+			VLC->objtypeh->loadSubObject(object->identifier, config, index, object->index);
+		});
+	}
+
+	registerObject(scope, "faction", name, object->index.getNum());
+}
+
+void CTownHandler::loadRandomFaction()
+{
+	JsonNode randomFactionJson(JsonPath::builtin("config/factions/random.json"));
+	randomFactionJson.setModScope(ModScope::scopeBuiltin(), true);
+	loadBuildings(randomTown, randomFactionJson["random"]["town"]["buildings"]);
+}
+
+void CTownHandler::loadCustom()
+{
+	loadRandomFaction();
+}
+
+void CTownHandler::beforeValidate(JsonNode & object)
+{
+	if (object.Struct().count("town") == 0)
+		return;
+
+	const auto & inheritBuilding = [this](const std::string & name, JsonNode & target)
+	{
+		if (buildingsLibrary.Struct().count(name) == 0)
+			return;
+
+		JsonNode baseCopy(buildingsLibrary[name]);
+		baseCopy.setModScope(target.getModScope());
+		JsonUtils::inherit(target, baseCopy);
+	};
+
+	for (auto & building : object["town"]["buildings"].Struct())
+	{
+		inheritBuilding(building.first, building.second);
+		if (building.second.Struct().count("type"))
+			inheritBuilding(building.second["type"].String(), building.second);
+
+		// MODS COMPATIBILITY FOR pre-1.6
+		// convert old buildigns with onVisitBonuses into configurable building
+		if (building.second.Struct().count("onVisitBonuses"))
+		{
+			building.second["configuration"]["visitMode"] = JsonNode("bonus");
+			building.second["configuration"]["rewards"][0]["message"] = building.second["description"];
+			building.second["configuration"]["rewards"][0]["bonuses"] = building.second["onVisitBonuses"];
+		}
+	}
+}
+
+void CTownHandler::afterLoadFinalization()
+{
+	initializeRequirements();
+}
+
+void CTownHandler::initializeRequirements()
+{
+	// must be done separately after all ID's are known
+	for (auto & requirement : requirementsToLoad)
+	{
+		requirement.building->requirements = CBuilding::TRequired(requirement.json, [&](const JsonNode & node) -> BuildingID
+		{
+			if (node.Vector().size() > 1)
+			{
+				logMod->error("Unexpected length of town buildings requirements: %d", node.Vector().size());
+				logMod->error("Entry contains: ");
+				logMod->error(node.toString());
+			}
+
+			auto index = VLC->identifiers()->getIdentifier(requirement.town->getBuildingScope(), node[0]);
+
+			if (!index.has_value())
+			{
+				logMod->error("Unknown building in town buildings: %s", node[0].String());
+				return BuildingID::NONE;
+			}
+			return BuildingID(index.value());
+		});
+	}
+	requirementsToLoad.clear();
+}
+
+std::set<FactionID> CTownHandler::getDefaultAllowed() const
+{
+	std::set<FactionID> allowedFactions;
+
+	for(const auto & town : objects)
+		if (town->town != nullptr && !town->special)
+			allowedFactions.insert(town->getId());
+
+	return allowedFactions;
+}
+
+std::set<FactionID> CTownHandler::getAllowedFactions(bool withTown) const
+{
+	if (withTown)
+		return getDefaultAllowed();
+
+	std::set<FactionID> result;
+	for(const auto & town : objects)
+		result.insert(town->getId());
+
+	return result;
+}
+
+const std::vector<std::string> & CTownHandler::getTypeNames() const
+{
+	static const std::vector<std::string> typeNames = { "faction", "town" };
+	return typeNames;
+}
+
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/entities/faction/CTownHandler.h vcmi/lib/entities/faction/CTownHandler.h
--- vcmi-1.5.7/lib/entities/faction/CTownHandler.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/entities/faction/CTownHandler.h	2024-12-19 15:00:22.898147938 +0100
@@ -0,0 +1,91 @@
+/*
+ * CTownHandler.h, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#pragma once
+
+#include <vcmi/FactionService.h>
+
+#include "CFaction.h"
+
+#include "../../IHandlerBase.h"
+#include "../../bonuses/Bonus.h"
+#include "../../constants/EntityIdentifiers.h"
+#include "../../json/JsonNode.h"
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+class CBuilding;
+class CTown;
+
+class DLL_LINKAGE CTownHandler : public CHandlerBase<FactionID, Faction, CFaction, FactionService>
+{
+	JsonNode buildingsLibrary;
+
+	struct BuildingRequirementsHelper
+	{
+		JsonNode json;
+		CBuilding * building;
+		CTown * town;
+	};
+
+	std::vector<BuildingRequirementsHelper> requirementsToLoad;
+	std::vector<BuildingRequirementsHelper> overriddenBidsToLoad; //list of buildings, which bonuses should be overridden.
+
+	static const TPropagatorPtr & emptyPropagator();
+
+	void initializeRequirements();
+
+	/// loads CBuilding's into town
+	void loadBuildingRequirements(CBuilding * building, const JsonNode & source, std::vector<BuildingRequirementsHelper> & bidsToLoad) const;
+	void loadBuilding(CTown * town, const std::string & stringID, const JsonNode & source);
+	void loadBuildings(CTown * town, const JsonNode & source);
+
+	/// loads CStructure's into town
+	void loadStructure(CTown & town, const std::string & stringID, const JsonNode & source) const;
+	void loadStructures(CTown & town, const JsonNode & source) const;
+
+	/// loads town hall vector (hallSlots)
+	void loadTownHall(CTown & town, const JsonNode & source) const;
+	void loadSiegeScreen(CTown & town, const JsonNode & source) const;
+
+	void loadClientData(CTown & town, const JsonNode & source) const;
+
+	void loadTown(CTown * town, const JsonNode & source);
+
+	void loadPuzzle(CFaction & faction, const JsonNode & source) const;
+
+	void loadRandomFaction();
+
+public:
+	CTown * randomTown;
+	CFaction * randomFaction;
+
+	CTownHandler();
+	~CTownHandler();
+
+	std::vector<JsonNode> loadLegacyData() override;
+
+	void loadObject(std::string scope, std::string name, const JsonNode & data) override;
+	void loadObject(std::string scope, std::string name, const JsonNode & data, size_t index) override;
+
+	void loadCustom() override;
+	void afterLoadFinalization() override;
+	void beforeValidate(JsonNode & object) override;
+
+	std::set<FactionID> getDefaultAllowed() const;
+	std::set<FactionID> getAllowedFactions(bool withTown = true) const;
+
+protected:
+
+	void loadBuildingBonuses(const JsonNode & source, BonusList & bonusList, CBuilding * building) const;
+	const std::vector<std::string> & getTypeNames() const override;
+	std::shared_ptr<CFaction> loadFromJson(const std::string & scope, const JsonNode & data, const std::string & identifier, size_t index) override;
+};
+
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/entities/hero/CHeroClass.cpp vcmi/lib/entities/hero/CHeroClass.cpp
--- vcmi-1.5.7/lib/entities/hero/CHeroClass.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/entities/hero/CHeroClass.cpp	2024-12-19 15:00:22.899147979 +0100
@@ -0,0 +1,120 @@
+/*
+ * CHeroClass.cpp, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#include "StdInc.h"
+#include "CHeroClass.h"
+
+#include "../faction/CFaction.h"
+
+#include "../../VCMI_Lib.h"
+#include "../../texts/CGeneralTextHandler.h"
+
+#include <vstd/RNG.h>
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+SecondarySkill CHeroClass::chooseSecSkill(const std::set<SecondarySkill> & possibles, vstd::RNG & rand) const //picks secondary skill out from given possibilities
+{
+	assert(!possibles.empty());
+
+	std::vector<int> weights;
+	std::vector<SecondarySkill> skills;
+
+	for(const auto & possible : possibles)
+	{
+		skills.push_back(possible);
+		if (secSkillProbability.count(possible) != 0)
+		{
+			int weight = secSkillProbability.at(possible);
+			weights.push_back(std::max(1, weight));
+		}
+		else
+			weights.push_back(1); // H3 behavior - banned skills have minimal (1) chance to be picked
+	}
+
+	int selectedIndex = RandomGeneratorUtil::nextItemWeighted(weights, rand);
+	return skills.at(selectedIndex);
+}
+
+bool CHeroClass::isMagicHero() const
+{
+	return affinity == MAGIC;
+}
+
+int CHeroClass::tavernProbability(FactionID targetFaction) const
+{
+	auto it = selectionProbability.find(targetFaction);
+	if (it != selectionProbability.end())
+		return it->second;
+	return 0;
+}
+
+EAlignment CHeroClass::getAlignment() const
+{
+	return faction.toEntity(VLC)->getAlignment();
+}
+
+int32_t CHeroClass::getIndex() const
+{
+	return id.getNum();
+}
+
+int32_t CHeroClass::getIconIndex() const
+{
+	return getIndex();
+}
+
+std::string CHeroClass::getJsonKey() const
+{
+	return modScope + ':' + identifier;
+}
+
+std::string CHeroClass::getModScope() const
+{
+	return modScope;
+}
+
+HeroClassID CHeroClass::getId() const
+{
+	return id;
+}
+
+void CHeroClass::registerIcons(const IconRegistar & cb) const
+{
+
+}
+
+std::string CHeroClass::getNameTranslated() const
+{
+	return VLC->generaltexth->translate(getNameTextID());
+}
+
+std::string CHeroClass::getNameTextID() const
+{
+	return TextIdentifier("heroClass", modScope, identifier, "name").get();
+}
+
+void CHeroClass::updateFrom(const JsonNode & data)
+{
+	//TODO: CHeroClass::updateFrom
+}
+
+void CHeroClass::serializeJson(JsonSerializeFormat & handler)
+{
+
+}
+
+CHeroClass::CHeroClass():
+	faction(0),
+	affinity(0),
+	defaultTavernChance(0)
+{
+}
+
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/entities/hero/CHeroClass.h vcmi/lib/entities/hero/CHeroClass.h
--- vcmi-1.5.7/lib/entities/hero/CHeroClass.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/entities/hero/CHeroClass.h	2024-12-19 15:00:22.899147979 +0100
@@ -0,0 +1,85 @@
+/*
+ * CHeroClass.h, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#pragma once
+
+#include <vcmi/HeroClass.h>
+
+#include "../../constants/EntityIdentifiers.h"
+#include "../../constants/Enumerations.h"
+#include "../../filesystem/ResourcePath.h"
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+namespace vstd
+{
+class RNG;
+}
+
+class DLL_LINKAGE CHeroClass : public HeroClass
+{
+	friend class CHeroClassHandler;
+	HeroClassID id; // use getId instead
+	std::string modScope;
+	std::string identifier; // use getJsonKey instead
+
+public:
+	enum EClassAffinity
+	{
+		MIGHT,
+		MAGIC
+	};
+
+	//double aggression; // not used in vcmi.
+	FactionID faction;
+	ui8 affinity; // affinity, using EClassAffinity enum
+
+	// default chance for hero of specific class to appear in tavern, if field "tavern" was not set
+	// resulting chance = sqrt(town.chance * heroClass.chance)
+	ui32 defaultTavernChance;
+
+	CreatureID commander;
+
+	std::vector<int> primarySkillInitial; // initial primary skills
+	std::vector<int> primarySkillLowLevel; // probability (%) of getting point of primary skill when getting level
+	std::vector<int> primarySkillHighLevel; // same for high levels (> 10)
+
+	std::map<SecondarySkill, int> secSkillProbability; //probabilities of gaining secondary skills (out of 112), in id order
+
+	std::map<FactionID, int> selectionProbability; //probability of selection in towns
+
+	AnimationPath imageBattleMale;
+	AnimationPath imageBattleFemale;
+	std::string imageMapMale;
+	std::string imageMapFemale;
+
+	CHeroClass();
+
+	int32_t getIndex() const override;
+	int32_t getIconIndex() const override;
+	std::string getJsonKey() const override;
+	std::string getModScope() const override;
+	HeroClassID getId() const override;
+	void registerIcons(const IconRegistar & cb) const override;
+
+	std::string getNameTranslated() const override;
+	std::string getNameTextID() const override;
+
+	bool isMagicHero() const;
+	SecondarySkill chooseSecSkill(const std::set<SecondarySkill> & possibles, vstd::RNG & rand) const; //picks secondary skill out from given possibilities
+
+	void updateFrom(const JsonNode & data);
+	void serializeJson(JsonSerializeFormat & handler);
+
+	EAlignment getAlignment() const;
+
+	int tavernProbability(FactionID faction) const;
+};
+
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/entities/hero/CHeroClassHandler.cpp vcmi/lib/entities/hero/CHeroClassHandler.cpp
--- vcmi-1.5.7/lib/entities/hero/CHeroClassHandler.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/entities/hero/CHeroClassHandler.cpp	2024-12-19 15:00:22.899147979 +0100
@@ -0,0 +1,226 @@
+/*
+ * CHeroClassHandler.cpp, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#include "StdInc.h"
+#include "CHeroClassHandler.h"
+
+#include "CHeroClass.h"
+
+#include "../faction/CTown.h"
+#include "../faction/CTownHandler.h"
+
+#include "../../CSkillHandler.h"
+#include "../../IGameSettings.h"
+#include "../../VCMI_Lib.h"
+#include "../../constants/StringConstants.h"
+#include "../../json/JsonNode.h"
+#include "../../mapObjectConstructors/AObjectTypeHandler.h"
+#include "../../mapObjectConstructors/CObjectClassesHandler.h"
+#include "../../modding/IdentifierStorage.h"
+#include "../../texts/CGeneralTextHandler.h"
+#include "../../texts/CLegacyConfigParser.h"
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+void CHeroClassHandler::fillPrimarySkillData(const JsonNode & node, CHeroClass * heroClass, PrimarySkill pSkill) const
+{
+	const auto & skillName = NPrimarySkill::names[pSkill.getNum()];
+	auto currentPrimarySkillValue = static_cast<int>(node["primarySkills"][skillName].Integer());
+	int primarySkillLegalMinimum = VLC->engineSettings()->getVector(EGameSettings::HEROES_MINIMAL_PRIMARY_SKILLS)[pSkill.getNum()];
+
+	if(currentPrimarySkillValue < primarySkillLegalMinimum)
+	{
+		logMod->error("Hero class '%s' has incorrect initial value '%d' for skill '%s'. Value '%d' will be used instead.",
+					  heroClass->getNameTranslated(), currentPrimarySkillValue, skillName, primarySkillLegalMinimum);
+		currentPrimarySkillValue = primarySkillLegalMinimum;
+	}
+	heroClass->primarySkillInitial.push_back(currentPrimarySkillValue);
+	heroClass->primarySkillLowLevel.push_back(static_cast<int>(node["lowLevelChance"][skillName].Float()));
+	heroClass->primarySkillHighLevel.push_back(static_cast<int>(node["highLevelChance"][skillName].Float()));
+}
+
+const std::vector<std::string> & CHeroClassHandler::getTypeNames() const
+{
+	static const std::vector<std::string> typeNames = { "heroClass" };
+	return typeNames;
+}
+
+std::shared_ptr<CHeroClass> CHeroClassHandler::loadFromJson(const std::string & scope, const JsonNode & node, const std::string & identifier, size_t index)
+{
+	assert(identifier.find(':') == std::string::npos);
+	assert(!scope.empty());
+
+	std::string affinityStr[2] = { "might", "magic" };
+
+	auto heroClass = std::make_shared<CHeroClass>();
+
+	heroClass->id = HeroClassID(index);
+	heroClass->identifier = identifier;
+	heroClass->modScope = scope;
+	heroClass->imageBattleFemale = AnimationPath::fromJson(node["animation"]["battle"]["female"]);
+	heroClass->imageBattleMale   = AnimationPath::fromJson(node["animation"]["battle"]["male"]);
+	//MODS COMPATIBILITY FOR 0.96
+	heroClass->imageMapFemale    = node["animation"]["map"]["female"].String();
+	heroClass->imageMapMale      = node["animation"]["map"]["male"].String();
+
+	VLC->generaltexth->registerString(scope, heroClass->getNameTextID(), node["name"].String());
+
+	if (vstd::contains(affinityStr, node["affinity"].String()))
+	{
+		heroClass->affinity = vstd::find_pos(affinityStr, node["affinity"].String());
+	}
+	else
+	{
+		logGlobal->error("Mod '%s', hero class '%s': invalid affinity '%s'! Expected 'might' or 'magic'!", scope, identifier, node["affinity"].String());
+		heroClass->affinity = CHeroClass::MIGHT;
+	}
+
+	fillPrimarySkillData(node, heroClass.get(), PrimarySkill::ATTACK);
+	fillPrimarySkillData(node, heroClass.get(), PrimarySkill::DEFENSE);
+	fillPrimarySkillData(node, heroClass.get(), PrimarySkill::SPELL_POWER);
+	fillPrimarySkillData(node, heroClass.get(), PrimarySkill::KNOWLEDGE);
+
+	auto percentSumm = std::accumulate(heroClass->primarySkillLowLevel.begin(), heroClass->primarySkillLowLevel.end(), 0);
+	if(percentSumm <= 0)
+		logMod->error("Hero class %s has wrong lowLevelChance values: must be above zero!", heroClass->identifier, percentSumm);
+
+	percentSumm = std::accumulate(heroClass->primarySkillHighLevel.begin(), heroClass->primarySkillHighLevel.end(), 0);
+	if(percentSumm <= 0)
+		logMod->error("Hero class %s has wrong highLevelChance values: must be above zero!", heroClass->identifier, percentSumm);
+
+	for(auto skillPair : node["secondarySkills"].Struct())
+	{
+		int probability = static_cast<int>(skillPair.second.Integer());
+		VLC->identifiers()->requestIdentifier(skillPair.second.getModScope(), "skill", skillPair.first, [heroClass, probability](si32 skillID)
+											  {
+												  heroClass->secSkillProbability[skillID] = probability;
+											  });
+	}
+
+	VLC->identifiers()->requestIdentifier ("creature", node["commander"],
+										  [=](si32 commanderID)
+										  {
+											  heroClass->commander = CreatureID(commanderID);
+										  });
+
+	heroClass->defaultTavernChance = static_cast<ui32>(node["defaultTavern"].Float());
+	for(const auto & tavern : node["tavern"].Struct())
+	{
+		int value = static_cast<int>(tavern.second.Float());
+
+		VLC->identifiers()->requestIdentifier(tavern.second.getModScope(), "faction", tavern.first,
+											  [=](si32 factionID)
+											  {
+												  heroClass->selectionProbability[FactionID(factionID)] = value;
+											  });
+	}
+
+	VLC->identifiers()->requestIdentifier("faction", node["faction"],
+										  [=](si32 factionID)
+										  {
+											  heroClass->faction.setNum(factionID);
+										  });
+
+	VLC->identifiers()->requestIdentifier(scope, "object", "hero", [=](si32 index)
+										  {
+											  JsonNode classConf = node["mapObject"];
+											  classConf["heroClass"].String() = identifier;
+											  if (!node["compatibilityIdentifiers"].isNull())
+												  classConf["compatibilityIdentifiers"] = node["compatibilityIdentifiers"];
+											  classConf.setModScope(scope);
+											  VLC->objtypeh->loadSubObject(identifier, classConf, index, heroClass->getIndex());
+										  });
+
+	return heroClass;
+}
+
+std::vector<JsonNode> CHeroClassHandler::loadLegacyData()
+{
+	size_t dataSize = VLC->engineSettings()->getInteger(EGameSettings::TEXTS_HERO_CLASS);
+
+	objects.resize(dataSize);
+	std::vector<JsonNode> h3Data;
+	h3Data.reserve(dataSize);
+
+	CLegacyConfigParser parser(TextPath::builtin("DATA/HCTRAITS.TXT"));
+
+	parser.endLine(); // header
+	parser.endLine();
+
+	for (size_t i=0; i<dataSize; i++)
+	{
+		JsonNode entry;
+
+		entry["name"].String() = parser.readString();
+
+		parser.readNumber(); // unused aggression
+
+		for(const auto & name : NPrimarySkill::names)
+			entry["primarySkills"][name].Float() = parser.readNumber();
+
+		for(const auto & name : NPrimarySkill::names)
+			entry["lowLevelChance"][name].Float() = parser.readNumber();
+
+		for(const auto & name : NPrimarySkill::names)
+			entry["highLevelChance"][name].Float() = parser.readNumber();
+
+		for(const auto & name : NSecondarySkill::names)
+			entry["secondarySkills"][name].Float() = parser.readNumber();
+
+		for(const auto & name : NFaction::names)
+			entry["tavern"][name].Float() = parser.readNumber();
+
+		parser.endLine();
+		h3Data.push_back(entry);
+	}
+	return h3Data;
+}
+
+void CHeroClassHandler::afterLoadFinalization()
+{
+	// for each pair <class, town> set selection probability if it was not set before in tavern entries
+	for(auto & heroClass : objects)
+	{
+		for(auto & faction : VLC->townh->objects)
+		{
+			if (!faction->town)
+				continue;
+			if (heroClass->selectionProbability.count(faction->getId()))
+				continue;
+
+			auto chance = static_cast<float>(heroClass->defaultTavernChance * faction->town->defaultTavernChance);
+			heroClass->selectionProbability[faction->getId()] = static_cast<int>(sqrt(chance) + 0.5); //FIXME: replace with std::round once MVS supports it
+		}
+
+		// set default probabilities for gaining secondary skills where not loaded previously
+		for(int skillID = 0; skillID < VLC->skillh->size(); skillID++)
+		{
+			if(heroClass->secSkillProbability.count(skillID) == 0)
+			{
+				const CSkill * skill = (*VLC->skillh)[SecondarySkill(skillID)];
+				logMod->trace("%s: no probability for %s, using default", heroClass->identifier, skill->getJsonKey());
+				heroClass->secSkillProbability[skillID] = skill->gainChance[heroClass->affinity];
+			}
+		}
+	}
+
+	for(const auto & hc : objects)
+	{
+		if(!hc->imageMapMale.empty())
+		{
+			JsonNode templ;
+			templ["animation"].String() = hc->imageMapMale;
+			VLC->objtypeh->getHandlerFor(Obj::HERO, hc->getIndex())->addTemplate(templ);
+		}
+	}
+}
+
+CHeroClassHandler::~CHeroClassHandler() = default;
+
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/entities/hero/CHeroClassHandler.h vcmi/lib/entities/hero/CHeroClassHandler.h
--- vcmi-1.5.7/lib/entities/hero/CHeroClassHandler.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/entities/hero/CHeroClassHandler.h	2024-12-19 15:00:22.899147979 +0100
@@ -0,0 +1,37 @@
+/*
+ * CHeroClassHandler.h, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#pragma once
+
+#include <vcmi/HeroClassService.h>
+
+#include "CHeroClass.h" // convenience include - users of handler generally also use its entity
+
+#include "../../IHandlerBase.h"
+#include "../../constants/EntityIdentifiers.h"
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+class DLL_LINKAGE CHeroClassHandler : public CHandlerBase<HeroClassID, HeroClass, CHeroClass, HeroClassService>
+{
+	void fillPrimarySkillData(const JsonNode & node, CHeroClass * heroClass, PrimarySkill pSkill) const;
+
+public:
+	std::vector<JsonNode> loadLegacyData() override;
+
+	void afterLoadFinalization() override;
+
+	~CHeroClassHandler();
+
+protected:
+	const std::vector<std::string> & getTypeNames() const override;
+	std::shared_ptr<CHeroClass> loadFromJson(const std::string & scope, const JsonNode & node, const std::string & identifier, size_t index) override;
+};
+
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/entities/hero/CHero.cpp vcmi/lib/entities/hero/CHero.cpp
--- vcmi-1.5.7/lib/entities/hero/CHero.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/entities/hero/CHero.cpp	2024-12-19 15:00:22.898147938 +0100
@@ -0,0 +1,114 @@
+/*
+ * CHero.cpp, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#include "StdInc.h"
+#include "CHero.h"
+
+#include "../../VCMI_Lib.h"
+#include "../../texts/CGeneralTextHandler.h"
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+CHero::CHero() = default;
+CHero::~CHero() = default;
+
+int32_t CHero::getIndex() const
+{
+	return ID.getNum();
+}
+
+int32_t CHero::getIconIndex() const
+{
+	return imageIndex;
+}
+
+std::string CHero::getJsonKey() const
+{
+	return modScope + ':' + identifier;
+}
+
+std::string CHero::getModScope() const
+{
+	return modScope;
+}
+
+HeroTypeID CHero::getId() const
+{
+	return ID;
+}
+
+std::string CHero::getNameTranslated() const
+{
+	return VLC->generaltexth->translate(getNameTextID());
+}
+
+std::string CHero::getBiographyTranslated() const
+{
+	return VLC->generaltexth->translate(getBiographyTextID());
+}
+
+std::string CHero::getSpecialtyNameTranslated() const
+{
+	return VLC->generaltexth->translate(getSpecialtyNameTextID());
+}
+
+std::string CHero::getSpecialtyDescriptionTranslated() const
+{
+	return VLC->generaltexth->translate(getSpecialtyDescriptionTextID());
+}
+
+std::string CHero::getSpecialtyTooltipTranslated() const
+{
+	return VLC->generaltexth->translate(getSpecialtyTooltipTextID());
+}
+
+std::string CHero::getNameTextID() const
+{
+	return TextIdentifier("hero", modScope, identifier, "name").get();
+}
+
+std::string CHero::getBiographyTextID() const
+{
+	return TextIdentifier("hero", modScope, identifier, "biography").get();
+}
+
+std::string CHero::getSpecialtyNameTextID() const
+{
+	return TextIdentifier("hero", modScope, identifier, "specialty", "name").get();
+}
+
+std::string CHero::getSpecialtyDescriptionTextID() const
+{
+	return TextIdentifier("hero", modScope, identifier, "specialty", "description").get();
+}
+
+std::string CHero::getSpecialtyTooltipTextID() const
+{
+	return TextIdentifier("hero", modScope, identifier, "specialty", "tooltip").get();
+}
+
+void CHero::registerIcons(const IconRegistar & cb) const
+{
+	cb(getIconIndex(), 0, "UN32", iconSpecSmall);
+	cb(getIconIndex(), 0, "UN44", iconSpecLarge);
+	cb(getIconIndex(), 0, "PORTRAITSLARGE", portraitLarge);
+	cb(getIconIndex(), 0, "PORTRAITSSMALL", portraitSmall);
+}
+
+void CHero::updateFrom(const JsonNode & data)
+{
+	//todo: CHero::updateFrom
+}
+
+void CHero::serializeJson(JsonSerializeFormat & handler)
+{
+
+}
+
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/entities/hero/CHero.h vcmi/lib/entities/hero/CHero.h
--- vcmi-1.5.7/lib/entities/hero/CHero.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/entities/hero/CHero.h	2024-12-19 15:00:22.898147938 +0100
@@ -0,0 +1,87 @@
+/*
+ * CHero.h, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#pragma once
+
+#include <vcmi/HeroType.h>
+
+#include "EHeroGender.h"
+
+#include "../../bonuses/BonusList.h"
+#include "../../constants/EntityIdentifiers.h"
+#include "../../filesystem/ResourcePath.h"
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+class DLL_LINKAGE CHero : public HeroType
+{
+	friend class CHeroHandler;
+
+	HeroTypeID ID;
+	std::string identifier;
+	std::string modScope;
+
+public:
+	struct InitialArmyStack
+	{
+		ui32 minAmount;
+		ui32 maxAmount;
+		CreatureID creature;
+	};
+	si32 imageIndex = 0;
+
+	std::vector<InitialArmyStack> initialArmy;
+
+	const CHeroClass * heroClass = nullptr;
+
+	//initial secondary skills; first - ID of skill, second - level of skill (1 - basic, 2 - adv., 3 - expert)
+	std::vector<std::pair<SecondarySkill, ui8>> secSkillsInit;
+
+	BonusList specialty;
+	std::set<SpellID> spells;
+	bool haveSpellBook = false;
+	bool special = false; // hero is special and won't be placed in game (unless preset on map), e.g. campaign heroes
+	bool onlyOnWaterMap; // hero will be placed only if the map contains water
+	bool onlyOnMapWithoutWater; // hero will be placed only if the map does not contain water
+	EHeroGender gender = EHeroGender::MALE; // default sex: 0=male, 1=female
+
+	/// Graphics
+	std::string iconSpecSmall;
+	std::string iconSpecLarge;
+	std::string portraitSmall;
+	std::string portraitLarge;
+	AnimationPath battleImage;
+
+	CHero();
+	virtual ~CHero();
+
+	int32_t getIndex() const override;
+	int32_t getIconIndex() const override;
+	std::string getJsonKey() const override;
+	std::string getModScope() const override;
+	HeroTypeID getId() const override;
+	void registerIcons(const IconRegistar & cb) const override;
+
+	std::string getNameTranslated() const override;
+	std::string getBiographyTranslated() const override;
+	std::string getSpecialtyNameTranslated() const override;
+	std::string getSpecialtyDescriptionTranslated() const override;
+	std::string getSpecialtyTooltipTranslated() const override;
+
+	std::string getNameTextID() const override;
+	std::string getBiographyTextID() const override;
+	std::string getSpecialtyNameTextID() const override;
+	std::string getSpecialtyDescriptionTextID() const override;
+	std::string getSpecialtyTooltipTextID() const override;
+
+	void updateFrom(const JsonNode & data);
+	void serializeJson(JsonSerializeFormat & handler);
+};
+
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/entities/hero/CHeroHandler.cpp vcmi/lib/entities/hero/CHeroHandler.cpp
--- vcmi-1.5.7/lib/entities/hero/CHeroHandler.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/entities/hero/CHeroHandler.cpp	2024-12-19 15:00:22.899147979 +0100
@@ -0,0 +1,424 @@
+/*
+ * CHeroHandler.cpp, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#include "StdInc.h"
+#include "CHeroHandler.h"
+
+#include "CHero.h"
+
+#include "../../VCMI_Lib.h"
+#include "../../constants/StringConstants.h"
+#include "../../CCreatureHandler.h"
+#include "../../IGameSettings.h"
+#include "../../bonuses/Limiters.h"
+#include "../../bonuses/Updaters.h"
+#include "../../json/JsonBonus.h"
+#include "../../json/JsonUtils.h"
+#include "../../modding/IdentifierStorage.h"
+#include "../../texts/CGeneralTextHandler.h"
+#include "../../texts/CLegacyConfigParser.h"
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+CHeroHandler::~CHeroHandler() = default;
+
+CHeroHandler::CHeroHandler()
+{
+	loadExperience();
+}
+
+const std::vector<std::string> & CHeroHandler::getTypeNames() const
+{
+	static const std::vector<std::string> typeNames = { "hero" };
+	return typeNames;
+}
+
+std::shared_ptr<CHero> CHeroHandler::loadFromJson(const std::string & scope, const JsonNode & node, const std::string & identifier, size_t index)
+{
+	assert(identifier.find(':') == std::string::npos);
+	assert(!scope.empty());
+
+	auto hero = std::make_shared<CHero>();
+	hero->ID = HeroTypeID(index);
+	hero->identifier = identifier;
+	hero->modScope = scope;
+	hero->gender = node["female"].Bool() ? EHeroGender::FEMALE : EHeroGender::MALE;
+	hero->special = node["special"].Bool();
+	//Default - both false
+	hero->onlyOnWaterMap = node["onlyOnWaterMap"].Bool();
+	hero->onlyOnMapWithoutWater = node["onlyOnMapWithoutWater"].Bool();
+
+	VLC->generaltexth->registerString(scope, hero->getNameTextID(), node["texts"]["name"]);
+	VLC->generaltexth->registerString(scope, hero->getBiographyTextID(), node["texts"]["biography"]);
+	VLC->generaltexth->registerString(scope, hero->getSpecialtyNameTextID(), node["texts"]["specialty"]["name"]);
+	VLC->generaltexth->registerString(scope, hero->getSpecialtyTooltipTextID(), node["texts"]["specialty"]["tooltip"]);
+	VLC->generaltexth->registerString(scope, hero->getSpecialtyDescriptionTextID(), node["texts"]["specialty"]["description"]);
+
+	hero->iconSpecSmall = node["images"]["specialtySmall"].String();
+	hero->iconSpecLarge = node["images"]["specialtyLarge"].String();
+	hero->portraitSmall = node["images"]["small"].String();
+	hero->portraitLarge = node["images"]["large"].String();
+	hero->battleImage = AnimationPath::fromJson(node["battleImage"]);
+
+	loadHeroArmy(hero.get(), node);
+	loadHeroSkills(hero.get(), node);
+	loadHeroSpecialty(hero.get(), node);
+
+	VLC->identifiers()->requestIdentifier("heroClass", node["class"],
+	[=](si32 classID)
+	{
+		hero->heroClass = HeroClassID(classID).toHeroClass();
+	});
+
+	return hero;
+}
+
+void CHeroHandler::loadHeroArmy(CHero * hero, const JsonNode & node) const
+{
+	assert(node["army"].Vector().size() <= 3); // anything bigger is useless - army initialization uses up to 3 slots
+
+	hero->initialArmy.resize(node["army"].Vector().size());
+
+	for (size_t i=0; i< hero->initialArmy.size(); i++)
+	{
+		const JsonNode & source = node["army"].Vector()[i];
+
+		hero->initialArmy[i].minAmount = static_cast<ui32>(source["min"].Float());
+		hero->initialArmy[i].maxAmount = static_cast<ui32>(source["max"].Float());
+
+		if (hero->initialArmy[i].minAmount > hero->initialArmy[i].maxAmount)
+		{
+			logMod->error("Hero %s has minimal army size (%d) greater than maximal size (%d)!", hero->getJsonKey(), hero->initialArmy[i].minAmount, hero->initialArmy[i].maxAmount);
+			std::swap(hero->initialArmy[i].minAmount, hero->initialArmy[i].maxAmount);
+		}
+
+		VLC->identifiers()->requestIdentifier("creature", source["creature"], [=](si32 creature)
+		{
+			hero->initialArmy[i].creature = CreatureID(creature);
+		});
+	}
+}
+
+void CHeroHandler::loadHeroSkills(CHero * hero, const JsonNode & node) const
+{
+	for(const JsonNode &set : node["skills"].Vector())
+	{
+		int skillLevel = static_cast<int>(boost::range::find(NSecondarySkill::levels, set["level"].String()) - std::begin(NSecondarySkill::levels));
+		if (skillLevel < MasteryLevel::LEVELS_SIZE)
+		{
+			size_t currentIndex = hero->secSkillsInit.size();
+			hero->secSkillsInit.emplace_back(SecondarySkill(-1), skillLevel);
+
+			VLC->identifiers()->requestIdentifier("skill", set["skill"], [=](si32 id)
+			{
+				hero->secSkillsInit[currentIndex].first = SecondarySkill(id);
+			});
+		}
+		else
+		{
+			logMod->error("Unknown skill level: %s", set["level"].String());
+		}
+	}
+
+	// spellbook is considered present if hero have "spellbook" entry even when this is an empty set (0 spells)
+	hero->haveSpellBook = !node["spellbook"].isNull();
+
+	for(const JsonNode & spell : node["spellbook"].Vector())
+	{
+		VLC->identifiers()->requestIdentifier("spell", spell,
+		[=](si32 spellID)
+		{
+			hero->spells.insert(SpellID(spellID));
+		});
+	}
+}
+
+/// creates standard H3 hero specialty for creatures
+static std::vector<std::shared_ptr<Bonus>> createCreatureSpecialty(CreatureID baseCreatureID)
+{
+	std::vector<std::shared_ptr<Bonus>> result;
+	std::set<CreatureID> targets;
+	targets.insert(baseCreatureID);
+
+	// go through entire upgrade chain and collect all creatures to which baseCreatureID can be upgraded
+	for (;;)
+	{
+		std::set<CreatureID> oldTargets = targets;
+
+		for(const auto & upgradeSourceID : oldTargets)
+		{
+			const CCreature * upgradeSource = upgradeSourceID.toCreature();
+			targets.insert(upgradeSource->upgrades.begin(), upgradeSource->upgrades.end());
+		}
+
+		if (oldTargets.size() == targets.size())
+			break;
+	}
+
+	for(CreatureID cid : targets)
+	{
+		const auto & specCreature = *cid.toCreature();
+		int stepSize = specCreature.getLevel() ? specCreature.getLevel() : 5;
+
+		{
+			auto bonus = std::make_shared<Bonus>();
+			bonus->limiter.reset(new CCreatureTypeLimiter(specCreature, false));
+			bonus->type = BonusType::STACKS_SPEED;
+			bonus->val = 1;
+			result.push_back(bonus);
+		}
+
+		{
+			auto bonus = std::make_shared<Bonus>();
+			bonus->type = BonusType::PRIMARY_SKILL;
+			bonus->subtype = BonusSubtypeID(PrimarySkill::ATTACK);
+			bonus->val = 0;
+			bonus->limiter.reset(new CCreatureTypeLimiter(specCreature, false));
+			bonus->updater.reset(new GrowsWithLevelUpdater(specCreature.getAttack(false), stepSize));
+			result.push_back(bonus);
+		}
+
+		{
+			auto bonus = std::make_shared<Bonus>();
+			bonus->type = BonusType::PRIMARY_SKILL;
+			bonus->subtype = BonusSubtypeID(PrimarySkill::DEFENSE);
+			bonus->val = 0;
+			bonus->limiter.reset(new CCreatureTypeLimiter(specCreature, false));
+			bonus->updater.reset(new GrowsWithLevelUpdater(specCreature.getDefense(false), stepSize));
+			result.push_back(bonus);
+		}
+	}
+
+	return result;
+}
+
+void CHeroHandler::beforeValidate(JsonNode & object)
+{
+	//handle "base" specialty info
+	JsonNode & specialtyNode = object["specialty"];
+	if(specialtyNode.getType() == JsonNode::JsonType::DATA_STRUCT)
+	{
+		const JsonNode & base = specialtyNode["base"];
+		if(!base.isNull())
+		{
+			if(specialtyNode["bonuses"].isNull())
+			{
+				logMod->warn("specialty has base without bonuses");
+			}
+			else
+			{
+				JsonMap & bonuses = specialtyNode["bonuses"].Struct();
+				for(std::pair<std::string, JsonNode> keyValue : bonuses)
+					JsonUtils::inherit(bonuses[keyValue.first], base);
+			}
+		}
+	}
+}
+
+void CHeroHandler::afterLoadFinalization()
+{
+	for(const auto & functor : callAfterLoadFinalization)
+		functor();
+
+	callAfterLoadFinalization.clear();
+}
+
+void CHeroHandler::loadHeroSpecialty(CHero * hero, const JsonNode & node)
+{
+	auto prepSpec = [=](std::shared_ptr<Bonus> bonus)
+	{
+		bonus->duration = BonusDuration::PERMANENT;
+		bonus->source = BonusSource::HERO_SPECIAL;
+		bonus->sid = BonusSourceID(hero->getId());
+		return bonus;
+	};
+
+	//new format, using bonus system
+	const JsonNode & specialtyNode = node["specialty"];
+	if(specialtyNode.getType() != JsonNode::JsonType::DATA_STRUCT)
+	{
+		logMod->error("Unsupported speciality format for hero %s!", hero->getNameTranslated());
+		return;
+	}
+
+	//creature specialty - alias for simplicity
+	if(!specialtyNode["creature"].isNull())
+	{
+		JsonNode creatureNode = specialtyNode["creature"];
+
+		std::function<void()> specialtyLoader = [creatureNode, hero, prepSpec]
+		{
+			VLC->identifiers()->requestIdentifier("creature", creatureNode, [hero, prepSpec](si32 creature)
+			{
+				for (const auto & bonus : createCreatureSpecialty(CreatureID(creature)))
+					hero->specialty.push_back(prepSpec(bonus));
+			});
+		};
+
+		callAfterLoadFinalization.push_back(specialtyLoader);
+	}
+
+	for(const auto & keyValue : specialtyNode["bonuses"].Struct())
+		hero->specialty.push_back(prepSpec(JsonUtils::parseBonus(keyValue.second)));
+}
+
+void CHeroHandler::loadExperience()
+{
+	expPerLevel.push_back(0);
+	expPerLevel.push_back(1000);
+	expPerLevel.push_back(2000);
+	expPerLevel.push_back(3200);
+	expPerLevel.push_back(4600);
+	expPerLevel.push_back(6200);
+	expPerLevel.push_back(8000);
+	expPerLevel.push_back(10000);
+	expPerLevel.push_back(12200);
+	expPerLevel.push_back(14700);
+	expPerLevel.push_back(17500);
+	expPerLevel.push_back(20600);
+	expPerLevel.push_back(24320);
+	expPerLevel.push_back(28784);
+	expPerLevel.push_back(34140);
+
+	for (;;)
+	{
+		auto i = expPerLevel.size() - 1;
+		auto currExp = expPerLevel[i];
+		auto prevExp = expPerLevel[i-1];
+		auto prevDiff = currExp - prevExp;
+		auto nextDiff = prevDiff + prevDiff / 5;
+		auto maxExp = std::numeric_limits<decltype(currExp)>::max();
+
+		if (currExp > maxExp - nextDiff)
+			break; // overflow point reached
+
+		expPerLevel.push_back (currExp + nextDiff);
+	}
+}
+
+/// convert h3-style ID (e.g. Gobin Wolf Rider) to vcmi (e.g. goblinWolfRider)
+static std::string genRefName(std::string input)
+{
+	boost::algorithm::replace_all(input, " ", ""); //remove spaces
+	input[0] = std::tolower(input[0]); // to camelCase
+	return input;
+}
+
+std::vector<JsonNode> CHeroHandler::loadLegacyData()
+{
+	size_t dataSize = VLC->engineSettings()->getInteger(EGameSettings::TEXTS_HERO);
+
+	objects.resize(dataSize);
+	std::vector<JsonNode> h3Data;
+	h3Data.reserve(dataSize);
+
+	CLegacyConfigParser specParser(TextPath::builtin("DATA/HEROSPEC.TXT"));
+	CLegacyConfigParser bioParser(TextPath::builtin("DATA/HEROBIOS.TXT"));
+	CLegacyConfigParser parser(TextPath::builtin("DATA/HOTRAITS.TXT"));
+
+	parser.endLine(); //ignore header
+	parser.endLine();
+
+	specParser.endLine(); //ignore header
+	specParser.endLine();
+
+	for (int i=0; i<GameConstants::HEROES_QUANTITY; i++)
+	{
+		JsonNode heroData;
+
+		heroData["texts"]["name"].String() = parser.readString();
+		heroData["texts"]["biography"].String() = bioParser.readString();
+		heroData["texts"]["specialty"]["name"].String() = specParser.readString();
+		heroData["texts"]["specialty"]["tooltip"].String() = specParser.readString();
+		heroData["texts"]["specialty"]["description"].String() = specParser.readString();
+
+		for(int x=0;x<3;x++)
+		{
+			JsonNode armySlot;
+			armySlot["min"].Float() = parser.readNumber();
+			armySlot["max"].Float() = parser.readNumber();
+			armySlot["creature"].String() = genRefName(parser.readString());
+
+			heroData["army"].Vector().push_back(armySlot);
+		}
+		parser.endLine();
+		specParser.endLine();
+		bioParser.endLine();
+
+		h3Data.push_back(heroData);
+	}
+	return h3Data;
+}
+
+void CHeroHandler::loadObject(std::string scope, std::string name, const JsonNode & data)
+{
+	size_t index = objects.size();
+	static const int specialFramesCount = 2; // reserved for 2 special frames
+	auto object = loadFromJson(scope, data, name, index);
+	object->imageIndex = static_cast<si32>(index) + specialFramesCount;
+
+	objects.emplace_back(object);
+
+	registerObject(scope, "hero", name, object->getIndex());
+
+	for(const auto & compatID : data["compatibilityIdentifiers"].Vector())
+		registerObject(scope, "hero", compatID.String(), object->getIndex());
+}
+
+void CHeroHandler::loadObject(std::string scope, std::string name, const JsonNode & data, size_t index)
+{
+	auto object = loadFromJson(scope, data, name, index);
+	object->imageIndex = static_cast<si32>(index);
+
+	assert(objects[index] == nullptr); // ensure that this id was not loaded before
+	objects[index] = object;
+
+	registerObject(scope, "hero", name, object->getIndex());
+	for(const auto & compatID : data["compatibilityIdentifiers"].Vector())
+		registerObject(scope, "hero", compatID.String(), object->getIndex());
+}
+
+ui32 CHeroHandler::level (TExpType experience) const
+{
+	return static_cast<ui32>(boost::range::upper_bound(expPerLevel, experience) - std::begin(expPerLevel));
+}
+
+TExpType CHeroHandler::reqExp (ui32 level) const
+{
+	if(!level)
+		return 0;
+
+	if (level <= expPerLevel.size())
+	{
+		return expPerLevel[level-1];
+	}
+	else
+	{
+		logGlobal->warn("A hero has reached unsupported amount of experience");
+		return expPerLevel[expPerLevel.size()-1];
+	}
+}
+
+ui32 CHeroHandler::maxSupportedLevel() const
+{
+	return expPerLevel.size();
+}
+
+std::set<HeroTypeID> CHeroHandler::getDefaultAllowed() const
+{
+	std::set<HeroTypeID> result;
+
+	for(auto & hero : objects)
+		if (hero && !hero->special)
+			result.insert(hero->getId());
+
+	return result;
+}
+
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/entities/hero/CHeroHandler.h vcmi/lib/entities/hero/CHeroHandler.h
--- vcmi-1.5.7/lib/entities/hero/CHeroHandler.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/entities/hero/CHeroHandler.h	2024-12-19 15:00:22.899147979 +0100
@@ -0,0 +1,59 @@
+/*
+ * CHeroHandler.h, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#pragma once
+
+#include <vcmi/HeroTypeService.h>
+
+#include "CHero.h" // convenience include - users of handler generally also use its entity
+
+
+#include "../../GameConstants.h"
+#include "../../IHandlerBase.h"
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+class DLL_LINKAGE CHeroHandler : public CHandlerBase<HeroTypeID, HeroType, CHero, HeroTypeService>
+{
+	/// expPerLEvel[i] is amount of exp needed to reach level i;
+	/// consists of 196 values. Any higher levels require experience larger that TExpType can hold
+	std::vector<TExpType> expPerLevel;
+
+	/// helpers for loading to avoid huge load functions
+	void loadHeroArmy(CHero * hero, const JsonNode & node) const;
+	void loadHeroSkills(CHero * hero, const JsonNode & node) const;
+	void loadHeroSpecialty(CHero * hero, const JsonNode & node);
+
+	void loadExperience();
+
+	std::vector<std::function<void()>> callAfterLoadFinalization;
+
+public:
+	ui32 level(TExpType experience) const; //calculates level corresponding to given experience amount
+	TExpType reqExp(ui32 level) const; //calculates experience required for given level
+	ui32 maxSupportedLevel() const;
+
+	std::vector<JsonNode> loadLegacyData() override;
+
+	void beforeValidate(JsonNode & object) override;
+	void loadObject(std::string scope, std::string name, const JsonNode & data) override;
+	void loadObject(std::string scope, std::string name, const JsonNode & data, size_t index) override;
+	void afterLoadFinalization() override;
+
+	CHeroHandler();
+	~CHeroHandler();
+
+	std::set<HeroTypeID> getDefaultAllowed() const;
+
+protected:
+	const std::vector<std::string> & getTypeNames() const override;
+	std::shared_ptr<CHero> loadFromJson(const std::string & scope, const JsonNode & node, const std::string & identifier, size_t index) override;
+};
+
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/entities/hero/EHeroGender.h vcmi/lib/entities/hero/EHeroGender.h
--- vcmi-1.5.7/lib/entities/hero/EHeroGender.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/entities/hero/EHeroGender.h	2024-12-19 15:00:22.899147979 +0100
@@ -0,0 +1,21 @@
+/*
+ * EHeroGender.h, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#pragma once
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+	enum class EHeroGender : int8_t
+{
+	DEFAULT = -1, // from h3m, instance has same gender as hero type
+	MALE = 0,
+	FEMALE = 1,
+};
+
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/events/ApplyDamage.cpp vcmi/lib/events/ApplyDamage.cpp
--- vcmi-1.5.7/lib/events/ApplyDamage.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/events/ApplyDamage.cpp	2024-12-19 15:00:22.899147979 +0100
@@ -29,7 +29,7 @@
 	: pack(pack_),
 	target(std::move(target_))
 {
-	initalDamage = pack->damageAmount;
+	initialDamage = pack->damageAmount;
 }
 
 bool CApplyDamage::isEnabled() const
@@ -37,9 +37,9 @@
 	return true;
 }
 
-int64_t CApplyDamage::getInitalDamage() const
+int64_t CApplyDamage::getInitialDamage() const
 {
-	return initalDamage;
+	return initialDamage;
 }
 
 int64_t CApplyDamage::getDamage() const
diff --color -urN vcmi-1.5.7/lib/events/ApplyDamage.h vcmi/lib/events/ApplyDamage.h
--- vcmi-1.5.7/lib/events/ApplyDamage.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/events/ApplyDamage.h	2024-12-19 15:00:22.899147979 +0100
@@ -23,12 +23,12 @@
 	CApplyDamage(const Environment * env_, BattleStackAttacked * pack_, std::shared_ptr<battle::Unit> target_);
 
 	bool isEnabled() const override;
-	int64_t getInitalDamage() const override;
+	int64_t getInitialDamage() const override;
 	int64_t getDamage() const override;
 	void setDamage(int64_t value) override;
 	const battle::Unit * getTarget() const override;
 private:
-	int64_t initalDamage;
+	int64_t initialDamage;
 
 	BattleStackAttacked * pack;
 	std::shared_ptr<battle::Unit> target;
diff --color -urN vcmi-1.5.7/lib/filesystem/AdapterLoaders.cpp vcmi/lib/filesystem/AdapterLoaders.cpp
--- vcmi-1.5.7/lib/filesystem/AdapterLoaders.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/filesystem/AdapterLoaders.cpp	2024-12-19 15:00:22.900148020 +0100
@@ -68,10 +68,8 @@
 {
 	// load resource from last loader that have it (last overridden version)
 	for(const auto & loader : boost::adaptors::reverse(loaders))
-	{
 		if (loader->existsResource(resourceName))
 			return loader->load(resourceName);
-	}
 
 	throw std::runtime_error("Resource with name " + resourceName.getName() + " and type "
 		+ EResTypeHelper::getEResTypeAsString(resourceName.getType()) + " wasn't found.");
diff --color -urN vcmi-1.5.7/lib/filesystem/CArchiveLoader.cpp vcmi/lib/filesystem/CArchiveLoader.cpp
--- vcmi-1.5.7/lib/filesystem/CArchiveLoader.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/filesystem/CArchiveLoader.cpp	2024-12-19 15:00:22.900148020 +0100
@@ -197,6 +197,11 @@
 	return mountPoint;
 }
 
+const std::unordered_map<ResourcePath, ArchiveEntry> & CArchiveLoader::getEntries() const
+{
+	return entries;
+}
+
 std::unordered_set<ResourcePath> CArchiveLoader::getFilteredFiles(std::function<bool(const ResourcePath &)> filter) const
 {
 	std::unordered_set<ResourcePath> foundID;
@@ -209,7 +214,7 @@
 	return foundID;
 }
 
-void CArchiveLoader::extractToFolder(const std::string & outputSubFolder, CInputStream & fileStream, const ArchiveEntry & entry) const
+void CArchiveLoader::extractToFolder(const std::string & outputSubFolder, CInputStream & fileStream, const ArchiveEntry & entry, bool absolute) const
 {
 	si64 currentPosition = fileStream.tell(); // save filestream position
 
@@ -217,7 +222,7 @@
 	fileStream.seek(entry.offset);
 	fileStream.read(data.data(), entry.fullSize);
 
-	boost::filesystem::path extractedFilePath = createExtractedFilePath(outputSubFolder, entry.name);
+	boost::filesystem::path extractedFilePath = createExtractedFilePath(outputSubFolder, entry.name, absolute);
 
 	// writeToOutputFile
 	std::ofstream out(extractedFilePath.string(), std::ofstream::binary);
@@ -227,17 +232,17 @@
 	fileStream.seek(currentPosition); // restore filestream position
 }
 
-void CArchiveLoader::extractToFolder(const std::string & outputSubFolder, const std::string & mountPoint, ArchiveEntry entry) const
+void CArchiveLoader::extractToFolder(const std::string & outputSubFolder, const std::string & mountPoint, ArchiveEntry entry, bool absolute) const
 {
 	std::unique_ptr<CInputStream> inputStream = load(ResourcePath(mountPoint + entry.name));
 
 	entry.offset = 0;
-	extractToFolder(outputSubFolder, *inputStream, entry);
+	extractToFolder(outputSubFolder, *inputStream, entry, absolute);
 }
 
-boost::filesystem::path createExtractedFilePath(const std::string & outputSubFolder, const std::string & entryName)
+boost::filesystem::path createExtractedFilePath(const std::string & outputSubFolder, const std::string & entryName, bool absolute)
 {
-	boost::filesystem::path extractionFolderPath = VCMIDirs::get().userExtractedPath() / outputSubFolder;
+	boost::filesystem::path extractionFolderPath = absolute ? outputSubFolder : VCMIDirs::get().userExtractedPath() / outputSubFolder;
 	boost::filesystem::path extractedFilePath = extractionFolderPath / entryName;
 
 	boost::filesystem::create_directories(extractionFolderPath);
diff --color -urN vcmi-1.5.7/lib/filesystem/CArchiveLoader.h vcmi/lib/filesystem/CArchiveLoader.h
--- vcmi-1.5.7/lib/filesystem/CArchiveLoader.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/filesystem/CArchiveLoader.h	2024-12-19 15:00:22.900148020 +0100
@@ -63,12 +63,13 @@
 	std::unique_ptr<CInputStream> load(const ResourcePath & resourceName) const override;
 	bool existsResource(const ResourcePath & resourceName) const override;
 	std::string getMountPoint() const override;
+	const std::unordered_map<ResourcePath, ArchiveEntry> & getEntries() const;
 	void updateFilteredFiles(std::function<bool(const std::string &)> filter) const override {}
 	std::unordered_set<ResourcePath> getFilteredFiles(std::function<bool(const ResourcePath &)> filter) const override;
 	/** Extracts one archive entry to the specified subfolder. Used for Video and Sound */
-	void extractToFolder(const std::string & outputSubFolder, CInputStream & fileStream, const ArchiveEntry & entry) const;
+	void extractToFolder(const std::string & outputSubFolder, CInputStream & fileStream, const ArchiveEntry & entry, bool absolute = false) const;
 	/** Extracts one archive entry to the specified subfolder. Used for Images, Sprites, etc */
-	void extractToFolder(const std::string & outputSubFolder, const std::string & mountPoint, ArchiveEntry entry) const;
+	void extractToFolder(const std::string & outputSubFolder, const std::string & mountPoint, ArchiveEntry entry, bool absolute = false) const;
 
 private:
 	/**
@@ -105,6 +106,6 @@
 };
 
 /** Constructs the file path for the extracted file. Creates the subfolder hierarchy aswell **/
-boost::filesystem::path createExtractedFilePath(const std::string & outputSubFolder, const std::string & entryName);
+boost::filesystem::path createExtractedFilePath(const std::string & outputSubFolder, const std::string & entryName, bool absolute);
 
 VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/filesystem/CBinaryReader.cpp vcmi/lib/filesystem/CBinaryReader.cpp
--- vcmi-1.5.7/lib/filesystem/CBinaryReader.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/filesystem/CBinaryReader.cpp	2024-12-19 15:00:22.900148020 +0100
@@ -11,7 +11,6 @@
 #include "CBinaryReader.h"
 
 #include "CInputStream.h"
-#include "../TextOperations.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
diff --color -urN vcmi-1.5.7/lib/filesystem/CCompressedStream.cpp vcmi/lib/filesystem/CCompressedStream.cpp
--- vcmi-1.5.7/lib/filesystem/CCompressedStream.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/filesystem/CCompressedStream.cpp	2024-12-19 15:00:22.900148020 +0100
@@ -136,6 +136,9 @@
 	{
 		if (inflateState->avail_in == 0)
 		{
+			if (gzipStream == nullptr)
+				throw std::runtime_error("Potentially truncated gzip file");
+
 			//inflate ran out of available data or was not initialized yet
 			// get new input data and update state accordingly
 			si64 availSize = gzipStream->read(compressedBuffer.data(), compressedBuffer.size());
diff --color -urN vcmi-1.5.7/lib/filesystem/CCompressedStream.h vcmi/lib/filesystem/CCompressedStream.h
--- vcmi-1.5.7/lib/filesystem/CCompressedStream.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/filesystem/CCompressedStream.h	2024-12-19 15:00:22.901148061 +0100
@@ -103,8 +103,8 @@
 	/**
 	 * C-tor.
 	 *
-	 * @param stream - stream with compresed data
-	 * @param gzip - this is gzipp'ed file e.g. campaign or maps, false for files in lod
+	 * @param stream - stream with compressed data
+	 * @param gzip - this is gzipp'ed file e.g. campaign or maps, false for files in .lod
 	 * @param decompressedSize - optional parameter to hint size of decompressed data
 	 */
 	CCompressedStream(std::unique_ptr<CInputStream> stream, bool gzip, size_t decompressedSize=0);
@@ -136,7 +136,7 @@
 
 	enum EState
 	{
-		ERROR_OCCURED,
+		ERROR_OCCURRED,
 		INITIALIZED,
 		IN_PROGRESS,
 		STREAM_END,
diff --color -urN vcmi-1.5.7/lib/filesystem/CFilesystemLoader.cpp vcmi/lib/filesystem/CFilesystemLoader.cpp
--- vcmi-1.5.7/lib/filesystem/CFilesystemLoader.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/filesystem/CFilesystemLoader.cpp	2024-12-19 15:00:22.901148061 +0100
@@ -118,10 +118,11 @@
 		EResType::ARCHIVE_SND,
 		EResType::ARCHIVE_ZIP };
 	static const std::set<EResType> initialTypes(initArray, initArray + std::size(initArray));
-
-	assert(boost::filesystem::is_directory(baseDirectory));
 	std::unordered_map<ResourcePath, boost::filesystem::path> fileList;
 
+	if(!boost::filesystem::is_directory(baseDirectory))
+		return fileList;
+
 	std::vector<boost::filesystem::path> path; //vector holding relative path to our file
 
 	boost::filesystem::recursive_directory_iterator enddir;
diff --color -urN vcmi-1.5.7/lib/filesystem/Filesystem.cpp vcmi/lib/filesystem/Filesystem.cpp
--- vcmi-1.5.7/lib/filesystem/Filesystem.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/filesystem/Filesystem.cpp	2024-12-19 15:00:22.902148103 +0100
@@ -117,7 +117,7 @@
 	if (filename)
 	{
 		auto configData = CResourceHandler::get("initial")->load(JsonPath::builtin(URI))->readAll();
-		const JsonNode configInitial(reinterpret_cast<std::byte *>(configData.first.get()), configData.second);
+		const JsonNode configInitial(reinterpret_cast<std::byte *>(configData.first.get()), configData.second, URI);
 		filesystem->addLoader(new CMappedFileLoader(mountPoint, configInitial), false);
 	}
 }
@@ -183,9 +183,16 @@
 	knownLoaders["saves"] = new CFilesystemLoader("SAVES/", VCMIDirs::get().userSavePath());
 	knownLoaders["config"] = new CFilesystemLoader("CONFIG/", VCMIDirs::get().userConfigPath());
 
+	if(boost::filesystem::is_directory(VCMIDirs::get().userDataPath() / "Generated"))
+		boost::filesystem::remove_all(VCMIDirs::get().userDataPath() / "Generated");
+	knownLoaders["gen_data"] = new CFilesystemLoader("DATA/", VCMIDirs::get().userDataPath() / "Generated" / "Data");
+	knownLoaders["gen_sprites"] = new CFilesystemLoader("SPRITES/", VCMIDirs::get().userDataPath() / "Generated" / "Sprites");
+
 	auto * localFS = new CFilesystemList();
 	localFS->addLoader(knownLoaders["saves"], true);
 	localFS->addLoader(knownLoaders["config"], true);
+	localFS->addLoader(knownLoaders["gen_data"], true);
+	localFS->addLoader(knownLoaders["gen_sprites"], true);
 
 	addFilesystem("root", "initial", createInitial());
 	addFilesystem("root", "data", new CFilesystemList());
@@ -205,6 +212,7 @@
 
 ISimpleResourceLoader * CResourceHandler::get(const std::string & identifier)
 {
+	assert(knownLoaders.count(identifier));
 	return knownLoaders.at(identifier);
 }
 
@@ -212,7 +220,7 @@
 {
 	auto fsConfigData = get("initial")->load(JsonPath::builtin(fsConfigURI))->readAll();
 
-	const JsonNode fsConfig(reinterpret_cast<std::byte *>(fsConfigData.first.get()), fsConfigData.second);
+	const JsonNode fsConfig(reinterpret_cast<std::byte *>(fsConfigData.first.get()), fsConfigData.second, fsConfigURI);
 
 	addFilesystem("data", ModScope::scopeBuiltin(), createFileSystem("", fsConfig["filesystem"], extractArchives));
 }
diff --color -urN vcmi-1.5.7/lib/filesystem/Filesystem.h vcmi/lib/filesystem/Filesystem.h
--- vcmi-1.5.7/lib/filesystem/Filesystem.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/filesystem/Filesystem.h	2024-12-19 15:00:22.902148103 +0100
@@ -101,7 +101,7 @@
 	static void addFilesystem(const std::string & parent, const std::string & identifier, ISimpleResourceLoader * loader);
 	
 	/**
-	 * @brief removeFilesystem removes previously added filesystem from global resouce holder
+	 * @brief removeFilesystem removes previously added filesystem from global resource holder
 	 * @param parent parent loader containing filesystem
 	 * @param identifier name of this loader
 	 * @return if filesystem was successfully removed
diff --color -urN vcmi-1.5.7/lib/filesystem/ISimpleResourceLoader.h vcmi/lib/filesystem/ISimpleResourceLoader.h
--- vcmi-1.5.7/lib/filesystem/ISimpleResourceLoader.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/filesystem/ISimpleResourceLoader.h	2024-12-19 15:00:22.902148103 +0100
@@ -25,7 +25,7 @@
 	/**
 	 * Loads a resource with the given resource name.
 	 *
-	 * @param resourceName The unqiue resource name in space of the archive.
+	 * @param resourceName The unique resource name in space of the archive.
 	 * @return a input stream object
 	 */
 	virtual std::unique_ptr<CInputStream> load(const ResourcePath & resourceName) const = 0;
diff --color -urN vcmi-1.5.7/lib/filesystem/ResourcePath.cpp vcmi/lib/filesystem/ResourcePath.cpp
--- vcmi-1.5.7/lib/filesystem/ResourcePath.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/filesystem/ResourcePath.cpp	2024-12-19 15:00:22.902148103 +0100
@@ -113,11 +113,9 @@
 		{".MP3",   EResType::SOUND},
 		{".OGG",   EResType::SOUND},
 		{".FLAC",  EResType::SOUND},
-		{".SMK",   EResType::VIDEO},
+		{".SMK",   EResType::VIDEO_LOW_QUALITY},
 		{".BIK",   EResType::VIDEO},
-		{".MJPG",  EResType::VIDEO},
-		{".MPG",   EResType::VIDEO},
-		{".AVI",   EResType::VIDEO},
+		{".OGV",   EResType::VIDEO},
 		{".WEBM",  EResType::VIDEO},
 		{".ZIP",   EResType::ARCHIVE_ZIP},
 		{".LOD",   EResType::ARCHIVE_LOD},
@@ -157,6 +155,7 @@
 		MAP_ENUM(TTF_FONT)
 		MAP_ENUM(IMAGE)
 		MAP_ENUM(VIDEO)
+		MAP_ENUM(VIDEO_LOW_QUALITY)
 		MAP_ENUM(SOUND)
 		MAP_ENUM(ARCHIVE_ZIP)
 		MAP_ENUM(ARCHIVE_LOD)
diff --color -urN vcmi-1.5.7/lib/filesystem/ResourcePath.h vcmi/lib/filesystem/ResourcePath.h
--- vcmi-1.5.7/lib/filesystem/ResourcePath.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/filesystem/ResourcePath.h	2024-12-19 15:00:22.903148144 +0100
@@ -28,7 +28,7 @@
  * Font: .fnt
  * Image: .bmp, .jpg, .pcx, .png, .tga
  * Sound: .wav .82m
- * Video: .smk, .bik .mjpg .mpg .webm
+ * Video: .smk, .bik .ogv .webm
  * Music: .mp3, .ogg
  * Archive: .lod, .snd, .vid .pac .zip
  * Palette: .pal
@@ -46,6 +46,7 @@
 	TTF_FONT,
 	IMAGE,
 	VIDEO,
+	VIDEO_LOW_QUALITY,
 	SOUND,
 	ARCHIVE_VID,
 	ARCHIVE_ZIP,
diff --color -urN vcmi-1.5.7/lib/GameSettings.cpp vcmi/lib/GameSettings.cpp
--- vcmi-1.5.7/lib/GameSettings.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/GameSettings.cpp	2024-12-19 15:00:22.854146119 +0100
@@ -33,86 +33,87 @@
 	return getValue(option).convertTo<std::vector<int>>();
 }
 
+GameSettings::GameSettings() = default;
 GameSettings::~GameSettings() = default;
 
-GameSettings::GameSettings()
-	: gameSettings(static_cast<size_t>(EGameSettings::OPTIONS_COUNT))
-{
-}
-
-void GameSettings::load(const JsonNode & input)
-{
-	struct SettingOption
-	{
-		EGameSettings setting;
-		std::string group;
-		std::string key;
+const std::vector<GameSettings::SettingOption> GameSettings::settingProperties = {
+		{EGameSettings::BANKS_SHOW_GUARDS_COMPOSITION,                    "banks",     "showGuardsComposition"                },
+		{EGameSettings::BONUSES_GLOBAL,                                   "bonuses",   "global"                               },
+		{EGameSettings::BONUSES_PER_HERO,                                 "bonuses",   "perHero"                              },
+		{EGameSettings::COMBAT_AREA_SHOT_CAN_TARGET_EMPTY_HEX,            "combat",    "areaShotCanTargetEmptyHex"            },
+		{EGameSettings::COMBAT_ATTACK_POINT_DAMAGE_FACTOR,                "combat",    "attackPointDamageFactor"              },
+		{EGameSettings::COMBAT_ATTACK_POINT_DAMAGE_FACTOR_CAP,            "combat",    "attackPointDamageFactorCap"           },
+		{EGameSettings::COMBAT_BAD_LUCK_DICE,                             "combat",    "badLuckDice"                          },
+		{EGameSettings::COMBAT_BAD_MORALE_DICE,                           "combat",    "badMoraleDice"                        },
+		{EGameSettings::COMBAT_DEFENSE_POINT_DAMAGE_FACTOR,               "combat",    "defensePointDamageFactor"             },
+		{EGameSettings::COMBAT_DEFENSE_POINT_DAMAGE_FACTOR_CAP,           "combat",    "defensePointDamageFactorCap"          },
+		{EGameSettings::COMBAT_GOOD_LUCK_DICE,                            "combat",    "goodLuckDice"                         },
+		{EGameSettings::COMBAT_GOOD_MORALE_DICE,                          "combat",    "goodMoraleDice"                       },
+		{EGameSettings::COMBAT_LAYOUTS,                                   "combat",    "layouts"                              },
+		{EGameSettings::COMBAT_ONE_HEX_TRIGGERS_OBSTACLES,                "combat",    "oneHexTriggersObstacles"              },
+		{EGameSettings::CREATURES_ALLOW_ALL_FOR_DOUBLE_MONTH,             "creatures", "allowAllForDoubleMonth"               },
+		{EGameSettings::CREATURES_ALLOW_RANDOM_SPECIAL_WEEKS,             "creatures", "allowRandomSpecialWeeks"              },
+		{EGameSettings::CREATURES_DAILY_STACK_EXPERIENCE,                 "creatures", "dailyStackExperience"                 },
+		{EGameSettings::CREATURES_WEEKLY_GROWTH_CAP,                      "creatures", "weeklyGrowthCap"                      },
+		{EGameSettings::CREATURES_WEEKLY_GROWTH_PERCENT,                  "creatures", "weeklyGrowthPercent"                  },
+		{EGameSettings::DIMENSION_DOOR_EXPOSES_TERRAIN_TYPE,              "spells",    "dimensionDoorExposesTerrainType"      },
+		{EGameSettings::DIMENSION_DOOR_FAILURE_SPENDS_POINTS,             "spells",    "dimensionDoorFailureSpendsPoints"     },
+		{EGameSettings::DIMENSION_DOOR_ONLY_TO_UNCOVERED_TILES,           "spells",    "dimensionDoorOnlyToUncoveredTiles"    },
+		{EGameSettings::DIMENSION_DOOR_TOURNAMENT_RULES_LIMIT,            "spells",    "dimensionDoorTournamentRulesLimit"    },
+		{EGameSettings::DIMENSION_DOOR_TRIGGERS_GUARDS,                   "spells",    "dimensionDoorTriggersGuards"          },
+		{EGameSettings::DWELLINGS_ACCUMULATE_WHEN_NEUTRAL,                "dwellings", "accumulateWhenNeutral"                },
+		{EGameSettings::DWELLINGS_ACCUMULATE_WHEN_OWNED,                  "dwellings", "accumulateWhenOwned"                  },
+		{EGameSettings::DWELLINGS_MERGE_ON_RECRUIT,                       "dwellings", "mergeOnRecruit"                       },
+		{EGameSettings::HEROES_BACKPACK_CAP,                              "heroes",    "backpackSize"                         },
+		{EGameSettings::HEROES_MINIMAL_PRIMARY_SKILLS,                    "heroes",    "minimalPrimarySkills"                 },
+		{EGameSettings::HEROES_PER_PLAYER_ON_MAP_CAP,                     "heroes",    "perPlayerOnMapCap"                    },
+		{EGameSettings::HEROES_PER_PLAYER_TOTAL_CAP,                      "heroes",    "perPlayerTotalCap"                    },
+		{EGameSettings::HEROES_RETREAT_ON_WIN_WITHOUT_TROOPS,             "heroes",    "retreatOnWinWithoutTroops"            },
+		{EGameSettings::HEROES_STARTING_STACKS_CHANCES,                   "heroes",    "startingStackChances"                 },
+		{EGameSettings::HEROES_TAVERN_INVITE,                             "heroes",    "tavernInvite"                         },
+		{EGameSettings::MAP_FORMAT_ARMAGEDDONS_BLADE,                     "mapFormat", "armageddonsBlade"                     },
+		{EGameSettings::MAP_FORMAT_CHRONICLES,                            "mapFormat", "chronicles"                           },
+		{EGameSettings::MAP_FORMAT_HORN_OF_THE_ABYSS,                     "mapFormat", "hornOfTheAbyss"                       },
+		{EGameSettings::MAP_FORMAT_IN_THE_WAKE_OF_GODS,                   "mapFormat", "inTheWakeOfGods"                      },
+		{EGameSettings::MAP_FORMAT_JSON_VCMI,                             "mapFormat", "jsonVCMI"                             },
+		{EGameSettings::MAP_FORMAT_RESTORATION_OF_ERATHIA,                "mapFormat", "restorationOfErathia"                 },
+		{EGameSettings::MAP_FORMAT_SHADOW_OF_DEATH,                       "mapFormat", "shadowOfDeath"                        },
+		{EGameSettings::MARKETS_BLACK_MARKET_RESTOCK_PERIOD,              "markets",   "blackMarketRestockPeriod"             },
+		{EGameSettings::MODULE_COMMANDERS,                                "modules",   "commanders"                           },
+		{EGameSettings::MODULE_STACK_ARTIFACT,                            "modules",   "stackArtifact"                        },
+		{EGameSettings::MODULE_STACK_EXPERIENCE,                          "modules",   "stackExperience"                      },
+		{EGameSettings::PATHFINDER_IGNORE_GUARDS,                         "pathfinder", "ignoreGuards"                        },
+		{EGameSettings::PATHFINDER_ORIGINAL_FLY_RULES,                    "pathfinder", "originalFlyRules"                    },
+		{EGameSettings::PATHFINDER_USE_BOAT,                              "pathfinder", "useBoat"                             },
+		{EGameSettings::PATHFINDER_USE_MONOLITH_ONE_WAY_RANDOM,           "pathfinder", "useMonolithOneWayRandom"             },
+		{EGameSettings::PATHFINDER_USE_MONOLITH_ONE_WAY_UNIQUE,           "pathfinder", "useMonolithOneWayUnique"             },
+		{EGameSettings::PATHFINDER_USE_MONOLITH_TWO_WAY,                  "pathfinder", "useMonolithTwoWay"                   },
+		{EGameSettings::PATHFINDER_USE_WHIRLPOOL,                         "pathfinder", "useWhirlpool"                        },
+		{EGameSettings::RESOURCES_WEEKLY_BONUSES_AI,                      "resources", "weeklyBonusesAI"                      },
+		{EGameSettings::TEXTS_ARTIFACT,                                   "textData",  "artifact"                             },
+		{EGameSettings::TEXTS_CREATURE,                                   "textData",  "creature"                             },
+		{EGameSettings::TEXTS_FACTION,                                    "textData",  "faction"                              },
+		{EGameSettings::TEXTS_HERO,                                       "textData",  "hero"                                 },
+		{EGameSettings::TEXTS_HERO_CLASS,                                 "textData",  "heroClass"                            },
+		{EGameSettings::TEXTS_OBJECT,                                     "textData",  "object"                               },
+		{EGameSettings::TEXTS_RIVER,                                      "textData",  "river"                                },
+		{EGameSettings::TEXTS_ROAD,                                       "textData",  "road"                                 },
+		{EGameSettings::TEXTS_SPELL,                                      "textData",  "spell"                                },
+		{EGameSettings::TEXTS_TERRAIN,                                    "textData",  "terrain"                              },
+		{EGameSettings::TOWNS_BUILDINGS_PER_TURN_CAP,                     "towns",     "buildingsPerTurnCap"                  },
+		{EGameSettings::TOWNS_STARTING_DWELLING_CHANCES,                  "towns",     "startingDwellingChances"              },
+		{EGameSettings::TOWNS_SPELL_RESEARCH,                             "towns",     "spellResearch"                        },
+		{EGameSettings::TOWNS_SPELL_RESEARCH_COST,                        "towns",     "spellResearchCost"                    },
+		{EGameSettings::TOWNS_SPELL_RESEARCH_PER_DAY,                     "towns",     "spellResearchPerDay"                  },
+		{EGameSettings::TOWNS_SPELL_RESEARCH_COST_EXPONENT_PER_RESEARCH,  "towns",     "spellResearchCostExponentPerResearch" },
+		{EGameSettings::INTERFACE_PLAYER_COLORED_BACKGROUND,              "interface", "playerColoredBackground"              },
 	};
 
-	static const std::vector<SettingOption> optionPath = {
-		{EGameSettings::BONUSES_GLOBAL,                         "bonuses",   "global"                           },
-		{EGameSettings::BONUSES_PER_HERO,                       "bonuses",   "perHero"                          },
-		{EGameSettings::COMBAT_ATTACK_POINT_DAMAGE_FACTOR,      "combat",    "attackPointDamageFactor"          },
-		{EGameSettings::COMBAT_ATTACK_POINT_DAMAGE_FACTOR_CAP,  "combat",    "attackPointDamageFactorCap"       },
-		{EGameSettings::COMBAT_BAD_LUCK_DICE,                   "combat",    "badLuckDice"                      },
-		{EGameSettings::COMBAT_BAD_MORALE_DICE,                 "combat",    "badMoraleDice"                    },
-		{EGameSettings::COMBAT_DEFENSE_POINT_DAMAGE_FACTOR,     "combat",    "defensePointDamageFactor"         },
-		{EGameSettings::COMBAT_DEFENSE_POINT_DAMAGE_FACTOR_CAP, "combat",    "defensePointDamageFactorCap"      },
-		{EGameSettings::COMBAT_GOOD_LUCK_DICE,                  "combat",    "goodLuckDice"                     },
-		{EGameSettings::COMBAT_GOOD_MORALE_DICE,                "combat",    "goodMoraleDice"                   },
-		{EGameSettings::COMBAT_ONE_HEX_TRIGGERS_OBSTACLES,      "combat",    "oneHexTriggersObstacles"          },
-		{EGameSettings::CREATURES_ALLOW_ALL_FOR_DOUBLE_MONTH,   "creatures", "allowAllForDoubleMonth"           },
-		{EGameSettings::CREATURES_ALLOW_RANDOM_SPECIAL_WEEKS,   "creatures", "allowRandomSpecialWeeks"          },
-		{EGameSettings::CREATURES_DAILY_STACK_EXPERIENCE,       "creatures", "dailyStackExperience"             },
-		{EGameSettings::CREATURES_WEEKLY_GROWTH_CAP,            "creatures", "weeklyGrowthCap"                  },
-		{EGameSettings::CREATURES_WEEKLY_GROWTH_PERCENT,        "creatures", "weeklyGrowthPercent"              },
-		{EGameSettings::DWELLINGS_ACCUMULATE_WHEN_NEUTRAL,      "dwellings", "accumulateWhenNeutral"            },
-		{EGameSettings::DWELLINGS_ACCUMULATE_WHEN_OWNED,        "dwellings", "accumulateWhenOwned"              },
-		{EGameSettings::DWELLINGS_MERGE_ON_RECRUIT,             "dwellings", "mergeOnRecruit"                   },
-		{EGameSettings::HEROES_PER_PLAYER_ON_MAP_CAP,           "heroes",    "perPlayerOnMapCap"                },
-		{EGameSettings::HEROES_PER_PLAYER_TOTAL_CAP,            "heroes",    "perPlayerTotalCap"                },
-		{EGameSettings::HEROES_RETREAT_ON_WIN_WITHOUT_TROOPS,   "heroes",    "retreatOnWinWithoutTroops"        },
-		{EGameSettings::HEROES_STARTING_STACKS_CHANCES,         "heroes",    "startingStackChances"             },
-		{EGameSettings::HEROES_BACKPACK_CAP,                    "heroes",    "backpackSize"                     },
-		{EGameSettings::HEROES_TAVERN_INVITE,                   "heroes",    "tavernInvite"                     },
-		{EGameSettings::MAP_FORMAT_RESTORATION_OF_ERATHIA,      "mapFormat", "restorationOfErathia"             },
-		{EGameSettings::MAP_FORMAT_ARMAGEDDONS_BLADE,           "mapFormat", "armageddonsBlade"                 },
-		{EGameSettings::MAP_FORMAT_SHADOW_OF_DEATH,             "mapFormat", "shadowOfDeath"                    },
-		{EGameSettings::MAP_FORMAT_HORN_OF_THE_ABYSS,           "mapFormat", "hornOfTheAbyss"                   },
-		{EGameSettings::MAP_FORMAT_IN_THE_WAKE_OF_GODS,         "mapFormat", "inTheWakeOfGods"                  },
-		{EGameSettings::MAP_FORMAT_JSON_VCMI,                   "mapFormat", "jsonVCMI"                         },
-		{EGameSettings::MARKETS_BLACK_MARKET_RESTOCK_PERIOD,    "markets",   "blackMarketRestockPeriod"         },
-		{EGameSettings::BANKS_SHOW_GUARDS_COMPOSITION,          "banks",     "showGuardsComposition"            },
-		{EGameSettings::MODULE_COMMANDERS,                      "modules",   "commanders"                       },
-		{EGameSettings::MODULE_STACK_ARTIFACT,                  "modules",   "stackArtifact"                    },
-		{EGameSettings::MODULE_STACK_EXPERIENCE,                "modules",   "stackExperience"                  },
-		{EGameSettings::TEXTS_ARTIFACT,                         "textData",  "artifact"                         },
-		{EGameSettings::TEXTS_CREATURE,                         "textData",  "creature"                         },
-		{EGameSettings::TEXTS_FACTION,                          "textData",  "faction"                          },
-		{EGameSettings::TEXTS_HERO,                             "textData",  "hero"                             },
-		{EGameSettings::TEXTS_HERO_CLASS,                       "textData",  "heroClass"                        },
-		{EGameSettings::TEXTS_OBJECT,                           "textData",  "object"                           },
-		{EGameSettings::TEXTS_RIVER,                            "textData",  "river"                            },
-		{EGameSettings::TEXTS_ROAD,                             "textData",  "road"                             },
-		{EGameSettings::TEXTS_SPELL,                            "textData",  "spell"                            },
-		{EGameSettings::TEXTS_TERRAIN,                          "textData",  "terrain"                          },
-		{EGameSettings::PATHFINDER_IGNORE_GUARDS,               "pathfinder", "ignoreGuards"                    },
-		{EGameSettings::PATHFINDER_USE_BOAT,                    "pathfinder", "useBoat"                         },
-		{EGameSettings::PATHFINDER_USE_MONOLITH_TWO_WAY,        "pathfinder", "useMonolithTwoWay"               },
-		{EGameSettings::PATHFINDER_USE_MONOLITH_ONE_WAY_UNIQUE, "pathfinder", "useMonolithOneWayUnique"         },
-		{EGameSettings::PATHFINDER_USE_MONOLITH_ONE_WAY_RANDOM, "pathfinder", "useMonolithOneWayRandom"         },
-		{EGameSettings::PATHFINDER_USE_WHIRLPOOL,               "pathfinder", "useWhirlpool"                    },
-		{EGameSettings::PATHFINDER_ORIGINAL_FLY_RULES,          "pathfinder", "originalFlyRules"                },
-		{EGameSettings::DIMENSION_DOOR_ONLY_TO_UNCOVERED_TILES, "spells",    "dimensionDoorOnlyToUncoveredTiles"},
-		{EGameSettings::DIMENSION_DOOR_EXPOSES_TERRAIN_TYPE,    "spells",    "dimensionDoorExposesTerrainType"  },
-		{EGameSettings::DIMENSION_DOOR_FAILURE_SPENDS_POINTS,   "spells",    "dimensionDoorFailureSpendsPoints" },
-		{EGameSettings::DIMENSION_DOOR_TRIGGERS_GUARDS,         "spells",    "dimensionDoorTriggersGuards"      },
-		{EGameSettings::DIMENSION_DOOR_TOURNAMENT_RULES_LIMIT,  "spells",    "dimensionDoorTournamentRulesLimit"},
-		{EGameSettings::TOWNS_BUILDINGS_PER_TURN_CAP,           "towns",     "buildingsPerTurnCap"              },
-		{EGameSettings::TOWNS_STARTING_DWELLING_CHANCES,        "towns",     "startingDwellingChances"          },
-	};
+void GameSettings::loadBase(const JsonNode & input)
+{
+	JsonUtils::validate(input, "vcmi:gameSettings", input.getModScope());
 
-	for(const auto & option : optionPath)
+	for(const auto & option : settingProperties)
 	{
 		const JsonNode & optionValue = input[option.group][option.key];
 		size_t index = static_cast<size_t>(option.setting);
@@ -120,16 +121,59 @@
 		if(optionValue.isNull())
 			continue;
 
-		JsonUtils::mergeCopy(gameSettings[index], optionValue);
+		JsonUtils::mergeCopy(baseSettings[index], optionValue);
 	}
+	actualSettings = baseSettings;
+}
+
+void GameSettings::loadOverrides(const JsonNode & input)
+{
+	for(const auto & option : settingProperties)
+	{
+		const JsonNode & optionValue = input[option.group][option.key];
+		if (!optionValue.isNull())
+			addOverride(option.setting, optionValue);
+	}
+}
+
+void GameSettings::addOverride(EGameSettings option, const JsonNode & input)
+{
+	size_t index = static_cast<size_t>(option);
+
+	overridenSettings[index] = input;
+	JsonNode newValue = baseSettings[index];
+	JsonUtils::mergeCopy(newValue, input);
+	actualSettings[index] = newValue;
 }
 
 const JsonNode & GameSettings::getValue(EGameSettings option) const
 {
 	auto index = static_cast<size_t>(option);
 
-	assert(!gameSettings.at(index).isNull());
-	return gameSettings.at(index);
+	assert(!actualSettings.at(index).isNull());
+	return actualSettings.at(index);
+}
+
+JsonNode GameSettings::getFullConfig() const
+{
+	JsonNode result;
+	for(const auto & option : settingProperties)
+		result[option.group][option.key] = getValue(option.setting);
+
+	return result;
+}
+
+JsonNode GameSettings::getAllOverrides() const
+{
+	JsonNode result;
+	for(const auto & option : settingProperties)
+	{
+		const JsonNode & value = overridenSettings[static_cast<int32_t>(option.setting)];
+		if (!value.isNull())
+			result[option.group][option.key] = value;
+	}
+
+	return result;
 }
 
 VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/GameSettings.h vcmi/lib/GameSettings.h
--- vcmi-1.5.7/lib/GameSettings.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/GameSettings.h	2024-12-19 15:00:22.854146119 +0100
@@ -9,103 +9,65 @@
  */
 #pragma once
 
-VCMI_LIB_NAMESPACE_BEGIN
-
-class JsonNode;
-
-enum class EGameSettings
-{
-	BONUSES_GLOBAL,
-	BONUSES_PER_HERO,
-	COMBAT_ATTACK_POINT_DAMAGE_FACTOR,
-	COMBAT_ATTACK_POINT_DAMAGE_FACTOR_CAP,
-	COMBAT_BAD_LUCK_DICE,
-	COMBAT_BAD_MORALE_DICE,
-	COMBAT_DEFENSE_POINT_DAMAGE_FACTOR,
-	COMBAT_DEFENSE_POINT_DAMAGE_FACTOR_CAP,
-	COMBAT_GOOD_LUCK_DICE,
-	COMBAT_GOOD_MORALE_DICE,
-	CREATURES_ALLOW_ALL_FOR_DOUBLE_MONTH,
-	CREATURES_ALLOW_RANDOM_SPECIAL_WEEKS,
-	CREATURES_DAILY_STACK_EXPERIENCE,
-	CREATURES_WEEKLY_GROWTH_CAP,
-	CREATURES_WEEKLY_GROWTH_PERCENT,
-	DWELLINGS_ACCUMULATE_WHEN_NEUTRAL,
-	DWELLINGS_ACCUMULATE_WHEN_OWNED,
-	DWELLINGS_MERGE_ON_RECRUIT,
-	HEROES_PER_PLAYER_ON_MAP_CAP,
-	HEROES_PER_PLAYER_TOTAL_CAP,
-	HEROES_RETREAT_ON_WIN_WITHOUT_TROOPS,
-	HEROES_STARTING_STACKS_CHANCES,
-	HEROES_BACKPACK_CAP,
-	HEROES_TAVERN_INVITE,
-	MARKETS_BLACK_MARKET_RESTOCK_PERIOD,
-	BANKS_SHOW_GUARDS_COMPOSITION,
-	MODULE_COMMANDERS,
-	MODULE_STACK_ARTIFACT,
-	MODULE_STACK_EXPERIENCE,
-	TEXTS_ARTIFACT,
-	TEXTS_CREATURE,
-	TEXTS_FACTION,
-	TEXTS_HERO,
-	TEXTS_HERO_CLASS,
-	TEXTS_OBJECT,
-	TEXTS_RIVER,
-	TEXTS_ROAD,
-	TEXTS_SPELL,
-	TEXTS_TERRAIN,
-	MAP_FORMAT_RESTORATION_OF_ERATHIA,
-	MAP_FORMAT_ARMAGEDDONS_BLADE,
-	MAP_FORMAT_SHADOW_OF_DEATH,
-	MAP_FORMAT_HORN_OF_THE_ABYSS,
-	MAP_FORMAT_JSON_VCMI,
-	MAP_FORMAT_IN_THE_WAKE_OF_GODS,
-	PATHFINDER_USE_BOAT,
-	PATHFINDER_IGNORE_GUARDS,
-	PATHFINDER_USE_MONOLITH_TWO_WAY,
-	PATHFINDER_USE_MONOLITH_ONE_WAY_UNIQUE,
-	PATHFINDER_USE_MONOLITH_ONE_WAY_RANDOM,
-	PATHFINDER_USE_WHIRLPOOL,
-	PATHFINDER_ORIGINAL_FLY_RULES,
-	TOWNS_BUILDINGS_PER_TURN_CAP,
-	TOWNS_STARTING_DWELLING_CHANCES,
-	COMBAT_ONE_HEX_TRIGGERS_OBSTACLES,
-	DIMENSION_DOOR_ONLY_TO_UNCOVERED_TILES,
-	DIMENSION_DOOR_EXPOSES_TERRAIN_TYPE,
-	DIMENSION_DOOR_FAILURE_SPENDS_POINTS,
-	DIMENSION_DOOR_TRIGGERS_GUARDS,
-	DIMENSION_DOOR_TOURNAMENT_RULES_LIMIT,
+#include "IGameSettings.h"
+#include "json/JsonNode.h"
 
-	OPTIONS_COUNT
-};
-
-class DLL_LINKAGE IGameSettings
-{
-public:
-	virtual const JsonNode & getValue(EGameSettings option) const = 0;
-	virtual ~IGameSettings() = default;
-
-	bool getBoolean(EGameSettings option) const;
-	int64_t getInteger(EGameSettings option) const;
-	double getDouble(EGameSettings option) const;
-	std::vector<int> getVector(EGameSettings option) const;
-};
+VCMI_LIB_NAMESPACE_BEGIN
 
 class DLL_LINKAGE GameSettings final : public IGameSettings, boost::noncopyable
 {
-	std::vector<JsonNode> gameSettings;
+	struct SettingOption
+	{
+		EGameSettings setting;
+		std::string group;
+		std::string key;
+	};
+
+	static constexpr int32_t OPTIONS_COUNT = static_cast<int32_t>(EGameSettings::OPTIONS_COUNT);
+	static const std::vector<SettingOption> settingProperties;
+
+	// contains base settings, like those defined in base game or mods
+	std::array<JsonNode, OPTIONS_COUNT> baseSettings;
+	// contains settings that were overriden, in map or in random map template
+	std::array<JsonNode, OPTIONS_COUNT> overridenSettings;
+	// for convenience / performance, contains actual settings - combined version of base and override settings
+	std::array<JsonNode, OPTIONS_COUNT> actualSettings;
+
+	// converts all existing overrides into a single json node for serialization
+	JsonNode getAllOverrides() const;
 
 public:
 	GameSettings();
 	~GameSettings();
 
-	void load(const JsonNode & input);
+	/// Loads settings as 'base settings' that can be overriden
+	/// For settings defined in vcmi or in mods
+	void loadBase(const JsonNode & input);
+
+	/// Loads setting as an override, for use in maps or rmg templates
+	/// undefined behavior if setting was already overriden (TODO: decide which approach is better - replace or append)
+	void addOverride(EGameSettings option, const JsonNode & input);
+
+	// loads all overrides from provided json node, for deserialization
+	void loadOverrides(const JsonNode &);
+
+	JsonNode getFullConfig() const override;
 	const JsonNode & getValue(EGameSettings option) const override;
 
 	template<typename Handler>
 	void serialize(Handler & h)
 	{
-		h & gameSettings;
+		if (h.saving)
+		{
+			JsonNode overrides = getAllOverrides();
+			h & overrides;
+		}
+		else
+		{
+			JsonNode overrides;
+			h & overrides;
+			loadOverrides(overrides);
+		}
 	}
 };
 
diff --color -urN vcmi-1.5.7/lib/gameState/CGameStateCampaign.cpp vcmi/lib/gameState/CGameStateCampaign.cpp
--- vcmi-1.5.7/lib/gameState/CGameStateCampaign.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/gameState/CGameStateCampaign.cpp	2024-12-19 15:00:22.904148185 +0100
@@ -14,6 +14,10 @@
 #include "QuestInfo.h"
 
 #include "../campaign/CampaignState.h"
+#include "../entities/building/CBuilding.h"
+#include "../entities/building/CBuildingHandler.h"
+#include "../entities/hero/CHeroClass.h"
+#include "../entities/hero/CHero.h"
 #include "../mapping/CMapEditManager.h"
 #include "../mapObjects/CGHeroInstance.h"
 #include "../mapObjects/CGTownInstance.h"
@@ -21,13 +25,14 @@
 #include "../mapObjectConstructors/AObjectTypeHandler.h"
 #include "../mapObjectConstructors/CObjectClassesHandler.h"
 #include "../StartInfo.h"
-#include "../CBuildingHandler.h"
-#include "../CHeroHandler.h"
 #include "../mapping/CMap.h"
 #include "../ArtifactUtils.h"
 #include "../CPlayerState.h"
 #include "../serializer/CMemorySerializer.h"
 
+#include <vstd/RNG.h>
+#include <vcmi/HeroTypeService.h>
+
 VCMI_LIB_NAMESPACE_BEGIN
 
 CampaignHeroReplacement::CampaignHeroReplacement(CGHeroInstance * hero, const ObjectInstanceID & heroPlaceholderId):
@@ -83,7 +88,7 @@
 					.And(Selector::subtype()(BonusSubtypeID(g)))
 					.And(Selector::sourceType()(BonusSource::HERO_BASE_SKILL));
 
-				hero.hero->getLocalBonus(sel)->val = hero.hero->type->heroClass->primarySkillInitial[g.getNum()];
+				hero.hero->getLocalBonus(sel)->val = hero.hero->getHeroClass()->primarySkillInitial[g.getNum()];
 			}
 		}
 	}
@@ -93,7 +98,7 @@
 		//trimming sec skills
 		for(auto & hero : campaignHeroReplacements)
 		{
-			hero.hero->secSkills = hero.hero->type->secSkillsInit;
+			hero.hero->secSkills = hero.hero->getHeroType()->secSkillsInit;
 			hero.hero->recreateSecondarySkillsBonuses();
 		}
 	}
@@ -132,15 +137,19 @@
 
 				ArtifactLocation al(hero.hero->id, artifactPosition);
 
-				bool takeable = travelOptions.artifactsKeptByHero.count(art->artType->getId());
+				bool takeable = travelOptions.artifactsKeptByHero.count(art->getTypeId());
 				bool locked = hero.hero->getSlot(al.slot)->locked;
 
 				if (!locked && takeable)
+				{
+					logGlobal->debug("Artifact %s from slot %d of hero %s will be transferred to next scenario", art->getType()->getJsonKey(), al.slot.getNum(), hero.hero->getHeroTypeName());
 					hero.transferrableArtifacts.push_back(artifactPosition);
+				}
 
 				if (!locked && !takeable)
 				{
-					hero.hero->getArt(al.slot)->removeFrom(*hero.hero, al.slot);
+					logGlobal->debug("Removing artifact %s from slot %d of hero %s", art->getType()->getJsonKey(), al.slot.getNum(), hero.hero->getHeroTypeName());
+					gameState->map->removeArtifactInstance(*hero.hero, al.slot);
 					return true;
 				}
 				return false;
@@ -233,7 +242,7 @@
 
 	for(auto & replacement : campaignHeroReplacements)
 		if (replacement.heroPlaceholderId.hasValue())
-			heroesToRemove.insert(replacement.hero->getHeroType());
+			heroesToRemove.insert(replacement.hero->getHeroTypeID());
 
 	for(auto & heroID : heroesToRemove)
 	{
@@ -320,7 +329,7 @@
 			CArtifactInstance * scroll = ArtifactUtils::createScroll(SpellID(curBonus->info2));
 			const auto slot = ArtifactUtils::getArtAnyPosition(hero, scroll->getTypeId());
 			if(ArtifactUtils::isSlotEquipment(slot) || ArtifactUtils::isSlotBackpack(slot))
-				scroll->putAt(*hero, slot);
+				gameState->map->putArtifactInstance(*hero, scroll, slot);
 			else
 				logGlobal->error("Cannot give starting scroll - no free slots!");
 			break;
@@ -361,9 +370,9 @@
 		heroToPlace->id = campaignHeroReplacement.heroPlaceholderId;
 		if(heroPlaceholder->tempOwner.isValidPlayer())
 			heroToPlace->tempOwner = heroPlaceholder->tempOwner;
-		heroToPlace->pos = heroPlaceholder->pos;
-		heroToPlace->type = heroToPlace->getHeroType().toHeroType();
-		heroToPlace->appearance = VLC->objtypeh->getHandlerFor(Obj::HERO, heroToPlace->type->heroClass->getIndex())->getTemplates().front();
+		heroToPlace->setAnchorPos(heroPlaceholder->anchorPos());
+		heroToPlace->setHeroType(heroToPlace->getHeroTypeID());
+		heroToPlace->appearance = heroToPlace->getObjectHandler()->getTemplates().front();
 
 		gameState->map->removeBlockVisTiles(heroPlaceholder, true);
 		gameState->map->objects[heroPlaceholder->id.getNum()] = nullptr;
@@ -410,19 +419,21 @@
 		if (!donorHero)
 			throw std::runtime_error("Failed to find hero to take artifacts from! Scenario: " + gameState->map->name.toString());
 
-		for (auto const & artLocation : campaignHeroReplacement.transferrableArtifacts)
+		// process in reverse - 2nd artifact from a backpack must be processed before 1st one to avoid invalidation of artifact positions
+		for (auto const & artLocation : boost::adaptors::reverse(campaignHeroReplacement.transferrableArtifacts))
 		{
 			auto * artifact = donorHero->getArt(artLocation);
-			if (!donorHero)
-				throw std::runtime_error("Failed to find artifacts to transfer to travelling hero! Scenario: " + gameState->map->name.toString());
 
-			artifact->removeFrom(*donorHero, artLocation);
+			logGlobal->debug("Removing artifact %s from slot %d of hero %s for transfer", artifact->getType()->getJsonKey(), artLocation.getNum(), donorHero->getHeroTypeName());
+			gameState->map->removeArtifactInstance(*donorHero, artLocation);
 
 			if (receiver)
 			{
+				logGlobal->debug("Granting artifact %s to hero %s for transfer", artifact->getType()->getJsonKey(), receiver->getHeroTypeName());
+
 				const auto slot = ArtifactUtils::getArtAnyPosition(receiver, artifact->getTypeId());
 				if(ArtifactUtils::isSlotEquipment(slot) || ArtifactUtils::isSlotBackpack(slot))
-					artifact->putAt(*receiver, slot);
+					gameState->map->putArtifactInstance(*receiver, artifact, slot);
 				else
 					logGlobal->error("Cannot transfer artifact - no free slots!");
 			}
@@ -533,7 +544,7 @@
 		}
 		assert(humanPlayer != PlayerColor::NEUTRAL);
 
-		std::vector<ConstTransitivePtr<CGHeroInstance> > & heroes = gameState->players[humanPlayer].heroes;
+		const auto & heroes = gameState->players[humanPlayer].getHeroes();
 
 		if (chosenBonus->info1 == 0xFFFD) //most powerful
 		{
@@ -552,11 +563,11 @@
 		}
 		else //specific hero
 		{
-			for (auto & heroe : heroes)
+			for (auto & hero : heroes)
 			{
-				if (heroe->getHeroType().getNum() == chosenBonus->info1)
+				if (hero->getHeroTypeID().getNum() == chosenBonus->info1)
 				{
-					giveCampaignBonusToHero(heroe);
+					giveCampaignBonusToHero(hero);
 					break;
 				}
 			}
@@ -646,14 +657,14 @@
 		if (!owner->human)
 			continue;
 
-		if (town->pos != pi.posOfMainTown)
+		if (town->anchorPos() != pi.posOfMainTown)
 			continue;
 
 		BuildingID newBuilding;
 		if(gameState->scenarioOps->campState->formatVCMI())
 			newBuilding = BuildingID(chosenBonus->info1);
 		else
-			newBuilding = CBuildingHandler::campToERMU(chosenBonus->info1, town->getFaction(), town->builtBuildings);
+			newBuilding = CBuildingHandler::campToERMU(chosenBonus->info1, town->getFactionID(), town->getBuildings());
 
 		// Build granted building & all prerequisites - e.g. Mages Guild Lvl 3 should also give Mages Guild Lvl 1 & 2
 		while(true)
@@ -661,12 +672,12 @@
 			if (newBuilding == BuildingID::NONE)
 				break;
 
-			if (town->builtBuildings.count(newBuilding) != 0)
+			if(town->hasBuilt(newBuilding))
 				break;
 
-			town->builtBuildings.insert(newBuilding);
+			town->addBuilding(newBuilding);
 
-			auto building = town->town->buildings.at(newBuilding);
+			auto building = town->getTown()->buildings.at(newBuilding);
 			newBuilding = building->upgrade;
 		}
 		break;
diff --color -urN vcmi-1.5.7/lib/gameState/CGameStateCampaign.h vcmi/lib/gameState/CGameStateCampaign.h
--- vcmi-1.5.7/lib/gameState/CGameStateCampaign.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/gameState/CGameStateCampaign.h	2024-12-19 15:00:22.904148185 +0100
@@ -11,6 +11,7 @@
 
 #include "../GameConstants.h"
 #include "../campaign/CampaignConstants.h"
+#include "../serializer/Serializeable.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
@@ -28,7 +29,7 @@
 	std::vector<ArtifactPosition> transferrableArtifacts;
 };
 
-class CGameStateCampaign
+class CGameStateCampaign : public Serializeable
 {
 	CGameState * gameState;
 
diff --color -urN vcmi-1.5.7/lib/gameState/CGameState.cpp vcmi/lib/gameState/CGameState.cpp
--- vcmi-1.5.7/lib/gameState/CGameState.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/gameState/CGameState.cpp	2024-12-19 15:00:22.903148144 +0100
@@ -17,12 +17,10 @@
 #include "SThievesGuildInfo.h"
 
 #include "../ArtifactUtils.h"
-#include "../CBuildingHandler.h"
-#include "../CGeneralTextHandler.h"
-#include "../CHeroHandler.h"
+#include "../texts/CGeneralTextHandler.h"
 #include "../CPlayerState.h"
 #include "../CStopWatch.h"
-#include "../GameSettings.h"
+#include "../IGameSettings.h"
 #include "../StartInfo.h"
 #include "../TerrainHandler.h"
 #include "../VCMIDirs.h"
@@ -30,6 +28,9 @@
 #include "../battle/BattleInfo.h"
 #include "../campaign/CampaignState.h"
 #include "../constants/StringConstants.h"
+#include "../entities/faction/CTownHandler.h"
+#include "../entities/hero/CHero.h"
+#include "../entities/hero/CHeroClass.h"
 #include "../filesystem/ResourcePath.h"
 #include "../json/JsonBonus.h"
 #include "../json/JsonUtils.h"
@@ -45,45 +46,23 @@
 #include "../mapping/CMapService.h"
 #include "../modding/IdentifierStorage.h"
 #include "../modding/ModScope.h"
+#include "../networkPacks/NetPacksBase.h"
 #include "../pathfinder/CPathfinder.h"
 #include "../pathfinder/PathfinderOptions.h"
-#include "../registerTypes/RegisterTypesClientPacks.h"
 #include "../rmg/CMapGenerator.h"
 #include "../serializer/CMemorySerializer.h"
-#include "../serializer/CTypeList.h"
 #include "../spells/CSpellHandler.h"
 
+#include <vstd/RNG.h>
+
 VCMI_LIB_NAMESPACE_BEGIN
 
 boost::shared_mutex CGameState::mutex;
 
-template <typename T> class CApplyOnGS;
-
-class CBaseForGSApply
-{
-public:
-	virtual void applyOnGS(CGameState *gs, CPack * pack) const =0;
-	virtual ~CBaseForGSApply() = default;
-	template<typename U> static CBaseForGSApply *getApplier(const U * t=nullptr)
-	{
-		return new CApplyOnGS<U>();
-	}
-};
-
-template <typename T> class CApplyOnGS : public CBaseForGSApply
-{
-public:
-	void applyOnGS(CGameState *gs, CPack * pack) const override
-	{
-		T *ptr = static_cast<T*>(pack);
-		ptr->applyGs(gs);
-	}
-};
-
 HeroTypeID CGameState::pickNextHeroType(const PlayerColor & owner)
 {
 	const PlayerSettings &ps = scenarioOps->getIthPlayersSettings(owner);
-	if(ps.hero >= HeroTypeID(0) && !isUsedHero(HeroTypeID(ps.hero))) //we haven't used selected hero
+	if(ps.hero.isValid() && !isUsedHero(HeroTypeID(ps.hero))) //we haven't used selected hero
 	{
 		return HeroTypeID(ps.hero);
 	}
@@ -127,26 +106,26 @@
 	throw std::runtime_error("Can not allocate hero. All heroes are already used.");
 }
 
-int CGameState::getDate(Date mode) const
+int CGameState::getDate(int d, Date mode)
 {
 	int temp;
 	switch (mode)
 	{
 	case Date::DAY:
-		return day;
+		return d;
 	case Date::DAY_OF_WEEK: //day of week
-		temp = (day)%7; // 1 - Monday, 7 - Sunday
+		temp = (d)%7; // 1 - Monday, 7 - Sunday
 		return temp ? temp : 7;
 	case Date::WEEK:  //current week
-		temp = ((day-1)/7)+1;
+		temp = ((d-1)/7)+1;
 		if (!(temp%4))
 			return 4;
 		else
 			return (temp%4);
 	case Date::MONTH: //current month
-		return ((day-1)/28)+1;
+		return ((d-1)/28)+1;
 	case Date::DAY_OF_MONTH: //day of month
-		temp = (day)%28;
+		temp = (d)%28;
 		if (temp)
 			return temp;
 		else return 28;
@@ -154,12 +133,15 @@
 	return 0;
 }
 
+int CGameState::getDate(Date mode) const
+{
+	return getDate(day, mode);
+}
+
 CGameState::CGameState()
 {
 	gs = this;
 	heroesPool = std::make_unique<TavernHeroesPool>();
-	applier = std::make_shared<CApplier<CBaseForGSApply>>();
-	registerTypesClientPacks(*applier);
 	globalEffects.setNodeType(CBonusSystemNode::GLOBAL_EFFECTS);
 }
 
@@ -172,6 +154,11 @@
 	initialOpts.dellNull();
 }
 
+const IGameSettings & CGameState::getSettings() const
+{
+	return map->getSettings();
+}
+
 void CGameState::preInit(Services * newServices, IGameCallback * newCallback)
 {
 	services = newServices;
@@ -182,8 +169,6 @@
 {
 	assert(services);
 	assert(callback);
-	logGlobal->info("\tUsing random seed: %d", si->seedToBeUsed);
-	getRandomGenerator().setSeed(si->seedToBeUsed);
 	scenarioOps = CMemorySerializer::deepCopy(*si).release();
 	initialOpts = CMemorySerializer::deepCopy(*si).release();
 	si = nullptr;
@@ -202,8 +187,6 @@
 	}
 	logGlobal->info("Map loaded!");
 
-	checkMapChecksum();
-
 	day = 0;
 
 	logGlobal->debug("Initialization:");
@@ -217,6 +200,7 @@
 	initRandomFactionsForPlayers();
 	randomizeMapObjects();
 	placeStartingHeroes();
+	initOwnedObjects();
 	initDifficulty();
 	initHeroes();
 	initStartingBonus();
@@ -235,18 +219,6 @@
 
 	logGlobal->debug("\tChecking objectives");
 	map->checkForObjectives(); //needs to be run when all objects are properly placed
-
-	auto seedAfterInit = getRandomGenerator().nextInt();
-	logGlobal->info("Seed after init is %d (before was %d)", seedAfterInit, scenarioOps->seedToBeUsed);
-	if(scenarioOps->seedPostInit > 0)
-	{
-		//RNG must be in the same state on all machines when initialization is done (otherwise we have desync)
-		assert(scenarioOps->seedPostInit == seedAfterInit);
-	}
-	else
-	{
-		scenarioOps->seedPostInit = seedAfterInit; //store the post init "seed"
-	}
 }
 
 void CGameState::updateEntity(Metatype metatype, int32_t index, const JsonNode & data)
@@ -283,7 +255,7 @@
 		}
 		break;
 	default:
-		services->updateEntity(metatype, index, data);
+		logGlobal->error("This metatype update is not implemented");
 		break;
 	}
 }
@@ -296,6 +268,8 @@
 	for(auto & i : si->playerInfos)
 		gs->players[i.first].human = i.second.isControlledByHuman();
 	scenarioOps->extraOptionsInfo = si->extraOptionsInfo;
+	scenarioOps->turnTimerInfo = si->turnTimerInfo;
+	scenarioOps->simturnsInfo = si->simturnsInfo;
 }
 
 void CGameState::initNewGame(const IMapService * mapService, bool allowSavingRandomMap, Load::ProgressAccumulator & progressTracking)
@@ -306,7 +280,7 @@
 		CStopWatch sw;
 
 		// Gen map
-		CMapGenerator mapGenerator(*scenarioOps->mapGenOptions, callback, scenarioOps->seedToBeUsed);
+		CMapGenerator mapGenerator(*scenarioOps->mapGenOptions, callback, getRandomGenerator().nextInt());
 		progressTracking.include(mapGenerator);
 
 		std::unique_ptr<CMap> randomMap = mapGenerator.generate();
@@ -343,10 +317,9 @@
 				std::shared_ptr<CMapGenOptions> options = scenarioOps->mapGenOptions;
 
 				const std::string templateName = options->getMapTemplate()->getName();
-				const ui32 seed = scenarioOps->seedToBeUsed;
 				const std::string dt = vstd::getDateTimeISO8601Basic(std::time(nullptr));
 
-				const std::string fileName = boost::str(boost::format("%s_%s_%d.vmap") % dt % templateName % seed );
+				const std::string fileName = boost::str(boost::format("%s_%s.vmap") % dt % templateName );
 				const auto fullPath = path / fileName;
 
 				randomMap->name.appendRawString(boost::str(boost::format(" %s") % dt));
@@ -380,27 +353,18 @@
 	map = campaign->getCurrentMap().release();
 }
 
-void CGameState::checkMapChecksum()
+void CGameState::generateOwnedObjectsAfterDeserialize()
 {
-	logGlobal->info("\tOur checksum for the map: %d", map->checksum);
-	if(scenarioOps->mapfileChecksum)
+	for (auto & object : map->objects)
 	{
-		logGlobal->info("\tServer checksum for %s: %d", scenarioOps->mapname, scenarioOps->mapfileChecksum);
-		if(map->checksum != scenarioOps->mapfileChecksum)
-		{
-			logGlobal->error("Wrong map checksum!!!");
-			throw std::runtime_error("Wrong checksum");
-		}
-	}
-	else
-	{
-		scenarioOps->mapfileChecksum = map->checksum;
+		if (object && object->asOwnable() && object->getOwner().isValidPlayer())
+			players.at(object->getOwner()).addOwnedObject(object.get());
 	}
 }
 
 void CGameState::initGlobalBonuses()
 {
-	const JsonNode & baseBonuses = VLC->settings()->getValue(EGameSettings::BONUSES_GLOBAL);
+	const JsonNode & baseBonuses = getSettings().getValue(EGameSettings::BONUSES_GLOBAL);
 	logGlobal->debug("\tLoading global bonuses");
 	for(const auto & b : baseBonuses.Struct())
 	{
@@ -421,10 +385,14 @@
 	const JsonNode & difficultyAI(config["ai"][GameConstants::DIFFICULTY_NAMES[scenarioOps->difficulty]]);
 	const JsonNode & difficultyHuman(config["human"][GameConstants::DIFFICULTY_NAMES[scenarioOps->difficulty]]);
 	
-	auto setDifficulty = [](PlayerState & state, const JsonNode & json)
+	auto setDifficulty = [this](PlayerState & state, const JsonNode & json)
 	{
 		//set starting resources
 		state.resources = TResources(json["resources"]);
+
+		//handicap
+		const PlayerSettings &ps = scenarioOps->getIthPlayersSettings(state.color);
+		state.resources += ps.handicap.startBonus;
 		
 		//set global bonuses
 		for(auto & jsonBonus : json["globalBonuses"].Vector())
@@ -469,10 +437,10 @@
 				for(int y = BORDER_WIDTH; y < map->height - BORDER_WIDTH; y++)
 				{
 					const TerrainTile &t = map->getTile(int3(x, y, z));
-					if(!t.blocked
-						&& !t.visitable
-						&& t.terType->isLand()
-						&& t.terType->isPassable()
+					if(!t.blocked()
+					   && !t.visitable()
+						&& t.isLand()
+						&& t.getTerrain()->isPassable()
 						&& (int)map->grailPos.dist2dSQ(int3(x, y, z)) <= (map->grailRadius * map->grailRadius))
 						allowedPos.emplace_back(x, y, z);
 				}
@@ -482,7 +450,7 @@
 		//remove tiles with holes
 		for(auto & elem : map->objects)
 			if(elem && elem->ID == Obj::HOLE)
-				allowedPos -= elem->pos;
+				allowedPos -= elem->anchorPos();
 
 		if(!allowedPos.empty())
 		{
@@ -528,7 +496,7 @@
 			{
 				for (int j = 0; j < object->getHeight() ; j++)
 				{
-					int3 pos = object->pos - int3(i,j,0);
+					int3 pos = object->anchorPos() - int3(i,j,0);
 					if(map->isInTheMap(pos)) map->getTile(pos).extTileFlags |= 128;
 				}
 			}
@@ -536,6 +504,15 @@
 	}
 }
 
+void CGameState::initOwnedObjects()
+{
+	for(CGObjectInstance *object : map->objects)
+	{
+		if (object && object->getOwner().isValidPlayer())
+			getPlayerState(object->getOwner())->addOwnedObject(object);
+	}
+}
+
 void CGameState::initPlayerStates()
 {
 	logGlobal->debug("\tCreating player entries in gs");
@@ -554,7 +531,7 @@
 {
 	for(auto town : map->towns)
 	{
-		if(town->getPosition() == townPos)
+		if(town->anchorPos() == townPos)
 		{
 			townPos = town->visitablePos();
 			break;
@@ -569,8 +546,7 @@
 	hero->setHeroType(heroTypeId);
 	hero->tempOwner = playerColor;
 
-	hero->pos = townPos;
-	hero->pos += hero->getVisitableOffset();
+	hero->setAnchorPos(townPos + hero->getVisitableOffset());
 	map->getEditManager()->insertObject(hero);
 }
 
@@ -624,8 +600,7 @@
 		}
 
 		hero->initHero(getRandomGenerator());
-		getPlayerState(hero->getOwner())->heroes.push_back(hero);
-		map->allHeroes[hero->getHeroType().getNum()] = hero;
+		map->allHeroes[hero->getHeroTypeID().getNum()] = hero;
 	}
 
 	// generate boats for all heroes on water
@@ -633,13 +608,13 @@
 	{
 		assert(map->isInTheMap(hero->visitablePos()));
 		const auto & tile = map->getTile(hero->visitablePos());
-		if (tile.terType->isWater())
+		if (tile.isWater())
 		{
 			auto handler = VLC->objtypeh->getHandlerFor(Obj::BOAT, hero->getBoatType().getNum());
 			auto boat = dynamic_cast<CGBoat*>(handler->create(callback, nullptr));
 			handler->configureObject(boat, gs->getRandomGenerator());
 
-			boat->pos = hero->pos;
+			boat->setAnchorPos(hero->anchorPos());
 			boat->appearance = handler->getTemplates().front();
 			boat->id = ObjectInstanceID(static_cast<si32>(gs->map->objects.size()));
 
@@ -655,20 +630,20 @@
 		{
 			auto * hero = dynamic_cast<CGHeroInstance*>(obj.get());
 			hero->initHero(getRandomGenerator());
-			map->allHeroes[hero->getHeroType().getNum()] = hero;
+			map->allHeroes[hero->getHeroTypeID().getNum()] = hero;
 		}
 	}
 
 	std::set<HeroTypeID> heroesToCreate = getUnusedAllowedHeroes(); //ids of heroes to be created and put into the pool
 	for(auto ph : map->predefinedHeroes)
 	{
-		if(!vstd::contains(heroesToCreate, ph->getHeroType()))
+		if(!vstd::contains(heroesToCreate, ph->getHeroTypeID()))
 			continue;
 		ph->initHero(getRandomGenerator());
 		heroesPool->addHeroToPool(ph);
-		heroesToCreate.erase(ph->type->getId());
+		heroesToCreate.erase(ph->getHeroTypeID());
 
-		map->allHeroes[ph->getHeroType().getNum()] = ph;
+		map->allHeroes[ph->getHeroTypeID().getNum()] = ph;
 	}
 
 	for(const HeroTypeID & htype : heroesToCreate) //all not used allowed heroes go with default state into the pool
@@ -696,8 +671,8 @@
 	for(auto & elem : teams)
 	{
 		auto & fow = elem.second.fogOfWarMap;
-		fow->resize(boost::extents[layers][map->width][map->height]);
-		std::fill(fow->data(), fow->data() + fow->num_elements(), 0);
+		fow.resize(boost::extents[layers][map->width][map->height]);
+		std::fill(fow.data(), fow.data() + fow.num_elements(), 0);
 
 		for(CGObjectInstance *obj : map->objects)
 		{
@@ -707,7 +682,7 @@
 			getTilesInRange(tiles, obj->getSightCenter(), obj->getSightRadius(), ETileVisibility::HIDDEN, obj->tempOwner);
 			for(const int3 & tile : tiles)
 			{
-				(*elem.second.fogOfWarMap)[tile.z][tile.x][tile.y] = 1;
+				elem.second.fogOfWarMap[tile.z][tile.x][tile.y] = 1;
 			}
 		}
 	}
@@ -749,14 +724,14 @@
 			}
 		case PlayerStartingBonus::ARTIFACT:
 			{
-				if(elem.second.heroes.empty())
+				if(elem.second.getHeroes().empty())
 				{
 					logGlobal->error("Cannot give starting artifact - no heroes!");
 					break;
 				}
 				const Artifact * toGive = pickRandomArtifact(getRandomGenerator(), CArtifact::ART_TREASURE).toEntity(VLC);
 
-				CGHeroInstance *hero = elem.second.heroes[0];
+				CGHeroInstance *hero = elem.second.getHeroes()[0];
 				if(!giveHeroArtifact(hero, toGive->getId()))
 					logGlobal->error("Cannot give starting artifact - no free slots!");
 			}
@@ -782,12 +757,12 @@
 
 	for(auto & vti : map->towns)
 	{
-		assert(vti->town);
+		assert(vti->getTown());
 
 		if(!vti->getNameTextID().empty())
 			continue;
 
-		FactionID faction = vti->getFaction();
+		FactionID faction = vti->getFactionID();
 
 		if(availableNames.empty())
 		{
@@ -824,68 +799,70 @@
 
 	for (auto & vti : map->towns)
 	{
-		assert(vti->town);
+		assert(vti->getTown());
+		assert(vti->getTown()->creatures.size() <= GameConstants::CREATURES_PER_TOWN);
 
-		constexpr std::array basicDwellings = { BuildingID::DWELL_FIRST, BuildingID::DWELL_LVL_2, BuildingID::DWELL_LVL_3, BuildingID::DWELL_LVL_4, BuildingID::DWELL_LVL_5, BuildingID::DWELL_LVL_6, BuildingID::DWELL_LVL_7 };
-		constexpr std::array upgradedDwellings = { BuildingID::DWELL_UP_FIRST, BuildingID::DWELL_LVL_2_UP, BuildingID::DWELL_LVL_3_UP, BuildingID::DWELL_LVL_4_UP, BuildingID::DWELL_LVL_5_UP, BuildingID::DWELL_LVL_6_UP, BuildingID::DWELL_LVL_7_UP };
-		constexpr std::array hordes = { BuildingID::HORDE_PLACEHOLDER1, BuildingID::HORDE_PLACEHOLDER2, BuildingID::HORDE_PLACEHOLDER3, BuildingID::HORDE_PLACEHOLDER4, BuildingID::HORDE_PLACEHOLDER5, BuildingID::HORDE_PLACEHOLDER6, BuildingID::HORDE_PLACEHOLDER7 };
+		constexpr std::array basicDwellings = { BuildingID::DWELL_FIRST, BuildingID::DWELL_LVL_2, BuildingID::DWELL_LVL_3, BuildingID::DWELL_LVL_4, BuildingID::DWELL_LVL_5, BuildingID::DWELL_LVL_6, BuildingID::DWELL_LVL_7, BuildingID::DWELL_LVL_8 };
+		constexpr std::array upgradedDwellings = { BuildingID::DWELL_UP_FIRST, BuildingID::DWELL_LVL_2_UP, BuildingID::DWELL_LVL_3_UP, BuildingID::DWELL_LVL_4_UP, BuildingID::DWELL_LVL_5_UP, BuildingID::DWELL_LVL_6_UP, BuildingID::DWELL_LVL_7_UP, BuildingID::DWELL_LVL_8_UP };
+		constexpr std::array hordes = { BuildingID::HORDE_PLACEHOLDER1, BuildingID::HORDE_PLACEHOLDER2, BuildingID::HORDE_PLACEHOLDER3, BuildingID::HORDE_PLACEHOLDER4, BuildingID::HORDE_PLACEHOLDER5, BuildingID::HORDE_PLACEHOLDER6, BuildingID::HORDE_PLACEHOLDER7, BuildingID::HORDE_PLACEHOLDER8 };
 
 		//init buildings
-		if(vstd::contains(vti->builtBuildings, BuildingID::DEFAULT)) //give standard set of buildings
+		if(vti->hasBuilt(BuildingID::DEFAULT)) //give standard set of buildings
 		{
-			vti->builtBuildings.erase(BuildingID::DEFAULT);
-			vti->builtBuildings.insert(BuildingID::VILLAGE_HALL);
+			vti->removeBuilding(BuildingID::DEFAULT);
+			vti->addBuilding(BuildingID::VILLAGE_HALL);
 			if(vti->tempOwner != PlayerColor::NEUTRAL)
-				vti->builtBuildings.insert(BuildingID::TAVERN);
+				vti->addBuilding(BuildingID::TAVERN);
 
-			auto definesBuildingsChances = VLC->settings()->getVector(EGameSettings::TOWNS_STARTING_DWELLING_CHANCES);
+			auto definesBuildingsChances = getSettings().getVector(EGameSettings::TOWNS_STARTING_DWELLING_CHANCES);
 
 			for(int i = 0; i < definesBuildingsChances.size(); i++)
 			{
 				if((getRandomGenerator().nextInt(1,100) <= definesBuildingsChances[i]))
 				{
-					vti->builtBuildings.insert(basicDwellings[i]);
+					vti->addBuilding(basicDwellings[i]);
 				}
 			}
 		}
 
 		// village hall must always exist
-		vti->builtBuildings.insert(BuildingID::VILLAGE_HALL);
+		vti->addBuilding(BuildingID::VILLAGE_HALL);
 
 		//init hordes
-		for (int i = 0; i < GameConstants::CREATURES_PER_TOWN; i++)
+		for (int i = 0; i < vti->getTown()->creatures.size(); i++)
 		{
-			if (vstd::contains(vti->builtBuildings, hordes[i])) //if we have horde for this level
+			if(vti->hasBuilt(hordes[i])) //if we have horde for this level
 			{
-				vti->builtBuildings.erase(hordes[i]);//remove old ID
+				vti->removeBuilding(hordes[i]);//remove old ID
 				if (vti->getTown()->hordeLvl.at(0) == i)//if town first horde is this one
 				{
-					vti->builtBuildings.insert(BuildingID::HORDE_1);//add it
+					vti->addBuilding(BuildingID::HORDE_1);//add it
 					//if we have upgraded dwelling as well
-					if (vstd::contains(vti->builtBuildings, upgradedDwellings[i]))
-						vti->builtBuildings.insert(BuildingID::HORDE_1_UPGR);//add it as well
+					if(vti->hasBuilt(upgradedDwellings[i]))
+						vti->addBuilding(BuildingID::HORDE_1_UPGR);//add it as well
 				}
 				if (vti->getTown()->hordeLvl.at(1) == i)//if town second horde is this one
 				{
-					vti->builtBuildings.insert(BuildingID::HORDE_2);
-					if (vstd::contains(vti->builtBuildings, upgradedDwellings[i]))
-						vti->builtBuildings.insert(BuildingID::HORDE_2_UPGR);
+					vti->addBuilding(BuildingID::HORDE_2);
+					if(vti->hasBuilt(upgradedDwellings[i]))
+						vti->addBuilding(BuildingID::HORDE_2_UPGR);
 				}
 			}
 		}
 
 		//#1444 - remove entries that don't have buildings defined (like some unused extra town hall buildings)
 		//But DO NOT remove horde placeholders before they are replaced
-		vstd::erase_if(vti->builtBuildings, [vti](const BuildingID & bid)
-			{
-				return !vti->getTown()->buildings.count(bid) || !vti->getTown()->buildings.at(bid);
-			});
+		for(const auto & building : vti->getBuildings())
+		{
+			if(!vti->getTown()->buildings.count(building) || !vti->getTown()->buildings.at(building))
+				vti->removeBuilding(building);
+		}
 
-		if (vstd::contains(vti->builtBuildings, BuildingID::SHIPYARD) && vti->shipyardStatus()==IBoatGenerator::TILE_BLOCKED)
-			vti->builtBuildings.erase(BuildingID::SHIPYARD);//if we have harbor without water - erase it (this is H3 behaviour)
+		if(vti->hasBuilt(BuildingID::SHIPYARD) && vti->shipyardStatus()==IBoatGenerator::TILE_BLOCKED)
+			vti->removeBuilding(BuildingID::SHIPYARD);//if we have harbor without water - erase it (this is H3 behaviour)
 
 		//Early check for #1444-like problems
-		for([[maybe_unused]] const auto & building : vti->builtBuildings)
+		for([[maybe_unused]] const auto & building : vti->getBuildings())
 		{
 			assert(vti->getTown()->buildings.at(building) != nullptr);
 		}
@@ -893,7 +870,7 @@
 		//town events
 		for(CCastleEvent &ev : vti->events)
 		{
-			for (int i = 0; i<GameConstants::CREATURES_PER_TOWN; i++)
+			for (int i = 0; i<vti->getTown()->creatures.size(); i++)
 				if (vstd::contains(ev.buildings,hordes[i])) //if we have horde for this level
 				{
 					ev.buildings.erase(hordes[i]);
@@ -905,7 +882,7 @@
 		}
 		//init spells
 		vti->spells.resize(GameConstants::SPELL_LEVELS);
-
+		vti->possibleSpells -= SpellID::PRESET;
 		for(ui32 z=0; z<vti->obligatorySpells.size();z++)
 		{
 			const auto * s = vti->obligatorySpells[z].toSpell();
@@ -918,7 +895,7 @@
 			int sel = -1;
 
 			for(ui32 ps=0;ps<vti->possibleSpells.size();ps++)
-				total += vti->possibleSpells[ps].toSpell()->getProbability(vti->getFaction());
+				total += vti->possibleSpells[ps].toSpell()->getProbability(vti->getFactionID());
 
 			if (total == 0) // remaining spells have 0 probability
 				break;
@@ -926,7 +903,7 @@
 			auto r = getRandomGenerator().nextInt(total - 1);
 			for(ui32 ps=0; ps<vti->possibleSpells.size();ps++)
 			{
-				r -= vti->possibleSpells[ps].toSpell()->getProbability(vti->getFaction());
+				r -= vti->possibleSpells[ps].toSpell()->getProbability(vti->getFactionID());
 				if(r<0)
 				{
 					sel = ps;
@@ -941,8 +918,6 @@
 			vti->possibleSpells -= s->id;
 		}
 		vti->possibleSpells.clear();
-		if(vti->getOwner() != PlayerColor::NEUTRAL)
-			getPlayerState(vti->getOwner())->towns.emplace_back(vti);
 	}
 }
 
@@ -985,26 +960,22 @@
 		if(player.first == PlayerColor::NEUTRAL)
 			continue;
 
-		for(CGHeroInstance * h : player.second.heroes)
+		for(CGHeroInstance * h : player.second.getHeroes())
 		{
-			for(CGTownInstance * t : player.second.towns)
+			for(CGTownInstance * t : player.second.getTowns())
 			{
-				if(h->visitablePos().z != t->visitablePos().z)
-					continue;
-
-				bool heroOnTownBlockableTile = t->blockingAt(h->visitablePos().x, h->visitablePos().y);
+				bool heroOnTownBlockableTile = t->blockingAt(h->visitablePos());
 
 				// current hero position is at one of blocking tiles of current town
 				// assume that this hero should be visiting the town (H3M format quirk) and move hero to correct position
 				if (heroOnTownBlockableTile)
 				{
-					int3 correctedPos = h->convertFromVisitablePos(t->visitablePos());
-
 					map->removeBlockVisTiles(h);
-					h->pos = correctedPos;
+					int3 correctedPos = h->convertFromVisitablePos(t->visitablePos());
+					h->setAnchorPos(correctedPos);
 					map->addBlockVisTiles(h);
 
-					assert(t->visitableAt(h->visitablePos().x, h->visitablePos().y));
+					assert(t->visitableAt(h->visitablePos()));
 				}
 			}
 		}
@@ -1019,14 +990,14 @@
 			continue;
 
 		//init visiting and garrisoned heroes
-		for(CGHeroInstance * h : player.second.heroes)
+		for(CGHeroInstance * h : player.second.getHeroes())
 		{
-			for(CGTownInstance * t : player.second.towns)
+			for(CGTownInstance * t : player.second.getTowns())
 			{
 				if(h->visitablePos().z != t->visitablePos().z)
 					continue;
 
-				if (t->visitableAt(h->visitablePos().x, h->visitablePos().y))
+				if (t->visitableAt(h->visitablePos()))
 				{
 					assert(t->visitingHero == nullptr);
 					t->setVisitingHero(h);
@@ -1049,7 +1020,7 @@
 		return nullptr;
 
 	for (const auto & battlePtr : currentBattles)
-		if (battlePtr->sides[0].color == player || battlePtr->sides[1].color == player)
+		if (battlePtr->getSide(BattleSide::ATTACKER).color == player || battlePtr->getSide(BattleSide::DEFENDER).color == player)
 			return battlePtr.get();
 
 	return nullptr;
@@ -1073,7 +1044,7 @@
 	return nullptr;
 }
 
-BattleField CGameState::battleGetBattlefieldType(int3 tile, CRandomGenerator & rand)
+BattleField CGameState::battleGetBattlefieldType(int3 tile, vstd::RNG & rand)
 {
 	assert(tile.valid());
 
@@ -1091,7 +1062,7 @@
 	for(auto &obj : map->objects)
 	{
 		//look only for objects covering given tile
-		if( !obj || obj->pos.z != tile.z || !obj->coveringAt(tile.x, tile.y))
+		if( !obj || !obj->coveringAt(tile))
 			continue;
 
 		auto customBattlefield = obj->getBattlefield();
@@ -1103,10 +1074,10 @@
 	if(map->isCoastalTile(tile)) //coastal tile is always ground
 		return BattleField(*VLC->identifiers()->getIdentifier("core", "battlefield.sand_shore"));
 	
-	if (t.terType->battleFields.empty())
-		throw std::runtime_error("Failed to find battlefield for terrain " + t.terType->getJsonKey());
+	if (t.getTerrain()->battleFields.empty())
+		throw std::runtime_error("Failed to find battlefield for terrain " + t.getTerrain()->getJsonKey());
 
-	return BattleField(*RandomGeneratorUtil::nextItem(t.terType->battleFields, rand));
+	return BattleField(*RandomGeneratorUtil::nextItem(t.getTerrain()->battleFields, rand));
 }
 
 void CGameState::fillUpgradeInfo(const CArmedInstance *obj, SlotID stackPos, UpgradeInfo &out) const
@@ -1120,7 +1091,7 @@
 UpgradeInfo CGameState::fillUpgradeInfo(const CStackInstance &stack) const
 {
 	UpgradeInfo ret;
-	const CCreature *base = stack.type;
+	const CCreature *base = stack.getCreature();
 
 	if (stack.armyObj->ID == Obj::HERO)
 	{
@@ -1168,10 +1139,9 @@
 	return PlayerRelations::ENEMIES;
 }
 
-void CGameState::apply(CPack *pack)
+void CGameState::apply(CPackForClient & pack)
 {
-	ui16 typ = CTypeList::getInstance().getTypeID(pack);
-	applier->getApplier(typ)->applyOnGS(this, pack);
+	pack.applyGs(this);
 }
 
 void CGameState::calculatePaths(const CGHeroInstance *hero, CPathsInfo &out)
@@ -1201,7 +1171,7 @@
 		return guards;
 
 	const TerrainTile &posTile = map->getTile(pos);
-	if (posTile.visitable)
+	if (posTile.visitable())
 	{
 		for (CGObjectInstance* obj : posTile.visitableObjects)
 		{
@@ -1220,7 +1190,7 @@
 			if (map->isInTheMap(pos))
 			{
 				const auto & tile = map->getTile(pos);
-				if (tile.visitable && (tile.isWater() == posTile.isWater()))
+				if (tile.visitable() && (tile.isWater() == posTile.isWater()))
 				{
 					for (CGObjectInstance* obj : tile.visitableObjects)
 					{
@@ -1246,78 +1216,6 @@
 	return gs->map->guardingCreaturePositions[pos.z][pos.x][pos.y];
 }
 
-void CGameState::updateRumor()
-{
-	static const std::vector<RumorState::ERumorType> rumorTypes = {RumorState::TYPE_MAP, RumorState::TYPE_SPECIAL, RumorState::TYPE_RAND, RumorState::TYPE_RAND};
-	std::vector<RumorState::ERumorTypeSpecial> sRumorTypes = {
-		RumorState::RUMOR_OBELISKS, RumorState::RUMOR_ARTIFACTS, RumorState::RUMOR_ARMY, RumorState::RUMOR_INCOME};
-	if(map->grailPos.valid()) // Grail should always be on map, but I had related crash I didn't manage to reproduce
-		sRumorTypes.push_back(RumorState::RUMOR_GRAIL);
-
-	int rumorId = -1;
-	int rumorExtra = -1;
-	auto & rand = getRandomGenerator();
-	rumor.type = *RandomGeneratorUtil::nextItem(rumorTypes, rand);
-
-	do
-	{
-		switch(rumor.type)
-		{
-		case RumorState::TYPE_SPECIAL:
-		{
-			SThievesGuildInfo tgi;
-			obtainPlayersStats(tgi, 20);
-			rumorId = *RandomGeneratorUtil::nextItem(sRumorTypes, rand);
-			if(rumorId == RumorState::RUMOR_GRAIL)
-			{
-				rumorExtra = getTile(map->grailPos)->terType->getIndex();
-				break;
-			}
-
-			std::vector<PlayerColor> players = {};
-			switch(rumorId)
-			{
-			case RumorState::RUMOR_OBELISKS:
-				players = tgi.obelisks[0];
-				break;
-
-			case RumorState::RUMOR_ARTIFACTS:
-				players = tgi.artifacts[0];
-				break;
-
-			case RumorState::RUMOR_ARMY:
-				players = tgi.army[0];
-				break;
-
-			case RumorState::RUMOR_INCOME:
-				players = tgi.income[0];
-				break;
-			}
-			rumorExtra = RandomGeneratorUtil::nextItem(players, rand)->getNum();
-
-			break;
-		}
-		case RumorState::TYPE_MAP:
-			// Makes sure that map rumors only used if there enough rumors too choose from
-			if(!map->rumors.empty() && (map->rumors.size() > 1 || !rumor.last.count(RumorState::TYPE_MAP)))
-			{
-				rumorId = rand.nextInt((int)map->rumors.size() - 1);
-				break;
-			}
-			else
-				rumor.type = RumorState::TYPE_RAND;
-			[[fallthrough]];
-
-		case RumorState::TYPE_RAND:
-			auto vector = VLC->generaltexth->findStringsWithPrefix("core.randtvrn");
-			rumorId = rand.nextInt((int)vector.size() - 1);
-
-			break;
-		}
-	}
-	while(!rumor.update(rumorId, rumorExtra));
-}
-
 bool CGameState::isVisible(int3 pos, const std::optional<PlayerColor> & player) const
 {
 	if (!map->isInTheMap(pos))
@@ -1329,7 +1227,7 @@
 	if(player->isSpectator())
 		return true;
 
-	return (*getPlayerTeam(*player)->fogOfWarMap)[pos.z][pos.x][pos.y];
+	return getPlayerTeam(*player)->fogOfWarMap[pos.z][pos.x][pos.y];
 }
 
 bool CGameState::isVisible(const CGObjectInstance * obj, const std::optional<PlayerColor> & player) const
@@ -1348,10 +1246,10 @@
 	{
 		for(int fx=0; fx < obj->getWidth(); ++fx)
 		{
-			int3 pos = obj->pos + int3(-fx, -fy, 0);
+			int3 pos = obj->anchorPos() + int3(-fx, -fy, 0);
 
 			if ( map->isInTheMap(pos) &&
-				 obj->coveringAt(pos.x, pos.y) &&
+				 obj->coveringAt(pos) &&
 				 isVisible(pos, *player))
 				return true;
 		}
@@ -1416,7 +1314,7 @@
 		}
 		case EventCondition::HAVE_ARTIFACT: //check if any hero has winning artifact
 		{
-			for(const auto & elem : p->heroes)
+			for(const auto & elem : p->getHeroes())
 				if(elem->hasArt(condition.objectType.as<ArtifactID>()))
 					return true;
 			return false;
@@ -1450,7 +1348,7 @@
 			}
 			else // any town
 			{
-				for (const CGTownInstance * t : p->towns)
+				for (const CGTownInstance * t : p->getTowns())
 				{
 					if (t->hasBuilt(condition.objectType.as<BuildingID>()))
 						return true;
@@ -1564,137 +1462,6 @@
 	return pState.checkVanquished();
 }
 
-struct statsHLP
-{
-	using TStat = std::pair<PlayerColor, si64>;
-	//converts [<player's color, value>] to vec[place] -> platers
-	static std::vector< std::vector< PlayerColor > > getRank( std::vector<TStat> stats )
-	{
-		std::sort(stats.begin(), stats.end(), statsHLP());
-
-		//put first element
-		std::vector< std::vector<PlayerColor> > ret;
-		std::vector<PlayerColor> tmp;
-		tmp.push_back( stats[0].first );
-		ret.push_back( tmp );
-
-		//the rest of elements
-		for(int g=1; g<stats.size(); ++g)
-		{
-			if(stats[g].second == stats[g-1].second)
-			{
-				(ret.end()-1)->push_back( stats[g].first );
-			}
-			else
-			{
-				//create next occupied rank
-				std::vector<PlayerColor> tmp;
-				tmp.push_back(stats[g].first);
-				ret.push_back(tmp);
-			}
-		}
-
-		return ret;
-	}
-
-	bool operator()(const TStat & a, const TStat & b) const
-	{
-		return a.second > b.second;
-	}
-
-	static const CGHeroInstance * findBestHero(CGameState * gs, const PlayerColor & color)
-	{
-		std::vector<ConstTransitivePtr<CGHeroInstance> > &h = gs->players[color].heroes;
-		if(h.empty())
-			return nullptr;
-		//best hero will be that with highest exp
-		int best = 0;
-		for(int b=1; b<h.size(); ++b)
-		{
-			if(h[b]->exp > h[best]->exp)
-			{
-				best = b;
-			}
-		}
-		return h[best];
-	}
-
-	//calculates total number of artifacts that belong to given player
-	static int getNumberOfArts(const PlayerState * ps)
-	{
-		int ret = 0;
-		for(auto h : ps->heroes)
-		{
-			ret += (int)h->artifactsInBackpack.size() + (int)h->artifactsWorn.size();
-		}
-		return ret;
-	}
-
-	// get total strength of player army
-	static si64 getArmyStrength(const PlayerState * ps)
-	{
-		si64 str = 0;
-
-		for(auto h : ps->heroes)
-		{
-			if(!h->inTownGarrison)		//original h3 behavior
-				str += h->getArmyStrength();
-		}
-		return str;
-	}
-
-	// get total gold income
-	static int getIncome(const PlayerState * ps)
-	{
-		int totalIncome = 0;
-		const CGObjectInstance * heroOrTown = nullptr;
-
-		//Heroes can produce gold as well - skill, specialty or arts
-		for(const auto & h : ps->heroes)
-		{
-			totalIncome += h->valOfBonuses(Selector::typeSubtype(BonusType::GENERATE_RESOURCE, BonusSubtypeID(GameResID(GameResID::GOLD))));
-
-			if(!heroOrTown)
-				heroOrTown = h;
-		}
-
-		//Add town income of all towns
-		for(const auto & t : ps->towns)
-		{
-			totalIncome += t->dailyIncome()[EGameResID::GOLD];
-
-			if(!heroOrTown)
-				heroOrTown = t;
-		}
-
-		/// FIXME: Dirty dirty hack
-		/// Stats helper need some access to gamestate.
-		std::vector<const CGObjectInstance *> ownedObjects;
-		for(const CGObjectInstance * obj : heroOrTown->cb->gameState()->map->objects)
-		{
-			if(obj && obj->tempOwner == ps->color)
-				ownedObjects.push_back(obj);
-		}
-		/// This is code from CPlayerSpecificInfoCallback::getMyObjects
-		/// I'm really need to find out about callback interface design...
-
-		for(const auto * object : ownedObjects)
-		{
-			//Mines
-			if ( object->ID == Obj::MINE )
-			{
-				const auto * mine = dynamic_cast<const CGMine *>(object);
-				assert(mine);
-
-				if (mine->producedResource == EGameResID::GOLD)
-					totalIncome += mine->producedQuantity;
-			}
-		}
-
-		return totalIncome;
-	}
-};
-
 void CGameState::obtainPlayersStats(SThievesGuildInfo & tgi, int level)
 {
 	auto playerInactive = [&](const PlayerColor & color) 
@@ -1714,7 +1481,7 @@
 			stat.second = VAL_GETTER; \
 			stats.push_back(stat); \
 		} \
-		tgi.FIELD = statsHLP::getRank(stats); \
+		tgi.FIELD = Statistic::getRank(stats); \
 	}
 
 	for(auto & elem : players)
@@ -1726,9 +1493,9 @@
 	if(level >= 0) //num of towns & num of heroes
 	{
 		//num of towns
-		FILL_FIELD(numOfTowns, g->second.towns.size())
+		FILL_FIELD(numOfTowns, g->second.getTowns().size())
 		//num of heroes
-		FILL_FIELD(numOfHeroes, g->second.heroes.size())
+		FILL_FIELD(numOfHeroes, g->second.getHeroes().size())
 	}
 	if(level >= 1) //best hero's portrait
 	{
@@ -1736,7 +1503,7 @@
 		{
 			if(playerInactive(player.second.color))
 				continue;
-			const CGHeroInstance * best = statsHLP::findBestHero(this, player.second.color);
+			const CGHeroInstance * best = Statistic::findBestHero(this, player.second.color);
 			InfoAboutHero iah;
 			iah.initFromHero(best, (level >= 2) ? InfoAboutHero::EInfoLevel::DETAILED : InfoAboutHero::EInfoLevel::BASIC);
 			iah.army.clear();
@@ -1757,27 +1524,19 @@
 	}
 	if(level >= 3) //obelisks found
 	{
-		auto getObeliskVisited = [&](const TeamID & t)
-		{
-			if(map->obelisksVisited.count(t))
-				return map->obelisksVisited[t];
-			else
-				return ui8(0);
-		};
-
-		FILL_FIELD(obelisks, getObeliskVisited(gs->getPlayerTeam(g->second.color)->id))
+		FILL_FIELD(obelisks, Statistic::getObeliskVisited(gs, gs->getPlayerTeam(g->second.color)->id))
 	}
 	if(level >= 4) //artifacts
 	{
-		FILL_FIELD(artifacts, statsHLP::getNumberOfArts(&g->second))
+		FILL_FIELD(artifacts, Statistic::getNumberOfArts(&g->second))
 	}
 	if(level >= 4) //army strength
 	{
-		FILL_FIELD(army, statsHLP::getArmyStrength(&g->second))
+		FILL_FIELD(army, Statistic::getArmyStrength(&g->second))
 	}
 	if(level >= 5) //income
 	{
-		FILL_FIELD(income, statsHLP::getIncome(&g->second))
+		FILL_FIELD(income, Statistic::getIncome(gs, &g->second))
 	}
 	if(level >= 2) //best hero's stats
 	{
@@ -1808,11 +1567,11 @@
 			if(playerInactive(player.second.color)) //do nothing for neutral player
 				continue;
 			CreatureID bestCre; //best creature's ID
-			for(const auto & elem : player.second.heroes)
+			for(const auto & elem : player.second.getHeroes())
 			{
 				for(const auto & it : elem->Slots())
 				{
-					CreatureID toCmp = it.second->type->getId(); //ID of creature we should compare with the best one
+					CreatureID toCmp = it.second->getId(); //ID of creature we should compare with the best one
 					if(bestCre == CreatureID::NONE || bestCre.toEntity(VLC)->getAIValue() < toCmp.toEntity(VLC)->getAIValue())
 					{
 						bestCre = toCmp;
@@ -1872,12 +1631,12 @@
 
 bool CGameState::giveHeroArtifact(CGHeroInstance * h, const ArtifactID & aid)
 {
-	 CArtifactInstance * ai = ArtifactUtils::createNewArtifactInstance(aid);
+	 CArtifactInstance * ai = ArtifactUtils::createArtifact(aid);
 	 map->addNewArtifactInstance(ai);
 	 auto slot = ArtifactUtils::getArtAnyPosition(h, aid);
 	 if(ArtifactUtils::isSlotEquipment(slot) || ArtifactUtils::isSlotBackpack(slot))
 	 {
-		 ai->putAt(*h, slot);
+		 map->putArtifactInstance(*h, ai, slot);
 		 return true;
 	 }
 	 else
@@ -1897,18 +1656,13 @@
 	}
 
 	for(auto hero : map->heroesOnMap)  //heroes instances initialization
-	{
-		if(hero->type)
-			ret -= hero->type->getId();
-		else
-			ret -= hero->getHeroType();
-	}
+		ret -= hero->getHeroTypeID();
 
 	for(auto obj : map->objects) //prisons
 	{
 		auto * hero = dynamic_cast<const CGHeroInstance *>(obj.get());
 		if(hero && hero->ID == Obj::PRISON)
-			ret -= hero->getHeroType();
+			ret -= hero->getHeroTypeID();
 	}
 
 	return ret;
@@ -1932,47 +1686,30 @@
 		auto * hero = dynamic_cast<CGHeroInstance *>(obj.get());
 		assert(hero);
 
-		if (hero->getHeroType() == hid)
+		if (hero->getHeroTypeID() == hid)
 			return hero;
 	}
 
 	return nullptr;
 }
 
-bool RumorState::update(int id, int extra)
-{
-	if(vstd::contains(last, type))
-	{
-		if(last[type].first != id)
-		{
-			last[type].first = id;
-			last[type].second = extra;
-		}
-		else
-			return false;
-	}
-	else
-		last[type] = std::make_pair(id, extra);
 
-	return true;
-}
 
 TeamState::TeamState()
 {
 	setNodeType(TEAM);
-	fogOfWarMap = std::make_unique<boost::multi_array<ui8, 3>>();
 }
 
-CRandomGenerator & CGameState::getRandomGenerator()
+vstd::RNG & CGameState::getRandomGenerator()
 {
-	return rand;
+	return callback->getRandomGenerator();
 }
 
-ArtifactID CGameState::pickRandomArtifact(CRandomGenerator & rand, int flags, std::function<bool(ArtifactID)> accepts)
+ArtifactID CGameState::pickRandomArtifact(vstd::RNG & rand, int flags, std::function<bool(ArtifactID)> accepts)
 {
 	std::set<ArtifactID> potentialPicks;
 
-	// Select artifacts that satisfy provided criterias
+	// Select artifacts that satisfy provided criteria
 	for (auto const & artifactID : map->allowedArtifact)
 	{
 		if (!VLC->arth->legalArtifact(artifactID))
@@ -2003,7 +1740,7 @@
 	return pickRandomArtifact(rand, potentialPicks);
 }
 
-ArtifactID CGameState::pickRandomArtifact(CRandomGenerator & rand, std::set<ArtifactID> potentialPicks)
+ArtifactID CGameState::pickRandomArtifact(vstd::RNG & rand, std::set<ArtifactID> potentialPicks)
 {
 	// No allowed artifacts at all - give Grail - this can't be banned (hopefully)
 	// FIXME: investigate how such cases are handled by H3 - some heavily customized user-made maps likely rely on H3 behavior
@@ -2032,12 +1769,12 @@
 	return artID;
 }
 
-ArtifactID CGameState::pickRandomArtifact(CRandomGenerator & rand, std::function<bool(ArtifactID)> accepts)
+ArtifactID CGameState::pickRandomArtifact(vstd::RNG & rand, std::function<bool(ArtifactID)> accepts)
 {
 	return pickRandomArtifact(rand, 0xff, std::move(accepts));
 }
 
-ArtifactID CGameState::pickRandomArtifact(CRandomGenerator & rand, int flags)
+ArtifactID CGameState::pickRandomArtifact(vstd::RNG & rand, int flags)
 {
 	return pickRandomArtifact(rand, flags, [](const ArtifactID &) { return true; });
 }
diff --color -urN vcmi-1.5.7/lib/gameState/CGameState.h vcmi/lib/gameState/CGameState.h
--- vcmi-1.5.7/lib/gameState/CGameState.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/gameState/CGameState.h	2024-12-19 15:00:22.903148144 +0100
@@ -9,11 +9,13 @@
  */
 #pragma once
 
-#include "bonuses/CBonusSystemNode.h"
-#include "IGameCallback.h"
-#include "LoadProgress.h"
-#include "ConstTransitivePtr.h"
-#include "../CRandomGenerator.h"
+#include "../bonuses/CBonusSystemNode.h"
+#include "../IGameCallback.h"
+#include "../LoadProgress.h"
+#include "../ConstTransitivePtr.h"
+
+#include "RumorState.h"
+#include "GameStatistics.h"
 
 namespace boost
 {
@@ -34,38 +36,8 @@
 class CGameStateCampaign;
 class TavernHeroesPool;
 struct SThievesGuildInfo;
-
-template<typename T> class CApplier;
-class CBaseForGSApply;
-
-struct DLL_LINKAGE RumorState
-{
-	enum ERumorType : ui8
-	{
-		TYPE_NONE = 0, TYPE_RAND, TYPE_SPECIAL, TYPE_MAP
-	};
-
-	enum ERumorTypeSpecial : ui8
-	{
-		RUMOR_OBELISKS = 208,
-		RUMOR_ARTIFACTS = 209,
-		RUMOR_ARMY = 210,
-		RUMOR_INCOME = 211,
-		RUMOR_GRAIL = 212
-	};
-
-	ERumorType type;
-	std::map<ERumorType, std::pair<int, int>> last;
-
-	RumorState(){type = TYPE_NONE;};
-	bool update(int id, int extra);
-
-	template <typename Handler> void serialize(Handler &h)
-	{
-		h & type;
-		h & last;
-	}
-};
+class CRandomGenerator;
+class GameSettings;
 
 struct UpgradeInfo
 {
@@ -79,10 +51,9 @@
 
 DLL_LINKAGE std::ostream & operator<<(std::ostream & os, const EVictoryLossCheckResult & victoryLossCheckResult);
 
-class DLL_LINKAGE CGameState : public CNonConstInfoCallback
+class DLL_LINKAGE CGameState : public CNonConstInfoCallback, public Serializeable
 {
 	friend class CGameStateCampaign;
-
 public:
 	/// Stores number of times each artifact was placed on map via randomization
 	std::map<ArtifactID, int> allocatedArtifacts;
@@ -115,7 +86,9 @@
 	std::map<PlayerColor, PlayerState> players;
 	std::map<TeamID, TeamState> teams;
 	CBonusSystemNode globalEffects;
-	RumorState rumor;
+	RumorState currentRumor;
+
+	StatisticDataSet statistic;
 
 	static boost::shared_mutex mutex;
 
@@ -125,8 +98,8 @@
 	/// picks next free hero type of the H3 hero init sequence -> chosen starting hero, then unused hero type randomly
 	HeroTypeID pickNextHeroType(const PlayerColor & owner);
 
-	void apply(CPack *pack);
-	BattleField battleGetBattlefieldType(int3 tile, CRandomGenerator & rand);
+	void apply(CPackForClient & pack);
+	BattleField battleGetBattlefieldType(int3 tile, vstd::RNG & rand);
 
 	void fillUpgradeInfo(const CArmedInstance *obj, SlotID stackPos, UpgradeInfo &out) const override;
 	PlayerRelations getPlayerRelations(PlayerColor color1, PlayerColor color2) const override;
@@ -135,13 +108,12 @@
 	void calculatePaths(const std::shared_ptr<PathfinderConfig> & config) override;
 	int3 guardingCreaturePosition (int3 pos) const override;
 	std::vector<CGObjectInstance*> guardingCreatures (int3 pos) const;
-	void updateRumor();
 
 	/// Gets a artifact ID randomly and removes the selected artifact from this handler.
-	ArtifactID pickRandomArtifact(CRandomGenerator & rand, int flags);
-	ArtifactID pickRandomArtifact(CRandomGenerator & rand, std::function<bool(ArtifactID)> accepts);
-	ArtifactID pickRandomArtifact(CRandomGenerator & rand, int flags, std::function<bool(ArtifactID)> accepts);
-	ArtifactID pickRandomArtifact(CRandomGenerator & rand, std::set<ArtifactID> filtered);
+	ArtifactID pickRandomArtifact(vstd::RNG & rand, int flags);
+	ArtifactID pickRandomArtifact(vstd::RNG & rand, std::function<bool(ArtifactID)> accepts);
+	ArtifactID pickRandomArtifact(vstd::RNG & rand, int flags, std::function<bool(ArtifactID)> accepts);
+	ArtifactID pickRandomArtifact(vstd::RNG & rand, std::set<ArtifactID> filtered);
 
 	/// Returns battle in which selected player is engaged, or nullptr if none.
 	/// Can NOT be used with neutral player, use battle by ID instead
@@ -158,10 +130,12 @@
 	bool checkForStandardLoss(const PlayerColor & player) const; //checks if given player lost the game
 
 	void obtainPlayersStats(SThievesGuildInfo & tgi, int level); //fills tgi with info about other players that is available at given level of thieves' guild
+	const IGameSettings & getSettings() const;
 
 	bool isVisible(int3 pos, const std::optional<PlayerColor> & player) const override;
 	bool isVisible(const CGObjectInstance * obj, const std::optional<PlayerColor> & player) const override;
 
+	static int getDate(int day, Date mode);
 	int getDate(Date mode=Date::DAY) const override; //mode=0 - total days in game, mode=1 - day of week, mode=2 - current week, mode=3 - current month
 
 	// ----- getters, setters -----
@@ -169,11 +143,11 @@
 	/// This RNG should only be used inside GS or CPackForClient-derived applyGs
 	/// If this doesn't work for your code that mean you need a new netpack
 	///
-	/// Client-side must use CRandomGenerator::getDefault which is not serialized
+	/// Client-side must use vstd::RNG::getDefault which is not serialized
 	///
-	/// CGameHandler have it's own getter for CRandomGenerator::getDefault
-	/// Any server-side code outside of GH must use CRandomGenerator::getDefault
-	CRandomGenerator & getRandomGenerator();
+	/// CGameHandler have it's own getter for vstd::RNG::getDefault
+	/// Any server-side code outside of GH must use vstd::RNG::getDefault
+	vstd::RNG & getRandomGenerator();
 
 	template <typename Handler> void serialize(Handler &h)
 	{
@@ -183,13 +157,21 @@
 		h & day;
 		h & map;
 		h & players;
+		if (h.version < Handler::Version::PLAYER_STATE_OWNED_OBJECTS)
+			generateOwnedObjectsAfterDeserialize();
 		h & teams;
 		h & heroesPool;
 		h & globalEffects;
-		h & rand;
-		h & rumor;
+		if (h.version < Handler::Version::REMOVE_LIB_RNG)
+		{
+			std::string oldStateOfRNG;
+			h & oldStateOfRNG;
+		}
+		h & currentRumor;
 		h & campaign;
 		h & allocatedArtifacts;
+		if (h.version >= Handler::Version::STATISTICS)
+			h & statistic;
 
 		BONUS_TREE_DESERIALIZATION_FIX
 	}
@@ -197,10 +179,10 @@
 private:
 	// ----- initialization -----
 	void initNewGame(const IMapService * mapService, bool allowSavingRandomMap, Load::ProgressAccumulator & progressTracking);
-	void checkMapChecksum();
 	void initGlobalBonuses();
 	void initGrailPosition();
 	void initRandomFactionsForPlayers();
+	void initOwnedObjects();
 	void randomizeMapObjects();
 	void initPlayerStates();
 	void placeStartingHeroes();
@@ -217,6 +199,8 @@
 	void initVisitingAndGarrisonedHeroes();
 	void initCampaign();
 
+	void generateOwnedObjectsAfterDeserialize();
+
 	// ----- bonus system handling -----
 
 	void buildBonusSystemTree();
@@ -233,11 +217,9 @@
 	UpgradeInfo fillUpgradeInfo(const CStackInstance &stack) const;
 
 	// ---- data -----
-	std::shared_ptr<CApplier<CBaseForGSApply>> applier;
-	CRandomGenerator rand;
 	Services * services;
 
-	/// Ponter to campaign state manager. Nullptr for single scenarios
+	/// Pointer to campaign state manager. Nullptr for single scenarios
 	std::unique_ptr<CGameStateCampaign> campaign;
 
 	friend class IGameCallback;
diff --color -urN vcmi-1.5.7/lib/gameState/EVictoryLossCheckResult.h vcmi/lib/gameState/EVictoryLossCheckResult.h
--- vcmi-1.5.7/lib/gameState/EVictoryLossCheckResult.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/gameState/EVictoryLossCheckResult.h	2024-12-19 15:00:22.904148185 +0100
@@ -9,8 +9,6 @@
  */
 #pragma once
 
-#include "MetaString.h"
-
 VCMI_LIB_NAMESPACE_BEGIN
 
 class DLL_LINKAGE EVictoryLossCheckResult
diff --color -urN vcmi-1.5.7/lib/gameState/GameStatistics.cpp vcmi/lib/gameState/GameStatistics.cpp
--- vcmi-1.5.7/lib/gameState/GameStatistics.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/gameState/GameStatistics.cpp	2024-12-19 15:00:22.904148185 +0100
@@ -0,0 +1,394 @@
+/*
+ * GameStatistics.cpp, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#include "StdInc.h"
+#include "GameStatistics.h"
+#include "../CPlayerState.h"
+#include "../constants/StringConstants.h"
+#include "../VCMIDirs.h"
+#include "CGameState.h"
+#include "TerrainHandler.h"
+#include "StartInfo.h"
+#include "HighScore.h"
+#include "../mapObjects/CGHeroInstance.h"
+#include "../mapObjects/CGTownInstance.h"
+#include "../mapObjects/CGObjectInstance.h"
+#include "../mapObjects/MiscObjects.h"
+#include "../mapping/CMap.h"
+#include "../entities/building/CBuilding.h"
+
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+void StatisticDataSet::add(StatisticDataSetEntry entry)
+{
+	data.push_back(entry);
+}
+
+StatisticDataSetEntry StatisticDataSet::createEntry(const PlayerState * ps, const CGameState * gs)
+{
+	StatisticDataSetEntry data;
+
+	HighScoreParameter param = HighScore::prepareHighScores(gs, ps->color, false);
+	HighScoreCalculation scenarioHighScores;
+	scenarioHighScores.parameters.push_back(param);
+	scenarioHighScores.isCampaign = false;
+
+	data.map = gs->map->name.toString();
+	data.timestamp = std::time(nullptr);
+	data.day = gs->getDate(Date::DAY);
+	data.player = ps->color;
+	data.playerName = gs->getStartInfo()->playerInfos.at(ps->color).name;
+	data.team = ps->team;
+	data.isHuman = ps->isHuman();
+	data.status = ps->status;
+	data.resources = ps->resources;
+	data.numberHeroes = ps->getHeroes().size();
+	data.numberTowns = gs->howManyTowns(ps->color);
+	data.numberArtifacts = Statistic::getNumberOfArts(ps);
+	data.numberDwellings = Statistic::getNumberOfDwellings(ps);
+	data.armyStrength = Statistic::getArmyStrength(ps, true);
+	data.totalExperience = Statistic::getTotalExperience(ps);
+	data.income = Statistic::getIncome(gs, ps);
+	data.mapExploredRatio = Statistic::getMapExploredRatio(gs, ps->color);
+	data.obeliskVisitedRatio = Statistic::getObeliskVisitedRatio(gs, ps->team);
+	data.townBuiltRatio = Statistic::getTownBuiltRatio(ps);
+	data.hasGrail = param.hasGrail;
+	data.numMines = Statistic::getNumMines(gs, ps);
+	data.score = scenarioHighScores.calculate().total;
+	data.maxHeroLevel = Statistic::findBestHero(gs, ps->color) ? Statistic::findBestHero(gs, ps->color)->level : 0;
+	data.numBattlesNeutral = gs->statistic.accumulatedValues.count(ps->color) ? gs->statistic.accumulatedValues.at(ps->color).numBattlesNeutral : 0;
+	data.numBattlesPlayer = gs->statistic.accumulatedValues.count(ps->color) ? gs->statistic.accumulatedValues.at(ps->color).numBattlesPlayer : 0;
+	data.numWinBattlesNeutral = gs->statistic.accumulatedValues.count(ps->color) ? gs->statistic.accumulatedValues.at(ps->color).numWinBattlesNeutral : 0;
+	data.numWinBattlesPlayer = gs->statistic.accumulatedValues.count(ps->color) ? gs->statistic.accumulatedValues.at(ps->color).numWinBattlesPlayer : 0;
+	data.numHeroSurrendered = gs->statistic.accumulatedValues.count(ps->color) ? gs->statistic.accumulatedValues.at(ps->color).numHeroSurrendered : 0;
+	data.numHeroEscaped = gs->statistic.accumulatedValues.count(ps->color) ? gs->statistic.accumulatedValues.at(ps->color).numHeroEscaped : 0;
+	data.spentResourcesForArmy = gs->statistic.accumulatedValues.count(ps->color) ? gs->statistic.accumulatedValues.at(ps->color).spentResourcesForArmy : TResources();
+	data.spentResourcesForBuildings = gs->statistic.accumulatedValues.count(ps->color) ? gs->statistic.accumulatedValues.at(ps->color).spentResourcesForBuildings : TResources();
+	data.tradeVolume = gs->statistic.accumulatedValues.count(ps->color) ? gs->statistic.accumulatedValues.at(ps->color).tradeVolume : TResources();
+	data.eventCapturedTown = gs->statistic.accumulatedValues.count(ps->color) ? gs->statistic.accumulatedValues.at(ps->color).lastCapturedTownDay == gs->getDate(Date::DAY) : false;
+	data.eventDefeatedStrongestHero = gs->statistic.accumulatedValues.count(ps->color) ? gs->statistic.accumulatedValues.at(ps->color).lastDefeatedStrongestHeroDay == gs->getDate(Date::DAY) : false;
+	data.movementPointsUsed = gs->statistic.accumulatedValues.count(ps->color) ? gs->statistic.accumulatedValues.at(ps->color).movementPointsUsed : 0;
+
+	return data;
+}
+
+std::string StatisticDataSet::toCsv(std::string sep)
+{
+	std::stringstream ss;
+
+	auto resources = std::vector<EGameResID>{EGameResID::GOLD, EGameResID::WOOD, EGameResID::MERCURY, EGameResID::ORE, EGameResID::SULFUR, EGameResID::CRYSTAL, EGameResID::GEMS};
+
+	ss << "Map" << sep;
+	ss << "Timestamp" << sep;
+	ss << "Day" << sep;
+	ss << "Player" << sep;
+	ss << "PlayerName" << sep;
+	ss << "Team" << sep;
+	ss << "IsHuman" << sep;
+	ss << "Status" << sep;
+	ss << "NumberHeroes" << sep;
+	ss << "NumberTowns" << sep;
+	ss << "NumberArtifacts" << sep;
+	ss << "NumberDwellings" << sep;
+	ss << "ArmyStrength" << sep;
+	ss << "TotalExperience" << sep;
+	ss << "Income" << sep;
+	ss << "MapExploredRatio" << sep;
+	ss << "ObeliskVisitedRatio" << sep;
+	ss << "TownBuiltRatio" << sep;
+	ss << "HasGrail" << sep;
+	ss << "Score" << sep;
+	ss << "MaxHeroLevel" << sep;
+	ss << "NumBattlesNeutral" << sep;
+	ss << "NumBattlesPlayer" << sep;
+	ss << "NumWinBattlesNeutral" << sep;
+	ss << "NumWinBattlesPlayer" << sep;
+	ss << "NumHeroSurrendered" << sep;
+	ss << "NumHeroEscaped" << sep;
+	ss << "EventCapturedTown" << sep;
+	ss << "EventDefeatedStrongestHero" << sep;
+	ss << "MovementPointsUsed";
+	for(auto & resource : resources)
+		ss << sep << GameConstants::RESOURCE_NAMES[resource];
+	for(auto & resource : resources)
+		ss << sep << GameConstants::RESOURCE_NAMES[resource] + "Mines";
+	for(auto & resource : resources)
+		ss << sep << GameConstants::RESOURCE_NAMES[resource] + "SpentResourcesForArmy";
+	for(auto & resource : resources)
+		ss << sep << GameConstants::RESOURCE_NAMES[resource] + "SpentResourcesForBuildings";
+	for(auto & resource : resources)
+		ss << sep << GameConstants::RESOURCE_NAMES[resource] + "TradeVolume";
+	ss << "\r\n";
+
+	for(auto & entry : data)
+	{
+		ss << entry.map << sep;
+		ss << vstd::getFormattedDateTime(entry.timestamp, "%Y-%m-%dT%H:%M:%S") << sep;
+		ss << entry.day << sep;
+		ss << GameConstants::PLAYER_COLOR_NAMES[entry.player] << sep;
+		ss << entry.playerName << sep;
+		ss << entry.team.getNum() << sep;
+		ss << entry.isHuman << sep;
+		ss << static_cast<int>(entry.status) << sep;
+		ss << entry.numberHeroes << sep;
+		ss << entry.numberTowns <<  sep;
+		ss << entry.numberArtifacts << sep;
+		ss << entry.numberDwellings << sep;
+		ss << entry.armyStrength << sep;
+		ss << entry.totalExperience << sep;
+		ss << entry.income << sep;
+		ss << entry.mapExploredRatio << sep;
+		ss << entry.obeliskVisitedRatio << sep;
+		ss << entry.townBuiltRatio << sep;
+		ss << entry.hasGrail << sep;
+		ss << entry.score << sep;
+		ss << entry.maxHeroLevel << sep;
+		ss << entry.numBattlesNeutral << sep;
+		ss << entry.numBattlesPlayer << sep;
+		ss << entry.numWinBattlesNeutral << sep;
+		ss << entry.numWinBattlesPlayer << sep;
+		ss << entry.numHeroSurrendered << sep;
+		ss << entry.numHeroEscaped << sep;
+		ss << entry.eventCapturedTown << sep;
+		ss << entry.eventDefeatedStrongestHero << sep;
+		ss << entry.movementPointsUsed;
+		for(auto & resource : resources)
+			ss << sep << entry.resources[resource];
+		for(auto & resource : resources)
+			ss << sep << entry.numMines[resource];
+		for(auto & resource : resources)
+			ss << sep << entry.spentResourcesForArmy[resource];
+		for(auto & resource : resources)
+			ss << sep << entry.spentResourcesForBuildings[resource];
+		for(auto & resource : resources)
+			ss << sep << entry.tradeVolume[resource];
+		ss << "\r\n";
+	}
+
+	return ss.str();
+}
+
+std::string StatisticDataSet::writeCsv()
+{
+	const boost::filesystem::path outPath = VCMIDirs::get().userCachePath() / "statistic";
+	boost::filesystem::create_directories(outPath);
+
+	const boost::filesystem::path filePath = outPath / (vstd::getDateTimeISO8601Basic(std::time(nullptr)) + ".csv");
+	std::ofstream file(filePath.c_str());
+	std::string csv = toCsv(";");
+	file << csv;
+
+	return filePath.string();
+}
+
+std::vector<const CGMine *> Statistic::getMines(const CGameState * gs, const PlayerState * ps)
+{
+	std::vector<const CGMine *> tmp;
+
+	std::vector<const CGObjectInstance *> ownedObjects;
+	for(const CGObjectInstance * obj : gs->map->objects)
+	{
+		if(obj && obj->tempOwner == ps->color)
+			ownedObjects.push_back(obj);
+	}
+	/// This is code from CPlayerSpecificInfoCallback::getMyObjects
+	/// I'm really need to find out about callback interface design...
+
+	for(const auto * object : ownedObjects)
+	{
+		//Mines
+		if ( object->ID == Obj::MINE )
+		{
+			const auto * mine = dynamic_cast<const CGMine *>(object);
+			assert(mine);
+
+			tmp.push_back(mine);
+		}
+	}
+
+	return tmp;
+}
+
+//calculates total number of artifacts that belong to given player
+int Statistic::getNumberOfArts(const PlayerState * ps)
+{
+	int ret = 0;
+	for(auto h : ps->getHeroes())
+	{
+		ret += h->artifactsInBackpack.size() + h->artifactsWorn.size();
+	}
+	return ret;
+}
+
+int Statistic::getNumberOfDwellings(const PlayerState * ps)
+{
+	int ret = 0;
+	for(const auto * obj : ps->getOwnedObjects())
+		if (!obj->asOwnable()->providedCreatures().empty())
+			ret	+= 1;
+
+	return ret;
+}
+
+// get total strength of player army
+si64 Statistic::getArmyStrength(const PlayerState * ps, bool withTownGarrison)
+{
+	si64 str = 0;
+
+	for(auto h : ps->getHeroes())
+	{
+		if(!h->inTownGarrison || withTownGarrison)		//original h3 behavior
+			str += h->getArmyStrength();
+	}
+	return str;
+}
+
+// get total experience of all heroes
+si64 Statistic::getTotalExperience(const PlayerState * ps)
+{
+	si64 tmp = 0;
+
+	for(auto h : ps->getHeroes())
+		tmp += h->exp;
+	
+	return tmp;
+}
+
+// get total gold income
+int Statistic::getIncome(const CGameState * gs, const PlayerState * ps)
+{
+	int totalIncome = 0;
+
+	//Heroes can produce gold as well - skill, specialty or arts
+	for(const auto & h : ps->getHeroes())
+		totalIncome += h->dailyIncome()[EGameResID::GOLD];
+
+	//Add town income of all towns
+	for(const auto & t : ps->getTowns())
+		totalIncome += t->dailyIncome()[EGameResID::GOLD];
+
+	for(const CGMine * mine : getMines(gs, ps))
+			totalIncome += mine->dailyIncome()[EGameResID::GOLD];
+
+	return totalIncome;
+}
+
+float Statistic::getMapExploredRatio(const CGameState * gs, PlayerColor player)
+{
+	float visible = 0.0;
+	float numTiles = 0.0;
+
+	for(int layer = 0; layer < (gs->map->twoLevel ? 2 : 1); layer++)
+		for(int y = 0; y < gs->map->height; ++y)
+			for(int x = 0; x < gs->map->width; ++x)
+			{
+				TerrainTile tile = gs->map->getTile(int3(x, y, layer));
+
+				if(tile.blocked() && !tile.visitable())
+					continue;
+
+				if(gs->isVisible(int3(x, y, layer), player))
+					visible++;
+				numTiles++;
+			}
+	
+	return visible / numTiles;
+}
+
+const CGHeroInstance * Statistic::findBestHero(const CGameState * gs, const PlayerColor & color)
+{
+	const auto &h = gs->players.at(color).getHeroes();
+	if(h.empty())
+		return nullptr;
+	//best hero will be that with highest exp
+	int best = 0;
+	for(int b=1; b<h.size(); ++b)
+	{
+		if(h[b]->exp > h[best]->exp)
+		{
+			best = b;
+		}
+	}
+	return h[best];
+}
+
+std::vector<std::vector<PlayerColor>> Statistic::getRank(std::vector<std::pair<PlayerColor, si64>> stats)
+{
+	std::sort(stats.begin(), stats.end(), [](const std::pair<PlayerColor, si64> & a, const std::pair<PlayerColor, si64> & b) { return a.second > b.second; });
+
+	//put first element
+	std::vector< std::vector<PlayerColor> > ret;
+	ret.push_back( { stats[0].first } );
+
+	//the rest of elements
+	for(int g=1; g<stats.size(); ++g)
+	{
+		if(stats[g].second == stats[g-1].second)
+		{
+			(ret.end()-1)->push_back( stats[g].first );
+		}
+		else
+		{
+			//create next occupied rank
+			ret.push_back( { stats[g].first });
+		}
+	}
+
+	return ret;
+}
+
+int Statistic::getObeliskVisited(const CGameState * gs, const TeamID & t)
+{
+	if(gs->map->obelisksVisited.count(t))
+		return gs->map->obelisksVisited.at(t);
+	else
+		return 0;
+}
+
+float Statistic::getObeliskVisitedRatio(const CGameState * gs, const TeamID & t)
+{
+	if(!gs->map->obeliskCount)
+		return 0;
+	return static_cast<float>(getObeliskVisited(gs, t)) / gs->map->obeliskCount;
+}
+
+std::map<EGameResID, int> Statistic::getNumMines(const CGameState * gs, const PlayerState * ps)
+{
+	std::map<EGameResID, int> tmp;
+
+	for(auto & res : EGameResID::ALL_RESOURCES())
+		tmp[res] = 0;
+
+	for(const CGMine * mine : getMines(gs, ps))
+		tmp[mine->producedResource]++;
+	
+	return tmp;
+}
+
+float Statistic::getTownBuiltRatio(const PlayerState * ps)
+{
+	float built = 0.0;
+	float total = 0.0;
+
+	for(const auto & t : ps->getTowns())
+	{
+		built += t->getBuildings().size();
+		for(const auto & b : t->getTown()->buildings)
+			if(!t->forbiddenBuildings.count(b.first))
+				total += 1;
+	}
+
+	if(total < 1)
+		return 0;
+	
+	return built / total;
+}
+
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/gameState/GameStatistics.h vcmi/lib/gameState/GameStatistics.h
--- vcmi-1.5.7/lib/gameState/GameStatistics.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/gameState/GameStatistics.h	2024-12-19 15:00:22.904148185 +0100
@@ -0,0 +1,174 @@
+/*
+ * GameSTatistics.h, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#pragma once
+
+#include "../GameConstants.h"
+#include "../ResourceSet.h"
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+class PlayerState;
+class CGameState;
+class CGHeroInstance;
+class CGMine;
+
+struct DLL_LINKAGE StatisticDataSetEntry
+{
+	std::string map;
+	time_t timestamp;
+    int day;
+    PlayerColor player;
+    std::string playerName;
+	TeamID team;
+	bool isHuman;
+	EPlayerStatus status;
+	TResources resources;
+	int numberHeroes;
+	int numberTowns;
+	int numberArtifacts;
+	int numberDwellings;
+	si64 armyStrength;
+	si64 totalExperience;
+	int income;
+	float mapExploredRatio;
+	float obeliskVisitedRatio;
+	float townBuiltRatio;
+	bool hasGrail;
+	std::map<EGameResID, int> numMines;
+	int score;
+	int maxHeroLevel;
+	int numBattlesNeutral;
+	int numBattlesPlayer;
+	int numWinBattlesNeutral;
+	int numWinBattlesPlayer;
+	int numHeroSurrendered;
+	int numHeroEscaped;
+	TResources spentResourcesForArmy;
+	TResources spentResourcesForBuildings;
+	TResources tradeVolume;
+	bool eventCapturedTown;
+	bool eventDefeatedStrongestHero;
+	si64 movementPointsUsed;
+
+	template <typename Handler> void serialize(Handler &h)
+	{
+		h & map;
+		h & timestamp;
+		h & day;
+		h & player;
+		if(h.version >= Handler::Version::STATISTICS_SCREEN)
+			h & playerName;
+		h & team;
+		h & isHuman;
+		h & status;
+		h & resources;
+		h & numberHeroes;
+		h & numberTowns;
+		h & numberArtifacts;
+		h & numberDwellings;
+		h & armyStrength;
+		h & totalExperience;
+		h & income;
+		h & mapExploredRatio;
+		h & obeliskVisitedRatio;
+		h & townBuiltRatio;
+		h & hasGrail;
+		h & numMines;
+		h & score;
+		h & maxHeroLevel;
+		h & numBattlesNeutral;
+		h & numBattlesPlayer;
+		h & numWinBattlesNeutral;
+		h & numWinBattlesPlayer;
+		h & numHeroSurrendered;
+		h & numHeroEscaped;
+		h & spentResourcesForArmy;
+		h & spentResourcesForBuildings;
+		h & tradeVolume;
+		if(h.version >= Handler::Version::STATISTICS_SCREEN)
+		{
+			h & eventCapturedTown;
+			h & eventDefeatedStrongestHero;
+		}
+		h & movementPointsUsed;
+	}
+};
+
+class DLL_LINKAGE StatisticDataSet
+{
+public:
+    void add(StatisticDataSetEntry entry);
+	static StatisticDataSetEntry createEntry(const PlayerState * ps, const CGameState * gs);
+    std::string toCsv(std::string sep);
+    std::string writeCsv();
+
+	struct PlayerAccumulatedValueStorage // holds some actual values needed for stats
+	{
+		int numBattlesNeutral;
+		int numBattlesPlayer;
+		int numWinBattlesNeutral;
+		int numWinBattlesPlayer;
+		int numHeroSurrendered;
+		int numHeroEscaped;
+		TResources spentResourcesForArmy;
+		TResources spentResourcesForBuildings;
+		TResources tradeVolume;
+		si64 movementPointsUsed;
+		int lastCapturedTownDay;
+		int lastDefeatedStrongestHeroDay;
+
+		template <typename Handler> void serialize(Handler &h)
+		{
+			h & numBattlesNeutral;
+			h & numBattlesPlayer;
+			h & numWinBattlesNeutral;
+			h & numWinBattlesPlayer;
+			h & numHeroSurrendered;
+			h & numHeroEscaped;
+			h & spentResourcesForArmy;
+			h & spentResourcesForBuildings;
+			h & tradeVolume;
+			h & movementPointsUsed;
+			if(h.version >= Handler::Version::STATISTICS_SCREEN)
+			{
+				h & lastCapturedTownDay;
+				h & lastDefeatedStrongestHeroDay;
+			}
+		}
+	};
+	std::vector<StatisticDataSetEntry> data;
+	std::map<PlayerColor, PlayerAccumulatedValueStorage> accumulatedValues;
+
+	template <typename Handler> void serialize(Handler &h)
+	{
+		h & data;
+		h & accumulatedValues;
+	}
+};
+
+class DLL_LINKAGE Statistic
+{
+	static std::vector<const CGMine *> getMines(const CGameState * gs, const PlayerState * ps);
+public:
+	static int getNumberOfArts(const PlayerState * ps);
+	static int getNumberOfDwellings(const PlayerState * ps);
+	static si64 getArmyStrength(const PlayerState * ps, bool withTownGarrison = false);
+	static si64 getTotalExperience(const PlayerState * ps);
+	static int getIncome(const CGameState * gs, const PlayerState * ps);
+	static float getMapExploredRatio(const CGameState * gs, PlayerColor player);
+	static const CGHeroInstance * findBestHero(const CGameState * gs, const PlayerColor & color);
+	static std::vector<std::vector<PlayerColor>> getRank(std::vector<std::pair<PlayerColor, si64>> stats);
+	static int getObeliskVisited(const CGameState * gs, const TeamID & t);
+	static float getObeliskVisitedRatio(const CGameState * gs, const TeamID & t);
+	static std::map<EGameResID, int> getNumMines(const CGameState * gs, const PlayerState * ps);
+	static float getTownBuiltRatio(const PlayerState * ps);
+};
+
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/gameState/HighScore.cpp vcmi/lib/gameState/HighScore.cpp
--- vcmi-1.5.7/lib/gameState/HighScore.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/gameState/HighScore.cpp	2024-12-19 15:00:22.904148185 +0100
@@ -0,0 +1,111 @@
+/*
+ * HighScore.cpp, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#include "StdInc.h"
+#include "HighScore.h"
+#include "../CPlayerState.h"
+#include "../constants/StringConstants.h"
+#include "CGameState.h"
+#include "StartInfo.h"
+#include "../mapping/CMapHeader.h"
+#include "../mapObjects/CGHeroInstance.h"
+#include "../mapObjects/CGTownInstance.h"
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+HighScoreParameter HighScore::prepareHighScores(const CGameState * gs, PlayerColor player, bool victory)
+{
+	const auto * playerState = gs->getPlayerState(player);
+
+	HighScoreParameter param;
+	param.difficulty = gs->getStartInfo()->difficulty;
+	param.day = gs->getDate();
+	param.townAmount = gs->howManyTowns(player);
+	param.usedCheat = gs->getPlayerState(player)->cheated;
+	param.hasGrail = false;
+	for(const CGHeroInstance * h : playerState->getHeroes())
+		if(h->hasArt(ArtifactID::GRAIL))
+			param.hasGrail = true;
+	for(const CGTownInstance * t : playerState->getTowns())
+		if(t->hasBuilt(BuildingID::GRAIL))
+			param.hasGrail = true;
+	param.allEnemiesDefeated = true;
+	for (PlayerColor otherPlayer(0); otherPlayer < PlayerColor::PLAYER_LIMIT; ++otherPlayer)
+	{
+		auto ps = gs->getPlayerState(otherPlayer, false);
+		if(ps && otherPlayer != player && !ps->checkVanquished())
+			param.allEnemiesDefeated = false;
+	}
+	param.scenarioName = gs->getMapHeader()->name.toString();
+	param.playerName = gs->getStartInfo()->playerInfos.find(player)->second.name;
+
+	return param;
+}
+
+HighScoreCalculation::Result HighScoreCalculation::calculate()
+{
+	Result firstResult;
+	Result summary;
+	const std::array<double, 5> difficultyMultipliers{0.8, 1.0, 1.3, 1.6, 2.0};
+	for(const auto & param : parameters)
+	{
+		double tmp = 200 - (param.day + 10) / (param.townAmount + 5) + (param.allEnemiesDefeated ? 25 : 0) + (param.hasGrail ? 25 : 0);
+		firstResult = Result{static_cast<int>(tmp), static_cast<int>(tmp * difficultyMultipliers.at(param.difficulty)), param.day, param.usedCheat};
+		summary.basic += firstResult.basic * 5.0 / parameters.size();
+		summary.total += firstResult.total * 5.0 / parameters.size();
+		summary.sumDays += firstResult.sumDays;
+		summary.cheater |= firstResult.cheater;
+	}
+
+	if(parameters.size() == 1)
+		return firstResult;
+
+	return summary;
+}
+
+struct HighScoreCreature
+{
+	CreatureID creature;
+	int min;
+	int max;
+};
+
+static std::vector<HighScoreCreature> getHighscoreCreaturesList()
+{
+	JsonNode configCreatures(JsonPath::builtin("CONFIG/highscoreCreatures.json"));
+
+	std::vector<HighScoreCreature> ret;
+
+	for(auto & json : configCreatures["creatures"].Vector())
+	{
+		HighScoreCreature entry;
+		entry.creature = CreatureID::decode(json["creature"].String());
+		entry.max = json["max"].isNull() ? std::numeric_limits<int>::max() : json["max"].Integer();
+		entry.min = json["min"].isNull() ? std::numeric_limits<int>::min() : json["min"].Integer();
+
+		ret.push_back(entry);
+	}
+
+	return ret;
+}
+
+CreatureID HighScoreCalculation::getCreatureForPoints(int points, bool campaign)
+{
+	static const std::vector<HighScoreCreature> creatures = getHighscoreCreaturesList();
+
+	int divide = campaign ? 5 : 1;
+
+	for(auto & creature : creatures)
+		if(points / divide <= creature.max && points / divide >= creature.min)
+			return creature.creature;
+
+	throw std::runtime_error("Unable to find creature for score " + std::to_string(points));
+}
+
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/gameState/HighScore.h vcmi/lib/gameState/HighScore.h
--- vcmi-1.5.7/lib/gameState/HighScore.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/gameState/HighScore.h	2024-12-19 15:00:22.904148185 +0100
@@ -0,0 +1,68 @@
+/*
+ * HighScore.h, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#pragma once
+
+#include "../GameConstants.h"
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+class CGameState;
+
+class DLL_LINKAGE HighScoreParameter
+{
+public:
+	int difficulty;
+	int day;
+	int townAmount;
+	bool usedCheat;
+	bool hasGrail;
+	bool allEnemiesDefeated;
+	std::string campaignName;
+	std::string scenarioName;
+	std::string playerName;
+
+	template <typename Handler> void serialize(Handler &h)
+	{
+		h & difficulty;
+		h & day;
+		h & townAmount;
+		h & usedCheat;
+		h & hasGrail;
+		h & allEnemiesDefeated;
+		h & campaignName;
+		h & scenarioName;
+		h & playerName;
+	}
+};
+class DLL_LINKAGE HighScore
+{
+public:
+	static HighScoreParameter prepareHighScores(const CGameState * gs, PlayerColor player, bool victory);
+};
+
+class DLL_LINKAGE HighScoreCalculation
+{
+public:
+	struct Result
+	{
+		int basic = 0;
+		int total = 0;
+		int sumDays = 0;
+		bool cheater = false;
+	};
+
+	std::vector<HighScoreParameter> parameters;
+	bool isCampaign = false;
+
+	Result calculate();
+	static CreatureID getCreatureForPoints(int points, bool campaign);
+};
+
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/gameState/InfoAboutArmy.cpp vcmi/lib/gameState/InfoAboutArmy.cpp
--- vcmi-1.5.7/lib/gameState/InfoAboutArmy.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/gameState/InfoAboutArmy.cpp	2024-12-19 15:00:22.904148185 +0100
@@ -12,7 +12,9 @@
 
 #include "../mapObjects/CGHeroInstance.h"
 #include "../mapObjects/CGTownInstance.h"
-#include "../CHeroHandler.h"
+
+#include <vcmi/HeroTypeService.h>
+#include <vcmi/HeroType.h>
 
 VCMI_LIB_NAMESPACE_BEGIN
 
@@ -24,7 +26,7 @@
 		if(detailed)
 			(*this)[elem.first] = *elem.second;
 		else
-			(*this)[elem.first] = CStackBasicDescriptor(elem.second->type, (int)elem.second->getQuantityID());
+			(*this)[elem.first] = CStackBasicDescriptor(elem.second->getCreature(), (int)elem.second->getQuantityID());
 	}
 }
 
@@ -40,12 +42,12 @@
 	if(isDetailed)
 	{
 		for(const auto & elem : *this)
-			ret += elem.second.type->getAIValue() * elem.second.count;
+			ret += elem.second.getType()->getAIValue() * elem.second.count;
 	}
 	else
 	{
 		for(const auto & elem : *this)
-			ret += elem.second.type->getAIValue() * CCreature::estimateCreatureCount(elem.second.count);
+			ret += elem.second.getType()->getAIValue() * CCreature::estimateCreatureCount(elem.second.count);
 	}
 	return static_cast<int>(ret);
 }
@@ -115,7 +117,7 @@
 
 	initFromArmy(h, detailed);
 
-	hclass = h->type->heroClass;
+	hclass = h->getHeroClass();
 	name = h->getNameTranslated();
 	portraitSource = h->getPortraitSource();
 
@@ -166,7 +168,7 @@
 {
 	initFromArmy(t, detailed);
 	army = ArmyDescriptor(t->getUpperArmy(), detailed);
-	built = t->builded;
+	built = t->built;
 	fortLevel = t->fortLevel();
 	name = t->getNameTranslated();
 	tType = t->getTown();
diff --color -urN vcmi-1.5.7/lib/gameState/RumorState.cpp vcmi/lib/gameState/RumorState.cpp
--- vcmi-1.5.7/lib/gameState/RumorState.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/gameState/RumorState.cpp	2024-12-19 15:00:22.904148185 +0100
@@ -0,0 +1,33 @@
+/*
+ * RumorState.cpp, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#include "StdInc.h"
+#include "RumorState.h"
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+bool RumorState::update(int id, int extra)
+{
+	if(vstd::contains(last, type))
+	{
+		if(last[type].first != id)
+		{
+			last[type].first = id;
+			last[type].second = extra;
+		}
+		else
+			return false;
+	}
+	else
+		last[type] = std::make_pair(id, extra);
+
+	return true;
+}
+
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/gameState/RumorState.h vcmi/lib/gameState/RumorState.h
--- vcmi-1.5.7/lib/gameState/RumorState.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/gameState/RumorState.h	2024-12-19 15:00:22.905148227 +0100
@@ -0,0 +1,43 @@
+/*
+ * RumorState.h, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#pragma once
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+struct DLL_LINKAGE RumorState
+{
+	enum ERumorType : ui8
+	{
+		TYPE_NONE = 0, TYPE_RAND, TYPE_SPECIAL, TYPE_MAP
+	};
+
+	enum ERumorTypeSpecial : ui8
+	{
+		RUMOR_OBELISKS = 208,
+		RUMOR_ARTIFACTS = 209,
+		RUMOR_ARMY = 210,
+		RUMOR_INCOME = 211,
+		RUMOR_GRAIL = 212
+	};
+
+	ERumorType type;
+	std::map<ERumorType, std::pair<int, int>> last;
+
+	RumorState(){type = TYPE_NONE;};
+	bool update(int id, int extra);
+
+	template <typename Handler> void serialize(Handler &h)
+	{
+		h & type;
+		h & last;
+	}
+};
+
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/gameState/SThievesGuildInfo.h vcmi/lib/gameState/SThievesGuildInfo.h
--- vcmi-1.5.7/lib/gameState/SThievesGuildInfo.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/gameState/SThievesGuildInfo.h	2024-12-19 15:00:22.905148227 +0100
@@ -20,7 +20,7 @@
 
 	std::vector< std::vector< PlayerColor > > numOfTowns, numOfHeroes, gold, woodOre, mercSulfCrystGems, obelisks, artifacts, army, income; // [place] -> [colours of players]
 
-	std::map<PlayerColor, InfoAboutHero> colorToBestHero; //maps player's color to his best heros'
+	std::map<PlayerColor, InfoAboutHero> colorToBestHero; //maps player's color to his best hero's
 
 	std::map<PlayerColor, EAiTactic> personality; // color to personality // ai tactic
 	std::map<PlayerColor, CreatureID> bestCreature; // color to ID // id or -1 if not known
diff --color -urN vcmi-1.5.7/lib/gameState/TavernHeroesPool.cpp vcmi/lib/gameState/TavernHeroesPool.cpp
--- vcmi-1.5.7/lib/gameState/TavernHeroesPool.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/gameState/TavernHeroesPool.cpp	2024-12-19 15:00:22.905148227 +0100
@@ -11,7 +11,6 @@
 #include "TavernHeroesPool.h"
 
 #include "../mapObjects/CGHeroInstance.h"
-#include "../CHeroHandler.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
@@ -25,7 +24,7 @@
 {
 	std::map<HeroTypeID, CGHeroInstance*> pool = heroesPool;
 	for(const auto & slot : currentTavern)
-		pool.erase(slot.hero->getHeroType());
+		pool.erase(slot.hero->getHeroTypeID());
 
 	return pool;
 }
@@ -34,7 +33,7 @@
 {
 	for (auto const & slot : currentTavern)
 	{
-		if (slot.hero->getHeroType() == hero)
+		if (slot.hero->getHeroTypeID() == hero)
 			return slot.role;
 	}
 	return TavernSlotRole::NONE;
@@ -106,7 +105,7 @@
 	heroesPool.erase(hero);
 
 	vstd::erase_if(currentTavern, [&](const TavernSlot & entry){
-		return entry.hero->type->getId() == hero;
+		return entry.hero->getHeroTypeID() == hero;
 	});
 
 	assert(result);
@@ -138,7 +137,7 @@
 
 void TavernHeroesPool::addHeroToPool(CGHeroInstance * hero)
 {
-	heroesPool[hero->getHeroType()] = hero;
+	heroesPool[hero->getHeroTypeID()] = hero;
 }
 
 void TavernHeroesPool::setAvailability(HeroTypeID hero, std::set<PlayerColor> mask)
diff --color -urN vcmi-1.5.7/lib/gameState/TavernHeroesPool.h vcmi/lib/gameState/TavernHeroesPool.h
--- vcmi-1.5.7/lib/gameState/TavernHeroesPool.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/gameState/TavernHeroesPool.h	2024-12-19 15:00:22.905148227 +0100
@@ -11,17 +11,18 @@
 
 #include "../GameConstants.h"
 #include "TavernSlot.h"
+#include "../serializer/Serializeable.h"
+
 
 VCMI_LIB_NAMESPACE_BEGIN
 
 class CGHeroInstance;
 class CTown;
-class CRandomGenerator;
 class CHeroClass;
 class CGameState;
 class CSimpleArmy;
 
-class DLL_LINKAGE TavernHeroesPool
+class DLL_LINKAGE TavernHeroesPool : public Serializeable
 {
 	struct TavernSlot
 	{
@@ -52,7 +53,7 @@
 public:
 	~TavernHeroesPool();
 
-	/// Returns heroes currently availabe in tavern of a specific player
+	/// Returns heroes currently available in tavern of a specific player
 	std::vector<const CGHeroInstance *> getHeroesFor(PlayerColor color) const;
 
 	/// returns heroes in pool without heroes that are available in taverns
diff --color -urN vcmi-1.5.7/lib/IGameCallback.cpp vcmi/lib/IGameCallback.cpp
--- vcmi-1.5.7/lib/IGameCallback.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/IGameCallback.cpp	2024-12-19 15:00:22.856146202 +0100
@@ -10,7 +10,6 @@
 #include "StdInc.h"
 #include "IGameCallback.h"
 
-#include "CHeroHandler.h" // for CHeroHandler
 #include "spells/CSpellHandler.h"// for CSpell
 #include "CSkillHandler.h"// for CSkill
 #include "CBonusTypeHandler.h"
@@ -19,7 +18,8 @@
 #include "bonuses/Limiters.h"
 #include "bonuses/Propagators.h"
 #include "bonuses/Updaters.h"
-
+#include "entities/building/CBuilding.h"
+#include "entities/hero/CHero.h"
 #include "networkPacks/ArtifactLocation.h"
 #include "serializer/CLoadFile.h"
 #include "serializer/CSaveFile.h"
@@ -27,6 +27,7 @@
 #include "mapObjectConstructors/AObjectTypeHandler.h"
 #include "mapObjectConstructors/CObjectClassesHandler.h"
 #include "mapObjects/CGMarket.h"
+#include "mapObjects/TownBuildingInstance.h"
 #include "mapObjects/CGTownInstance.h"
 #include "mapObjects/CObjectHandler.h"
 #include "mapObjects/CQuest.h"
@@ -40,7 +41,6 @@
 #include "gameState/QuestInfo.h"
 #include "mapping/CMap.h"
 #include "modding/CModHandler.h"
-#include "modding/CModInfo.h"
 #include "modding/IdentifierStorage.h"
 #include "modding/CModVersion.h"
 #include "modding/ActiveModsInSaveList.h"
@@ -51,6 +51,8 @@
 #include "RiverHandler.h"
 #include "TerrainHandler.h"
 
+#include <vstd/RNG.h>
+
 VCMI_LIB_NAMESPACE_BEGIN
 
 void CPrivilegedInfoCallback::getFreeTiles(std::vector<int3> & tiles) const
@@ -69,7 +71,7 @@
 			for (int yd = 0; yd < gs->map->height; yd++)
 			{
 				tinfo = getTile(int3 (xd,yd,zd));
-				if (tinfo->terType->isLand() && tinfo->terType->isPassable() && !tinfo->blocked) //land and free
+				if (tinfo->isLand() && tinfo->getTerrain()->isPassable() && !tinfo->blocked()) //land and free
 					tiles.emplace_back(xd, yd, zd);
 			}
 		}
@@ -103,8 +105,8 @@
 				if(distance <= radious)
 				{
 					if(!player
-						|| (mode == ETileVisibility::HIDDEN  && (*team->fogOfWarMap)[pos.z][xd][yd] == 0)
-						|| (mode == ETileVisibility::REVEALED && (*team->fogOfWarMap)[pos.z][xd][yd] == 1)
+						|| (mode == ETileVisibility::HIDDEN  && team->fogOfWarMap[pos.z][xd][yd] == 0)
+						|| (mode == ETileVisibility::REVEALED && team->fogOfWarMap[pos.z][xd][yd] == 1)
 					)
 						tiles.insert(int3(xd,yd,pos.z));
 				}
@@ -146,14 +148,14 @@
 	}
 }
 
-void CPrivilegedInfoCallback::pickAllowedArtsSet(std::vector<const CArtifact *> & out, CRandomGenerator & rand)
+void CPrivilegedInfoCallback::pickAllowedArtsSet(std::vector<ArtifactID> & out, vstd::RNG & rand)
 {
 	for (int j = 0; j < 3 ; j++)
-		out.push_back(gameState()->pickRandomArtifact(rand, CArtifact::ART_TREASURE).toArtifact());
+		out.push_back(gameState()->pickRandomArtifact(rand, CArtifact::ART_TREASURE));
 	for (int j = 0; j < 3 ; j++)
-		out.push_back(gameState()->pickRandomArtifact(rand, CArtifact::ART_MINOR).toArtifact());
+		out.push_back(gameState()->pickRandomArtifact(rand, CArtifact::ART_MINOR));
 
-	out.push_back(gameState()->pickRandomArtifact(rand, CArtifact::ART_MAJOR).toArtifact());
+	out.push_back(gameState()->pickRandomArtifact(rand, CArtifact::ART_MAJOR));
 }
 
 void CPrivilegedInfoCallback::getAllowedSpells(std::vector<SpellID> & out, std::optional<ui16> level)
@@ -177,8 +179,7 @@
 	return gs;
 }
 
-template<typename Loader>
-void CPrivilegedInfoCallback::loadCommonState(Loader & in)
+void CPrivilegedInfoCallback::loadCommonState(CLoadFile & in)
 {
 	logGlobal->info("Loading lib part of game...");
 	in.checkMagicBytes(SAVEGAME_MAGIC);
@@ -200,8 +201,7 @@
 	in.serializer & gs;
 }
 
-template<typename Saver>
-void CPrivilegedInfoCallback::saveCommonState(Saver & out) const
+void CPrivilegedInfoCallback::saveCommonState(CSaveFile & out) const
 {
 	ActiveModsInSaveList activeMods;
 
@@ -217,10 +217,6 @@
 	out.serializer & gs;
 }
 
-// hardly memory usage for `-gdwarf-4` flag
-template DLL_LINKAGE void CPrivilegedInfoCallback::loadCommonState<CLoadFile>(CLoadFile &);
-template DLL_LINKAGE void CPrivilegedInfoCallback::saveCommonState<CSaveFile>(CSaveFile &) const;
-
 TerrainTile * CNonConstInfoCallback::getTile(const int3 & pos)
 {
 	if(!gs->map->isInTheMap(pos))
@@ -284,14 +280,16 @@
 			return hero;
 		}
 	}
-	else if(auto market = dynamic_cast<CGArtifactsAltar*>(getObjInstance(loc.artHolder)))
+	else if(auto market = getMarket(loc.artHolder))
 	{
-		return market;
+		if(auto artSet = market->getArtifactsStorage())
+			return artSet;
 	}
-	else
+	else if(auto army = getArmyInstance(loc.artHolder))
 	{
-		return nullptr;
+		return army->getStackPtr(loc.creature.value());
 	}
+	return nullptr;
 }
 
 bool IGameCallback::isVisitCoveredByAnotherQuery(const CGObjectInstance *obj, const CGHeroInstance *hero)
diff --color -urN vcmi-1.5.7/lib/IGameCallback.h vcmi/lib/IGameCallback.h
--- vcmi-1.5.7/lib/IGameCallback.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/IGameCallback.h	2024-12-19 15:00:22.860146367 +0100
@@ -16,16 +16,25 @@
 
 VCMI_LIB_NAMESPACE_BEGIN
 
+namespace vstd
+{
+class RNG;
+}
+
 struct SetMovePoints;
 struct GiveBonus;
 struct BlockingDialog;
 struct TeleportDialog;
 struct StackLocation;
 struct ArtifactLocation;
-class CRandomGenerator;
+struct BankConfig;
+struct BattleLayout;
 class CCreatureSet;
 class CStackBasicDescriptor;
 class CGCreature;
+class CSaveFile;
+class CLoadFile;
+class IObjectInterface;
 enum class EOpenWindowMode : uint8_t;
 
 namespace spells
@@ -33,6 +42,11 @@
 	class Caster;
 }
 
+namespace Rewardable
+{
+	struct Configuration;
+}
+
 #if SCRIPTING_ENABLED
 namespace scripting
 {
@@ -61,32 +75,33 @@
 	void getAllTiles(std::unordered_set<int3> &tiles, std::optional<PlayerColor> player, int level, std::function<bool(const TerrainTile *)> filter) const;
 
 	//gives 3 treasures, 3 minors, 1 major -> used by Black Market and Artifact Merchant
-	void pickAllowedArtsSet(std::vector<const CArtifact *> & out, CRandomGenerator & rand);
+	void pickAllowedArtsSet(std::vector<ArtifactID> & out, vstd::RNG & rand);
 	void getAllowedSpells(std::vector<SpellID> &out, std::optional<ui16> level = std::nullopt);
 
-	template<typename Saver>
-	void saveCommonState(Saver &out) const; //stores GS and VLC
-
-	template<typename Loader>
-	void loadCommonState(Loader &in); //loads GS and VLC
+	void saveCommonState(CSaveFile &out) const; //stores GS and VLC
+	void loadCommonState(CLoadFile &in); //loads GS and VLC
 };
 
 class DLL_LINKAGE IGameEventCallback
 {
 public:
 	virtual void setObjPropertyValue(ObjectInstanceID objid, ObjProperty prop, int32_t value = 0) = 0;
+	virtual void setBankObjectConfiguration(ObjectInstanceID objid, const BankConfig & configuration) = 0;
+	virtual void setRewardableObjectConfiguration(ObjectInstanceID mapObjectID, const Rewardable::Configuration & configuration) = 0;
+	virtual void setRewardableObjectConfiguration(ObjectInstanceID townInstanceID, BuildingID buildingID, const Rewardable::Configuration & configuration) = 0;
 	virtual void setObjPropertyID(ObjectInstanceID objid, ObjProperty prop, ObjPropertyID identifier) = 0;
 
 	virtual void showInfoDialog(InfoWindow * iw) = 0;
 
 	virtual void changeSpells(const CGHeroInstance * hero, bool give, const std::set<SpellID> &spells)=0;
+	virtual void setResearchedSpells(const CGTownInstance * town, int level, const std::vector<SpellID> & spells, bool accepted)=0;
 	virtual bool removeObject(const CGObjectInstance * obj, const PlayerColor & initiator) = 0;
-	virtual void createObject(const int3 & visitablePosition, const PlayerColor & initiator, MapObjectID type, MapObjectSubID subtype) = 0;
+	virtual void createBoat(const int3 & visitablePosition, BoatId type, PlayerColor initiator) = 0;
 	virtual void setOwner(const CGObjectInstance * objid, PlayerColor owner)=0;
 	virtual void giveExperience(const CGHeroInstance * hero, TExpType val) =0;
 	virtual void changePrimSkill(const CGHeroInstance * hero, PrimarySkill which, si64 val, bool abs=false)=0;
 	virtual void changeSecSkill(const CGHeroInstance * hero, SecondarySkill which, int val, bool abs=false)=0;
-	virtual void showBlockingDialog(BlockingDialog *iw) =0;
+	virtual void showBlockingDialog(const IObjectInterface * caller, BlockingDialog *iw) =0;
 	virtual void showGarrisonDialog(ObjectInstanceID upobj, ObjectInstanceID hid, bool removableUnits) =0; //cb will be called when player closes garrison window
 	virtual void showTeleportDialog(TeleportDialog *iw) =0;
 	virtual void showObjectWindow(const CGObjectInstance * object, EOpenWindowMode window, const CGHeroInstance * visitor, bool addQuery) = 0;
@@ -106,17 +121,17 @@
 
 	virtual void removeAfterVisit(const CGObjectInstance *object) = 0; //object will be destroyed when interaction is over. Do not call when interaction is not ongoing!
 
-	virtual bool giveHeroNewArtifact(const CGHeroInstance * h, const CArtifact * artType, ArtifactPosition pos) = 0;
-	virtual bool putArtifact(const ArtifactLocation & al, const CArtifactInstance * art, std::optional<bool> askAssemble = std::nullopt) = 0;
-	virtual void removeArtifact(const ArtifactLocation &al) = 0;
+	virtual bool giveHeroNewArtifact(const CGHeroInstance * h, const ArtifactID & artId, const ArtifactPosition & pos) = 0;
+	virtual bool giveHeroNewScroll(const CGHeroInstance * h, const SpellID & spellId, const ArtifactPosition & pos) = 0;
+	virtual bool putArtifact(const ArtifactLocation & al, const ArtifactInstanceID & id, std::optional<bool> askAssemble = std::nullopt) = 0;
+	virtual void removeArtifact(const ArtifactLocation& al) = 0;
 	virtual bool moveArtifact(const PlayerColor & player, const ArtifactLocation & al1, const ArtifactLocation & al2) = 0;
 
 	virtual void heroVisitCastle(const CGTownInstance * obj, const CGHeroInstance * hero)=0;
 	virtual void visitCastleObjects(const CGTownInstance * obj, const CGHeroInstance * hero)=0;
 	virtual void stopHeroVisitCastle(const CGTownInstance * obj, const CGHeroInstance * hero)=0;
-	virtual void startBattlePrimary(const CArmedInstance *army1, const CArmedInstance *army2, int3 tile, const CGHeroInstance *hero1, const CGHeroInstance *hero2, bool creatureBank = false, const CGTownInstance *town = nullptr)=0; //use hero=nullptr for no hero
-	virtual void startBattleI(const CArmedInstance *army1, const CArmedInstance *army2, int3 tile, bool creatureBank = false)=0; //if any of armies is hero, hero will be used
-	virtual void startBattleI(const CArmedInstance *army1, const CArmedInstance *army2, bool creatureBank = false)=0; //if any of armies is hero, hero will be used, visitable tile of second obj is place of battle
+	virtual void startBattle(const CArmedInstance *army1, const CArmedInstance *army2, int3 tile, const CGHeroInstance *hero1, const CGHeroInstance *hero2, const BattleLayout & layout, const CGTownInstance *town)=0; //use hero=nullptr for no hero
+	virtual void startBattle(const CArmedInstance *army1, const CArmedInstance *army2)=0; //if any of armies is hero, hero will be used, visitable tile of second obj is place of battle
 	virtual bool moveHero(ObjectInstanceID hid, int3 dst, EMovementMode moveMove, bool transit = false, PlayerColor asker = PlayerColor::NEUTRAL)=0;
 	virtual bool swapGarrisonOnSiege(ObjectInstanceID tid)=0;
 	virtual void giveHeroBonus(GiveBonus * bonus)=0;
@@ -125,12 +140,15 @@
 	virtual void setManaPoints(ObjectInstanceID hid, int val)=0;
 	virtual void giveHero(ObjectInstanceID id, PlayerColor player, ObjectInstanceID boatId = ObjectInstanceID()) = 0;
 	virtual void changeObjPos(ObjectInstanceID objid, int3 newPos, const PlayerColor & initiator)=0;
-	virtual void sendAndApply(CPackForClient * pack) = 0;
+	virtual void sendAndApply(CPackForClient & pack) = 0;
 	virtual void heroExchange(ObjectInstanceID hero1, ObjectInstanceID hero2)=0; //when two heroes meet on adventure map
 	virtual void changeFogOfWar(int3 center, ui32 radius, PlayerColor player, ETileVisibility mode) = 0;
-	virtual void changeFogOfWar(std::unordered_set<int3> &tiles, PlayerColor player, ETileVisibility mode) = 0;
+	virtual void changeFogOfWar(const std::unordered_set<int3> &tiles, PlayerColor player, ETileVisibility mode) = 0;
 	
 	virtual void castSpell(const spells::Caster * caster, SpellID spellID, const int3 &pos) = 0;
+
+	virtual vstd::RNG & getRandomGenerator() = 0;
+
 };
 
 class DLL_LINKAGE CNonConstInfoCallback : public CPrivilegedInfoCallback
diff --color -urN vcmi-1.5.7/lib/IGameEventsReceiver.h vcmi/lib/IGameEventsReceiver.h
--- vcmi-1.5.7/lib/IGameEventsReceiver.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/IGameEventsReceiver.h	2024-12-19 15:00:22.861146408 +0100
@@ -68,7 +68,7 @@
 	virtual void battleStacksEffectsSet(const BattleID & battleID, const SetStackEffect & sse){};//called when a specific effect is set to stacks
 	virtual void battleTriggerEffect(const BattleID & battleID, const BattleTriggerEffect & bte){}; //called for various one-shot effects
 	virtual void battleStartBefore(const BattleID & battleID, const CCreatureSet *army1, const CCreatureSet *army2, int3 tile, const CGHeroInstance *hero1, const CGHeroInstance *hero2) {}; //called just before battle start
-	virtual void battleStart(const BattleID & battleID, const CCreatureSet *army1, const CCreatureSet *army2, int3 tile, const CGHeroInstance *hero1, const CGHeroInstance *hero2, bool side, bool replayAllowed){}; //called by engine when battle starts; side=0 - left, side=1 - right
+	virtual void battleStart(const BattleID & battleID, const CCreatureSet *army1, const CCreatureSet *army2, int3 tile, const CGHeroInstance *hero1, const CGHeroInstance *hero2, BattleSide side, bool replayAllowed){}; //called by engine when battle starts; side=0 - left, side=1 - right
 	virtual void battleUnitsChanged(const BattleID & battleID, const std::vector<UnitChanges> & units){};
 	virtual void battleObstaclesChanged(const BattleID & battleID, const std::vector<ObstacleChanges> & obstacles){};
 	virtual void battleCatapultAttacked(const BattleID & battleID, const CatapultAttack & ca){}; //called when catapult makes an attack
@@ -90,7 +90,7 @@
 	virtual void artifactAssembled(const ArtifactLocation &al){};
 	virtual void artifactDisassembled(const ArtifactLocation &al){};
 	virtual void artifactMoved(const ArtifactLocation &src, const ArtifactLocation &dst){};
-	virtual void bulkArtMovementStart(size_t numOfArts) {};
+	virtual void bulkArtMovementStart(size_t totalNumOfArts, size_t possibleAssemblyNumOfArts) {};
 	virtual void askToAssembleArtifact(const ArtifactLocation & dst) {};
 
 	virtual void heroVisit(const CGHeroInstance *visitor, const CGObjectInstance *visitedObj, bool start){};
@@ -105,11 +105,11 @@
 	virtual void receivedResource(){};
 	virtual void showInfoDialog(EInfoWindowMode type, const std::string & text, const std::vector<Component> & components, int soundID){};
 	virtual void showRecruitmentDialog(const CGDwelling *dwelling, const CArmedInstance *dst, int level, QueryID queryID){}
-	virtual void showShipyardDialog(const IShipyard *obj){} //obj may be town or shipyard; state: 0 - can buid, 1 - lack of resources, 2 - dest tile is blocked, 3 - no water
+	virtual void showShipyardDialog(const IShipyard *obj){} //obj may be town or shipyard; state: 0 - can build, 1 - lack of resources, 2 - dest tile is blocked, 3 - no water
 
 	virtual void showPuzzleMap(){};
 	virtual void viewWorldMap(){};
-	virtual void showMarketWindow(const IMarket *market, const CGHeroInstance *visitor, QueryID queryID){};
+	virtual void showMarketWindow(const IMarket * market, const CGHeroInstance * visitor, QueryID queryID){};
 	virtual void showUniversityWindow(const IMarket *market, const CGHeroInstance *visitor, QueryID queryID){};
 	virtual void showHillFortWindow(const CGObjectInstance *object, const CGHeroInstance *visitor){};
 	virtual void showThievesGuildWindow (const CGObjectInstance * obj){};
diff --color -urN vcmi-1.5.7/lib/IGameSettings.h vcmi/lib/IGameSettings.h
--- vcmi-1.5.7/lib/IGameSettings.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/IGameSettings.h	2024-12-19 15:00:22.862146450 +0100
@@ -0,0 +1,106 @@
+/*
+ * IIGameSettings.h, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#pragma once
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+class JsonNode;
+
+enum class EGameSettings
+{
+	BANKS_SHOW_GUARDS_COMPOSITION,
+	BONUSES_GLOBAL,
+	BONUSES_PER_HERO,
+	COMBAT_AREA_SHOT_CAN_TARGET_EMPTY_HEX,
+	COMBAT_ATTACK_POINT_DAMAGE_FACTOR,
+	COMBAT_ATTACK_POINT_DAMAGE_FACTOR_CAP,
+	COMBAT_BAD_LUCK_DICE,
+	COMBAT_BAD_MORALE_DICE,
+	COMBAT_DEFENSE_POINT_DAMAGE_FACTOR,
+	COMBAT_DEFENSE_POINT_DAMAGE_FACTOR_CAP,
+	COMBAT_GOOD_LUCK_DICE,
+	COMBAT_GOOD_MORALE_DICE,
+	COMBAT_LAYOUTS,
+	COMBAT_ONE_HEX_TRIGGERS_OBSTACLES,
+	CREATURES_ALLOW_ALL_FOR_DOUBLE_MONTH,
+	CREATURES_ALLOW_RANDOM_SPECIAL_WEEKS,
+	CREATURES_DAILY_STACK_EXPERIENCE,
+	CREATURES_WEEKLY_GROWTH_CAP,
+	CREATURES_WEEKLY_GROWTH_PERCENT,
+	DIMENSION_DOOR_EXPOSES_TERRAIN_TYPE,
+	DIMENSION_DOOR_FAILURE_SPENDS_POINTS,
+	DIMENSION_DOOR_ONLY_TO_UNCOVERED_TILES,
+	DIMENSION_DOOR_TOURNAMENT_RULES_LIMIT,
+	DIMENSION_DOOR_TRIGGERS_GUARDS,
+	DWELLINGS_ACCUMULATE_WHEN_NEUTRAL,
+	DWELLINGS_ACCUMULATE_WHEN_OWNED,
+	DWELLINGS_MERGE_ON_RECRUIT,
+	HEROES_BACKPACK_CAP,
+	HEROES_MINIMAL_PRIMARY_SKILLS,
+	HEROES_PER_PLAYER_ON_MAP_CAP,
+	HEROES_PER_PLAYER_TOTAL_CAP,
+	HEROES_RETREAT_ON_WIN_WITHOUT_TROOPS,
+	HEROES_STARTING_STACKS_CHANCES,
+	HEROES_TAVERN_INVITE,
+	MAP_FORMAT_ARMAGEDDONS_BLADE,
+	MAP_FORMAT_CHRONICLES,
+	MAP_FORMAT_HORN_OF_THE_ABYSS,
+	MAP_FORMAT_IN_THE_WAKE_OF_GODS,
+	MAP_FORMAT_JSON_VCMI,
+	MAP_FORMAT_RESTORATION_OF_ERATHIA,
+	MAP_FORMAT_SHADOW_OF_DEATH,
+	MARKETS_BLACK_MARKET_RESTOCK_PERIOD,
+	MODULE_COMMANDERS,
+	MODULE_STACK_ARTIFACT,
+	MODULE_STACK_EXPERIENCE,
+	PATHFINDER_IGNORE_GUARDS,
+	PATHFINDER_ORIGINAL_FLY_RULES,
+	PATHFINDER_USE_BOAT,
+	PATHFINDER_USE_MONOLITH_ONE_WAY_RANDOM,
+	PATHFINDER_USE_MONOLITH_ONE_WAY_UNIQUE,
+	PATHFINDER_USE_MONOLITH_TWO_WAY,
+	PATHFINDER_USE_WHIRLPOOL,
+	RESOURCES_WEEKLY_BONUSES_AI,
+	TEXTS_ARTIFACT,
+	TEXTS_CREATURE,
+	TEXTS_FACTION,
+	TEXTS_HERO,
+	TEXTS_HERO_CLASS,
+	TEXTS_OBJECT,
+	TEXTS_RIVER,
+	TEXTS_ROAD,
+	TEXTS_SPELL,
+	TEXTS_TERRAIN,
+	TOWNS_BUILDINGS_PER_TURN_CAP,
+	TOWNS_STARTING_DWELLING_CHANCES,
+	INTERFACE_PLAYER_COLORED_BACKGROUND,
+	TOWNS_SPELL_RESEARCH,
+	TOWNS_SPELL_RESEARCH_COST,
+	TOWNS_SPELL_RESEARCH_PER_DAY,
+	TOWNS_SPELL_RESEARCH_COST_EXPONENT_PER_RESEARCH,
+
+	OPTIONS_COUNT,
+	OPTIONS_BEGIN = BONUSES_GLOBAL
+};
+
+class DLL_LINKAGE IGameSettings
+{
+public:
+	virtual JsonNode getFullConfig() const = 0;
+	virtual const JsonNode & getValue(EGameSettings option) const = 0;
+	virtual ~IGameSettings() = default;
+
+	bool getBoolean(EGameSettings option) const;
+	int64_t getInteger(EGameSettings option) const;
+	double getDouble(EGameSettings option) const;
+	std::vector<int> getVector(EGameSettings option) const;
+};
+
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/IHandlerBase.cpp vcmi/lib/IHandlerBase.cpp
--- vcmi-1.5.7/lib/IHandlerBase.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/IHandlerBase.cpp	2024-12-19 15:00:22.862146450 +0100
@@ -13,6 +13,7 @@
 #include "modding/IdentifierStorage.h"
 #include "modding/ModScope.h"
 #include "modding/CModHandler.h"
+#include "VCMI_Lib.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
diff --color -urN vcmi-1.5.7/lib/IHandlerBase.h vcmi/lib/IHandlerBase.h
--- vcmi-1.5.7/lib/IHandlerBase.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/IHandlerBase.h	2024-12-19 15:00:22.863146491 +0100
@@ -9,9 +9,6 @@
  */
 #pragma once
 
-#include "../lib/ConstTransitivePtr.h"
-#include "VCMI_Lib.h"
-
 VCMI_LIB_NAMESPACE_BEGIN
 
 class JsonNode;
@@ -60,13 +57,7 @@
 	}
 
 public:
-	virtual ~CHandlerBase()
-	{
-		for(auto & o : objects)
-		{
-			o.dellNull();
-		}
-	}
+	using ObjectPtr = std::shared_ptr<_Object>;
 
 	const Entity * getBaseByIndex(const int32_t index) const override
 	{
@@ -95,23 +86,19 @@
 
 	void loadObject(std::string scope, std::string name, const JsonNode & data) override
 	{
-		auto object = loadFromJson(scope, data, name, objects.size());
-
-		objects.push_back(object);
+		objects.push_back(loadFromJson(scope, data, name, objects.size()));
 
 		for(const auto & type_name : getTypeNames())
-			registerObject(scope, type_name, name, object->getIndex());
+			registerObject(scope, type_name, name, objects.back()->getIndex());
 	}
 
 	void loadObject(std::string scope, std::string name, const JsonNode & data, size_t index) override
 	{
-		auto object = loadFromJson(scope, data, name, index);
-
 		assert(objects[index] == nullptr); // ensure that this id was not loaded before
-		objects[index] = object;
+		objects[index] = loadFromJson(scope, data, name, index);
 
 		for(const auto & type_name : getTypeNames())
-			registerObject(scope, type_name, name, object->getIndex());
+			registerObject(scope, type_name, name, objects[index]->getIndex());
 	}
 
 	const _Object * operator[] (const _ObjectID id) const
@@ -124,25 +111,13 @@
 		return getObjectImpl(index);
 	}
 
-	void updateEntity(int32_t index, const JsonNode & data)
-	{
-		if(index < 0 || index >= objects.size())
-		{
-			logMod->error("%s id %d is invalid", getTypeNames()[0], index);
-		}
-		else
-		{
-			objects.at(index)->updateFrom(data);
-		}
-	}
-
 	size_t size() const
 	{
 		return objects.size();
 	}
 
 protected:
-	virtual _Object * loadFromJson(const std::string & scope, const JsonNode & json, const std::string & identifier, size_t index) = 0;
+	virtual ObjectPtr loadFromJson(const std::string & scope, const JsonNode & json, const std::string & identifier, size_t index) = 0;
 	virtual const std::vector<std::string> & getTypeNames() const = 0;
 
 	template<typename ItemType>
@@ -159,7 +134,7 @@
 	}
 
 public: //todo: make private
-	std::vector<ConstTransitivePtr<_Object>> objects;
+	std::vector<ObjectPtr> objects;
 };
 
 VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/json/JsonBonus.cpp vcmi/lib/json/JsonBonus.cpp
--- vcmi-1.5.7/lib/json/JsonBonus.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/json/JsonBonus.cpp	2024-12-19 15:00:22.905148227 +0100
@@ -13,7 +13,7 @@
 
 #include "JsonValidator.h"
 
-#include "../CGeneralTextHandler.h"
+#include "../texts/CGeneralTextHandler.h"
 #include "../VCMI_Lib.h"
 #include "../bonuses/BonusParams.h"
 #include "../bonuses/Limiters.h"
diff --color -urN vcmi-1.5.7/lib/json/JsonNode.cpp vcmi/lib/json/JsonNode.cpp
--- vcmi-1.5.7/lib/json/JsonNode.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/json/JsonNode.cpp	2024-12-19 15:00:22.905148227 +0100
@@ -26,7 +26,7 @@
 	size_t splitPos = pointer.find('/', 1);
 
 	std::string entry = pointer.substr(1, splitPos - 1);
-	std::string remainer = splitPos == std::string::npos ? "" : pointer.substr(splitPos);
+	std::string remainder = splitPos == std::string::npos ? "" : pointer.substr(splitPos);
 
 	if(in.getType() == VCMI_LIB_WRAP_NAMESPACE(JsonNode)::JsonType::DATA_VECTOR)
 	{
@@ -39,9 +39,9 @@
 		auto index = boost::lexical_cast<size_t>(entry);
 
 		if(in.Vector().size() > index)
-			return in.Vector()[index].resolvePointer(remainer);
+			return in.Vector()[index].resolvePointer(remainder);
 	}
-	return in[entry].resolvePointer(remainer);
+	return in[entry].resolvePointer(remainder);
 }
 
 VCMI_LIB_NAMESPACE_BEGIN
@@ -86,15 +86,20 @@
 {
 }
 
-JsonNode::JsonNode(const std::byte * data, size_t datasize)
-	: JsonNode(data, datasize, JsonParsingSettings())
+JsonNode::JsonNode(const JsonMap & map)
+	: data(map)
 {
 }
 
-JsonNode::JsonNode(const std::byte * data, size_t datasize, const JsonParsingSettings & parserSettings)
+JsonNode::JsonNode(const std::byte * data, size_t datasize, const std::string & fileName)
+	: JsonNode(data, datasize, JsonParsingSettings(), fileName)
+{
+}
+
+JsonNode::JsonNode(const std::byte * data, size_t datasize, const JsonParsingSettings & parserSettings, const std::string & fileName)
 {
 	JsonParser parser(data, datasize, parserSettings);
-	*this = parser.parse("<unknown>");
+	*this = parser.parse(fileName);
 }
 
 JsonNode::JsonNode(const JsonPath & fileURI)
@@ -110,17 +115,17 @@
 	*this = parser.parse(fileURI.getName());
 }
 
-JsonNode::JsonNode(const JsonPath & fileURI, const std::string & idx)
+JsonNode::JsonNode(const JsonPath & fileURI, const std::string & modName)
 {
-	auto file = CResourceHandler::get(idx)->load(fileURI)->readAll();
+	auto file = CResourceHandler::get(modName)->load(fileURI)->readAll();
 
 	JsonParser parser(reinterpret_cast<std::byte *>(file.first.get()), file.second, JsonParsingSettings());
 	*this = parser.parse(fileURI.getName());
 }
 
-JsonNode::JsonNode(const JsonPath & fileURI, bool & isValidSyntax)
+JsonNode::JsonNode(const JsonPath & fileURI, const std::string & modName, bool & isValidSyntax)
 {
-	auto file = CResourceHandler::get()->load(fileURI)->readAll();
+	auto file = CResourceHandler::get(modName)->load(fileURI)->readAll();
 
 	JsonParser parser(reinterpret_cast<std::byte *>(file.first.get()), file.second, JsonParsingSettings());
 	*this = parser.parse(fileURI.getName());
diff --color -urN vcmi-1.5.7/lib/json/JsonNode.h vcmi/lib/json/JsonNode.h
--- vcmi-1.5.7/lib/json/JsonNode.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/json/JsonNode.h	2024-12-19 15:00:22.906148268 +0100
@@ -71,15 +71,18 @@
 	explicit JsonNode(const char * string);
 	explicit JsonNode(const std::string & string);
 
+	/// Create tree from map
+	explicit JsonNode(const JsonMap & map);
+
 	/// Create tree from Json-formatted input
-	explicit JsonNode(const std::byte * data, size_t datasize);
-	explicit JsonNode(const std::byte * data, size_t datasize, const JsonParsingSettings & parserSettings);
+	explicit JsonNode(const std::byte * data, size_t datasize, const std::string & fileName);
+	explicit JsonNode(const std::byte * data, size_t datasize, const JsonParsingSettings & parserSettings, const std::string & fileName);
 
 	/// Create tree from JSON file
 	explicit JsonNode(const JsonPath & fileURI);
 	explicit JsonNode(const JsonPath & fileURI, const JsonParsingSettings & parserSettings);
 	explicit JsonNode(const JsonPath & fileURI, const std::string & modName);
-	explicit JsonNode(const JsonPath & fileURI, bool & isValidSyntax);
+	explicit JsonNode(const JsonPath & fileURI, const std::string & modName, bool & isValidSyntax);
 
 	bool operator==(const JsonNode & other) const;
 	bool operator!=(const JsonNode & other) const;
@@ -152,16 +155,7 @@
 	void serialize(Handler & h)
 	{
 		h & modScope;
-
-		if(h.version >= Handler::Version::JSON_FLAGS)
-		{
-			h & overrideFlag;
-		}
-		else
-		{
-			std::vector<std::string> oldFlags;
-			h & oldFlags;
-		}
+		h & overrideFlag;
 		h & data;
 	}
 };
@@ -196,7 +190,7 @@
 {
 	value.clear();
 	for(const JsonMap::value_type & entry : node.Struct())
-		value.insert(entry.first, entry.second.convertTo<Type>());
+		value.emplace(entry.first, entry.second.convertTo<Type>());
 }
 
 template<typename Type>
diff --color -urN vcmi-1.5.7/lib/json/JsonParser.cpp vcmi/lib/json/JsonParser.cpp
--- vcmi-1.5.7/lib/json/JsonParser.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/json/JsonParser.cpp	2024-12-19 15:00:22.906148268 +0100
@@ -12,7 +12,7 @@
 #include "JsonParser.h"
 
 #include "../ScopeGuard.h"
-#include "../TextOperations.h"
+#include "../texts/TextOperations.h"
 #include "JsonFormatException.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
@@ -55,7 +55,7 @@
 
 	if(!errors.empty())
 	{
-		logMod->warn("File %s is not a valid JSON file!", fileName);
+		logMod->warn("%s is not valid JSON!", fileName);
 		logMod->warn(errors);
 	}
 	return root;
@@ -158,40 +158,58 @@
 
 	switch(input[pos])
 	{
+		case '\r':
+			if(settings.mode == JsonParsingSettings::JsonFormatMode::JSON5 && input.size() > pos && input[pos+1] == '\n')
+			{
+				pos += 2;
+				return true;
+			}
+			break;
+		case '\n':
+			if(settings.mode == JsonParsingSettings::JsonFormatMode::JSON5)
+			{
+				pos += 1;
+				return true;
+			}
+			break;
 		case '\"':
 			str += '\"';
-			break;
+			pos++;
+			return true;
 		case '\\':
 			str += '\\';
-			break;
+			pos++;
+			return true;
 		case 'b':
 			str += '\b';
-			break;
+			pos++;
+			return true;
 		case 'f':
 			str += '\f';
-			break;
+			pos++;
+			return true;
 		case 'n':
 			str += '\n';
-			break;
+			pos++;
+			return true;
 		case 'r':
 			str += '\r';
-			break;
+			pos++;
+			return true;
 		case 't':
 			str += '\t';
-			break;
+			pos++;
+			return true;
 		case '/':
 			str += '/';
-			break;
-		default:
-			return error("Unknown escape sequence!", true);
+			pos++;
+			return true;
 	}
-	return true;
+	return error("Unknown escape sequence!", true);
 }
 
 bool JsonParser::extractString(std::string & str)
 {
-	//TODO: JSON5 - line breaks escaping
-
 	if(settings.mode < JsonParsingSettings::JsonFormatMode::JSON5)
 	{
 		if(input[pos] != '\"')
@@ -216,27 +234,30 @@
 			pos++;
 			return true;
 		}
-		if(input[pos] == '\\') // Escaping
+		else if(input[pos] == '\\') // Escaping
 		{
 			str.append(&input[first], pos - first);
 			pos++;
 			if(pos == input.size())
 				break;
+
 			extractEscaping(str);
-			first = pos + 1;
+			first = pos;
 		}
-		if(input[pos] == '\n') // end-of-line
+		else if(input[pos] == '\n') // end-of-line
 		{
 			str.append(&input[first], pos - first);
 			return error("Closing quote not found!", true);
 		}
-		if(static_cast<unsigned char>(input[pos]) < ' ') // control character
+		else if(static_cast<unsigned char>(input[pos]) < ' ') // control character
 		{
 			str.append(&input[first], pos - first);
-			first = pos + 1;
+			pos++;
+			first = pos;
 			error("Illegal character in the string!", true);
 		}
-		pos++;
+		else
+			pos++;
 	}
 	return error("Unterminated string!");
 }
@@ -587,7 +608,12 @@
 	std::ostringstream stream;
 	std::string type(warning ? " warning: " : " error: ");
 
-	stream << "At line " << lineCount << ", position " << pos - lineStart << type << message << "\n";
+	if(!errors.empty())
+	{
+		// only add the line breaks between error messages so we don't have a trailing line break
+		stream << "\n";
+	}
+	stream << "At line " << lineCount << ", position " << pos - lineStart << type << message;
 	errors += stream.str();
 
 	return warning;
diff --color -urN vcmi-1.5.7/lib/json/JsonRandom.cpp vcmi/lib/json/JsonRandom.cpp
--- vcmi-1.5.7/lib/json/JsonRandom.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/json/JsonRandom.cpp	2024-12-19 15:00:22.906148268 +0100
@@ -12,10 +12,12 @@
 #include "JsonRandom.h"
 
 #include <vstd/StringUtils.h>
+#include <vstd/RNG.h>
+#include <vcmi/HeroClassService.h>
+#include <vcmi/HeroTypeService.h>
 
 #include "JsonBonus.h"
 
-#include "../CRandomGenerator.h"
 #include "../constants/StringConstants.h"
 #include "../VCMI_Lib.h"
 #include "../CArtHandler.h"
@@ -23,8 +25,9 @@
 #include "../CCreatureSet.h"
 #include "../spells/CSpellHandler.h"
 #include "../CSkillHandler.h"
-#include "../CHeroHandler.h"
 #include "../IGameCallback.h"
+#include "../entities/hero/CHero.h"
+#include "../entities/hero/CHeroClass.h"
 #include "../gameState/CGameState.h"
 #include "../mapObjects/IObjectInterface.h"
 #include "../modding/IdentifierStorage.h"
@@ -50,7 +53,7 @@
 		return variables.at(variableID);
 	}
 
-	si32 JsonRandom::loadValue(const JsonNode & value, CRandomGenerator & rng, const Variables & variables, si32 defaultValue)
+	si32 JsonRandom::loadValue(const JsonNode & value, vstd::RNG & rng, const Variables & variables, si32 defaultValue)
 	{
 		if(value.isNull())
 			return defaultValue;
@@ -63,7 +66,7 @@
 		{
 			const auto & vector = value.Vector();
 
-			size_t index= rng.getIntRange(0, vector.size()-1)();
+			size_t index= rng.nextInt64(0, vector.size()-1);
 			return loadValue(vector[index], rng, variables, 0);
 		}
 		if(value.isStruct())
@@ -72,7 +75,7 @@
 				return loadValue(value["amount"], rng, variables, defaultValue);
 			si32 min = loadValue(value["min"], rng, variables, 0);
 			si32 max = loadValue(value["max"], rng, variables, 0);
-			return rng.getIntRange(min, max)();
+			return rng.nextInt64(min, max);
 		}
 		return defaultValue;
 	}
@@ -256,7 +259,7 @@
 		return valuesSet;
 	}
 
-	TResources JsonRandom::loadResources(const JsonNode & value, CRandomGenerator & rng, const Variables & variables)
+	TResources JsonRandom::loadResources(const JsonNode & value, vstd::RNG & rng, const Variables & variables)
 	{
 		TResources ret;
 
@@ -274,7 +277,7 @@
 		return ret;
 	}
 
-	TResources JsonRandom::loadResource(const JsonNode & value, CRandomGenerator & rng, const Variables & variables)
+	TResources JsonRandom::loadResource(const JsonNode & value, vstd::RNG & rng, const Variables & variables)
 	{
 		std::set<GameResID> defaultResources{
 			GameResID::WOOD,
@@ -295,7 +298,7 @@
 		return ret;
 	}
 
-	PrimarySkill JsonRandom::loadPrimary(const JsonNode & value, CRandomGenerator & rng, const Variables & variables)
+	PrimarySkill JsonRandom::loadPrimary(const JsonNode & value, vstd::RNG & rng, const Variables & variables)
 	{
 		std::set<PrimarySkill> defaultSkills{
 			PrimarySkill::ATTACK,
@@ -307,7 +310,7 @@
 		return *RandomGeneratorUtil::nextItem(potentialPicks, rng);
 	}
 
-	std::vector<si32> JsonRandom::loadPrimaries(const JsonNode & value, CRandomGenerator & rng, const Variables & variables)
+	std::vector<si32> JsonRandom::loadPrimaries(const JsonNode & value, vstd::RNG & rng, const Variables & variables)
 	{
 		std::vector<si32> ret(GameConstants::PRIMARY_SKILLS, 0);
 		std::set<PrimarySkill> defaultSkills{
@@ -339,7 +342,7 @@
 		return ret;
 	}
 
-	SecondarySkill JsonRandom::loadSecondary(const JsonNode & value, CRandomGenerator & rng, const Variables & variables)
+	SecondarySkill JsonRandom::loadSecondary(const JsonNode & value, vstd::RNG & rng, const Variables & variables)
 	{
 		std::set<SecondarySkill> defaultSkills;
 		for(const auto & skill : VLC->skillh->objects)
@@ -350,7 +353,7 @@
 		return *RandomGeneratorUtil::nextItem(potentialPicks, rng);
 	}
 
-	std::map<SecondarySkill, si32> JsonRandom::loadSecondaries(const JsonNode & value, CRandomGenerator & rng, const Variables & variables)
+	std::map<SecondarySkill, si32> JsonRandom::loadSecondaries(const JsonNode & value, vstd::RNG & rng, const Variables & variables)
 	{
 		std::map<SecondarySkill, si32> ret;
 		if(value.isStruct())
@@ -380,7 +383,7 @@
 		return ret;
 	}
 
-	ArtifactID JsonRandom::loadArtifact(const JsonNode & value, CRandomGenerator & rng, const Variables & variables)
+	ArtifactID JsonRandom::loadArtifact(const JsonNode & value, vstd::RNG & rng, const Variables & variables)
 	{
 		std::set<ArtifactID> allowedArts;
 		for(const auto & artifact : VLC->arth->objects)
@@ -392,7 +395,7 @@
 		return cb->gameState()->pickRandomArtifact(rng, potentialPicks);
 	}
 
-	std::vector<ArtifactID> JsonRandom::loadArtifacts(const JsonNode & value, CRandomGenerator & rng, const Variables & variables)
+	std::vector<ArtifactID> JsonRandom::loadArtifacts(const JsonNode & value, vstd::RNG & rng, const Variables & variables)
 	{
 		std::vector<ArtifactID> ret;
 		for (const JsonNode & entry : value.Vector())
@@ -402,7 +405,7 @@
 		return ret;
 	}
 
-	SpellID JsonRandom::loadSpell(const JsonNode & value, CRandomGenerator & rng, const Variables & variables)
+	SpellID JsonRandom::loadSpell(const JsonNode & value, vstd::RNG & rng, const Variables & variables)
 	{
 		std::set<SpellID> defaultSpells;
 		for(const auto & spell : VLC->spellh->objects)
@@ -419,7 +422,7 @@
 		return *RandomGeneratorUtil::nextItem(potentialPicks, rng);
 	}
 
-	std::vector<SpellID> JsonRandom::loadSpells(const JsonNode & value, CRandomGenerator & rng, const Variables & variables)
+	std::vector<SpellID> JsonRandom::loadSpells(const JsonNode & value, vstd::RNG & rng, const Variables & variables)
 	{
 		std::vector<SpellID> ret;
 		for (const JsonNode & entry : value.Vector())
@@ -429,7 +432,7 @@
 		return ret;
 	}
 
-	std::vector<PlayerColor> JsonRandom::loadColors(const JsonNode & value, CRandomGenerator & rng, const Variables & variables)
+	std::vector<PlayerColor> JsonRandom::loadColors(const JsonNode & value, vstd::RNG & rng, const Variables & variables)
 	{
 		std::vector<PlayerColor> ret;
 		std::set<PlayerColor> defaultPlayers;
@@ -445,7 +448,7 @@
 		return ret;
 	}
 
-	std::vector<HeroTypeID> JsonRandom::loadHeroes(const JsonNode & value, CRandomGenerator & rng)
+	std::vector<HeroTypeID> JsonRandom::loadHeroes(const JsonNode & value, vstd::RNG & rng)
 	{
 		std::vector<HeroTypeID> ret;
 		for(auto & entry : value.Vector())
@@ -455,7 +458,7 @@
 		return ret;
 	}
 
-	std::vector<HeroClassID> JsonRandom::loadHeroClasses(const JsonNode & value, CRandomGenerator & rng)
+	std::vector<HeroClassID> JsonRandom::loadHeroClasses(const JsonNode & value, vstd::RNG & rng)
 	{
 		std::vector<HeroClassID> ret;
 		for(auto & entry : value.Vector())
@@ -465,7 +468,7 @@
 		return ret;
 	}
 
-	CStackBasicDescriptor JsonRandom::loadCreature(const JsonNode & value, CRandomGenerator & rng, const Variables & variables)
+	CStackBasicDescriptor JsonRandom::loadCreature(const JsonNode & value, vstd::RNG & rng, const Variables & variables)
 	{
 		CStackBasicDescriptor stack;
 
@@ -482,19 +485,19 @@
 		else
 			logMod->warn("Failed to select suitable random creature!");
 
-		stack.type = pickedCreature.toCreature();
+		stack.setType(pickedCreature.toCreature());
 		stack.count = loadValue(value, rng, variables);
-		if (!value["upgradeChance"].isNull() && !stack.type->upgrades.empty())
+		if (!value["upgradeChance"].isNull() && !stack.getCreature()->upgrades.empty())
 		{
 			if (int(value["upgradeChance"].Float()) > rng.nextInt(99)) // select random upgrade
 			{
-				stack.type = RandomGeneratorUtil::nextItem(stack.type->upgrades, rng)->toCreature();
+				stack.setType(RandomGeneratorUtil::nextItem(stack.getCreature()->upgrades, rng)->toCreature());
 			}
 		}
 		return stack;
 	}
 
-	std::vector<CStackBasicDescriptor> JsonRandom::loadCreatures(const JsonNode & value, CRandomGenerator & rng, const Variables & variables)
+	std::vector<CStackBasicDescriptor> JsonRandom::loadCreatures(const JsonNode & value, vstd::RNG & rng, const Variables & variables)
 	{
 		std::vector<CStackBasicDescriptor> ret;
 		for (const JsonNode & node : value.Vector())
diff --color -urN vcmi-1.5.7/lib/json/JsonRandom.h vcmi/lib/json/JsonRandom.h
--- vcmi-1.5.7/lib/json/JsonRandom.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/json/JsonRandom.h	2024-12-19 15:00:22.906148268 +0100
@@ -15,9 +15,13 @@
 
 VCMI_LIB_NAMESPACE_BEGIN
 
+namespace vstd
+{
+class RNG;
+}
+
 class JsonNode;
 using JsonVector = std::vector<JsonNode>;
-class CRandomGenerator;
 
 struct Bonus;
 struct Component;
@@ -53,28 +57,28 @@
 		si32 maxAmount;
 	};
 
-	si32 loadValue(const JsonNode & value, CRandomGenerator & rng, const Variables & variables, si32 defaultValue = 0);
+	si32 loadValue(const JsonNode & value, vstd::RNG & rng, const Variables & variables, si32 defaultValue = 0);
 
-	TResources loadResources(const JsonNode & value, CRandomGenerator & rng, const Variables & variables);
-	TResources loadResource(const JsonNode & value, CRandomGenerator & rng, const Variables & variables);
-	PrimarySkill loadPrimary(const JsonNode & value, CRandomGenerator & rng, const Variables & variables);
-	std::vector<si32> loadPrimaries(const JsonNode & value, CRandomGenerator & rng, const Variables & variables);
-	SecondarySkill loadSecondary(const JsonNode & value, CRandomGenerator & rng, const Variables & variables);
-	std::map<SecondarySkill, si32> loadSecondaries(const JsonNode & value, CRandomGenerator & rng, const Variables & variables);
+	TResources loadResources(const JsonNode & value, vstd::RNG & rng, const Variables & variables);
+	TResources loadResource(const JsonNode & value, vstd::RNG & rng, const Variables & variables);
+	PrimarySkill loadPrimary(const JsonNode & value, vstd::RNG & rng, const Variables & variables);
+	std::vector<si32> loadPrimaries(const JsonNode & value, vstd::RNG & rng, const Variables & variables);
+	SecondarySkill loadSecondary(const JsonNode & value, vstd::RNG & rng, const Variables & variables);
+	std::map<SecondarySkill, si32> loadSecondaries(const JsonNode & value, vstd::RNG & rng, const Variables & variables);
 
-	ArtifactID loadArtifact(const JsonNode & value, CRandomGenerator & rng, const Variables & variables);
-	std::vector<ArtifactID> loadArtifacts(const JsonNode & value, CRandomGenerator & rng, const Variables & variables);
+	ArtifactID loadArtifact(const JsonNode & value, vstd::RNG & rng, const Variables & variables);
+	std::vector<ArtifactID> loadArtifacts(const JsonNode & value, vstd::RNG & rng, const Variables & variables);
 
-	SpellID loadSpell(const JsonNode & value, CRandomGenerator & rng, const Variables & variables);
-	std::vector<SpellID> loadSpells(const JsonNode & value, CRandomGenerator & rng, const Variables & variables);
+	SpellID loadSpell(const JsonNode & value, vstd::RNG & rng, const Variables & variables);
+	std::vector<SpellID> loadSpells(const JsonNode & value, vstd::RNG & rng, const Variables & variables);
 
-	CStackBasicDescriptor loadCreature(const JsonNode & value, CRandomGenerator & rng, const Variables & variables);
-	std::vector<CStackBasicDescriptor> loadCreatures(const JsonNode & value, CRandomGenerator & rng, const Variables & variables);
+	CStackBasicDescriptor loadCreature(const JsonNode & value, vstd::RNG & rng, const Variables & variables);
+	std::vector<CStackBasicDescriptor> loadCreatures(const JsonNode & value, vstd::RNG & rng, const Variables & variables);
 	std::vector<RandomStackInfo> evaluateCreatures(const JsonNode & value, const Variables & variables);
 
-	std::vector<PlayerColor> loadColors(const JsonNode & value, CRandomGenerator & rng, const Variables & variables);
-	std::vector<HeroTypeID> loadHeroes(const JsonNode & value, CRandomGenerator & rng);
-	std::vector<HeroClassID> loadHeroClasses(const JsonNode & value, CRandomGenerator & rng);
+	std::vector<PlayerColor> loadColors(const JsonNode & value, vstd::RNG & rng, const Variables & variables);
+	std::vector<HeroTypeID> loadHeroes(const JsonNode & value, vstd::RNG & rng);
+	std::vector<HeroClassID> loadHeroClasses(const JsonNode & value, vstd::RNG & rng);
 
 	static std::vector<Bonus> loadBonuses(const JsonNode & value);
 };
diff --color -urN vcmi-1.5.7/lib/json/JsonUtils.cpp vcmi/lib/json/JsonUtils.cpp
--- vcmi-1.5.7/lib/json/JsonUtils.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/json/JsonUtils.cpp	2024-12-19 15:00:22.906148268 +0100
@@ -230,13 +230,36 @@
 	std::swap(descendant, inheritedNode);
 }
 
-JsonNode JsonUtils::assembleFromFiles(const std::vector<std::string> & files)
+JsonNode JsonUtils::assembleFromFiles(const JsonNode & files, bool & isValid)
+{
+	if (files.isVector())
+	{
+		assert(!files.getModScope().empty());
+		auto configList = files.convertTo<std::vector<std::string> >();
+		JsonNode result = JsonUtils::assembleFromFiles(configList, files.getModScope(), isValid);
+
+		return result;
+	}
+	else
+	{
+		isValid = true;
+		return files;
+	}
+}
+
+JsonNode JsonUtils::assembleFromFiles(const JsonNode & files)
 {
 	bool isValid = false;
 	return assembleFromFiles(files, isValid);
 }
 
-JsonNode JsonUtils::assembleFromFiles(const std::vector<std::string> & files, bool & isValid)
+JsonNode JsonUtils::assembleFromFiles(const std::vector<std::string> & files)
+{
+	bool isValid = false;
+	return assembleFromFiles(files, "", isValid);
+}
+
+JsonNode JsonUtils::assembleFromFiles(const std::vector<std::string> & files, std::string modName, bool & isValid)
 {
 	isValid = true;
 	JsonNode result;
@@ -245,10 +268,10 @@
 	{
 		JsonPath path = JsonPath::builtinTODO(file);
 
-		if (CResourceHandler::get()->existsResource(path))
+		if (CResourceHandler::get(modName)->existsResource(path))
 		{
 			bool isValidFile = false;
-			JsonNode section(JsonPath::builtinTODO(file), isValidFile);
+			JsonNode section(JsonPath::builtinTODO(file), modName, isValidFile);
 			merge(result, section);
 			isValid |= isValidFile;
 		}
@@ -269,10 +292,34 @@
 	for(auto & loader : CResourceHandler::get()->getResourcesWithName(resID))
 	{
 		auto textData = loader->load(resID)->readAll();
-		JsonNode section(reinterpret_cast<std::byte *>(textData.first.get()), textData.second);
+		JsonNode section(reinterpret_cast<std::byte *>(textData.first.get()), textData.second, resID.getName());
 		merge(result, section);
 	}
 	return result;
 }
 
+void JsonUtils::detectConflicts(JsonNode & result, const JsonNode & left, const JsonNode & right, const std::string & keyName)
+{
+	switch (left.getType())
+	{
+		case JsonNode::JsonType::DATA_NULL:
+		case JsonNode::JsonType::DATA_BOOL:
+		case JsonNode::JsonType::DATA_FLOAT:
+		case JsonNode::JsonType::DATA_INTEGER:
+		case JsonNode::JsonType::DATA_STRING:
+		case JsonNode::JsonType::DATA_VECTOR: // NOTE: comparing vectors as whole - since merge will overwrite it in its entirety
+		{
+			result[keyName][left.getModScope()] = left;
+			result[keyName][right.getModScope()] = right;
+			return;
+		}
+		case JsonNode::JsonType::DATA_STRUCT:
+		{
+			for(const auto & node : left.Struct())
+				if (!right[node.first].isNull())
+					detectConflicts(result, node.second, right[node.first], keyName + "/" + node.first);
+		}
+	}
+}
+
 VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/json/JsonUtils.h vcmi/lib/json/JsonUtils.h
--- vcmi-1.5.7/lib/json/JsonUtils.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/json/JsonUtils.h	2024-12-19 15:00:22.906148268 +0100
@@ -44,8 +44,10 @@
 	 * @brief generate one Json structure from multiple files
 	 * @param files - list of filenames with parts of json structure
 	 */
+	DLL_LINKAGE JsonNode assembleFromFiles(const JsonNode & files);
+	DLL_LINKAGE JsonNode assembleFromFiles(const JsonNode & files, bool & isValid);
 	DLL_LINKAGE JsonNode assembleFromFiles(const std::vector<std::string> & files);
-	DLL_LINKAGE JsonNode assembleFromFiles(const std::vector<std::string> & files, bool & isValid);
+	DLL_LINKAGE JsonNode assembleFromFiles(const std::vector<std::string> & files, std::string modName, bool & isValid);
 
 	/// This version loads all files with same name (overridden by mods)
 	DLL_LINKAGE JsonNode assembleFromFiles(const std::string & filename);
@@ -65,13 +67,19 @@
 	* @param node - JsonNode to check
 	* @param schemaName - name of schema to use
 	* @param dataName - some way to identify data (printed in console in case of errors)
-	* @returns true if data in node fully compilant with schema
+	* @returns true if data in node fully compliant with schema
 	*/
 	DLL_LINKAGE bool validate(const JsonNode & node, const std::string & schemaName, const std::string & dataName);
 
 	/// get schema by json URI: vcmi:<name of file in schemas directory>#<entry in file, optional>
 	/// example: schema "vcmi:settings" is used to check user settings
 	DLL_LINKAGE const JsonNode & getSchema(const std::string & URI);
+
+	/// detects potential conflicts - json entries present in both nodes
+	/// returns JsonNode that contains list of conflicting keys
+	/// For each conflict - list of conflicting mods and list of conflicting json values
+	/// result[pathToKey][modID] -> node that was conflicting
+	DLL_LINKAGE void detectConflicts(JsonNode & result, const JsonNode & left, const JsonNode & right, const std::string & keyName);
 }
 
 VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/json/JsonValidator.cpp vcmi/lib/json/JsonValidator.cpp
--- vcmi-1.5.7/lib/json/JsonValidator.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/json/JsonValidator.cpp	2024-12-19 15:00:22.906148268 +0100
@@ -21,6 +21,80 @@
 
 VCMI_LIB_NAMESPACE_BEGIN
 
+// Algorithm for detection of typos in words
+// Determines how 'different' two strings are - how many changes must be done to turn one string into another one
+// https://en.wikipedia.org/wiki/Levenshtein_distance#Iterative_with_two_matrix_rows
+static int getLevenshteinDistance(const std::string & s, const std::string & t)
+{
+	int n = t.size();
+	int m = s.size();
+
+	// create two work vectors of integer distances
+	std::vector<int> v0(n+1, 0);
+	std::vector<int> v1(n+1, 0);
+
+	// initialize v0 (the previous row of distances)
+	// this row is A[0][i]: edit distance from an empty s to t;
+	// that distance is the number of characters to append to  s to make t.
+	for (int i = 0; i < n; ++i)
+		v0[i] = i;
+
+	for (int i = 0; i < m; ++i)
+	{
+		// calculate v1 (current row distances) from the previous row v0
+
+		// first element of v1 is A[i + 1][0]
+		// edit distance is delete (i + 1) chars from s to match empty t
+		v1[0] = i + 1;
+
+		// use formula to fill in the rest of the row
+		for (int j = 0; j < n; ++j)
+		{
+			// calculating costs for A[i + 1][j + 1]
+			int deletionCost = v0[j + 1] + 1;
+			int insertionCost = v1[j] + 1;
+			int substitutionCost;
+
+			if (s[i] == t[j])
+				substitutionCost = v0[j];
+			else
+				substitutionCost = v0[j] + 1;
+
+			v1[j + 1] = std::min({deletionCost, insertionCost, substitutionCost});
+		}
+
+		// copy v1 (current row) to v0 (previous row) for next iteration
+		// since data in v1 is always invalidated, a swap without copy could be more efficient
+		std::swap(v0, v1);
+	}
+
+	// after the last swap, the results of v1 are now in v0
+	return v0[n];
+}
+
+/// Searches for keys similar to 'target' in 'candidates' map
+/// Returns closest match or empty string if no suitable candidates are found
+static std::string findClosestMatch(const JsonMap & candidates, const std::string & target)
+{
+	// Maximum distance at which we can consider strings to be similar
+	// If strings have more different symbols than this number then it is not a typo, but a completely different word
+	static constexpr int maxDistance = 5;
+	int bestDistance = maxDistance;
+	std::string bestMatch;
+
+	for (auto const & candidate : candidates)
+	{
+		int newDistance = getLevenshteinDistance(candidate.first, target);
+
+		if (newDistance < bestDistance)
+		{
+			bestDistance = newDistance;
+			bestMatch = candidate.first;
+		}
+	}
+	return bestMatch;
+}
+
 static std::string emptyCheck(JsonValidator & validator, const JsonNode & baseSchema, const JsonNode & schema, const JsonNode & data)
 {
 	// check is not needed - e.g. incorporated into another check
@@ -348,7 +422,7 @@
 	std::string errors;
 	for(const auto & required : schema.Vector())
 	{
-		if (data[required.String()].isNull())
+		if (data[required.String()].isNull() && data.getModScope() != "core")
 			errors += validator.makeErrorMessage("Required entry " + required.String() + " is missing");
 	}
 	return errors;
@@ -417,7 +491,13 @@
 
 			// or, additionalItems field can be bool which indicates if such items are allowed
 			else if(!schema.isNull() && !schema.Bool()) // present and set to false - error
-				errors += validator.makeErrorMessage("Unknown entry found: " + entry.first);
+			{
+				std::string bestCandidate = findClosestMatch(baseSchema["properties"].Struct(), entry.first);
+				if (!bestCandidate.empty())
+					errors += validator.makeErrorMessage("Unknown entry found: '" + entry.first + "'. Perhaps you meant '" + bestCandidate + "'?");
+				else
+					errors += validator.makeErrorMessage("Unknown entry found: " + entry.first);
+			}
 		}
 	}
 	return errors;
@@ -496,6 +576,7 @@
 static std::string videoFile(const JsonNode & node)
 {
 	TEST_FILE(node.getModScope(), "Video/", node.String(), EResType::VIDEO);
+	TEST_FILE(node.getModScope(), "Video/", node.String(), EResType::VIDEO_LOW_QUALITY);
 	return "Video file \"" + node.String() + "\" was not found";
 }
 #undef TEST_FILE
diff --color -urN vcmi-1.5.7/lib/json/JsonValidator.h vcmi/lib/json/JsonValidator.h
--- vcmi-1.5.7/lib/json/JsonValidator.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/json/JsonValidator.h	2024-12-19 15:00:22.907148309 +0100
@@ -13,7 +13,7 @@
 
 VCMI_LIB_NAMESPACE_BEGIN
 
-/// Class for Json validation. Mostly compilant with json-schema v6 draf
+/// Class for Json validation. Mostly compliant with json-schema v6 draf
 struct JsonValidator
 {
 	/// path from root node to current one.
diff --color -urN vcmi-1.5.7/lib/Languages.h vcmi/lib/Languages.h
--- vcmi-1.5.7/lib/Languages.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/Languages.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,160 +0,0 @@
-/*
- * Languages.h, part of VCMI engine
- *
- * Authors: listed in file AUTHORS in main folder
- *
- * License: GNU General Public License v2.0 or later
- * Full text of license available in license.txt file, in main folder
- *
- */
-#pragma once
-
-namespace Languages
-{
-
-enum class EPluralForms
-{
-	NONE,
-	VI_1, // Single plural form, (Vietnamese)
-	EN_2, // Two forms, singular used for one only (English)
-	FR_2, // Two forms, singular used for zero and one (French)
-	UK_3, // Three forms, special cases for numbers ending in 1 and 2, 3, 4, except those ending in 1[1-4] (Ukrainian)
-	CZ_3, // Three forms, special cases for 1 and 2, 3, 4 (Czech)
-	PL_3, // Three forms, special case for one and some numbers ending in 2, 3, or 4 (Polish)
-};
-
-enum class ELanguages
-{
-	CZECH,
-	CHINESE,
-	ENGLISH,
-	FINNISH,
-	FRENCH,
-	GERMAN,
-	HUNGARIAN,
-	ITALIAN,
-	KOREAN,
-	POLISH,
-	PORTUGUESE,
-	RUSSIAN,
-	SPANISH,
-	SWEDISH,
-	TURKISH,
-	UKRAINIAN,
-	VIETNAMESE,
-
-	COUNT
-};
-
-struct Options
-{
-	/// string identifier (ascii, lower-case), e.g. "english"
-	std::string identifier;
-
-	/// human-readable name of language in English
-	std::string nameEnglish;
-
-	/// human-readable name of language in its own language
-	std::string nameNative;
-
-	/// encoding that is used by H3 for this language
-	std::string encoding;
-
-	/// primary IETF language tag
-	std::string tagIETF;
-
-	/// DateTime format
-	std::string dateTimeFormat;
-
-	/// Ruleset for plural forms in this language
-	EPluralForms pluralForms = EPluralForms::NONE;
-};
-
-inline const auto & getLanguageList()
-{
-	static const std::array<Options, 17> languages
-	{ {
-		{ "czech",       "Czech",       "etina",    "CP1250", "cs", "%d.%m.%Y %T",    EPluralForms::CZ_3 },
-		{ "chinese",     "Chinese",     "",       "GBK",    "zh", "%F %T",          EPluralForms::VI_1 }, // Note: actually Simplified Chinese
-		{ "english",     "English",     "English",    "CP1252", "en", "%F %T",          EPluralForms::EN_2 }, // English uses international date/time format here
-		{ "finnish",     "Finnish",     "Suomi",      "CP1252", "fi", "%d.%m.%Y %T",    EPluralForms::EN_2 },
-		{ "french",      "French",      "Franais",   "CP1252", "fr", "%d/%m/%Y %T",    EPluralForms::FR_2 },
-		{ "german",      "German",      "Deutsch",    "CP1252", "de", "%d.%m.%Y %T",    EPluralForms::EN_2 },
-		{ "hungarian",   "Hungarian",   "Magyar",     "CP1250", "hu", "%Y. %m. %d. %T", EPluralForms::EN_2 },
-		{ "italian",     "Italian",     "Italiano",   "CP1250", "it", "%d/%m/%Y %T",    EPluralForms::EN_2 },
-		{ "korean",      "Korean",      "",        "CP949",  "ko", "%F %T",		    EPluralForms::VI_1 },
-		{ "polish",      "Polish",      "Polski",     "CP1250", "pl", "%d.%m.%Y %T",    EPluralForms::PL_3 },
-		{ "portuguese",  "Portuguese",  "Portugus",  "CP1252", "pt", "%d/%m/%Y %T",    EPluralForms::EN_2 }, // Note: actually Brazilian Portuguese
-		{ "russian",     "Russian",     "",    "CP1251", "ru", "%d.%m.%Y %T",    EPluralForms::UK_3 },
-		{ "spanish",     "Spanish",     "Espaol",    "CP1252", "es", "%d/%m/%Y %T",    EPluralForms::EN_2 },
-		{ "swedish",     "Swedish",     "Svenska",    "CP1252", "sv", "%F %T",          EPluralForms::EN_2 },
-		{ "turkish",     "Turkish",     "Trke",     "CP1254", "tr", "%d.%m.%Y %T",    EPluralForms::EN_2 },
-		{ "ukrainian",   "Ukrainian",   "", "CP1251", "uk", "%d.%m.%Y %T",    EPluralForms::UK_3 },
-		{ "vietnamese",  "Vietnamese",  "Ting Vit", "UTF-8",  "vi", "%d/%m/%Y %T",    EPluralForms::VI_1 }, // Fan translation uses special encoding
-	} };
-	static_assert(languages.size() == static_cast<size_t>(ELanguages::COUNT), "Languages array is missing a value!");
-
-	return languages;
-}
-
-inline const Options & getLanguageOptions(ELanguages language)
-{
-	return getLanguageList().at(static_cast<size_t>(language));
-}
-
-inline const Options & getLanguageOptions(const std::string & language)
-{
-	for(const auto & entry : getLanguageList())
-		if(entry.identifier == language)
-			return entry;
-
-	throw std::out_of_range("Language " + language + " does not exists!");
-}
-
-template<typename Numeric>
-inline constexpr int getPluralFormIndex(EPluralForms form, Numeric value)
-{
-	// Based on https://www.gnu.org/software/gettext/manual/html_node/Plural-forms.html
-	switch(form)
-	{
-		case EPluralForms::NONE:
-		case EPluralForms::VI_1:
-			return 0;
-		case EPluralForms::EN_2:
-			if (value == 1)
-				return 1;
-			return 2;
-		case EPluralForms::FR_2:
-			if (value == 1 || value == 0)
-				return 1;
-			return 2;
-		case EPluralForms::UK_3:
-			if (value % 10 == 1 && value % 100 != 11)
-				return 1;
-			if (value%10>=2 && value%10<=4 && (value%100<10 || value%100>=20))
-				return 2;
-			return 0;
-		case EPluralForms::CZ_3:
-			if (value == 1)
-				return 1;
-			if (value>=2 && value<=4)
-				return 2;
-			return 0;
-		case EPluralForms::PL_3:
-			if (value == 1)
-				return 1;
-			if (value%10>=2 && value%10<=4 && (value%100<10 || value%100>=20))
-				return 2;
-			return 0;
-	}
-	throw std::runtime_error("Invalid plural form enumeration received!");
-}
-
-template<typename Numeric>
-inline std::string getPluralFormTextID(std::string languageName, Numeric value, std::string textID)
-{
-	int formIndex = getPluralFormIndex(getLanguageOptions(languageName).pluralForms, value);
-	return textID + '.' + std::to_string(formIndex);
-}
-
-}
diff --color -urN vcmi-1.5.7/lib/logging/CLogger.cpp vcmi/lib/logging/CLogger.cpp
--- vcmi-1.5.7/lib/logging/CLogger.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/logging/CLogger.cpp	2024-12-19 15:00:22.907148309 +0100
@@ -96,6 +96,7 @@
 DLL_LINKAGE vstd::CLoggerBase * logAi = CLogger::getLogger(CLoggerDomain("ai"));
 DLL_LINKAGE vstd::CLoggerBase * logAnim = CLogger::getLogger(CLoggerDomain("animation"));
 DLL_LINKAGE vstd::CLoggerBase * logMod = CLogger::getLogger(CLoggerDomain("mod"));
+DLL_LINKAGE vstd::CLoggerBase * logRng = CLogger::getLogger(CLoggerDomain("rng"));
 
 CLogger * CLogger::getLogger(const CLoggerDomain & domain)
 {
diff --color -urN vcmi-1.5.7/lib/logging/VisualLogger.cpp vcmi/lib/logging/VisualLogger.cpp
--- vcmi-1.5.7/lib/logging/VisualLogger.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/logging/VisualLogger.cpp	2024-12-19 15:00:22.907148309 +0100
@@ -15,30 +15,101 @@
 DLL_LINKAGE VisualLogger * logVisual = new VisualLogger();
 
 
-void VisualLogger::updateWithLock(std::string channel, std::function<void(IVisualLogBuilder & logBuilder)> func)
+void VisualLogger::updateWithLock(const std::string & channel, const std::function<void(IVisualLogBuilder & logBuilder)> & func)
 {
-	std::lock_guard<std::mutex> lock(mutex);
+	std::lock_guard lock(mutex);
 
 	mapLines[channel].clear();
+	mapTexts[channel].clear();
+	battleTexts[channel].clear();
 
-	VisualLogBuilder builder(mapLines[channel]);
+	VisualLogBuilder builder(mapLines[channel], mapTexts[channel], battleTexts[channel]);
 	
 	func(builder);
 }
 
-void VisualLogger::visualize(ILogVisualizer & visulizer)
+void VisualLogger::visualize(IMapOverlayLogVisualizer & visulizer)
 {
-	std::lock_guard<std::mutex> lock(mutex);
+	std::lock_guard lock(mutex);
 
-	for(auto line : mapLines[keyToShow])
+	for(const auto & line : mapLines[keyToShow])
 	{
 		visulizer.drawLine(line.start, line.end);
 	}
+
+	std::map<int3, std::vector<Text<int3>>> textMap;
+
+	for(const auto & line : mapTexts[keyToShow])
+	{
+		textMap[line.tile].push_back(line);
+	}
+
+	for(const auto & pair : textMap)
+	{
+		for(int i = 0; i < pair.second.size(); i++)
+		{
+			visulizer.drawText(pair.first, i, pair.second[i].text, pair.second[i].background);
+		}
+	}
 }
 
-void VisualLogger::setKey(std::string key)
+void VisualLogger::visualize(IBattleOverlayLogVisualizer & visulizer)
+{
+	std::lock_guard lock(mutex);
+	std::map<BattleHex, std::vector<std::string>> textMap;
+
+	for(auto line : battleTexts[keyToShow])
+	{
+		textMap[line.tile].push_back(line.text);
+	}
+
+	for(auto & pair : textMap)
+	{
+		for(int i = 0; i < pair.second.size(); i++)
+		{
+			visulizer.drawText(pair.first, i, pair.second[i]);
+		}
+	}
+}
+
+void VisualLogger::setKey(const std::string & key)
 {
 	keyToShow = key;
 }
 
+void IVisualLogBuilder::addText(int3 tile, const std::string & text, PlayerColor background)
+{
+	std::optional<ColorRGBA> rgbColor;
+
+	switch(background)
+	{
+	case 0:
+		rgbColor = ColorRGBA(255, 0, 0);
+		break;
+	case 1:
+		rgbColor = ColorRGBA(0, 0, 255);
+		break;
+	case 2:
+		rgbColor = ColorRGBA(128, 128, 128);
+		break;
+	case 3:
+		rgbColor = ColorRGBA(0, 255, 0);
+		break;
+	case 4:
+		rgbColor = ColorRGBA(255, 128, 0);
+		break;
+	case 5:
+		rgbColor = ColorRGBA(128, 0, 128);
+		break;
+	case 6:
+		rgbColor = ColorRGBA(0, 255, 255);
+		break;
+	case 7:
+		rgbColor = ColorRGBA(255, 128, 255);
+		break;
+	}
+
+	addText(tile, text, rgbColor);
+}
+
 VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/logging/VisualLogger.h vcmi/lib/logging/VisualLogger.h
--- vcmi-1.5.7/lib/logging/VisualLogger.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/logging/VisualLogger.h	2024-12-19 15:00:22.907148309 +0100
@@ -11,63 +11,108 @@
 
 #include "../int3.h"
 #include "../constants/EntityIdentifiers.h"
+#include "../battle/BattleHex.h"
+#include "../Color.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
-class ILogVisualizer
+class IMapOverlayLogVisualizer
 {
 public:
 	virtual void drawLine(int3 start, int3 end) = 0;
+	virtual void drawText(int3 tile, int lineNumber, const std::string & text, const std::optional<ColorRGBA> & color) = 0;
 };
 
-class IVisualLogBuilder
+class IBattleOverlayLogVisualizer
+{
+public:
+	virtual void drawText(BattleHex tile, int lineNumber, const std::string & text) = 0;
+};
+
+class DLL_LINKAGE IVisualLogBuilder
 {
 public:
 	virtual void addLine(int3 start, int3 end) = 0;
+	virtual void addText(int3 tile, const std::string & text, const std::optional<ColorRGBA> & color = {}) = 0;
+	virtual void addText(BattleHex tile, const std::string & text) = 0;
+
+	void addText(int3 tile, const std::string & text, PlayerColor background);
 };
 
 /// The logger is used to show screen overlay
 class DLL_LINKAGE VisualLogger
 {
 private:
-	struct MapLine
+	template<typename T>
+	struct Line
 	{
-		int3 start;
-		int3 end;
+		T start;
+		T end;
 
-		MapLine(int3 start, int3 end)
+		Line(T start, T end)
 			:start(start), end(end)
 		{
 		}
 	};
 
+	template<typename T>
+	struct Text
+	{
+		T tile;
+		std::string text;
+		std::optional<ColorRGBA> background;
+
+		Text(T tile, std::string text, std::optional<ColorRGBA> background)
+			:tile(tile), text(text), background(background)
+		{
+		}
+	};
+
 	class VisualLogBuilder : public IVisualLogBuilder
 	{
 	private:
-		std::vector<MapLine> & mapLines;
+		std::vector<Line<int3>> & mapLines;
+		std::vector<Text<BattleHex>> & battleTexts;
+		std::vector<Text<int3>> & mapTexts;
 
 	public:
-		VisualLogBuilder(std::vector<MapLine> & mapLines)
-			:mapLines(mapLines)
+		VisualLogBuilder(
+			std::vector<Line<int3>> & mapLines,
+			std::vector<Text<int3>> & mapTexts,
+			std::vector<Text<BattleHex>> & battleTexts)
+			:mapLines(mapLines), mapTexts(mapTexts), battleTexts(battleTexts)
+		{
+		}
+
+		void addLine(int3 start, int3 end) override
+		{
+			mapLines.emplace_back(start, end);
+		}
+
+		void addText(BattleHex tile, const std::string & text) override
 		{
+			battleTexts.emplace_back(tile, text, std::optional<ColorRGBA>());
 		}
 
-		virtual void addLine(int3 start, int3 end) override
+		void addText(int3 tile, const std::string & text, const std::optional<ColorRGBA> & background) override
 		{
-			mapLines.push_back(MapLine(start, end));
+			mapTexts.emplace_back(tile, text, background);
 		}
 	};
 
 private:
-	std::map<std::string, std::vector<MapLine>> mapLines;
+	std::map<std::string, std::vector<Line<int3>>> mapLines;
+	std::map<std::string, std::vector<Text<int3>>> mapTexts;
+	std::map<std::string, std::vector<Text<BattleHex>>> battleTexts;
 	std::mutex mutex;
 	std::string keyToShow;
 
 public:
 
-	void updateWithLock(std::string channel, std::function<void(IVisualLogBuilder & logBuilder)> func);
-	void visualize(ILogVisualizer & visulizer);
-	void setKey(std::string key);
+	void updateWithLock(const std::string & channel, const std::function<void(IVisualLogBuilder & logBuilder)> & func);
+	void visualize(IMapOverlayLogVisualizer & visulizer);
+	void visualize(IBattleOverlayLogVisualizer & visulizer);
+	void setKey(const std::string & key);
 };
 
 extern DLL_LINKAGE VisualLogger * logVisual;
diff --color -urN vcmi-1.5.7/lib/LogicalExpression.cpp vcmi/lib/LogicalExpression.cpp
--- vcmi-1.5.7/lib/LogicalExpression.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/LogicalExpression.cpp	2024-12-19 15:00:22.864146533 +0100
@@ -12,7 +12,7 @@
 #include "LogicalExpression.h"
 
 #include "VCMI_Lib.h"
-#include "CGeneralTextHandler.h"
+#include "texts/CGeneralTextHandler.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
diff --color -urN vcmi-1.5.7/lib/mapObjectConstructors/AObjectTypeHandler.cpp vcmi/lib/mapObjectConstructors/AObjectTypeHandler.cpp
--- vcmi-1.5.7/lib/mapObjectConstructors/AObjectTypeHandler.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapObjectConstructors/AObjectTypeHandler.cpp	2024-12-19 15:00:22.908148351 +0100
@@ -12,7 +12,7 @@
 #include "AObjectTypeHandler.h"
 
 #include "IObjectInfo.h"
-#include "../CGeneralTextHandler.h"
+#include "../texts/CGeneralTextHandler.h"
 #include "../VCMI_Lib.h"
 #include "../json/JsonUtils.h"
 #include "../modding/IdentifierStorage.h"
@@ -29,6 +29,11 @@
 	return modScope + ':' + subTypeName;
 }
 
+std::string AObjectTypeHandler::getModScope() const
+{
+	return modScope;
+}
+
 si32 AObjectTypeHandler::getIndex() const
 {
 	return type;
@@ -128,8 +133,6 @@
 {
 	obj->ID = Obj(type);
 	obj->subID = subtype;
-	obj->typeName = typeName;
-	obj->subTypeName = getJsonKey();
 	obj->blockVisit = blockVisit;
 	obj->removable = removable;
 }
diff --color -urN vcmi-1.5.7/lib/mapObjectConstructors/AObjectTypeHandler.h vcmi/lib/mapObjectConstructors/AObjectTypeHandler.h
--- vcmi-1.5.7/lib/mapObjectConstructors/AObjectTypeHandler.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapObjectConstructors/AObjectTypeHandler.h	2024-12-19 15:00:22.908148351 +0100
@@ -15,9 +15,13 @@
 
 VCMI_LIB_NAMESPACE_BEGIN
 
+namespace vstd
+{
+class RNG;
+}
+
 class ObjectTemplate;
 class CGObjectInstance;
-class CRandomGenerator;
 class IObjectInfo;
 class IGameCallback;
 
@@ -70,6 +74,8 @@
 	/// returns full form of identifier of this object in form of modName:objectName
 	std::string getJsonKey() const;
 
+	std::string getModScope() const;
+
 	/// Returns object-specific name, if set
 	SObjectSounds getSounds() const;
 
@@ -84,7 +90,7 @@
 
 	/// returns preferred template for this object, if present (e.g. one of 3 possible templates for town - village, fort and castle)
 	/// note that appearance will not be changed - this must be done separately (either by assignment or via pack from server)
-	std::shared_ptr<const ObjectTemplate> getOverride(TerrainId terrainType, const CGObjectInstance * object) const;
+	virtual std::shared_ptr<const ObjectTemplate> getOverride(TerrainId terrainType, const CGObjectInstance * object) const;
 
 	BattleField getBattlefield() const;
 
@@ -114,7 +120,7 @@
 
 	/// Configures object properties. Should be re-entrable, resetting state of the object if necessarily
 	/// This should set remaining properties, including randomized or depending on map
-	virtual void configureObject(CGObjectInstance * object, CRandomGenerator & rng) const = 0;
+	virtual void configureObject(CGObjectInstance * object, vstd::RNG & rng) const = 0;
 
 	/// Returns object configuration, if available. Otherwise returns NULL
 	virtual std::unique_ptr<IObjectInfo> getObjectInfo(std::shared_ptr<const ObjectTemplate> tmpl) const;
diff --color -urN vcmi-1.5.7/lib/mapObjectConstructors/CBankInstanceConstructor.cpp vcmi/lib/mapObjectConstructors/CBankInstanceConstructor.cpp
--- vcmi-1.5.7/lib/mapObjectConstructors/CBankInstanceConstructor.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapObjectConstructors/CBankInstanceConstructor.cpp	2024-12-19 15:00:22.908148351 +0100
@@ -11,9 +11,10 @@
 #include "CBankInstanceConstructor.h"
 
 #include "../json/JsonRandom.h"
-#include "../CGeneralTextHandler.h"
+#include "../texts/CGeneralTextHandler.h"
 #include "../IGameCallback.h"
-#include "../CRandomGenerator.h"
+
+#include <vstd/RNG.h>
 
 VCMI_LIB_NAMESPACE_BEGIN
 
@@ -27,7 +28,7 @@
 	if (input.Struct().count("name") == 0)
 		logMod->warn("Bank %s missing name!", getJsonKey());
 
-	VLC->generaltexth->registerString(input.getModScope(), getNameTextID(), input["name"].String());
+	VLC->generaltexth->registerString(input.getModScope(), getNameTextID(), input["name"]);
 
 	levels = input["levels"].Vector();
 	bankResetDuration = static_cast<si32>(input["resetDuration"].Float());
@@ -36,7 +37,7 @@
 	regularUnitPlacement = input["regularUnitPlacement"].Bool();
 }
 
-BankConfig CBankInstanceConstructor::generateConfig(IGameCallback * cb, const JsonNode & level, CRandomGenerator & rng) const
+BankConfig CBankInstanceConstructor::generateLevelConfiguration(IGameCallback * cb, const JsonNode & level, vstd::RNG & rng) const
 {
 	BankConfig bc;
 	JsonRandom randomizer(cb);
@@ -53,13 +54,17 @@
 	return bc;
 }
 
-void CBankInstanceConstructor::randomizeObject(CBank * bank, CRandomGenerator & rng) const
+void CBankInstanceConstructor::randomizeObject(CBank * bank, vstd::RNG & rng) const
 {
 	bank->resetDuration = bankResetDuration;
 	bank->blockVisit = blockVisit;
 	bank->coastVisitable = coastVisitable;
 	bank->regularUnitPlacement = regularUnitPlacement;
+	bank->setConfig(generateConfiguration(bank->cb, rng, bank->ID));
+}
 
+BankConfig CBankInstanceConstructor::generateConfiguration(IGameCallback * cb, vstd::RNG & rng, MapObjectID objectID) const
+{
 	si32 totalChance = 0;
 	for(const auto & node : levels)
 		totalChance += static_cast<si32>(node["chance"].Float());
@@ -73,11 +78,10 @@
 	{
 		cumulativeChance += static_cast<int>(node["chance"].Float());
 		if(selectedChance < cumulativeChance)
-		{
-			bank->setConfig(generateConfig(bank->cb, node, rng));
-			break;
-		}
+			return generateLevelConfiguration(cb, node, rng);
 	}
+
+	throw std::runtime_error("Failed to select bank configuration");
 }
 
 CBankInfo::CBankInfo(const JsonVector & Config) :
@@ -132,7 +136,7 @@
 {
 	JsonRandom::Variables emptyVariables;
 	JsonRandom randomizer(cb);
-	std::vector<PossibleReward<CStackBasicDescriptor>> aproximateReward;
+	std::vector<PossibleReward<CStackBasicDescriptor>> approximateReward;
 
 	for(const JsonNode & configEntry : config)
 	{
@@ -143,11 +147,11 @@
 		{
 			const auto * creature = stack.allowedCreatures.front();
 
-			aproximateReward.emplace_back(configEntry["chance"].Integer(), CStackBasicDescriptor(creature, (stack.minAmount + stack.maxAmount) / 2));
+			approximateReward.emplace_back(configEntry["chance"].Integer(), CStackBasicDescriptor(creature, (stack.minAmount + stack.maxAmount) / 2));
 		}
 	}
 
-	return aproximateReward;
+	return approximateReward;
 }
 
 bool CBankInfo::givesResources() const
diff --color -urN vcmi-1.5.7/lib/mapObjectConstructors/CBankInstanceConstructor.h vcmi/lib/mapObjectConstructors/CBankInstanceConstructor.h
--- vcmi-1.5.7/lib/mapObjectConstructors/CBankInstanceConstructor.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapObjectConstructors/CBankInstanceConstructor.h	2024-12-19 15:00:22.908148351 +0100
@@ -16,10 +16,11 @@
 #include "../ResourceSet.h"
 #include "../json/JsonNode.h"
 #include "../mapObjects/CBank.h"
+#include "../serializer/Serializeable.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
-struct BankConfig
+struct BankConfig : public Serializeable
 {
 	ui32 chance = 0; //chance for this level being chosen
 	std::vector<CStackBasicDescriptor> guards; //creature ID, amount
@@ -68,7 +69,7 @@
 
 class CBankInstanceConstructor : public CDefaultObjectTypeHandler<CBank>
 {
-	BankConfig generateConfig(IGameCallback * cb, const JsonNode & conf, CRandomGenerator & rng) const;
+	BankConfig generateLevelConfiguration(IGameCallback * cb, const JsonNode & conf, vstd::RNG & rng) const;
 
 	JsonVector levels;
 
@@ -86,11 +87,13 @@
 
 public:
 
-	void randomizeObject(CBank * object, CRandomGenerator & rng) const override;
+	void randomizeObject(CBank * object, vstd::RNG & rng) const override;
 
 	bool hasNameTextID() const override;
 
 	std::unique_ptr<IObjectInfo> getObjectInfo(std::shared_ptr<const ObjectTemplate> tmpl) const override;
+
+	BankConfig generateConfiguration(IGameCallback * cb, vstd::RNG & rand, MapObjectID objectID) const;
 };
 
 VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/mapObjectConstructors/CDefaultObjectTypeHandler.h vcmi/lib/mapObjectConstructors/CDefaultObjectTypeHandler.h
--- vcmi-1.5.7/lib/mapObjectConstructors/CDefaultObjectTypeHandler.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapObjectConstructors/CDefaultObjectTypeHandler.h	2024-12-19 15:00:22.908148351 +0100
@@ -17,7 +17,7 @@
 template<class ObjectType>
 class CDefaultObjectTypeHandler : public AObjectTypeHandler
 {
-	void configureObject(CGObjectInstance * object, CRandomGenerator & rng) const final
+	void configureObject(CGObjectInstance * object, vstd::RNG & rng) const final
 	{
 		ObjectType * castedObject = dynamic_cast<ObjectType*>(object);
 
@@ -43,7 +43,7 @@
 
 protected:
 	virtual void initializeObject(ObjectType * object) const {}
-	virtual void randomizeObject(ObjectType * object, CRandomGenerator & rng) const {}
+	virtual void randomizeObject(ObjectType * object, vstd::RNG & rng) const {}
 	virtual ObjectType * createObject(IGameCallback * cb) const
 	{
 		return new ObjectType(cb);
diff --color -urN vcmi-1.5.7/lib/mapObjectConstructors/CObjectClassesHandler.cpp vcmi/lib/mapObjectConstructors/CObjectClassesHandler.cpp
--- vcmi-1.5.7/lib/mapObjectConstructors/CObjectClassesHandler.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapObjectConstructors/CObjectClassesHandler.cpp	2024-12-19 15:00:22.908148351 +0100
@@ -16,28 +16,35 @@
 #include "../VCMI_Lib.h"
 #include "../GameConstants.h"
 #include "../constants/StringConstants.h"
-#include "../CGeneralTextHandler.h"
-#include "../GameSettings.h"
+#include "../IGameSettings.h"
 #include "../CSoundBase.h"
 
 #include "../mapObjectConstructors/CBankInstanceConstructor.h"
 #include "../mapObjectConstructors/CRewardableConstructor.h"
 #include "../mapObjectConstructors/CommonConstructors.h"
 #include "../mapObjectConstructors/DwellingInstanceConstructor.h"
+#include "../mapObjectConstructors/FlaggableInstanceConstructor.h"
 #include "../mapObjectConstructors/HillFortInstanceConstructor.h"
 #include "../mapObjectConstructors/ShipyardInstanceConstructor.h"
+
 #include "../mapObjects/CGCreature.h"
+#include "../mapObjects/CGHeroInstance.h"
+#include "../mapObjects/CGMarket.h"
 #include "../mapObjects/CGPandoraBox.h"
+#include "../mapObjects/CGTownInstance.h"
 #include "../mapObjects/CQuest.h"
-#include "../mapObjects/ObjectTemplate.h"
-#include "../mapObjects/CGMarket.h"
+#include "../mapObjects/FlaggableMapObject.h"
 #include "../mapObjects/MiscObjects.h"
-#include "../mapObjects/CGHeroInstance.h"
-#include "../mapObjects/CGTownInstance.h"
+#include "../mapObjects/ObjectTemplate.h"
 #include "../mapObjects/ObstacleSetHandler.h"
+
 #include "../modding/IdentifierStorage.h"
 #include "../modding/CModHandler.h"
 #include "../modding/ModScope.h"
+#include "../texts/CGeneralTextHandler.h"
+#include "../texts/CLegacyConfigParser.h"
+
+#include <vstd/StringUtils.h>
 
 VCMI_LIB_NAMESPACE_BEGIN
 
@@ -54,6 +61,7 @@
 	SET_HANDLER_CLASS("town", CTownInstanceConstructor);
 	SET_HANDLER_CLASS("bank", CBankInstanceConstructor);
 	SET_HANDLER_CLASS("boat", BoatInstanceConstructor);
+	SET_HANDLER_CLASS("flaggable", FlaggableInstanceConstructor);
 	SET_HANDLER_CLASS("market", MarketInstanceConstructor);
 	SET_HANDLER_CLASS("hillFort", HillFortInstanceConstructor);
 	SET_HANDLER_CLASS("shipyard", ShipyardInstanceConstructor);
@@ -79,7 +87,6 @@
 	SET_HANDLER("garrison", CGGarrison);
 	SET_HANDLER("heroPlaceholder", CGHeroPlaceholder);
 	SET_HANDLER("keymaster", CGKeymasterTent);
-	SET_HANDLER("lighthouse", CGLighthouse);
 	SET_HANDLER("magi", CGMagi);
 	SET_HANDLER("mine", CGMine);
 	SET_HANDLER("obelisk", CGObelisk);
@@ -102,7 +109,7 @@
 
 std::vector<JsonNode> CObjectClassesHandler::loadLegacyData()
 {
-	size_t dataSize = VLC->settings()->getInteger(EGameSettings::TEXTS_OBJECT);
+	size_t dataSize = VLC->engineSettings()->getInteger(EGameSettings::TEXTS_OBJECT);
 
 	CLegacyConfigParser parser(TextPath::builtin("Data/Objects.txt"));
 	auto totalNumber = static_cast<size_t>(parser.readNumber()); // first line contains number of objects to read and nothing else
@@ -119,7 +126,7 @@
 		legacyTemplates.insert(std::make_pair(key, tmpl));
 	}
 
-	objects.resize(256);
+	mapObjectTypes.resize(256);
 
 	std::vector<JsonNode> ret(dataSize);// create storage for 256 objects
 	assert(dataSize == 256);
@@ -161,39 +168,39 @@
 	return ret;
 }
 
-void CObjectClassesHandler::loadSubObject(const std::string & scope, const std::string & identifier, const JsonNode & entry, ObjectClass * obj)
+void CObjectClassesHandler::loadSubObject(const std::string & scope, const std::string & identifier, const JsonNode & entry, ObjectClass * baseObject)
 {
-	auto object = loadSubObjectFromJson(scope, identifier, entry, obj, obj->objects.size());
+	auto subObject = loadSubObjectFromJson(scope, identifier, entry, baseObject, baseObject->objectTypeHandlers.size());
 
-	assert(object);
-	obj->objects.push_back(object);
+	assert(subObject);
+	baseObject->objectTypeHandlers.push_back(subObject);
 
-	registerObject(scope, obj->getJsonKey(), object->getSubTypeName(), object->subtype);
+	registerObject(scope, baseObject->getJsonKey(), subObject->getSubTypeName(), subObject->subtype);
 	for(const auto & compatID : entry["compatibilityIdentifiers"].Vector())
-		registerObject(scope, obj->getJsonKey(), compatID.String(), object->subtype);
+		registerObject(scope, baseObject->getJsonKey(), compatID.String(), subObject->subtype);
 }
 
-void CObjectClassesHandler::loadSubObject(const std::string & scope, const std::string & identifier, const JsonNode & entry, ObjectClass * obj, size_t index)
+void CObjectClassesHandler::loadSubObject(const std::string & scope, const std::string & identifier, const JsonNode & entry, ObjectClass * baseObject, size_t index)
 {
-	auto object = loadSubObjectFromJson(scope, identifier, entry, obj, index);
+	auto subObject = loadSubObjectFromJson(scope, identifier, entry, baseObject, index);
 
-	assert(object);
-	if (obj->objects.at(index) != nullptr)
+	assert(subObject);
+	if (baseObject->objectTypeHandlers.at(index) != nullptr)
 		throw std::runtime_error("Attempt to load already loaded object:" + identifier);
 
-	obj->objects.at(index) = object;
+	baseObject->objectTypeHandlers.at(index) = subObject;
 
-	registerObject(scope, obj->getJsonKey(), object->getSubTypeName(), object->subtype);
+	registerObject(scope, baseObject->getJsonKey(), subObject->getSubTypeName(), subObject->subtype);
 	for(const auto & compatID : entry["compatibilityIdentifiers"].Vector())
-		registerObject(scope, obj->getJsonKey(), compatID.String(), object->subtype);
+		registerObject(scope, baseObject->getJsonKey(), compatID.String(), subObject->subtype);
 }
 
-TObjectTypeHandler CObjectClassesHandler::loadSubObjectFromJson(const std::string & scope, const std::string & identifier, const JsonNode & entry, ObjectClass * obj, size_t index)
+TObjectTypeHandler CObjectClassesHandler::loadSubObjectFromJson(const std::string & scope, const std::string & identifier, const JsonNode & entry, ObjectClass * baseObject, size_t index)
 {
 	assert(identifier.find(':') == std::string::npos);
 	assert(!scope.empty());
 
-	std::string handler = obj->handlerName;
+	std::string handler = baseObject->handlerName;
 	if(!handlerConstructors.count(handler))
 	{
 		logMod->error("Handler with name %s was not found!", handler);
@@ -202,13 +209,23 @@
 		assert(handlerConstructors.count(handler) != 0);
 	}
 
+	// Compatibility with 1.5 mods for 1.6. To be removed in 1.7
+	// Detect banks that use old format and load them using old bank hander
+	if (baseObject->id == Obj::CREATURE_BANK)
+	{
+		if (entry.Struct().count("levels") && !entry.Struct().count("rewards"))
+			handler = "bank";
+		else
+			handler = "configurable";
+	}
+
 	auto createdObject = handlerConstructors.at(handler)();
 
 	createdObject->modScope = scope;
-	createdObject->typeName = obj->identifier;
+	createdObject->typeName = baseObject->identifier;
 	createdObject->subTypeName = identifier;
 
-	createdObject->type = obj->id;
+	createdObject->type = baseObject->id;
 	createdObject->subtype = index;
 	createdObject->init(entry);
 
@@ -222,7 +239,7 @@
 		}
 	}
 
-	auto range = legacyTemplates.equal_range(std::make_pair(obj->id, index));
+	auto range = legacyTemplates.equal_range(std::make_pair(baseObject->id, index));
 	for (auto & templ : boost::make_iterator_range(range.first, range.second))
 	{
 		if (staticObject)
@@ -237,7 +254,7 @@
 	}
 	legacyTemplates.erase(range.first, range.second);
 
-	logGlobal->debug("Loaded object %s(%d)::%s(%d)", obj->getJsonKey(), obj->id, identifier, index);
+	logGlobal->debug("Loaded object %s(%d)::%s(%d)", baseObject->getJsonKey(), baseObject->id, identifier, index);
 
 	return createdObject;
 }
@@ -262,17 +279,17 @@
 
 std::unique_ptr<ObjectClass> CObjectClassesHandler::loadFromJson(const std::string & scope, const JsonNode & json, const std::string & name, size_t index)
 {
-	auto obj = std::make_unique<ObjectClass>();
+	auto newObject = std::make_unique<ObjectClass>();
 
-	obj->modScope = scope;
-	obj->identifier = name;
-	obj->handlerName = json["handler"].String();
-	obj->base = json["base"];
-	obj->id = index;
+	newObject->modScope = scope;
+	newObject->identifier = name;
+	newObject->handlerName = json["handler"].String();
+	newObject->base = json["base"];
+	newObject->id = index;
 
-	VLC->generaltexth->registerString(scope, obj->getNameTextID(), json["name"].String());
+	VLC->generaltexth->registerString(scope, newObject->getNameTextID(), json["name"]);
 
-	obj->objects.resize(json["lastReservedIndex"].Float() + 1);
+	newObject->objectTypeHandlers.resize(json["lastReservedIndex"].Float() + 1);
 
 	for (auto subData : json["types"].Struct())
 	{
@@ -283,68 +300,71 @@
 			if ( subMeta == "core")
 			{
 				size_t subIndex = subData.second["index"].Integer();
-				loadSubObject(subData.second.getModScope(), subData.first, subData.second, obj.get(), subIndex);
+				loadSubObject(subData.second.getModScope(), subData.first, subData.second, newObject.get(), subIndex);
 			}
 			else
 			{
 				logMod->error("Object %s:%s.%s - attempt to load object with preset index! This option is reserved for built-in mod", subMeta, name, subData.first );
-				loadSubObject(subData.second.getModScope(), subData.first, subData.second, obj.get());
+				loadSubObject(subData.second.getModScope(), subData.first, subData.second, newObject.get());
 			}
 		}
 		else
-			loadSubObject(subData.second.getModScope(), subData.first, subData.second, obj.get());
+			loadSubObject(subData.second.getModScope(), subData.first, subData.second, newObject.get());
 	}
 
-	if (obj->id == MapObjectID::MONOLITH_TWO_WAY)
-		generateExtraMonolithsForRMG(obj.get());
+	if (newObject->id == MapObjectID::MONOLITH_TWO_WAY)
+		generateExtraMonolithsForRMG(newObject.get());
 
-	return obj;
+	return newObject;
 }
 
 void CObjectClassesHandler::loadObject(std::string scope, std::string name, const JsonNode & data)
 {
-	objects.push_back(loadFromJson(scope, data, name, objects.size()));
+	mapObjectTypes.push_back(loadFromJson(scope, data, name, mapObjectTypes.size()));
 
-	VLC->identifiersHandler->registerObject(scope, "object", name, objects.back()->id);
+	VLC->identifiersHandler->registerObject(scope, "object", name, mapObjectTypes.back()->id);
 }
 
 void CObjectClassesHandler::loadObject(std::string scope, std::string name, const JsonNode & data, size_t index)
 {
-	assert(objects.at(index) == nullptr); // ensure that this id was not loaded before
+	assert(mapObjectTypes.at(index) == nullptr); // ensure that this id was not loaded before
 
-	objects.at(index) = loadFromJson(scope, data, name, index);
-	VLC->identifiersHandler->registerObject(scope, "object", name, objects.at(index)->id);
+	mapObjectTypes.at(index) = loadFromJson(scope, data, name, index);
+	VLC->identifiersHandler->registerObject(scope, "object", name, mapObjectTypes.at(index)->id);
 }
 
 void CObjectClassesHandler::loadSubObject(const std::string & identifier, JsonNode config, MapObjectID ID, MapObjectSubID subID)
 {
 	config.setType(JsonNode::JsonType::DATA_STRUCT); // ensure that input is not NULL
-	assert(objects.at(ID.getNum()));
 
-	if ( subID.getNum() >= objects.at(ID.getNum())->objects.size())
-		objects.at(ID.getNum())->objects.resize(subID.getNum()+1);
+	assert(mapObjectTypes.at(ID.getNum()));
+
+	if (subID.getNum() >= mapObjectTypes.at(ID.getNum())->objectTypeHandlers.size())
+	{
+		mapObjectTypes.at(ID.getNum())->objectTypeHandlers.resize(subID.getNum() + 1);
+	}
 
-	JsonUtils::inherit(config, objects.at(ID.getNum())->base);
-	loadSubObject(config.getModScope(), identifier, config, objects.at(ID.getNum()).get(), subID.getNum());
+	JsonUtils::inherit(config, mapObjectTypes.at(ID.getNum())->base);
+	loadSubObject(config.getModScope(), identifier, config, mapObjectTypes.at(ID.getNum()).get(), subID.getNum());
 }
 
 void CObjectClassesHandler::removeSubObject(MapObjectID ID, MapObjectSubID subID)
 {
-	assert(objects.at(ID.getNum()));
-	objects.at(ID.getNum())->objects.at(subID.getNum()) = nullptr;
+	assert(mapObjectTypes.at(ID.getNum()));
+	mapObjectTypes.at(ID.getNum())->objectTypeHandlers.at(subID.getNum()) = nullptr;
 }
 
 TObjectTypeHandler CObjectClassesHandler::getHandlerFor(MapObjectID type, MapObjectSubID subtype) const
 {
 	try
 	{
-		if (objects.at(type.getNum()) == nullptr)
-			return objects.front()->objects.front();
+		if (mapObjectTypes.at(type.getNum()) == nullptr)
+			return mapObjectTypes.front()->objectTypeHandlers.front();
 
 		auto subID = subtype.getNum();
-		if (type == Obj::PRISON)
+		if (type == Obj::PRISON || type == Obj::HERO_PLACEHOLDER || type == Obj::SPELL_SCROLL)
 			subID = 0;
-		auto result = objects.at(type.getNum())->objects.at(subID);
+		auto result = mapObjectTypes.at(type.getNum())->objectTypeHandlers.at(subID);
 
 		if (result != nullptr)
 			return result;
@@ -364,11 +384,11 @@
 	std::optional<si32> id = VLC->identifiers()->getIdentifier(scope, "object", type);
 	if(id)
 	{
-		const auto & object = objects.at(id.value());
+		const auto & object = mapObjectTypes.at(id.value());
 		std::optional<si32> subID = VLC->identifiers()->getIdentifier(scope, object->getJsonKey(), subtype);
 
 		if (subID)
-			return object->objects.at(subID.value());
+			return object->objectTypeHandlers.at(subID.value());
 	}
 
 	std::string errorString = "Failed to find object of type " + type + "::" + subtype;
@@ -381,11 +401,67 @@
 	return getHandlerFor(compoundIdentifier.primaryID, compoundIdentifier.secondaryID);
 }
 
+CompoundMapObjectID CObjectClassesHandler::getCompoundIdentifier(const std::string & scope, const std::string & type, const std::string & subtype) const
+{
+	std::optional<si32> id;
+	if (scope.empty())
+	{
+		id = VLC->identifiers()->getIdentifier("object", type);
+	}
+	else
+	{
+		id = VLC->identifiers()->getIdentifier(scope, "object", type);
+	}
+
+	if(id)
+	{
+		if (subtype.empty())
+			return CompoundMapObjectID(id.value(), 0);
+
+		const auto & object = mapObjectTypes.at(id.value());
+		std::optional<si32> subID = VLC->identifiers()->getIdentifier(scope, object->getJsonKey(), subtype);
+
+		if (subID)
+			return CompoundMapObjectID(id.value(), subID.value());
+	}
+
+	std::string errorString = "Failed to get id for object of type " + type + "." + subtype;
+	logGlobal->error(errorString);
+	throw std::runtime_error(errorString);
+}
+
+CompoundMapObjectID CObjectClassesHandler::getCompoundIdentifier(const std::string & objectName) const
+{
+	std::string subtype = "object"; //Default for objects with no subIds
+	std::string type;
+
+	auto scopeAndFullName = vstd::splitStringToPair(objectName, ':');
+	logGlobal->debug("scopeAndFullName: %s, %s", scopeAndFullName.first, scopeAndFullName.second);
+	
+	auto typeAndName = vstd::splitStringToPair(scopeAndFullName.second, '.');
+	logGlobal->debug("typeAndName: %s, %s", typeAndName.first, typeAndName.second);
+	
+	auto nameAndSubtype = vstd::splitStringToPair(typeAndName.second, '.');
+	logGlobal->debug("nameAndSubtype: %s, %s", nameAndSubtype.first, nameAndSubtype.second);
+
+	if (!nameAndSubtype.first.empty())
+	{
+		type = nameAndSubtype.first;
+		subtype = nameAndSubtype.second;
+	}
+	else
+	{
+		type = typeAndName.second;
+	}
+	
+	return getCompoundIdentifier(boost::to_lower_copy(scopeAndFullName.first), type, subtype);
+}
+
 std::set<MapObjectID> CObjectClassesHandler::knownObjects() const
 {
 	std::set<MapObjectID> ret;
 
-	for(auto & entry : objects)
+	for(auto & entry : mapObjectTypes)
 		if (entry)
 			ret.insert(entry->id);
 
@@ -396,13 +472,13 @@
 {
 	std::set<MapObjectSubID> ret;
 
-	if (!objects.at(primaryID.getNum()))
+	if (!mapObjectTypes.at(primaryID.getNum()))
 	{
 		logGlobal->error("Failed to find object %d", primaryID);
 		return ret;
 	}
 
-	for(const auto & entry : objects.at(primaryID.getNum())->objects)
+	for(const auto & entry : mapObjectTypes.at(primaryID.getNum())->objectTypeHandlers)
 		if (entry)
 			ret.insert(entry->subtype);
 
@@ -435,27 +511,39 @@
 
 void CObjectClassesHandler::afterLoadFinalization()
 {
-	for(auto & entry : objects)
+	for(auto & entry : mapObjectTypes)
 	{
 		if (!entry)
 			continue;
 
-		for(const auto & obj : entry->objects)
+		for(const auto & obj : entry->objectTypeHandlers)
 		{
 			if (!obj)
 				continue;
 
 			obj->afterLoadFinalization();
 			if(obj->getTemplates().empty())
-				logGlobal->warn("No templates found for %s:%s", entry->getJsonKey(), obj->getJsonKey());
+				logMod->debug("No templates found for %s:%s", entry->getJsonKey(), obj->getJsonKey());
 		}
 	}
+
+	for(auto & entry : objectIdHandlers)
+	{
+		// Call function for each object id
+		entry.second(entry.first);
+	}
+}
+
+void CObjectClassesHandler::resolveObjectCompoundId(const std::string & id, std::function<void(CompoundMapObjectID)> callback)
+{
+	auto compoundId = getCompoundIdentifier(id);
+	objectIdHandlers.push_back(std::make_pair(compoundId, callback));
 }
 
 void CObjectClassesHandler::generateExtraMonolithsForRMG(ObjectClass * container)
 {
 	//duplicate existing two-way portals to make reserve for RMG
-	auto& portalVec = container->objects;
+	auto& portalVec = container->objectTypeHandlers;
 	//FIXME: Monoliths  in this vector can be already not useful for every terrain
 	const size_t portalCount = portalVec.size();
 
@@ -499,10 +587,10 @@
 	if (handler && handler->hasNameTextID())
 		return handler->getNameTranslated();
 
-	if (objects.at(type.getNum()))
-		return objects.at(type.getNum())->getNameTranslated();
+	if (mapObjectTypes.at(type.getNum()))
+		return mapObjectTypes.at(type.getNum())->getNameTranslated();
 
-	return objects.front()->getNameTranslated();
+	return mapObjectTypes.front()->getNameTranslated();
 }
 
 SObjectSounds CObjectClassesHandler::getObjectSounds(MapObjectID type, MapObjectSubID subtype) const
@@ -514,27 +602,27 @@
 	if(type == Obj::PRISON || type == Obj::HERO || type == Obj::SPELL_SCROLL)
 		subtype = 0;
 
-	if(objects.at(type.getNum()))
+	if(mapObjectTypes.at(type.getNum()))
 		return getHandlerFor(type, subtype)->getSounds();
 	else
-		return objects.front()->objects.front()->getSounds();
+		return mapObjectTypes.front()->objectTypeHandlers.front()->getSounds();
 }
 
 std::string CObjectClassesHandler::getObjectHandlerName(MapObjectID type) const
 {
-	if (objects.at(type.getNum()))
-		return objects.at(type.getNum())->handlerName;
+	if (mapObjectTypes.at(type.getNum()))
+		return mapObjectTypes.at(type.getNum())->handlerName;
 	else
-		return objects.front()->handlerName;
+		return mapObjectTypes.front()->handlerName;
 }
 
 std::string CObjectClassesHandler::getJsonKey(MapObjectID type) const
 {
-	if (objects.at(type.getNum()) != nullptr)
-		return objects.at(type.getNum())->getJsonKey();
+	if (mapObjectTypes.at(type.getNum()) != nullptr)
+		return mapObjectTypes.at(type.getNum())->getJsonKey();
 
 	logGlobal->warn("Unknown object of type %d!", type);
-	return objects.front()->getJsonKey();
+	return mapObjectTypes.front()->getJsonKey();
 }
 
 VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/mapObjectConstructors/CObjectClassesHandler.h vcmi/lib/mapObjectConstructors/CObjectClassesHandler.h
--- vcmi-1.5.7/lib/mapObjectConstructors/CObjectClassesHandler.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapObjectConstructors/CObjectClassesHandler.h	2024-12-19 15:00:22.908148351 +0100
@@ -9,38 +9,16 @@
  */
 #pragma once
 
-#include "../constants/EntityIdentifiers.h"
+#include "../mapObjects/CompoundMapObjectID.h"
 #include "../IHandlerBase.h"
 #include "../json/JsonNode.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
-class CRandomGenerator;
 class AObjectTypeHandler;
 class ObjectTemplate;
 struct SObjectSounds;
 
-struct DLL_LINKAGE CompoundMapObjectID
-{
-	si32 primaryID;
-	si32 secondaryID;
-
-	CompoundMapObjectID(si32 primID, si32 secID) : primaryID(primID), secondaryID(secID) {};
-
-	bool operator<(const CompoundMapObjectID& other) const
-	{
-		if(this->primaryID != other.primaryID)
-			return this->primaryID < other.primaryID;
-		else
-			return this->secondaryID < other.secondaryID;
-	}
-
-	bool operator==(const CompoundMapObjectID& other) const
-	{
-		return (this->primaryID == other.primaryID) && (this->secondaryID == other.secondaryID);
-	}
-};
-
 class CGObjectInstance;
 
 using TObjectTypeHandler = std::shared_ptr<AObjectTypeHandler>;
@@ -56,7 +34,7 @@
 	std::string handlerName; // ID of handler that controls this object, should be determined using handlerConstructor map
 
 	JsonNode base;
-	std::vector<TObjectTypeHandler> objects;
+	std::vector<TObjectTypeHandler> objectTypeHandlers;
 
 	ObjectClass();
 	~ObjectClass();
@@ -70,11 +48,13 @@
 class DLL_LINKAGE CObjectClassesHandler : public IHandlerBase, boost::noncopyable
 {
 	/// list of object handlers, each of them handles only one type
-	std::vector< std::unique_ptr<ObjectClass> > objects;
+	std::vector< std::unique_ptr<ObjectClass> > mapObjectTypes;
 
-	/// map that is filled during contruction with all known handlers. Not serializeable due to usage of std::function
+	/// map that is filled during construction with all known handlers. Not serializeable due to usage of std::function
 	std::map<std::string, std::function<TObjectTypeHandler()> > handlerConstructors;
 
+	std::vector<std::pair<CompoundMapObjectID, std::function<void(CompoundMapObjectID)>>> objectIdHandlers;
+
 	/// container with H3 templates, used only during loading, no need to serialize it
 	using TTemplatesContainer = std::multimap<std::pair<MapObjectID, MapObjectSubID>, std::shared_ptr<const ObjectTemplate>>;
 	TTemplatesContainer legacyTemplates;
@@ -111,15 +91,19 @@
 	TObjectTypeHandler getHandlerFor(MapObjectID type, MapObjectSubID subtype) const;
 	TObjectTypeHandler getHandlerFor(const std::string & scope, const std::string & type, const std::string & subtype) const;
 	TObjectTypeHandler getHandlerFor(CompoundMapObjectID compoundIdentifier) const;
+	CompoundMapObjectID getCompoundIdentifier(const std::string & scope, const std::string & type, const std::string & subtype) const;
+	CompoundMapObjectID getCompoundIdentifier(const std::string & objectName) const;
 
 	std::string getObjectName(MapObjectID type, MapObjectSubID subtype) const;
 
 	SObjectSounds getObjectSounds(MapObjectID type, MapObjectSubID subtype) const;
 
+	void resolveObjectCompoundId(const std::string & id, std::function<void(CompoundMapObjectID)> callback);
+
 	/// Returns handler string describing the handler (for use in client)
 	std::string getObjectHandlerName(MapObjectID type) const;
 
 	std::string getJsonKey(MapObjectID type) const;
 };
 
-VCMI_LIB_NAMESPACE_END
+VCMI_LIB_NAMESPACE_END
\ No newline at end of file
diff --color -urN vcmi-1.5.7/lib/mapObjectConstructors/CommonConstructors.cpp vcmi/lib/mapObjectConstructors/CommonConstructors.cpp
--- vcmi-1.5.7/lib/mapObjectConstructors/CommonConstructors.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapObjectConstructors/CommonConstructors.cpp	2024-12-19 15:00:22.909148392 +0100
@@ -10,15 +10,17 @@
 #include "StdInc.h"
 #include "CommonConstructors.h"
 
-#include "../CGeneralTextHandler.h"
-#include "../CHeroHandler.h"
-#include "../CTownHandler.h"
+#include "../texts/CGeneralTextHandler.h"
 #include "../IGameCallback.h"
 #include "../json/JsonRandom.h"
 #include "../constants/StringConstants.h"
 #include "../TerrainHandler.h"
 #include "../VCMI_Lib.h"
 
+#include "../CConfigHandler.h"
+#include "../entities/faction/CTownHandler.h"
+#include "../entities/hero/CHeroClass.h"
+#include "../json/JsonUtils.h"
 #include "../mapObjects/CGHeroInstance.h"
 #include "../mapObjects/CGMarket.h"
 #include "../mapObjects/CGTownInstance.h"
@@ -96,13 +98,12 @@
 
 void CTownInstanceConstructor::initializeObject(CGTownInstance * obj) const
 {
-	obj->town = faction->town;
 	obj->tempOwner = PlayerColor::NEUTRAL;
 }
 
-void CTownInstanceConstructor::randomizeObject(CGTownInstance * object, CRandomGenerator & rng) const
+void CTownInstanceConstructor::randomizeObject(CGTownInstance * object, vstd::RNG & rng) const
 {
-	auto templ = getOverride(object->cb->getTile(object->pos)->terType->getId(), object);
+	auto templ = getOverride(object->cb->getTile(object->pos)->getTerrainID(), object);
 	if(templ)
 		object->appearance = templ;
 }
@@ -124,42 +125,74 @@
 		input["heroClass"],
 		[&](si32 index) { heroClass = HeroClassID(index).toHeroClass(); });
 
-	filtersJson = input["filters"];
-}
-
-void CHeroInstanceConstructor::afterLoadFinalization()
-{
-	for(const auto & entry : filtersJson.Struct())
+	for (const auto & [name, config] : input["filters"].Struct())
 	{
-		filters[entry.first] = LogicalExpression<HeroTypeID>(entry.second, [](const JsonNode & node)
+		HeroFilter filter;
+		filter.allowFemale =  config["female"].Bool();
+		filter.allowMale =  config["male"].Bool();
+		filters[name] = filter;
+
+		if (!config["hero"].isNull())
 		{
-			return HeroTypeID(VLC->identifiers()->getIdentifier("hero", node.Vector()[0]).value_or(-1));
-		});
+			VLC->identifiers()->requestIdentifier( "hero", config["hero"], [this, templateName = name](si32 index) {
+				filters.at(templateName).fixedHero = HeroTypeID(index);
+			});
+		}
 	}
 }
 
-bool CHeroInstanceConstructor::objectFilter(const CGObjectInstance * object, std::shared_ptr<const ObjectTemplate> templ) const
+std::shared_ptr<const ObjectTemplate> CHeroInstanceConstructor::getOverride(TerrainId terrainType, const CGObjectInstance * object) const
 {
 	const auto * hero = dynamic_cast<const CGHeroInstance *>(object);
 
-	auto heroTest = [&](const HeroTypeID & id)
-	{
-		return hero->type->getId() == id;
-	};
+	std::vector<std::shared_ptr<const ObjectTemplate>> allTemplates = getTemplates();
+	std::shared_ptr<const ObjectTemplate> candidateFullMatch;
+	std::shared_ptr<const ObjectTemplate> candidateGenderMatch;
+	std::shared_ptr<const ObjectTemplate> candidateBase;
+
+	assert(hero->gender != EHeroGender::DEFAULT);
 
-	if(filters.count(templ->stringID))
+	for (const auto & templ : allTemplates)
 	{
-		return filters.at(templ->stringID).test(heroTest);
+		if (filters.count(templ->stringID))
+		{
+			const auto & filter = filters.at(templ->stringID);
+			if (filter.fixedHero.hasValue())
+			{
+				if (filter.fixedHero == hero->getHeroTypeID())
+					candidateFullMatch = templ;
+			}
+			else if (filter.allowMale)
+			{
+				if (hero->gender == EHeroGender::MALE)
+					candidateGenderMatch = templ;
+			}
+			else if (filter.allowFemale)
+			{
+				if (hero->gender == EHeroGender::FEMALE)
+					candidateGenderMatch = templ;
+			}
+			else
+			{
+				candidateBase = templ;
+			}
+		}
+		else
+		{
+			candidateBase = templ;
+		}
 	}
-	return false;
-}
 
-void CHeroInstanceConstructor::initializeObject(CGHeroInstance * obj) const
-{
-	obj->type = nullptr; //FIXME: set to valid value. somehow.
+	if (candidateFullMatch)
+		return candidateFullMatch;
+
+	if (candidateGenderMatch)
+		return candidateGenderMatch;
+
+	return candidateBase;
 }
 
-void CHeroInstanceConstructor::randomizeObject(CGHeroInstance * object, CRandomGenerator & rng) const
+void CHeroInstanceConstructor::randomizeObject(CGHeroInstance * object, vstd::RNG & rng) const
 {
 
 }
@@ -211,6 +244,30 @@
 
 void MarketInstanceConstructor::initTypeData(const JsonNode & input)
 {
+	if (settings["mods"]["validation"].String() != "off")
+		JsonUtils::validate(input, "vcmi:market", getJsonKey());
+
+	if (!input["description"].isNull())
+	{
+		std::string description = input["description"].String();
+		descriptionTextID = TextIdentifier(getBaseTextID(), "description").get();
+		VLC->generaltexth->registerString( input.getModScope(), descriptionTextID, input["description"]);
+	}
+
+	if (!input["speech"].isNull())
+	{
+		std::string speech = input["speech"].String();
+		if (!speech.empty() && speech.at(0) == '@')
+		{
+			speechTextID = speech.substr(1);
+		}
+		else
+		{
+			speechTextID = TextIdentifier(getBaseTextID(), "speech").get();
+			VLC->generaltexth->registerString( input.getModScope(), speechTextID, input["speech"]);
+		}
+	}
+
 	for(auto & element : input["modes"].Vector())
 	{
 		if(MappedKeys::MARKET_NAMES_TO_TYPES.count(element.String()))
@@ -219,9 +276,11 @@
 	
 	marketEfficiency = input["efficiency"].isNull() ? 5 : input["efficiency"].Integer();
 	predefinedOffer = input["offer"];
-	
-	title = input["title"].String();
-	speech = input["speech"].String();
+}
+
+bool MarketInstanceConstructor::hasDescription() const
+{
+	return !descriptionTextID.empty();
 }
 
 CGMarket * MarketInstanceConstructor::createObject(IGameCallback * cb) const
@@ -238,28 +297,15 @@
 				return new CGUniversity(cb);
 		}
 	}
-	else if(marketModes.size() == 2)
-	{
-		if(vstd::contains(marketModes, EMarketMode::ARTIFACT_EXP))
-			return new CGArtifactsAltar(cb);
-	}
 	return new CGMarket(cb);
 }
 
-void MarketInstanceConstructor::initializeObject(CGMarket * market) const
+const std::set<EMarketMode> & MarketInstanceConstructor::availableModes() const
 {
-	market->marketModes = marketModes;
-	market->marketEfficiency = marketEfficiency;
-	
-	market->title = market->getObjectName();
-	if(!title.empty())
-		market->title = VLC->generaltexth->translate(title);
-	
-	if (!speech.empty())
-		market->speech = VLC->generaltexth->translate(speech);
+	return marketModes;
 }
 
-void MarketInstanceConstructor::randomizeObject(CGMarket * object, CRandomGenerator & rng) const
+void MarketInstanceConstructor::randomizeObject(CGMarket * object, vstd::RNG & rng) const
 {
 	JsonRandom randomizer(object->cb);
 	JsonRandom::Variables emptyVariables;
@@ -271,4 +317,15 @@
 	}
 }
 
+std::string MarketInstanceConstructor::getSpeechTranslated() const
+{
+	assert(marketModes.count(EMarketMode::RESOURCE_SKILL));
+	return VLC->generaltexth->translate(speechTextID);
+}
+
+int MarketInstanceConstructor::getMarketEfficiency() const
+{
+	return marketEfficiency;
+}
+
 VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/mapObjectConstructors/CommonConstructors.h vcmi/lib/mapObjectConstructors/CommonConstructors.h
--- vcmi-1.5.7/lib/mapObjectConstructors/CommonConstructors.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapObjectConstructors/CommonConstructors.h	2024-12-19 15:00:22.909148392 +0100
@@ -14,6 +14,7 @@
 
 #include "../mapObjects/MiscObjects.h"
 #include "../mapObjects/CGCreature.h"
+#include "../mapObjects/CGHeroInstance.h"
 #include "../mapObjects/ObstacleSetHandler.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
@@ -25,7 +26,6 @@
 class CGMarket;
 class CHeroClass;
 class CGCreature;
-class CBank;
 class CGBoat;
 class CFaction;
 class CStackBasicDescriptor;
@@ -63,7 +63,7 @@
 	std::map<std::string, LogicalExpression<BuildingID>> filters;
 
 	void initializeObject(CGTownInstance * object) const override;
-	void randomizeObject(CGTownInstance * object, CRandomGenerator & rng) const override;
+	void randomizeObject(CGTownInstance * object, vstd::RNG & rng) const override;
 	void afterLoadFinalization() override;
 
 	bool hasNameTextID() const override;
@@ -72,18 +72,21 @@
 
 class CHeroInstanceConstructor : public CDefaultObjectTypeHandler<CGHeroInstance>
 {
-	JsonNode filtersJson;
-protected:
-	bool objectFilter(const CGObjectInstance * obj, std::shared_ptr<const ObjectTemplate> tmpl) const override;
-	void initTypeData(const JsonNode & input) override;
+	struct HeroFilter
+	{
+		HeroTypeID fixedHero;
+		bool allowMale;
+		bool allowFemale;
+	};
 
-public:
+	std::map<std::string, HeroFilter> filters;
 	const CHeroClass * heroClass = nullptr;
-	std::map<std::string, LogicalExpression<HeroTypeID>> filters;
 
-	void initializeObject(CGHeroInstance * object) const override;
-	void randomizeObject(CGHeroInstance * object, CRandomGenerator & rng) const override;
-	void afterLoadFinalization() override;
+	std::shared_ptr<const ObjectTemplate> getOverride(TerrainId terrainType, const CGObjectInstance * object) const override;
+	void initTypeData(const JsonNode & input) override;
+
+public:
+	void randomizeObject(CGHeroInstance * object, vstd::RNG & rng) const override;
 
 	bool hasNameTextID() const override;
 	std::string getNameTextID() const override;
@@ -112,21 +115,23 @@
 
 class MarketInstanceConstructor : public CDefaultObjectTypeHandler<CGMarket>
 {
-protected:
-	void initTypeData(const JsonNode & config) override;
+	std::string descriptionTextID;
+	std::string speechTextID;
 	
 	std::set<EMarketMode> marketModes;
 	JsonNode predefinedOffer;
 	int marketEfficiency;
-	
-	std::string title;
-	std::string speech;
-	
+
+	void initTypeData(const JsonNode & config) override;
 public:
 	CGMarket * createObject(IGameCallback * cb) const override;
-	void initializeObject(CGMarket * object) const override;
-	void randomizeObject(CGMarket * object, CRandomGenerator & rng) const override;
+	void randomizeObject(CGMarket * object, vstd::RNG & rng) const override;
+
+	const std::set<EMarketMode> & availableModes() const;
+	bool hasDescription() const;
 
+	std::string getSpeechTranslated() const;
+	int getMarketEfficiency() const;
 };
 
 VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/mapObjectConstructors/CRewardableConstructor.cpp vcmi/lib/mapObjectConstructors/CRewardableConstructor.cpp
--- vcmi-1.5.7/lib/mapObjectConstructors/CRewardableConstructor.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapObjectConstructors/CRewardableConstructor.cpp	2024-12-19 15:00:22.909148392 +0100
@@ -10,9 +10,11 @@
 #include "StdInc.h"
 #include "CRewardableConstructor.h"
 
+#include "../json/JsonUtils.h"
 #include "../mapObjects/CRewardableObject.h"
-#include "../CGeneralTextHandler.h"
+#include "../texts/CGeneralTextHandler.h"
 #include "../IGameCallback.h"
+#include "../CConfigHandler.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
@@ -22,7 +24,10 @@
 	blockVisit = config["blockedVisitable"].Bool();
 
 	if (!config["name"].isNull())
-		VLC->generaltexth->registerString( config.getModScope(), getNameTextID(), config["name"].String());
+		VLC->generaltexth->registerString( config.getModScope(), getNameTextID(), config["name"]);
+
+	if (settings["mods"]["validation"].String() != "off")
+		JsonUtils::validate(config, "vcmi:rewardable", getJsonKey());
 	
 }
 
@@ -40,27 +45,41 @@
 	return ret;
 }
 
-void CRewardableConstructor::configureObject(CGObjectInstance * object, CRandomGenerator & rng) const
+Rewardable::Configuration CRewardableConstructor::generateConfiguration(IGameCallback * cb, vstd::RNG & rand, MapObjectID objectID, const std::map<std::string, JsonNode> & presetVariables) const
 {
-	if(auto * rewardableObject = dynamic_cast<CRewardableObject*>(object))
+	Rewardable::Configuration result;
+	result.variables.preset = presetVariables;
+	objectInfo.configureObject(result, rand, cb);
+
+	for(auto & rewardInfo : result.info)
 	{
-		objectInfo.configureObject(rewardableObject->configuration, rng, object->cb);
-		for(auto & rewardInfo : rewardableObject->configuration.info)
-		{
-			for (auto & bonus : rewardInfo.reward.bonuses)
-			{
-				bonus.source = BonusSource::OBJECT_TYPE;
-				bonus.sid = BonusSourceID(rewardableObject->ID);
-			}
-		}
-		if (rewardableObject->configuration.info.empty())
+		for (auto & bonus : rewardInfo.reward.bonuses)
 		{
-			if (objectInfo.getParameters()["rewards"].isNull())
-				logMod->error("Object %s has invalid configuration! No defined rewards found!", getJsonKey());
-			else
-				logMod->error("Object %s has invalid configuration! Make sure that defined appear chances are continious!", getJsonKey());
+			bonus.source = BonusSource::OBJECT_TYPE;
+			bonus.sid = BonusSourceID(objectID);
 		}
 	}
+
+	return result;
+}
+
+void CRewardableConstructor::configureObject(CGObjectInstance * object, vstd::RNG & rng) const
+{
+	auto * rewardableObject = dynamic_cast<CRewardableObject*>(object);
+
+	if (!rewardableObject)
+		throw std::runtime_error("Object " + std::to_string(object->getObjGroupIndex()) + ", " + std::to_string(object->getObjTypeIndex()) + " is not a rewardable object!" );
+
+	rewardableObject->configuration = generateConfiguration(object->cb, rng, object->ID, rewardableObject->configuration.variables.preset);
+	rewardableObject->initializeGuards();
+
+	if (rewardableObject->configuration.info.empty())
+	{
+		if (objectInfo.getParameters()["rewards"].isNull())
+			logMod->error("Object %s has invalid configuration! No defined rewards found!", getJsonKey());
+		else
+			logMod->error("Object %s has invalid configuration! Make sure that defined appear chances are continuous!", getJsonKey());
+	}
 }
 
 std::unique_ptr<IObjectInfo> CRewardableConstructor::getObjectInfo(std::shared_ptr<const ObjectTemplate> tmpl) const
diff --color -urN vcmi-1.5.7/lib/mapObjectConstructors/CRewardableConstructor.h vcmi/lib/mapObjectConstructors/CRewardableConstructor.h
--- vcmi-1.5.7/lib/mapObjectConstructors/CRewardableConstructor.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapObjectConstructors/CRewardableConstructor.h	2024-12-19 15:00:22.909148392 +0100
@@ -27,9 +27,11 @@
 
 	CGObjectInstance * create(IGameCallback * cb, std::shared_ptr<const ObjectTemplate> tmpl = nullptr) const override;
 
-	void configureObject(CGObjectInstance * object, CRandomGenerator & rng) const override;
+	void configureObject(CGObjectInstance * object, vstd::RNG & rng) const override;
 
 	std::unique_ptr<IObjectInfo> getObjectInfo(std::shared_ptr<const ObjectTemplate> tmpl) const override;
+
+	Rewardable::Configuration generateConfiguration(IGameCallback * cb, vstd::RNG & rand, MapObjectID objectID, const std::map<std::string, JsonNode> & presetVariables) const;
 };
 
 VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/mapObjectConstructors/DwellingInstanceConstructor.cpp vcmi/lib/mapObjectConstructors/DwellingInstanceConstructor.cpp
--- vcmi-1.5.7/lib/mapObjectConstructors/DwellingInstanceConstructor.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapObjectConstructors/DwellingInstanceConstructor.cpp	2024-12-19 15:00:22.909148392 +0100
@@ -11,7 +11,7 @@
 #include "DwellingInstanceConstructor.h"
 
 #include "../CCreatureHandler.h"
-#include "../CGeneralTextHandler.h"
+#include "../texts/CGeneralTextHandler.h"
 #include "../json/JsonRandom.h"
 #include "../VCMI_Lib.h"
 #include "../mapObjects/CGDwelling.h"
@@ -29,7 +29,7 @@
 	if (input.Struct().count("name") == 0)
 		logMod->warn("Dwelling %s missing name!", getJsonKey());
 
-	VLC->generaltexth->registerString( input.getModScope(), getNameTextID(), input["name"].String());
+	VLC->generaltexth->registerString( input.getModScope(), getNameTextID(), input["name"]);
 
 	const JsonVector & levels = input["creatures"].Vector();
 	const auto totalLevels = levels.size();
@@ -74,7 +74,7 @@
 	}
 }
 
-void DwellingInstanceConstructor::randomizeObject(CGDwelling * dwelling, CRandomGenerator &rng) const
+void DwellingInstanceConstructor::randomizeObject(CGDwelling * dwelling, vstd::RNG &rng) const
 {
 	JsonRandom randomizer(dwelling->cb);
 
@@ -88,25 +88,28 @@
 			dwelling->creatures.back().second.push_back(cre->getId());
 	}
 
-	bool guarded = false; //TODO: serialize for sanity
+	bool guarded = false;
 
-	if(guards.getType() == JsonNode::JsonType::DATA_BOOL) //simple switch
+	if(guards.getType() == JsonNode::JsonType::DATA_BOOL)
 	{
+		//simple switch
 		if(guards.Bool())
 		{
 			guarded = true;
 		}
 	}
-	else if(guards.getType() == JsonNode::JsonType::DATA_VECTOR) //custom guards (eg. Elemental Conflux)
+	else if(guards.getType() == JsonNode::JsonType::DATA_VECTOR)
 	{
+		//custom guards (eg. Elemental Conflux)
 		JsonRandom::Variables emptyVariables;
 		for(auto & stack : randomizer.loadCreatures(guards, rng, emptyVariables))
 		{
-			dwelling->putStack(SlotID(dwelling->stacksCount()), new CStackInstance(stack.type->getId(), stack.count));
+			dwelling->putStack(SlotID(dwelling->stacksCount()), new CStackInstance(stack.getId(), stack.count));
 		}
 	}
-	else //default condition - creatures are of level 5 or higher
+	else if (dwelling->ID == Obj::CREATURE_GENERATOR1 || dwelling->ID == Obj::CREATURE_GENERATOR4)
 	{
+		//default condition - this is dwelling with creatures of level 5 or higher
 		for(auto creatureEntry : availableCreatures)
 		{
 			if(creatureEntry.at(0)->getLevel() >= 5)
diff --color -urN vcmi-1.5.7/lib/mapObjectConstructors/DwellingInstanceConstructor.h vcmi/lib/mapObjectConstructors/DwellingInstanceConstructor.h
--- vcmi-1.5.7/lib/mapObjectConstructors/DwellingInstanceConstructor.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapObjectConstructors/DwellingInstanceConstructor.h	2024-12-19 15:00:22.909148392 +0100
@@ -33,7 +33,7 @@
 	bool hasNameTextID() const override;
 
 	void initializeObject(CGDwelling * object) const override;
-	void randomizeObject(CGDwelling * object, CRandomGenerator & rng) const override;
+	void randomizeObject(CGDwelling * object, vstd::RNG & rng) const override;
 
 	bool isBannedForRandomDwelling() const;
 	bool producesCreature(const CCreature * crea) const;
diff --color -urN vcmi-1.5.7/lib/mapObjectConstructors/FlaggableInstanceConstructor.cpp vcmi/lib/mapObjectConstructors/FlaggableInstanceConstructor.cpp
--- vcmi-1.5.7/lib/mapObjectConstructors/FlaggableInstanceConstructor.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/mapObjectConstructors/FlaggableInstanceConstructor.cpp	2024-12-19 15:00:22.909148392 +0100
@@ -0,0 +1,65 @@
+/*
+* FlaggableInstanceConstructor.cpp, part of VCMI engine
+*
+* Authors: listed in file AUTHORS in main folder
+*
+* License: GNU General Public License v2.0 or later
+* Full text of license available in license.txt file, in main folder
+*
+*/
+#include "StdInc.h"
+#include "FlaggableInstanceConstructor.h"
+
+#include "../CConfigHandler.h"
+#include "../VCMI_Lib.h"
+#include "../json/JsonBonus.h"
+#include "../json/JsonUtils.h"
+#include "../texts/CGeneralTextHandler.h"
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+void FlaggableInstanceConstructor::initTypeData(const JsonNode & config)
+{
+	if (settings["mods"]["validation"].String() != "off")
+		JsonUtils::validate(config, "vcmi:flaggable", getJsonKey());
+
+	for (const auto & bonusJson : config["bonuses"].Struct())
+		providedBonuses.push_back(JsonUtils::parseBonus(bonusJson.second));
+
+	if (!config["message"].isNull())
+	{
+		std::string message = config["message"].String();
+		if (!message.empty() && message.at(0) == '@')
+		{
+			visitMessageTextID = message.substr(1);
+		}
+		else
+		{
+			visitMessageTextID = TextIdentifier(getBaseTextID(), "onVisit").get();
+			VLC->generaltexth->registerString( config.getModScope(), visitMessageTextID, config["message"]);
+		}
+	}
+
+	dailyIncome = ResourceSet(config["dailyIncome"]);
+}
+
+void FlaggableInstanceConstructor::initializeObject(FlaggableMapObject * flaggable) const
+{
+}
+
+const std::string & FlaggableInstanceConstructor::getVisitMessageTextID() const
+{
+	return visitMessageTextID;
+}
+
+const std::vector<std::shared_ptr<Bonus>> & FlaggableInstanceConstructor::getProvidedBonuses() const
+{
+	return providedBonuses;
+}
+
+const ResourceSet & FlaggableInstanceConstructor::getDailyIncome() const
+{
+	return dailyIncome;
+}
+
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/mapObjectConstructors/FlaggableInstanceConstructor.h vcmi/lib/mapObjectConstructors/FlaggableInstanceConstructor.h
--- vcmi-1.5.7/lib/mapObjectConstructors/FlaggableInstanceConstructor.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/mapObjectConstructors/FlaggableInstanceConstructor.h	2024-12-19 15:00:22.909148392 +0100
@@ -0,0 +1,41 @@
+/*
+* FlaggableInstanceConstructor.h, part of VCMI engine
+*
+* Authors: listed in file AUTHORS in main folder
+*
+* License: GNU General Public License v2.0 or later
+* Full text of license available in license.txt file, in main folder
+*
+*/
+#pragma once
+
+#include "CDefaultObjectTypeHandler.h"
+
+#include "../ResourceSet.h"
+#include "../bonuses/Bonus.h"
+#include "../mapObjects/FlaggableMapObject.h"
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+class FlaggableInstanceConstructor final : public CDefaultObjectTypeHandler<FlaggableMapObject>
+{
+	/// List of bonuses that are provided by every map object of this type
+	std::vector<std::shared_ptr<Bonus>> providedBonuses;
+
+	/// ID of message to show on hero visit
+	std::string visitMessageTextID;
+
+	/// Amount of resources granted by this object to owner every day
+	ResourceSet dailyIncome;
+
+protected:
+	void initTypeData(const JsonNode & config) override;
+	void initializeObject(FlaggableMapObject * object) const override;
+
+public:
+	const std::string & getVisitMessageTextID() const;
+	const std::vector<std::shared_ptr<Bonus>> & getProvidedBonuses() const;
+	const ResourceSet & getDailyIncome() const;
+};
+
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/mapObjectConstructors/HillFortInstanceConstructor.cpp vcmi/lib/mapObjectConstructors/HillFortInstanceConstructor.cpp
--- vcmi-1.5.7/lib/mapObjectConstructors/HillFortInstanceConstructor.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapObjectConstructors/HillFortInstanceConstructor.cpp	2024-12-19 15:00:22.909148392 +0100
@@ -11,12 +11,17 @@
 #include "HillFortInstanceConstructor.h"
 
 #include "../mapObjects/MiscObjects.h"
+#include "../texts/CGeneralTextHandler.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
 void HillFortInstanceConstructor::initTypeData(const JsonNode & config)
 {
 	parameters = config;
+	if(!parameters["unavailableUpgradeMessage"].isNull())
+		VLC->generaltexth->registerString(parameters.getModScope(), TextIdentifier(getBaseTextID(), "unavailableUpgradeMessage"), parameters["unavailableUpgradeMessage"].String());
+	
+	VLC->generaltexth->registerString(parameters.getModScope(), TextIdentifier(getBaseTextID(), "description"), parameters["description"].String());
 }
 
 void HillFortInstanceConstructor::initializeObject(HillFort * fort) const
diff --color -urN vcmi-1.5.7/lib/mapObjectConstructors/IObjectInfo.h vcmi/lib/mapObjectConstructors/IObjectInfo.h
--- vcmi-1.5.7/lib/mapObjectConstructors/IObjectInfo.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapObjectConstructors/IObjectInfo.h	2024-12-19 15:00:22.910148434 +0100
@@ -49,7 +49,10 @@
 
 	virtual bool givesBonuses() const { return false; }
 
+	virtual bool hasGuards() const { return false; }
+
 	virtual ~IObjectInfo() = default;
+
 };
 
 VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/mapObjects/CArmedInstance.cpp vcmi/lib/mapObjects/CArmedInstance.cpp
--- vcmi-1.5.7/lib/mapObjects/CArmedInstance.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapObjects/CArmedInstance.cpp	2024-12-19 15:00:22.910148434 +0100
@@ -11,12 +11,13 @@
 #include "StdInc.h"
 #include "CArmedInstance.h"
 
-#include "../CTownHandler.h"
 #include "../CCreatureHandler.h"
-#include "../CGeneralTextHandler.h"
-#include "../gameState/CGameState.h"
 #include "../CPlayerState.h"
-#include "../MetaString.h"
+#include "../entities/faction/CFaction.h"
+#include "../entities/faction/CTown.h"
+#include "../entities/faction/CTownHandler.h"
+#include "../gameState/CGameState.h"
+#include "../texts/CGeneralTextHandler.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
@@ -77,7 +78,7 @@
 		const CStackInstance * inst = slot.second;
 		const auto * creature  = inst->getCreatureID().toEntity(VLC);
 
-		factions.insert(creature->getFaction());
+		factions.insert(creature->getFactionID());
 		// Check for undead flag instead of faction (undead mummies are neutral)
 		if (!hasUndead)
 		{
diff --color -urN vcmi-1.5.7/lib/mapObjects/CBank.cpp vcmi/lib/mapObjects/CBank.cpp
--- vcmi-1.5.7/lib/mapObjects/CBank.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapObjects/CBank.cpp	2024-12-19 15:00:22.910148434 +0100
@@ -14,9 +14,8 @@
 #include <vcmi/spells/Spell.h>
 #include <vcmi/spells/Service.h>
 
-#include "../CGeneralTextHandler.h"
-#include "../CSoundBase.h"
-#include "../GameSettings.h"
+#include "../texts/CGeneralTextHandler.h"
+#include "../IGameSettings.h"
 #include "../CPlayerState.h"
 #include "../mapObjectConstructors/CObjectClassesHandler.h"
 #include "../mapObjectConstructors/CBankInstanceConstructor.h"
@@ -24,7 +23,6 @@
 #include "../networkPacks/Component.h"
 #include "../networkPacks/PacksForClient.h"
 #include "../networkPacks/PacksForClientBattle.h"
-#include "../MetaString.h"
 #include "../IGameCallback.h"
 #include "../gameState/CGameState.h"
 
@@ -44,7 +42,7 @@
 //must be instantiated in .cpp file for access to complete types of all member fields
 CBank::~CBank() = default;
 
-void CBank::initObj(CRandomGenerator & rand)
+void CBank::initObj(vstd::RNG & rand)
 {
 	daycounter = 0;
 	resetDuration = 0;
@@ -69,7 +67,7 @@
 	if (!wasVisited(player))
 		return {};
 
-	if (!VLC->settings()->getBoolean(EGameSettings::BANKS_SHOW_GUARDS_COMPOSITION))
+	if (!cb->getSettings().getBoolean(EGameSettings::BANKS_SHOW_GUARDS_COMPOSITION))
 		return {};
 
 	if (bankConfig == nullptr)
@@ -96,7 +94,9 @@
 	clearSlots(); // remove all stacks, if any
 
 	for(const auto & stack : config.guards)
-		setCreature (SlotID(stacksCount()), stack.type->getId(), stack.count);
+		setCreature (SlotID(stacksCount()), stack.getId(), stack.count);
+
+	daycounter = 1; //yes, 1 since "today" daycounter won't be incremented
 }
 
 void CBank::setPropertyDer (ObjProperty what, ObjPropertyID identifier)
@@ -106,25 +106,24 @@
 		case ObjProperty::BANK_DAYCOUNTER: //daycounter
 				daycounter+= identifier.getNum();
 			break;
-		case ObjProperty::BANK_RESET:
-			// FIXME: Object reset must be done by separate netpack from server
-			initObj(cb->gameState()->getRandomGenerator());
-			daycounter = 1; //yes, 1 since "today" daycounter won't be incremented
-			break;
 		case ObjProperty::BANK_CLEAR:
 			bankConfig.reset();
 			break;
 	}
 }
 
-void CBank::newTurn(CRandomGenerator & rand) const
+void CBank::newTurn(vstd::RNG & rand) const
 {
 	if (bankConfig == nullptr)
 	{
 		if (resetDuration != 0)
 		{
 			if (daycounter >= resetDuration)
-				cb->setObjPropertyValue(id, ObjProperty::BANK_RESET); //daycounter 0
+			{
+				auto handler = std::dynamic_pointer_cast<CBankInstanceConstructor>(getObjectHandler());
+				auto config = handler->generateConfiguration(cb, rand, ID);
+				cb->setBankObjectConfiguration(id, config);
+			}
 			else
 				cb->setObjPropertyValue(id, ObjProperty::BANK_DAYCOUNTER, 1); //daycounter++
 		}
@@ -138,140 +137,31 @@
 
 void CBank::onHeroVisit(const CGHeroInstance * h) const
 {
-	ChangeObjectVisitors cov(ChangeObjectVisitors::VISITOR_ADD_TEAM, id, h->id);
-	cb->sendAndApply(&cov);
-
-	if(!bankConfig && (ID.toEnum() == Obj::CREATURE_BANK || ID.toEnum() == Obj::DRAGON_UTOPIA))
-	{
-		blockingDialogAnswered(h, 1);
-		return;
-	}
+	ChangeObjectVisitors cov(ChangeObjectVisitors::VISITOR_ADD_PLAYER, id, h->id);
+	cb->sendAndApply(cov);
 
-	int banktext = 0;
-	switch (ID.toEnum())
-	{
-	case Obj::DERELICT_SHIP:
-		banktext = 41;
-		break;
-	case Obj::DRAGON_UTOPIA:
-		banktext = 47;
-		break;
-	case Obj::CRYPT:
-		banktext = 119;
-		break;
-	case Obj::SHIPWRECK:
-		banktext = 122;
-		break;
-	case Obj::PYRAMID:
-		banktext = 105;
-		break;
-	case Obj::CREATURE_BANK:
-	default:
-		banktext = 32;
-		break;
-	}
 	BlockingDialog bd(true, false);
 	bd.player = h->getOwner();
-	bd.soundID = soundBase::invalid; // Sound is handled in json files, else two sounds are played
-	bd.text.appendLocalString(EMetaText::ADVOB_TXT, banktext);
+	bd.text.appendLocalString(EMetaText::ADVOB_TXT, 32);
 	bd.components = getPopupComponents(h->getOwner());
-	if (banktext == 32)
-		bd.text.replaceRawString(getObjectName());
-
-	cb->showBlockingDialog(&bd);
+	bd.text.replaceTextID(getObjectHandler()->getNameTextID());
+	cb->showBlockingDialog(this, &bd);
 }
 
 void CBank::doVisit(const CGHeroInstance * hero) const
 {
-	int textID = -1;
 	InfoWindow iw;
 	iw.type = EInfoWindowMode::AUTO;
 	iw.player = hero->getOwner();
 	MetaString loot;
 
-	if (bankConfig)
-	{
-		switch (ID.toEnum())
-		{
-		case Obj::DERELICT_SHIP:
-			textID = 43;
-			break;
-		case Obj::CRYPT:
-			textID = 121;
-			break;
-		case Obj::SHIPWRECK:
-			textID = 124;
-			break;
-		case Obj::PYRAMID:
-			textID = 106;
-			break;
-		case Obj::CREATURE_BANK:
-		case Obj::DRAGON_UTOPIA:
-		default:
-			textID = 34;
-			break;
-		}
-	}
-	else
+	if (!bankConfig)
 	{
-		switch (ID.toEnum())
-		{
-		case Obj::SHIPWRECK:
-		case Obj::DERELICT_SHIP:
-		case Obj::CRYPT:
-		{
-			GiveBonus gbonus;
-			gbonus.id = hero->id;
-			gbonus.bonus.duration = BonusDuration::ONE_BATTLE;
-			gbonus.bonus.source = BonusSource::OBJECT_TYPE;
-			gbonus.bonus.sid = BonusSourceID(ID);
-			gbonus.bonus.type = BonusType::MORALE;
-			gbonus.bonus.val = -1;
-			switch (ID.toEnum())
-			{
-			case Obj::SHIPWRECK:
-				textID = 123;
-				gbonus.bonus.description = MetaString::createFromTextID("core.arraytxt.99");
-				break;
-			case Obj::DERELICT_SHIP:
-				textID = 42;
-				gbonus.bonus.description = MetaString::createFromTextID("core.arraytxt.101");
-				break;
-			case Obj::CRYPT:
-				textID = 120;
-				gbonus.bonus.description = MetaString::createFromTextID("core.arraytxt.98");
-				break;
-			}
-			cb->giveHeroBonus(&gbonus);
-			iw.components.emplace_back(ComponentType::MORALE, -1);
-			iw.soundID = soundBase::invalid;
-			break;
-		}
-		case Obj::PYRAMID:
-		{
-			GiveBonus gb;
-			gb.bonus = Bonus(BonusDuration::ONE_BATTLE, BonusType::LUCK, BonusSource::OBJECT_INSTANCE, -2, BonusSourceID(id));
-			gb.bonus.description = MetaString::createFromTextID("core.arraytxt.70");
-			gb.id = hero->id;
-			cb->giveHeroBonus(&gb);
-			textID = 107;
-			iw.components.emplace_back(ComponentType::LUCK, -2);
-			break;
-		}
-		case Obj::CREATURE_BANK:
-		case Obj::DRAGON_UTOPIA:
-		default:
-			iw.text.appendRawString(VLC->generaltexth->advobtxt[33]);// This was X, now is completely empty
-			iw.text.replaceRawString(getObjectName());
-		}
-		if(textID != -1)
-		{
-			iw.text.appendLocalString(EMetaText::ADVOB_TXT, textID);
-		}
+		iw.text.appendRawString(VLC->generaltexth->advobtxt[33]);// This was X, now is completely empty
+		iw.text.replaceTextID(getObjectHandler()->getNameTextID());
 		cb->showInfoDialog(&iw);
 	}
 
-
 	//grant resources
 	if (bankConfig)
 	{
@@ -292,22 +182,20 @@
 			iw.components.emplace_back(ComponentType::ARTIFACT, elem);
 			loot.appendRawString("%s");
 			loot.replaceName(elem);
-			cb->giveHeroNewArtifact(hero, elem.toArtifact(), ArtifactPosition::FIRST_AVAILABLE);
+			cb->giveHeroNewArtifact(hero, elem, ArtifactPosition::FIRST_AVAILABLE);
 		}
 		//display loot
 		if (!iw.components.empty())
 		{
-			iw.text.appendLocalString(EMetaText::ADVOB_TXT, textID);
-			if (textID == 34)
+			iw.text.appendLocalString(EMetaText::ADVOB_TXT, 34);
+			const auto * strongest = boost::range::max_element(bankConfig->guards, [](const CStackBasicDescriptor & a, const CStackBasicDescriptor & b)
 			{
-				const auto * strongest = boost::range::max_element(bankConfig->guards, [](const CStackBasicDescriptor & a, const CStackBasicDescriptor & b)
-				{
-					return a.type->getFightValue() < b.type->getFightValue();
-				})->type;
+				return a.getType()->getFightValue() < b.getType()->getFightValue();
+			})->getType();
+
+			iw.text.replaceNamePlural(strongest->getId());
+			iw.text.replaceRawString(loot.buildList());
 
-				iw.text.replaceNamePlural(strongest->getId());
-				iw.text.replaceRawString(loot.buildList());
-			}
 			cb->showInfoDialog(&iw);
 		}
 
@@ -320,10 +208,7 @@
 			std::set<SpellID> spells;
 
 			bool noWisdom = false;
-			if(textID == 106)
-			{
-				iw.text.appendLocalString(EMetaText::ADVOB_TXT, textID); //pyramid
-			}
+
 			for(const SpellID & spellId : bankConfig->spells)
 			{
 				const auto * spell = spellId.toEntity(VLC);
@@ -359,7 +244,7 @@
 		CCreatureSet ourArmy;
 		for(const auto & slot : bankConfig->creatures)
 		{
-			ourArmy.addToSlot(ourArmy.getSlotFor(slot.type->getId()), slot.type->getId(), slot.count);
+			ourArmy.addToSlot(ourArmy.getSlotFor(slot.getId()), slot.getId(), slot.count);
 		}
 
 		for(const auto & elem : ourArmy.Slots())
@@ -387,18 +272,18 @@
 
 void CBank::battleFinished(const CGHeroInstance *hero, const BattleResult &result) const
 {
-	if (result.winner == 0)
+	if (result.winner == BattleSide::ATTACKER)
 	{
 		doVisit(hero);
 	}
 }
 
-void CBank::blockingDialogAnswered(const CGHeroInstance *hero, ui32 answer) const
+void CBank::blockingDialogAnswered(const CGHeroInstance *hero, int32_t answer) const
 {
 	if (answer)
 	{
 		if (bankConfig) // not looted bank
-			cb->startBattleI(hero, this, !regularUnitPlacement);
+			cb->startBattle(hero, this);
 		else
 			doVisit(hero);
 	}
diff --color -urN vcmi-1.5.7/lib/mapObjects/CBank.h vcmi/lib/mapObjects/CBank.h
--- vcmi-1.5.7/lib/mapObjects/CBank.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapObjects/CBank.h	2024-12-19 15:00:22.910148434 +0100
@@ -33,14 +33,14 @@
 
 	void setConfig(const BankConfig & bc);
 
-	void initObj(CRandomGenerator & rand) override;
+	void initObj(vstd::RNG & rand) override;
 	std::string getHoverText(PlayerColor player) const override;
-	void newTurn(CRandomGenerator & rand) const override;
+	void newTurn(vstd::RNG & rand) const override;
 	bool wasVisited (PlayerColor player) const override;
 	bool isCoastVisitable() const override;
 	void onHeroVisit(const CGHeroInstance * h) const override;
 	void battleFinished(const CGHeroInstance *hero, const BattleResult &result) const override;
-	void blockingDialogAnswered(const CGHeroInstance *hero, ui32 answer) const override;
+	void blockingDialogAnswered(const CGHeroInstance *hero, int32_t answer) const override;
 
 	std::vector<Component> getPopupComponents(PlayerColor player) const override;
 
diff --color -urN vcmi-1.5.7/lib/mapObjects/CGCreature.cpp vcmi/lib/mapObjects/CGCreature.cpp
--- vcmi-1.5.7/lib/mapObjects/CGCreature.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapObjects/CGCreature.cpp	2024-12-19 15:00:22.911148475 +0100
@@ -12,16 +12,19 @@
 #include "CGCreature.h"
 #include "CGHeroInstance.h"
 
-#include "../CGeneralTextHandler.h"
+#include "../texts/CGeneralTextHandler.h"
 #include "../CConfigHandler.h"
-#include "../GameSettings.h"
+#include "../IGameSettings.h"
 #include "../IGameCallback.h"
+#include "../gameState/CGameState.h"
 #include "../mapObjectConstructors/CObjectClassesHandler.h"
 #include "../networkPacks/PacksForClient.h"
 #include "../networkPacks/PacksForClientBattle.h"
 #include "../networkPacks/StackLocation.h"
 #include "../serializer/JsonSerializeFormat.h"
-#include "../CRandomGenerator.h"
+#include "../entities/faction/CTownHandler.h"
+
+#include <vstd/RNG.h>
 
 VCMI_LIB_NAMESPACE_BEGIN
 
@@ -30,7 +33,7 @@
 	if(stacks.empty())
 	{
 		//should not happen...
-		logGlobal->error("Invalid stack at tile %s: subID=%d; id=%d", pos.toString(), getCreature(), id.getNum());
+		logGlobal->error("Invalid stack at tile %s: subID=%d; id=%d", anchorPos().toString(), getCreature(), id.getNum());
 		return "INVALID_STACK";
 	}
 
@@ -42,7 +45,7 @@
 	else
 		ms.appendLocalString(EMetaText::ARRAY_TXT, quantityTextIndex);
 	ms.appendRawString(" ");
-	ms.appendNamePlural(getCreature());
+	ms.appendNamePlural(getCreatureID());
 
 	return ms.toString();
 }
@@ -54,7 +57,7 @@
 		MetaString ms;
 		ms.appendNumber(stacks.begin()->second->count);
 		ms.appendRawString(" ");
-		ms.appendName(getCreature(), stacks.begin()->second->count);
+		ms.appendName(getCreatureID(), stacks.begin()->second->count);
 		return ms.toString();
 	}
 	else
@@ -63,6 +66,18 @@
 	}
 }
 
+std::string CGCreature::getMonsterLevelText() const
+{
+	std::string monsterLevel = VLC->generaltexth->translate("vcmi.adventureMap.monsterLevel");
+	bool isRanged = getCreature()->getBonusBearer()->hasBonusOfType(BonusType::SHOOTER);
+	std::string attackTypeKey = isRanged ? "vcmi.adventureMap.monsterRangedType" : "vcmi.adventureMap.monsterMeleeType";
+	std::string attackType = VLC->generaltexth->translate(attackTypeKey);
+	boost::replace_first(monsterLevel, "%TOWN", getCreature()->getFactionID().toEntity(VLC)->getNameTranslated());
+	boost::replace_first(monsterLevel, "%LEVEL", std::to_string(getCreature()->getLevel()));
+	boost::replace_first(monsterLevel, "%ATTACK_TYPE", attackType);
+	return monsterLevel;
+}
+
 std::string CGCreature::getPopupText(const CGHeroInstance * hero) const
 {
 	std::string hoverName;
@@ -99,10 +114,13 @@
 
 	if (settings["general"]["enableUiEnhancements"].Bool())
 	{
+		hoverName += getMonsterLevelText();
 		hoverName += VLC->generaltexth->translate("vcmi.adventureMap.monsterThreat.title");
 
 		int choice;
-		double ratio = (static_cast<double>(getArmyStrength()) / hero->getTotalStrength());
+		uint64_t armyStrength = getArmyStrength();
+		uint64_t heroStrength = hero->getTotalStrength();
+		double ratio = static_cast<double>(armyStrength) / heroStrength;
 		if (ratio < 0.1)  choice = 0;
 		else if (ratio < 0.25) choice = 1;
 		else if (ratio < 0.6)  choice = 2;
@@ -123,13 +141,16 @@
 
 std::string CGCreature::getPopupText(PlayerColor player) const
 {
-	return getHoverText(player);
+	std::string hoverName = getHoverText(player);
+	if (settings["general"]["enableUiEnhancements"].Bool())
+		hoverName += getMonsterLevelText();
+	return hoverName;
 }
 
 std::vector<Component> CGCreature::getPopupComponents(PlayerColor player) const
 {
 	return {
-		Component(ComponentType::CREATURE, getCreature())
+		Component(ComponentType::CREATURE, getCreatureID())
 	};
 }
 
@@ -161,8 +182,8 @@
 			BlockingDialog ynd(true,false);
 			ynd.player = h->tempOwner;
 			ynd.text.appendLocalString(EMetaText::ADVOB_TXT, 86);
-			ynd.text.replaceName(getCreature(), getStackCount(SlotID(0)));
-			cb->showBlockingDialog(&ynd);
+			ynd.text.replaceName(getCreatureID(), getStackCount(SlotID(0)));
+			cb->showBlockingDialog(this, &ynd);
 			break;
 		}
 	default: //join for gold
@@ -176,20 +197,25 @@
 			std::string tmp = VLC->generaltexth->advobtxt[90];
 			boost::algorithm::replace_first(tmp, "%d", std::to_string(getStackCount(SlotID(0))));
 			boost::algorithm::replace_first(tmp, "%d", std::to_string(action));
-			boost::algorithm::replace_first(tmp,"%s",VLC->creatures()->getById(getCreature())->getNamePluralTranslated());
+			boost::algorithm::replace_first(tmp,"%s",getCreature()->getNamePluralTranslated());
 			ynd.text.appendRawString(tmp);
-			cb->showBlockingDialog(&ynd);
+			cb->showBlockingDialog(this, &ynd);
 			break;
 		}
 	}
 }
 
-CreatureID CGCreature::getCreature() const
+CreatureID CGCreature::getCreatureID() const
 {
 	return CreatureID(getObjTypeIndex().getNum());
 }
 
-void CGCreature::pickRandomObject(CRandomGenerator & rand)
+const CCreature * CGCreature::getCreature() const
+{
+	return getCreatureID().toCreature();
+}
+
+void CGCreature::pickRandomObject(vstd::RNG & rand)
 {
 	switch(ID.toEnum())
 	{
@@ -227,14 +253,14 @@
 	{
 		// Try to generate some debug information if sanity check failed
 		CreatureID creatureID(subID.getNum());
-		throw std::out_of_range("Failed to find handler for creature " + std::to_string(creatureID.getNum()) + ", identifer:" + creatureID.toEntity(VLC)->getJsonKey());
+		throw std::out_of_range("Failed to find handler for creature " + std::to_string(creatureID.getNum()) + ", identifier:" + creatureID.toEntity(VLC)->getJsonKey());
 	}
 
 	ID = MapObjectID::MONSTER;
 	setType(ID, subID);
 }
 
-void CGCreature::initObj(CRandomGenerator & rand)
+void CGCreature::initObj(vstd::RNG & rand)
 {
 	blockVisit = true;
 	switch(character)
@@ -258,7 +284,7 @@
 
 	stacks[SlotID(0)]->setType(getCreature());
 	TQuantity &amount = stacks[SlotID(0)]->count;
-	const Creature * c = VLC->creatures()->getById(getCreature());
+	const Creature * c = getCreature();
 	if(amount == 0)
 	{
 		amount = rand.nextInt(c->getAdvMapAmountMin(), c->getAdvMapAmountMax());
@@ -270,23 +296,23 @@
 		}
 	}
 
-	temppower = stacks[SlotID(0)]->count * static_cast<ui64>(1000);
+	temppower = stacks[SlotID(0)]->count * static_cast<int64_t>(1000);
 	refusedJoining = false;
 }
 
-void CGCreature::newTurn(CRandomGenerator & rand) const
+void CGCreature::newTurn(vstd::RNG & rand) const
 {//Works only for stacks of single type of size up to 2 millions
 	if (!notGrowingTeam)
 	{
-		if (stacks.begin()->second->count < VLC->settings()->getInteger(EGameSettings::CREATURES_WEEKLY_GROWTH_CAP) && cb->getDate(Date::DAY_OF_WEEK) == 1 && cb->getDate(Date::DAY) > 1)
+		if (stacks.begin()->second->count < cb->getSettings().getInteger(EGameSettings::CREATURES_WEEKLY_GROWTH_CAP) && cb->getDate(Date::DAY_OF_WEEK) == 1 && cb->getDate(Date::DAY) > 1)
 		{
-			ui32 power = static_cast<ui32>(temppower * (100 + VLC->settings()->getInteger(EGameSettings::CREATURES_WEEKLY_GROWTH_PERCENT)) / 100);
-			cb->setObjPropertyValue(id, ObjProperty::MONSTER_COUNT, std::min<uint32_t>(power / 1000, VLC->settings()->getInteger(EGameSettings::CREATURES_WEEKLY_GROWTH_CAP))); //set new amount
+			ui32 power = static_cast<ui32>(temppower * (100 + cb->getSettings().getInteger(EGameSettings::CREATURES_WEEKLY_GROWTH_PERCENT)) / 100);
+			cb->setObjPropertyValue(id, ObjProperty::MONSTER_COUNT, std::min<uint32_t>(power / 1000, cb->getSettings().getInteger(EGameSettings::CREATURES_WEEKLY_GROWTH_CAP))); //set new amount
 			cb->setObjPropertyValue(id, ObjProperty::MONSTER_POWER, power); //increase temppower
 		}
 	}
-	if (VLC->settings()->getBoolean(EGameSettings::MODULE_STACK_EXPERIENCE))
-		cb->setObjPropertyValue(id, ObjProperty::MONSTER_EXP, VLC->settings()->getInteger(EGameSettings::CREATURES_DAILY_STACK_EXPERIENCE)); //for testing purpose
+	if (cb->getSettings().getBoolean(EGameSettings::MODULE_STACK_EXPERIENCE))
+		cb->setObjPropertyValue(id, ObjProperty::MONSTER_EXP, cb->getSettings().getInteger(EGameSettings::CREATURES_DAILY_STACK_EXPERIENCE)); //for testing purpose
 }
 void CGCreature::setPropertyDer(ObjProperty what, ObjPropertyID identifier)
 {
@@ -332,8 +358,8 @@
 
 	for(const auto & elem : h->Slots())
 	{
-		bool isOurUpgrade = vstd::contains(getCreature().toCreature()->upgrades, elem.second->getCreatureID());
-		bool isOurDowngrade = vstd::contains(elem.second->type->upgrades, getCreature());
+		bool isOurUpgrade = vstd::contains(getCreature()->upgrades, elem.second->getCreatureID());
+		bool isOurDowngrade = vstd::contains(elem.second->getCreature()->upgrades, getCreatureID());
 
 		if(isOurUpgrade || isOurDowngrade)
 			count += elem.second->count;
@@ -359,7 +385,7 @@
 
 		if(diplomacy * 2 + sympathy + 1 >= character)
 		{
-			int32_t recruitCost = VLC->creatures()->getById(getCreature())->getRecruitCost(EGameResID::GOLD);
+			int32_t recruitCost = getCreature()->getRecruitCost(EGameResID::GOLD);
 			int32_t stackCount = getStackCount(SlotID(0));
 			return recruitCost * stackCount; //join for gold
 		}
@@ -454,16 +480,16 @@
 		if (containsUpgradedStack()) //upgrade
 		{
 			SlotID slotID = SlotID(static_cast<si32>(std::floor(static_cast<float>(stacks.size()) / 2.0f)));
-			const auto & upgrades = getStack(slotID).type->upgrades;
+			const auto & upgrades = getStack(slotID).getCreature()->upgrades;
 			if(!upgrades.empty())
 			{
-				auto it = RandomGeneratorUtil::nextItem(upgrades, CRandomGenerator::getDefault());
+				auto it = RandomGeneratorUtil::nextItem(upgrades, cb->gameState()->getRandomGenerator());
 				cb->changeStackType(StackLocation(this, slotID), it->toCreature());
 			}
 		}
 	}
 
-	cb->startBattleI(h, this);
+	cb->startBattle(h, this);
 
 }
 
@@ -472,18 +498,18 @@
 	BlockingDialog ynd(true,false);
 	ynd.player = h->tempOwner;
 	ynd.text.appendLocalString(EMetaText::ADVOB_TXT,91);
-	ynd.text.replaceName(getCreature(), getStackCount(SlotID(0)));
-	cb->showBlockingDialog(&ynd);
+	ynd.text.replaceName(getCreatureID(), getStackCount(SlotID(0)));
+	cb->showBlockingDialog(this, &ynd);
 }
 
 void CGCreature::battleFinished(const CGHeroInstance *hero, const BattleResult &result) const
 {
-	if(result.winner == 0)
+	if(result.winner == BattleSide::ATTACKER)
 	{
 		giveReward(hero);
 		cb->removeObject(this, hero->getOwner());
 	}
-	else if(result.winner > 1) // draw
+	else if(result.winner == BattleSide::NONE) // draw
 	{
 		// guarded reward is lost forever on draw
 		cb->removeObject(this, hero->getOwner());
@@ -492,10 +518,10 @@
 	{
 		//merge stacks into one
 		TSlots::const_iterator i;
-		const CCreature * cre = getCreature().toCreature();
+		const CCreature * cre = getCreature();
 		for(i = stacks.begin(); i != stacks.end(); i++)
 		{
-			if(cre->isMyUpgrade(i->second->type))
+			if(cre->isMyUpgrade(i->second->getCreature()))
 			{
 				cb->changeStackType(StackLocation(this, i->first), cre); //un-upgrade creatures
 			}
@@ -510,7 +536,7 @@
 			// TODO it's either overcomplicated (if we assume there'll be only one stack) or buggy (if we allow multiple stacks... but that'll also cause troubles elsewhere)
 			i = stacks.end();
 			i--;
-			SlotID slot = getSlotFor(i->second->type);
+			SlotID slot = getSlotFor(i->second->getCreature());
 			if(slot == i->first) //no reason to move stack to its own slot
 				break;
 			else
@@ -521,7 +547,7 @@
 	}
 }
 
-void CGCreature::blockingDialogAnswered(const CGHeroInstance *hero, ui32 answer) const
+void CGCreature::blockingDialogAnswered(const CGHeroInstance *hero, int32_t answer) const
 {
 	auto action = takenAction(hero);
 	if(!refusedJoining && action >= JOIN_FOR_FREE) //higher means price
@@ -541,7 +567,7 @@
 	float c = 5325.181015f;
 	float d = 32788.727920f;
 
-	int val = static_cast<int>(std::floor(a * pos.x + b * pos.y + c * pos.z + d));
+	int val = static_cast<int>(std::floor(a * visitablePos().x + b * visitablePos().y + c * visitablePos().z + d));
 	return ((val % 32768) % 100) < 50;
 }
 
@@ -570,7 +596,7 @@
 	ui32 c = 1943276003u;
 	ui32 d = 3174620878u;
 
-	ui32 R1 = a * static_cast<ui32>(pos.x) + b * static_cast<ui32>(pos.y) + c * static_cast<ui32>(pos.z) + d;
+	ui32 R1 = a * static_cast<ui32>(visitablePos().x) + b * static_cast<ui32>(visitablePos().y) + c * static_cast<ui32>(visitablePos().z) + d;
 	ui32 R2 = (R1 >> 16) & 0x7fff;
 
 	int R4 = R2 % 100 + 1;
@@ -603,7 +629,7 @@
 
 	if(gainedArtifact != ArtifactID::NONE)
 	{
-		cb->giveHeroNewArtifact(h, gainedArtifact.toArtifact(), ArtifactPosition::FIRST_AVAILABLE);
+		cb->giveHeroNewArtifact(h, gainedArtifact, ArtifactPosition::FIRST_AVAILABLE);
 		iw.components.emplace_back(ComponentType::ARTIFACT, gainedArtifact);
 	}
 
diff --color -urN vcmi-1.5.7/lib/mapObjects/CGCreature.h vcmi/lib/mapObjects/CGCreature.h
--- vcmi-1.5.7/lib/mapObjects/CGCreature.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapObjects/CGCreature.h	2024-12-19 15:00:22.911148475 +0100
@@ -11,7 +11,6 @@
 
 #include "CArmedInstance.h"
 #include "../ResourceSet.h"
-#include "../MetaString.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
@@ -35,7 +34,7 @@
 	ArtifactID gainedArtifact; //ID of artifact gained to hero, -1 if none
 	bool neverFlees = false; //if true, the troops will never flee
 	bool notGrowingTeam = false; //if true, number of units won't grow
-	ui64 temppower = 0; //used to handle fractional stack growth for tiny stacks
+	int64_t temppower = 0; //used to handle fractional stack growth for tiny stacks
 
 	bool refusedJoining = false;
 
@@ -45,12 +44,13 @@
 	std::string getPopupText(PlayerColor player) const override;
 	std::string getPopupText(const CGHeroInstance * hero) const override;
 	std::vector<Component> getPopupComponents(PlayerColor player) const override;
-	void initObj(CRandomGenerator & rand) override;
-	void pickRandomObject(CRandomGenerator & rand) override;
-	void newTurn(CRandomGenerator & rand) const override;
+	void initObj(vstd::RNG & rand) override;
+	void pickRandomObject(vstd::RNG & rand) override;
+	void newTurn(vstd::RNG & rand) const override;
 	void battleFinished(const CGHeroInstance *hero, const BattleResult &result) const override;
-	void blockingDialogAnswered(const CGHeroInstance *hero, ui32 answer) const override;
-	CreatureID getCreature() const;
+	void blockingDialogAnswered(const CGHeroInstance *hero, int32_t answer) const override;
+	CreatureID getCreatureID() const;
+	const CCreature * getCreature() const;
 
 	//stack formation depends on position,
 	bool containsUpgradedStack() const;
@@ -82,7 +82,7 @@
 
 	int takenAction(const CGHeroInstance *h, bool allowJoin=true) const; //action on confrontation: -2 - fight, -1 - flee, >=0 - will join for given value of gold (may be 0)
 	void giveReward(const CGHeroInstance * h) const;
-
+	std::string getMonsterLevelText() const;
 };
 
 VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/mapObjects/CGDwelling.cpp vcmi/lib/mapObjects/CGDwelling.cpp
--- vcmi-1.5.7/lib/mapObjects/CGDwelling.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapObjects/CGDwelling.cpp	2024-12-19 15:00:22.911148475 +0100
@@ -11,6 +11,7 @@
 #include "StdInc.h"
 #include "CGDwelling.h"
 #include "../serializer/JsonSerializeFormat.h"
+#include "../entities/faction/CTownHandler.h"
 #include "../mapping/CMap.h"
 #include "../mapObjectConstructors/AObjectTypeHandler.h"
 #include "../mapObjectConstructors/CObjectClassesHandler.h"
@@ -20,13 +21,14 @@
 #include "../networkPacks/StackLocation.h"
 #include "../networkPacks/PacksForClient.h"
 #include "../networkPacks/PacksForClientBattle.h"
-#include "../CTownHandler.h"
 #include "../IGameCallback.h"
 #include "../gameState/CGameState.h"
 #include "../CPlayerState.h"
-#include "../GameSettings.h"
+#include "../IGameSettings.h"
 #include "../CConfigHandler.h"
 
+#include <vstd/RNG.h>
+
 VCMI_LIB_NAMESPACE_BEGIN
 
 void CGDwellingRandomizationInfo::serializeJson(JsonSerializeFormat & handler)
@@ -50,7 +52,7 @@
 
 CGDwelling::~CGDwelling() = default;
 
-FactionID CGDwelling::randomizeFaction(CRandomGenerator & rand)
+FactionID CGDwelling::randomizeFaction(vstd::RNG & rand)
 {
 	if (ID == Obj::RANDOM_DWELLING_FACTION)
 		return FactionID(subID.getNum());
@@ -91,7 +93,7 @@
 
 		assert(linkedTown->ID == Obj::TOWN);
 		if(linkedTown->ID==Obj::TOWN)
-			return linkedTown->getFaction();
+			return linkedTown->getFactionID();
 	}
 
 	if(!randomizationInfo->allowedFactions.empty())
@@ -108,7 +110,7 @@
 	return *RandomGeneratorUtil::nextItem(potentialPicks, rand);
 }
 
-int CGDwelling::randomizeLevel(CRandomGenerator & rand)
+int CGDwelling::randomizeLevel(vstd::RNG & rand)
 {
 	if (ID == Obj::RANDOM_DWELLING_LVL)
 		return subID.getNum();
@@ -125,7 +127,7 @@
 	return rand.nextInt(randomizationInfo->minLevel, randomizationInfo->maxLevel) - 1;
 }
 
-void CGDwelling::pickRandomObject(CRandomGenerator & rand)
+void CGDwelling::pickRandomObject(vstd::RNG & rand)
 {
 	if (ID == Obj::RANDOM_DWELLING || ID == Obj::RANDOM_DWELLING_LVL || ID == Obj::RANDOM_DWELLING_FACTION)
 	{
@@ -172,18 +174,15 @@
 	}
 }
 
-void CGDwelling::initObj(CRandomGenerator & rand)
+void CGDwelling::initObj(vstd::RNG & rand)
 {
 	switch(ID.toEnum())
 	{
 	case Obj::CREATURE_GENERATOR1:
 	case Obj::CREATURE_GENERATOR4:
+	case Obj::WAR_MACHINE_FACTORY:
 		{
 			getObjectHandler()->configureObject(this, rand);
-
-			if (getOwner() != PlayerColor::NEUTRAL)
-				cb->gameState()->players[getOwner()].dwellings.emplace_back(this);
-
 			assert(!creatures.empty());
 			assert(!creatures[0].second.empty());
 			break;
@@ -192,13 +191,6 @@
 		//is handled within newturn func
 		break;
 
-	case Obj::WAR_MACHINE_FACTORY:
-		creatures.resize(3);
-		creatures[0].second.emplace_back(CreatureID::BALLISTA);
-		creatures[1].second.emplace_back(CreatureID::FIRST_AID_TENT);
-		creatures[2].second.emplace_back(CreatureID::AMMO_CART);
-		break;
-
 	default:
 		assert(0);
 		break;
@@ -209,19 +201,6 @@
 {
 	switch (what)
 	{
-		case ObjProperty::OWNER: //change owner
-			if (ID == Obj::CREATURE_GENERATOR1 || ID == Obj::CREATURE_GENERATOR2
-				|| ID == Obj::CREATURE_GENERATOR3 || ID == Obj::CREATURE_GENERATOR4)
-			{
-				if (tempOwner != PlayerColor::NEUTRAL)
-				{
-					std::vector<ConstTransitivePtr<CGDwelling> >* dwellings = &cb->gameState()->players[tempOwner].dwellings;
-					dwellings->erase (std::find(dwellings->begin(), dwellings->end(), this));
-				}
-				if (identifier.as<PlayerColor>().isValidPlayer())
-					cb->gameState()->players[identifier.as<PlayerColor>()].dwellings.emplace_back(this);
-			}
-			break;
 		case ObjProperty::AVAILABLE_CREATURE:
 			creatures.resize(1);
 			creatures[0].second.resize(1);
@@ -239,7 +218,7 @@
 		iw.player = h->tempOwner;
 		iw.text.appendLocalString(EMetaText::ADVOB_TXT, 44); //{%s} \n\n The camp is deserted.  Perhaps you should try next week.
 		iw.text.replaceName(ID);
-		cb->sendAndApply(&iw);
+		cb->sendAndApply(iw);
 		return;
 	}
 
@@ -259,7 +238,7 @@
 		else
 			bd.text.replaceLocalString(EMetaText::ARRAY_TXT, 173 + (int)Slots().begin()->second->getQuantityID()*3);
 		bd.text.replaceName(*Slots().begin()->second);
-		cb->showBlockingDialog(&bd);
+		cb->showBlockingDialog(this, &bd);
 		return;
 	}
 
@@ -295,10 +274,10 @@
 		bd.flags |= BlockingDialog::SAFE_TO_AUTOACCEPT;
 	}
 
-	cb->showBlockingDialog(&bd);
+	cb->showBlockingDialog(this, &bd);
 }
 
-void CGDwelling::newTurn(CRandomGenerator & rand) const
+void CGDwelling::newTurn(vstd::RNG & rand) const
 {
 	if(cb->getDate(Date::DAY_OF_WEEK) != 1) //not first day of week
 		return;
@@ -324,9 +303,9 @@
 			bool creaturesAccumulate = false;
 
 			if (tempOwner.isValidPlayer())
-				creaturesAccumulate = VLC->settings()->getBoolean(EGameSettings::DWELLINGS_ACCUMULATE_WHEN_OWNED);
+				creaturesAccumulate = cb->getSettings().getBoolean(EGameSettings::DWELLINGS_ACCUMULATE_WHEN_OWNED);
 			else
-				creaturesAccumulate = VLC->settings()->getBoolean(EGameSettings::DWELLINGS_ACCUMULATE_WHEN_NEUTRAL);
+				creaturesAccumulate = cb->getSettings().getBoolean(EGameSettings::DWELLINGS_ACCUMULATE_WHEN_NEUTRAL);
 
 			const CCreature * cre =creatures[i].second[0].toCreature();
 			TQuantity amount = cre->getGrowth() * (1 + cre->valOfBonuses(BonusType::CREATURE_GROWTH_PERCENT)/100) + cre->valOfBonuses(BonusType::CREATURE_GROWTH, BonusCustomSubtype::creatureLevel(cre->getLevel()));
@@ -339,7 +318,7 @@
 	}
 
 	if(change)
-		cb->sendAndApply(&sac);
+		cb->sendAndApply(sac);
 
 	updateGuards();
 }
@@ -407,7 +386,7 @@
 				csc.slot = slot;
 				csc.count = crea->getGrowth() * 3;
 				csc.absoluteValue = true;
-				cb->sendAndApply(&csc);
+				cb->sendAndApply(csc);
 			}
 			else //slot is empty, create whole new stack
 			{
@@ -416,7 +395,7 @@
 				ns.slot = slot;
 				ns.type = crea->getId();
 				ns.count = crea->getGrowth() * 3;
-				cb->sendAndApply(&ns);
+				cb->sendAndApply(ns);
 			}
 		}
 	}
@@ -433,13 +412,13 @@
 		if(count) //there are available creatures
 		{
 
-			if (VLC->settings()->getBoolean(EGameSettings::DWELLINGS_MERGE_ON_RECRUIT))
+			if (cb->getSettings().getBoolean(EGameSettings::DWELLINGS_MERGE_ON_RECRUIT))
 			{
 				SlotID testSlot = h->getSlotFor(crid);
 				if(!testSlot.validSlot()) //no available slot - try merging army of visiting hero
 				{
 					std::pair<SlotID, SlotID> toMerge;
-					if (h->mergableStacks(toMerge))
+					if (h->mergeableStacks(toMerge))
 					{
 						cb->moveStack(StackLocation(h, toMerge.first), StackLocation(h, toMerge.second), -1); //merge toMerge.first into toMerge.second
 						assert(!h->hasStackAtSlot(toMerge.first)); //we have now a new free slot
@@ -473,7 +452,7 @@
 				iw.text.replaceNamePlural(crid);
 
 				cb->showInfoDialog(&iw);
-				cb->sendAndApply(&sac);
+				cb->sendAndApply(sac);
 				cb->addToSlot(StackLocation(h, slot), crs, count);
 			}
 		}
@@ -484,7 +463,7 @@
 			iw.text.appendLocalString(EMetaText::GENERAL_TXT, 422); //There are no %s here to recruit.
 			iw.text.replaceNamePlural(crid);
 			iw.player = h->tempOwner;
-			cb->sendAndApply(&iw);
+			cb->sendAndApply(iw);
 		}
 	}
 	else
@@ -498,7 +477,7 @@
 			sac.creatures[0].first = !h->getArt(ArtifactPosition::MACH1); //ballista
 			sac.creatures[1].first = !h->getArt(ArtifactPosition::MACH3); //first aid tent
 			sac.creatures[2].first = !h->getArt(ArtifactPosition::MACH2); //ammo cart
-			cb->sendAndApply(&sac);
+			cb->sendAndApply(sac);
 		}
 
 		auto windowMode = (ID == Obj::CREATURE_GENERATOR1 || ID == Obj::REFUGEE_CAMP) ? EOpenWindowMode::RECRUITMENT_FIRST : EOpenWindowMode::RECRUITMENT_ALL;
@@ -508,19 +487,19 @@
 
 void CGDwelling::battleFinished(const CGHeroInstance *hero, const BattleResult &result) const
 {
-	if (result.winner == 0)
+	if (result.winner == BattleSide::ATTACKER)
 	{
 		onHeroVisit(hero);
 	}
 }
 
-void CGDwelling::blockingDialogAnswered(const CGHeroInstance *hero, ui32 answer) const
+void CGDwelling::blockingDialogAnswered(const CGHeroInstance *hero, int32_t answer) const
 {
 	auto relations = cb->getPlayerRelations(getOwner(), hero->getOwner());
 	if(stacksCount() > 0  && relations == PlayerRelations::ENEMIES) //guards present
 	{
 		if(answer)
-			cb->startBattleI(hero, this);
+			cb->startBattle(hero, this);
 	}
 	else if(answer)
 	{
@@ -549,4 +528,33 @@
 	}
 }
 
+const IOwnableObject * CGDwelling::asOwnable() const
+{
+	switch (ID.toEnum())
+	{
+		case Obj::WAR_MACHINE_FACTORY:
+		case Obj::REFUGEE_CAMP:
+			return nullptr; // can't be owned
+		default:
+			return this;
+	}
+}
+
+ResourceSet CGDwelling::dailyIncome() const
+{
+	return {};
+}
+
+std::vector<CreatureID> CGDwelling::providedCreatures() const
+{
+	if (ID == Obj::WAR_MACHINE_FACTORY || ID == Obj::REFUGEE_CAMP)
+		return {};
+
+	std::vector<CreatureID> result;
+	for (const auto & level : creatures)
+		result.insert(result.end(), level.second.begin(), level.second.end());
+
+	return result;
+}
+
 VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/mapObjects/CGDwelling.h vcmi/lib/mapObjects/CGDwelling.h
--- vcmi-1.5.7/lib/mapObjects/CGDwelling.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapObjects/CGDwelling.h	2024-12-19 15:00:22.911148475 +0100
@@ -11,6 +11,7 @@
 #pragma once
 
 #include "CArmedInstance.h"
+#include "IOwnableObject.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
@@ -30,10 +31,10 @@
 	void serializeJson(JsonSerializeFormat & handler);
 };
 
-class DLL_LINKAGE CGDwelling : public CArmedInstance
+class DLL_LINKAGE CGDwelling : public CArmedInstance, public IOwnableObject
 {
 public:
-	typedef std::vector<std::pair<ui32, std::vector<CreatureID> > > TCreaturesSet;
+	using TCreaturesSet = std::vector<std::pair<ui32, std::vector<CreatureID> > >;
 
 	std::optional<CGDwellingRandomizationInfo> randomizationInfo; //random dwelling options; not serialized
 	TCreaturesSet creatures; //creatures[level] -> <vector of alternative ids (base creature and upgrades, creatures amount>
@@ -41,20 +42,24 @@
 	CGDwelling(IGameCallback *cb);
 	~CGDwelling() override;
 
+	const IOwnableObject * asOwnable() const final;
+	ResourceSet dailyIncome() const override;
+	std::vector<CreatureID> providedCreatures() const override;
+
 protected:
 	void serializeJsonOptions(JsonSerializeFormat & handler) override;
 
 private:
-	FactionID randomizeFaction(CRandomGenerator & rand);
-	int randomizeLevel(CRandomGenerator & rand);
+	FactionID randomizeFaction(vstd::RNG & rand);
+	int randomizeLevel(vstd::RNG & rand);
 
-	void pickRandomObject(CRandomGenerator & rand) override;
-	void initObj(CRandomGenerator & rand) override;
+	void pickRandomObject(vstd::RNG & rand) override;
+	void initObj(vstd::RNG & rand) override;
 	void onHeroVisit(const CGHeroInstance * h) const override;
-	void newTurn(CRandomGenerator & rand) const override;
+	void newTurn(vstd::RNG & rand) const override;
 	void setPropertyDer(ObjProperty what, ObjPropertyID identifier) override;
 	void battleFinished(const CGHeroInstance *hero, const BattleResult &result) const override;
-	void blockingDialogAnswered(const CGHeroInstance *hero, ui32 answer) const override;
+	void blockingDialogAnswered(const CGHeroInstance *hero, int32_t answer) const override;
 	std::vector<Component> getPopupComponents(PlayerColor player) const override;
 
 	void updateGuards() const;
diff --color -urN vcmi-1.5.7/lib/mapObjects/CGHeroInstance.cpp vcmi/lib/mapObjects/CGHeroInstance.cpp
--- vcmi-1.5.7/lib/mapObjects/CGHeroInstance.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapObjects/CGHeroInstance.cpp	2024-12-19 15:00:22.912148516 +0100
@@ -15,22 +15,24 @@
 #include <vcmi/spells/Spell.h>
 #include <vstd/RNG.h>
 
-#include "../CGeneralTextHandler.h"
+#include "../texts/CGeneralTextHandler.h"
 #include "../ArtifactUtils.h"
-#include "../CHeroHandler.h"
 #include "../TerrainHandler.h"
 #include "../RoadHandler.h"
-#include "../GameSettings.h"
+#include "../IGameSettings.h"
 #include "../CSoundBase.h"
 #include "../spells/CSpellHandler.h"
 #include "../CSkillHandler.h"
 #include "../IGameCallback.h"
 #include "../gameState/CGameState.h"
 #include "../CCreatureHandler.h"
-#include "../CTownHandler.h"
 #include "../mapping/CMap.h"
 #include "../StartInfo.h"
 #include "CGTownInstance.h"
+#include "../entities/faction/CTownHandler.h"
+#include "../entities/hero/CHeroHandler.h"
+#include "../entities/hero/CHeroClass.h"
+#include "../battle/CBattleInfoEssentials.h"
 #include "../campaign/CampaignState.h"
 #include "../json/JsonBonus.h"
 #include "../pathfinder/TurnInfo.h"
@@ -47,6 +49,8 @@
 
 VCMI_LIB_NAMESPACE_BEGIN
 
+const ui32 CGHeroInstance::NO_PATROLLING = std::numeric_limits<ui32>::max();
+
 void CGHeroPlaceholder::serializeJsonOptions(JsonSerializeFormat & handler)
 {
 	serializeJsonOwner(handler);
@@ -98,16 +102,16 @@
 	int64_t ret = GameConstants::BASE_MOVEMENT_COST;
 
 	//if there is road both on dest and src tiles - use src road movement cost
-	if(dest.roadType->getId() != Road::NO_ROAD && from.roadType->getId() != Road::NO_ROAD)
+	if(dest.hasRoad() && from.hasRoad())
 	{
-		ret = from.roadType->movementCost;
+		ret = from.getRoad()->movementCost;
 	}
-	else if(ti->nativeTerrain != from.terType->getId() &&//the terrain is not native
+	else if(ti->nativeTerrain != from.getTerrainID() &&//the terrain is not native
 			ti->nativeTerrain != ETerrainId::ANY_TERRAIN && //no special creature bonus
-			!ti->hasBonusOfType(BonusType::NO_TERRAIN_PENALTY, BonusSubtypeID(from.terType->getId()))) //no special movement bonus
+			!ti->hasBonusOfType(BonusType::NO_TERRAIN_PENALTY, BonusSubtypeID(from.getTerrainID()))) //no special movement bonus
 	{
 
-		ret = VLC->terrainTypeHandler->getById(from.terType->getId())->moveCost;
+		ret = VLC->terrainTypeHandler->getById(from.getTerrainID())->moveCost;
 		ret -= ti->valOfBonuses(BonusType::ROUGH_TERRAIN_DISCOUNT);
 		if(ret < GameConstants::BASE_MOVEMENT_COST)
 			ret = GameConstants::BASE_MOVEMENT_COST;
@@ -115,9 +119,9 @@
 	return static_cast<ui32>(ret);
 }
 
-FactionID CGHeroInstance::getFaction() const
+FactionID CGHeroInstance::getFactionID() const
 {
-	return FactionID(type->heroClass->faction);
+	return getHeroClass()->faction;
 }
 
 const IBonusBearer* CGHeroInstance::getBonusBearer() const
@@ -228,10 +232,10 @@
 	if (getSecSkillLevel(which) > 0)
 		return false;
 
-	if (type->heroClass->secSkillProbability.count(which) == 0)
+	if (getHeroClass()->secSkillProbability.count(which) == 0)
 		return false;
 
-	if (type->heroClass->secSkillProbability.at(which) == 0)
+	if (getHeroClass()->secSkillProbability.at(which) == 0)
 		return false;
 
 	return true;
@@ -281,7 +285,6 @@
 
 CGHeroInstance::CGHeroInstance(IGameCallback * cb)
 	: CArmedInstance(cb),
-	type(nullptr),
 	tacticFormationEnabled(false),
 	inTownGarrison(false),
 	moveDir(4),
@@ -302,36 +305,83 @@
 	return tempOwner;
 }
 
-HeroTypeID CGHeroInstance::getHeroType() const
+const CHeroClass * CGHeroInstance::getHeroClass() const
+{
+	return getHeroType()->heroClass;
+}
+
+HeroClassID CGHeroInstance::getHeroClassID() const
+{
+	auto heroType = getHeroTypeID();
+	if (heroType.hasValue())
+		return getHeroType()->heroClass->getId();
+	else
+		return HeroClassID();
+}
+
+const CHero * CGHeroInstance::getHeroType() const
+{
+	return getHeroTypeID().toHeroType();
+}
+
+HeroTypeID CGHeroInstance::getHeroTypeID() const
 {
+	if (ID == Obj::RANDOM_HERO)
+		return HeroTypeID::NONE;
 	return HeroTypeID(getObjTypeIndex().getNum());
 }
 
 void CGHeroInstance::setHeroType(HeroTypeID heroType)
 {
-	assert(type == nullptr);
 	subID = heroType;
 }
 
-void CGHeroInstance::initHero(CRandomGenerator & rand, const HeroTypeID & SUBID)
+void CGHeroInstance::initObj(vstd::RNG & rand)
+{
+	if (ID == Obj::HERO)
+		updateAppearance();
+}
+
+void CGHeroInstance::initHero(vstd::RNG & rand, const HeroTypeID & SUBID)
 {
 	subID = SUBID.getNum();
 	initHero(rand);
 }
 
-void CGHeroInstance::initHero(CRandomGenerator & rand)
+TObjectTypeHandler CGHeroInstance::getObjectHandler() const
+{
+	if (ID == Obj::HERO)
+		return VLC->objtypeh->getHandlerFor(ID, getHeroClass()->getIndex());
+	else // prison or random hero
+		return VLC->objtypeh->getHandlerFor(ID, 0);
+}
+
+void CGHeroInstance::updateAppearance()
+{
+	auto handler = VLC->objtypeh->getHandlerFor(Obj::HERO, getHeroClass()->getIndex());;
+	auto terrain = cb->gameState()->getTile(visitablePos())->getTerrainID();
+	auto app = handler->getOverride(terrain, this);
+	if (app)
+		appearance = app;
+}
+
+void CGHeroInstance::initHero(vstd::RNG & rand)
 {
 	assert(validTypes(true));
-	if(!type)
-		type = getHeroType().toHeroType();
+	
+	if (gender == EHeroGender::DEFAULT)
+		gender = getHeroType()->gender;
 
 	if (ID == Obj::HERO)
-		appearance = VLC->objtypeh->getHandlerFor(Obj::HERO, type->heroClass->getIndex())->getTemplates().front();
+	{
+		auto handler = VLC->objtypeh->getHandlerFor(Obj::HERO, getHeroClass()->getIndex());;
+		appearance = handler->getTemplates().front();
+	}
 
 	if(!vstd::contains(spells, SpellID::PRESET))
 	{
 		// hero starts with default spells
-		for(const auto & spellID : type->spells)
+		for(const auto & spellID : getHeroType()->spells)
 			spells.insert(spellID);
 	}
 	else //remove placeholder
@@ -340,9 +390,9 @@
 	if(!vstd::contains(spells, SpellID::SPELLBOOK_PRESET))
 	{
 		// hero starts with default spellbook presence status
-		if(!getArt(ArtifactPosition::SPELLBOOK) && type->haveSpellBook)
+		if(!getArt(ArtifactPosition::SPELLBOOK) && getHeroType()->haveSpellBook)
 		{
-			auto artifact = ArtifactUtils::createNewArtifactInstance(ArtifactID::SPELLBOOK);
+			auto artifact = ArtifactUtils::createArtifact(ArtifactID::SPELLBOOK);
 			putArtifact(ArtifactPosition::SPELLBOOK, artifact);
 		}
 	}
@@ -351,7 +401,7 @@
 
 	if(!getArt(ArtifactPosition::MACH4))
 	{
-		auto artifact = ArtifactUtils::createNewArtifactInstance(ArtifactID::CATAPULT);
+		auto artifact = ArtifactUtils::createArtifact(ArtifactID::CATAPULT);
 		putArtifact(ArtifactPosition::MACH4, artifact); //everyone has a catapult
 	}
 
@@ -359,14 +409,11 @@
 	{
 		for(int g=0; g<GameConstants::PRIMARY_SKILLS; ++g)
 		{
-			pushPrimSkill(static_cast<PrimarySkill>(g), type->heroClass->primarySkillInitial[g]);
+			pushPrimSkill(static_cast<PrimarySkill>(g), getHeroClass()->primarySkillInitial[g]);
 		}
 	}
 	if(secSkills.size() == 1 && secSkills[0] == std::pair<SecondarySkill,ui8>(SecondarySkill::NONE, -1)) //set secondary skills to default
-		secSkills = type->secSkillsInit;
-
-	if (gender == EHeroGender::DEFAULT)
-		gender = type->gender;
+		secSkills = getHeroType()->secSkillsInit;
 
 	setFormation(EArmyFormation::LOOSE);
 	if (!stacksCount()) //standard army//initial army
@@ -392,7 +439,7 @@
 	// are not attached to global bonus node but need access to some global bonuses
 	// e.g. MANA_PER_KNOWLEDGE_PERCENTAGE for correct preview and initial state after recruit	for(const auto & ob : VLC->modh->heroBaseBonuses)
 	// or MOVEMENT to compute initial movement before recruiting is finished
-	const JsonNode & baseBonuses = VLC->settings()->getValue(EGameSettings::BONUSES_PER_HERO);
+	const JsonNode & baseBonuses = cb->getSettings().getValue(EGameSettings::BONUSES_PER_HERO);
 	for(const auto & b : baseBonuses.Struct())
 	{
 		auto bonus = JsonUtils::parseBonus(b.second);
@@ -402,9 +449,9 @@
 		addNewBonus(bonus);
 	}
 
-	if (VLC->settings()->getBoolean(EGameSettings::MODULE_COMMANDERS) && !commander && type->heroClass->commander.hasValue())
+	if (cb->getSettings().getBoolean(EGameSettings::MODULE_COMMANDERS) && !commander && getHeroClass()->commander.hasValue())
 	{
-		commander = new CCommanderInstance(type->heroClass->commander);
+		commander = new CCommanderInstance(getHeroClass()->commander);
 		commander->setArmyObj (castToArmyObj()); //TODO: separate function for setting commanders
 		commander->giveStackExp (exp); //after our exp is set
 	}
@@ -412,7 +459,7 @@
 	skillsInfo = SecondarySkillsInfo();
 
 	//copy active (probably growing) bonuses from hero prototype to hero object
-	for(const std::shared_ptr<Bonus> & b : type->specialty)
+	for(const std::shared_ptr<Bonus> & b : getHeroType()->specialty)
 		addNewBonus(b);
 
 	//initialize bonuses
@@ -422,24 +469,24 @@
 	mana = manaLimit(); //after all bonuses are taken into account, make sure this line is the last one
 }
 
-void CGHeroInstance::initArmy(CRandomGenerator & rand, IArmyDescriptor * dst)
+void CGHeroInstance::initArmy(vstd::RNG & rand, IArmyDescriptor * dst)
 {
 	if(!dst)
 		dst = this;
 
 	int warMachinesGiven = 0;
 
-	auto stacksCountChances = VLC->settings()->getVector(EGameSettings::HEROES_STARTING_STACKS_CHANCES);
+	auto stacksCountChances = cb->getSettings().getVector(EGameSettings::HEROES_STARTING_STACKS_CHANCES);
 	int stacksCountInitRandomNumber = rand.nextInt(1, 100);
 
-	size_t maxStacksCount = std::min(stacksCountChances.size(), type->initialArmy.size());
+	size_t maxStacksCount = std::min(stacksCountChances.size(), getHeroType()->initialArmy.size());
 
 	for(int stackNo=0; stackNo < maxStacksCount; stackNo++)
 	{
 		if (stacksCountInitRandomNumber > stacksCountChances[stackNo])
 			continue;
 
-		auto & stack = type->initialArmy[stackNo];
+		auto & stack = getHeroType()->initialArmy[stackNo];
 
 		int count = rand.nextInt(stack.minAmount, stack.maxAmount);
 
@@ -467,7 +514,7 @@
 
 				if(!getArt(slot))
 				{
-					auto artifact = ArtifactUtils::createNewArtifactInstance(aid);
+					auto artifact = ArtifactUtils::createArtifact(aid);
 					putArtifact(slot, artifact);
 				}
 				else
@@ -511,12 +558,12 @@
 			if(visitedTown) //we're in town
 				visitedTown->onHeroVisit(h); //town will handle attacking
 			else
-				cb->startBattleI(h,	this);
+				cb->startBattle(h,	this);
 		}
 	}
 	else if(ID == Obj::PRISON)
 	{
-		if (cb->getHeroCount(h->tempOwner, false) < VLC->settings()->getInteger(EGameSettings::HEROES_PER_PLAYER_ON_MAP_CAP))//free hero slot
+		if (cb->getHeroCount(h->tempOwner, false) < cb->getSettings().getInteger(EGameSettings::HEROES_PER_PLAYER_ON_MAP_CAP))//free hero slot
 		{
 			//update hero parameters
 			SetMovePoints smp;
@@ -532,7 +579,7 @@
 				if (!boat)
 				{
 					//Create a new boat for hero
-					cb->createObject(boatPos, h->getOwner(), Obj::BOAT, getBoatType().getNum());
+					cb->createBoat(boatPos, getBoatType(), h->getOwner());
 					boatId = cb->getTopObj(boatPos)->id;
 				}
 			}
@@ -566,13 +613,32 @@
 		return VLC->objtypeh->getObjectName(ID, 0);
 }
 
+std::string CGHeroInstance::getHoverText(PlayerColor player) const
+{
+	std::string hoverText = CArmedInstance::getHoverText(player) + getMovementPointsTextIfOwner(player);
+	return hoverText;
+}
+
+std::string CGHeroInstance::getMovementPointsTextIfOwner(PlayerColor player) const
+{
+	std::string output = "";
+	if(player == getOwner())
+	{
+		output += " " + VLC->generaltexth->translate("vcmi.adventureMap.movementPointsHeroInfo");
+		boost::replace_first(output, "%POINTS", std::to_string(movementPointsLimit(!boat)));
+		boost::replace_first(output, "%REMAINING", std::to_string(movementPointsRemaining()));
+	}
+
+	return output;
+}
+
 ui8 CGHeroInstance::maxlevelsToMagicSchool() const
 {
-	return type->heroClass->isMagicHero() ? 3 : 4;
+	return getHeroClass()->isMagicHero() ? 3 : 4;
 }
 ui8 CGHeroInstance::maxlevelsToWisdom() const
 {
-	return type->heroClass->isMagicHero() ? 3 : 6;
+	return getHeroClass()->isMagicHero() ? 3 : 6;
 }
 
 CGHeroInstance::SecondarySkillsInfo::SecondarySkillsInfo():
@@ -589,19 +655,18 @@
 	wisdomCounter = 0;
 }
 
-void CGHeroInstance::pickRandomObject(CRandomGenerator & rand)
+void CGHeroInstance::pickRandomObject(vstd::RNG & rand)
 {
 	assert(ID == Obj::HERO || ID == Obj::PRISON || ID == Obj::RANDOM_HERO);
 
 	if (ID == Obj::RANDOM_HERO)
 	{
+		auto selectedHero = cb->gameState()->pickNextHeroType(getOwner());
+
 		ID = Obj::HERO;
-		subID = cb->gameState()->pickNextHeroType(getOwner());
-		type = getHeroType().toHeroType();
-		randomizeArmy(type->heroClass->faction);
+		subID = selectedHero;
+		randomizeArmy(getHeroClass()->faction);
 	}
-	else
-		type = getHeroType().toHeroType();
 
 	auto oldSubID = subID;
 
@@ -609,16 +674,11 @@
 	// after setType subID used to store unique hero identify id. Check issue 2277 for details
 	// exclude prisons which should use appearance as set in map, via map editor or RMG
 	if (ID != Obj::PRISON)
-		setType(ID, type->heroClass->getIndex());
+		setType(ID, getHeroClass()->getIndex());
 
 	this->subID = oldSubID;
 }
 
-void CGHeroInstance::initObj(CRandomGenerator & rand)
-{
-
-}
-
 void CGHeroInstance::recreateSecondarySkillsBonuses()
 {
 	auto secondarySkillsBonuses = getBonuses(Selector::sourceType()(BonusSource::SECONDARY_SKILL));
@@ -651,7 +711,25 @@
 
 double CGHeroInstance::getMagicStrength() const
 {
-	return sqrt((1.0 + 0.05*getPrimSkillLevel(PrimarySkill::KNOWLEDGE)) * (1.0 + 0.05*getPrimSkillLevel(PrimarySkill::SPELL_POWER)));
+	if (!hasSpellbook())
+		return 1;
+	bool atLeastOneCombatSpell = false;
+	for (auto spell : spells)
+	{
+		if (spellbookContainsSpell(spell) && spell.toSpell()->isCombat())
+		{
+			atLeastOneCombatSpell = true;
+			break;
+		}
+	}
+	if (!atLeastOneCombatSpell)
+		return 1;
+	return sqrt((1.0 + 0.05*getPrimSkillLevel(PrimarySkill::KNOWLEDGE) * mana / manaLimit()) * (1.0 + 0.05*getPrimSkillLevel(PrimarySkill::SPELL_POWER) * mana / manaLimit()));
+}
+
+double CGHeroInstance::getMagicStrengthForCampaign() const
+{
+	return sqrt((1.0 + 0.05 * getPrimSkillLevel(PrimarySkill::KNOWLEDGE)) * (1.0 + 0.05 * getPrimSkillLevel(PrimarySkill::SPELL_POWER)));
 }
 
 double CGHeroInstance::getHeroStrength() const
@@ -659,9 +737,14 @@
 	return sqrt(pow(getFightingStrength(), 2.0) * pow(getMagicStrength(), 2.0));
 }
 
+double CGHeroInstance::getHeroStrengthForCampaign() const
+{
+	return sqrt(pow(getFightingStrength(), 2.0) * pow(getMagicStrengthForCampaign(), 2.0));
+}
+
 ui64 CGHeroInstance::getTotalStrength() const
 {
-	double ret = getFightingStrength() * getArmyStrength();
+	double ret = getHeroStrength() * getArmyStrength();
 	return static_cast<ui64>(ret);
 }
 
@@ -789,7 +872,7 @@
 		sm.hid = id;
 		sm.val = -spellCost;
 
-		server->apply(&sm);
+		server->apply(sm);
 	}
 }
 
@@ -885,7 +968,7 @@
 		double necromancySkill = valOfBonuses(BonusType::UNDEAD_RAISE_PERCENTAGE) / 100.0;
 		const ui8 necromancyLevel = valOfBonuses(BonusType::IMPROVED_NECROMANCY);
 		vstd::amin(necromancySkill, 1.0); //it's impossible to raise more creatures than all...
-		const std::map<CreatureID,si32> &casualties = battleResult.casualties[!battleResult.winner];
+		const std::map<CreatureID,si32> &casualties = battleResult.casualties[CBattleInfoEssentials::otherSide(battleResult.winner)];
 		// figure out what to raise - pick strongest creature meeting requirements
 		CreatureID creatureTypeRaised = CreatureID::NONE; //now we always have IMPROVED_NECROMANCY, no need for hardcode
 		int requiredCasualtyLevel = 1;
@@ -959,7 +1042,7 @@
  * @param raisedStack Pair where the first element represents ID of the raised creature
  * and the second element the amount.
  */
-void CGHeroInstance::showNecromancyDialog(const CStackBasicDescriptor &raisedStack, CRandomGenerator & rand) const
+void CGHeroInstance::showNecromancyDialog(const CStackBasicDescriptor &raisedStack, vstd::RNG & rand) const
 {
 	InfoWindow iw;
 	iw.type = EInfoWindowMode::AUTO;
@@ -1026,7 +1109,7 @@
 
 BoatId CGHeroInstance::getBoatType() const
 {
-	return BoatId(VLC->townh->getById(type->heroClass->faction)->getBoatType());
+	return BoatId(VLC->townh->getById(getHeroClass()->faction)->getBoatType());
 }
 
 void CGHeroInstance::getOutOffsets(std::vector<int3> &offsets) const
@@ -1065,10 +1148,10 @@
 
 EAlignment CGHeroInstance::getAlignment() const
 {
-	return type->heroClass->getAlignment();
+	return getHeroClass()->getAlignment();
 }
 
-void CGHeroInstance::initExp(CRandomGenerator & rand)
+void CGHeroInstance::initExp(vstd::RNG & rand)
 {
 	exp = rand.nextInt(40, 89);
 }
@@ -1089,12 +1172,12 @@
 	if (customPortraitSource.isValid())
 		return customPortraitSource;
 	else
-		return getHeroType();
+		return getHeroTypeID();
 }
 
 int32_t CGHeroInstance::getIconIndex() const
 {
-	return VLC->heroTypes()->getById(getPortraitSource())->getIconIndex();
+	return getPortraitSource().toEntity(VLC)->getIconIndex();
 }
 
 std::string CGHeroInstance::getNameTranslated() const
@@ -1111,15 +1194,15 @@
 {
 	if (isCampaignGem())
 		return "core.genrltxt.735";
-	return type->heroClass->getNameTextID();
+	return getHeroClass()->getNameTextID();
 }
 
 std::string CGHeroInstance::getNameTextID() const
 {
 	if (!nameCustomTextId.empty())
 		return nameCustomTextId;
-	if (type)
-		return type->getNameTextID();
+	if (getHeroTypeID().hasValue())
+		return getHeroType()->getNameTextID();
 
 	// FIXME: called by logging from some specialties (mods?) before type is set on deserialization
 	// assert(0);
@@ -1135,13 +1218,13 @@
 {
 	if (!biographyCustomTextId.empty())
 		return biographyCustomTextId;
-	if (type)
-		return type->getBiographyTextID();
+	if (getHeroTypeID().hasValue())
+		return getHeroType()->getBiographyTextID();
 	
 	return ""; //for random hero
 }
 
-CGHeroInstance::ArtPlacementMap CGHeroInstance::putArtifact(ArtifactPosition pos, CArtifactInstance * art)
+CGHeroInstance::ArtPlacementMap CGHeroInstance::putArtifact(const ArtifactPosition & pos, CArtifactInstance * art)
 {
 	assert(art->canBePutAt(this, pos));
 
@@ -1150,7 +1233,7 @@
 	return CArtifactSet::putArtifact(pos, art);
 }
 
-void CGHeroInstance::removeArtifact(ArtifactPosition pos)
+void CGHeroInstance::removeArtifact(const ArtifactPosition & pos)
 {
 	auto art = getArt(pos);
 	assert(art);
@@ -1186,7 +1269,7 @@
 
 	if(hasSpellbook())
 	{
-		getArt(ArtifactPosition::SPELLBOOK)->removeFrom(*this, ArtifactPosition::SPELLBOOK);
+		cb->gameState()->map->removeArtifactInstance(*this, ArtifactPosition::SPELLBOOK);
 	}
 }
 
@@ -1286,7 +1369,7 @@
 	return ArtBearer::HERO;
 }
 
-std::vector<SecondarySkill> CGHeroInstance::getLevelUpProposedSecondarySkills(CRandomGenerator & rand) const
+std::vector<SecondarySkill> CGHeroInstance::getLevelUpProposedSecondarySkills(vstd::RNG & rand) const
 {
 	auto getObligatorySkills = [](CSkill::Obligatory obl){
 		std::set<SecondarySkill> obligatory;
@@ -1334,11 +1417,11 @@
 		SecondarySkill selection;
 
 		if (selectWisdom)
-			selection = type->heroClass->chooseSecSkill(intersect(options, wisdomList), rand);
+			selection = getHeroClass()->chooseSecSkill(intersect(options, wisdomList), rand);
 		else if (selectSchool)
-			selection = type->heroClass->chooseSecSkill(intersect(options, schoolList), rand);
+			selection = getHeroClass()->chooseSecSkill(intersect(options, schoolList), rand);
 		else
-			selection = type->heroClass->chooseSecSkill(options, rand);
+			selection = getHeroClass()->chooseSecSkill(options, rand);
 
 		skills.push_back(selection);
 		options.erase(selection);
@@ -1365,11 +1448,11 @@
 	return skills;
 }
 
-PrimarySkill CGHeroInstance::nextPrimarySkill(CRandomGenerator & rand) const
+PrimarySkill CGHeroInstance::nextPrimarySkill(vstd::RNG & rand) const
 {
 	assert(gainsLevel());
 	const auto isLowLevelHero = level < GameConstants::HERO_HIGH_LEVEL;
-	const auto & skillChances = isLowLevelHero ? type->heroClass->primarySkillLowLevel : type->heroClass->primarySkillHighLevel;
+	const auto & skillChances = isLowLevelHero ? getHeroClass()->primarySkillLowLevel : getHeroClass()->primarySkillHighLevel;
 
 	if (isCampaignYog())
 	{
@@ -1381,7 +1464,7 @@
 	return static_cast<PrimarySkill>(RandomGeneratorUtil::nextItemWeighted(skillChances, rand));
 }
 
-std::optional<SecondarySkill> CGHeroInstance::nextSecondarySkill(CRandomGenerator & rand) const
+std::optional<SecondarySkill> CGHeroInstance::nextSecondarySkill(vstd::RNG & rand) const
 {
 	assert(gainsLevel());
 
@@ -1469,7 +1552,7 @@
 	treeHasChanged();
 }
 
-void CGHeroInstance::levelUpAutomatically(CRandomGenerator & rand)
+void CGHeroInstance::levelUpAutomatically(vstd::RNG & rand)
 {
 	while(gainsLevel())
 	{
@@ -1499,35 +1582,25 @@
 	if (visionsMultiplier > 0)
 		vstd::amax(visionsRange, 3); //minimum range is 3 tiles, but only if VISIONS bonus present
 
-	const int distance = static_cast<int>(target->pos.dist2d(visitablePos()));
+	const int distance = static_cast<int>(target->anchorPos().dist2d(visitablePos()));
 
 	//logGlobal->debug(boost::str(boost::format("Visions: dist %d, mult %d, range %d") % distance % visionsMultiplier % visionsRange));
 
-	return (distance < visionsRange) && (target->pos.z == pos.z);
+	return (distance < visionsRange) && (target->anchorPos().z == anchorPos().z);
 }
 
 std::string CGHeroInstance::getHeroTypeName() const
 {
 	if(ID == Obj::HERO || ID == Obj::PRISON)
-	{
-		if(type)
-		{
-			return type->getJsonKey();
-		}
-		else
-		{
-			return getHeroType().toEntity(VLC)->getJsonKey();
-		}
-	}
+		return getHeroType()->getJsonKey();
+
 	return "";
 }
 
 void CGHeroInstance::afterAddToMap(CMap * map)
 {
 	if(ID != Obj::PRISON)
-	{		
 		map->heroesOnMap.emplace_back(this);
-	}
 }
 void CGHeroInstance::afterRemoveFromMap(CMap* map)
 {
@@ -1690,7 +1763,7 @@
 	handler.serializeIdArray("spellBook", spells);
 
 	if(handler.saving)
-		CArtifactSet::serializeJsonArtifacts(handler, "artifacts", nullptr);
+		CArtifactSet::serializeJsonArtifacts(handler, "artifacts");
 }
 
 void CGHeroInstance::serializeJsonOptions(JsonSerializeFormat & handler)
@@ -1714,29 +1787,27 @@
 		if(!appearance)
 		{
 			// crossoverDeserialize
-			type = getHeroType().toHeroType();
-			appearance = VLC->objtypeh->getHandlerFor(Obj::HERO, type->heroClass->getIndex())->getTemplates().front();
+			appearance = VLC->objtypeh->getHandlerFor(Obj::HERO, getHeroClassID())->getTemplates().front();
 		}
 	}
 
 	CArmedInstance::serializeJsonOptions(handler);
 
 	{
-		static constexpr int NO_PATROLING = -1;
-		int rawPatrolRadius = NO_PATROLING;
+		ui32 rawPatrolRadius = NO_PATROLLING;
 
 		if(handler.saving)
 		{
-			rawPatrolRadius = patrol.patrolling ? patrol.patrolRadius : NO_PATROLING;
+			rawPatrolRadius = patrol.patrolling ? patrol.patrolRadius : NO_PATROLLING;
 		}
 
-		handler.serializeInt("patrolRadius", rawPatrolRadius, NO_PATROLING);
+		handler.serializeInt("patrolRadius", rawPatrolRadius, NO_PATROLLING);
 
 		if(!handler.saving)
 		{
-			patrol.patrolling = (rawPatrolRadius > NO_PATROLING);
+			patrol.patrolling = (rawPatrolRadius != NO_PATROLLING);
 			patrol.initialPos = visitablePos();
-			patrol.patrolRadius = (rawPatrolRadius > NO_PATROLING) ? rawPatrolRadius : 0;
+			patrol.patrolRadius = patrol.patrolling ? rawPatrolRadius : 0;
 		}
 	}
 }
@@ -1778,14 +1849,14 @@
 
 void CGHeroInstance::fillUpgradeInfo(UpgradeInfo & info, const CStackInstance &stack) const
 {
-	TConstBonusListPtr lista = getBonuses(Selector::typeSubtype(BonusType::SPECIAL_UPGRADE, BonusSubtypeID(stack.type->getId())));
+	TConstBonusListPtr lista = getBonuses(Selector::typeSubtype(BonusType::SPECIAL_UPGRADE, BonusSubtypeID(stack.getId())));
 	for(const auto & it : *lista)
 	{
 		auto nid = CreatureID(it->additionalInfo[0]);
-		if (nid != stack.type->getId()) //in very specific case the upgrade is available by default (?)
+		if (nid != stack.getId()) //in very specific case the upgrade is available by default (?)
 		{
 			info.newID.push_back(nid);
-			info.cost.push_back(nid.toCreature()->getFullRecruitCost() - stack.type->getFullRecruitCost());
+			info.cost.push_back(nid.toCreature()->getFullRecruitCost() - stack.getType()->getFullRecruitCost());
 		}
 	}
 }
@@ -1802,7 +1873,7 @@
 	if (!boost::starts_with(campaign, "DATA/YOG")) // "Birth of a Barbarian"
 		return false;
 
-	if (getHeroType() != HeroTypeID::SOLMYR) // Yog (based on Solmyr)
+	if (getHeroTypeID() != HeroTypeID::SOLMYR) // Yog (based on Solmyr)
 		return false;
 
 	return true;
@@ -1820,10 +1891,39 @@
 	if (!boost::starts_with(campaign, "DATA/GEM") &&  !boost::starts_with(campaign, "DATA/FINAL")) // "New Beginning" and "Unholy Alliance"
 		return false;
 
-	if (getHeroType() != HeroTypeID::GEM) // Yog (based on Solmyr)
+	if (getHeroTypeID() != HeroTypeID::GEM) // Yog (based on Solmyr)
 		return false;
 
 	return true;
 }
 
+ResourceSet CGHeroInstance::dailyIncome() const
+{
+	ResourceSet income;
+
+	for (GameResID k : GameResID::ALL_RESOURCES())
+		income[k] += valOfBonuses(BonusType::GENERATE_RESOURCE, BonusSubtypeID(k));
+
+	const auto & playerSettings = cb->getPlayerSettings(getOwner());
+	income.applyHandicap(playerSettings->handicap.percentIncome);
+	return income;
+}
+
+std::vector<CreatureID> CGHeroInstance::providedCreatures() const
+{
+	return {};
+}
+
+const IOwnableObject * CGHeroInstance::asOwnable() const
+{
+	return this;
+}
+
+int CGHeroInstance::getBasePrimarySkillValue(PrimarySkill which) const
+{
+	std::string cachingStr = "type_PRIMARY_SKILL_base_" + std::to_string(static_cast<int>(which));
+	auto selector = Selector::typeSubtype(BonusType::PRIMARY_SKILL, BonusSubtypeID(which)).And(Selector::sourceType()(BonusSource::HERO_BASE_SKILL));
+	return valOfBonuses(selector, cachingStr);
+}
+
 VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/mapObjects/CGHeroInstance.h vcmi/lib/mapObjects/CGHeroInstance.h
--- vcmi-1.5.7/lib/mapObjects/CGHeroInstance.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapObjects/CGHeroInstance.h	2024-12-19 15:00:22.912148516 +0100
@@ -12,7 +12,9 @@
 #include <vcmi/spells/Caster.h>
 
 #include "CArmedInstance.h"
+#include "IOwnableObject.h"
 
+#include "../entities/hero/EHeroGender.h"
 #include "../CArtHandler.h" // For CArtifactSet
 
 VCMI_LIB_NAMESPACE_BEGIN
@@ -23,7 +25,6 @@
 class CMap;
 struct TerrainTile;
 struct TurnInfo;
-enum class EHeroGender : int8_t;
 
 class DLL_LINKAGE CGHeroPlaceholder : public CGObjectInstance
 {
@@ -48,7 +49,7 @@
 };
 
 
-class DLL_LINKAGE CGHeroInstance : public CArmedInstance, public IBoatGenerator, public CArtifactSet, public spells::Caster, public AFactionMember, public ICreatureUpgrader
+class DLL_LINKAGE CGHeroInstance : public CArmedInstance, public IBoatGenerator, public CArtifactSet, public spells::Caster, public AFactionMember, public ICreatureUpgrader, public IOwnableObject
 {
 	// We serialize heroes into JSON for crossover
 	friend class CampaignState;
@@ -71,7 +72,6 @@
 
 	//////////////////////////////////////////////////////////////////////////
 
-	const CHero * type;
 	TExpType exp; //experience points
 	ui32 level; //current level of hero
 
@@ -92,6 +92,7 @@
 	static constexpr si32 UNINITIALIZED_MANA = -1;
 	static constexpr ui32 UNINITIALIZED_MOVEMENT = -1;
 	static constexpr auto UNINITIALIZED_EXPERIENCE = std::numeric_limits<TExpType>::max();
+	static const ui32 NO_PATROLLING;
 
 	//std::vector<const CArtifact*> artifacts; //hero's artifacts from bag
 	//std::map<ui16, const CArtifact*> artifWorn; //map<position,artifact_id>; positions: 0 - head; 1 - shoulders; 2 - neck; 3 - right hand; 4 - left hand; 5 - torso; 6 - right ring; 7 - left ring; 8 - feet; 9 - misc1; 10 - misc2; 11 - misc3; 12 - misc4; 13 - mach1; 14 - mach2; 15 - mach3; 16 - mach4; 17 - spellbook; 18 - misc5
@@ -99,10 +100,9 @@
 
 	struct DLL_LINKAGE Patrol
 	{
-		Patrol(){patrolling=false;initialPos=int3();patrolRadius=-1;};
-		bool patrolling;
+		bool patrolling{false};
 		int3 initialPos;
-		ui32 patrolRadius;
+		ui32 patrolRadius{NO_PATROLLING};
 		template <typename Handler> void serialize(Handler &h)
 		{
 			h & patrolling;
@@ -165,8 +165,12 @@
 	EAlignment getAlignment() const;
 	bool needsLastStack()const override;
 
+	ResourceSet dailyIncome() const override;
+	std::vector<CreatureID> providedCreatures() const override;
+	const IOwnableObject * asOwnable() const final;
+
 	//INativeTerrainProvider
-	FactionID getFaction() const override;
+	FactionID getFactionID() const override;
 	TerrainId getNativeTerrain() const override;
 	int getLowestCreatureSpeed() const;
 	si32 manaRegain() const; //how many points of mana can hero regain "naturally" in one day
@@ -187,13 +191,13 @@
 	bool gainsLevel() const;
 
 	/// Returns the next primary skill on level up. Can only be called if hero can gain a level up.
-	PrimarySkill nextPrimarySkill(CRandomGenerator & rand) const;
+	PrimarySkill nextPrimarySkill(vstd::RNG & rand) const;
 
 	/// Returns the next secondary skill randomly on level up. Can only be called if hero can gain a level up.
-	std::optional<SecondarySkill> nextSecondarySkill(CRandomGenerator & rand) const;
+	std::optional<SecondarySkill> nextSecondarySkill(vstd::RNG & rand) const;
 
 	/// Gets 0, 1 or 2 secondary skills which are proposed on hero level up.
-	std::vector<SecondarySkill> getLevelUpProposedSecondarySkills(CRandomGenerator & rand) const;
+	std::vector<SecondarySkill> getLevelUpProposedSecondarySkills(vstd::RNG & rand) const;
 
 	ui8 getSecSkillLevel(const SecondarySkill & skill) const; //0 - no skill
 
@@ -219,27 +223,35 @@
 	int movementPointsAfterEmbark(int MPsBefore, int basicCost, bool disembark = false, const TurnInfo * ti = nullptr) const;
 
 	double getFightingStrength() const; // takes attack / defense skill into account
-	double getMagicStrength() const; // takes knowledge / spell power skill into account
+	double getMagicStrength() const; // takes knowledge / spell power skill but also current mana, whether the hero owns a spell-book and whether that books contains anything into account
+	double getMagicStrengthForCampaign() const; // takes knowledge / spell power skill into account
 	double getHeroStrength() const; // includes fighting and magic strength
+	double getHeroStrengthForCampaign() const; // includes fighting and the for-campaign-version of magic strength
 	ui64 getTotalStrength() const; // includes fighting strength and army strength
 	TExpType calculateXp(TExpType exp) const; //apply learning skill
+	int getBasePrimarySkillValue(PrimarySkill which) const; //the value of a base-skill without items or temporary bonuses
 
 	CStackBasicDescriptor calculateNecromancy (const BattleResult &battleResult) const;
-	void showNecromancyDialog(const CStackBasicDescriptor &raisedStack, CRandomGenerator & rand) const;
+	void showNecromancyDialog(const CStackBasicDescriptor &raisedStack, vstd::RNG & rand) const;
 	EDiggingStatus diggingStatus() const;
 
 	//////////////////////////////////////////////////////////////////////////
 
-	HeroTypeID getHeroType() const;
-	void setHeroType(HeroTypeID type);
+	const CHeroClass * getHeroClass() const;
+	HeroClassID getHeroClassID() const;
 
-	void initHero(CRandomGenerator & rand);
-	void initHero(CRandomGenerator & rand, const HeroTypeID & SUBID);
+	const CHero * getHeroType() const;
+	HeroTypeID getHeroTypeID() const;
+	void setHeroType(HeroTypeID type);
 
-	ArtPlacementMap putArtifact(ArtifactPosition pos, CArtifactInstance * art) override;
-	void removeArtifact(ArtifactPosition pos) override;
-	void initExp(CRandomGenerator & rand);
-	void initArmy(CRandomGenerator & rand, IArmyDescriptor *dst = nullptr);
+	void initObj(vstd::RNG & rand) override;
+	void initHero(vstd::RNG & rand);
+	void initHero(vstd::RNG & rand, const HeroTypeID & SUBID);
+
+	ArtPlacementMap putArtifact(const ArtifactPosition & pos, CArtifactInstance * art) override;
+	void removeArtifact(const ArtifactPosition & pos) override;
+	void initExp(vstd::RNG & rand);
+	void initArmy(vstd::RNG & rand, IArmyDescriptor *dst = nullptr);
 	void pushPrimSkill(PrimarySkill which, int val);
 	ui8 maxlevelsToMagicSchool() const;
 	ui8 maxlevelsToWisdom() const;
@@ -292,11 +304,15 @@
 	void attachToBoat(CGBoat* newBoat);
 	void boatDeserializationFix();
 	void deserializationFix();
+	void updateAppearance();
 
-	void initObj(CRandomGenerator & rand) override;
-	void pickRandomObject(CRandomGenerator & rand) override;
+	void pickRandomObject(vstd::RNG & rand) override;
 	void onHeroVisit(const CGHeroInstance * h) const override;
 	std::string getObjectName() const override;
+	std::string getHoverText(PlayerColor player) const override;
+	std::string getMovementPointsTextIfOwner(PlayerColor player) const;
+
+	TObjectTypeHandler getObjectHandler() const override;
 
 	void afterAddToMap(CMap * map) override;
 	void afterRemoveFromMap(CMap * map) override;
@@ -318,7 +334,7 @@
 	void serializeJsonOptions(JsonSerializeFormat & handler) override;
 
 private:
-	void levelUpAutomatically(CRandomGenerator & rand);
+	void levelUpAutomatically(vstd::RNG & rand);
 
 public:
 	std::string getHeroTypeName() const;
@@ -346,7 +362,14 @@
 		h & skillsInfo;
 		h & visitedTown;
 		h & boat;
-		h & type;
+		if (h.version < Handler::Version::REMOVE_TOWN_PTR)
+		{
+			HeroTypeID type;
+			bool isNull = false;
+			h & isNull;
+			if(!isNull)
+				h & type;
+		}
 		h & commander;
 		h & visitedObjects;
 		BONUS_TREE_DESERIALIZATION_FIX
diff --color -urN vcmi-1.5.7/lib/mapObjects/CGMarket.cpp vcmi/lib/mapObjects/CGMarket.cpp
--- vcmi-1.5.7/lib/mapObjects/CGMarket.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapObjects/CGMarket.cpp	2024-12-19 15:00:22.912148516 +0100
@@ -11,19 +11,25 @@
 #include "StdInc.h"
 #include "CGMarket.h"
 
-#include "../CGeneralTextHandler.h"
+#include "../texts/CGeneralTextHandler.h"
 #include "../IGameCallback.h"
 #include "../CCreatureHandler.h"
 #include "CGTownInstance.h"
-#include "../GameSettings.h"
+#include "../IGameSettings.h"
 #include "../CSkillHandler.h"
 #include "../mapObjectConstructors/AObjectTypeHandler.h"
 #include "../mapObjectConstructors/CObjectClassesHandler.h"
+#include "../mapObjectConstructors/CommonConstructors.h"
 #include "../networkPacks/PacksForClient.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
-void CGMarket::initObj(CRandomGenerator & rand)
+ObjectInstanceID CGMarket::getObjInstanceID() const
+{
+	return id;
+}
+
+void CGMarket::initObj(vstd::RNG & rand)
 {
 	getObjectHandler()->configureObject(this, rand);
 }
@@ -33,14 +39,25 @@
 	cb->showObjectWindow(this, EOpenWindowMode::MARKET_WINDOW, h, true);
 }
 
-int CGMarket::getMarketEfficiency() const
+std::string CGMarket::getPopupText(PlayerColor player) const
+{
+	if (!getMarketHandler()->hasDescription())
+		return getHoverText(player);
+
+	MetaString message = MetaString::createFromRawString("{%s}\r\n\r\n%s");
+	message.replaceName(ID);
+	message.replaceTextID(TextIdentifier(getObjectHandler()->getBaseTextID(), "description").get());
+	return message.toString();
+}
+
+std::string CGMarket::getPopupText(const CGHeroInstance * hero) const
 {
-	return marketEfficiency;
+	return getPopupText(hero->getOwner());
 }
 
-bool CGMarket::allowsTrade(EMarketMode mode) const
+int CGMarket::getMarketEfficiency() const
 {
-	return marketModes.count(mode);
+	return getMarketHandler()->getMarketEfficiency();
 }
 
 int CGMarket::availableUnits(EMarketMode mode, int marketItemSerial) const
@@ -48,11 +65,16 @@
 	return -1;
 }
 
-std::vector<TradeItemBuy> CGMarket::availableItemsIds(EMarketMode mode) const
+std::shared_ptr<MarketInstanceConstructor> CGMarket::getMarketHandler() const
+{
+	const auto & baseHandler = getObjectHandler();
+	const auto & ourHandler = std::dynamic_pointer_cast<MarketInstanceConstructor>(baseHandler);
+	return ourHandler;
+}
+
+std::set<EMarketMode> CGMarket::availableModes() const
 {
-	if(allowsTrade(mode))
-		return IMarket::availableItemsIds(mode);
-	return std::vector<TradeItemBuy>();
+	return getMarketHandler()->availableModes();
 }
 
 CGMarket::CGMarket(IGameCallback *cb):
@@ -63,16 +85,11 @@
 {
 	switch(mode)
 	{
-	case EMarketMode::ARTIFACT_RESOURCE:
-		return IMarket::availableItemsIds(mode);
 	case EMarketMode::RESOURCE_ARTIFACT:
 		{
 			std::vector<TradeItemBuy> ret;
-			for(const CArtifact *a : artifacts)
-				if(a)
-					ret.push_back(a->getId());
-				else
-					ret.push_back(ArtifactID{});
+			for(const auto & a : artifacts)
+				ret.push_back(a);
 			return ret;
 		}
 	default:
@@ -80,12 +97,12 @@
 	}
 }
 
-void CGBlackMarket::newTurn(CRandomGenerator & rand) const
+void CGBlackMarket::newTurn(vstd::RNG & rand) const
 {
-	int resetPeriod = VLC->settings()->getInteger(EGameSettings::MARKETS_BLACK_MARKET_RESTOCK_PERIOD);
+	int resetPeriod = cb->getSettings().getInteger(EGameSettings::MARKETS_BLACK_MARKET_RESTOCK_PERIOD);
 
 	bool isFirstDay = cb->getDate(Date::DAY) == 1;
-	bool regularResetTriggered = resetPeriod != 0 && ((cb->getDate(Date::DAY)-1) % resetPeriod) != 0;
+	bool regularResetTriggered = resetPeriod != 0 && ((cb->getDate(Date::DAY)-1) % resetPeriod) == 0;
 
 	if (!isFirstDay && !regularResetTriggered)
 		return;
@@ -93,7 +110,7 @@
 	SetAvailableArtifacts saa;
 	saa.id = id;
 	cb->pickAllowedArtsSet(saa.arts, rand);
-	cb->sendAndApply(&saa);
+	cb->sendAndApply(saa);
 }
 
 std::vector<TradeItemBuy> CGUniversity::availableItemsIds(EMarketMode mode) const
@@ -108,14 +125,14 @@
 	}
 }
 
-void CGUniversity::onHeroVisit(const CGHeroInstance * h) const
+std::string CGUniversity::getSpeechTranslated() const
 {
-	cb->showObjectWindow(this, EOpenWindowMode::UNIVERSITY_WINDOW, h, true);
+	return getMarketHandler()->getSpeechTranslated();
 }
 
-ArtBearer::ArtBearer CGArtifactsAltar::bearerType() const
+void CGUniversity::onHeroVisit(const CGHeroInstance * h) const
 {
-	return ArtBearer::ALTAR;
+	cb->showObjectWindow(this, EOpenWindowMode::UNIVERSITY_WINDOW, h, true);
 }
 
 VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/mapObjects/CGMarket.h vcmi/lib/mapObjects/CGMarket.h
--- vcmi-1.5.7/lib/mapObjects/CGMarket.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapObjects/CGMarket.h	2024-12-19 15:00:22.912148516 +0100
@@ -15,35 +15,57 @@
 
 VCMI_LIB_NAMESPACE_BEGIN
 
+class MarketInstanceConstructor;
+
 class DLL_LINKAGE CGMarket : public CGObjectInstance, public IMarket
 {
+protected:
+	std::shared_ptr<MarketInstanceConstructor> getMarketHandler() const;
+
 public:
-	
-	std::set<EMarketMode> marketModes;
-	int marketEfficiency;
-	
-	//window variables
-	std::string title;
-	std::string speech; //currently shown only in university
-	
 	CGMarket(IGameCallback *cb);
 	///IObjectInterface
 	void onHeroVisit(const CGHeroInstance * h) const override; //open trading window
-	void initObj(CRandomGenerator & rand) override;//set skills for trade
+	void initObj(vstd::RNG & rand) override;//set skills for trade
+
+	std::string getPopupText(PlayerColor player) const override;
+	std::string getPopupText(const CGHeroInstance * hero) const override;
 
 	///IMarket
+	ObjectInstanceID getObjInstanceID() const override;
 	int getMarketEfficiency() const override;
-	bool allowsTrade(EMarketMode mode) const override;
 	int availableUnits(EMarketMode mode, int marketItemSerial) const override; //-1 if unlimited
-	std::vector<TradeItemBuy> availableItemsIds(EMarketMode mode) const override;
+	std::set<EMarketMode> availableModes() const override;
 
-	template <typename Handler> void serialize(Handler &h)
+	template <typename Handler>
+	void serialize(Handler &h)
 	{
 		h & static_cast<CGObjectInstance&>(*this);
-		h & marketModes;
-		h & marketEfficiency;
-		h & title;
-		h & speech;
+		if (h.version < Handler::Version::NEW_MARKETS)
+		{
+			std::set<EMarketMode> marketModes;
+			h & marketModes;
+		}
+
+		if (h.version < Handler::Version::MARKET_TRANSLATION_FIX)
+		{
+			int unused = 0;
+			h & unused;
+		}
+
+		if (h.version < Handler::Version::NEW_MARKETS)
+		{
+			std::string speech;
+			std::string title;
+			h & speech;
+			h & title;
+		}
+	}
+
+	template <typename Handler> void serializeArtifactsAltar(Handler &h)
+	{
+		serialize(h);
+		IMarket::serializeArtifactsAltar(h);
 	}
 };
 
@@ -52,15 +74,32 @@
 public:
 	using CGMarket::CGMarket;
 
-	std::vector<const CArtifact *> artifacts; //available artifacts
+	std::vector<ArtifactID> artifacts; //available artifacts
 
-	void newTurn(CRandomGenerator & rand) const override; //reset artifacts for black market every month
+	void newTurn(vstd::RNG & rand) const override; //reset artifacts for black market every month
 	std::vector<TradeItemBuy> availableItemsIds(EMarketMode mode) const override;
 
 	template <typename Handler> void serialize(Handler &h)
 	{
 		h & static_cast<CGMarket&>(*this);
-		h & artifacts;
+		if (h.version < Handler::Version::REMOVE_VLC_POINTERS)
+		{
+			int32_t size = 0;
+			h & size;
+			for (int32_t i = 0; i < size; ++i)
+			{
+				bool isNull = false;
+				ArtifactID artifact;
+				h & isNull;
+				if (!isNull)
+					h & artifact;
+				artifacts.push_back(artifact);
+			}
+		}
+		else
+		{
+			h & artifacts;
+		}
 	}
 };
 
@@ -69,6 +108,8 @@
 public:
 	using CGMarket::CGMarket;
 
+	std::string getSpeechTranslated() const;
+
 	std::vector<TradeItemBuy> skills; //available skills
 
 	std::vector<TradeItemBuy> availableItemsIds(EMarketMode mode) const override;
@@ -78,20 +119,12 @@
 	{
 		h & static_cast<CGMarket&>(*this);
 		h & skills;
-	}
-};
-
-class DLL_LINKAGE CGArtifactsAltar : public CGMarket, public CArtifactSet
-{
-public:
-	using CGMarket::CGMarket;
-
-	ArtBearer::ArtBearer bearerType() const override;
-
-	template <typename Handler> void serialize(Handler & h)
-	{
-		h & static_cast<CGMarket&>(*this);
-		h & static_cast<CArtifactSet&>(*this);
+		if (h.version >= Handler::Version::NEW_MARKETS && h.version < Handler::Version::MARKET_TRANSLATION_FIX)
+		{
+			std::string temp;
+			h & temp;
+			h & temp;
+		}
 	}
 };
 
diff --color -urN vcmi-1.5.7/lib/mapObjects/CGObjectInstance.cpp vcmi/lib/mapObjects/CGObjectInstance.cpp
--- vcmi-1.5.7/lib/mapObjects/CGObjectInstance.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapObjects/CGObjectInstance.cpp	2024-12-19 15:00:22.912148516 +0100
@@ -15,7 +15,7 @@
 #include "ObjectTemplate.h"
 
 #include "../gameState/CGameState.h"
-#include "../CGeneralTextHandler.h"
+#include "../texts/CGeneralTextHandler.h"
 #include "../IGameCallback.h"
 #include "../constants/StringConstants.h"
 #include "../TerrainHandler.h"
@@ -25,6 +25,8 @@
 #include "../networkPacks/PacksForClient.h"
 #include "../serializer/JsonSerializeFormat.h"
 
+#include <vstd/RNG.h>
+
 VCMI_LIB_NAMESPACE_BEGIN
 
 //TODO: remove constructor
@@ -52,14 +54,14 @@
 	return subID;
 }
 
-int3 CGObjectInstance::getPosition() const
+int3 CGObjectInstance::anchorPos() const
 {
 	return pos;
 }
 
 int3 CGObjectInstance::getTopVisiblePos() const
 {
-	return pos - appearance->getTopVisibleOffset();
+	return anchorPos() - appearance->getTopVisibleOffset();
 }
 
 void CGObjectInstance::setOwner(const PlayerColor & ow)
@@ -67,6 +69,11 @@
 	tempOwner = ow;
 }
 
+void CGObjectInstance::setAnchorPos(int3 newPos)
+{
+	pos = newPos;
+}
+
 int CGObjectInstance::getWidth() const
 {
 	return appearance->getWidth();
@@ -77,32 +84,19 @@
 	return appearance->getHeight();
 }
 
-bool CGObjectInstance::visitableAt(int x, int y) const
-{
-	return appearance->isVisitableAt(pos.x - x, pos.y - y);
-}
-bool CGObjectInstance::blockingAt(int x, int y) const
-{
-	return appearance->isBlockedAt(pos.x - x, pos.y - y);
-}
-
-bool CGObjectInstance::coveringAt(int x, int y) const
-{
-	return appearance->isVisibleAt(pos.x - x, pos.y - y);
-}
-
 bool CGObjectInstance::visitableAt(const int3 & testPos) const
 {
-	return pos.z == testPos.z && appearance->isVisitableAt(pos.x - testPos.x, pos.y - testPos.y);
+	return anchorPos().z == testPos.z && appearance->isVisitableAt(anchorPos().x - testPos.x, anchorPos().y - testPos.y);
 }
+
 bool CGObjectInstance::blockingAt(const int3 & testPos) const
 {
-	return pos.z == testPos.z && appearance->isBlockedAt(pos.x - testPos.x, pos.y - testPos.y);
+	return anchorPos().z == testPos.z && appearance->isBlockedAt(anchorPos().x - testPos.x, anchorPos().y - testPos.y);
 }
 
 bool CGObjectInstance::coveringAt(const int3 & testPos) const
 {
-	return pos.z == testPos.z && appearance->isVisibleAt(pos.x - testPos.x, pos.y - testPos.y);
+	return anchorPos().z == testPos.z && appearance->isVisibleAt(anchorPos().x - testPos.x, anchorPos().y - testPos.y);
 }
 
 std::set<int3> CGObjectInstance::getBlockedPos() const
@@ -113,7 +107,7 @@
 		for(int h=0; h<getHeight(); ++h)
 		{
 			if(appearance->isBlockedAt(w, h))
-				ret.insert(int3(pos.x - w, pos.y - h, pos.z));
+				ret.insert(int3(anchorPos().x - w, anchorPos().y - h, anchorPos().z));
 		}
 	}
 	return ret;
@@ -134,13 +128,13 @@
 	cb->gameState()->map->removeBlockVisTiles(this, true);
 	auto handler = VLC->objtypeh->getHandlerFor(newID, newSubID);
 
-	if(!handler->getTemplates(tile.terType->getId()).empty())
+	if(!handler->getTemplates(tile.getTerrainID()).empty())
 	{
-		appearance = handler->getTemplates(tile.terType->getId())[0];
+		appearance = handler->getTemplates(tile.getTerrainID())[0];
 	}
 	else
 	{
-		logGlobal->warn("Object %d:%d at %s has no templates suitable for terrain %s", newID, newSubID, visitablePos().toString(), tile.terType->getNameTranslated());
+		logGlobal->warn("Object %d:%d at %s has no templates suitable for terrain %s", newID, newSubID, visitablePos().toString(), tile.getTerrain()->getNameTranslated());
 		appearance = handler->getTemplates()[0]; // get at least some appearance since alternative is crash
 	}
 
@@ -164,12 +158,12 @@
 	cb->gameState()->map->addBlockVisTiles(this);
 }
 
-void CGObjectInstance::pickRandomObject(CRandomGenerator & rand)
+void CGObjectInstance::pickRandomObject(vstd::RNG & rand)
 {
 	// no-op
 }
 
-void CGObjectInstance::initObj(CRandomGenerator & rand)
+void CGObjectInstance::initObj(vstd::RNG & rand)
 {
 	// no-op
 }
@@ -198,6 +192,16 @@
 	return VLC->objtypeh->getHandlerFor(ID, subID);
 }
 
+std::string CGObjectInstance::getTypeName() const
+{
+	return getObjectHandler()->getTypeName();
+}
+
+std::string CGObjectInstance::getSubtypeName() const
+{
+	return getObjectHandler()->getSubTypeName();
+}
+
 void CGObjectInstance::setPropertyDer( ObjProperty what, ObjPropertyID identifier )
 {}
 
@@ -213,6 +217,8 @@
 
 int3 CGObjectInstance::getVisitableOffset() const
 {
+	if (!isVisitable())
+		logGlobal->debug("Attempt to access visitable offset on a non-visitable object!");
 	return appearance->getVisitableOffset();
 }
 
@@ -232,7 +238,7 @@
 	return VLC->objtypeh->getObjectName(ID, subID);
 }
 
-std::optional<AudioPath> CGObjectInstance::getAmbientSound() const
+std::optional<AudioPath> CGObjectInstance::getAmbientSound(vstd::RNG & rng) const
 {
 	const auto & sounds = VLC->objtypeh->getObjectSounds(ID, subID).ambient;
 	if(!sounds.empty())
@@ -241,20 +247,20 @@
 	return std::nullopt;
 }
 
-std::optional<AudioPath> CGObjectInstance::getVisitSound() const
+std::optional<AudioPath> CGObjectInstance::getVisitSound(vstd::RNG & rng) const
 {
 	const auto & sounds = VLC->objtypeh->getObjectSounds(ID, subID).visit;
 	if(!sounds.empty())
-		return *RandomGeneratorUtil::nextItem(sounds, CRandomGenerator::getDefault());
+		return *RandomGeneratorUtil::nextItem(sounds, rng);
 
 	return std::nullopt;
 }
 
-std::optional<AudioPath> CGObjectInstance::getRemovalSound() const
+std::optional<AudioPath> CGObjectInstance::getRemovalSound(vstd::RNG & rng) const
 {
 	const auto & sounds = VLC->objtypeh->getObjectSounds(ID, subID).removal;
 	if(!sounds.empty())
-		return *RandomGeneratorUtil::nextItem(sounds, CRandomGenerator::getDefault());
+		return *RandomGeneratorUtil::nextItem(sounds, rng);
 
 	return std::nullopt;
 }
@@ -311,6 +317,9 @@
 
 int3 CGObjectInstance::visitablePos() const
 {
+	if (!isVisitable())
+		logGlobal->debug("Attempt to access visitable position on a non-visitable object!");
+
 	return pos - getVisitableOffset();
 }
 
@@ -351,8 +360,11 @@
 	//only save here, loading is handled by map loader
 	if(handler.saving)
 	{
-		handler.serializeString("type", typeName);
-		handler.serializeString("subtype", subTypeName);
+		std::string ourTypeName = getTypeName();
+		std::string ourSubtypeName = getSubtypeName();
+
+		handler.serializeString("type", ourTypeName);
+		handler.serializeString("subtype", ourSubtypeName);
 
 		handler.serializeInt("x", pos.x);
 		handler.serializeInt("y", pos.y);
@@ -393,4 +405,9 @@
 	return VLC->objtypeh->getHandlerFor(ID, subID)->getBattlefield();
 }
 
+const IOwnableObject * CGObjectInstance::asOwnable() const
+{
+	return nullptr;
+}
+
 VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/mapObjects/CGObjectInstance.h vcmi/lib/mapObjects/CGObjectInstance.h
--- vcmi-1.5.7/lib/mapObjects/CGObjectInstance.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapObjects/CGObjectInstance.h	2024-12-19 15:00:22.912148516 +0100
@@ -10,10 +10,11 @@
 #pragma once
 
 #include "IObjectInterface.h"
+
+#include "../bonuses/BonusEnum.h"
 #include "../constants/EntityIdentifiers.h"
 #include "../filesystem/ResourcePath.h"
 #include "../int3.h"
-#include "../bonuses/BonusEnum.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
@@ -27,8 +28,6 @@
 class DLL_LINKAGE CGObjectInstance : public IObjectInterface
 {
 public:
-	/// Position of bottom-right corner of object on map
-	int3 pos;
 	/// Type of object, e.g. town, hero, creature.
 	MapObjectID ID;
 	/// Subtype of object, depends on type
@@ -40,9 +39,10 @@
 	/// Defines appearance of object on map (animation, blocked tiles, blit order, etc)
 	std::shared_ptr<const ObjectTemplate> appearance;
 
+	/// Position of bottom-right corner of object on map
+	int3 pos;
+
 	std::string instanceName;
-	std::string typeName;
-	std::string subTypeName;
 
 	CGObjectInstance(IGameCallback *cb);
 	~CGObjectInstance() override;
@@ -50,6 +50,9 @@
 	MapObjectID getObjGroupIndex() const override;
 	MapObjectSubID getObjTypeIndex() const override;
 
+	std::string getTypeName() const;
+	std::string getSubtypeName() const;
+
 	/// "center" tile from which the sight distance is calculated
 	int3 getSightCenter() const;
 	/// If true hero can visit this object only from neighbouring tiles and can't stand on this object
@@ -61,21 +64,19 @@
 		return this->tempOwner;
 	}
 	void setOwner(const PlayerColor & ow);
+	void setAnchorPos(int3 pos);
 
 	/** APPEARANCE ACCESSORS **/
 
 	int getWidth() const; //returns width of object graphic in tiles
 	int getHeight() const; //returns height of object graphic in tiles
 	int3 visitablePos() const override;
-	int3 getPosition() const override;
+	int3 anchorPos() const override;
 	int3 getTopVisiblePos() const;
-	bool visitableAt(int x, int y) const; //returns true if object is visitable at location (x, y) (h3m pos)
-	bool blockingAt(int x, int y) const; //returns true if object is blocking location (x, y) (h3m pos)
-	bool coveringAt(int x, int y) const; //returns true if object covers with picture location (x, y) (h3m pos)
-
-	bool visitableAt(const int3 & pos) const; //returns true if object is visitable at location (x, y) (h3m pos)
-	bool blockingAt (const int3 & pos) const; //returns true if object is blocking location (x, y) (h3m pos)
-	bool coveringAt (const int3 & pos) const; //returns true if object covers with picture location (x, y) (h3m pos)
+
+	bool visitableAt(const int3 & pos) const; //returns true if object is visitable at location
+	bool blockingAt (const int3 & pos) const; //returns true if object is blocking location
+	bool coveringAt (const int3 & pos) const; //returns true if object covers with picture location
 
 	std::set<int3> getBlockedPos() const; //returns set of positions blocked by this object
 	const std::set<int3> & getBlockedOffsets() const; //returns set of relative positions blocked by this object
@@ -96,11 +97,11 @@
 
 	virtual bool isTile2Terrain() const { return false; }
 
-	std::optional<AudioPath> getAmbientSound() const;
-	std::optional<AudioPath> getVisitSound() const;
-	std::optional<AudioPath> getRemovalSound() const;
+	std::optional<AudioPath> getAmbientSound(vstd::RNG & rng) const;
+	std::optional<AudioPath> getVisitSound(vstd::RNG & rng) const;
+	std::optional<AudioPath> getRemovalSound(vstd::RNG & rng) const;
 
-	TObjectTypeHandler getObjectHandler() const;
+	virtual TObjectTypeHandler getObjectHandler() const;
 
 	/** VIRTUAL METHODS **/
 
@@ -125,10 +126,12 @@
 	virtual std::vector<Component> getPopupComponents(PlayerColor player) const;
 	virtual std::vector<Component> getPopupComponents(const CGHeroInstance * hero) const;
 
+	const IOwnableObject * asOwnable() const override;
+
 	/** OVERRIDES OF IObjectInterface **/
 
-	void initObj(CRandomGenerator & rand) override;
-	void pickRandomObject(CRandomGenerator & rand) override;
+	void initObj(vstd::RNG & rand) override;
+	void pickRandomObject(vstd::RNG & rand) override;
 	void onHeroVisit(const CGHeroInstance * h) const override;
 	/// method for synchronous update. Note: For new properties classes should override setPropertyDer instead
 	void setProperty(ObjProperty what, ObjPropertyID identifier) final;
@@ -140,8 +143,12 @@
 	template <typename Handler> void serialize(Handler &h)
 	{
 		h & instanceName;
-		h & typeName;
-		h & subTypeName;
+		if (h.version < Handler::Version::REMOVE_OBJECT_TYPENAME)
+		{
+			std::string unused;
+			h & unused;
+			h & unused;
+		}
 		h & pos;
 		h & ID;
 		subID.serializeIdentifier(h, ID);
diff --color -urN vcmi-1.5.7/lib/mapObjects/CGPandoraBox.cpp vcmi/lib/mapObjects/CGPandoraBox.cpp
--- vcmi-1.5.7/lib/mapObjects/CGPandoraBox.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapObjects/CGPandoraBox.cpp	2024-12-19 15:00:22.913148557 +0100
@@ -41,7 +41,7 @@
 	}
 }
 
-void CGPandoraBox::initObj(CRandomGenerator & rand)
+void CGPandoraBox::initObj(vstd::RNG & rand)
 {
 	init();
 	
@@ -175,25 +175,25 @@
 	BlockingDialog bd (true, false);
 	bd.player = h->getOwner();
 	bd.text.appendLocalString(EMetaText::ADVOB_TXT, 14);
-	cb->showBlockingDialog(&bd);
+	cb->showBlockingDialog(this, &bd);
 }
 
 void CGPandoraBox::battleFinished(const CGHeroInstance *hero, const BattleResult &result) const
 {
-	if(result.winner == 0)
+	if(result.winner == BattleSide::ATTACKER)
 	{
 		CRewardableObject::onHeroVisit(hero);
 	}
 }
 
-void CGPandoraBox::blockingDialogAnswered(const CGHeroInstance *hero, ui32 answer) const
+void CGPandoraBox::blockingDialogAnswered(const CGHeroInstance *hero, int32_t answer) const
 {
 	if(answer)
 	{
 		if(stacksCount() > 0) //if pandora's box is protected by army
 		{
 			hero->showInfoDialog(16, 0, EInfoWindowMode::MODAL);
-			cb->startBattleI(hero, this); //grants things after battle
+			cb->startBattle(hero, this); //grants things after battle
 		}
 		else if(getAvailableRewards(hero, Rewardable::EEventType::EVENT_FIRST_VISIT).empty())
 		{
@@ -332,7 +332,7 @@
 		else
 			iw.text.appendLocalString(EMetaText::ADVOB_TXT, 16);
 		cb->showInfoDialog(&iw);
-		cb->startBattleI(h, this);
+		cb->startBattle(h, this);
 	}
 	else
 	{
diff --color -urN vcmi-1.5.7/lib/mapObjects/CGPandoraBox.h vcmi/lib/mapObjects/CGPandoraBox.h
--- vcmi-1.5.7/lib/mapObjects/CGPandoraBox.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapObjects/CGPandoraBox.h	2024-12-19 15:00:22.913148557 +0100
@@ -23,10 +23,10 @@
 
 	MetaString message;
 
-	void initObj(CRandomGenerator & rand) override;
+	void initObj(vstd::RNG & rand) override;
 	void onHeroVisit(const CGHeroInstance * h) const override;
 	void battleFinished(const CGHeroInstance *hero, const BattleResult &result) const override;
-	void blockingDialogAnswered(const CGHeroInstance *hero, ui32 answer) const override;
+	void blockingDialogAnswered(const CGHeroInstance *hero, int32_t answer) const override;
 
 	template <typename Handler> void serialize(Handler &h)
 	{
diff --color -urN vcmi-1.5.7/lib/mapObjects/CGTownBuilding.cpp vcmi/lib/mapObjects/CGTownBuilding.cpp
--- vcmi-1.5.7/lib/mapObjects/CGTownBuilding.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapObjects/CGTownBuilding.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,530 +0,0 @@
-/*
- * CGTownBuilding.cpp, part of VCMI engine
- *
- * Authors: listed in file AUTHORS in main folder
- *
- * License: GNU General Public License v2.0 or later
- * Full text of license available in license.txt file, in main folder
- *
- */
-
-#include "StdInc.h"
-#include "CGTownBuilding.h"
-#include "CGTownInstance.h"
-#include "../CGeneralTextHandler.h"
-#include "../IGameCallback.h"
-#include "../gameState/CGameState.h"
-#include "../mapObjects/CGHeroInstance.h"
-#include "../networkPacks/PacksForClient.h"
-
-VCMI_LIB_NAMESPACE_BEGIN
-
-CGTownBuilding::CGTownBuilding(IGameCallback * cb)
-	: IObjectInterface(cb)
-	, town(nullptr)
-{}
-
-CGTownBuilding::CGTownBuilding(CGTownInstance * town)
-	: IObjectInterface(town->cb)
-	, town(town)
-{}
-
-PlayerColor CGTownBuilding::getOwner() const
-{
-	return town->getOwner();
-}
-
-MapObjectID CGTownBuilding::getObjGroupIndex() const
-{
-	return -1;
-}
-
-MapObjectSubID CGTownBuilding::getObjTypeIndex() const
-{
-	return 0;
-}
-
-int3 CGTownBuilding::visitablePos() const
-{
-	return town->visitablePos();
-}
-
-int3 CGTownBuilding::getPosition() const
-{
-	return town->getPosition();
-}
-
-std::string CGTownBuilding::getVisitingBonusGreeting() const
-{
-	auto bonusGreeting = town->getTown()->getGreeting(bType);
-
-	if(!bonusGreeting.empty())
-		return bonusGreeting;
-
-	switch(bType)
-	{
-	case BuildingSubID::MANA_VORTEX:
-		bonusGreeting = std::string(VLC->generaltexth->translate("vcmi.townHall.greetingManaVortex"));
-		break;
-	case BuildingSubID::KNOWLEDGE_VISITING_BONUS:
-		bonusGreeting = std::string(VLC->generaltexth->translate("vcmi.townHall.greetingKnowledge"));
-		break;
-	case BuildingSubID::SPELL_POWER_VISITING_BONUS:
-		bonusGreeting = std::string(VLC->generaltexth->translate("vcmi.townHall.greetingSpellPower"));
-		break;
-	case BuildingSubID::ATTACK_VISITING_BONUS:
-		bonusGreeting = std::string(VLC->generaltexth->translate("vcmi.townHall.greetingAttack"));
-		break;
-	case BuildingSubID::EXPERIENCE_VISITING_BONUS:
-		bonusGreeting = std::string(VLC->generaltexth->translate("vcmi.townHall.greetingExperience"));
-		break;
-	case BuildingSubID::DEFENSE_VISITING_BONUS:
-		bonusGreeting = std::string(VLC->generaltexth->translate("vcmi.townHall.greetingDefence"));
-		break;
-	}
-	auto buildingName = town->getTown()->getSpecialBuilding(bType)->getNameTranslated();
-
-	if(bonusGreeting.empty())
-	{
-		bonusGreeting = "Error: Bonus greeting for '%s' is not localized.";
-		logGlobal->error("'%s' building of '%s' faction has not localized bonus greeting.", buildingName, town->getTown()->faction->getNameTranslated());
-	}
-	boost::algorithm::replace_first(bonusGreeting, "%s", buildingName);
-	town->getTown()->setGreeting(bType, bonusGreeting);
-	return bonusGreeting;
-}
-
-std::string CGTownBuilding::getCustomBonusGreeting(const Bonus & bonus) const
-{
-	if(bonus.type == BonusType::TOWN_MAGIC_WELL)
-	{
-		MetaString wellGreeting = MetaString::createFromTextID("vcmi.townHall.greetingInTownMagicWell");
-
-		wellGreeting.replaceTextID(town->getTown()->getSpecialBuilding(bType)->getNameTextID());
-		return wellGreeting.toString();
-	}
-
-	MetaString greeting = MetaString::createFromTextID("vcmi.townHall.greetingCustomBonus");
-
-	std::string paramTextID;
-	std::string until;
-
-	if(bonus.type == BonusType::MORALE)
-		paramTextID = "core.genrltxt.384"; // Morale
-
-	if(bonus.type == BonusType::LUCK)
-		paramTextID = "core.genrltxt.385"; // Luck
-
-	greeting.replaceTextID(town->getTown()->getSpecialBuilding(bType)->getNameTextID());
-	greeting.replaceNumber(bonus.val);
-	greeting.replaceTextID(paramTextID);
-
-	if (bonus.duration == BonusDuration::ONE_BATTLE)
-		greeting.replaceTextID("vcmi.townHall.greetingCustomUntil");
-	else
-		greeting.replaceRawString(".");
-
-	return greeting.toString();
-}
-
-COPWBonus::COPWBonus(IGameCallback *cb)
-	: CGTownBuilding(cb)
-{}
-
-COPWBonus::COPWBonus(const BuildingID & bid, BuildingSubID::EBuildingSubID subId, CGTownInstance * cgTown)
-	: CGTownBuilding(cgTown)
-{
-	bID = bid;
-	bType = subId;
-	indexOnTV = static_cast<si32>(town->bonusingBuildings.size());
-}
-
-void COPWBonus::setProperty(ObjProperty what, ObjPropertyID identifier)
-{
-	switch (what)
-	{
-		case ObjProperty::VISITORS:
-			visitors.insert(identifier.as<ObjectInstanceID>());
-			break;
-		case ObjProperty::STRUCTURE_CLEAR_VISITORS:
-			visitors.clear();
-			break;
-	}
-}
-
-void COPWBonus::onHeroVisit (const CGHeroInstance * h) const
-{
-	ObjectInstanceID heroID = h->id;
-	if(town->hasBuilt(bID))
-	{
-		InfoWindow iw;
-		iw.player = h->tempOwner;
-
-		switch (this->bType)
-		{
-		case BuildingSubID::STABLES:
-			if(!h->hasBonusFrom(BonusSource::OBJECT_TYPE, BonusSourceID(Obj(Obj::STABLES)))) //does not stack with advMap Stables
-			{
-				GiveBonus gb;
-				gb.bonus = Bonus(BonusDuration::ONE_WEEK, BonusType::MOVEMENT, BonusSource::OBJECT_TYPE, 600, BonusSourceID(Obj(Obj::STABLES)), BonusCustomSubtype::heroMovementLand);
-				gb.id = heroID;
-				cb->giveHeroBonus(&gb);
-
-				cb->setMovePoints(heroID, 600, false);
-
-				iw.text.appendRawString(VLC->generaltexth->allTexts[580]);
-				cb->showInfoDialog(&iw);
-			}
-			break;
-
-		case BuildingSubID::MANA_VORTEX:
-			if(visitors.empty())
-			{
-				if(h->mana < h->manaLimit() * 2)
-				{
-					cb->setManaPoints (heroID, 2 * h->manaLimit());
-					//TODO: investigate line below
-					//cb->setObjProperty (town->id, ObjProperty::VISITED, true);
-					iw.text.appendRawString(getVisitingBonusGreeting());
-					cb->showInfoDialog(&iw);
-					town->addHeroToStructureVisitors(h, indexOnTV);
-				}
-			}
-			break;
-		}
-	}
-}
-
-CTownBonus::CTownBonus(IGameCallback *cb)
-	: CGTownBuilding(cb)
-{}
-
-CTownBonus::CTownBonus(const BuildingID & index, BuildingSubID::EBuildingSubID subId, CGTownInstance * cgTown)
-	: CGTownBuilding(cgTown)
-{
-	bID = index;
-	bType = subId;
-	indexOnTV = static_cast<si32>(town->bonusingBuildings.size());
-}
-
-void CTownBonus::setProperty(ObjProperty what, ObjPropertyID identifier)
-{
-	if(what == ObjProperty::VISITORS)
-		visitors.insert(identifier.as<ObjectInstanceID>());
-}
-
-void CTownBonus::onHeroVisit (const CGHeroInstance * h) const
-{
-	ObjectInstanceID heroID = h->id;
-	if(town->hasBuilt(bID) && visitors.find(heroID) == visitors.end())
-	{
-		si64 val = 0;
-		InfoWindow iw;
-		PrimarySkill what = PrimarySkill::NONE;
-
-		switch(bType)
-		{
-		case BuildingSubID::KNOWLEDGE_VISITING_BONUS: //wall of knowledge
-			what = PrimarySkill::KNOWLEDGE;
-			val = 1;
-			iw.components.emplace_back(ComponentType::PRIM_SKILL, PrimarySkill::KNOWLEDGE, 1);
-			break;
-
-		case BuildingSubID::SPELL_POWER_VISITING_BONUS: //order of fire
-			what = PrimarySkill::SPELL_POWER;
-			val = 1;
-			iw.components.emplace_back(ComponentType::PRIM_SKILL, PrimarySkill::SPELL_POWER, 1);
-			break;
-
-		case BuildingSubID::ATTACK_VISITING_BONUS: //hall of Valhalla
-			what = PrimarySkill::ATTACK;
-			val = 1;
-			iw.components.emplace_back(ComponentType::PRIM_SKILL, PrimarySkill::ATTACK, 1);
-			break;
-
-		case BuildingSubID::EXPERIENCE_VISITING_BONUS: //academy of battle scholars
-			what = PrimarySkill::EXPERIENCE;
-			val = static_cast<int>(h->calculateXp(1000));
-			iw.components.emplace_back(ComponentType::EXPERIENCE, val);
-			break;
-
-		case BuildingSubID::DEFENSE_VISITING_BONUS: //cage of warlords
-			what = PrimarySkill::DEFENSE;
-			val = 1;
-			iw.components.emplace_back(ComponentType::PRIM_SKILL, PrimarySkill::DEFENSE, 1);
-			break;
-
-		case BuildingSubID::CUSTOM_VISITING_BONUS:
-			const auto building = town->getTown()->buildings.at(bID);
-			if(!h->hasBonusFrom(BonusSource::TOWN_STRUCTURE, BonusSourceID(building->getUniqueTypeID())))
-			{
-				const auto & bonuses = building->onVisitBonuses;
-				applyBonuses(const_cast<CGHeroInstance *>(h), bonuses);
-			}
-			break;
-		}
-
-		if(what != PrimarySkill::NONE)
-		{
-			iw.player = cb->getOwner(heroID);
-				iw.text.appendRawString(getVisitingBonusGreeting());
-			cb->showInfoDialog(&iw);
-			if (what == PrimarySkill::EXPERIENCE)
-				cb->giveExperience(cb->getHero(heroID), val);
-			else
-				cb->changePrimSkill(cb->getHero(heroID), what, val);
-
-			town->addHeroToStructureVisitors(h, indexOnTV);
-		}
-	}
-}
-
-void CTownBonus::applyBonuses(CGHeroInstance * h, const BonusList & bonuses) const
-{
-	auto addToVisitors = false;
-
-	for(const auto & bonus : bonuses)
-	{
-		GiveBonus gb;
-		InfoWindow iw;
-
-		if(bonus->type == BonusType::TOWN_MAGIC_WELL)
-		{
-			if(h->mana >= h->manaLimit())
-				return;
-			cb->setManaPoints(h->id, h->manaLimit());
-			bonus->duration = BonusDuration::ONE_DAY;
-		}
-		gb.bonus = * bonus;
-		gb.id = h->id;
-		cb->giveHeroBonus(&gb);
-
-		if(bonus->duration == BonusDuration::PERMANENT)
-			addToVisitors = true;
-
-		iw.player = cb->getOwner(h->id);
-		iw.text.appendRawString(getCustomBonusGreeting(gb.bonus));
-		cb->showInfoDialog(&iw);
-	}
-	if(addToVisitors)
-		town->addHeroToStructureVisitors(h, indexOnTV);
-}
-
-CTownRewardableBuilding::CTownRewardableBuilding(IGameCallback *cb)
-	: CGTownBuilding(cb)
-{}
-
-CTownRewardableBuilding::CTownRewardableBuilding(const BuildingID & index, BuildingSubID::EBuildingSubID subId, CGTownInstance * cgTown, CRandomGenerator & rand)
-	: CGTownBuilding(cgTown)
-{
-	bID = index;
-	bType = subId;
-	indexOnTV = static_cast<si32>(town->bonusingBuildings.size());
-	initObj(rand);
-}
-
-void CTownRewardableBuilding::initObj(CRandomGenerator & rand)
-{
-	assert(town && town->town);
-
-	auto building = town->town->buildings.at(bID);
-
-	building->rewardableObjectInfo.configureObject(configuration, rand, cb);
-	for(auto & rewardInfo : configuration.info)
-	{
-		for (auto & bonus : rewardInfo.reward.bonuses)
-		{
-			bonus.source = BonusSource::TOWN_STRUCTURE;
-			bonus.sid = BonusSourceID(building->getUniqueTypeID());
-		}
-	}
-}
-
-void CTownRewardableBuilding::newTurn(CRandomGenerator & rand) const
-{
-	if (configuration.resetParameters.period != 0 && cb->getDate(Date::DAY) > 1 && ((cb->getDate(Date::DAY)-1) % configuration.resetParameters.period) == 0)
-	{
-		if(configuration.resetParameters.rewards)
-		{
-			cb->setObjPropertyValue(town->id, ObjProperty::REWARD_RANDOMIZE, indexOnTV);
-		}
-		if(configuration.resetParameters.visitors)
-		{
-			cb->setObjPropertyValue(town->id, ObjProperty::STRUCTURE_CLEAR_VISITORS, indexOnTV);
-		}
-	}
-}
-
-void CTownRewardableBuilding::setProperty(ObjProperty what, ObjPropertyID identifier)
-{
-	switch (what)
-	{
-		case ObjProperty::VISITORS:
-			visitors.insert(identifier.as<ObjectInstanceID>());
-			break;
-		case ObjProperty::STRUCTURE_CLEAR_VISITORS:
-			visitors.clear();
-			break;
-		case ObjProperty::REWARD_RANDOMIZE:
-			initObj(cb->gameState()->getRandomGenerator());
-			break;
-		case ObjProperty::REWARD_SELECT:
-			selectedReward = identifier.getNum();
-			break;
-	}
-}
-
-void CTownRewardableBuilding::heroLevelUpDone(const CGHeroInstance *hero) const
-{
-	grantRewardAfterLevelup(cb, configuration.info.at(selectedReward), town, hero);
-}
-
-void CTownRewardableBuilding::blockingDialogAnswered(const CGHeroInstance *hero, ui32 answer) const
-{
-	if(answer == 0)
-		return; // player refused
-	
-	if(visitors.find(hero->id) != visitors.end())
-		return; // query not for this building
-
-	if(answer > 0 && answer-1 < configuration.info.size())
-	{
-		auto list = getAvailableRewards(hero, Rewardable::EEventType::EVENT_FIRST_VISIT);
-		grantReward(list[answer - 1], hero);
-	}
-	else
-	{
-		throw std::runtime_error("Unhandled choice");
-	}
-}
-
-void CTownRewardableBuilding::grantReward(ui32 rewardID, const CGHeroInstance * hero) const
-{
-	town->addHeroToStructureVisitors(hero, indexOnTV);
-	
-	grantRewardBeforeLevelup(cb, configuration.info.at(rewardID), hero);
-	
-	// hero is not blocked by levelup dialog - grant remainer immediately
-	if(!cb->isVisitCoveredByAnotherQuery(town, hero))
-	{
-		grantRewardAfterLevelup(cb, configuration.info.at(rewardID), town, hero);
-	}
-}
-
-bool CTownRewardableBuilding::wasVisitedBefore(const CGHeroInstance * contextHero) const
-{
-	switch (configuration.visitMode)
-	{
-		case Rewardable::VISIT_UNLIMITED:
-			return false;
-		case Rewardable::VISIT_ONCE:
-			return !visitors.empty();
-		case Rewardable::VISIT_PLAYER:
-			return false; //not supported
-		case Rewardable::VISIT_BONUS:
-		{
-			const auto building = town->getTown()->buildings.at(bID);
-			return contextHero->hasBonusFrom(BonusSource::TOWN_STRUCTURE, BonusSourceID(building->getUniqueTypeID()));
-		}
-		case Rewardable::VISIT_HERO:
-			return visitors.find(contextHero->id) != visitors.end();
-		case Rewardable::VISIT_LIMITER:
-			return configuration.visitLimiter.heroAllowed(contextHero);
-		default:
-			return false;
-	}
-}
-
-void CTownRewardableBuilding::onHeroVisit(const CGHeroInstance *h) const
-{
-	auto grantRewardWithMessage = [&](int index) -> void
-	{
-		auto vi = configuration.info.at(index);
-		logGlobal->debug("Granting reward %d. Message says: %s", index, vi.message.toString());
-		
-		town->addHeroToStructureVisitors(h, indexOnTV); //adding to visitors
-
-		InfoWindow iw;
-		iw.player = h->tempOwner;
-		iw.text = vi.message;
-		vi.reward.loadComponents(iw.components, h);
-		iw.type = EInfoWindowMode::MODAL;
-		if(!iw.components.empty() || !iw.text.toString().empty())
-			cb->showInfoDialog(&iw);
-		
-		grantReward(index, h);
-	};
-	auto selectRewardsMessage = [&](const std::vector<ui32> & rewards, const MetaString & dialog) -> void
-	{
-		BlockingDialog sd(configuration.canRefuse, rewards.size() > 1);
-		sd.player = h->tempOwner;
-		sd.text = dialog;
-
-		if (rewards.size() > 1)
-			for (auto index : rewards)
-				sd.components.push_back(configuration.info.at(index).reward.getDisplayedComponent(h));
-
-		if (rewards.size() == 1)
-			configuration.info.at(rewards.front()).reward.loadComponents(sd.components, h);
-
-		cb->showBlockingDialog(&sd);
-	};
-	
-	if(!town->hasBuilt(bID) || cb->isVisitCoveredByAnotherQuery(town, h))
-		return;
-
-	if(!wasVisitedBefore(h))
-	{
-		auto rewards = getAvailableRewards(h, Rewardable::EEventType::EVENT_FIRST_VISIT);
-
-		logGlobal->debug("Visiting object with %d possible rewards", rewards.size());
-		switch (rewards.size())
-		{
-			case 0: // no available rewards, e.g. visiting School of War without gold
-			{
-				auto emptyRewards = getAvailableRewards(h, Rewardable::EEventType::EVENT_NOT_AVAILABLE);
-				if (!emptyRewards.empty())
-					grantRewardWithMessage(emptyRewards[0]);
-				else
-					logMod->warn("No applicable message for visiting empty object!");
-				break;
-			}
-			case 1: // one reward. Just give it with message
-			{
-				if (configuration.canRefuse)
-					selectRewardsMessage(rewards, configuration.info.at(rewards.front()).message);
-				else
-					grantRewardWithMessage(rewards.front());
-				break;
-			}
-			default: // multiple rewards. Act according to select mode
-			{
-				switch (configuration.selectMode) {
-					case Rewardable::SELECT_PLAYER: // player must select
-						selectRewardsMessage(rewards, configuration.onSelect);
-						break;
-					case Rewardable::SELECT_FIRST: // give first available
-						grantRewardWithMessage(rewards.front());
-						break;
-					case Rewardable::SELECT_RANDOM: // give random
-						grantRewardWithMessage(*RandomGeneratorUtil::nextItem(rewards, cb->gameState()->getRandomGenerator()));
-						break;
-				}
-				break;
-			}
-		}
-	}
-	else
-	{
-		logGlobal->debug("Revisiting already visited object");
-
-		auto visitedRewards = getAvailableRewards(h, Rewardable::EEventType::EVENT_ALREADY_VISITED);
-		if (!visitedRewards.empty())
-			grantRewardWithMessage(visitedRewards[0]);
-		else
-			logMod->debug("No applicable message for visiting already visited object!");
-	}
-}
-
-
-VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/mapObjects/CGTownBuilding.h vcmi/lib/mapObjects/CGTownBuilding.h
--- vcmi-1.5.7/lib/mapObjects/CGTownBuilding.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapObjects/CGTownBuilding.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,147 +0,0 @@
-/*
- * CGTownBuilding.h, part of VCMI engine
- *
- * Authors: listed in file AUTHORS in main folder
- *
- * License: GNU General Public License v2.0 or later
- * Full text of license available in license.txt file, in main folder
- *
- */
-
-#pragma once
-
-#include "IObjectInterface.h"
-#include "../rewardable/Interface.h"
-
-VCMI_LIB_NAMESPACE_BEGIN
-
-class CGTownInstance;
-class CBuilding;
-
-class DLL_LINKAGE CGTownBuilding : public IObjectInterface
-{
-///basic class for town structures handled as map objects
-public:
-	CGTownBuilding(CGTownInstance * town);
-	CGTownBuilding(IGameCallback *cb);
-
-	si32 indexOnTV = 0; //identifies its index on towns vector
-	
-	CGTownInstance * town;
-
-	STRONG_INLINE
-	BuildingSubID::EBuildingSubID getBuildingSubtype() const
-	{
-		return bType;
-	}
-
-	STRONG_INLINE
-	const BuildingID & getBuildingType() const
-	{
-		return bID;
-	}
-
-	STRONG_INLINE
-	void setBuildingSubtype(BuildingSubID::EBuildingSubID subId)
-	{
-		bType = subId;
-	}
-
-	PlayerColor getOwner() const override;
-	MapObjectID getObjGroupIndex() const override;
-	MapObjectSubID getObjTypeIndex() const override;
-
-	int3 visitablePos() const override;
-	int3 getPosition() const override;
-
-	template <typename Handler> void serialize(Handler &h)
-	{
-		h & bID;
-		h & indexOnTV;
-		h & bType;
-	}
-
-protected:
-	BuildingID bID; //from buildig list
-	BuildingSubID::EBuildingSubID bType = BuildingSubID::NONE;
-
-	std::string getVisitingBonusGreeting() const;
-	std::string getCustomBonusGreeting(const Bonus & bonus) const;
-};
-
-class DLL_LINKAGE COPWBonus : public CGTownBuilding
-{///used for OPW bonusing structures
-public:
-	std::set<ObjectInstanceID> visitors;
-	void setProperty(ObjProperty what, ObjPropertyID identifier) override;
-	void onHeroVisit (const CGHeroInstance * h) const override;
-
-	COPWBonus(const BuildingID & index, BuildingSubID::EBuildingSubID subId, CGTownInstance * TOWN);
-	COPWBonus(IGameCallback *cb);
-
-	template <typename Handler> void serialize(Handler &h)
-	{
-		h & static_cast<CGTownBuilding&>(*this);
-		h & visitors;
-	}
-};
-
-class DLL_LINKAGE CTownBonus : public CGTownBuilding
-{
-///used for one-time bonusing structures
-///feel free to merge inheritance tree
-public:
-	std::set<ObjectInstanceID> visitors;
-	void setProperty(ObjProperty what, ObjPropertyID identifier) override;
-	void onHeroVisit (const CGHeroInstance * h) const override;
-
-	CTownBonus(const BuildingID & index, BuildingSubID::EBuildingSubID subId, CGTownInstance * TOWN);
-	CTownBonus(IGameCallback *cb);
-
-	template <typename Handler> void serialize(Handler &h)
-	{
-		h & static_cast<CGTownBuilding&>(*this);
-		h & visitors;
-	}
-
-private:
-	void applyBonuses(CGHeroInstance * h, const BonusList & bonuses) const;
-};
-
-class DLL_LINKAGE CTownRewardableBuilding : public CGTownBuilding, public Rewardable::Interface
-{
-	/// reward selected by player, no serialize
-	ui16 selectedReward = 0;
-		
-	std::set<ObjectInstanceID> visitors;
-	
-	bool wasVisitedBefore(const CGHeroInstance * contextHero) const;
-	
-	void grantReward(ui32 rewardID, const CGHeroInstance * hero) const;
-	
-public:
-	void setProperty(ObjProperty what, ObjPropertyID identifier) override;
-	void onHeroVisit(const CGHeroInstance * h) const override;
-	
-	void newTurn(CRandomGenerator & rand) const override;
-	
-	/// gives second part of reward after hero level-ups for proper granting of spells/mana
-	void heroLevelUpDone(const CGHeroInstance *hero) const override;
-	
-	void initObj(CRandomGenerator & rand) override;
-	
-	/// applies player selection of reward
-	void blockingDialogAnswered(const CGHeroInstance *hero, ui32 answer) const override;
-	
-	CTownRewardableBuilding(const BuildingID & index, BuildingSubID::EBuildingSubID subId, CGTownInstance * town, CRandomGenerator & rand);
-	CTownRewardableBuilding(IGameCallback *cb);
-	
-	template <typename Handler> void serialize(Handler &h)
-	{
-		h & static_cast<CGTownBuilding&>(*this);
-		h & static_cast<Rewardable::Interface&>(*this);
-		h & visitors;
-	}
-};
-
-VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/mapObjects/CGTownInstance.cpp vcmi/lib/mapObjects/CGTownInstance.cpp
--- vcmi-1.5.7/lib/mapObjects/CGTownInstance.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapObjects/CGTownInstance.cpp	2024-12-19 15:00:22.913148557 +0100
@@ -10,18 +10,22 @@
 
 #include "StdInc.h"
 #include "CGTownInstance.h"
-#include "CGTownBuilding.h"
+
+#include "TownBuildingInstance.h"
 #include "../spells/CSpellHandler.h"
 #include "../bonuses/Bonus.h"
 #include "../battle/IBattleInfoCallback.h"
+#include "../battle/BattleLayout.h"
 #include "../CConfigHandler.h"
-#include "../CGeneralTextHandler.h"
+#include "../texts/CGeneralTextHandler.h"
 #include "../IGameCallback.h"
 #include "../gameState/CGameState.h"
 #include "../mapping/CMap.h"
 #include "../CPlayerState.h"
 #include "../StartInfo.h"
 #include "../TerrainHandler.h"
+#include "../entities/building/CBuilding.h"
+#include "../entities/faction/CTownHandler.h"
 #include "../mapObjectConstructors/AObjectTypeHandler.h"
 #include "../mapObjectConstructors/CObjectClassesHandler.h"
 #include "../mapObjects/CGHeroInstance.h"
@@ -31,6 +35,8 @@
 #include "../networkPacks/PacksForClientBattle.h"
 #include "../serializer/JsonSerializeFormat.h"
 
+#include <vstd/RNG.h>
+
 VCMI_LIB_NAMESPACE_BEGIN
 
 int CGTownInstance::getSightRadius() const //returns sight distance
@@ -39,13 +45,10 @@
 
 	for(const auto & bid : builtBuildings)
 	{
-		if(bid.IsSpecialOrGrail())
-		{
-			auto height = town->buildings.at(bid)->height;
-			if(ret < height)
-				ret = height;
+		auto height = getTown()->buildings.at(bid)->height;
+		if(ret < height)
+			ret = height;
 	}
-}
 	return ret;
 }
 
@@ -55,13 +58,13 @@
 	switch (what)
 	{
 		case ObjProperty::STRUCTURE_ADD_VISITING_HERO:
-			bonusingBuildings[identifier.getNum()]->setProperty(ObjProperty::VISITORS, visitingHero->id);
+			rewardableBuildings.at(identifier.getNum())->setProperty(ObjProperty::VISITORS, visitingHero->id);
 			break;
 		case ObjProperty::STRUCTURE_CLEAR_VISITORS:
-			bonusingBuildings[identifier.getNum()]->setProperty(ObjProperty::STRUCTURE_CLEAR_VISITORS, NumericID(0));
+			rewardableBuildings.at(identifier.getNum())->setProperty(ObjProperty::STRUCTURE_CLEAR_VISITORS, NumericID(0));
 			break;
 		case ObjProperty::STRUCTURE_ADD_GARRISONED_HERO: //add garrisoned hero to visitors
-			bonusingBuildings[identifier.getNum()]->setProperty(ObjProperty::VISITORS, garrisonHero->id);
+			rewardableBuildings.at(identifier.getNum())->setProperty(ObjProperty::VISITORS, garrisonHero->id);
 			break;
 		case ObjProperty::BONUS_VALUE_FIRST:
 			bonusValue.first = identifier.getNum();
@@ -69,9 +72,6 @@
 		case ObjProperty::BONUS_VALUE_SECOND:
 			bonusValue.second = identifier.getNum();
 			break;
-		case ObjProperty::REWARD_RANDOMIZE:
-			bonusingBuildings[identifier.getNum()]->setProperty(ObjProperty::REWARD_RANDOMIZE, NumericID(0));
-			break;
 	}
 }
 CGTownInstance::EFortLevel CGTownInstance::fortLevel() const //0 - none, 1 - fort, 2 - citadel, 3 - castle
@@ -115,7 +115,7 @@
 
 int CGTownInstance::getHordeLevel(const int & HID)  const//HID - 0 or 1; returns creature level or -1 if that horde structure is not present
 {
-	return town->hordeLvl.at(HID);
+	return getTown()->hordeLvl.at(HID);
 }
 
 int CGTownInstance::creatureGrowth(const int & level) const
@@ -127,7 +127,7 @@
 {
 	GrowthInfo ret;
 
-	if (level<0 || level >=GameConstants::CREATURES_PER_TOWN)
+	if (level<0 || level >=getTown()->creatures.size())
 		return ret;
 	if (creatures[level].second.empty())
 		return ret; //no dwelling
@@ -136,6 +136,14 @@
 	const int base = creature->getGrowth();
 	int castleBonus = 0;
 
+	if(tempOwner.isValidPlayer())
+	{
+		auto * playerSettings = cb->getPlayerSettings(tempOwner);
+		ret.handicapPercentage = playerSettings->handicap.percentGrowth;
+	}
+	else
+		ret.handicapPercentage = 100;
+
 	ret.entries.emplace_back(VLC->generaltexth->allTexts[590], base); // \n\nBasic growth %d"
 
 	if (hasBuilt(BuildingID::CASTLE))
@@ -143,11 +151,11 @@
 	else if (hasBuilt(BuildingID::CITADEL))
 		ret.entries.emplace_back(subID, BuildingID::CITADEL, castleBonus = base / 2);
 
-	if(town->hordeLvl.at(0) == level)//horde 1
+	if(getTown()->hordeLvl.at(0) == level)//horde 1
 		if(hasBuilt(BuildingID::HORDE_1))
 			ret.entries.emplace_back(subID, BuildingID::HORDE_1, creature->getHorde());
 
-	if(town->hordeLvl.at(1) == level)//horde 2
+	if(getTown()->hordeLvl.at(1) == level)//horde 2
 		if(hasBuilt(BuildingID::HORDE_2))
 			ret.entries.emplace_back(subID, BuildingID::HORDE_2, creature->getHorde());
 
@@ -158,7 +166,7 @@
 		const auto growth = b->val * (base + castleBonus) / 100;
 		if (growth)
 		{
-			ret.entries.emplace_back(growth, b->Description(growth));
+			ret.entries.emplace_back(growth, b->Description(cb, growth));
 		}
 	}
 
@@ -166,12 +174,12 @@
 	// Note: bonus uses 1-based levels (Pikeman is level 1), town list uses 0-based (Pikeman in 0-th creatures entry)
 	TConstBonusListPtr bonuses = getBonuses(Selector::typeSubtype(BonusType::CREATURE_GROWTH, BonusCustomSubtype::creatureLevel(level+1)));
 	for(const auto & b : *bonuses)
-		ret.entries.emplace_back(b->val, b->Description());
+		ret.entries.emplace_back(b->val, b->Description(cb));
 
 	int dwellingBonus = 0;
 	if(const PlayerState *p = cb->getPlayerState(tempOwner, false))
 	{
-		dwellingBonus = getDwellingBonus(creatures[level].second, p->dwellings);
+		dwellingBonus = getDwellingBonus(creatures[level].second, p->getOwnedObjects());
 	}
 	if(dwellingBonus)
 		ret.entries.emplace_back(VLC->generaltexth->allTexts[591], dwellingBonus); // \nExternal dwellings %+d
@@ -182,15 +190,18 @@
 	return ret;
 }
 
-int CGTownInstance::getDwellingBonus(const std::vector<CreatureID>& creatureIds, const std::vector<ConstTransitivePtr<CGDwelling> >& dwellings) const
+int CGTownInstance::getDwellingBonus(const std::vector<CreatureID>& creatureIds, const std::vector<const CGObjectInstance * >& dwellings) const
 {
 	int totalBonus = 0;
 	for (const auto& dwelling : dwellings)
 	{
-		for (const auto& creature : dwelling->creatures)
-		{
-			totalBonus += vstd::contains(creatureIds, creature.second[0]) ? 1 : 0;
-		}
+		const auto & dwellingCreatures = dwelling->asOwnable()->providedCreatures();
+		bool hasMatch = false;
+		for (const auto& creature : dwellingCreatures)
+			hasMatch = vstd::contains(creatureIds, creature);
+
+		if (hasMatch)
+			totalBonus += 1;
 	}
 	return totalBonus;
 }
@@ -198,11 +209,11 @@
 TResources CGTownInstance::dailyIncome() const
 {
 	TResources ret;
-	for(const auto & p : town->buildings)
+	for(const auto & p : getTown()->buildings)
 	{
 		BuildingID buildingUpgrade;
 
-		for(const auto & p2 : town->buildings)
+		for(const auto & p2 : getTown()->buildings)
 		{
 			if (p2.second->upgrade == p.first)
 			{
@@ -214,9 +225,20 @@
 			ret += p.second->produce;
 		}
 	}
+
+	if (!getOwner().isValidPlayer())
+		return ret;
+
+	const auto & playerSettings = cb->getPlayerSettings(getOwner());
+	ret.applyHandicap(playerSettings->handicap.percentIncome);
 	return ret;
 }
 
+std::vector<CreatureID> CGTownInstance::providedCreatures() const
+{
+	return {};
+}
+
 bool CGTownInstance::hasFort() const
 {
 	return hasBuilt(BuildingID::FORT);
@@ -227,21 +249,36 @@
 	return hasBuilt(BuildingID::CAPITOL);
 }
 
+TownFortifications CGTownInstance::fortificationsLevel() const
+{
+	auto result = getTown()->fortifications;
+
+	for (auto const	& buildingID : builtBuildings)
+		result += getTown()->buildings.at(buildingID)->fortifications;
+
+	if (result.wallsHealth == 0)
+		return TownFortifications();
+
+	return result;
+}
+
 CGTownInstance::CGTownInstance(IGameCallback *cb):
 	CGDwelling(cb),
-	town(nullptr),
-	builded(0),
+	built(0),
 	destroyed(0),
 	identifier(0),
-	alignmentToPlayer(PlayerColor::NEUTRAL)
+	alignmentToPlayer(PlayerColor::NEUTRAL),
+	spellResearchCounterDay(0),
+	spellResearchAcceptedCounter(0),
+	spellResearchAllowed(true)
 {
 	this->setNodeType(CBonusSystemNode::TOWN);
 }
 
 CGTownInstance::~CGTownInstance()
 {
-	for (auto & elem : bonusingBuildings)
-		delete elem;
+	for (auto & elem : rewardableBuildings)
+		delete elem.second;
 }
 
 int CGTownInstance::spellsAtLevel(int level, bool checkGuild) const
@@ -267,12 +304,6 @@
 	cb->setOwner(this, player);
 }
 
-void CGTownInstance::blockingDialogAnswered(const CGHeroInstance *hero, ui32 answer) const
-{
-	for (auto building : bonusingBuildings)
-		building->blockingDialogAnswered(hero, answer);
-}
-
 void CGTownInstance::onHeroVisit(const CGHeroInstance * h) const
 {
 	if(cb->gameState()->getPlayerRelations( getOwner(), h->getOwner() ) == PlayerRelations::ENEMIES)
@@ -293,7 +324,7 @@
 
 				const_cast<CGHeroInstance *>(defendingHero)->inTownGarrison = false; //hack to return visitor from garrison after battle
 			}
-			cb->startBattlePrimary(h, defendingArmy, getSightCenter(), h, defendingHero, false, (isBattleOutside ? nullptr : this));
+			cb->startBattle(h, defendingArmy, getSightCenter(), h, defendingHero, BattleLayout::createDefaultLayout(cb, h, defendingArmy), (isBattleOutside ? nullptr : this));
 		}
 		else
 		{
@@ -308,8 +339,9 @@
 			cb->heroVisitCastle(this, h);
 		}
 	}
-	else if(h->visitablePos() == visitablePos())
+	else
 	{
+		assert(h->visitablePos() == this->visitablePos());
 		bool commander_recover = h->commander && !h->commander->alive;
 		if (commander_recover) // rise commander from dead
 		{
@@ -317,7 +349,7 @@
 			scp.heroid = h->id;
 			scp.which = SetCommanderProperty::ALIVE;
 			scp.amount = 1;
-			cb->sendAndApply(&scp);
+			cb->sendAndApply(scp);
 		}
 		cb->heroVisitCastle(this, h);
 		// TODO(vmarkovtsev): implement payment for rising the commander
@@ -330,10 +362,6 @@
 			cb->showInfoDialog(&iw);
 		}
 	}
-	else
-	{
-		logGlobal->error("%s visits allied town of %s from different pos?", h->getNameTranslated(), getNameTranslated());
-	}
 }
 
 void CGTownInstance::onHeroLeave(const CGHeroInstance * h) const
@@ -350,57 +378,28 @@
 
 std::string CGTownInstance::getObjectName() const
 {
-	return getNameTranslated() + ", " + town->faction->getNameTranslated();
-}
+	if(ID == Obj::RANDOM_TOWN )
+		return CGObjectInstance::getObjectName();
 
-bool CGTownInstance::townEnvisagesBuilding(BuildingSubID::EBuildingSubID subId) const
-{
-	return town->getBuildingType(subId) != BuildingID::NONE;
+	return getNameTranslated() + ", " + getTown()->faction->getNameTranslated();
 }
 
-void CGTownInstance::initOverriddenBids()
-{
-	for(const auto & bid : builtBuildings)
-	{
-		const auto & overrideThem = town->buildings.at(bid)->overrideBids;
-
-		for(const auto & overrideIt : overrideThem)
-			overriddenBuildings.insert(overrideIt);
-	}
-}
-
-bool CGTownInstance::isBonusingBuildingAdded(BuildingID bid) const
+bool CGTownInstance::townEnvisagesBuilding(BuildingSubID::EBuildingSubID subId) const
 {
-	auto present = std::find_if(bonusingBuildings.begin(), bonusingBuildings.end(), [&](CGTownBuilding* building)
-		{
-			return building->getBuildingType() == bid;
-		});
-
-	return present != bonusingBuildings.end();
+	return getTown()->getBuildingType(subId) != BuildingID::NONE;
 }
 
-void CGTownInstance::addTownBonuses(CRandomGenerator & rand)
+void CGTownInstance::initializeConfigurableBuildings(vstd::RNG & rand)
 {
-	for(const auto & kvp : town->buildings)
+	for(const auto & kvp : getTown()->buildings)
 	{
-		if(vstd::contains(overriddenBuildings, kvp.first))
-			continue;
-
-		if(kvp.second->IsVisitingBonus())
-			bonusingBuildings.push_back(new CTownBonus(kvp.second->bid, kvp.second->subId, this));
-
-		if(kvp.second->IsWeekBonus())
-			bonusingBuildings.push_back(new COPWBonus(kvp.second->bid, kvp.second->subId, this));
-		
-		if(kvp.second->subId == BuildingSubID::CUSTOM_VISITING_REWARD)
-			bonusingBuildings.push_back(new CTownRewardableBuilding(kvp.second->bid, kvp.second->subId, this, rand));
+		if(!kvp.second->rewardableObjectInfo.getParameters().isNull())
+			rewardableBuildings[kvp.first] = new TownRewardableBuildingInstance(this, kvp.second->bid, rand);
 	}
 }
 
 DamageRange CGTownInstance::getTowerDamageRange() const
 {
-	assert(hasBuilt(BuildingID::CASTLE));
-
 	// http://heroes.thelazy.net/wiki/Arrow_tower
 	// base damage, irregardless of town level
 	static constexpr int baseDamage = 6;
@@ -417,8 +416,6 @@
 
 DamageRange CGTownInstance::getKeepDamageRange() const
 {
-	assert(hasBuilt(BuildingID::CITADEL));
-
 	// http://heroes.thelazy.net/wiki/Arrow_tower
 	// base damage, irregardless of town level
 	static constexpr int baseDamage = 10;
@@ -433,35 +430,7 @@
 	};
 }
 
-void CGTownInstance::deleteTownBonus(BuildingID bid)
-{
-	size_t i = 0;
-	CGTownBuilding * freeIt = nullptr;
-
-	for(i = 0; i != bonusingBuildings.size(); i++)
-	{
-		if(bonusingBuildings[i]->getBuildingType() == bid)
-		{
-			freeIt = bonusingBuildings[i];
-			break;
-		}
-	}
-	if(freeIt == nullptr)
-		return;
-
-	auto building = town->buildings.at(bid);
-	auto isVisitingBonus = building->IsVisitingBonus();
-	auto isWeekBonus = building->IsWeekBonus();
-
-	if(!isVisitingBonus && !isWeekBonus)
-		return;
-
-	bonusingBuildings.erase(bonusingBuildings.begin() + i);
-
-	delete freeIt;
-}
-
-FactionID CGTownInstance::randomizeFaction(CRandomGenerator & rand)
+FactionID CGTownInstance::randomizeFaction(vstd::RNG & rand)
 {
 	if(getOwner().isValidPlayer())
 		return cb->gameState()->scenarioOps->getIthPlayersSettings(getOwner()).castle;
@@ -479,7 +448,7 @@
 	return *RandomGeneratorUtil::nextItem(potentialPicks, rand);
 }
 
-void CGTownInstance::pickRandomObject(CRandomGenerator & rand)
+void CGTownInstance::pickRandomObject(vstd::RNG & rand)
 {
 	assert(ID == MapObjectID::TOWN || ID == MapObjectID::RANDOM_TOWN);
 	if (ID == MapObjectID::RANDOM_TOWN)
@@ -490,128 +459,87 @@
 
 	assert(ID == Obj::TOWN); // just in case
 	setType(ID, subID);
-	town = (*VLC->townh)[getFaction()]->town;
-	randomizeArmy(getFaction());
+	randomizeArmy(getFactionID());
 	updateAppearance();
 }
 
-void CGTownInstance::initObj(CRandomGenerator & rand) ///initialize town structures
+void CGTownInstance::initObj(vstd::RNG & rand) ///initialize town structures
 {
 	blockVisit = true;
 
 	if(townEnvisagesBuilding(BuildingSubID::PORTAL_OF_SUMMONING)) //Dungeon for example
-		creatures.resize(GameConstants::CREATURES_PER_TOWN + 1);
+		creatures.resize(getTown()->creatures.size() + 1);
 	else
-		creatures.resize(GameConstants::CREATURES_PER_TOWN);
+		creatures.resize(getTown()->creatures.size());
 
-	for (int level = 0; level < GameConstants::CREATURES_PER_TOWN; level++)
+	for (int level = 0; level < getTown()->creatures.size(); level++)
 	{
-		BuildingID buildID = BuildingID(BuildingID::DWELL_FIRST + level);
+		BuildingID buildID = BuildingID(BuildingID::getDwellingFromLevel(level, 0));
 		int upgradeNum = 0;
 
-		for (; town->buildings.count(buildID); upgradeNum++, buildID.advance(GameConstants::CREATURES_PER_TOWN))
+		for (; getTown()->buildings.count(buildID); upgradeNum++, BuildingID::advanceDwelling(buildID))
 		{
-			if (hasBuilt(buildID) && town->creatures.at(level).size() > upgradeNum)
-				creatures[level].second.push_back(town->creatures[level][upgradeNum]);
+			if (hasBuilt(buildID) && getTown()->creatures.at(level).size() > upgradeNum)
+				creatures[level].second.push_back(getTown()->creatures[level][upgradeNum]);
 		}
 	}
-	initOverriddenBids();
-	addTownBonuses(rand); //add special bonuses from buildings to the bonusingBuildings vector.
+	initializeConfigurableBuildings(rand);
+	initializeNeutralTownGarrison(rand);
 	recreateBuildingsBonuses();
 	updateAppearance();
 }
 
-void CGTownInstance::newTurn(CRandomGenerator & rand) const
+void CGTownInstance::initializeNeutralTownGarrison(vstd::RNG & rand)
 {
-	if (cb->getDate(Date::DAY_OF_WEEK) == 1) //reset on new week
-	{
-		//give resources if there's a Mystic Pond
-		if (hasBuilt(BuildingSubID::MYSTIC_POND)
-			&& cb->getDate(Date::DAY) != 1
-			&& (tempOwner.isValidPlayer())
-			)
-		{
-			int resID = rand.nextInt(2, 5); //bonus to random rare resource
-			resID = (resID==2)?1:resID;
-			int resVal = rand.nextInt(1, 4);//with size 1..4
-			cb->giveResource(tempOwner, static_cast<EGameResID>(resID), resVal);
-			cb->setObjPropertyValue(id, ObjProperty::BONUS_VALUE_FIRST, resID);
-			cb->setObjPropertyValue(id, ObjProperty::BONUS_VALUE_SECOND, resVal);
-		}
-		
-		for(const auto * manaVortex : getBonusingBuildings(BuildingSubID::MANA_VORTEX))
-			cb->setObjPropertyValue(id, ObjProperty::STRUCTURE_CLEAR_VISITORS, manaVortex->indexOnTV); //reset visitors for Mana Vortex
+	struct RandomGuardsInfo{
+		int tier;
+		int chance;
+		int min;
+		int max;
+	};
 
-		//get Mana Vortex or Stables bonuses
-		//same code is in the CGameHandler::buildStructure method
-		if (garrisonHero != nullptr) //garrison hero first - consistent with original H3 Mana Vortex and Battle Scholar Academy levelup windows order
-			cb->visitCastleObjects(this, garrisonHero);
+	constexpr std::array<RandomGuardsInfo, 4> randomGuards = {
+		RandomGuardsInfo{ 0, 33, 8, 15 },
+		RandomGuardsInfo{ 1, 33, 5,  7 },
+		RandomGuardsInfo{ 2, 20, 3,  5 },
+		RandomGuardsInfo{ 3, 14, 1,  3 },
+	};
 
-		if (visitingHero != nullptr)
-			cb->visitCastleObjects(this, visitingHero);
+	// Only neutral towns may get initial garrison
+	if (getOwner().isValidPlayer())
+		return;
 
-		if (tempOwner == PlayerColor::NEUTRAL) //garrison growth for neutral towns
-		{
-			std::vector<SlotID> nativeCrits; //slots
-			for(const auto & elem : Slots())
-			{
-				if (elem.second->type->getFaction() == getFaction()) //native
-				{
-					nativeCrits.push_back(elem.first); //collect matching slots
-				}
-			}
-			if(!nativeCrits.empty())
-			{
-				SlotID pos = *RandomGeneratorUtil::nextItem(nativeCrits, rand);
-				StackLocation sl(this, pos);
-				
-				const CCreature *c = getCreature(pos);
-				if (rand.nextInt(99) < 90 || c->upgrades.empty()) //increase number if no upgrade available
-				{
-					cb->changeStackCount(sl, c->getGrowth());
-				}
-				else //upgrade
-				{
-					cb->changeStackType(sl, c->upgrades.begin()->toCreature());
-				}
-			}
-			if ((stacksCount() < GameConstants::ARMY_SIZE && rand.nextInt(99) < 25) || Slots().empty()) //add new stack
-			{
-				int i = rand.nextInt(std::min(GameConstants::CREATURES_PER_TOWN, cb->getDate(Date::MONTH) << 1) - 1);
-				if (!town->creatures[i].empty())
-				{
-					CreatureID c = town->creatures[i][0];
-					SlotID n;
-					
-					TQuantity count = creatureGrowth(i);
-					if (!count) // no dwelling
-						count = VLC->creatures()->getById(c)->getGrowth();
-					
-					{//no lower tiers or above current month
-						
-						if ((n = getSlotFor(c)).validSlot())
-						{
-							StackLocation sl(this, n);
-							if (slotEmpty(n))
-								cb->insertNewStack(sl, c.toCreature(), count);
-							else //add to existing
-								cb->changeStackCount(sl, count);
-						}
-					}
-				}
-			}
-		}
+	// Only towns with garrison not set in map editor may get initial garrison
+	// FIXME: H3 editor allow explicitly empty garrison, but vcmi loses this flag on load
+	if (stacksCount() > 0)
+		return;
+
+	for (auto const & guard : randomGuards)
+	{
+		if (rand.nextInt(99) >= guard.chance)
+			continue;
+
+		CreatureID guardID = getTown()->creatures[guard.tier].at(0);
+		int guardSize = rand.nextInt(guard.min, guard.max);
+
+		putStack(getFreeSlot(), new CStackInstance(guardID, guardSize));
 	}
-	
-	for(const auto * rewardableBuilding : getBonusingBuildings(BuildingSubID::CUSTOM_VISITING_REWARD))
-		rewardableBuilding->newTurn(rand);
 }
-/*
-int3 CGTownInstance::getSightCenter() const
+
+void CGTownInstance::newTurn(vstd::RNG & rand) const
 {
-	return pos - int3(2,0,0);
+	for(const auto & building : rewardableBuildings)
+		building.second->newTurn(rand);
+		
+	if(hasBuilt(BuildingSubID::BANK) && bonusValue.second > 0)
+	{
+		TResources res;
+		res[EGameResID::GOLD] = -500;
+		cb->giveResources(getOwner(), res);
+		cb->setObjPropertyValue(id, ObjProperty::BONUS_VALUE_SECOND, bonusValue.second - 500);
+	}
 }
-*/
+
 bool CGTownInstance::passableFor(PlayerColor color) const
 {
 	if (!armedGarrison())//empty castle - anyone can visit
@@ -696,15 +624,15 @@
 	if (hasCapitol()) // search if there's an older capitol
 	{
 		PlayerState* state = cb->gameState()->getPlayerState(owner); //get all towns owned by player
-		for (auto i = state->towns.cbegin(); i < state->towns.cend(); ++i)
+		for (const auto & otherTown : state->getTowns())
 		{
-			if (*i != this && (*i)->hasCapitol())
+			if (otherTown != this && otherTown->hasCapitol())
 			{
 				RazeStructures rs;
 				rs.tid = id;
 				rs.bid.insert(BuildingID::CAPITOL);
 				rs.destroyed = destroyed;
-				cb->sendAndApply(&rs);
+				cb->sendAndApply(rs);
 				return;
 			}
 		}
@@ -721,7 +649,7 @@
 
 BoatId CGTownInstance::getBoatType() const
 {
-	return town->faction->boatType;
+	return getTown()->faction->boatType;
 }
 
 int CGTownInstance::getMarketEfficiency() const
@@ -733,52 +661,21 @@
 	assert(p);
 
 	int marketCount = 0;
-	for(const CGTownInstance *t : p->towns)
+	for(const CGTownInstance *t : p->getTowns())
 		if(t->hasBuiltSomeTradeBuilding())
 			marketCount++;
 
 	return marketCount;
 }
 
-bool CGTownInstance::allowsTrade(EMarketMode mode) const
-{
-	switch(mode)
-	{
-	case EMarketMode::RESOURCE_RESOURCE:
-	case EMarketMode::RESOURCE_PLAYER:
-		return hasBuilt(BuildingID::MARKETPLACE);
-
-	case EMarketMode::ARTIFACT_RESOURCE:
-	case EMarketMode::RESOURCE_ARTIFACT:
-		return hasBuilt(BuildingSubID::ARTIFACT_MERCHANT);
-
-	case EMarketMode::CREATURE_RESOURCE:
-		return hasBuilt(BuildingSubID::FREELANCERS_GUILD);
-
-	case EMarketMode::CREATURE_UNDEAD:
-		return hasBuilt(BuildingSubID::CREATURE_TRANSFORMER);
-
-	case EMarketMode::RESOURCE_SKILL:
-		return hasBuilt(BuildingSubID::MAGIC_UNIVERSITY);
-	case EMarketMode::CREATURE_EXP:
-	case EMarketMode::ARTIFACT_EXP:
-		return false;
-	default:
-		assert(0);
-		return false;
-	}
-}
-
 std::vector<TradeItemBuy> CGTownInstance::availableItemsIds(EMarketMode mode) const
 {
 	if(mode == EMarketMode::RESOURCE_ARTIFACT)
 	{
 		std::vector<TradeItemBuy> ret;
-		for(const CArtifact *a : cb->gameState()->map->townMerchantArtifacts)
-			if(a)
-				ret.push_back(a->getId());
-			else
-				ret.push_back(ArtifactID{});
+		for(const ArtifactID a : cb->gameState()->map->townMerchantArtifacts)
+			ret.push_back(a);
+
 		return ret;
 	}
 	else if ( mode == EMarketMode::RESOURCE_SKILL )
@@ -789,9 +686,14 @@
 		return IMarket::availableItemsIds(mode);
 }
 
+ObjectInstanceID CGTownInstance::getObjInstanceID() const
+{
+	return id;
+}
+
 void CGTownInstance::updateAppearance()
 {
-	auto terrain = cb->gameState()->getTile(visitablePos())->terType->getId();
+	auto terrain = cb->gameState()->getTile(visitablePos())->getTerrainID();
 	//FIXME: not the best way to do this
 	auto app = getObjectHandler()->getOverride(terrain, this);
 	if (app)
@@ -800,7 +702,7 @@
 
 std::string CGTownInstance::nodeName() const
 {
-	return "Town (" + (town ? town->faction->getNameTranslated() : "unknown") + ") of " + getNameTranslated();
+	return "Town (" + getTown()->faction->getNameTranslated() + ") of " + getNameTranslated();
 }
 
 void CGTownInstance::deserializationFix()
@@ -841,12 +743,24 @@
 	for(const auto & b : bl)
 		removeBonus(b);
 
+
+
 	for(const auto & bid : builtBuildings)
 	{
-		if(vstd::contains(overriddenBuildings, bid)) //tricky! -> checks tavern only if no bratherhood of sword
+		bool bonusesReplacedByUpgrade = false;
+
+		for(const auto & upgradeID : builtBuildings)
+		{
+			const auto & upgrade = getTown()->buildings.at(upgradeID);
+			if (upgrade->getBase() == bid && upgrade->upgradeReplacesBonuses)
+				bonusesReplacedByUpgrade = true;
+		}
+
+		// bonuses from this building are disabled and replaced by bonuses from an upgrade
+		if (bonusesReplacedByUpgrade)
 			continue;
 
-		auto building = town->buildings.at(bid);
+		auto building = getTown()->buildings.at(bid);
 
 		if(building->buildingBonuses.empty())
 			continue;
@@ -913,21 +827,6 @@
 	return !stacks.empty() || garrisonHero;
 }
 
-const CTown * CGTownInstance::getTown() const
-{
-    if(ID == Obj::RANDOM_TOWN)
-		return VLC->townh->randomTown;
-	else
-	{
-		if(nullptr == town)
-		{
-			return (*VLC->townh)[getFaction()]->town;
-		}
-		else
-			return town;
-	}
-}
-
 int CGTownInstance::getTownLevel() const
 {
 	// count all buildings that are not upgrades
@@ -935,7 +834,7 @@
 
 	for(const auto & bid : builtBuildings)
 	{
-		if(town->buildings.at(bid)->upgrade == BuildingID::NONE)
+		if(getTown()->buildings.at(bid)->upgrade == BuildingID::NONE)
 			level++;
 	}
 	return level;
@@ -968,33 +867,16 @@
 	return this;
 }
 
-std::vector<const CGTownBuilding *> CGTownInstance::getBonusingBuildings(BuildingSubID::EBuildingSubID subId) const
-{
-	std::vector<const CGTownBuilding *> ret;
-	for(auto * const building : bonusingBuildings)
-	{
-		if(building->getBuildingSubtype() == subId)
-			ret.push_back(building);
-	}
-	return ret;
-}
-
-
 bool CGTownInstance::hasBuiltSomeTradeBuilding() const
 {
-	for(const auto & bid : builtBuildings)
-	{
-		if(town->buildings.at(bid)->IsTradeBuilding())
-			return true;
-	}
-	return false;
+	return availableModes().empty() ? false : true;
 }
 
 bool CGTownInstance::hasBuilt(BuildingSubID::EBuildingSubID buildingID) const
 {
 	for(const auto & bid : builtBuildings)
 	{
-		if(town->buildings.at(bid)->subId == buildingID)
+		if(getTown()->buildings.at(bid)->subId == buildingID)
 			return true;
 	}
 	return false;
@@ -1007,18 +889,56 @@
 
 bool CGTownInstance::hasBuilt(const BuildingID & buildingID, FactionID townID) const
 {
-	if (townID == town->faction->getId() || townID == FactionID::ANY)
+	if (townID == getTown()->faction->getId() || townID == FactionID::ANY)
 		return hasBuilt(buildingID);
 	return false;
 }
 
+void CGTownInstance::addBuilding(const BuildingID & buildingID)
+{
+	if(buildingID == BuildingID::NONE)
+		return;
+
+	builtBuildings.insert(buildingID);
+}
+
+std::set<EMarketMode> CGTownInstance::availableModes() const
+{
+	std::set<EMarketMode> result;
+	for (const auto & buildingID : builtBuildings)
+	{
+		const auto * buildingPtr = getTown()->buildings.at(buildingID).get();
+		result.insert(buildingPtr->marketModes.begin(), buildingPtr->marketModes.end());
+	}
+
+	return result;
+}
+
+void CGTownInstance::removeBuilding(const BuildingID & buildingID)
+{
+	if(!vstd::contains(builtBuildings, buildingID))
+		return;
+
+	builtBuildings.erase(buildingID);
+}
+
+void CGTownInstance::removeAllBuildings()
+{
+	builtBuildings.clear();
+}
+
+std::set<BuildingID> CGTownInstance::getBuildings() const
+{
+	return builtBuildings;
+}
+
 TResources CGTownInstance::getBuildingCost(const BuildingID & buildingID) const
 {
-	if (vstd::contains(town->buildings, buildingID))
-		return town->buildings.at(buildingID)->resources;
+	if (vstd::contains(getTown()->buildings, buildingID))
+		return getTown()->buildings.at(buildingID)->resources;
 	else
 	{
-		logGlobal->error("Town %s at %s has no possible building %d!", getNameTranslated(), pos.toString(), buildingID.toEnum());
+		logGlobal->error("Town %s at %s has no possible building %d!", getNameTranslated(), anchorPos().toString(), buildingID.toEnum());
 		return TResources();
 	}
 
@@ -1026,7 +946,7 @@
 
 CBuilding::TRequired CGTownInstance::genBuildingRequirements(const BuildingID & buildID, bool deep) const
 {
-	const CBuilding * building = town->buildings.at(buildID);
+	const CBuilding * building = getTown()->buildings.at(buildID);
 
 	//TODO: find better solution to prevent infinite loops
 	std::set<BuildingID> processed;
@@ -1034,13 +954,13 @@
 	std::function<CBuilding::TRequired::Variant(const BuildingID &)> dependTest =
 	[&](const BuildingID & id) -> CBuilding::TRequired::Variant
 	{
-		if (town->buildings.count(id) == 0)
+		if (getTown()->buildings.count(id) == 0)
 		{
 			logMod->error("Invalid building ID %d in building dependencies!", id.getNum());
 			return CBuilding::TRequired::OperatorAll();
 		}
 
-		const CBuilding * build = town->buildings.at(id);
+		const CBuilding * build = getTown()->buildings.at(id);
 		CBuilding::TRequired::OperatorAll requirements;
 
 		if (!hasBuilt(id))
@@ -1065,7 +985,7 @@
 	CBuilding::TRequired::OperatorAll requirements;
 	if (building->upgrade != BuildingID::NONE)
 	{
-		const CBuilding * upgr = town->buildings.at(building->upgrade);
+		const CBuilding * upgr = getTown()->buildings.at(building->upgrade);
 
 		requirements.expressions.push_back(dependTest(upgr->bid));
 		processed.clear();
@@ -1182,23 +1102,23 @@
 		{
 			handler.serializeLIC("buildings", buildingsLIC);
 
-			builtBuildings.insert(BuildingID::VILLAGE_HALL);
+			addBuilding(BuildingID::VILLAGE_HALL);
 
 			if(buildingsLIC.none.empty() && buildingsLIC.all.empty())
 			{
-				builtBuildings.insert(BuildingID::DEFAULT);
+				addBuilding(BuildingID::DEFAULT);
 
 				bool hasFort = false;
 				handler.serializeBool("hasFort",hasFort);
 				if(hasFort)
-					builtBuildings.insert(BuildingID::FORT);
+					addBuilding(BuildingID::FORT);
 			}
 			else
 			{
 				for(const si32 item : buildingsLIC.none)
 					forbiddenBuildings.insert(BuildingID(item));
 				for(const si32 item : buildingsLIC.all)
-					builtBuildings.insert(BuildingID(item));
+					addBuilding(BuildingID(item));
 			}
 		}
 	}
@@ -1207,16 +1127,60 @@
 		handler.serializeIdArray( "possibleSpells", possibleSpells);
 		handler.serializeIdArray( "obligatorySpells", obligatorySpells);
 	}
+
+	{
+		auto eventsHandler = handler.enterArray("events");
+		eventsHandler.syncSize(events, JsonNode::JsonType::DATA_VECTOR);
+		eventsHandler.serializeStruct(events);
+	}
+}
+
+const CFaction * CGTownInstance::getFaction() const
+{
+	return getFactionID().toFaction();
+}
+
+const CTown * CGTownInstance::getTown() const
+{
+	if(ID == Obj::RANDOM_TOWN)
+		return VLC->townh->randomTown;
+
+	return getFaction()->town;
 }
 
-FactionID CGTownInstance::getFaction() const
+FactionID CGTownInstance::getFactionID() const
 {
-	return  FactionID(subID.getNum());
+	return FactionID(subID.getNum());
 }
 
 TerrainId CGTownInstance::getNativeTerrain() const
 {
-	return town->faction->getNativeTerrain();
+	return getTown()->faction->getNativeTerrain();
+}
+
+ArtifactID CGTownInstance::getWarMachineInBuilding(BuildingID building) const
+{
+	if (builtBuildings.count(building) == 0)
+		return ArtifactID::NONE;
+
+	if (building == BuildingID::BLACKSMITH && getTown()->warMachineDeprecated.hasValue())
+		return getTown()->warMachineDeprecated.toCreature()->warMachine;
+
+	return getTown()->buildings.at(building)->warMachine;
+}
+
+bool CGTownInstance::isWarMachineAvailable(ArtifactID warMachine) const
+{
+	for (auto const & buildingID : builtBuildings)
+		if (getTown()->buildings.at(buildingID)->warMachine == warMachine)
+			return true;
+
+	if (builtBuildings.count(BuildingID::BLACKSMITH) &&
+	   getTown()->warMachineDeprecated.hasValue() &&
+	   getTown()->warMachineDeprecated.toCreature()->warMachine == warMachine)
+		return true;
+
+	return false;
 }
 
 GrowthInfo::Entry::Entry(const std::string &format, int _count)
@@ -1233,7 +1197,7 @@
 {
 	MetaString formatter;
 	formatter.appendRawString("%s %+d");
-	formatter.replaceRawString((*VLC->townh)[subID]->town->buildings.at(building)->getNameTranslated());
+	formatter.replaceRawString(FactionID(subID).toFaction()->town->buildings.at(building)->getNameTranslated());
 	formatter.replacePositiveNumber(count);
 
 	description = formatter.toString();
@@ -1256,25 +1220,46 @@
 	for(const Entry &entry : entries)
 		ret += entry.count;
 
-	return ret;
+	// always round up income - we don't want buildings to always produce zero if handicap in use
+	return vstd::divideAndCeil(ret * handicapPercentage, 100);
 }
 
 void CGTownInstance::fillUpgradeInfo(UpgradeInfo & info, const CStackInstance &stack) const
 {
 	for(const CGTownInstance::TCreaturesSet::value_type & dwelling : creatures)
 	{
-		if (vstd::contains(dwelling.second, stack.type->getId())) //Dwelling with our creature
+		if (vstd::contains(dwelling.second, stack.getId())) //Dwelling with our creature
 		{
 			for(const auto & upgrID : dwelling.second)
 			{
-				if(vstd::contains(stack.type->upgrades, upgrID)) //possible upgrade
+				if(vstd::contains(stack.getCreature()->upgrades, upgrID)) //possible upgrade
 				{
 					info.newID.push_back(upgrID);
-					info.cost.push_back(upgrID.toCreature()->getFullRecruitCost() - stack.type->getFullRecruitCost());
+					info.cost.push_back(upgrID.toCreature()->getFullRecruitCost() - stack.getType()->getFullRecruitCost());
 				}
 			}
 		}
 	}
 }
 
+void CGTownInstance::postDeserialize()
+{
+	setNodeType(CBonusSystemNode::TOWN);
+	for(auto & building : rewardableBuildings)
+		building.second->town = this;
+}
+
+std::map<BuildingID, TownRewardableBuildingInstance*> CGTownInstance::convertOldBuildings(std::vector<TownRewardableBuildingInstance*> oldVector)
+{
+	std::map<BuildingID, TownRewardableBuildingInstance*> result;
+
+	for(auto & building : oldVector)
+	{
+		result[building->getBuildingType()] = new TownRewardableBuildingInstance(*building);
+		delete building;
+	}
+
+	return result;
+}
+
 VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/mapObjects/CGTownInstance.h vcmi/lib/mapObjects/CGTownInstance.h
--- vcmi-1.5.7/lib/mapObjects/CGTownInstance.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapObjects/CGTownInstance.h	2024-12-19 15:00:22.913148557 +0100
@@ -11,15 +11,20 @@
 
 #include "IMarket.h"
 #include "CGDwelling.h"
-#include "CGTownBuilding.h"
-
-#include "../CTownHandler.h" // For CTown
+#include "../entities/faction/CFaction.h" // TODO: remove
+#include "../entities/faction/CTown.h" // TODO: remove
 
 VCMI_LIB_NAMESPACE_BEGIN
 
 class CCastleEvent;
+class CTown;
+class TownBuildingInstance;
+struct TownFortifications;
+class TownRewardableBuildingInstance;
 struct DamageRange;
 
+template<typename ContainedClass>
+class LogicalExpression;
 
 class DLL_LINKAGE CTownAndVisitingHero : public CBonusSystemNode
 {
@@ -40,38 +45,42 @@
 
 	std::vector<Entry> entries;
 	int totalGrowth() const;
+	int handicapPercentage;
 };
 
 class DLL_LINKAGE CGTownInstance : public CGDwelling, public IShipyard, public IMarket, public INativeTerrainProvider, public ICreatureUpgrader
 {
+	friend class CTownInstanceConstructor;
 	std::string nameTextId; // name of town
-public:
-	using CGDwelling::getPosition;
 
+	std::map<BuildingID, TownRewardableBuildingInstance*> convertOldBuildings(std::vector<TownRewardableBuildingInstance*> oldVector);
+	std::set<BuildingID> builtBuildings;
+
+public:
 	enum EFortLevel {NONE = 0, FORT = 1, CITADEL = 2, CASTLE = 3};
 
 	CTownAndVisitingHero townAndVis;
-	const CTown * town;
-	si32 builded; //how many buildings has been built this turn
+	si32 built; //how many buildings has been built this turn
 	si32 destroyed; //how many buildings has been destroyed this turn
 	ConstTransitivePtr<CGHeroInstance> garrisonHero, visitingHero;
 	ui32 identifier; //special identifier from h3m (only > RoE maps)
 	PlayerColor alignmentToPlayer; // if set to non-neutral, random town will have same faction as specified player
 	std::set<BuildingID> forbiddenBuildings;
-	std::set<BuildingID> builtBuildings;
-	std::set<BuildingID> overriddenBuildings; ///buildings which bonuses are overridden and should not be applied
-	std::vector<CGTownBuilding*> bonusingBuildings;
+	std::map<BuildingID, TownRewardableBuildingInstance*> rewardableBuildings;
 	std::vector<SpellID> possibleSpells, obligatorySpells;
 	std::vector<std::vector<SpellID> > spells; //spells[level] -> vector of spells, first will be available in guild
-	std::list<CCastleEvent> events;
-	std::pair<si32, si32> bonusValue;//var to store town bonuses (rampart = resources from mystic pond);
+	std::vector<CCastleEvent> events;
+	std::pair<si32, si32> bonusValue;//var to store town bonuses (rampart = resources from mystic pond, factory = save debts);
+	int spellResearchCounterDay;
+	int spellResearchAcceptedCounter;
+	bool spellResearchAllowed;
 
 	//////////////////////////////////////////////////////////////////////////
 	template <typename Handler> void serialize(Handler &h)
 	{
 		h & static_cast<CGDwelling&>(*this);
 		h & nameTextId;
-		h & builded;
+		h & built;
 		h & destroyed;
 		h & identifier;
 		h & garrisonHero;
@@ -84,43 +93,45 @@
 		h & obligatorySpells;
 		h & spells;
 		h & events;
-		h & bonusingBuildings;
-		
-		for(auto * bonusingBuilding : bonusingBuildings)
-			bonusingBuilding->town = this;
-		
-		if (h.saving)
+
+		if (h.version >= Handler::Version::SPELL_RESEARCH)
 		{
-			CFaction * faction = town ? town->faction : nullptr;
-			h & faction;
+			h & spellResearchCounterDay;
+			h & spellResearchAcceptedCounter;
+			h & spellResearchAllowed;
+		}
+
+		if (h.version >= Handler::Version::NEW_TOWN_BUILDINGS)
+		{
+			h & rewardableBuildings;
 		}
 		else
 		{
-			CFaction * faction = nullptr;
-			h & faction;
-			town = faction ? faction->town : nullptr;
+			std::vector<TownRewardableBuildingInstance*> oldVector;
+			h & oldVector;
+			rewardableBuildings = convertOldBuildings(oldVector);
+		}
+
+		if (h.version < Handler::Version::REMOVE_TOWN_PTR)
+		{
+			FactionID faction;
+			bool isNull = false;
+			h & isNull;
+			if (!isNull)
+				h & faction;
 		}
 
 		h & townAndVis;
 		BONUS_TREE_DESERIALIZATION_FIX
 
-		if(town)
+		if (h.version < Handler::Version::NEW_TOWN_BUILDINGS)
 		{
-			vstd::erase_if(builtBuildings, [this](BuildingID building) -> bool
-			{
-				if(!town->buildings.count(building) || !town->buildings.at(building))
-				{
-					logGlobal->error("#1444-like issue in CGTownInstance::serialize. From town %s at %s removing the bogus builtBuildings item %s", nameTextId, pos.toString(), building);
-					return true;
-				}
-				return false;
-			});
+			std::set<BuildingID> overriddenBuildings;
+			h & overriddenBuildings;
 		}
 
-		h & overriddenBuildings;
-
 		if(!h.saving)
-			this->setNodeType(CBonusSystemNode::TOWN);
+			postDeserialize();
 	}
 	//////////////////////////////////////////////////////////////////////////
 
@@ -128,6 +139,7 @@
 	std::string nodeName() const override;
 	void updateMoraleBonusFromArmy() override;
 	void deserializationFix();
+	void postDeserialize();
 	void recreateBuildingsBonuses();
 	void setVisitingHero(CGHeroInstance *h);
 	void setGarrisonedHero(CGHeroInstance *h);
@@ -147,15 +159,16 @@
 	EGeneratorState shipyardStatus() const override;
 	const IObjectInterface * getObject() const override;
 	int getMarketEfficiency() const override; //=market count
-	bool allowsTrade(EMarketMode mode) const override;
+	std::set<EMarketMode> availableModes() const override;
 	std::vector<TradeItemBuy> availableItemsIds(EMarketMode mode) const override;
-
+	ObjectInstanceID getObjInstanceID() const override;
 	void updateAppearance();
 
 	//////////////////////////////////////////////////////////////////////////
 
 	bool needsLastStack() const override;
 	CGTownInstance::EFortLevel fortLevel() const;
+	TownFortifications fortificationsLevel() const;
 	int hallLevel() const; // -1 - none, 0 - village, 1 - town, 2 - city, 3 - capitol
 	int mageGuildLevel() const; // -1 - none, 0 - village, 1 - town, 2 - city, 3 - capitol
 	int getHordeLevel(const int & HID) const; //HID - 0 or 1; returns creature level or -1 if that horde structure is not present
@@ -163,21 +176,26 @@
 	GrowthInfo getGrowthInfo(int level) const;
 	bool hasFort() const;
 	bool hasCapitol() const;
-	std::vector<const CGTownBuilding *> getBonusingBuildings(BuildingSubID::EBuildingSubID subId) const;
 	bool hasBuiltSomeTradeBuilding() const;
 	//checks if special building with type buildingID is constructed
 	bool hasBuilt(BuildingSubID::EBuildingSubID buildingID) const;
 	//checks if building is constructed and town has same subID
 	bool hasBuilt(const BuildingID & buildingID) const;
 	bool hasBuilt(const BuildingID & buildingID, FactionID townID) const;
+	void addBuilding(const BuildingID & buildingID);
+	void removeBuilding(const BuildingID & buildingID);
+	void removeAllBuildings();
+	std::set<BuildingID> getBuildings() const;
 
 	TResources getBuildingCost(const BuildingID & buildingID) const;
-	TResources dailyIncome() const; //calculates daily income of this town
+	ResourceSet dailyIncome() const override;
+	std::vector<CreatureID> providedCreatures() const override;
+
 	int spellsAtLevel(int level, bool checkGuild) const; //levels are counted from 1 (1 - 5)
 	bool armedGarrison() const; //true if town has creatures in garrison or garrisoned hero
 	int getTownLevel() const;
 
-	CBuilding::TRequired genBuildingRequirements(const BuildingID & build, bool deep = false) const;
+	LogicalExpression<BuildingID> genBuildingRequirements(const BuildingID & build, bool deep = false) const;
 
 	void mergeGarrisonOnSiege() const; // merge garrison into army of visiting hero
 	void removeCapitols(const PlayerColor & owner) const;
@@ -192,20 +210,26 @@
 	DamageRange getKeepDamageRange() const;
 
 	const CTown * getTown() const;
+	const CFaction * getFaction() const;
 
 	/// INativeTerrainProvider
-	FactionID getFaction() const override;
+	FactionID getFactionID() const override;
 	TerrainId getNativeTerrain() const override;
 
+	/// Returns ID of war machine that is produced by specified building or NONE if this is not built or if building does not produce war machines
+	ArtifactID getWarMachineInBuilding(BuildingID) const;
+	/// Returns true if provided war machine is available in any of built buildings of this town
+	bool isWarMachineAvailable(ArtifactID) const;
+
 	CGTownInstance(IGameCallback *cb);
 	virtual ~CGTownInstance();
 
 	///IObjectInterface overrides
-	void newTurn(CRandomGenerator & rand) const override;
+	void newTurn(vstd::RNG & rand) const override;
 	void onHeroVisit(const CGHeroInstance * h) const override;
 	void onHeroLeave(const CGHeroInstance * h) const override;
-	void initObj(CRandomGenerator & rand) override;
-	void pickRandomObject(CRandomGenerator & rand) override;
+	void initObj(vstd::RNG & rand) override;
+	void pickRandomObject(vstd::RNG & rand) override;
 	void battleFinished(const CGHeroInstance * hero, const BattleResult & result) const override;
 	std::string getObjectName() const override;
 
@@ -221,17 +245,15 @@
 protected:
 	void setPropertyDer(ObjProperty what, ObjPropertyID identifier) override;
 	void serializeJsonOptions(JsonSerializeFormat & handler) override;
-	void blockingDialogAnswered(const CGHeroInstance *hero, ui32 answer) const override;
 
 private:
-	FactionID randomizeFaction(CRandomGenerator & rand);
+	FactionID randomizeFaction(vstd::RNG & rand);
 	void setOwner(const PlayerColor & owner) const;
 	void onTownCaptured(const PlayerColor & winner) const;
-	int getDwellingBonus(const std::vector<CreatureID>& creatureIds, const std::vector<ConstTransitivePtr<CGDwelling> >& dwellings) const;
+	int getDwellingBonus(const std::vector<CreatureID>& creatureIds, const std::vector<const CGObjectInstance* >& dwellings) const;
 	bool townEnvisagesBuilding(BuildingSubID::EBuildingSubID bid) const;
-	bool isBonusingBuildingAdded(BuildingID bid) const;
-	void initOverriddenBids();
-	void addTownBonuses(CRandomGenerator & rand);
+	void initializeConfigurableBuildings(vstd::RNG & rand);
+	void initializeNeutralTownGarrison(vstd::RNG & rand);
 };
 
 VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/mapObjects/CompoundMapObjectID.h vcmi/lib/mapObjects/CompoundMapObjectID.h
--- vcmi-1.5.7/lib/mapObjects/CompoundMapObjectID.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/mapObjects/CompoundMapObjectID.h	2024-12-19 15:00:22.914148599 +0100
@@ -0,0 +1,37 @@
+/*
+ * CompoundMapObjectID.h, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#pragma once
+
+#include "../constants/EntityIdentifiers.h"
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+struct DLL_LINKAGE CompoundMapObjectID
+{
+	si32 primaryID;
+	si32 secondaryID;
+
+	CompoundMapObjectID(si32 primID, si32 secID) : primaryID(primID), secondaryID(secID) {};
+
+	bool operator<(const CompoundMapObjectID& other) const
+	{
+		if(this->primaryID != other.primaryID)
+			return this->primaryID < other.primaryID;
+		else
+			return this->secondaryID < other.secondaryID;
+	}
+
+	bool operator==(const CompoundMapObjectID& other) const
+	{
+		return (this->primaryID == other.primaryID) && (this->secondaryID == other.secondaryID);
+	}
+};
+
+VCMI_LIB_NAMESPACE_END
\ No newline at end of file
diff --color -urN vcmi-1.5.7/lib/mapObjects/CQuest.cpp vcmi/lib/mapObjects/CQuest.cpp
--- vcmi-1.5.7/lib/mapObjects/CQuest.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapObjects/CQuest.cpp	2024-12-19 15:00:22.914148599 +0100
@@ -15,10 +15,10 @@
 
 #include "../ArtifactUtils.h"
 #include "../CSoundBase.h"
-#include "../CGeneralTextHandler.h"
-#include "../CHeroHandler.h"
+#include "../texts/CGeneralTextHandler.h"
 #include "CGCreature.h"
 #include "../IGameCallback.h"
+#include "../entities/hero/CHeroHandler.h"
 #include "../mapObjectConstructors/CObjectClassesHandler.h"
 #include "../serializer/JsonSerializeFormat.h"
 #include "../GameConstants.h"
@@ -31,7 +31,8 @@
 #include "../modding/ModUtility.h"
 #include "../networkPacks/PacksForClient.h"
 #include "../spells/CSpellHandler.h"
-#include "../CRandomGenerator.h"
+
+#include <vstd/RNG.h>
 
 VCMI_LIB_NAMESPACE_BEGIN
 
@@ -109,7 +110,7 @@
 	{
 		for(count = 0, it = army->Slots().begin(); it != army->Slots().end(); ++it)
 		{
-			if(it->second->type == cre->type)
+			if(it->second->getType() == cre->getType())
 			{
 				count += it->second->count;
 				slotsCount++;
@@ -151,7 +152,7 @@
 		}
 		else
 		{
-			const auto * assembly = h->getAssemblyByConstituent(elem);
+			const auto * assembly = h->getCombinedArtWithPart(elem);
 			assert(assembly);
 			auto parts = assembly->getPartsInfo();
 
@@ -162,7 +163,7 @@
 			for(const auto & ci : parts)
 			{
 				if(ci.art->getTypeId() != elem)
-					cb->giveHeroNewArtifact(h, ci.art->artType, ArtifactPosition::BACKPACK_START);
+					cb->giveHeroNewArtifact(h, ci.art->getTypeId(), ArtifactPosition::BACKPACK_START);
 			}
 		}
 	}
@@ -430,7 +431,7 @@
 	
 	if(getCreatureToKill(true))
 	{
-		quest->stackToKill = getCreatureToKill(false)->getCreature();
+		quest->stackToKill = getCreatureToKill(false)->getCreatureID();
 		assert(quest->stackToKill != CreatureID::NONE);
 		quest->stackDirection = checkDirection();
 	}
@@ -441,7 +442,7 @@
 	}
 }
 
-void CGSeerHut::init(CRandomGenerator & rand)
+void CGSeerHut::init(vstd::RNG & rand)
 {
 	auto names = VLC->generaltexth->findStringsWithPrefix("core.seerhut.names");
 
@@ -455,7 +456,7 @@
 	configuration.selectMode = Rewardable::ESelectMode::SELECT_PLAYER;
 }
 
-void CGSeerHut::initObj(CRandomGenerator & rand)
+void CGSeerHut::initObj(vstd::RNG & rand)
 {
 	init(rand);
 	
@@ -562,7 +563,7 @@
 	}
 }
 
-void CGSeerHut::newTurn(CRandomGenerator & rand) const
+void CGSeerHut::newTurn(vstd::RNG & rand) const
 {
 	CRewardableObject::newTurn(rand);
 	if(quest->lastDay >= 0 && quest->lastDay <= cb->getDate() - 1) //time is up
@@ -587,7 +588,7 @@
 			AddQuest aq;
 			aq.quest = QuestInfo (quest, this, visitablePos());
 			aq.player = h->tempOwner;
-			cb->sendAndApply(&aq); //TODO: merge with setObjProperty?
+			cb->sendAndApply(aq); //TODO: merge with setObjProperty?
 		}
 
 		if(firstVisit || failRequirements)
@@ -613,7 +614,7 @@
 
 int CGSeerHut::checkDirection() const
 {
-	int3 cord = getCreatureToKill(false)->pos;
+	int3 cord = getCreatureToKill(false)->visitablePos();
 	if(static_cast<double>(cord.x) / static_cast<double>(cb->getMapSize().x) < 0.34) //north
 	{
 		if(static_cast<double>(cord.y) / static_cast<double>(cb->getMapSize().y) < 0.34) //northwest
@@ -659,7 +660,7 @@
 	return dynamic_cast<const CGCreature *>(o);
 }
 
-void CGSeerHut::blockingDialogAnswered(const CGHeroInstance *hero, ui32 answer) const
+void CGSeerHut::blockingDialogAnswered(const CGHeroInstance *hero, int32_t answer) const
 {
 	CRewardableObject::blockingDialogAnswered(hero, answer);
 	if(answer)
@@ -750,7 +751,7 @@
 	}
 }
 
-void CGQuestGuard::init(CRandomGenerator & rand)
+void CGQuestGuard::init(vstd::RNG & rand)
 {
 	blockVisit = true;
 	quest->textOption = rand.nextInt(3, 5);
@@ -810,7 +811,7 @@
 		cow.mode = ChangeObjectVisitors::VISITOR_GLOBAL;
 		cow.hero = h->id;
 		cow.object = id;
-		cb->sendAndApply(&cow);
+		cb->sendAndApply(cow);
 		txt_id=19;
 	}
 	else
@@ -818,7 +819,7 @@
 	h->showInfoDialog(txt_id);
 }
 
-void CGBorderGuard::initObj(CRandomGenerator & rand)
+void CGBorderGuard::initObj(vstd::RNG & rand)
 {
 	blockVisit = true;
 }
@@ -850,7 +851,7 @@
 		BlockingDialog bd (true, false);
 		bd.player = h->getOwner();
 		bd.text.appendLocalString (EMetaText::ADVOB_TXT, 17);
-		cb->showBlockingDialog (&bd);
+		cb->showBlockingDialog (this, &bd);
 	}
 	else
 	{
@@ -859,12 +860,12 @@
 		AddQuest aq;
 		aq.quest = QuestInfo (quest, this, visitablePos());
 		aq.player = h->tempOwner;
-		cb->sendAndApply (&aq);
+		cb->sendAndApply(aq);
 		//TODO: add this quest only once OR check for multiple instances later
 	}
 }
 
-void CGBorderGuard::blockingDialogAnswered(const CGHeroInstance *hero, ui32 answer) const
+void CGBorderGuard::blockingDialogAnswered(const CGHeroInstance *hero, int32_t answer) const
 {
 	if (answer)
 		cb->removeObject(this, hero->getOwner());
@@ -884,7 +885,7 @@
 		AddQuest aq;
 		aq.quest = QuestInfo (quest, this, visitablePos());
 		aq.player = h->tempOwner;
-		cb->sendAndApply (&aq);
+		cb->sendAndApply(aq);
 	}
 }
 
diff --color -urN vcmi-1.5.7/lib/mapObjects/CQuest.h vcmi/lib/mapObjects/CQuest.h
--- vcmi-1.5.7/lib/mapObjects/CQuest.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapObjects/CQuest.h	2024-12-19 15:00:22.914148599 +0100
@@ -11,7 +11,8 @@
 
 #include "CRewardableObject.h"
 #include "../ResourceSet.h"
-#include "../MetaString.h"
+#include "../serializer/Serializeable.h"
+#include "../texts/MetaString.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
@@ -36,7 +37,7 @@
 	HOTA_REACH_DATE = 13,
 };
 
-class DLL_LINKAGE CQuest final
+class DLL_LINKAGE CQuest final : public Serializeable
 {
 public:
 
@@ -74,13 +75,13 @@
 	CQuest(); //TODO: Remove constructor
 
 	static bool checkMissionArmy(const CQuest * q, const CCreatureSet * army);
-	virtual bool checkQuest(const CGHeroInstance * h) const; //determines whether the quest is complete or not
-	virtual void getVisitText(IGameCallback * cb, MetaString &text, std::vector<Component> & components, bool FirstVisit, const CGHeroInstance * h = nullptr) const;
-	virtual void getCompletionText(IGameCallback * cb, MetaString &text) const;
-	virtual void getRolloverText (IGameCallback * cb, MetaString &text, bool onHover) const; //hover or quest log entry
-	virtual void completeQuest(IGameCallback *, const CGHeroInstance * h) const;
-	virtual void addTextReplacements(IGameCallback * cb, MetaString &out, std::vector<Component> & components) const;
-	virtual void addKillTargetReplacements(MetaString &out) const;
+	bool checkQuest(const CGHeroInstance * h) const; //determines whether the quest is complete or not
+	void getVisitText(IGameCallback * cb, MetaString &text, std::vector<Component> & components, bool FirstVisit, const CGHeroInstance * h = nullptr) const;
+	void getCompletionText(IGameCallback * cb, MetaString &text) const;
+	void getRolloverText (IGameCallback * cb, MetaString &text, bool onHover) const; //hover or quest log entry
+	void completeQuest(IGameCallback *, const CGHeroInstance * h) const;
+	void addTextReplacements(IGameCallback * cb, MetaString &out, std::vector<Component> & components) const;
+	void addKillTargetReplacements(MetaString &out) const;
 	void defineQuestName();
 
 	bool operator== (const CQuest & quest) const
@@ -114,7 +115,7 @@
 	void serializeJson(JsonSerializeFormat & handler, const std::string & fieldName);
 };
 
-class DLL_LINKAGE IQuestObject
+class DLL_LINKAGE IQuestObject : public virtual Serializeable
 {
 public:
 	CQuest * quest = new CQuest();
@@ -140,19 +141,19 @@
 
 	std::string seerName;
 
-	void initObj(CRandomGenerator & rand) override;
+	void initObj(vstd::RNG & rand) override;
 	std::string getHoverText(PlayerColor player) const override;
 	std::string getHoverText(const CGHeroInstance * hero) const override;
 	std::string getPopupText(PlayerColor player) const override;
 	std::string getPopupText(const CGHeroInstance * hero) const override;
 	std::vector<Component> getPopupComponents(PlayerColor player) const override;
 	std::vector<Component> getPopupComponents(const CGHeroInstance * hero) const override;
-	void newTurn(CRandomGenerator & rand) const override;
+	void newTurn(vstd::RNG & rand) const override;
 	void onHeroVisit(const CGHeroInstance * h) const override;
-	void blockingDialogAnswered(const CGHeroInstance *hero, ui32 answer) const override;
+	void blockingDialogAnswered(const CGHeroInstance *hero, int32_t answer) const override;
 	void getVisitText (MetaString &text, std::vector<Component> &components, bool FirstVisit, const CGHeroInstance * h = nullptr) const override;
 
-	virtual void init(CRandomGenerator & rand);
+	virtual void init(vstd::RNG & rand);
 	int checkDirection() const; //calculates the region of map where monster is placed
 	void setObjToKill(); //remember creatures / heroes to kill after they are initialized
 	const CGHeroInstance *getHeroToKill(bool allowNull) const;
@@ -178,7 +179,7 @@
 public:
 	using CGSeerHut::CGSeerHut;
 
-	void init(CRandomGenerator & rand) override;
+	void init(vstd::RNG & rand) override;
 	
 	void onHeroVisit(const CGHeroInstance * h) const override;
 	bool passableFor(PlayerColor color) const override;
@@ -226,9 +227,9 @@
 public:
 	using CGKeys::CGKeys;
 
-	void initObj(CRandomGenerator & rand) override;
+	void initObj(vstd::RNG & rand) override;
 	void onHeroVisit(const CGHeroInstance * h) const override;
-	void blockingDialogAnswered(const CGHeroInstance *hero, ui32 answer) const override;
+	void blockingDialogAnswered(const CGHeroInstance *hero, int32_t answer) const override;
 
 	void getVisitText (MetaString &text, std::vector<Component> &components, bool FirstVisit, const CGHeroInstance * h = nullptr) const override;
 	void getRolloverText (MetaString &text, bool onHover) const;
diff --color -urN vcmi-1.5.7/lib/mapObjects/CRewardableObject.cpp vcmi/lib/mapObjects/CRewardableObject.cpp
--- vcmi-1.5.7/lib/mapObjects/CRewardableObject.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapObjects/CRewardableObject.cpp	2024-12-19 15:00:22.914148599 +0100
@@ -10,207 +10,92 @@
 
 #include "StdInc.h"
 #include "CRewardableObject.h"
-#include "../gameState/CGameState.h"
-#include "../CGeneralTextHandler.h"
+
 #include "../CPlayerState.h"
 #include "../IGameCallback.h"
+#include "../IGameSettings.h"
+#include "../battle/BattleLayout.h"
+#include "../gameState/CGameState.h"
 #include "../mapObjectConstructors/AObjectTypeHandler.h"
-#include "../mapObjectConstructors/CObjectClassesHandler.h"
+#include "../mapObjectConstructors/CRewardableConstructor.h"
 #include "../mapObjects/CGHeroInstance.h"
 #include "../networkPacks/PacksForClient.h"
+#include "../networkPacks/PacksForClientBattle.h"
 #include "../serializer/JsonSerializeFormat.h"
 
+#include <vstd/RNG.h>
+
 VCMI_LIB_NAMESPACE_BEGIN
 
-void CRewardableObject::grantRewardWithMessage(const CGHeroInstance * contextHero, int index, bool markAsVisit) const
+const IObjectInterface * CRewardableObject::getObject() const
 {
-	auto vi = configuration.info.at(index);
-	logGlobal->debug("Granting reward %d. Message says: %s", index, vi.message.toString());
-	// show message only if it is not empty or in infobox
-	if (configuration.infoWindowType != EInfoWindowMode::MODAL || !vi.message.toString().empty())
-	{
-		InfoWindow iw;
-		iw.player = contextHero->tempOwner;
-		iw.text = vi.message;
-		vi.reward.loadComponents(iw.components, contextHero);
-		iw.type = configuration.infoWindowType;
-		if(!iw.components.empty() || !iw.text.toString().empty())
-			cb->showInfoDialog(&iw);
-	}
-	// grant reward afterwards. Note that it may remove object
-	if(markAsVisit)
-		markAsVisited(contextHero);
-	grantReward(index, contextHero);
+	return this;
 }
 
-void CRewardableObject::selectRewardWthMessage(const CGHeroInstance * contextHero, const std::vector<ui32> & rewardIndices, const MetaString & dialog) const
+void CRewardableObject::markAsScouted(const CGHeroInstance * hero) const
 {
-	BlockingDialog sd(configuration.canRefuse, rewardIndices.size() > 1);
-	sd.player = contextHero->tempOwner;
-	sd.text = dialog;
-	sd.components = loadComponents(contextHero, rewardIndices);
-	cb->showBlockingDialog(&sd);
-
+	ChangeObjectVisitors cov(ChangeObjectVisitors::VISITOR_ADD_PLAYER, id, hero->id);
+	cb->sendAndApply(cov);
 }
 
-void CRewardableObject::grantAllRewardsWthMessage(const CGHeroInstance * contextHero, const std::vector<ui32> & rewardIndices, bool markAsVisit) const
+bool CRewardableObject::isGuarded() const
 {
-	if (rewardIndices.empty())
-		return;
-		
-	for (auto index : rewardIndices)
-	{
-		// TODO: Merge all rewards of same type, with single message?
-		grantRewardWithMessage(contextHero, index, false);
-	}
-	// Mark visited only after all rewards were processed
-	if(markAsVisit)
-		markAsVisited(contextHero);
+	return stacksCount() > 0;
 }
 
-std::vector<Component> CRewardableObject::loadComponents(const CGHeroInstance * contextHero, const std::vector<ui32> & rewardIndices) const
+void CRewardableObject::onHeroVisit(const CGHeroInstance *hero) const
 {
-	std::vector<Component> result;
-
-	if (rewardIndices.empty())
-		return result;
-
-	if (configuration.selectMode != Rewardable::SELECT_FIRST && rewardIndices.size() > 1)
-	{
-		for (auto index : rewardIndices)
-			result.push_back(configuration.info.at(index).reward.getDisplayedComponent(contextHero));
-	}
-	else
+	if(!wasScouted(hero->getOwner()))
 	{
-		configuration.info.at(rewardIndices.front()).reward.loadComponents(result, contextHero);
+		ChangeObjectVisitors cov(ChangeObjectVisitors::VISITOR_SCOUTED, id, hero->id);
+		cb->sendAndApply(cov);
 	}
 
-	return result;
-}
-
-void CRewardableObject::onHeroVisit(const CGHeroInstance *h) const
-{
-	if(!wasVisitedBefore(h))
+	if (isGuarded())
 	{
-		auto rewards = getAvailableRewards(h, Rewardable::EEventType::EVENT_FIRST_VISIT);
-		bool objectRemovalPossible = false;
-		for(auto index : rewards)
-		{
-			if(configuration.info.at(index).reward.removeObject)
-				objectRemovalPossible = true;
-		}
+		auto guardedIndexes = getAvailableRewards(hero, Rewardable::EEventType::EVENT_GUARDED);
+		auto guardedReward = configuration.info.at(guardedIndexes.at(0));
 
-		logGlobal->debug("Visiting object with %d possible rewards", rewards.size());
-		switch (rewards.size())
-		{
-			case 0: // no available rewards, e.g. visiting School of War without gold
-			{
-				auto emptyRewards = getAvailableRewards(h, Rewardable::EEventType::EVENT_NOT_AVAILABLE);
-				if (!emptyRewards.empty())
-					grantRewardWithMessage(h, emptyRewards[0], false);
-				else
-					logMod->warn("No applicable message for visiting empty object!");
-				break;
-			}
-			case 1: // one reward. Just give it with message
-			{
-				if (configuration.canRefuse)
-					selectRewardWthMessage(h, rewards, configuration.info.at(rewards.front()).message);
-				else
-					grantRewardWithMessage(h, rewards.front(), true);
-				break;
-			}
-			default: // multiple rewards. Act according to select mode
-			{
-				switch (configuration.selectMode) {
-					case Rewardable::SELECT_PLAYER: // player must select
-						selectRewardWthMessage(h, rewards, configuration.onSelect);
-						break;
-					case Rewardable::SELECT_FIRST: // give first available
-						if (configuration.canRefuse)
-							selectRewardWthMessage(h, { rewards.front() }, configuration.info.at(rewards.front()).message);
-						else
-							grantRewardWithMessage(h, rewards.front(), true);
-						break;
-					case Rewardable::SELECT_RANDOM: // give random
-					{
-						ui32 rewardIndex = *RandomGeneratorUtil::nextItem(rewards, cb->gameState()->getRandomGenerator());
-						if (configuration.canRefuse)
-							selectRewardWthMessage(h, { rewardIndex }, configuration.info.at(rewardIndex).message);
-						else
-							grantRewardWithMessage(h, rewardIndex, true);
-						break;
-					}
-					case Rewardable::SELECT_ALL: // grant all possible
-						grantAllRewardsWthMessage(h, rewards, true);
-						break;
-				}
-				break;
-			}
-		}
+		// ask player to confirm attack
+		BlockingDialog bd(true, false);
+		bd.player = hero->getOwner();
+		bd.text = guardedReward.message;
+		bd.components = getPopupComponents(hero->getOwner());
 
-		if(!objectRemovalPossible && getAvailableRewards(h, Rewardable::EEventType::EVENT_FIRST_VISIT).empty())
-		{
-			ChangeObjectVisitors cov(ChangeObjectVisitors::VISITOR_ADD_TEAM, id, h->id);
-			cb->sendAndApply(&cov);
-		}
+		cb->showBlockingDialog(this, &bd);
 	}
 	else
 	{
-		logGlobal->debug("Revisiting already visited object");
-
-		if (!wasVisited(h->getOwner()))
-		{
-			ChangeObjectVisitors cov(ChangeObjectVisitors::VISITOR_ADD_TEAM, id, h->id);
-			cb->sendAndApply(&cov);
-		}
-
-		auto visitedRewards = getAvailableRewards(h, Rewardable::EEventType::EVENT_ALREADY_VISITED);
-		if (!visitedRewards.empty())
-			grantRewardWithMessage(h, visitedRewards[0], false);
-		else
-			logMod->warn("No applicable message for visiting already visited object!");
+		doHeroVisit(hero);
 	}
 }
 
 void CRewardableObject::heroLevelUpDone(const CGHeroInstance *hero) const
 {
-	grantRewardAfterLevelup(cb, configuration.info.at(selectedReward), this, hero);
+	grantRewardAfterLevelup(configuration.info.at(selectedReward), this, hero);
 }
 
-void CRewardableObject::blockingDialogAnswered(const CGHeroInstance *hero, ui32 answer) const
+void CRewardableObject::battleFinished(const CGHeroInstance *hero, const BattleResult &result) const
 {
-	if(answer == 0)
+	if (result.winner == BattleSide::ATTACKER)
 	{
-		switch (configuration.visitMode)
-		{
-			case Rewardable::VISIT_UNLIMITED:
-			case Rewardable::VISIT_BONUS:
-			case Rewardable::VISIT_HERO:
-			case Rewardable::VISIT_LIMITER:
-			{
-				// workaround for object with refusable reward not getting marked as visited
-				// TODO: better solution that would also work for player-visitable objects
-				if (!wasScouted(hero->getOwner()))
-				{
-					ChangeObjectVisitors cov(ChangeObjectVisitors::VISITOR_ADD_TEAM, id, hero->id);
-					cb->sendAndApply(&cov);
-				}
-			}
-		}
-
-		return; // player refused
+		doHeroVisit(hero);
 	}
+}
 
-	if(answer > 0 && answer-1 < configuration.info.size())
+void CRewardableObject::blockingDialogAnswered(const CGHeroInstance * hero, int32_t answer) const
+{
+	if(isGuarded())
 	{
-		auto list = getAvailableRewards(hero, Rewardable::EEventType::EVENT_FIRST_VISIT);
-		markAsVisited(hero);
-		grantReward(list[answer - 1], hero);
+		if (answer)
+		{
+			auto layout = BattleLayout::createLayout(cb, configuration.guardsLayout, hero, this);
+			cb->startBattle(hero, this, visitablePos(), hero, nullptr, layout, nullptr);
+		}
 	}
 	else
 	{
-		throw std::runtime_error("Unhandled choice");
+		onBlockingDialogAnswered(hero, answer);
 	}
 }
 
@@ -218,19 +103,19 @@
 {
 	cb->setObjPropertyValue(id, ObjProperty::REWARD_CLEARED, true);
 
-	ChangeObjectVisitors cov(ChangeObjectVisitors::VISITOR_ADD, id, hero->id);
-	cb->sendAndApply(&cov);
+	ChangeObjectVisitors cov(ChangeObjectVisitors::VISITOR_ADD_HERO, id, hero->id);
+	cb->sendAndApply(cov);
 }
 
 void CRewardableObject::grantReward(ui32 rewardID, const CGHeroInstance * hero) const
 {
 	cb->setObjPropertyValue(id, ObjProperty::REWARD_SELECT, rewardID);
-	grantRewardBeforeLevelup(cb, configuration.info.at(rewardID), hero);
+	grantRewardBeforeLevelup(configuration.info.at(rewardID), hero);
 	
-	// hero is not blocked by levelup dialog - grant remainer immediately
+	// hero is not blocked by levelup dialog - grant remainder immediately
 	if(!cb->isVisitCoveredByAnotherQuery(this, hero))
 	{
-		grantRewardAfterLevelup(cb, configuration.info.at(rewardID), this, hero);
+		grantRewardAfterLevelup(configuration.info.at(rewardID), this, hero);
 	}
 }
 
@@ -274,7 +159,7 @@
 
 bool CRewardableObject::wasScouted(PlayerColor player) const
 {
-	return vstd::contains(cb->getPlayerState(player)->visitedObjects, ObjectInstanceID(id));
+	return vstd::contains(cb->getPlayerTeam(player)->scoutedObjects, ObjectInstanceID(id));
 }
 
 bool CRewardableObject::wasVisited(const CGHeroInstance * h) const
@@ -362,22 +247,44 @@
 	if (!wasScouted(player))
 		return {};
 
-	if (!configuration.showScoutedPreview)
-		return {};
-
-	auto rewardIndices = getAvailableRewards(hero, Rewardable::EEventType::EVENT_FIRST_VISIT);
-	if (rewardIndices.empty() && !configuration.info.empty())
+	if (isGuarded())
 	{
-		// Object has valid config, but current hero has no rewards that he can receive.
-		// Usually this happens if hero has already visited this object -> show reward using context without any hero
-		// since reward may be context-sensitive - e.g. Witch Hut that gives 1 skill, but always at basic level
-		return loadComponents(nullptr, {0});
+		if (!cb->getSettings().getBoolean(EGameSettings::BANKS_SHOW_GUARDS_COMPOSITION))
+			return {};
+
+		std::map<CreatureID, int> guardsAmounts;
+		std::vector<Component> result;
+
+		for (auto const & slot : Slots())
+			if (slot.second)
+				guardsAmounts[slot.second->getCreatureID()] += slot.second->getCount();
+
+		for (auto const & guard : guardsAmounts)
+		{
+			Component comp(ComponentType::CREATURE, guard.first, guard.second);
+			result.push_back(comp);
+		}
+		return result;
 	}
+	else
+	{
+		if (!configuration.showScoutedPreview)
+			return {};
 
-	if (rewardIndices.empty())
-		return {};
+		auto rewardIndices = getAvailableRewards(hero, Rewardable::EEventType::EVENT_FIRST_VISIT);
+		if (rewardIndices.empty() && !configuration.info.empty())
+		{
+			// Object has valid config, but current hero has no rewards that he can receive.
+			// Usually this happens if hero has already visited this object -> show reward using context without any hero
+			// since reward may be context-sensitive - e.g. Witch Hut that gives 1 skill, but always at basic level
+			return loadComponents(nullptr, {0});
+		}
 
-	return loadComponents(hero, rewardIndices);
+		if (rewardIndices.empty())
+			return {};
+
+		return loadComponents(hero, rewardIndices);
+	}
 }
 
 std::vector<Component> CRewardableObject::getPopupComponents(PlayerColor player) const
@@ -394,9 +301,6 @@
 {
 	switch (what)
 	{
-		case ObjProperty::REWARD_RANDOMIZE:
-			initObj(cb->gameState()->getRandomGenerator());
-			break;
 		case ObjProperty::REWARD_SELECT:
 			selectedReward = identifier.getNum();
 			break;
@@ -406,24 +310,26 @@
 	}
 }
 
-void CRewardableObject::newTurn(CRandomGenerator & rand) const
+void CRewardableObject::newTurn(vstd::RNG & rand) const
 {
 	if (configuration.resetParameters.period != 0 && cb->getDate(Date::DAY) > 1 && ((cb->getDate(Date::DAY)-1) % configuration.resetParameters.period) == 0)
 	{
 		if (configuration.resetParameters.rewards)
 		{
-			cb->setObjPropertyValue(id, ObjProperty::REWARD_RANDOMIZE, 0);
+			auto handler = std::dynamic_pointer_cast<const CRewardableConstructor>(getObjectHandler());
+			auto newConfiguration = handler->generateConfiguration(cb, rand, ID, configuration.variables.preset);
+			cb->setRewardableObjectConfiguration(id, newConfiguration);
 		}
 		if (configuration.resetParameters.visitors)
 		{
 			cb->setObjPropertyValue(id, ObjProperty::REWARD_CLEARED, false);
 			ChangeObjectVisitors cov(ChangeObjectVisitors::VISITOR_CLEAR, id);
-			cb->sendAndApply(&cov);
+			cb->sendAndApply(cov);
 		}
 	}
 }
 
-void CRewardableObject::initObj(CRandomGenerator & rand)
+void CRewardableObject::initObj(vstd::RNG & rand)
 {
 	getObjectHandler()->configureObject(this, rand);
 }
@@ -438,4 +344,31 @@
 	handler.serializeStruct("rewardable", static_cast<Rewardable::Interface&>(*this));
 }
 
+void CRewardableObject::initializeGuards()
+{
+	clearSlots();
+
+	// Workaround for default creature banks strings that has placeholder for object name
+	// TODO: find better location for this code
+	for (auto & visitInfo : configuration.info)
+		visitInfo.message.replaceRawString(getObjectName());
+
+	for (auto const & visitInfo : configuration.info)
+	{
+		for (auto const & guard : visitInfo.reward.guards)
+		{
+			auto slotID = getFreeSlot();
+			if (!slotID.validSlot())
+				return;
+
+			putStack(slotID, new CStackInstance(guard.getId(), guard.getCount()));
+		}
+	}
+}
+
+bool CRewardableObject::isCoastVisitable() const
+{
+	return configuration.coastVisitable;
+}
+
 VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/mapObjects/CRewardableObject.h vcmi/lib/mapObjects/CRewardableObject.h
--- vcmi-1.5.7/lib/mapObjects/CRewardableObject.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapObjects/CRewardableObject.h	2024-12-19 15:00:22.914148599 +0100
@@ -15,7 +15,7 @@
 VCMI_LIB_NAMESPACE_BEGIN
 
 /// Base class that can handle granting rewards to visiting heroes.
-/// Inherits from CArmedInstance for proper trasfer of armies
+/// Inherits from CArmedInstance for proper transfer of armies
 class DLL_LINKAGE CRewardableObject : public CArmedInstance, public Rewardable::Interface
 {
 protected:
@@ -25,27 +25,26 @@
 	/// reward selected by player, no serialize
 	ui16 selectedReward = 0;
 	
-	void grantReward(ui32 rewardID, const CGHeroInstance * hero) const;
-	void markAsVisited(const CGHeroInstance * hero) const;
+	void grantReward(ui32 rewardID, const CGHeroInstance * hero) const override;
+	void markAsVisited(const CGHeroInstance * hero) const override;
+
+	const IObjectInterface * getObject() const override;
+	void markAsScouted(const CGHeroInstance * hero) const override;
 	
 	/// return true if this object was "cleared" before and no longer has rewards applicable to selected hero
 	/// unlike wasVisited, this method uses information not available to player owner, for example, if object was cleared by another player before
-	bool wasVisitedBefore(const CGHeroInstance * contextHero) const;
+	bool wasVisitedBefore(const CGHeroInstance * contextHero) const override;
 	
 	void serializeJsonOptions(JsonSerializeFormat & handler) override;
 	
-	virtual void grantRewardWithMessage(const CGHeroInstance * contextHero, int rewardIndex, bool markAsVisit) const;
-	virtual void selectRewardWthMessage(const CGHeroInstance * contextHero, const std::vector<ui32> & rewardIndices, const MetaString & dialog) const;
-
-	virtual void grantAllRewardsWthMessage(const CGHeroInstance * contextHero, const std::vector<ui32>& rewardIndices, bool markAsVisit) const;
-
-	std::vector<Component> loadComponents(const CGHeroInstance * contextHero, const std::vector<ui32> & rewardIndices) const;
-
 	std::string getDisplayTextImpl(PlayerColor player, const CGHeroInstance * hero, bool includeDescription) const;
 	std::string getDescriptionMessage(PlayerColor player, const CGHeroInstance * hero) const;
 	std::vector<Component> getPopupComponentsImpl(PlayerColor player, const CGHeroInstance * hero) const;
 
+	/// Returns true if this object is currently guarded
+	bool isGuarded() const;
 public:
+
 	/// Visitability checks. Note that hero check includes check for hero owner (returns true if object was visited by player)
 	bool wasVisited(PlayerColor player) const override;
 	bool wasVisited(const CGHeroInstance * h) const override;
@@ -56,16 +55,22 @@
 	/// gives reward to player or ask for choice in case of multiple rewards
 	void onHeroVisit(const CGHeroInstance *h) const override;
 
+	void battleFinished(const CGHeroInstance *hero, const BattleResult &result) const override;
+
 	///possibly resets object state
-	void newTurn(CRandomGenerator & rand) const override;
+	void newTurn(vstd::RNG & rand) const override;
 
 	/// gives second part of reward after hero level-ups for proper granting of spells/mana
 	void heroLevelUpDone(const CGHeroInstance *hero) const override;
 
 	/// applies player selection of reward
-	void blockingDialogAnswered(const CGHeroInstance *hero, ui32 answer) const override;
+	void blockingDialogAnswered(const CGHeroInstance *hero, int32_t answer) const override;
+
+	void initObj(vstd::RNG & rand) override;
 
-	void initObj(CRandomGenerator & rand) override;
+	bool isCoastVisitable() const override;
+
+	void initializeGuards();
 	
 	void setPropertyDer(ObjProperty what, ObjPropertyID identifier) override;
 
@@ -89,14 +94,6 @@
 };
 
 //TODO:
-
-// MAX
-// class DLL_LINKAGE CBank : public CArmedInstance
-// class DLL_LINKAGE CGPyramid : public CBank
-
-// EXTRA
-// class DLL_LINKAGE COPWBonus : public CGTownBuilding
-// class DLL_LINKAGE CTownBonus : public CGTownBuilding
 // class DLL_LINKAGE CGKeys : public CGObjectInstance //Base class for Keymaster and guards
 // class DLL_LINKAGE CGKeymasterTent : public CGKeys
 // class DLL_LINKAGE CGBorderGuard : public CGKeys, public IQuestObject
diff --color -urN vcmi-1.5.7/lib/mapObjects/FlaggableMapObject.cpp vcmi/lib/mapObjects/FlaggableMapObject.cpp
--- vcmi-1.5.7/lib/mapObjects/FlaggableMapObject.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/mapObjects/FlaggableMapObject.cpp	2024-12-19 15:00:22.914148599 +0100
@@ -0,0 +1,111 @@
+/*
+ * FlaggableMapObject.cpp, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+
+#include "StdInc.h"
+#include "FlaggableMapObject.h"
+
+#include "../IGameCallback.h"
+#include "CGHeroInstance.h"
+#include "../networkPacks/PacksForClient.h"
+#include "../mapObjectConstructors/FlaggableInstanceConstructor.h"
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+const IOwnableObject * FlaggableMapObject::asOwnable() const
+{
+	return this;
+}
+
+ResourceSet FlaggableMapObject::dailyIncome() const
+{
+	return getFlaggableHandler()->getDailyIncome();
+}
+
+std::vector<CreatureID> FlaggableMapObject::providedCreatures() const
+{
+	return {};
+}
+
+void FlaggableMapObject::onHeroVisit( const CGHeroInstance * h ) const
+{
+	if (cb->getPlayerRelations(h->getOwner(), getOwner()) != PlayerRelations::ENEMIES)
+		return; // H3 behavior - revisiting owned Lighthouse is a no-op
+
+	if (getOwner().isValidPlayer())
+		takeBonusFrom(getOwner());
+
+	cb->setOwner(this, h->getOwner()); //not ours? flag it!
+
+	InfoWindow iw;
+	iw.player = h->getOwner();
+	iw.text.appendTextID(getFlaggableHandler()->getVisitMessageTextID());
+	cb->showInfoDialog(&iw);
+
+	giveBonusTo(h->getOwner());
+}
+
+void FlaggableMapObject::markAsDeleted() const
+{
+	if(getOwner().isValidPlayer())
+		takeBonusFrom(getOwner());
+}
+
+void FlaggableMapObject::initObj(vstd::RNG & rand)
+{
+	if(getOwner().isValidPlayer())
+	{
+		// FIXME: This is dirty hack
+		giveBonusTo(getOwner(), true);
+	}
+}
+
+std::shared_ptr<FlaggableInstanceConstructor> FlaggableMapObject::getFlaggableHandler() const
+{
+	return std::dynamic_pointer_cast<FlaggableInstanceConstructor>(getObjectHandler());
+}
+
+void FlaggableMapObject::giveBonusTo(const PlayerColor & player, bool onInit) const
+{
+	for (auto const & bonus : getFlaggableHandler()->getProvidedBonuses())
+	{
+		GiveBonus gb(GiveBonus::ETarget::PLAYER);
+		gb.id = player;
+		gb.bonus = *bonus;
+
+		// FIXME: better place for this code?
+		gb.bonus.duration = BonusDuration::PERMANENT;
+		gb.bonus.source = BonusSource::OBJECT_INSTANCE;
+		gb.bonus.sid = BonusSourceID(id);
+
+		// FIXME: This is really dirty hack
+		// Proper fix would be to make FlaggableMapObject into bonus system node
+		// Unfortunately this will cause saves breakage
+		if(onInit)
+			gb.applyGs(cb->gameState());
+		else
+			cb->sendAndApply(gb);
+	}
+}
+
+void FlaggableMapObject::takeBonusFrom(const PlayerColor & player) const
+{
+	RemoveBonus rb(GiveBonus::ETarget::PLAYER);
+	rb.whoID = player;
+	rb.source = BonusSource::OBJECT_INSTANCE;
+	rb.id = BonusSourceID(id);
+	cb->sendAndApply(rb);
+}
+
+void FlaggableMapObject::serializeJsonOptions(JsonSerializeFormat& handler)
+{
+	serializeJsonOwner(handler);
+}
+
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/mapObjects/FlaggableMapObject.h vcmi/lib/mapObjects/FlaggableMapObject.h
--- vcmi-1.5.7/lib/mapObjects/FlaggableMapObject.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/mapObjects/FlaggableMapObject.h	2024-12-19 15:00:22.915148640 +0100
@@ -0,0 +1,42 @@
+/*
+ * FlaggableMapObject.h, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#pragma once
+
+#include "CGObjectInstance.h"
+#include "IOwnableObject.h"
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+struct Bonus;
+class FlaggableInstanceConstructor;
+
+class DLL_LINKAGE FlaggableMapObject : public CGObjectInstance, public IOwnableObject
+{
+	std::shared_ptr<FlaggableInstanceConstructor> getFlaggableHandler() const;
+
+	void giveBonusTo(const PlayerColor & player, bool onInit = false) const;
+	void takeBonusFrom(const PlayerColor & player) const;
+
+public:
+	using CGObjectInstance::CGObjectInstance;
+
+	void onHeroVisit(const CGHeroInstance * h) const override;
+	void markAsDeleted() const;
+	void initObj(vstd::RNG & rand) override;
+
+	const IOwnableObject * asOwnable() const final;
+	ResourceSet dailyIncome() const override;
+	std::vector<CreatureID> providedCreatures() const override;
+
+protected:
+	void serializeJsonOptions(JsonSerializeFormat & handler) override;
+};
+
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/mapObjects/IMarket.cpp vcmi/lib/mapObjects/IMarket.cpp
--- vcmi-1.5.7/lib/mapObjects/IMarket.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapObjects/IMarket.cpp	2024-12-19 15:00:22.915148640 +0100
@@ -20,6 +20,11 @@
 
 VCMI_LIB_NAMESPACE_BEGIN
 
+bool IMarket::allowsTrade(const EMarketMode mode) const
+{
+	return vstd::contains(availableModes(), mode);
+}
+
 bool IMarket::getOffer(int id1, int id2, int &val1, int &val2, EMarketMode mode) const
 {
 	switch(mode)
@@ -122,12 +127,7 @@
 	return true;
 }
 
-bool IMarket::allowsTrade(EMarketMode mode) const
-{
-	return false;
-}
-
-int IMarket::availableUnits(EMarketMode mode, int marketItemSerial) const
+int IMarket::availableUnits(const EMarketMode mode, const int marketItemSerial) const
 {
 	switch(mode)
 	{
@@ -140,7 +140,22 @@
 	}
 }
 
-std::vector<TradeItemBuy> IMarket::availableItemsIds(EMarketMode mode) const
+IMarket::IMarket()
+	:altarArtifactsStorage(std::make_unique<CArtifactSetAltar>())
+{
+}
+
+IMarket::~IMarket() = default;
+
+CArtifactSet * IMarket::getArtifactsStorage() const
+{
+	if (availableModes().count(EMarketMode::ARTIFACT_EXP))
+		return altarArtifactsStorage.get();
+	else
+		return nullptr;
+}
+
+std::vector<TradeItemBuy> IMarket::availableItemsIds(const EMarketMode mode) const
 {
 	std::vector<TradeItemBuy> ret;
 	switch(mode)
@@ -148,24 +163,10 @@
 	case EMarketMode::RESOURCE_RESOURCE:
 	case EMarketMode::ARTIFACT_RESOURCE:
 	case EMarketMode::CREATURE_RESOURCE:
-		for (auto res : GameResID::ALL_RESOURCES())
+		for(const auto & res : GameResID::ALL_RESOURCES())
 			ret.push_back(res);
 	}
 	return ret;
 }
 
-IMarket::IMarket()
-{
-}
-
-std::vector<EMarketMode> IMarket::availableModes() const
-{
-	std::vector<EMarketMode> ret;
-	for (EMarketMode i = static_cast<EMarketMode>(0); i < EMarketMode::MARKET_AFTER_LAST_PLACEHOLDER; i = vstd::next(i, 1))
-	if(allowsTrade(i))
-		ret.push_back(i);
-
-	return ret;
-}
-
 VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/mapObjects/IMarket.h vcmi/lib/mapObjects/IMarket.h
--- vcmi-1.5.7/lib/mapObjects/IMarket.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapObjects/IMarket.h	2024-12-19 15:00:22.915148640 +0100
@@ -11,24 +11,38 @@
 
 #include "../networkPacks/TradeItem.h"
 #include "../constants/Enumerations.h"
+#include "../CArtHandler.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
-class CGObjectInstance;
-
-class DLL_LINKAGE IMarket
+class DLL_LINKAGE IMarket : public virtual Serializeable, boost::noncopyable
 {
 public:
 	IMarket();
-	virtual ~IMarket() {}
+	~IMarket();
 
-	virtual int getMarketEfficiency() const = 0;
-	virtual bool allowsTrade(EMarketMode mode) const;
-	virtual int availableUnits(EMarketMode mode, int marketItemSerial) const; //-1 if unlimited
-	virtual std::vector<TradeItemBuy> availableItemsIds(EMarketMode mode) const;
+	class CArtifactSetAltar : public CArtifactSet
+	{
+	public:
+		ArtBearer::ArtBearer bearerType() const override {return ArtBearer::ALTAR;};
+	};
 
+	virtual ObjectInstanceID getObjInstanceID() const = 0;	// The market is always an object on the map
+	virtual int getMarketEfficiency() const = 0;
+	virtual bool allowsTrade(const EMarketMode mode) const;
+	virtual int availableUnits(const EMarketMode mode, const int marketItemSerial) const; //-1 if unlimited
+	virtual std::vector<TradeItemBuy> availableItemsIds(const EMarketMode mode) const;
+	virtual std::set<EMarketMode> availableModes() const = 0;
+	CArtifactSet * getArtifactsStorage() const;
 	bool getOffer(int id1, int id2, int &val1, int &val2, EMarketMode mode) const; //val1 - how many units of id1 player has to give to receive val2 units
-	std::vector<EMarketMode> availableModes() const;
+
+	template <typename Handler> void serializeArtifactsAltar(Handler &h)
+	{
+		h & *altarArtifactsStorage;
+	}
+
+private:
+	std::unique_ptr<CArtifactSetAltar> altarArtifactsStorage;
 };
 
 VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/mapObjects/IObjectInterface.cpp vcmi/lib/mapObjects/IObjectInterface.cpp
--- vcmi-1.5.7/lib/mapObjects/IObjectInterface.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapObjects/IObjectInterface.cpp	2024-12-19 15:00:22.915148640 +0100
@@ -28,7 +28,7 @@
 	iw.player = getOwner();
 	iw.type = mode;
 	iw.text.appendLocalString(EMetaText::ADVOB_TXT,txtID);
-	cb->sendAndApply(&iw);
+	cb->sendAndApply(iw);
 }
 
 ///IObjectInterface
@@ -38,13 +38,13 @@
 void IObjectInterface::onHeroLeave(const CGHeroInstance * h) const
 {}
 
-void IObjectInterface::newTurn(CRandomGenerator & rand) const
+void IObjectInterface::newTurn(vstd::RNG & rand) const
 {}
 
-void IObjectInterface::initObj(CRandomGenerator & rand)
+void IObjectInterface::initObj(vstd::RNG & rand)
 {}
 
-void IObjectInterface::pickRandomObject(CRandomGenerator & rand)
+void IObjectInterface::pickRandomObject(vstd::RNG & rand)
 {}
 
 void IObjectInterface::setProperty(ObjProperty what, ObjPropertyID identifier)
@@ -68,7 +68,7 @@
 void IObjectInterface::battleFinished(const CGHeroInstance *hero, const BattleResult &result) const
 {}
 
-void IObjectInterface::blockingDialogAnswered(const CGHeroInstance *hero, ui32 answer) const
+void IObjectInterface::blockingDialogAnswered(const CGHeroInstance *hero, int32_t answer) const
 {}
 
 void IObjectInterface::garrisonDialogClosed(const CGHeroInstance *hero) const
@@ -90,10 +90,10 @@
 		if(!tile)
 			continue; // tile not visible / outside the map
 
-		if(!tile->terType->isWater())
+		if(!tile->isWater())
 			continue;
 
-		if (tile->blocked)
+		if (tile->blocked())
 		{
 			bool hasBoat = false;
 			for (auto const * object : tile->blockingObjects)
@@ -145,7 +145,7 @@
 			out.appendLocalString(EMetaText::ADVOB_TXT, 189);
 		break;
 	case NO_WATER:
-		logGlobal->error("Shipyard without water at tile %s! ", getObject()->getPosition().toString());
+		logGlobal->error("Shipyard without water at tile %s! ", getObject()->anchorPos().toString());
 		return;
 	}
 }
diff --color -urN vcmi-1.5.7/lib/mapObjects/IObjectInterface.h vcmi/lib/mapObjects/IObjectInterface.h
--- vcmi-1.5.7/lib/mapObjects/IObjectInterface.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapObjects/IObjectInterface.h	2024-12-19 15:00:22.915148640 +0100
@@ -9,18 +9,23 @@
  */
 #pragma once
 
+#include "../GameCallbackHolder.h"
+#include "../constants/EntityIdentifiers.h"
 #include "../networkPacks/EInfoWindowMode.h"
 #include "../networkPacks/ObjProperty.h"
-#include "../constants/EntityIdentifiers.h"
-#include "../GameCallbackHolder.h"
+#include "../serializer/Serializeable.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
+namespace vstd
+{
+class RNG;
+}
+
 struct BattleResult;
 struct UpgradeInfo;
 class BoatId;
 class CGObjectInstance;
-class CRandomGenerator;
 class CStackInstance;
 class CGHeroInstance;
 class IGameCallback;
@@ -28,8 +33,9 @@
 class int3;
 class MetaString;
 class PlayerColor;
+class IOwnableObject;
 
-class DLL_LINKAGE IObjectInterface : public GameCallbackHolder
+class DLL_LINKAGE IObjectInterface : public GameCallbackHolder, public virtual Serializeable
 {
 public:
 	using GameCallbackHolder::GameCallbackHolder;
@@ -41,25 +47,30 @@
 
 	virtual PlayerColor getOwner() const = 0;
 	virtual int3 visitablePos() const = 0;
-	virtual int3 getPosition() const = 0;
+	virtual int3 anchorPos() const = 0;
 
 	virtual void onHeroVisit(const CGHeroInstance * h) const;
 	virtual void onHeroLeave(const CGHeroInstance * h) const;
-	virtual void newTurn(CRandomGenerator & rand) const;
-	virtual void initObj(CRandomGenerator & rand); //synchr
-	virtual void pickRandomObject(CRandomGenerator & rand);
+
+	/// Called on new turn by server. This method can not modify object state on its own
+	/// Instead all changes must be propagated via netpacks
+	virtual void newTurn(vstd::RNG & rand) const;
+	virtual void initObj(vstd::RNG & rand); //synchr
+	virtual void pickRandomObject(vstd::RNG & rand);
 	virtual void setProperty(ObjProperty what, ObjPropertyID identifier);//synchr
 
 	//Called when queries created DURING HERO VISIT are resolved
 	//First parameter is always hero that visited object and triggered the query
 	virtual void battleFinished(const CGHeroInstance *hero, const BattleResult &result) const;
-	virtual void blockingDialogAnswered(const CGHeroInstance *hero, ui32 answer) const;
+	virtual void blockingDialogAnswered(const CGHeroInstance *hero, int32_t answer) const;
 	virtual void garrisonDialogClosed(const CGHeroInstance *hero) const;
 	virtual void heroLevelUpDone(const CGHeroInstance *hero) const;
 
 	//unified helper to show info dialog for object owner
 	virtual void showInfoDialog(const ui32 txtID, const ui16 soundID = 0, EInfoWindowMode mode = EInfoWindowMode::AUTO) const;
 
+	virtual const IOwnableObject * asOwnable() const = 0;
+
 	//unified interface, AI helpers
 	virtual bool wasVisited (PlayerColor player) const;
 	virtual bool wasVisited (const CGHeroInstance * h) const;
diff --color -urN vcmi-1.5.7/lib/mapObjects/IOwnableObject.h vcmi/lib/mapObjects/IOwnableObject.h
--- vcmi-1.5.7/lib/mapObjects/IOwnableObject.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/mapObjects/IOwnableObject.h	2024-12-19 15:00:22.915148640 +0100
@@ -0,0 +1,31 @@
+/*
+* IOwnableObject.h, part of VCMI engine
+*
+* Authors: listed in file AUTHORS in main folder
+*
+* License: GNU General Public License v2.0 or later
+* Full text of license available in license.txt file, in main folder
+*
+*/
+#pragma once
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+class ResourceSet;
+class CreatureID;
+
+class DLL_LINKAGE IOwnableObject
+{
+public:
+	/// Fixed daily income of this object
+	/// May not include random or periodical (e.g. weekly) income sources
+	virtual ResourceSet dailyIncome() const = 0;
+
+	/// List of creatures that are provided by this building
+	/// For use in town dwellings growth bonus and for portal of summoning
+	virtual std::vector<CreatureID> providedCreatures() const = 0;
+
+	virtual ~IOwnableObject() = default;
+};
+
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/mapObjects/MapObjects.h vcmi/lib/mapObjects/MapObjects.h
--- vcmi-1.5.7/lib/mapObjects/MapObjects.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapObjects/MapObjects.h	2024-12-19 15:00:22.915148640 +0100
@@ -14,7 +14,6 @@
 #include "CObjectHandler.h"
 
 #include "CArmedInstance.h"
-#include "CBank.h"
 #include "CGDwelling.h"
 #include "CGHeroInstance.h"
 #include "CGMarket.h"
diff --color -urN vcmi-1.5.7/lib/mapObjects/MiscObjects.cpp vcmi/lib/mapObjects/MiscObjects.cpp
--- vcmi-1.5.7/lib/mapObjects/MiscObjects.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapObjects/MiscObjects.cpp	2024-12-19 15:00:22.916148681 +0100
@@ -15,7 +15,7 @@
 #include "../bonuses/Propagators.h"
 #include "../constants/StringConstants.h"
 #include "../CConfigHandler.h"
-#include "../CGeneralTextHandler.h"
+#include "../texts/CGeneralTextHandler.h"
 #include "../CSoundBase.h"
 #include "../CSkillHandler.h"
 #include "../spells/CSpellHandler.h"
@@ -23,6 +23,7 @@
 #include "../gameState/CGameState.h"
 #include "../mapping/CMap.h"
 #include "../CPlayerState.h"
+#include "../StartInfo.h"
 #include "../serializer/JsonSerializeFormat.h"
 #include "../mapObjectConstructors/AObjectTypeHandler.h"
 #include "../mapObjectConstructors/CObjectClassesHandler.h"
@@ -32,6 +33,8 @@
 #include "../networkPacks/PacksForClientBattle.h"
 #include "../networkPacks/StackLocation.h"
 
+#include <vstd/RNG.h>
+
 VCMI_LIB_NAMESPACE_BEGIN
 
 ///helpers
@@ -85,26 +88,14 @@
 		BlockingDialog ynd(true,false);
 		ynd.player = h->tempOwner;
 		ynd.text.appendLocalString(EMetaText::ADVOB_TXT, isAbandoned() ? 84 : 187);
-		cb->showBlockingDialog(&ynd);
+		cb->showBlockingDialog(this, &ynd);
 		return;
 	}
 
 	flagMine(h->tempOwner);
-
-}
-
-void CGMine::newTurn(CRandomGenerator & rand) const
-{
-	if(cb->getDate() == 1)
-		return;
-
-	if (tempOwner == PlayerColor::NEUTRAL)
-		return;
-
-	cb->giveResource(tempOwner, producedResource, producedQuantity);
 }
 
-void CGMine::initObj(CRandomGenerator & rand)
+void CGMine::initObj(vstd::RNG & rand)
 {
 	if(isAbandoned())
 	{
@@ -120,7 +111,7 @@
 		}
 		else
 		{
-			logGlobal->error("Abandoned mine at (%s) has no valid resource candidates!", pos.toString());
+			logGlobal->error("Abandoned mine at (%s) has no valid resource candidates!", anchorPos().toString());
 			producedResource = GameResID::GOLD;
 		}
 	}
@@ -136,11 +127,24 @@
 	return subID.getNum() >= 7;
 }
 
+const IOwnableObject * CGMine::asOwnable() const
+{
+	return this;
+}
+
+std::vector<CreatureID> CGMine::providedCreatures() const
+{
+	return {};
+}
+
 ResourceSet CGMine::dailyIncome() const
 {
 	ResourceSet result;
 	result[producedResource] += defaultResProduction();
 
+	const auto & playerSettings = cb->getPlayerSettings(getOwner());
+	result.applyHandicap(playerSettings->handicap.percentIncome);
+
 	return result;
 }
 
@@ -175,7 +179,7 @@
 	iw.type = EInfoWindowMode::AUTO;
 	iw.text.appendTextID(TextIdentifier("core.mineevnt", producedResource.getNum()).get()); //not use subID, abandoned mines uses default mine texts
 	iw.player = player;
-	iw.components.emplace_back(ComponentType::RESOURCE_PER_DAY, producedResource, producedQuantity);
+	iw.components.emplace_back(ComponentType::RESOURCE_PER_DAY, producedResource, getProducedQuantity());
 	cb->showInfoDialog(&iw);
 }
 
@@ -193,9 +197,16 @@
 	}
 }
 
+ui32 CGMine::getProducedQuantity() const
+{
+	auto * playerSettings = cb->getPlayerSettings(getOwner());
+	// always round up income - we don't want mines to always produce zero if handicap in use
+	return vstd::divideAndCeil(producedQuantity * playerSettings->handicap.percentIncome, 100);
+}
+
 void CGMine::battleFinished(const CGHeroInstance *hero, const BattleResult &result) const
 {
-	if(result.winner == 0) //attacker won
+	if(result.winner == BattleSide::ATTACKER) //attacker won
 	{
 		if(isAbandoned())
 		{
@@ -205,10 +216,10 @@
 	}
 }
 
-void CGMine::blockingDialogAnswered(const CGHeroInstance *hero, ui32 answer) const
+void CGMine::blockingDialogAnswered(const CGHeroInstance *hero, int32_t answer) const
 {
 	if(answer)
-		cb->startBattleI(hero, this);
+		cb->startBattle(hero, this);
 }
 
 void CGMine::serializeJsonOptions(JsonSerializeFormat & handler)
@@ -254,7 +265,7 @@
 	return VLC->generaltexth->restypes[resourceID().getNum()];
 }
 
-void CGResource::pickRandomObject(CRandomGenerator & rand)
+void CGResource::pickRandomObject(vstd::RNG & rand)
 {
 	assert(ID == Obj::RESOURCE || ID == Obj::RANDOM_RESOURCE);
 
@@ -269,7 +280,7 @@
 	}
 }
 
-void CGResource::initObj(CRandomGenerator & rand)
+void CGResource::initObj(vstd::RNG & rand)
 {
 	blockVisit = true;
 
@@ -299,7 +310,7 @@
 			BlockingDialog ynd(true,false);
 			ynd.player = h->getOwner();
 			ynd.text = message;
-			cb->showBlockingDialog(&ynd);
+			cb->showBlockingDialog(this, &ynd);
 		}
 		else
 		{
@@ -327,21 +338,21 @@
 		sii.text.replaceName(resourceID());
 	}
 	sii.components.emplace_back(ComponentType::RESOURCE, resourceID(), amount);
-	sii.soundID = soundBase::pickup01 + CRandomGenerator::getDefault().nextInt(6);
+	sii.soundID = soundBase::pickup01 + cb->gameState()->getRandomGenerator().nextInt(6);
 	cb->showInfoDialog(&sii);
 	cb->removeObject(this, player);
 }
 
 void CGResource::battleFinished(const CGHeroInstance *hero, const BattleResult &result) const
 {
-	if(result.winner == 0) //attacker won
+	if(result.winner == BattleSide::ATTACKER) //attacker won
 		collectRes(hero->getOwner());
 }
 
-void CGResource::blockingDialogAnswered(const CGHeroInstance *hero, ui32 answer) const
+void CGResource::blockingDialogAnswered(const CGHeroInstance *hero, int32_t answer) const
 {
 	if(answer)
-		cb->startBattleI(hero, this);
+		cb->startBattle(hero, this);
 }
 
 void CGResource::serializeJsonOptions(JsonSerializeFormat & handler)
@@ -375,7 +386,7 @@
 
 std::vector<ObjectInstanceID> CGTeleport::getAllEntrances(bool excludeCurrent) const
 {
-	auto ret = cb->getTeleportChannelEntraces(channel);
+	auto ret = cb->getTeleportChannelEntrances(channel);
 	if(excludeCurrent)
 		vstd::erase_if_present(ret, id);
 
@@ -395,7 +406,7 @@
 {
 	auto passableExits = getPassableExits(cb->gameState(), h, getAllExits(true));
 	if(!passableExits.empty())
-		return *RandomGeneratorUtil::nextItem(passableExits, CRandomGenerator::getDefault());
+		return *RandomGeneratorUtil::nextItem(passableExits, cb->gameState()->getRandomGenerator());
 
 	return ObjectInstanceID();
 }
@@ -499,11 +510,11 @@
 
 		if(cb->isTeleportChannelImpassable(channel))
 		{
-			logGlobal->debug("Cannot find corresponding exit monolith for %d at %s", id.getNum(), pos.toString());
+			logGlobal->debug("Cannot find corresponding exit monolith for %d at %s", id.getNum(), anchorPos().toString());
 			td.impassable = true;
 		}
 		else if(getRandomExit(h) == ObjectInstanceID())
-			logGlobal->debug("All exits blocked for monolith %d at %s", id.getNum(), pos.toString());
+			logGlobal->debug("All exits blocked for monolith %d at %s", id.getNum(), anchorPos().toString());
 	}
 	else
 		h->showInfoDialog(70);
@@ -530,7 +541,7 @@
 	cb->moveHero(hero->id, hero->convertFromVisitablePos(dPos), EMovementMode::MONOLITH);
 }
 
-void CGMonolith::initObj(CRandomGenerator & rand)
+void CGMonolith::initObj(vstd::RNG & rand)
 {
 	std::vector<Obj> IDs;
 	IDs.push_back(ID);
@@ -563,7 +574,7 @@
 	if(cb->isTeleportChannelImpassable(channel))
 	{
 		h->showInfoDialog(153);//Just inside the entrance you find a large pile of rubble blocking the tunnel. You leave discouraged.
-		logGlobal->debug("Cannot find exit subterranean gate for  %d at %s", id.getNum(), pos.toString());
+		logGlobal->debug("Cannot find exit subterranean gate for  %d at %s", id.getNum(), anchorPos().toString());
 		td.impassable = true;
 	}
 	else
@@ -575,7 +586,7 @@
 	cb->showTeleportDialog(&td);
 }
 
-void CGSubterraneanGate::initObj(CRandomGenerator & rand)
+void CGSubterraneanGate::initObj(vstd::RNG & rand)
 {
 	type = BOTH;
 }
@@ -591,13 +602,13 @@
 
 		auto * hlp = dynamic_cast<CGSubterraneanGate *>(cb->gameState()->getObjInstance(obj->id));
 		if(hlp)
-			gatesSplit[hlp->pos.z].push_back(hlp);
+			gatesSplit[hlp->visitablePos().z].push_back(hlp);
 	}
 
 	//sort by position
 	std::sort(gatesSplit[0].begin(), gatesSplit[0].end(), [](const CGObjectInstance * a, const CGObjectInstance * b)
 	{
-		return a->pos < b->pos;
+		return a->visitablePos() < b->visitablePos();
 	});
 
 	auto assignToChannel = [&](CGSubterraneanGate * obj)
@@ -620,7 +631,7 @@
 			CGSubterraneanGate *checked = gatesSplit[1][j];
 			if(checked->channel != TeleportChannelID())
 				continue;
-			si32 hlp = checked->pos.dist2dSQ(objCurrent->pos);
+			si32 hlp = checked->visitablePos().dist2dSQ(objCurrent->visitablePos());
 			if(hlp < best.second)
 			{
 				best.first = j;
@@ -646,11 +657,11 @@
 	TeleportDialog td(h->id, channel);
 	if(cb->isTeleportChannelImpassable(channel))
 	{
-		logGlobal->debug("Cannot find exit whirlpool for %d at %s", id.getNum(), pos.toString());
+		logGlobal->debug("Cannot find exit whirlpool for %d at %s", id.getNum(), anchorPos().toString());
 		td.impassable = true;
 	}
 	else if(getRandomExit(h) == ObjectInstanceID())
-		logGlobal->debug("All exits are blocked for whirlpool  %d at %s", id.getNum(), pos.toString());
+		logGlobal->debug("All exits are blocked for whirlpool  %d at %s", id.getNum(), anchorPos().toString());
 
 	if(!isProtected(h))
 	{
@@ -703,7 +714,7 @@
 
 		const auto * obj = cb->getObj(exit);
 		std::set<int3> tiles = obj->getBlockedPos();
-		dPos = *RandomGeneratorUtil::nextItem(tiles, CRandomGenerator::getDefault());
+		dPos = *RandomGeneratorUtil::nextItem(tiles, cb->gameState()->getRandomGenerator());
 	}
 
 	cb->moveHero(hero->id, hero->convertFromVisitablePos(dPos), EMovementMode::MONOLITH);
@@ -724,7 +735,7 @@
 		return getObjTypeIndex().getNum();
 }
 
-void CGArtifact::pickRandomObject(CRandomGenerator & rand)
+void CGArtifact::pickRandomObject(vstd::RNG & rand)
 {
 	switch(ID.toEnum())
 	{
@@ -754,24 +765,23 @@
 		ID = MapObjectID::ARTIFACT;
 }
 
-void CGArtifact::initObj(CRandomGenerator & rand)
+void CGArtifact::initObj(vstd::RNG & rand)
 {
 	blockVisit = true;
 	if(ID == Obj::ARTIFACT)
 	{
 		if (!storedArtifact)
 		{
-			auto * a = new CArtifactInstance();
-			cb->gameState()->map->addNewArtifactInstance(a);
-			storedArtifact = a;
+			storedArtifact = ArtifactUtils::createArtifact(ArtifactID());
+			cb->gameState()->map->addNewArtifactInstance(storedArtifact);
 		}
-		if(!storedArtifact->artType)
+		if(!storedArtifact->getType())
 			storedArtifact->setType(getArtifact().toArtifact());
 	}
 	if(ID == Obj::SPELL_SCROLL)
 		subID = 1;
 
-	assert(storedArtifact->artType);
+	assert(storedArtifact->getType());
 	assert(!storedArtifact->getParentNodes().empty());
 
 	//assert(storedArtifact->artType->id == subID); //this does not stop desync
@@ -815,7 +825,7 @@
 		iw.type = EInfoWindowMode::AUTO;
 		iw.player = h->tempOwner;
 
-		if(storedArtifact->artType->canBePutAt(h))
+		if(storedArtifact->getType()->canBePutAt(h))
 		{
 			switch (ID.toEnum())
 			{
@@ -868,7 +878,7 @@
 					ynd.text.replaceRawString(getArmyDescription());
 					ynd.text.replaceLocalString(EMetaText::GENERAL_TXT, 43); // creatures
 				}
-				cb->showBlockingDialog(&ynd);
+				cb->showBlockingDialog(this, &ynd);
 			}
 			break;
 		case Obj::SPELL_SCROLL:
@@ -878,7 +888,7 @@
 					BlockingDialog ynd(true,false);
 					ynd.player = h->getOwner();
 					ynd.text = message;
-					cb->showBlockingDialog(&ynd);
+					cb->showBlockingDialog(this, &ynd);
 				}
 				else
 					blockingDialogAnswered(h, true);
@@ -890,7 +900,7 @@
 
 void CGArtifact::pick(const CGHeroInstance * h) const
 {
-	if(cb->putArtifact(ArtifactLocation(h->id, ArtifactPosition::FIRST_AVAILABLE), storedArtifact))
+	if(cb->putArtifact(ArtifactLocation(h->id, ArtifactPosition::FIRST_AVAILABLE), storedArtifact->getId()))
 		cb->removeObject(this, h->getOwner());
 }
 
@@ -901,14 +911,14 @@
 
 void CGArtifact::battleFinished(const CGHeroInstance *hero, const BattleResult &result) const
 {
-	if(result.winner == 0) //attacker won
+	if(result.winner == BattleSide::ATTACKER) //attacker won
 		pick(hero);
 }
 
-void CGArtifact::blockingDialogAnswered(const CGHeroInstance *hero, ui32 answer) const
+void CGArtifact::blockingDialogAnswered(const CGHeroInstance *hero, int32_t answer) const
 {
 	if(answer)
-		cb->startBattleI(hero, this);
+		cb->startBattle(hero, this);
 }
 
 void CGArtifact::afterAddToMap(CMap * map)
@@ -936,7 +946,7 @@
 	}
 }
 
-void CGSignBottle::initObj(CRandomGenerator & rand)
+void CGSignBottle::initObj(vstd::RNG & rand)
 {
 	//if no text is set than we pick random from the predefined ones
 	if(message.empty())
@@ -968,12 +978,27 @@
 	handler.serializeStruct("text", message);
 }
 
+const IOwnableObject * CGGarrison::asOwnable() const
+{
+	return this;
+}
+
+ResourceSet CGGarrison::dailyIncome() const
+{
+	return {};
+}
+
+std::vector<CreatureID> CGGarrison::providedCreatures() const
+{
+	return {};
+}
+
 void CGGarrison::onHeroVisit (const CGHeroInstance *h) const
 {
 	auto relations = cb->gameState()->getPlayerRelations(h->tempOwner, tempOwner);
 	if (relations == PlayerRelations::ENEMIES && stacksCount() > 0) {
 		//TODO: Find a way to apply magic garrison effects in battle.
-		cb->startBattleI(h, this);
+		cb->startBattle(h, this);
 		return;
 	}
 
@@ -1000,7 +1025,7 @@
 
 void CGGarrison::battleFinished(const CGHeroInstance *hero, const BattleResult &result) const
 {
-	if (result.winner == 0)
+	if (result.winner == BattleSide::ATTACKER)
 		onHeroVisit(hero);
 }
 
@@ -1011,7 +1036,7 @@
 	CArmedInstance::serializeJsonOptions(handler);
 }
 
-void CGGarrison::initObj(CRandomGenerator &rand)
+void CGGarrison::initObj(vstd::RNG &rand)
 {
 	if(this->subID == MapObjectSubID::decode(this->ID, "antiMagic"))
 		addAntimagicGarrisonBonus();
@@ -1028,7 +1053,7 @@
 	this->addNewBonus(bonus);
 }
 
-void CGMagi::initObj(CRandomGenerator & rand)
+void CGMagi::initObj(vstd::RNG & rand)
 {
 	if (ID == Obj::EYE_OF_MAGI)
 		blockVisit = true;
@@ -1061,15 +1086,15 @@
 
 			for(const auto & eye : eyes)
 			{
-				cb->getTilesInRange (fw.tiles, eye->pos, 10, ETileVisibility::HIDDEN, h->tempOwner);
-				cb->sendAndApply(&fw);
-				cv.pos = eye->pos;
+				cb->getTilesInRange (fw.tiles, eye->visitablePos(), 10, ETileVisibility::HIDDEN, h->tempOwner);
+				cb->sendAndApply(fw);
+				cv.pos = eye->visitablePos();
 
-				cb->sendAndApply(&cv);
+				cb->sendAndApply(cv);
 			}
 			cv.pos = h->visitablePos();
 			cv.focusTime = 0;
-			cb->sendAndApply(&cv);
+			cb->sendAndApply(cv);
 		}
 	}
 	else if (ID == Obj::EYE_OF_MAGI)
@@ -1091,7 +1116,7 @@
 	return true;
 }
 
-void CGSirens::initObj(CRandomGenerator & rand)
+void CGSirens::initObj(vstd::RNG & rand)
 {
 	blockVisit = true;
 }
@@ -1127,7 +1152,7 @@
 			if(drown)
 			{
 				cb->changeStackCount(StackLocation(h, i->first), -drown);
-				xp += drown * i->second->type->getMaxHealth();
+				xp += drown * i->second->getType()->getMaxHealth();
 			}
 		}
 
@@ -1201,6 +1226,21 @@
 	return createdBoat;
 }
 
+const IOwnableObject * CGShipyard::asOwnable() const
+{
+	return this;
+}
+
+ResourceSet CGShipyard::dailyIncome() const
+{
+	return {};
+}
+
+std::vector<CreatureID> CGShipyard::providedCreatures() const
+{
+	return {};
+}
+
 void CGDenOfthieves::onHeroVisit (const CGHeroInstance * h) const
 {
 	cb->showObjectWindow(this, EOpenWindowMode::THIEVES_GUILD, h, false);
@@ -1218,7 +1258,7 @@
 	if(!wasVisited(team))
 	{
 		iw.text.appendLocalString(EMetaText::ADVOB_TXT, 96);
-		cb->sendAndApply(&iw);
+		cb->sendAndApply(iw);
 
 		// increment general visited obelisks counter
 		cb->setObjPropertyID(id, ObjProperty::OBELISK_VISITED, team);
@@ -1233,12 +1273,12 @@
 	else
 	{
 		iw.text.appendLocalString(EMetaText::ADVOB_TXT, 97);
-		cb->sendAndApply(&iw);
+		cb->sendAndApply(iw);
 	}
 
 }
 
-void CGObelisk::initObj(CRandomGenerator & rand)
+void CGObelisk::initObj(vstd::RNG & rand)
 {
 	cb->gameState()->map->obeliskCount++;
 }
@@ -1271,80 +1311,53 @@
 	}
 }
 
-void CGLighthouse::onHeroVisit( const CGHeroInstance * h ) const
+void HillFort::onHeroVisit(const CGHeroInstance * h) const
 {
-	if(h->tempOwner != tempOwner)
-	{
-		PlayerColor oldOwner = tempOwner;
-		cb->setOwner(this,h->tempOwner); //not ours? flag it!
-		h->showInfoDialog(69);
-		giveBonusTo(h->tempOwner);
-
-		if(oldOwner.isValidPlayer()) //remove bonus from old owner
-		{
-			RemoveBonus rb(GiveBonus::ETarget::PLAYER);
-			rb.whoID = oldOwner;
-			rb.source = BonusSource::OBJECT_INSTANCE;
-			rb.id = BonusSourceID(id);
-			cb->sendAndApply(&rb);
-		}
-	}
+	cb->showObjectWindow(this, EOpenWindowMode::HILL_FORT_WINDOW, h, false);
 }
 
-void CGLighthouse::initObj(CRandomGenerator & rand)
+void HillFort::fillUpgradeInfo(UpgradeInfo & info, const CStackInstance &stack) const
 {
-	if(tempOwner.isValidPlayer())
+	int32_t level = stack.getType()->getLevel();
+	int32_t index = std::clamp<int32_t>(level - 1, 0, upgradeCostPercentage.size() - 1);
+
+	int costModifier = upgradeCostPercentage[index];
+
+	if (costModifier < 0)
+		return; // upgrade not allowed
+
+	for(const auto & nid : stack.getCreature()->upgrades)
 	{
-		// FIXME: This is dirty hack
-		giveBonusTo(tempOwner, true);
+		info.newID.push_back(nid);
+		info.cost.push_back((nid.toCreature()->getFullRecruitCost() - stack.getType()->getFullRecruitCost()) * costModifier / 100);
 	}
 }
 
-void CGLighthouse::giveBonusTo(const PlayerColor & player, bool onInit) const
+std::string HillFort::getPopupText(PlayerColor player) const
 {
-	GiveBonus gb(GiveBonus::ETarget::PLAYER);
-	gb.bonus.type = BonusType::MOVEMENT;
-	gb.bonus.val = 500;
-	gb.id = player;
-	gb.bonus.duration = BonusDuration::PERMANENT;
-	gb.bonus.source = BonusSource::OBJECT_INSTANCE;
-	gb.bonus.sid = BonusSourceID(id);
-	gb.bonus.subtype = BonusCustomSubtype::heroMovementSea;
+	MetaString message = MetaString::createFromRawString("{%s}\r\n\r\n%s");
 
-	// FIXME: This is really dirty hack
-	// Proper fix would be to make CGLighthouse into bonus system node
-	// Unfortunately this will cause saves breakage
-	if(onInit)
-		gb.applyGs(cb->gameState());
-	else
-		cb->sendAndApply(&gb);
+	message.replaceName(ID, subID);
+	message.replaceTextID(getDescriptionToolTip());
+
+	return message.toString();
 }
 
-void CGLighthouse::serializeJsonOptions(JsonSerializeFormat& handler)
+std::string HillFort::getPopupText(const CGHeroInstance * hero) const
 {
-	serializeJsonOwner(handler);
+	return getPopupText(hero->getOwner());
 }
 
-void HillFort::onHeroVisit(const CGHeroInstance * h) const
+
+std::string HillFort::getDescriptionToolTip() const
 {
-	cb->showObjectWindow(this, EOpenWindowMode::HILL_FORT_WINDOW, h, false);
+	return TextIdentifier(getObjectHandler()->getBaseTextID(), "description").get();
 }
 
-void HillFort::fillUpgradeInfo(UpgradeInfo & info, const CStackInstance &stack) const
+std::string HillFort::getUnavailableUpgradeMessage() const
 {
-	int32_t level = stack.type->getLevel();
-	int32_t index = std::clamp<int32_t>(level - 1, 0, upgradeCostPercentage.size() - 1);
-
-	int costModifier = upgradeCostPercentage[index];
-
-	if (costModifier < 0)
-		return; // upgrade not allowed
-
-	for(const auto & nid : stack.type->upgrades)
-	{
-		info.newID.push_back(nid);
-		info.cost.push_back((nid.toCreature()->getFullRecruitCost() - stack.type->getFullRecruitCost()) * costModifier / 100);
-	}
+	assert(getObjectHandler()->getModScope() != "core");
+	return TextIdentifier(getObjectHandler()->getBaseTextID(), "unavailableUpgradeMessage").get();
 }
 
 VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/mapObjects/MiscObjects.h vcmi/lib/mapObjects/MiscObjects.h
--- vcmi-1.5.7/lib/mapObjects/MiscObjects.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapObjects/MiscObjects.h	2024-12-19 15:00:22.916148681 +0100
@@ -10,7 +10,8 @@
 #pragma once
 
 #include "CArmedInstance.h"
-#include "../MetaString.h"
+#include "IOwnableObject.h"
+#include "../texts/MetaString.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
@@ -48,7 +49,7 @@
 	MetaString message;
 
 	void onHeroVisit(const CGHeroInstance * h) const override;
-	void initObj(CRandomGenerator & rand) override;
+	void initObj(vstd::RNG & rand) override;
 
 	template <typename Handler> void serialize(Handler &h)
 	{
@@ -59,18 +60,22 @@
 	void serializeJsonOptions(JsonSerializeFormat & handler) override;
 };
 
-class DLL_LINKAGE CGGarrison : public CArmedInstance
+class DLL_LINKAGE CGGarrison : public CArmedInstance, public IOwnableObject
 {
 public:
 	using CArmedInstance::CArmedInstance;
 
 	bool removableUnits;
 
-	void initObj(CRandomGenerator &rand) override;
+	void initObj(vstd::RNG &rand) override;
 	bool passableFor(PlayerColor color) const override;
 	void onHeroVisit(const CGHeroInstance * h) const override;
 	void battleFinished(const CGHeroInstance *hero, const BattleResult &result) const override;
 
+	const IOwnableObject * asOwnable() const final;
+	ResourceSet dailyIncome() const override;
+	std::vector<CreatureID> providedCreatures() const override;
+
 	template <typename Handler> void serialize(Handler &h)
 	{
 		h & static_cast<CArmedInstance&>(*this);
@@ -79,6 +84,7 @@
 protected:
 	void serializeJsonOptions(JsonSerializeFormat & handler) override;
 	void addAntimagicGarrisonBonus();
+
 };
 
 class DLL_LINKAGE CGArtifact : public CArmedInstance
@@ -91,7 +97,7 @@
 
 	void onHeroVisit(const CGHeroInstance * h) const override;
 	void battleFinished(const CGHeroInstance *hero, const BattleResult &result) const override;
-	void blockingDialogAnswered(const CGHeroInstance *hero, ui32 answer) const override;
+	void blockingDialogAnswered(const CGHeroInstance *hero, int32_t answer) const override;
 
 	std::string getObjectName() const override;
 	std::string getPopupText(PlayerColor player) const override;
@@ -99,8 +105,8 @@
 	std::vector<Component> getPopupComponents(PlayerColor player) const override;
 
 	void pick( const CGHeroInstance * h ) const;
-	void initObj(CRandomGenerator & rand) override;
-	void pickRandomObject(CRandomGenerator & rand) override;
+	void initObj(vstd::RNG & rand) override;
+	void pickRandomObject(vstd::RNG & rand) override;
 
 	void afterAddToMap(CMap * map) override;
 	BattleField getBattlefield() const override;
@@ -129,10 +135,10 @@
 	MetaString message;
 
 	void onHeroVisit(const CGHeroInstance * h) const override;
-	void initObj(CRandomGenerator & rand) override;
-	void pickRandomObject(CRandomGenerator & rand) override;
+	void initObj(vstd::RNG & rand) override;
+	void pickRandomObject(vstd::RNG & rand) override;
 	void battleFinished(const CGHeroInstance *hero, const BattleResult &result) const override;
-	void blockingDialogAnswered(const CGHeroInstance *hero, ui32 answer) const override;
+	void blockingDialogAnswered(const CGHeroInstance *hero, int32_t answer) const override;
 	std::string getHoverText(PlayerColor player) const override;
 
 	void collectRes(const PlayerColor & player) const;
@@ -148,26 +154,22 @@
 	void serializeJsonOptions(JsonSerializeFormat & handler) override;
 };
 
-class DLL_LINKAGE CGMine : public CArmedInstance
+class DLL_LINKAGE CGMine : public CArmedInstance, public IOwnableObject
 {
 public:
 	GameResID producedResource;
 	ui32 producedQuantity;
 	std::set<GameResID> abandonedMineResources;
-	
 	bool isAbandoned() const;
-	ResourceSet dailyIncome() const;
-
 private:
 	using CArmedInstance::CArmedInstance;
 
 	void onHeroVisit(const CGHeroInstance * h) const override;
 	void battleFinished(const CGHeroInstance *hero, const BattleResult &result) const override;
-	void blockingDialogAnswered(const CGHeroInstance *hero, ui32 answer) const override;
+	void blockingDialogAnswered(const CGHeroInstance *hero, int32_t answer) const override;
 
 	void flagMine(const PlayerColor & player) const;
-	void newTurn(CRandomGenerator & rand) const override;
-	void initObj(CRandomGenerator & rand) override;
+	void initObj(vstd::RNG & rand) override;
 
 	std::string getObjectName() const override;
 	std::string getHoverText(PlayerColor player) const override;
@@ -181,12 +183,17 @@
 		h & abandonedMineResources;
 	}
 	ui32 defaultResProduction() const;
+	ui32 getProducedQuantity() const;
+
+	const IOwnableObject * asOwnable() const final;
+	ResourceSet dailyIncome() const override;
+	std::vector<CreatureID> providedCreatures() const override;
 
 protected:
 	void serializeJsonOptions(JsonSerializeFormat & handler) override;
 };
 
-struct DLL_LINKAGE TeleportChannel
+struct DLL_LINKAGE TeleportChannel : public Serializeable
 {
 	enum EPassability {UNKNOWN, IMPASSABLE, PASSABLE};
 
@@ -248,7 +255,7 @@
 protected:
 	void onHeroVisit(const CGHeroInstance * h) const override;
 	void teleportDialogAnswered(const CGHeroInstance *hero, ui32 answer, TTeleportExitsList exits) const override;
-	void initObj(CRandomGenerator & rand) override;
+	void initObj(vstd::RNG & rand) override;
 
 public:
 	using CGTeleport::CGTeleport;
@@ -262,7 +269,7 @@
 class DLL_LINKAGE CGSubterraneanGate : public CGMonolith
 {
 	void onHeroVisit(const CGHeroInstance * h) const override;
-	void initObj(CRandomGenerator & rand) override;
+	void initObj(vstd::RNG & rand) override;
 
 public:
 	using CGMonolith::CGMonolith;
@@ -297,7 +304,7 @@
 
 	void onHeroVisit(const CGHeroInstance * h) const override;
 	std::string getHoverText(const CGHeroInstance * hero) const override;
-	void initObj(CRandomGenerator & rand) override;
+	void initObj(vstd::RNG & rand) override;
 
 	template <typename Handler> void serialize(Handler &h)
 	{
@@ -339,7 +346,7 @@
 	}
 };
 
-class DLL_LINKAGE CGShipyard : public CGObjectInstance, public IShipyard
+class DLL_LINKAGE CGShipyard : public CGObjectInstance, public IShipyard, public IOwnableObject
 {
 	friend class ShipyardInstanceConstructor;
 
@@ -351,6 +358,10 @@
 	const IObjectInterface * getObject() const override;
 	BoatId getBoatType() const override;
 
+	const IOwnableObject * asOwnable() const final;
+	ResourceSet dailyIncome() const override;
+	std::vector<CreatureID> providedCreatures() const override;
+
 public:
 	using CGObjectInstance::CGObjectInstance;
 
@@ -369,7 +380,7 @@
 public:
 	using CGObjectInstance::CGObjectInstance;
 
-	void initObj(CRandomGenerator & rand) override;
+	void initObj(vstd::RNG & rand) override;
 	void onHeroVisit(const CGHeroInstance * h) const override;
 
 	template <typename Handler> void serialize(Handler &h)
@@ -391,7 +402,7 @@
 	using CTeamVisited::CTeamVisited;
 
 	void onHeroVisit(const CGHeroInstance * h) const override;
-	void initObj(CRandomGenerator & rand) override;
+	void initObj(vstd::RNG & rand) override;
 	std::string getHoverText(PlayerColor player) const override;
 
 	template <typename Handler> void serialize(Handler &h)
@@ -402,24 +413,6 @@
 	void setPropertyDer(ObjProperty what, ObjPropertyID identifier) override;
 };
 
-class DLL_LINKAGE CGLighthouse : public CGObjectInstance
-{
-public:
-	using CGObjectInstance::CGObjectInstance;
-
-	void onHeroVisit(const CGHeroInstance * h) const override;
-	void initObj(CRandomGenerator & rand) override;
-
-	template <typename Handler> void serialize(Handler &h)
-	{
-		h & static_cast<CGObjectInstance&>(*this);
-	}
-	void giveBonusTo(const PlayerColor & player, bool onInit = false) const;
-
-protected:
-	void serializeJsonOptions(JsonSerializeFormat & handler) override;
-};
-
 class DLL_LINKAGE CGTerrainPatch : public CGObjectInstance
 {
 public:
@@ -444,6 +437,12 @@
 public:
 	using CGObjectInstance::CGObjectInstance;
 
+	std::string getPopupText(PlayerColor player) const override;
+	std::string getPopupText(const CGHeroInstance * hero) const override;
+
+	std::string getDescriptionToolTip() const;
+	std::string getUnavailableUpgradeMessage() const;
+
 	template <typename Handler> void serialize(Handler &h)
 	{
 		h & static_cast<CGObjectInstance&>(*this);
diff --color -urN vcmi-1.5.7/lib/mapObjects/ObjectTemplate.cpp vcmi/lib/mapObjects/ObjectTemplate.cpp
--- vcmi-1.5.7/lib/mapObjects/ObjectTemplate.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapObjects/ObjectTemplate.cpp	2024-12-19 15:00:22.916148681 +0100
@@ -15,7 +15,7 @@
 #include "../VCMI_Lib.h"
 #include "../GameConstants.h"
 #include "../constants/StringConstants.h"
-#include "../CGeneralTextHandler.h"
+#include "../texts/CLegacyConfigParser.h"
 #include "../TerrainHandler.h"
 
 #include "../mapObjectConstructors/CRewardableConstructor.h"
@@ -59,54 +59,6 @@
 {
 }
 
-ObjectTemplate::ObjectTemplate(const ObjectTemplate& other):
-	visitDir(other.visitDir),
-	allowedTerrains(other.allowedTerrains),
-	id(other.id),
-	subid(other.subid),
-	printPriority(other.printPriority),
-	animationFile(other.animationFile),
-	editorAnimationFile(other.editorAnimationFile),
-	stringID(other.stringID),
-	width(other.width),
-	height(other.height),
-	visitable(other.visitable),
-	blockedOffsets(other.blockedOffsets),
-	blockMapOffset(other.blockMapOffset),
-	visitableOffset(other.visitableOffset)
-{
-	//default copy constructor is failing with usedTiles this for unknown reason
-
-	usedTiles.resize(other.usedTiles.size());
-	for(size_t i = 0; i < usedTiles.size(); i++)
-		std::copy(other.usedTiles[i].begin(), other.usedTiles[i].end(), std::back_inserter(usedTiles[i]));
-}
-
-ObjectTemplate & ObjectTemplate::operator=(const ObjectTemplate & rhs)
-{
-	visitDir = rhs.visitDir;
-	allowedTerrains = rhs.allowedTerrains;
-	id = rhs.id;
-	subid = rhs.subid;
-	printPriority = rhs.printPriority;
-	animationFile = rhs.animationFile;
-	editorAnimationFile = rhs.editorAnimationFile;
-	stringID = rhs.stringID;
-	width = rhs.width;
-	height = rhs.height;
-	visitable = rhs.visitable;
-	blockedOffsets = rhs.blockedOffsets;
-	blockMapOffset = rhs.blockMapOffset;
-	visitableOffset = rhs.visitableOffset;
-
-	usedTiles.clear();
-	usedTiles.resize(rhs.usedTiles.size());
-	for(size_t i = 0; i < usedTiles.size(); i++)
-		std::copy(rhs.usedTiles[i].begin(), rhs.usedTiles[i].end(), std::back_inserter(usedTiles[i]));
-
-	return *this;
-}
-
 void ObjectTemplate::afterLoadFixup()
 {
 	if(id == Obj::EVENT)
@@ -556,6 +508,11 @@
 	return vstd::contains(allowedTerrains, terrainID);
 }
 
+CompoundMapObjectID ObjectTemplate::getCompoundID() const
+{
+	return CompoundMapObjectID(id, subid);
+}
+
 void ObjectTemplate::recalculate()
 {
 	calculateWidth();
diff --color -urN vcmi-1.5.7/lib/mapObjects/ObjectTemplate.h vcmi/lib/mapObjects/ObjectTemplate.h
--- vcmi-1.5.7/lib/mapObjects/ObjectTemplate.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapObjects/ObjectTemplate.h	2024-12-19 15:00:22.916148681 +0100
@@ -12,6 +12,8 @@
 #include "../GameConstants.h"
 #include "../int3.h"
 #include "../filesystem/ResourcePath.h"
+#include "../serializer/Serializeable.h"
+#include "../mapObjects/CompoundMapObjectID.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
@@ -20,7 +22,7 @@
 class JsonNode;
 class int3;
 
-class DLL_LINKAGE ObjectTemplate
+class DLL_LINKAGE ObjectTemplate : public Serializeable
 {
 	enum EBlockMapBits
 	{
@@ -45,6 +47,7 @@
 	/// H3 ID/subID of this object
 	MapObjectID id;
 	MapObjectSubID subid;
+
 	/// print priority, objects with higher priority will be print first, below everything else
 	si32 printPriority;
 	/// animation file that should be used to display object
@@ -121,11 +124,9 @@
 	// Checks if object can be placed on specific terrain
 	bool canBePlacedAt(TerrainId terrain) const;
 
-	ObjectTemplate();
-	//custom copy constructor is required
-	ObjectTemplate(const ObjectTemplate & other);
+	CompoundMapObjectID getCompoundID() const;
 
-	ObjectTemplate& operator=(const ObjectTemplate & rhs);
+	ObjectTemplate();
 
 	void readTxt(CLegacyConfigParser & parser);
 	void readMsk();
diff --color -urN vcmi-1.5.7/lib/mapObjects/ObstacleSetHandler.cpp vcmi/lib/mapObjects/ObstacleSetHandler.cpp
--- vcmi-1.5.7/lib/mapObjects/ObstacleSetHandler.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapObjects/ObstacleSetHandler.cpp	2024-12-19 15:00:22.916148681 +0100
@@ -14,20 +14,21 @@
 #include "../modding/IdentifierStorage.h"
 #include "../constants/StringConstants.h"
 #include "../TerrainHandler.h"
+#include "../VCMI_Lib.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
 ObstacleSet::ObstacleSet():
 	type(INVALID),
-	allowedTerrains({TerrainId::NONE}),
-	level(EMapLevel::ANY)
+	level(EMapLevel::ANY),
+	allowedTerrains({TerrainId::NONE})
 {
 }
 
 ObstacleSet::ObstacleSet(EObstacleType type, TerrainId terrain):
 	type(type),
-	allowedTerrains({terrain}),
-	level(EMapLevel::ANY)
+	level(EMapLevel::ANY),
+	allowedTerrains({terrain})
 {
 }
 
@@ -42,7 +43,7 @@
 	{
 		if (tmpl->getBlockedOffsets().empty())
 		{
-			logMod->warn("Obstacle template %s blocks no tiles, removing it", tmpl->stringID);
+			logMod->debug("Obstacle template %s blocks no tiles, removing it", tmpl->stringID);
 			return true;
 		}
 		return false;
@@ -51,27 +52,27 @@
 
 ObstacleSetFilter::ObstacleSetFilter(std::vector<ObstacleSet::EObstacleType> allowedTypes,
 	TerrainId terrain = TerrainId::ANY_TERRAIN,
-	ObstacleSet::EMapLevel level = ObstacleSet::EMapLevel::ANY,
+	EMapLevel level = EMapLevel::ANY,
 	FactionID faction = FactionID::ANY,
 	EAlignment alignment = EAlignment::ANY):
 	allowedTypes(allowedTypes),
-	terrain(terrain),
-	level(level),
 	faction(faction),
-	alignment(alignment)
+	alignment(alignment),
+	terrain(terrain),
+	level(level)
 {
 }
 
 ObstacleSetFilter::ObstacleSetFilter(ObstacleSet::EObstacleType allowedType,
 	TerrainId terrain = TerrainId::ANY_TERRAIN,
-	ObstacleSet::EMapLevel level = ObstacleSet::EMapLevel::ANY,
+	EMapLevel level = EMapLevel::ANY,
 	FactionID faction = FactionID::ANY,
 	EAlignment alignment = EAlignment::ANY):
 	allowedTypes({allowedType}),
-	terrain(terrain),
-	level(level),
 	faction(faction),
-	alignment(alignment)
+	alignment(alignment),
+	terrain(terrain),
+	level(level)
 {
 }
 
@@ -82,7 +83,7 @@
 		return false;
 	}
 
-	if (level != ObstacleSet::EMapLevel::ANY && set.getLevel() != ObstacleSet::EMapLevel::ANY)
+	if (level != EMapLevel::ANY && set.getLevel() != EMapLevel::ANY)
 	{
 		if (level != set.getLevel())
 		{
@@ -137,12 +138,12 @@
 	this->allowedTerrains.insert(terrain);
 }
 
-ObstacleSet::EMapLevel ObstacleSet::getLevel() const
+EMapLevel ObstacleSet::getLevel() const
 {
 	return level;
 }
 
-void ObstacleSet::setLevel(ObstacleSet::EMapLevel newLevel)
+void ObstacleSet::setLevel(EMapLevel newLevel)
 {
 	level = newLevel;
 }
@@ -172,9 +173,9 @@
 	return type;
 }
 
-void ObstacleSet::setType(EObstacleType type)
+void ObstacleSet::setType(EObstacleType newType)
 {
-	this->type = type;
+	type = newType;
 }
 
 std::vector<std::shared_ptr<const ObjectTemplate>> ObstacleSet::getObstacles() const
@@ -278,12 +279,12 @@
 	return OBSTACLE_TYPE_STRINGS.at(type);
 }
 
-ObstacleSet::EMapLevel ObstacleSet::levelFromString(const std::string &str)
+EMapLevel ObstacleSet::levelFromString(const std::string &str)
 {
 	static const std::map<std::string, EMapLevel> LEVEL_NAMES =
 	{
-		{"surface", SURFACE},
-		{"underground", UNDERGROUND}
+		{"surface", EMapLevel::SURFACE},
+		{"underground", EMapLevel::UNDERGROUND}
 	};
 
 	if (LEVEL_NAMES.find(str) != LEVEL_NAMES.end())
@@ -304,7 +305,7 @@
 	allowedTypes = {type};
 }
 
-void ObstacleSetFilter::setTypes(std::vector<ObstacleSet::EObstacleType> types)
+void ObstacleSetFilter::setTypes(const std::vector<ObstacleSet::EObstacleType> & types)
 {
 	this->allowedTypes = types;
 }
@@ -456,7 +457,7 @@
 
 	if (VLC->identifiersHandler->getIdentifier(scope, "obstacleTemplate", strippedName, true))
 	{
-		logMod->warn("Duplicate obstacle template: %s", strippedName);
+		logMod->debug("Duplicate obstacle template: %s", strippedName);
 		return;
 	}
 	else
@@ -476,10 +477,9 @@
 
 void ObstacleSetHandler::afterLoadFinalization()
 {
-	for (auto &os :biomes)
-	{
+	for(const auto & os : biomes)
 		os->removeEmptyTemplates();
-	}
+
 	vstd::erase_if(biomes, [](const std::shared_ptr<ObstacleSet> &os)
 	{
 		if (os->getObstacles().empty())
@@ -491,10 +491,8 @@
 	});
 
 	// Populate map
-	for (auto &os : biomes)
-	{
+	for(const auto & os : biomes)
 		obstacleSets[os->getType()].push_back(os);
-	}
 }
 
 TObstacleTypes ObstacleSetHandler::getObstacles( const ObstacleSetFilter &filter) const
diff --color -urN vcmi-1.5.7/lib/mapObjects/ObstacleSetHandler.h vcmi/lib/mapObjects/ObstacleSetHandler.h
--- vcmi-1.5.7/lib/mapObjects/ObstacleSetHandler.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapObjects/ObstacleSetHandler.h	2024-12-19 15:00:22.916148681 +0100
@@ -29,7 +29,7 @@
 		INVALID = -1,
 		MOUNTAINS = 0,
 		TREES,
-		LAKES, // Inluding dry or lava lakes
+		LAKES, // Including dry or lava lakes
 		CRATERS, // Chasms, Canyons, etc.
 		ROCKS,
 		PLANTS, // Flowers, cacti, mushrooms, logs, shrubs, etc.
@@ -38,13 +38,6 @@
 		OTHER // Crystals, shipwrecks, barrels, etc.
 	};
 
-	enum EMapLevel // TODO: Move somewhere to map definitions
-	{
-		ANY = -1,
-		SURFACE = 0,
-		UNDERGROUND = 1
-	};
-
 	ObstacleSet();
 	explicit ObstacleSet(EObstacleType type, TerrainId terrain);
 
@@ -82,18 +75,18 @@
 	std::vector<std::shared_ptr<const ObjectTemplate>> obstacles;
 };
 
-typedef std::vector<std::shared_ptr<ObstacleSet>> TObstacleTypes;
+using TObstacleTypes = std::vector<std::shared_ptr<ObstacleSet>>;
 
 class DLL_LINKAGE ObstacleSetFilter
 {
 public:
-	ObstacleSetFilter(ObstacleSet::EObstacleType allowedType, TerrainId terrain, ObstacleSet::EMapLevel level, FactionID faction, EAlignment alignment);
-	ObstacleSetFilter(std::vector<ObstacleSet::EObstacleType> allowedTypes, TerrainId terrain, ObstacleSet::EMapLevel level, FactionID faction, EAlignment alignment);
+	ObstacleSetFilter(ObstacleSet::EObstacleType allowedType, TerrainId terrain, EMapLevel level, FactionID faction, EAlignment alignment);
+	ObstacleSetFilter(std::vector<ObstacleSet::EObstacleType> allowedTypes, TerrainId terrain, EMapLevel level, FactionID faction, EAlignment alignment);
 
 	bool filter(const ObstacleSet &set) const;
 
 	void setType(ObstacleSet::EObstacleType type);
-	void setTypes(std::vector<ObstacleSet::EObstacleType> types);
+	void setTypes(const std::vector<ObstacleSet::EObstacleType> & types);
 	std::vector<ObstacleSet::EObstacleType> getAllowedTypes() const;
 	TerrainId getTerrain() const;
 
@@ -105,7 +98,7 @@
 	EAlignment alignment;
 // TODO: Filter by faction,  surface/underground, etc.
 	const TerrainId terrain;
-	ObstacleSet::EMapLevel level;
+	EMapLevel level;
 };
 
 // TODO: Instantiate ObstacleSetHandler
@@ -117,8 +110,8 @@
 	~ObstacleSetHandler() = default;
 
 	std::vector<JsonNode> loadLegacyData() override;
-	virtual void loadObject(std::string scope, std::string name, const JsonNode & data) override;
-	virtual void loadObject(std::string scope, std::string name, const JsonNode & data, size_t index) override;
+	void loadObject(std::string scope, std::string name, const JsonNode & data) override;
+	void loadObject(std::string scope, std::string name, const JsonNode & data, size_t index) override;
 	std::shared_ptr<ObstacleSet> loadFromJson(const std::string & scope, const JsonNode & json, const std::string & name, size_t index);
 
 	ObstacleSet::EObstacleType convertObstacleClass(MapObjectID id);
@@ -143,4 +136,4 @@
 		std::map<ObstacleSet::EObstacleType, std::vector<std::shared_ptr<ObstacleSet>>> obstacleSets;
 };
 
-VCMI_LIB_NAMESPACE_END
\ No newline at end of file
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/mapObjects/TownBuildingInstance.cpp vcmi/lib/mapObjects/TownBuildingInstance.cpp
--- vcmi-1.5.7/lib/mapObjects/TownBuildingInstance.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/mapObjects/TownBuildingInstance.cpp	2024-12-19 15:00:22.916148681 +0100
@@ -0,0 +1,218 @@
+/*
+ * TownBuildingInstance.cpp, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+
+#include "StdInc.h"
+#include "TownBuildingInstance.h"
+
+#include "CGTownInstance.h"
+#include "../IGameCallback.h"
+#include "../mapObjects/CGHeroInstance.h"
+#include "../entities/building/CBuilding.h"
+
+#include <vstd/RNG.h>
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+TownBuildingInstance::TownBuildingInstance(IGameCallback * cb)
+	: IObjectInterface(cb)
+	, town(nullptr)
+{}
+
+TownBuildingInstance::TownBuildingInstance(CGTownInstance * town, const BuildingID & index)
+	: IObjectInterface(town->cb)
+	, town(town)
+	, bID(index)
+{}
+
+PlayerColor TownBuildingInstance::getOwner() const
+{
+	return town->getOwner();
+}
+
+MapObjectID TownBuildingInstance::getObjGroupIndex() const
+{
+	return -1;
+}
+
+MapObjectSubID TownBuildingInstance::getObjTypeIndex() const
+{
+	return 0;
+}
+
+const IOwnableObject * TownBuildingInstance::asOwnable() const
+{
+	return nullptr;
+}
+
+int3 TownBuildingInstance::visitablePos() const
+{
+	return town->visitablePos();
+}
+
+int3 TownBuildingInstance::anchorPos() const
+{
+	return town->anchorPos();
+}
+
+TownRewardableBuildingInstance::TownRewardableBuildingInstance(IGameCallback *cb)
+	: TownBuildingInstance(cb)
+{}
+
+TownRewardableBuildingInstance::TownRewardableBuildingInstance(CGTownInstance * town, const BuildingID & index, vstd::RNG & rand)
+	: TownBuildingInstance(town, index)
+{
+	initObj(rand);
+}
+
+void TownRewardableBuildingInstance::initObj(vstd::RNG & rand)
+{
+	assert(town && town->getTown());
+	configuration = generateConfiguration(rand);
+}
+
+Rewardable::Configuration TownRewardableBuildingInstance::generateConfiguration(vstd::RNG & rand) const
+{
+	Rewardable::Configuration result;
+	auto building = town->getTown()->buildings.at(getBuildingType());
+
+	building->rewardableObjectInfo.configureObject(result, rand, cb);
+	for(auto & rewardInfo : result.info)
+	{
+		for (auto & bonus : rewardInfo.reward.bonuses)
+		{
+			bonus.source = BonusSource::TOWN_STRUCTURE;
+			bonus.sid = BonusSourceID(building->getUniqueTypeID());
+		}
+	}
+	return result;
+}
+
+void TownRewardableBuildingInstance::newTurn(vstd::RNG & rand) const
+{
+	if (configuration.resetParameters.period != 0 && cb->getDate(Date::DAY) > 1 && ((cb->getDate(Date::DAY)-1) % configuration.resetParameters.period) == 0)
+	{
+		auto newConfiguration = generateConfiguration(rand);
+		cb->setRewardableObjectConfiguration(town->id, getBuildingType(), newConfiguration);
+
+		if(configuration.resetParameters.visitors)
+		{
+			cb->setObjPropertyValue(town->id, ObjProperty::STRUCTURE_CLEAR_VISITORS, getBuildingType());
+		}
+	}
+}
+
+void TownRewardableBuildingInstance::setProperty(ObjProperty what, ObjPropertyID identifier)
+{
+	switch (what)
+	{
+		case ObjProperty::VISITORS:
+			visitors.insert(identifier.as<ObjectInstanceID>());
+			break;
+		case ObjProperty::STRUCTURE_CLEAR_VISITORS:
+			visitors.clear();
+			break;
+		case ObjProperty::REWARD_SELECT:
+			selectedReward = identifier.getNum();
+			break;
+	}
+}
+
+void TownRewardableBuildingInstance::heroLevelUpDone(const CGHeroInstance *hero) const
+{
+	grantRewardAfterLevelup(configuration.info.at(selectedReward), town, hero);
+}
+
+void TownRewardableBuildingInstance::blockingDialogAnswered(const CGHeroInstance *hero, int32_t answer) const
+{
+	onBlockingDialogAnswered(hero, answer);
+}
+
+void TownRewardableBuildingInstance::grantReward(ui32 rewardID, const CGHeroInstance * hero) const
+{
+	grantRewardBeforeLevelup(configuration.info.at(rewardID), hero);
+	
+	// hero is not blocked by levelup dialog - grant remainder immediately
+	if(!cb->isVisitCoveredByAnotherQuery(town, hero))
+	{
+		grantRewardAfterLevelup(configuration.info.at(rewardID), town, hero);
+	}
+}
+
+bool TownRewardableBuildingInstance::wasVisited(const CGHeroInstance * contextHero) const
+{
+	return wasVisitedBefore(contextHero);
+}
+
+bool TownRewardableBuildingInstance::wasVisitedBefore(const CGHeroInstance * contextHero) const
+{
+	switch (configuration.visitMode)
+	{
+		case Rewardable::VISIT_UNLIMITED:
+			return false;
+		case Rewardable::VISIT_ONCE:
+			return !visitors.empty();
+		case Rewardable::VISIT_PLAYER:
+			return false; //not supported
+		case Rewardable::VISIT_BONUS:
+		{
+			const auto building = town->getTown()->buildings.at(getBuildingType());
+			return contextHero->hasBonusFrom(BonusSource::TOWN_STRUCTURE, BonusSourceID(building->getUniqueTypeID()));
+		}
+		case Rewardable::VISIT_HERO:
+			return visitors.find(contextHero->id) != visitors.end();
+		case Rewardable::VISIT_LIMITER:
+			return configuration.visitLimiter.heroAllowed(contextHero);
+		default:
+			return false;
+	}
+}
+
+void TownRewardableBuildingInstance::onHeroVisit(const CGHeroInstance *h) const
+{
+	assert(town->hasBuilt(getBuildingType()));
+
+	if(town->hasBuilt(getBuildingType()))
+		doHeroVisit(h);
+}
+
+const IObjectInterface * TownRewardableBuildingInstance::getObject() const
+{
+	return this;
+}
+
+bool TownRewardableBuildingInstance::wasVisited(PlayerColor player) const
+{
+	switch (configuration.visitMode)
+	{
+		case Rewardable::VISIT_UNLIMITED:
+		case Rewardable::VISIT_BONUS:
+		case Rewardable::VISIT_HERO:
+		case Rewardable::VISIT_LIMITER:
+			return false;
+		case Rewardable::VISIT_ONCE:
+		case Rewardable::VISIT_PLAYER:
+			return !visitors.empty();
+		default:
+			return false;
+	}
+}
+
+void TownRewardableBuildingInstance::markAsVisited(const CGHeroInstance * hero) const
+{
+	town->addHeroToStructureVisitors(hero, getBuildingType());
+}
+
+void TownRewardableBuildingInstance::markAsScouted(const CGHeroInstance * hero) const
+{
+	// no-op - town building is always 'scouted' by owner
+}
+
+
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/mapObjects/TownBuildingInstance.h vcmi/lib/mapObjects/TownBuildingInstance.h
--- vcmi-1.5.7/lib/mapObjects/TownBuildingInstance.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/mapObjects/TownBuildingInstance.h	2024-12-19 15:00:22.916148681 +0100
@@ -0,0 +1,101 @@
+/*
+ * TownBuildingInstance.h, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+
+#pragma once
+
+#include "IObjectInterface.h"
+#include "../rewardable/Interface.h"
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+class CGTownInstance;
+class CBuilding;
+
+class DLL_LINKAGE TownBuildingInstance : public IObjectInterface
+{
+///basic class for town structures handled as map objects
+public:
+	TownBuildingInstance(CGTownInstance * town, const BuildingID & index);
+	TownBuildingInstance(IGameCallback *cb);
+
+	CGTownInstance * town;
+
+	const BuildingID & getBuildingType() const
+	{
+		return bID;
+	}
+
+	PlayerColor getOwner() const override;
+	MapObjectID getObjGroupIndex() const override;
+	MapObjectSubID getObjTypeIndex() const override;
+	const IOwnableObject * asOwnable() const override;
+
+	int3 visitablePos() const override;
+	int3 anchorPos() const override;
+
+	template <typename Handler> void serialize(Handler &h)
+	{
+		h & bID;
+		if (h.version < Handler::Version::NEW_TOWN_BUILDINGS)
+		{
+			// compatibility code
+			si32 indexOnTV = 0; //identifies its index on towns vector
+			BuildingSubID::EBuildingSubID bType = BuildingSubID::NONE;
+			h & indexOnTV;
+			h & bType;
+		}
+	}
+
+private:
+	BuildingID bID; //from building list
+};
+
+class DLL_LINKAGE TownRewardableBuildingInstance : public TownBuildingInstance, public Rewardable::Interface
+{
+	/// reward selected by player, no serialize
+	ui16 selectedReward = 0;
+	std::set<ObjectInstanceID> visitors;
+
+	bool wasVisitedBefore(const CGHeroInstance * contextHero) const override;
+	void grantReward(ui32 rewardID, const CGHeroInstance * hero) const override;
+	Rewardable::Configuration generateConfiguration(vstd::RNG & rand) const;
+
+	const IObjectInterface * getObject() const override;
+	bool wasVisited(PlayerColor player) const override;
+	void markAsVisited(const CGHeroInstance * hero) const override;
+	void markAsScouted(const CGHeroInstance * hero) const override;
+public:
+	void setProperty(ObjProperty what, ObjPropertyID identifier) override;
+	void onHeroVisit(const CGHeroInstance * h) const override;
+	bool wasVisited(const CGHeroInstance * contextHero) const override;
+	
+	void newTurn(vstd::RNG & rand) const override;
+	
+	/// gives second part of reward after hero level-ups for proper granting of spells/mana
+	void heroLevelUpDone(const CGHeroInstance *hero) const override;
+	
+	void initObj(vstd::RNG & rand) override;
+	
+	/// applies player selection of reward
+	void blockingDialogAnswered(const CGHeroInstance *hero, int32_t answer) const override;
+	
+	TownRewardableBuildingInstance(CGTownInstance * town, const BuildingID & index, vstd::RNG & rand);
+	TownRewardableBuildingInstance(IGameCallback *cb);
+	
+	template <typename Handler> void serialize(Handler &h)
+	{
+		h & static_cast<TownBuildingInstance&>(*this);
+		if (h.version >= Handler::Version::NEW_TOWN_BUILDINGS)
+			h & static_cast<Rewardable::Interface&>(*this);
+		h & visitors;
+	}
+};
+
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/mapping/CDrawRoadsOperation.cpp vcmi/lib/mapping/CDrawRoadsOperation.cpp
--- vcmi-1.5.7/lib/mapping/CDrawRoadsOperation.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapping/CDrawRoadsOperation.cpp	2024-12-19 15:00:22.917148723 +0100
@@ -12,9 +12,11 @@
 #include "CDrawRoadsOperation.h"
 #include "CMap.h"
 
-#include "../CRandomGenerator.h"
 #include "../RoadHandler.h"
 #include "../RiverHandler.h"
+#include "../VCMI_Lib.h"
+
+#include <vstd/RNG.h>
 
 VCMI_LIB_NAMESPACE_BEGIN
 
@@ -154,7 +156,7 @@
 #endif
 
 ///CDrawLinesOperation
-CDrawLinesOperation::CDrawLinesOperation(CMap * map, CTerrainSelection terrainSel, CRandomGenerator * gen):
+CDrawLinesOperation::CDrawLinesOperation(CMap * map, CTerrainSelection terrainSel, vstd::RNG * gen):
 	CMapOperation(map),
 	terrainSel(std::move(terrainSel)),
 	gen(gen)
@@ -162,14 +164,14 @@
 }
 
 ///CDrawRoadsOperation
-CDrawRoadsOperation::CDrawRoadsOperation(CMap * map, const CTerrainSelection & terrainSel, RoadId roadType, CRandomGenerator * gen):
+CDrawRoadsOperation::CDrawRoadsOperation(CMap * map, const CTerrainSelection & terrainSel, RoadId roadType, vstd::RNG * gen):
 	CDrawLinesOperation(map, terrainSel,gen),
 	roadType(roadType)
 {
 }
 
 ///CDrawRiversOperation
-CDrawRiversOperation::CDrawRiversOperation(CMap * map, const CTerrainSelection & terrainSel, RiverId riverType, CRandomGenerator * gen):
+CDrawRiversOperation::CDrawRiversOperation(CMap * map, const CTerrainSelection & terrainSel, RiverId riverType, vstd::RNG * gen):
 	CDrawLinesOperation(map, terrainSel, gen),
 	riverType(riverType)
 {
@@ -342,12 +344,12 @@
 
 void CDrawRoadsOperation::executeTile(TerrainTile & tile)
 {
-	tile.roadType = const_cast<RoadType*>(VLC->roadTypeHandler->getByIndex(roadType.getNum()));
+	tile.roadType = roadType;
 }
 
 void CDrawRiversOperation::executeTile(TerrainTile & tile)
 {
-	tile.riverType = const_cast<RiverType*>(VLC->riverTypeHandler->getByIndex(riverType.getNum()));
+	tile.riverType = riverType;
 }
 
 bool CDrawRoadsOperation::canApplyPattern(const LinePattern & pattern) const
@@ -362,22 +364,22 @@
 
 bool CDrawRoadsOperation::needUpdateTile(const TerrainTile & tile) const
 {
-	return tile.roadType->getId() != Road::NO_ROAD;
+	return tile.hasRoad();
 }
 
 bool CDrawRiversOperation::needUpdateTile(const TerrainTile & tile) const
 {
-	return tile.riverType->getId() != River::NO_RIVER;
+	return tile.hasRiver();
 }
 
 bool CDrawRoadsOperation::tileHasSomething(const int3& pos) const
 {
-	return map->getTile(pos).roadType->getId() != Road::NO_ROAD;
+	return map->getTile(pos).hasRoad();
 }
 
 bool CDrawRiversOperation::tileHasSomething(const int3& pos) const
 {
-	return map->getTile(pos).riverType->getId() != River::NO_RIVER;
+	return map->getTile(pos).hasRiver();
 }
 
 void CDrawRoadsOperation::updateTile(TerrainTile & tile, const LinePattern & pattern, const int flip)
diff --color -urN vcmi-1.5.7/lib/mapping/CDrawRoadsOperation.h vcmi/lib/mapping/CDrawRoadsOperation.h
--- vcmi-1.5.7/lib/mapping/CDrawRoadsOperation.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapping/CDrawRoadsOperation.h	2024-12-19 15:00:22.917148723 +0100
@@ -41,7 +41,7 @@
 		int flip;
 	};
 
-	CDrawLinesOperation(CMap * map, CTerrainSelection terrainSel, CRandomGenerator * gen);
+	CDrawLinesOperation(CMap * map, CTerrainSelection terrainSel, vstd::RNG * gen);
 
 	virtual void executeTile(TerrainTile & tile) = 0;
 	virtual bool canApplyPattern(const CDrawLinesOperation::LinePattern & pattern) const = 0;
@@ -58,13 +58,13 @@
 	ValidationResult validateTile(const LinePattern & pattern, const int3 & pos);
 	
 	CTerrainSelection terrainSel;
-	CRandomGenerator * gen;
+	vstd::RNG * gen;
 };
 
 class CDrawRoadsOperation : public CDrawLinesOperation
 {
 public:
-	CDrawRoadsOperation(CMap * map, const CTerrainSelection & terrainSel, RoadId roadType, CRandomGenerator * gen);
+	CDrawRoadsOperation(CMap * map, const CTerrainSelection & terrainSel, RoadId roadType, vstd::RNG * gen);
 	std::string getLabel() const override;
 	
 protected:
@@ -81,7 +81,7 @@
 class CDrawRiversOperation : public CDrawLinesOperation
 {
 public:
-	CDrawRiversOperation(CMap * map, const CTerrainSelection & terrainSel, RiverId roadType, CRandomGenerator * gen);
+	CDrawRiversOperation(CMap * map, const CTerrainSelection & terrainSel, RiverId roadType, vstd::RNG * gen);
 	std::string getLabel() const override;
 	
 protected:
diff --color -urN vcmi-1.5.7/lib/mapping/CMap.cpp vcmi/lib/mapping/CMap.cpp
--- vcmi-1.5.7/lib/mapping/CMap.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapping/CMap.cpp	2024-12-19 15:00:22.917148723 +0100
@@ -13,22 +13,24 @@
 #include "../CArtHandler.h"
 #include "../VCMI_Lib.h"
 #include "../CCreatureHandler.h"
-#include "../CTownHandler.h"
-#include "../CHeroHandler.h"
+#include "../GameSettings.h"
 #include "../RiverHandler.h"
 #include "../RoadHandler.h"
 #include "../TerrainHandler.h"
+#include "../entities/hero/CHeroHandler.h"
 #include "../mapObjects/CGHeroInstance.h"
 #include "../mapObjects/CGTownInstance.h"
 #include "../mapObjects/CQuest.h"
 #include "../mapObjects/ObjectTemplate.h"
-#include "../CGeneralTextHandler.h"
+#include "../texts/CGeneralTextHandler.h"
 #include "../spells/CSpellHandler.h"
 #include "../CSkillHandler.h"
 #include "CMapEditManager.h"
 #include "CMapOperation.h"
 #include "../serializer/JsonSerializeFormat.h"
 
+#include <vstd/RNG.h>
+
 VCMI_LIB_NAMESPACE_BEGIN
 
 void Rumor::serializeJson(JsonSerializeFormat & handler)
@@ -43,35 +45,67 @@
 }
 
 CMapEvent::CMapEvent()
-	: players(0)
-	, humanAffected(false)
+	: humanAffected(false)
 	, computerAffected(false)
-	, firstOccurence(0)
-	, nextOccurence(0)
+	, firstOccurrence(0)
+	, nextOccurrence(0)
 {
 
 }
 
-bool CMapEvent::earlierThan(const CMapEvent & other) const
+bool CMapEvent::occursToday(int currentDay) const
 {
-	return firstOccurence < other.firstOccurence;
+	if (currentDay == firstOccurrence + 1)
+		return true;
+
+	if (nextOccurrence == 0)
+		return false;
+
+	if (currentDay < firstOccurrence)
+		return false;
+
+	return (currentDay - firstOccurrence - 1) % nextOccurrence == 0;
 }
 
-bool CMapEvent::earlierThanOrEqual(const CMapEvent & other) const
+bool CMapEvent::affectsPlayer(PlayerColor color, bool isHuman) const
 {
-	return firstOccurence <= other.firstOccurence;
+	if (players.count(color) == 0)
+		return false;
+
+	if (!isHuman && !computerAffected)
+		return false;
+
+	if (isHuman && !humanAffected)
+		return false;
+
+	return true;
 }
 
 void CMapEvent::serializeJson(JsonSerializeFormat & handler)
 {
 	handler.serializeString("name", name);
 	handler.serializeStruct("message", message);
-	handler.serializeInt("players", players);
+	if (!handler.saving && handler.getCurrent()["players"].isNumber())
+	{
+		// compatibility for old maps
+		int playersMask = 0;
+		handler.serializeInt("players", playersMask);
+		for (int i = 0; i < 8; ++i)
+			if ((playersMask & (1 << i)) != 0)
+				players.insert(PlayerColor(i));
+	}
+	else
+	{
+		handler.serializeIdArray("players", players);
+	}
 	handler.serializeInt("humanAffected", humanAffected);
 	handler.serializeInt("computerAffected", computerAffected);
-	handler.serializeInt("firstOccurence", firstOccurence);
-	handler.serializeInt("nextOccurence", nextOccurence);
+	handler.serializeInt("firstOccurrence", firstOccurrence);
+	handler.serializeInt("nextOccurrence", nextOccurrence);
 	resources.serializeJson(handler, "resources");
+
+	auto deletedObjects = handler.enterArray("deletedObjectsInstances");
+	deletedObjects.serializeArray(deletedObjectsInstances);
 }
 
 void CCastleEvent::serializeJson(JsonSerializeFormat & handler)
@@ -100,32 +134,29 @@
 }
 
 TerrainTile::TerrainTile():
-	terType(nullptr),
+	riverType(River::NO_RIVER),
+	roadType(Road::NO_ROAD),
 	terView(0),
-	riverType(VLC->riverTypeHandler->getById(River::NO_RIVER)),
 	riverDir(0),
-	roadType(VLC->roadTypeHandler->getById(Road::NO_ROAD)),
 	roadDir(0),
-	extTileFlags(0),
-	visitable(false),
-	blocked(false)
+	extTileFlags(0)
 {
 }
 
 bool TerrainTile::entrableTerrain(const TerrainTile * from) const
 {
-	return entrableTerrain(from ? from->terType->isLand() : true, from ? from->terType->isWater() : true);
+	return entrableTerrain(from ? from->isLand() : true, from ? from->isWater() : true);
 }
 
 bool TerrainTile::entrableTerrain(bool allowLand, bool allowSea) const
 {
-	return terType->isPassable()
-			&& ((allowSea && terType->isWater())  ||  (allowLand && terType->isLand()));
+	return getTerrain()->isPassable()
+			&& ((allowSea && isWater())  ||  (allowLand && isLand()));
 }
 
 bool TerrainTile::isClear(const TerrainTile * from) const
 {
-	return entrableTerrain(from) && !blocked;
+	return entrableTerrain(from) && !blocked();
 }
 
 Obj TerrainTile::topVisitableId(bool excludeTop) const
@@ -146,7 +177,7 @@
 
 EDiggingStatus TerrainTile::getDiggingStatus(const bool excludeTop) const
 {
-	if(terType->isWater() || !terType->isPassable())
+	if(isWater() || !getTerrain()->isPassable())
 		return EDiggingStatus::WRONG_TERRAIN;
 
 	int allowedBlocked = excludeTop ? 1 : 0;
@@ -163,9 +194,65 @@
 
 bool TerrainTile::isWater() const
 {
-	return terType->isWater();
+	return getTerrain()->isWater();
+}
+
+bool TerrainTile::isLand() const
+{
+	return getTerrain()->isLand();
+}
+
+bool TerrainTile::visitable() const
+{
+	return !visitableObjects.empty();
+}
+
+bool TerrainTile::blocked() const
+{
+	return !blockingObjects.empty();
+}
+
+bool TerrainTile::hasRiver() const
+{
+	return getRiverID() != RiverId::NO_RIVER;
+}
+
+bool TerrainTile::hasRoad() const
+{
+	return getRoadID() != RoadId::NO_ROAD;
+}
+
+const TerrainType * TerrainTile::getTerrain() const
+{
+	return terrainType.toEntity(VLC);
+}
+
+const RiverType * TerrainTile::getRiver() const
+{
+	return riverType.toEntity(VLC);
+}
+
+const RoadType * TerrainTile::getRoad() const
+{
+	return roadType.toEntity(VLC);
+}
+
+TerrainId TerrainTile::getTerrainID() const
+{
+	return terrainType;
 }
 
+RiverId TerrainTile::getRiverID() const
+{
+	return riverType;
+}
+
+RoadId TerrainTile::getRoadID() const
+{
+	return roadType;
+}
+
+
 CMap::CMap(IGameCallback * cb)
 	: GameCallbackHolder(cb)
 	, checksum(0)
@@ -178,6 +265,9 @@
 	allowedAbilities = VLC->skillh->getDefaultAllowed();
 	allowedArtifact = VLC->arth->getDefaultAllowed();
 	allowedSpells = VLC->spellh->getDefaultAllowed();
+
+	gameSettings = std::make_unique<GameSettings>();
+	gameSettings->loadBase(VLC->settingsHandler->getFullConfig());
 }
 
 CMap::~CMap()
@@ -198,26 +288,21 @@
 
 void CMap::removeBlockVisTiles(CGObjectInstance * obj, bool total)
 {
-	const int zVal = obj->pos.z;
+	const int zVal = obj->anchorPos().z;
 	for(int fx = 0; fx < obj->getWidth(); ++fx)
 	{
-		int xVal = obj->pos.x - fx;
+		int xVal = obj->anchorPos().x - fx;
 		for(int fy = 0; fy < obj->getHeight(); ++fy)
 		{
-			int yVal = obj->pos.y - fy;
+			int yVal = obj->anchorPos().y - fy;
 			if(xVal>=0 && xVal < width && yVal>=0 && yVal < height)
 			{
 				TerrainTile & curt = terrain[zVal][xVal][yVal];
-				if(total || obj->visitableAt(xVal, yVal))
-				{
+				if(total || obj->visitableAt(int3(xVal, yVal, zVal)))
 					curt.visitableObjects -= obj;
-					curt.visitable = curt.visitableObjects.size();
-				}
-				if(total || obj->blockingAt(xVal, yVal))
-				{
+
+				if(total || obj->blockingAt(int3(xVal, yVal, zVal)))
 					curt.blockingObjects -= obj;
-					curt.blocked = curt.blockingObjects.size();
-				}
 			}
 		}
 	}
@@ -225,26 +310,21 @@
 
 void CMap::addBlockVisTiles(CGObjectInstance * obj)
 {
-	const int zVal = obj->pos.z;
+	const int zVal = obj->anchorPos().z;
 	for(int fx = 0; fx < obj->getWidth(); ++fx)
 	{
-		int xVal = obj->pos.x - fx;
+		int xVal = obj->anchorPos().x - fx;
 		for(int fy = 0; fy < obj->getHeight(); ++fy)
 		{
-			int yVal = obj->pos.y - fy;
+			int yVal = obj->anchorPos().y - fy;
 			if(xVal>=0 && xVal < width && yVal >= 0 && yVal < height)
 			{
 				TerrainTile & curt = terrain[zVal][xVal][yVal];
-				if(obj->visitableAt(xVal, yVal))
-				{
+				if(obj->visitableAt(int3(xVal, yVal, zVal)))
 					curt.visitableObjects.push_back(obj);
-					curt.visitable = true;
-				}
-				if(obj->blockingAt(xVal, yVal))
-				{
+
+				if(obj->blockingAt(int3(xVal, yVal, zVal)))
 					curt.blockingObjects.push_back(obj);
-					curt.blocked = true;
-				}
 			}
 		}
 	}
@@ -268,7 +348,7 @@
 CGHeroInstance * CMap::getHero(HeroTypeID heroID)
 {
 	for(auto & elem : heroesOnMap)
-		if(elem->getHeroType() == heroID)
+		if(elem->getHeroTypeID() == heroID)
 			return elem;
 	return nullptr;
 }
@@ -302,11 +382,6 @@
 	return false;
 }
 
-bool CMap::isInTheMap(const int3 & pos) const
-{
-	return pos.x >= 0 && pos.y >= 0 && pos.z >= 0 && pos.x < width && pos.y < height && pos.z <= (twoLevel ? 1 : 0);
-}
-
 TerrainTile & CMap::getTile(const int3 & tile)
 {
 	assert(isInTheMap(tile));
@@ -352,7 +427,7 @@
 	if (!isInTheMap(pos))
 		return int3(-1, -1, -1);
 	const TerrainTile &posTile = getTile(pos);
-	if (posTile.visitable)
+	if (posTile.visitable())
 	{
 		for (CGObjectInstance* obj : posTile.visitableObjects)
 		{
@@ -372,7 +447,7 @@
 			if (isInTheMap(pos))
 			{
 				const auto & tile = getTile(pos);
-                if (tile.visitable && (tile.isWater() == water))
+				if (tile.visitable() && (tile.isWater() == water))
 				{
 					for (CGObjectInstance* obj : tile.visitableObjects)
 					{
@@ -415,14 +490,14 @@
 				bestMatch = object;
 			else
 			{
-				if (object->pos.dist2dSQ(pos) < bestMatch->pos.dist2dSQ(pos))
+				if (object->anchorPos().dist2dSQ(pos) < bestMatch->anchorPos().dist2dSQ(pos))
 					bestMatch = object;// closer than one we already found
 			}
 		}
 	}
 	assert(bestMatch != nullptr); // if this happens - victory conditions or map itself is very, very broken
 
-	logGlobal->error("Will use %s from %s", bestMatch->getObjectName(), bestMatch->pos.toString());
+	logGlobal->error("Will use %s from %s", bestMatch->getObjectName(), bestMatch->anchorPos().toString());
 	return bestMatch;
 }
 
@@ -494,10 +569,26 @@
 	}
 }
 
+void CMap::addNewArtifactInstance(CArtifactSet & artSet)
+{
+	for(const auto & [slot, slotInfo] : artSet.artifactsWorn)
+	{
+		if(!slotInfo.locked && slotInfo.getArt())
+			addNewArtifactInstance(slotInfo.artifact);
+	}
+	for(const auto & slotInfo : artSet.artifactsInBackpack)
+		addNewArtifactInstance(slotInfo.artifact);
+}
+
 void CMap::addNewArtifactInstance(ConstTransitivePtr<CArtifactInstance> art)
 {
+	assert(art);
+	assert(art->getId() == -1);
 	art->setId(static_cast<ArtifactInstanceID>(artInstances.size()));
 	artInstances.emplace_back(art);
+		
+	for(const auto & partInfo : art->getPartsInfo())
+		addNewArtifactInstance(partInfo.art);
 }
 
 void CMap::eraseArtifactInstance(CArtifactInstance * art)
@@ -507,6 +598,34 @@
 	artInstances[art->getId().getNum()].dellNull();
 }
 
+void CMap::moveArtifactInstance(
+	CArtifactSet & srcSet, const ArtifactPosition & srcSlot,
+	CArtifactSet & dstSet, const ArtifactPosition & dstSlot)
+{
+	auto art = srcSet.getArt(srcSlot);
+	removeArtifactInstance(srcSet, srcSlot);
+	putArtifactInstance(dstSet, art, dstSlot);
+}
+
+void CMap::putArtifactInstance(CArtifactSet & set, CArtifactInstance * art, const ArtifactPosition & slot)
+{
+	art->addPlacementMap(set.putArtifact(slot, art));
+}
+
+void CMap::removeArtifactInstance(CArtifactSet & set, const ArtifactPosition & slot)
+{
+	auto art = set.getArt(slot);
+	assert(art);
+	set.removeArtifact(slot);
+	CArtifactSet::ArtPlacementMap partsMap;
+	for(auto & part : art->getPartsInfo())
+	{
+		if(part.slot != ArtifactPosition::PRE_FIRST)
+			partsMap.try_emplace(part.art, ArtifactPosition::PRE_FIRST);
+	}
+	art->addPlacementMap(partsMap);
+}
+
 void CMap::addNewQuestInstance(CQuest* quest)
 {
 	quest->qid = static_cast<si32>(quests.size());
@@ -535,7 +654,7 @@
 	auto uid = uidCounter++;
 
 	boost::format fmt("%s_%d");
-	fmt % obj->typeName % uid;
+	fmt % obj->getTypeName() % uid;
 	obj->instanceName = fmt.str();
 }
 
@@ -562,7 +681,7 @@
 void CMap::moveObject(CGObjectInstance * obj, const int3 & pos)
 {
 	removeBlockVisTiles(obj);
-	obj->pos = pos;
+	obj->setAnchorPos(pos);
 	addBlockVisTiles(obj);
 }
 
@@ -571,7 +690,7 @@
 	removeBlockVisTiles(obj);
 	instanceNames.erase(obj->instanceName);
 
-	//update indeces
+	//update indices
 
 	auto iter = std::next(objects.begin(), obj->id.getNum());
 	iter = objects.erase(iter);
@@ -582,7 +701,7 @@
 
 	obj->afterRemoveFromMap(this);
 
-	//TOOD: Clean artifact instances (mostly worn by hero?) and quests related to this object
+	//TODO: Clean artifact instances (mostly worn by hero?) and quests related to this object
 	//This causes crash with undo/redo in editor
 }
 
@@ -730,7 +849,7 @@
 		if (lhs->isRemovable() && !rhs->isRemovable())
 			return false;
 
-		return lhs->pos.y < rhs->pos.y;
+		return lhs->anchorPos().y < rhs->anchorPos().y;
 	});
 
 	// instanceNames don't change
@@ -740,4 +859,19 @@
 	}
 }
 
+const IGameSettings & CMap::getSettings() const
+{
+	return *gameSettings;
+}
+
+void CMap::overrideGameSetting(EGameSettings option, const JsonNode & input)
+{
+	return gameSettings->addOverride(option, input);
+}
+
+void CMap::overrideGameSettings(const JsonNode & input)
+{
+	return gameSettings->loadOverrides(input);
+}
+
 VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/mapping/CMapDefines.h vcmi/lib/mapping/CMapDefines.h
--- vcmi-1.5.7/lib/mapping/CMapDefines.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapping/CMapDefines.h	2024-12-19 15:00:22.917148723 +0100
@@ -11,7 +11,8 @@
 #pragma once
 
 #include "../ResourceSet.h"
-#include "../MetaString.h"
+#include "../texts/MetaString.h"
+#include "../int3.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
@@ -30,17 +31,19 @@
 	CMapEvent();
 	virtual ~CMapEvent() = default;
 
-	bool earlierThan(const CMapEvent & other) const;
-	bool earlierThanOrEqual(const CMapEvent & other) const;
+	bool occursToday(int currentDay) const;
+	bool affectsPlayer(PlayerColor player, bool isHuman) const;
 
 	std::string name;
 	MetaString message;
 	TResources resources;
-	ui8 players; // affected players, bit field?
+	std::set<PlayerColor> players;
 	bool humanAffected;
 	bool computerAffected;
-	ui32 firstOccurence;
-	ui32 nextOccurence; /// specifies after how many days the event will occur the next time; 0 if event occurs only one time
+	ui32 firstOccurrence;
+	ui32 nextOccurrence; /// specifies after how many days the event will occur the next time; 0 if event occurs only one time
+
+	std::vector<ObjectInstanceID> deletedObjectsInstances;
 
 	template <typename Handler>
 	void serialize(Handler & h)
@@ -48,11 +51,26 @@
 		h & name;
 		h & message;
 		h & resources;
-		h & players;
+		if (h.version >= Handler::Version::EVENTS_PLAYER_SET)
+		{
+			h & players;
+		}
+		else
+		{
+			ui8 playersMask = 0;
+			h & playersMask;
+			for (int i = 0; i < 8; ++i)
+				if ((playersMask & (1 << i)) != 0)
+					players.insert(PlayerColor(i));
+		}
 		h & humanAffected;
 		h & computerAffected;
-		h & firstOccurence;
-		h & nextOccurence;
+		h & firstOccurrence;
+		h & nextOccurrence;
+		if(h.version >= Handler::Version::EVENT_OBJECTS_DELETION)
+		{
+			h & deletedObjectsInstances;
+		}
 	}
 	
 	virtual void serializeJson(JsonSerializeFormat & handler);
@@ -93,20 +111,33 @@
 	Obj topVisitableId(bool excludeTop = false) const;
 	CGObjectInstance * topVisitableObj(bool excludeTop = false) const;
 	bool isWater() const;
-	EDiggingStatus getDiggingStatus(const bool excludeTop = true) const;
+	bool isLand() const;
+	EDiggingStatus getDiggingStatus(bool excludeTop = true) const;
 	bool hasFavorableWinds() const;
 
-	const TerrainType * terType;
+	bool visitable() const;
+	bool blocked() const;
+
+	const TerrainType * getTerrain() const;
+	const RiverType * getRiver() const;
+	const RoadType * getRoad() const;
+
+	TerrainId getTerrainID() const;
+	RiverId getRiverID() const;
+	RoadId getRoadID() const;
+
+	bool hasRiver() const;
+	bool hasRoad() const;
+
+	TerrainId terrainType;
+	RiverId riverType;
+	RoadId roadType;
 	ui8 terView;
-	const RiverType * riverType;
 	ui8 riverDir;
-	const RoadType * roadType;
 	ui8 roadDir;
 	/// first two bits - how to rotate terrain graphic (next two - river graphic, next two - road);
 	///	7th bit - whether tile is coastal (allows disembarking if land or block movement if water); 8th bit - Favorable Winds effect
 	ui8 extTileFlags;
-	bool visitable;
-	bool blocked;
 
 	std::vector<CGObjectInstance *> visitableObjects;
 	std::vector<CGObjectInstance *> blockingObjects;
@@ -114,15 +145,49 @@
 	template <typename Handler>
 	void serialize(Handler & h)
 	{
-		h & terType;
+		if (h.version >= Handler::Version::REMOVE_VLC_POINTERS)
+		{
+			h & terrainType;
+		}
+		else
+		{
+			bool isNull = false;
+			h & isNull;
+			if (!isNull)
+				h & terrainType;
+		}
 		h & terView;
-		h & riverType;
+		if (h.version >= Handler::Version::REMOVE_VLC_POINTERS)
+		{
+			h & riverType;
+		}
+		else
+		{
+			bool isNull = false;
+			h & isNull;
+			if (!isNull)
+				h & riverType;
+		}
 		h & riverDir;
-		h & roadType;
+		if (h.version >= Handler::Version::REMOVE_VLC_POINTERS)
+		{
+			h & roadType;
+		}
+		else
+		{
+			bool isNull = false;
+			h & isNull;
+			if (!isNull)
+				h & roadType;
+		}
 		h & roadDir;
 		h & extTileFlags;
-		h & visitable;
-		h & blocked;
+		if (h.version < Handler::Version::REMOVE_VLC_POINTERS)
+		{
+			bool unused = false;
+			h & unused;
+			h & unused;
+		}
 		h & visitableObjects;
 		h & blockingObjects;
 	}
diff --color -urN vcmi-1.5.7/lib/mapping/CMapEditManager.cpp vcmi/lib/mapping/CMapEditManager.cpp
--- vcmi-1.5.7/lib/mapping/CMapEditManager.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapping/CMapEditManager.cpp	2024-12-19 15:00:22.917148723 +0100
@@ -15,6 +15,8 @@
 #include "CDrawRoadsOperation.h"
 #include "CMapOperation.h"
 
+#include <vstd/RNG.h>
+
 VCMI_LIB_NAMESPACE_BEGIN
 
 CMapUndoManager::CMapUndoManager() :
@@ -113,34 +115,35 @@
 CMapEditManager::CMapEditManager(CMap * map)
 	: map(map), terrainSel(map), objectSel(map)
 {
-
 }
 
+CMapEditManager::~CMapEditManager() = default;
+
 CMap * CMapEditManager::getMap()
 {
 	return map;
 }
 
-void CMapEditManager::clearTerrain(CRandomGenerator * gen)
+void CMapEditManager::clearTerrain(vstd::RNG * customGen)
 {
-	execute(std::make_unique<CClearTerrainOperation>(map, gen ? gen : &(this->gen)));
+	execute(std::make_unique<CClearTerrainOperation>(map, customGen ? customGen : gen.get()));
 }
 
-void CMapEditManager::drawTerrain(TerrainId terType, int decorationsPercentage, CRandomGenerator * gen)
+void CMapEditManager::drawTerrain(TerrainId terType, int decorationsPercentage, vstd::RNG * customGen)
 {
-	execute(std::make_unique<CDrawTerrainOperation>(map, terrainSel, terType, decorationsPercentage, gen ? gen : &(this->gen)));
+	execute(std::make_unique<CDrawTerrainOperation>(map, terrainSel, terType, decorationsPercentage, customGen ? customGen : gen.get()));
 	terrainSel.clearSelection();
 }
 
-void CMapEditManager::drawRoad(RoadId roadType, CRandomGenerator* gen)
+void CMapEditManager::drawRoad(RoadId roadType, vstd::RNG* customGen)
 {
-	execute(std::make_unique<CDrawRoadsOperation>(map, terrainSel, roadType, gen ? gen : &(this->gen)));
+	execute(std::make_unique<CDrawRoadsOperation>(map, terrainSel, roadType, customGen ? customGen : gen.get()));
 	terrainSel.clearSelection();
 }
 
-void CMapEditManager::drawRiver(RiverId riverType, CRandomGenerator* gen)
+void CMapEditManager::drawRiver(RiverId riverType, vstd::RNG* customGen)
 {
-	execute(std::make_unique<CDrawRiversOperation>(map, terrainSel, riverType, gen ? gen : &(this->gen)));
+	execute(std::make_unique<CDrawRiversOperation>(map, terrainSel, riverType, customGen ? customGen : gen.get()));
 	terrainSel.clearSelection();
 }
 
diff --color -urN vcmi-1.5.7/lib/mapping/CMapEditManager.h vcmi/lib/mapping/CMapEditManager.h
--- vcmi-1.5.7/lib/mapping/CMapEditManager.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapping/CMapEditManager.h	2024-12-19 15:00:22.917148723 +0100
@@ -11,13 +11,17 @@
 #pragma once
 
 #include "../GameConstants.h"
-#include "../CRandomGenerator.h"
 #include "MapEditUtils.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
 class CMapOperation;
 
+namespace vstd
+{
+class RNG;
+}
+
 /// The CMapUndoManager provides the functionality to save operations and undo/redo them.
 class DLL_LINKAGE CMapUndoManager : boost::noncopyable
 {
@@ -64,19 +68,20 @@
 {
 public:
 	CMapEditManager(CMap * map);
+	~CMapEditManager();
 	CMap * getMap();
 
 	/// Clears the terrain. The free level is filled with water and the underground level with rock.
-	void clearTerrain(CRandomGenerator * gen = nullptr);
+	void clearTerrain(vstd::RNG * gen);
 
 	/// Draws terrain at the current terrain selection. The selection will be cleared automatically.
-	void drawTerrain(TerrainId terType, int decorationsPercentage, CRandomGenerator * gen = nullptr);
+	void drawTerrain(TerrainId terType, int decorationsPercentage, vstd::RNG * gen);
 
 	/// Draws roads at the current terrain selection. The selection will be cleared automatically.
-	void drawRoad(RoadId roadType, CRandomGenerator * gen = nullptr);
+	void drawRoad(RoadId roadType, vstd::RNG * gen);
 	
 	/// Draws rivers at the current terrain selection. The selection will be cleared automatically.
-	void drawRiver(RiverId riverType, CRandomGenerator * gen = nullptr);
+	void drawRiver(RiverId riverType, vstd::RNG * gen);
 
 	void insertObject(CGObjectInstance * obj);
 	void insertObjects(std::set<CGObjectInstance *> & objects);
@@ -94,7 +99,7 @@
 
 	CMap * map;
 	CMapUndoManager undoManager;
-	CRandomGenerator gen;
+	std::unique_ptr<vstd::RNG> gen;
 	CTerrainSelection terrainSel;
 	CObjectSelection objectSel;
 };
diff --color -urN vcmi-1.5.7/lib/mapping/CMap.h vcmi/lib/mapping/CMap.h
--- vcmi-1.5.7/lib/mapping/CMap.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapping/CMap.h	2024-12-19 15:00:22.917148723 +0100
@@ -15,12 +15,12 @@
 
 #include "../ConstTransitivePtr.h"
 #include "../GameCallbackHolder.h"
-#include "../MetaString.h"
 #include "../networkPacks/TradeItem.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
 class CArtifactInstance;
+class CArtifactSet;
 class CGObjectInstance;
 class CGHeroInstance;
 class CCommanderInstance;
@@ -32,7 +32,10 @@
 class CInputStream;
 class CMapEditManager;
 class JsonSerializeFormat;
+class IGameSettings;
+class GameSettings;
 struct TeleportChannel;
+enum class EGameSettings;
 
 /// The rumor struct consists of a rumor name and text.
 struct DLL_LINKAGE Rumor
@@ -76,6 +79,7 @@
 /// The map contains the map header, the tiles of the terrain, objects, heroes, towns, rumors...
 class DLL_LINKAGE CMap : public CMapHeader, public GameCallbackHolder
 {
+	std::unique_ptr<GameSettings> gameSettings;
 public:
 	explicit CMap(IGameCallback *cb);
 	~CMap();
@@ -85,8 +89,15 @@
 	TerrainTile & getTile(const int3 & tile);
 	const TerrainTile & getTile(const int3 & tile) const;
 	bool isCoastalTile(const int3 & pos) const;
-	bool isInTheMap(const int3 & pos) const;
 	bool isWaterTile(const int3 & pos) const;
+	inline bool isInTheMap(const int3 & pos) const
+	{
+		// Check whether coord < 0 is done implicitly. Negative signed int overflows to unsigned number larger than all signed ints.
+		return
+			static_cast<uint32_t>(pos.x) < static_cast<uint32_t>(width) &&
+			static_cast<uint32_t>(pos.y) < static_cast<uint32_t>(height) &&
+			static_cast<uint32_t>(pos.z) <= (twoLevel ? 1 : 0);
+	}
 
 	bool canMoveBetween(const int3 &src, const int3 &dst) const;
 	bool checkForVisitableDir(const int3 & src, const TerrainTile * pom, const int3 & dst) const;
@@ -96,8 +107,12 @@
 	void removeBlockVisTiles(CGObjectInstance * obj, bool total = false);
 	void calculateGuardingGreaturePositions();
 
+	void addNewArtifactInstance(CArtifactSet & artSet);
 	void addNewArtifactInstance(ConstTransitivePtr<CArtifactInstance> art);
 	void eraseArtifactInstance(CArtifactInstance * art);
+	void moveArtifactInstance(CArtifactSet & srcSet, const ArtifactPosition & srcSlot, CArtifactSet & dstSet, const ArtifactPosition & dstSlot);
+	void putArtifactInstance(CArtifactSet & set, CArtifactInstance * art, const ArtifactPosition & slot);
+	void removeArtifactInstance(CArtifactSet & set, const ArtifactPosition & slot);
 
 	void addNewQuestInstance(CQuest * quest);
 	void removeQuestInstance(CQuest * quest);
@@ -137,7 +152,7 @@
 	std::set<SpellID> allowedSpells;
 	std::set<ArtifactID> allowedArtifact;
 	std::set<SecondarySkill> allowedAbilities;
-	std::list<CMapEvent> events;
+	std::vector<CMapEvent> events;
 	int3 grailPos;
 	int grailRadius;
 
@@ -165,9 +180,13 @@
 	ui8 obeliskCount = 0; //how many obelisks are on map
 	std::map<TeamID, ui8> obelisksVisited; //map: team_id => how many obelisks has been visited
 
-	std::vector<const CArtifact *> townMerchantArtifacts;
+	std::vector<ArtifactID> townMerchantArtifacts;
 	std::vector<TradeItemBuy> townUniversitySkills;
 
+	void overrideGameSettings(const JsonNode & input);
+	void overrideGameSetting(EGameSettings option, const JsonNode & input);
+	const IGameSettings & getSettings() const;
+
 private:
 	/// a 3-dimensional array of terrain tiles, access is as follows: x, y, level. where level=1 is underground
 	boost::multi_array<TerrainTile, 3> terrain;
@@ -190,14 +209,6 @@
 		h & quests;
 		h & allHeroes;
 
-		if (h.version < Handler::Version::DESTROYED_OBJECTS)
-		{
-			// old save compatibility
-			//FIXME: remove this field after save-breaking change
-			h & questIdentifierToId;
-			resolveQuestIdentifiers();
-		}
-
 		//TODO: viccondetails
 		h & terrain;
 		h & guardingCreaturePositions;
@@ -211,10 +222,31 @@
 		// static members
 		h & obeliskCount;
 		h & obelisksVisited;
-		h & townMerchantArtifacts;
+
+		if (h.version < Handler::Version::REMOVE_VLC_POINTERS)
+		{
+			int32_t size = 0;
+			h & size;
+			for (int32_t i = 0; i < size; ++i)
+			{
+				bool isNull = false;
+				ArtifactID artifact;
+				h & isNull;
+				if (!isNull)
+					h & artifact;
+				townMerchantArtifacts.push_back(artifact);
+			}
+		}
+		else
+		{
+			h & townMerchantArtifacts;
+		}
 		h & townUniversitySkills;
 
 		h & instanceNames;
+
+		if (h.version >= Handler::Version::PER_MAP_GAME_SETTINGS)
+			h & *gameSettings;
 	}
 };
 
diff --color -urN vcmi-1.5.7/lib/mapping/CMapHeader.cpp vcmi/lib/mapping/CMapHeader.cpp
--- vcmi-1.5.7/lib/mapping/CMapHeader.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapping/CMapHeader.cpp	2024-12-19 15:00:22.917148723 +0100
@@ -13,12 +13,12 @@
 #include "MapFormat.h"
 
 #include "../VCMI_Lib.h"
-#include "../CTownHandler.h"
-#include "../CGeneralTextHandler.h"
+#include "../entities/faction/CTownHandler.h"
+#include "../entities/hero/CHeroHandler.h"
 #include "../json/JsonUtils.h"
 #include "../modding/CModHandler.h"
-#include "../CHeroHandler.h"
-#include "../Languages.h"
+#include "../texts/CGeneralTextHandler.h"
+#include "../texts/Languages.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
@@ -163,7 +163,7 @@
 	
 	std::string baseLanguage;
 	std::string language;
-	//english is preferrable as base language
+	//english is preferable as base language
 	if(mapBaseLanguages.count(Languages::getLanguageOptions(Languages::ELanguages::ENGLISH).identifier))
 		baseLanguage = Languages::getLanguageOptions(Languages::ELanguages::ENGLISH).identifier;
 	else
@@ -189,7 +189,7 @@
 		JsonUtils::mergeCopy(data, translations[language]);
 	
 	for(auto & s : data.Struct())
-		texts.registerString("map", TextIdentifier(s.first), s.second.String(), language);
+		texts.registerString("map", TextIdentifier(s.first), s.second.String());
 }
 
 std::string mapRegisterLocalizedString(const std::string & modContext, CMapHeader & mapHeader, const TextIdentifier & UID, const std::string & localized)
@@ -199,7 +199,7 @@
 
 std::string mapRegisterLocalizedString(const std::string & modContext, CMapHeader & mapHeader, const TextIdentifier & UID, const std::string & localized, const std::string & language)
 {
-	mapHeader.texts.registerString(modContext, UID, localized, language);
+	mapHeader.texts.registerString(modContext, UID, localized);
 	mapHeader.translations.Struct()[language].Struct()[UID.get()].String() = localized;
 	return UID.get();
 }
diff --color -urN vcmi-1.5.7/lib/mapping/CMapHeader.h vcmi/lib/mapping/CMapHeader.h
--- vcmi-1.5.7/lib/mapping/CMapHeader.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapping/CMapHeader.h	2024-12-19 15:00:22.917148723 +0100
@@ -13,11 +13,12 @@
 #include "../constants/EntityIdentifiers.h"
 #include "../constants/Enumerations.h"
 #include "../constants/VariantIdentifier.h"
-#include "../modding/CModInfo.h"
+#include "../modding/ModVerificationInfo.h"
+#include "../serializer/Serializeable.h"
 #include "../LogicalExpression.h"
 #include "../int3.h"
-#include "../MetaString.h"
-#include "../CGeneralTextHandler.h"
+#include "../texts/MetaString.h"
+#include "../texts/TextLocalizationContainer.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
@@ -202,7 +203,7 @@
 };
 
 /// The map header holds information about loss/victory condition,map format, version, players, height, width,...
-class DLL_LINKAGE CMapHeader
+class DLL_LINKAGE CMapHeader: public Serializeable
 {
 	void setupEvents();
 public:
@@ -229,6 +230,10 @@
 	MetaString name;
 	MetaString description;
 	EMapDifficulty difficulty;
+	MetaString author;
+	MetaString authorContact;
+	MetaString mapVersion;
+	std::time_t creationDateTime;
 	/// Specifies the maximum level to reach for a hero. A value of 0 states that there is no
 	///	maximum level for heroes. This is the default value.
 	ui8 levelLimit;
@@ -241,7 +246,7 @@
 	std::vector<PlayerInfo> players; /// The default size of the vector is PlayerColor::PLAYER_LIMIT.
 	ui8 howManyTeams;
 	std::set<HeroTypeID> allowedHeroes;
-	std::set<HeroTypeID> reservedCampaignHeroes; /// Heroes that have placeholders in this map and are reserverd for campaign
+	std::set<HeroTypeID> reservedCampaignHeroes; /// Heroes that have placeholders in this map and are reserved for campaign
 
 	bool areAnyPlayers; /// Unused. True if there are any playable players on the map.
 
@@ -262,15 +267,26 @@
 		h & mods;
 		h & name;
 		h & description;
+		if (h.version >= Handler::Version::MAP_FORMAT_ADDITIONAL_INFOS)
+		{
+			h & author;
+			h & authorContact;
+			h & mapVersion;
+			h & creationDateTime;
+		}
 		h & width;
 		h & height;
 		h & twoLevel;
-		// FIXME: we should serialize enum's according to their underlying type
-		// should be fixed when we are making breaking change to save compatiblity
-		static_assert(Handler::Version::MINIMAL < Handler::Version::RELEASE_143);
-		uint8_t difficultyInteger = static_cast<uint8_t>(difficulty);
-		h & difficultyInteger;
-		difficulty = static_cast<EMapDifficulty>(difficultyInteger);
+
+		if (h.version >= Handler::Version::SAVE_COMPATIBILITY_FIXES)
+			h & difficulty;
+		else
+		{
+			uint8_t difficultyInteger = static_cast<uint8_t>(difficulty);
+			h & difficultyInteger;
+			difficulty = static_cast<EMapDifficulty>(difficultyInteger);
+		}
+
 		h & levelLimit;
 		h & areAnyPlayers;
 		h & players;
diff --color -urN vcmi-1.5.7/lib/mapping/CMapInfo.cpp vcmi/lib/mapping/CMapInfo.cpp
--- vcmi-1.5.7/lib/mapping/CMapInfo.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapping/CMapInfo.cpp	2024-12-19 15:00:22.917148723 +0100
@@ -19,14 +19,12 @@
 
 #include "../campaign/CampaignHandler.h"
 #include "../filesystem/Filesystem.h"
-#include "../serializer/CLoadFile.h"
-#include "../CGeneralTextHandler.h"
-#include "../TextOperations.h"
 #include "../rmg/CMapGenOptions.h"
+#include "../serializer/CLoadFile.h"
+#include "../texts/CGeneralTextHandler.h"
+#include "../texts/TextOperations.h"
 #include "../CCreatureHandler.h"
-#include "../GameSettings.h"
-#include "../CHeroHandler.h"
-#include "../Languages.h"
+#include "../IGameSettings.h"
 #include "../CConfigHandler.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
@@ -168,17 +166,19 @@
 	switch(mapHeader->version)
 	{
 		case EMapFormat::ROE:
-			return VLC->settings()->getValue(EGameSettings::MAP_FORMAT_RESTORATION_OF_ERATHIA)["iconIndex"].Integer();
+			return VLC->engineSettings()->getValue(EGameSettings::MAP_FORMAT_RESTORATION_OF_ERATHIA)["iconIndex"].Integer();
 		case EMapFormat::AB:
-			return VLC->settings()->getValue(EGameSettings::MAP_FORMAT_ARMAGEDDONS_BLADE)["iconIndex"].Integer();
+			return VLC->engineSettings()->getValue(EGameSettings::MAP_FORMAT_ARMAGEDDONS_BLADE)["iconIndex"].Integer();
 		case EMapFormat::SOD:
-			return VLC->settings()->getValue(EGameSettings::MAP_FORMAT_SHADOW_OF_DEATH)["iconIndex"].Integer();
+			return VLC->engineSettings()->getValue(EGameSettings::MAP_FORMAT_SHADOW_OF_DEATH)["iconIndex"].Integer();
+		case EMapFormat::CHR:
+			return VLC->engineSettings()->getValue(EGameSettings::MAP_FORMAT_CHRONICLES)["iconIndex"].Integer();
 		case EMapFormat::WOG:
-			return VLC->settings()->getValue(EGameSettings::MAP_FORMAT_IN_THE_WAKE_OF_GODS)["iconIndex"].Integer();
+			return VLC->engineSettings()->getValue(EGameSettings::MAP_FORMAT_IN_THE_WAKE_OF_GODS)["iconIndex"].Integer();
 		case EMapFormat::HOTA:
-			return VLC->settings()->getValue(EGameSettings::MAP_FORMAT_HORN_OF_THE_ABYSS)["iconIndex"].Integer();
+			return VLC->engineSettings()->getValue(EGameSettings::MAP_FORMAT_HORN_OF_THE_ABYSS)["iconIndex"].Integer();
 		case EMapFormat::VCMI:
-			return VLC->settings()->getValue(EGameSettings::MAP_FORMAT_JSON_VCMI)["iconIndex"].Integer();
+			return VLC->engineSettings()->getValue(EGameSettings::MAP_FORMAT_JSON_VCMI)["iconIndex"].Integer();
 	}
 	return 0;
 }
diff --color -urN vcmi-1.5.7/lib/mapping/CMapInfo.h vcmi/lib/mapping/CMapInfo.h
--- vcmi-1.5.7/lib/mapping/CMapInfo.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapping/CMapInfo.h	2024-12-19 15:00:22.917148723 +0100
@@ -9,6 +9,8 @@
  */
 #pragma once
 
+#include "../serializer/Serializeable.h"
+
 VCMI_LIB_NAMESPACE_BEGIN
 
 struct StartInfo;
@@ -21,7 +23,7 @@
  * A class which stores the count of human players and all players, the filename,
  * scenario options, the map header information,...
  */
-class DLL_LINKAGE CMapInfo
+class DLL_LINKAGE CMapInfo : public Serializeable
 {
 public:
 	std::unique_ptr<CMapHeader> mapHeader; //may be nullptr if campaign
diff --color -urN vcmi-1.5.7/lib/mapping/CMapOperation.cpp vcmi/lib/mapping/CMapOperation.cpp
--- vcmi-1.5.7/lib/mapping/CMapOperation.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapping/CMapOperation.cpp	2024-12-19 15:00:22.918148764 +0100
@@ -12,12 +12,13 @@
 #include "CMapOperation.h"
 
 #include "../VCMI_Lib.h"
-#include "../CRandomGenerator.h"
 #include "../TerrainHandler.h"
 #include "../mapObjects/CGObjectInstance.h"
 #include "CMap.h"
 #include "MapEditUtils.h"
 
+#include <vstd/RNG.h>
+
 VCMI_LIB_NAMESPACE_BEGIN
 
 CMapOperation::CMapOperation(CMap* map) : map(map)
@@ -87,7 +88,7 @@
 	operations.push_back(std::move(operation));
 }
 
-CDrawTerrainOperation::CDrawTerrainOperation(CMap * map, CTerrainSelection terrainSel, TerrainId terType, int decorationsPercentage, CRandomGenerator * gen):
+CDrawTerrainOperation::CDrawTerrainOperation(CMap * map, CTerrainSelection terrainSel, TerrainId terType, int decorationsPercentage, vstd::RNG * gen):
 	CMapOperation(map),
 	terrainSel(std::move(terrainSel)),
 	terType(terType),
@@ -102,7 +103,7 @@
 	for(const auto & pos : terrainSel.getSelectedItems())
 	{
 		auto & tile = map->getTile(pos);
-		tile.terType = const_cast<TerrainType*>(VLC->terrainTypeHandler->getById(terType));
+		tile.terrainType = terType;
 		invalidateTerrainViews(pos);
 	}
 
@@ -136,7 +137,7 @@
 		auto tiles = getInvalidTiles(centerPos);
 		auto updateTerrainType = [&](const int3& pos)
 		{
-			map->getTile(pos).terType = centerTile.terType;
+			map->getTile(pos).terrainType = centerTile.terrainType;
 			positions.insert(pos);
 			invalidateTerrainViews(pos);
 			//logGlobal->debug("Set additional terrain tile at pos '%s' to type '%s'", pos, centerTile.terType);
@@ -160,10 +161,10 @@
 			rect.forEach([&](const int3& posToTest)
 				{
 					auto & terrainTile = map->getTile(posToTest);
-					if(centerTile.terType->getId() != terrainTile.terType->getId())
+					if(centerTile.getTerrain() != terrainTile.getTerrain())
 					{
-						const auto * formerTerType = terrainTile.terType;
-						terrainTile.terType = centerTile.terType;
+						const auto formerTerType = terrainTile.terrainType;
+						terrainTile.terrainType = centerTile.terrainType;
 						auto testTile = getInvalidTiles(posToTest);
 
 						int nativeTilesCntNorm = testTile.nativeTiles.empty() ? std::numeric_limits<int>::max() : static_cast<int>(testTile.nativeTiles.size());
@@ -220,7 +221,7 @@
 							suitableTiles.insert(posToTest);
 						}
 
-						terrainTile.terType = formerTerType;
+						terrainTile.terrainType = formerTerType;
 					}
 				});
 
@@ -263,7 +264,7 @@
 {
 	for(const auto & pos : invalidatedTerViews)
 	{
-		const auto & patterns = VLC->terviewh->getTerrainViewPatterns(map->getTile(pos).terType->getId());
+		const auto & patterns = VLC->terviewh->getTerrainViewPatterns(map->getTile(pos).getTerrainID());
 
 		// Detect a pattern which fits best
 		int bestPattern = -1;
@@ -339,7 +340,7 @@
 
 CDrawTerrainOperation::ValidationResult CDrawTerrainOperation::validateTerrainViewInner(const int3& pos, const TerrainViewPattern& pattern, int recDepth) const
 {
-	const auto * centerTerType = map->getTile(pos).terType;
+	const auto * centerTerType = map->getTile(pos).getTerrain();
 	int totalPoints = 0;
 	std::string transitionReplacement;
 
@@ -371,24 +372,24 @@
 			}
 			else if(widthTooHigh)
 			{
-				terType = map->getTile(int3(currentPos.x - 1, currentPos.y, currentPos.z)).terType;
+				terType = map->getTile(int3(currentPos.x - 1, currentPos.y, currentPos.z)).getTerrain();
 			}
 			else if(heightTooHigh)
 			{
-				terType = map->getTile(int3(currentPos.x, currentPos.y - 1, currentPos.z)).terType;
+				terType = map->getTile(int3(currentPos.x, currentPos.y - 1, currentPos.z)).getTerrain();
 			}
 			else if(widthTooLess)
 			{
-				terType = map->getTile(int3(currentPos.x + 1, currentPos.y, currentPos.z)).terType;
+				terType = map->getTile(int3(currentPos.x + 1, currentPos.y, currentPos.z)).getTerrain();
 			}
 			else if(heightTooLess)
 			{
-				terType = map->getTile(int3(currentPos.x, currentPos.y + 1, currentPos.z)).terType;
+				terType = map->getTile(int3(currentPos.x, currentPos.y + 1, currentPos.z)).getTerrain();
 			}
 		}
 		else
 		{
-			terType = map->getTile(currentPos).terType;
+			terType = map->getTile(currentPos).getTerrain();
 			if(terType != centerTerType && (terType->isPassable() || centerTerType->isPassable()))
 			{
 				isAlien = true;
@@ -508,13 +509,13 @@
 {
 	//TODO: this is very expensive function for RMG, needs optimization
 	InvalidTiles tiles;
-	const auto * centerTerType = map->getTile(centerPos).terType;
+	const auto * centerTerType = map->getTile(centerPos).getTerrain();
 	auto rect = extendTileAround(centerPos);
 	rect.forEach([&](const int3& pos)
 		{
 			if(map->isInTheMap(pos))
 			{
-				const auto * terType = map->getTile(pos).terType;
+				const auto * terType = map->getTile(pos).getTerrain();
 				auto valid = validateTerrainView(pos, VLC->terviewh->getTerrainTypePatternById("n1")).result;
 
 				// Special validity check for rock & water
@@ -560,7 +561,7 @@
 
 }
 
-CClearTerrainOperation::CClearTerrainOperation(CMap* map, CRandomGenerator* gen) : CComposedOperation(map)
+CClearTerrainOperation::CClearTerrainOperation(CMap* map, vstd::RNG* gen) : CComposedOperation(map)
 {
 	CTerrainSelection terrainSel(map);
 	terrainSel.selectRange(MapRect(int3(0, 0, 0), map->width, map->height));
@@ -614,7 +615,7 @@
 CMoveObjectOperation::CMoveObjectOperation(CMap* map, CGObjectInstance* obj, const int3& targetPosition)
 	: CMapOperation(map),
 	obj(obj),
-	initialPos(obj->pos),
+	initialPos(obj->anchorPos()),
 	targetPos(targetPosition)
 {
 }
diff --color -urN vcmi-1.5.7/lib/mapping/CMapOperation.h vcmi/lib/mapping/CMapOperation.h
--- vcmi-1.5.7/lib/mapping/CMapOperation.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapping/CMapOperation.h	2024-12-19 15:00:22.918148764 +0100
@@ -17,7 +17,11 @@
 
 class CGObjectInstance;
 class CMap;
-class CRandomGenerator;
+
+namespace vstd
+{
+class RNG;
+}
 
 /// The abstract base class CMapOperation defines an operation that can be executed, undone and redone.
 class DLL_LINKAGE CMapOperation : public boost::noncopyable
@@ -63,7 +67,7 @@
 class CDrawTerrainOperation : public CMapOperation
 {
 public:
-	CDrawTerrainOperation(CMap * map, CTerrainSelection terrainSel, TerrainId terType, int decorationsPercentage, CRandomGenerator * gen);
+	CDrawTerrainOperation(CMap * map, CTerrainSelection terrainSel, TerrainId terType, int decorationsPercentage, vstd::RNG * gen);
 
 	void execute() override;
 	void undo() override;
@@ -103,7 +107,7 @@
 	CTerrainSelection terrainSel;
 	TerrainId terType;
 	int decorationsPercentage;
-	CRandomGenerator* gen;
+	vstd::RNG* gen;
 	std::set<int3> invalidatedTerViews;
 };
 
@@ -111,7 +115,7 @@
 class CClearTerrainOperation : public CComposedOperation
 {
 public:
-	CClearTerrainOperation(CMap * map, CRandomGenerator * gen);
+	CClearTerrainOperation(CMap * map, vstd::RNG * gen);
 
 	std::string getLabel() const override;
 };
diff --color -urN vcmi-1.5.7/lib/mapping/CMapService.cpp vcmi/lib/mapping/CMapService.cpp
--- vcmi-1.5.7/lib/mapping/CMapService.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapping/CMapService.cpp	2024-12-19 15:00:22.918148764 +0100
@@ -17,9 +17,8 @@
 #include "../filesystem/CMemoryStream.h"
 #include "../filesystem/CMemoryBuffer.h"
 #include "../modding/CModHandler.h"
+#include "../modding/ModDescription.h"
 #include "../modding/ModScope.h"
-#include "../modding/CModInfo.h"
-#include "../Languages.h"
 #include "../VCMI_Lib.h"
 
 #include "CMap.h"
@@ -34,8 +33,7 @@
 std::unique_ptr<CMap> CMapService::loadMap(const ResourcePath & name, IGameCallback * cb) const
 {
 	std::string modName = VLC->modh->findResourceOrigin(name);
-	std::string language = VLC->modh->getModLanguage(modName);
-	std::string encoding = Languages::getLanguageOptions(language).encoding;
+	std::string encoding = VLC->modh->findResourceEncoding(name);
 
 	auto stream = getStreamFromFS(name);
 	return getMapLoader(stream, name.getName(), modName, encoding)->loadMap(cb);
@@ -44,8 +42,7 @@
 std::unique_ptr<CMapHeader> CMapService::loadMapHeader(const ResourcePath & name) const
 {
 	std::string modName = VLC->modh->findResourceOrigin(name);
-	std::string language = VLC->modh->getModLanguage(modName);
-	std::string encoding = Languages::getLanguageOptions(language).encoding;
+	std::string encoding = VLC->modh->findResourceEncoding(name);
 
 	auto stream = getStreamFromFS(name);
 	return getMapLoader(stream, name.getName(), modName, encoding)->loadMapHeader();
@@ -102,7 +99,7 @@
 		if(vstd::contains(activeMods, mapMod.first))
 		{
 			const auto & modInfo = VLC->modh->getModInfo(mapMod.first);
-			if(modInfo.getVerificationInfo().version.compatible(mapMod.second.version))
+			if(modInfo.getVersion().compatible(mapMod.second.version))
 				continue;
 		}
 		missingMods[mapMod.first] = mapMod.second;
@@ -157,6 +154,7 @@
 			case static_cast<int>(EMapFormat::AB)  :
 			case static_cast<int>(EMapFormat::ROE) :
 			case static_cast<int>(EMapFormat::SOD) :
+			case static_cast<int>(EMapFormat::CHR) :
 			case static_cast<int>(EMapFormat::HOTA) :
 				return std::unique_ptr<IMapLoader>(new CMapLoaderH3M(mapName, modName, encoding, stream.get()));
 			default :
diff --color -urN vcmi-1.5.7/lib/mapping/MapEditUtils.cpp vcmi/lib/mapping/MapEditUtils.cpp
--- vcmi-1.5.7/lib/mapping/MapEditUtils.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapping/MapEditUtils.cpp	2024-12-19 15:00:22.918148764 +0100
@@ -13,6 +13,7 @@
 
 #include "../filesystem/Filesystem.h"
 #include "../TerrainHandler.h"
+#include "../VCMI_Lib.h"
 #include "CMap.h"
 #include "CMapOperation.h"
 
@@ -355,7 +356,7 @@
 			{
 				auto debugTile = map->getTile(debugPos);
 
-				std::string terType = debugTile.terType->shortIdentifier;
+				std::string terType = debugTile.getTerrain()->shortIdentifier;
 				line += terType;
 				line.insert(line.end(), PADDED_LENGTH - terType.size(), ' ');
 			}
diff --color -urN vcmi-1.5.7/lib/mapping/MapFeaturesH3M.cpp vcmi/lib/mapping/MapFeaturesH3M.cpp
--- vcmi-1.5.7/lib/mapping/MapFeaturesH3M.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapping/MapFeaturesH3M.cpp	2024-12-19 15:00:22.918148764 +0100
@@ -25,6 +25,8 @@
 			return getFeaturesAB();
 		case EMapFormat::SOD:
 			return getFeaturesSOD();
+		case EMapFormat::CHR:
+			return getFeaturesCHR();
 		case EMapFormat::WOG:
 			return getFeaturesWOG();
 		case EMapFormat::HOTA:
@@ -107,6 +109,16 @@
 	return result;
 }
 
+MapFormatFeaturesH3M MapFormatFeaturesH3M::getFeaturesCHR()
+{
+	MapFormatFeaturesH3M result = getFeaturesSOD();
+	result.levelCHR = true;
+
+	result.heroesPortraitsCount = 169; // +6x tarnum
+
+	return result;
+}
+
 MapFormatFeaturesH3M MapFormatFeaturesH3M::getFeaturesWOG()
 {
 	MapFormatFeaturesH3M result = getFeaturesSOD();
@@ -118,7 +130,7 @@
 MapFormatFeaturesH3M MapFormatFeaturesH3M::getFeaturesHOTA(uint32_t hotaVersion)
 {
 	// even if changes are minimal, we might not be able to parse map header in map selection screen
-	// throw exception - to be catched by map selection screen & excluded as invalid
+	// throw exception - to be caught by map selection screen & excluded as invalid
 	if(hotaVersion > 3)
 		throw std::runtime_error("Invalid map format!");
 
diff --color -urN vcmi-1.5.7/lib/mapping/MapFeaturesH3M.h vcmi/lib/mapping/MapFeaturesH3M.h
--- vcmi-1.5.7/lib/mapping/MapFeaturesH3M.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapping/MapFeaturesH3M.h	2024-12-19 15:00:22.918148764 +0100
@@ -21,6 +21,7 @@
 	static MapFormatFeaturesH3M getFeaturesROE();
 	static MapFormatFeaturesH3M getFeaturesAB();
 	static MapFormatFeaturesH3M getFeaturesSOD();
+	static MapFormatFeaturesH3M getFeaturesCHR();
 	static MapFormatFeaturesH3M getFeaturesWOG();
 	static MapFormatFeaturesH3M getFeaturesHOTA(uint32_t hotaVersion);
 
@@ -64,6 +65,7 @@
 	bool levelROE = false;
 	bool levelAB = false;
 	bool levelSOD = false;
+	bool levelCHR = false;
 	bool levelWOG = false;
 	bool levelHOTA0 = false;
 	bool levelHOTA1 = false;
diff --color -urN vcmi-1.5.7/lib/mapping/MapFormat.h vcmi/lib/mapping/MapFormat.h
--- vcmi-1.5.7/lib/mapping/MapFormat.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapping/MapFormat.h	2024-12-19 15:00:22.918148764 +0100
@@ -19,7 +19,7 @@
 	ROE   = 0x0e, // 14
 	AB    = 0x15, // 21
 	SOD   = 0x1c, // 28
-//	CHR   = 0x1d, // 29 Heroes Chronicles, presumably - identical to SoD, untested
+	CHR   = 0x1d, // 29
 	HOTA  = 0x20, // 32
 	WOG   = 0x33, // 51
 	VCMI  = 0x64
diff --color -urN vcmi-1.5.7/lib/mapping/MapFormatH3M.cpp vcmi/lib/mapping/MapFormatH3M.cpp
--- vcmi-1.5.7/lib/mapping/MapFormatH3M.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapping/MapFormatH3M.cpp	2024-12-19 15:00:22.919148805 +0100
@@ -17,17 +17,16 @@
 
 #include "../ArtifactUtils.h"
 #include "../CCreatureHandler.h"
-#include "../CGeneralTextHandler.h"
-#include "../CHeroHandler.h"
+#include "../texts/CGeneralTextHandler.h"
 #include "../CSkillHandler.h"
 #include "../CStopWatch.h"
-#include "../GameSettings.h"
+#include "../IGameSettings.h"
 #include "../RiverHandler.h"
 #include "../RoadHandler.h"
 #include "../TerrainHandler.h"
-#include "../TextOperations.h"
 #include "../VCMI_Lib.h"
 #include "../constants/StringConstants.h"
+#include "../entities/hero/CHeroHandler.h"
 #include "../filesystem/CBinaryReader.h"
 #include "../filesystem/Filesystem.h"
 #include "../mapObjectConstructors/AObjectTypeHandler.h"
@@ -39,6 +38,7 @@
 #include "../networkPacks/Component.h"
 #include "../networkPacks/ArtifactLocation.h"
 #include "../spells/CSpellHandler.h"
+#include "../texts/TextOperations.h"
 
 #include <boost/crc.hpp>
 
@@ -130,15 +130,17 @@
 	MapIdentifiersH3M identifierMapper;
 
 	if(features.levelROE)
-		identifierMapper.loadMapping(VLC->settings()->getValue(EGameSettings::MAP_FORMAT_RESTORATION_OF_ERATHIA));
+		identifierMapper.loadMapping(VLC->engineSettings()->getValue(EGameSettings::MAP_FORMAT_RESTORATION_OF_ERATHIA));
 	if(features.levelAB)
-		identifierMapper.loadMapping(VLC->settings()->getValue(EGameSettings::MAP_FORMAT_ARMAGEDDONS_BLADE));
+		identifierMapper.loadMapping(VLC->engineSettings()->getValue(EGameSettings::MAP_FORMAT_ARMAGEDDONS_BLADE));
 	if(features.levelSOD)
-		identifierMapper.loadMapping(VLC->settings()->getValue(EGameSettings::MAP_FORMAT_SHADOW_OF_DEATH));
+		identifierMapper.loadMapping(VLC->engineSettings()->getValue(EGameSettings::MAP_FORMAT_SHADOW_OF_DEATH));
+	if(features.levelCHR)
+		identifierMapper.loadMapping(VLC->engineSettings()->getValue(EGameSettings::MAP_FORMAT_CHRONICLES));
 	if(features.levelWOG)
-		identifierMapper.loadMapping(VLC->settings()->getValue(EGameSettings::MAP_FORMAT_IN_THE_WAKE_OF_GODS));
+		identifierMapper.loadMapping(VLC->engineSettings()->getValue(EGameSettings::MAP_FORMAT_IN_THE_WAKE_OF_GODS));
 	if(features.levelHOTA0)
-		identifierMapper.loadMapping(VLC->settings()->getValue(EGameSettings::MAP_FORMAT_HORN_OF_THE_ABYSS));
+		identifierMapper.loadMapping(VLC->engineSettings()->getValue(EGameSettings::MAP_FORMAT_HORN_OF_THE_ABYSS));
 
 	return identifierMapper;
 }
@@ -161,6 +163,7 @@
 	addMapping(EMapFormat::ROE);
 	addMapping(EMapFormat::AB);
 	addMapping(EMapFormat::SOD);
+	addMapping(EMapFormat::CHR);
 	addMapping(EMapFormat::HOTA);
 	addMapping(EMapFormat::WOG);
 
@@ -205,20 +208,23 @@
 
 	// optimization - load mappings only once to avoid slow parsing of map headers for map list
 	static const std::map<EMapFormat, MapIdentifiersH3M> identifierMappers = generateMappings();
+	if (!identifierMappers.count(mapHeader->version))
+		throw std::runtime_error("Unsupported map format! Format ID " + std::to_string(static_cast<int>(mapHeader->version)));
+
 	const MapIdentifiersH3M & identifierMapper = identifierMappers.at(mapHeader->version);
 
 	reader->setIdentifierRemapper(identifierMapper);
 
-	// include basic mod
-	if(mapHeader->version == EMapFormat::WOG)
-		mapHeader->mods["wake-of-gods"];
-
 	// Read map name, description, dimensions,...
 	mapHeader->areAnyPlayers = reader->readBool();
 	mapHeader->height = mapHeader->width = reader->readInt32();
 	mapHeader->twoLevel = reader->readBool();
 	mapHeader->name.appendTextID(readLocalizedString("header.name"));
 	mapHeader->description.appendTextID(readLocalizedString("header.description"));
+	mapHeader->author.appendRawString("");
+	mapHeader->authorContact.appendRawString("");
+	mapHeader->mapVersion.appendRawString("");
+	mapHeader->creationDateTime = 0;
 	mapHeader->difficulty = static_cast<EMapDifficulty>(reader->readInt8Checked(0, 4));
 
 	if(features.levelAB)
@@ -730,8 +736,7 @@
 	{
 		//TODO: HotA
 		bool allowSpecialMonths = reader->readBool();
-		if(!allowSpecialMonths)
-			logGlobal->warn("Map '%s': Option 'allow special months' is not implemented!", mapName);
+		map->overrideGameSetting(EGameSettings::CREATURES_ALLOW_RANDOM_SPECIAL_WEEKS, JsonNode(allowSpecialMonths));
 		reader->skipZero(3);
 	}
 
@@ -890,7 +895,7 @@
 		}
 		map->predefinedHeroes.emplace_back(hero);
 
-		logGlobal->debug("Map '%s': Hero predefined in map: %s", mapName, VLC->heroh->getById(hero->getHeroType())->getJsonKey());
+		logGlobal->debug("Map '%s': Hero predefined in map: %s", mapName, hero->getHeroType()->getJsonKey());
 	}
 }
 
@@ -907,11 +912,11 @@
 
 	if(!hero->artifactsWorn.empty() || !hero->artifactsInBackpack.empty())
 	{
-		logGlobal->debug("Hero %d at %s has set artifacts twice (in map properties and on adventure map instance). Using the latter set...", hero->getHeroType().getNum(), hero->pos.toString());
+		logGlobal->debug("Hero %d at %s has set artifacts twice (in map properties and on adventure map instance). Using the latter set...", hero->getHeroTypeID().getNum(), hero->anchorPos().toString());
 
 		hero->artifactsInBackpack.clear();
 		while(!hero->artifactsWorn.empty())
-			hero->eraseArtSlot(hero->artifactsWorn.begin()->first);
+			hero->removeArtifact(hero->artifactsWorn.begin()->first);
 	}
 
 	for(int i = 0; i < features.artifactSlotsCount; i++)
@@ -950,14 +955,15 @@
 	// H3 bug workaround - Enemy hero on 3rd scenario of Good1.h3c campaign ("Long Live The Queen")
 	// He has Shackles of War (normally - MISC slot artifact) in LEFT_HAND slot set in editor
 	// Artifact seems to be missing in game, so skip artifacts that don't fit target slot
-	auto * artifact = ArtifactUtils::createArtifact(map, artifactID);
-	if(artifact->canBePutAt(hero, ArtifactPosition(slot)))
+	if(ArtifactID(artifactID).toArtifact()->canBePutAt(hero, ArtifactPosition(slot)))
 	{
-		artifact->putAt(*hero, ArtifactPosition(slot));
+		auto * artifact = ArtifactUtils::createArtifact(artifactID);
+		map->putArtifactInstance(*hero, artifact, slot);
+		map->addNewArtifactInstance(artifact);
 	}
 	else
 	{
-		logGlobal->warn("Map '%s': Artifact '%s' can't be put at the slot %d", mapName, artifact->artType->getNameTranslated(), slot);
+		logGlobal->warn("Map '%s': Artifact '%s' can't be put at the slot %d", mapName, ArtifactID(artifactID).toArtifact()->getNameTranslated(), slot);
 		return false;
 	}
 
@@ -978,17 +984,13 @@
 			for(pos.x = 0; pos.x < map->width; pos.x++)
 			{
 				auto & tile = map->getTile(pos);
-				tile.terType = VLC->terrainTypeHandler->getById(reader->readTerrain());
+				tile.terrainType = reader->readTerrain();
 				tile.terView = reader->readUInt8();
-				tile.riverType = VLC->riverTypeHandler->getById(reader->readRiver());
+				tile.riverType = reader->readRiver();
 				tile.riverDir = reader->readUInt8();
-				tile.roadType = VLC->roadTypeHandler->getById(reader->readRoad());
+				tile.roadType = reader->readRoad();
 				tile.roadDir = reader->readUInt8();
 				tile.extTileFlags = reader->readUInt8();
-				tile.blocked = !tile.terType->isPassable();
-				tile.visitable = false;
-
-				assert(tile.terType->getId() != ETerrainId::NONE);
 			}
 		}
 	}
@@ -1052,7 +1054,7 @@
 	if(auto val = reader->readInt8Checked(-3, 3))
 		reward.bonuses.emplace_back(BonusDuration::ONE_BATTLE, BonusType::LUCK, BonusSource::OBJECT_INSTANCE, val, BonusSourceID(idToBeGiven));
 
-	reader->readResourses(reward.resources);
+	reader->readResources(reward.resources);
 	for(int x = 0; x < GameConstants::PRIMARY_SKILLS; ++x)
 		reward.primary.at(x) = reader->readUInt8();
 
@@ -1109,7 +1111,7 @@
 	if(hasMessage)
 	{
 		object->message.appendTextID(readLocalizedString(TextIdentifier("monster", mapPosition.x, mapPosition.y, mapPosition.z, "message")));
-		reader->readResourses(object->resources);
+		reader->readResources(object->resources);
 		object->gainedArtifact = reader->readArtifact();
 	}
 	object->neverFlees = reader->readBool();
@@ -1119,18 +1121,18 @@
 	if(features.levelHOTA3)
 	{
 		//TODO: HotA
-		int32_t agressionExact = reader->readInt32(); // -1 = default, 1-10 = possible values range
+		int32_t aggressionExact = reader->readInt32(); // -1 = default, 1-10 = possible values range
 		bool joinOnlyForMoney = reader->readBool(); // if true, monsters will only join for money
-		int32_t joinPercent = reader->readInt32(); // 100 = default, percent of monsters that will join on succesfull agression check
+		int32_t joinPercent = reader->readInt32(); // 100 = default, percent of monsters that will join on successful aggression check
 		int32_t upgradedStack = reader->readInt32(); // Presence of upgraded stack, -1 = random, 0 = never, 1 = always
 		int32_t stacksCount = reader->readInt32(); // TODO: check possible values. How many creature stacks will be present on battlefield, -1 = default
 
-		if(agressionExact != -1 || joinOnlyForMoney || joinPercent != 100 || upgradedStack != -1 || stacksCount != -1)
+		if(aggressionExact != -1 || joinOnlyForMoney || joinPercent != 100 || upgradedStack != -1 || stacksCount != -1)
 			logGlobal->warn(
 				"Map '%s': Wandering monsters %s settings %d %d %d %d %d are not implemented!",
 				mapName,
 				mapPosition.toString(),
-				agressionExact,
+				aggressionExact,
 				int(joinOnlyForMoney),
 				joinPercent,
 				upgradedStack,
@@ -1301,7 +1303,8 @@
 		artID = ArtifactID(objectTemplate->subid);
 	}
 
-	object->storedArtifact = ArtifactUtils::createArtifact(map, artID, spellID.getNum());
+	object->storedArtifact = ArtifactUtils::createArtifact(artID, spellID.getNum());
+	map->addNewArtifactInstance(object->storedArtifact);
 	return object;
 }
 
@@ -1451,7 +1454,7 @@
 CGObjectInstance * CMapLoaderH3M::readPyramid(const int3 & mapPosition, std::shared_ptr<const ObjectTemplate> objectTemplate)
 {
 	if(objectTemplate->subid == 0)
-		return new CBank(map->cb);
+		return readGeneric(mapPosition, objectTemplate);
 
 	return new CGObjectInstance(map->cb);
 }
@@ -1470,9 +1473,9 @@
 	return object;
 }
 
-CGObjectInstance * CMapLoaderH3M::readLighthouse(const int3 & mapPosition)
+CGObjectInstance * CMapLoaderH3M::readLighthouse(const int3 & mapPosition, std::shared_ptr<const ObjectTemplate> objectTemplate)
 {
-	auto * object = new CGLighthouse(map->cb);
+	auto * object = readGeneric(mapPosition, objectTemplate);
 	setOwnerAndValidate(mapPosition, object, reader->readPlayer32());
 	return object;
 }
@@ -1610,7 +1613,7 @@
 			return readPyramid(mapPosition, objectTemplate);
 
 		case Obj::LIGHTHOUSE:
-			return readLighthouse(mapPosition);
+			return readLighthouse(mapPosition, objectTemplate);
 
 		case Obj::CREATURE_BANK:
 		case Obj::DERELICT_SHIP:
@@ -1643,7 +1646,7 @@
 		if(!newObject)
 			continue;
 
-		newObject->pos = mapPosition;
+		newObject->setAnchorPos(mapPosition);
 		newObject->ID = objectTemplate->id;
 		newObject->id = objectInstanceID;
 		if(newObject->ID != Obj::HERO && newObject->ID != Obj::HERO_PLACEHOLDER && newObject->ID != Obj::PRISON)
@@ -1770,7 +1773,7 @@
 
 	for(auto & elem : map->disposedHeroes)
 	{
-		if(elem.heroId == object->getHeroType())
+		if(elem.heroId == object->getHeroTypeID())
 		{
 			object->nameCustomTextId = elem.name;
 			object->customPortraitSource = elem.portrait;
@@ -1780,7 +1783,7 @@
 
 	bool hasName = reader->readBool();
 	if(hasName)
-		object->nameCustomTextId = readLocalizedString(TextIdentifier("heroes", object->getHeroType().getNum(), "name"));
+		object->nameCustomTextId = readLocalizedString(TextIdentifier("heroes", object->getHeroTypeID().getNum(), "name"));
 
 	if(features.levelSOD)
 	{
@@ -1883,7 +1886,7 @@
 			auto ps = object->getAllBonuses(Selector::type()(BonusType::PRIMARY_SKILL).And(Selector::sourceType()(BonusSource::HERO_BASE_SKILL)), nullptr);
 			if(ps->size())
 			{
-				logGlobal->debug("Hero %s has set primary skills twice (in map properties and on adventure map instance). Using the latter set...", object->getHeroType().getNum() );
+				logGlobal->debug("Hero %s has set primary skills twice (in map properties and on adventure map instance). Using the latter set...", object->getHeroTypeID().getNum() );
 				for(const auto & b : *ps)
 					object->removeBonus(b);
 			}
@@ -1896,7 +1899,7 @@
 	}
 
 	if (object->subID != MapObjectSubID())
-		logGlobal->debug("Map '%s': Hero on map: %s at %s, owned by %s", mapName, VLC->heroh->getById(object->getHeroType())->getJsonKey(), mapPosition.toString(), object->getOwner().toString());
+		logGlobal->debug("Map '%s': Hero on map: %s at %s, owned by %s", mapName, object->getHeroType()->getJsonKey(), mapPosition.toString(), object->getOwner().toString());
 	else
 		logGlobal->debug("Map '%s': Hero on map: (random) at %s, owned by %s", mapName, mapPosition.toString(), object->getOwner().toString());
 
@@ -2109,7 +2112,7 @@
 			guard->quest->mission.creatures.resize(typeNumber);
 			for(size_t hh = 0; hh < typeNumber; ++hh)
 			{
-				guard->quest->mission.creatures[hh].type = reader->readCreature().toCreature();
+				guard->quest->mission.creatures[hh].setType(reader->readCreature().toCreature());
 				guard->quest->mission.creatures[hh].count = reader->readUInt16();
 			}
 			break;
@@ -2194,7 +2197,10 @@
 	bool hasCustomBuildings = reader->readBool();
 	if(hasCustomBuildings)
 	{
-		reader->readBitmaskBuildings(object->builtBuildings, faction);
+		std::set<BuildingID> builtBuildings;
+		reader->readBitmaskBuildings(builtBuildings, faction);
+		for(const auto & building : builtBuildings)
+			object->addBuilding(building);
 		reader->readBitmaskBuildings(object->forbiddenBuildings, faction);
 	}
 	// Standard buildings
@@ -2202,10 +2208,10 @@
 	{
 		bool hasFort = reader->readBool();
 		if(hasFort)
-			object->builtBuildings.insert(BuildingID::FORT);
+			object->addBuilding(BuildingID::FORT);
 
 		//means that set of standard building should be included
-		object->builtBuildings.insert(BuildingID::DEFAULT);
+		object->addBuilding(BuildingID::DEFAULT);
 	}
 
 	if(features.levelAB)
@@ -2224,10 +2230,7 @@
 	}
 
 	if(features.levelHOTA1)
-	{
-		// TODO: HOTA support
-		[[maybe_unused]] bool spellResearchAvailable = reader->readBool();
-	}
+		object->spellResearchAllowed = reader->readBool();
 
 	// Read castle events
 	uint32_t eventsCount = reader->readUInt32();
@@ -2238,17 +2241,17 @@
 		event.name = readBasicString();
 		event.message.appendTextID(readLocalizedString(TextIdentifier("town", position.x, position.y, position.z, "event", eventID, "description")));
 
-		reader->readResourses(event.resources);
+		reader->readResources(event.resources);
 
-		event.players = reader->readUInt8();
+		reader->readBitmaskPlayers(event.players, false);
 		if(features.levelSOD)
 			event.humanAffected = reader->readBool();
 		else
 			event.humanAffected = true;
 
 		event.computerAffected = reader->readBool();
-		event.firstOccurence = reader->readUInt16();
-		event.nextOccurence = reader->readUInt8();
+		event.firstOccurrence = reader->readUInt16();
+		event.nextOccurrence = reader->readUInt8();
 
 		reader->skipZero(17);
 
@@ -2276,7 +2279,7 @@
 				if (mapHeader->players[alignment].canAnyonePlay())
 					object->alignmentToPlayer = PlayerColor(alignment);
 				else
-					logGlobal->warn("%s - Aligment of town at %s is invalid! Player %d is not present on map!", mapName, position.toString(), int(alignment));
+					logGlobal->warn("%s - Alignment of town at %s is invalid! Player %d is not present on map!", mapName, position.toString(), int(alignment));
 			}
 			else
 			{
@@ -2285,11 +2288,11 @@
 
 				if(invertedAlignment < PlayerColor::PLAYER_LIMIT.getNum())
 				{
-					logGlobal->warn("%s - Aligment of town at %s 'not as player %d' is not implemented!", mapName, position.toString(), alignment - PlayerColor::PLAYER_LIMIT.getNum());
+					logGlobal->warn("%s - Alignment of town at %s 'not as player %d' is not implemented!", mapName, position.toString(), alignment - PlayerColor::PLAYER_LIMIT.getNum());
 				}
 				else
 				{
-					logGlobal->warn("%s - Aligment of town at %s is corrupted!!", mapName, position.toString());
+					logGlobal->warn("%s - Alignment of town at %s is corrupted!!", mapName, position.toString());
 				}
 			}
 		}
@@ -2308,8 +2311,8 @@
 		event.name = readBasicString();
 		event.message.appendTextID(readLocalizedString(TextIdentifier("event", eventID, "description")));
 
-		reader->readResourses(event.resources);
-		event.players = reader->readUInt8();
+		reader->readResources(event.resources);
+		reader->readBitmaskPlayers(event.players, false);
 		if(features.levelSOD)
 		{
 			event.humanAffected = reader->readBool();
@@ -2319,8 +2322,8 @@
 			event.humanAffected = true;
 		}
 		event.computerAffected = reader->readBool();
-		event.firstOccurence = reader->readUInt16();
-		event.nextOccurence = reader->readUInt8();
+		event.firstOccurrence = reader->readUInt16();
+		event.nextOccurrence = reader->readUInt8();
 
 		reader->skipZero(17);
 
diff --color -urN vcmi-1.5.7/lib/mapping/MapFormatH3M.h vcmi/lib/mapping/MapFormatH3M.h
--- vcmi-1.5.7/lib/mapping/MapFormatH3M.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapping/MapFormatH3M.h	2024-12-19 15:00:22.919148805 +0100
@@ -208,7 +208,7 @@
 	CGObjectInstance * readPyramid(const int3 & position, std::shared_ptr<const ObjectTemplate> objTempl);
 	CGObjectInstance * readQuestGuard(const int3 & position);
 	CGObjectInstance * readShipyard(const int3 & mapPosition, std::shared_ptr<const ObjectTemplate> objectTemplate);
-	CGObjectInstance * readLighthouse(const int3 & mapPosition);
+	CGObjectInstance * readLighthouse(const int3 & mapPosition, std::shared_ptr<const ObjectTemplate> objectTemplate);
 	CGObjectInstance * readGeneric(const int3 & position, std::shared_ptr<const ObjectTemplate> objectTemplate);
 	CGObjectInstance * readBank(const int3 & position, std::shared_ptr<const ObjectTemplate> objectTemplate);
 
diff --color -urN vcmi-1.5.7/lib/mapping/MapFormatJson.cpp vcmi/lib/mapping/MapFormatJson.cpp
--- vcmi-1.5.7/lib/mapping/MapFormatJson.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapping/MapFormatJson.cpp	2024-12-19 15:00:22.919148805 +0100
@@ -17,12 +17,12 @@
 #include "CMap.h"
 #include "MapFormat.h"
 #include "../ArtifactUtils.h"
-#include "../CHeroHandler.h"
-#include "../CTownHandler.h"
 #include "../VCMI_Lib.h"
 #include "../RiverHandler.h"
 #include "../RoadHandler.h"
 #include "../TerrainHandler.h"
+#include "../entities/faction/CTownHandler.h"
+#include "../entities/hero/CHeroHandler.h"
 #include "../mapObjectConstructors/AObjectTypeHandler.h"
 #include "../mapObjectConstructors/CObjectClassesHandler.h"
 #include "../mapObjects/ObjectTemplate.h"
@@ -36,7 +36,7 @@
 #include "../constants/StringConstants.h"
 #include "../serializer/JsonDeserializer.h"
 #include "../serializer/JsonSerializer.h"
-#include "../Languages.h"
+#include "../texts/Languages.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
@@ -260,34 +260,34 @@
 
 }
 
-TerrainType * CMapFormatJson::getTerrainByCode(const std::string & code)
+TerrainId CMapFormatJson::getTerrainByCode(const std::string & code)
 {
 	for(const auto & object : VLC->terrainTypeHandler->objects)
 	{
 		if(object->shortIdentifier == code)
-			return const_cast<TerrainType *>(object.get());
+			return object->getId();
 	}
-	return nullptr;
+	return TerrainId::NONE;
 }
 
-RiverType * CMapFormatJson::getRiverByCode(const std::string & code)
+RiverId CMapFormatJson::getRiverByCode(const std::string & code)
 {
 	for(const auto & object : VLC->riverTypeHandler->objects)
 	{
 		if (object->shortIdentifier == code)
-			return const_cast<RiverType *>(object.get());
+			return object->getId();
 	}
-	return nullptr;
+	return RiverId::NO_RIVER;
 }
 
-RoadType * CMapFormatJson::getRoadByCode(const std::string & code)
+RoadId CMapFormatJson::getRoadByCode(const std::string & code)
 {
 	for(const auto & object : VLC->roadTypeHandler->objects)
 	{
 		if (object->shortIdentifier == code)
-			return const_cast<RoadType *>(object.get());
+			return object->getId();
 	}
-	return nullptr;
+	return RoadId::NO_ROAD;
 }
 
 void CMapFormatJson::serializeAllowedFactions(JsonSerializeFormat & handler, std::set<FactionID> & value) const
@@ -296,9 +296,9 @@
 
 	if(handler.saving)
 	{
-		for(auto faction : VLC->townh->objects)
-			if(faction->town && vstd::contains(value, faction->getId()))
-				temp.insert(faction->getId());
+		for(auto const factionID : VLC->townh->getDefaultAllowed())
+			if(vstd::contains(value, factionID))
+				temp.insert(factionID);
 	}
 
 	handler.serializeLIC("allowedFactions", &FactionID::decode, &FactionID::encode, VLC->townh->getDefaultAllowed(), temp);
@@ -311,6 +311,10 @@
 {
 	handler.serializeStruct("name", mapHeader->name);
 	handler.serializeStruct("description", mapHeader->description);
+	handler.serializeStruct("author", mapHeader->author);
+	handler.serializeStruct("authorContact", mapHeader->authorContact);
+	handler.serializeStruct("mapVersion", mapHeader->mapVersion);
+	handler.serializeInt("creationDateTime", mapHeader->creationDateTime, 0);
 	handler.serializeInt("heroLevelLimit", mapHeader->levelLimit, 0);
 
 	//todo: support arbitrary percentage
@@ -325,6 +329,8 @@
 
 	handler.serializeStruct("defeatMessage", mapHeader->defeatMessage);
 	handler.serializeInt("defeatIconIndex", mapHeader->defeatIconIndex);
+
+	handler.serializeIdArray("reservedCampaignHeroes", mapHeader->reservedCampaignHeroes);
 }
 
 void CMapFormatJson::serializePlayerInfo(JsonSerializeFormat & handler)
@@ -430,10 +436,8 @@
 						if(hero->ID == Obj::HERO)
 						{
 							std::string temp;
-							if(hero->type)
-								temp = hero->type->getJsonKey();
-							else
-								temp = hero->getHeroType().toEntity(VLC)->getJsonKey();
+							if(hero->getHeroTypeID().hasValue())
+								temp = hero->getHeroType()->getJsonKey();
 
 							handler.serializeString("type", temp);
 						}
@@ -809,7 +813,7 @@
 
 	auto data = loader.load(resource)->readAll();
 
-	JsonNode res(reinterpret_cast<const std::byte*>(data.first.get()), data.second);
+	JsonNode res(reinterpret_cast<const std::byte*>(data.first.get()), data.second, archiveFilename);
 
 	return res;
 }
@@ -855,7 +859,6 @@
 	//todo: multilevel map load support
 	{
 		auto levels = handler.enterStruct("mapLevels");
-
 		{
 			auto surface = handler.enterStruct("surface");
 			handler.serializeInt("height", mapHeader->height);
@@ -887,7 +890,7 @@
 		using namespace TerrainDetail;
 		{//terrain type
 			const std::string typeCode = src.substr(0, 2);
-			tile.terType = getTerrainByCode(typeCode);
+			tile.terrainType = getTerrainByCode(typeCode);
 		}
 		int startPos = 2; //0+typeCode fixed length
 		{//terrain view
@@ -917,7 +920,7 @@
 			tile.roadType = getRoadByCode(typeCode);
 			if(!tile.roadType) //it's not a road, it's a river
 			{
-				tile.roadType = VLC->roadTypeHandler->getById(Road::NO_ROAD);
+				tile.roadType = Road::NO_ROAD;
 				tile.riverType = getRiverByCode(typeCode);
 				hasRoad = false;
 				if(!tile.riverType)
@@ -1011,8 +1014,6 @@
 		const JsonNode underground = getFromArchive(TERRAIN_FILE_NAMES[1]);
 		readTerrainLevel(underground, 1);
 	}
-
-	map->calculateWaterContent();
 }
 
 CMapLoaderJson::MapObjectLoader::MapObjectLoader(CMapLoaderJson * _owner, JsonMap::value_type & json):
@@ -1067,7 +1068,7 @@
 
 	instance->id = ObjectInstanceID(static_cast<si32>(owner->map->objects.size()));
 	instance->instanceName = jsonKey;
-	instance->pos = pos;
+	instance->setAnchorPos(pos);
 	owner->map->addNewObject(instance);
 }
 
@@ -1104,13 +1105,15 @@
 			artID = art->getArtifact();
 		}
 
-		art->storedArtifact = ArtifactUtils::createArtifact(owner->map, artID, spellID.getNum());
+		art->storedArtifact = ArtifactUtils::createArtifact(artID, spellID.getNum());
+		owner->map->addNewArtifactInstance(art->storedArtifact);
 	}
 
 	if(auto * hero = dynamic_cast<CGHeroInstance *>(instance))
 	{
 		auto o = handler.enterStruct("options");
-		hero->serializeJsonArtifacts(handler, "artifacts", owner->map);
+		hero->serializeJsonArtifacts(handler, "artifacts");
+		owner->map->addNewArtifactInstance(*hero);
 	}
 }
 
@@ -1147,10 +1150,10 @@
 
 		auto * hero = dynamic_cast<const CGHeroInstance *>(object.get());
 
-		if (debugHeroesOnMap.count(hero->getHeroType()))
+		if (debugHeroesOnMap.count(hero->getHeroTypeID()))
 			logGlobal->error("Hero is already on the map at %s", hero->visitablePos().toString());
 
-		debugHeroesOnMap.insert(hero->getHeroType());
+		debugHeroesOnMap.insert(hero->getHeroTypeID());
 	}
 }
 
@@ -1251,13 +1254,13 @@
 	out.setf(std::ios::dec, std::ios::basefield);
 	out.unsetf(std::ios::showbase);
 
-	out << tile.terType->shortIdentifier << static_cast<int>(tile.terView) << flipCodes[tile.extTileFlags % 4];
+	out << tile.getTerrain()->shortIdentifier << static_cast<int>(tile.terView) << flipCodes[tile.extTileFlags % 4];
 
-	if(tile.roadType->getId() != Road::NO_ROAD)
-		out << tile.roadType->shortIdentifier << static_cast<int>(tile.roadDir) << flipCodes[(tile.extTileFlags >> 4) % 4];
+	if(tile.hasRoad())
+		out << tile.getRoad()->shortIdentifier << static_cast<int>(tile.roadDir) << flipCodes[(tile.extTileFlags >> 4) % 4];
 
-	if(tile.riverType->getId() != River::NO_RIVER)
-		out << tile.riverType->shortIdentifier << static_cast<int>(tile.riverDir) << flipCodes[(tile.extTileFlags >> 2) % 4];
+	if(tile.hasRiver())
+		out << tile.getRiver()->shortIdentifier << static_cast<int>(tile.riverDir) << flipCodes[(tile.extTileFlags >> 2) % 4];
 
 	return out.str();
 }
diff --color -urN vcmi-1.5.7/lib/mapping/MapFormatJson.h vcmi/lib/mapping/MapFormatJson.h
--- vcmi-1.5.7/lib/mapping/MapFormatJson.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapping/MapFormatJson.h	2024-12-19 15:00:22.919148805 +0100
@@ -60,9 +60,9 @@
 
 	CMapFormatJson();
 
-	static TerrainType * getTerrainByCode(const std::string & code);
-	static RiverType * getRiverByCode(const std::string & code);
-	static RoadType * getRoadByCode(const std::string & code);
+	static TerrainId getTerrainByCode(const std::string & code);
+	static RiverId getRiverByCode(const std::string & code);
+	static RoadId getRoadByCode(const std::string & code);
 
 	void serializeAllowedFactions(JsonSerializeFormat & handler, std::set<FactionID> & value) const;
 
diff --color -urN vcmi-1.5.7/lib/mapping/MapIdentifiersH3M.cpp vcmi/lib/mapping/MapIdentifiersH3M.cpp
--- vcmi-1.5.7/lib/mapping/MapIdentifiersH3M.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapping/MapIdentifiersH3M.cpp	2024-12-19 15:00:22.919148805 +0100
@@ -12,8 +12,8 @@
 #include "MapIdentifiersH3M.h"
 
 #include "../VCMI_Lib.h"
-#include "../CTownHandler.h"
-#include "../CHeroHandler.h"
+#include "../entities/faction/CFaction.h"
+#include "../entities/faction/CTownHandler.h"
 #include "../filesystem/Filesystem.h"
 #include "../mapObjectConstructors/AObjectTypeHandler.h"
 #include "../mapObjectConstructors/CObjectClassesHandler.h"
diff --color -urN vcmi-1.5.7/lib/mapping/MapReaderH3M.cpp vcmi/lib/mapping/MapReaderH3M.cpp
--- vcmi-1.5.7/lib/mapping/MapReaderH3M.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapping/MapReaderH3M.cpp	2024-12-19 15:00:22.919148805 +0100
@@ -393,7 +393,7 @@
 #endif
 }
 
-void MapReaderH3M::readResourses(TResources & resources)
+void MapReaderH3M::readResources(TResources & resources)
 {
 	for(int x = 0; x < features.resourcesCount; ++x)
 		resources[x] = reader->readInt32();
@@ -410,9 +410,11 @@
 int8_t MapReaderH3M::readInt8Checked(int8_t lowerLimit, int8_t upperLimit)
 {
 	int8_t result = readInt8();
-	assert(result >= lowerLimit);
-	assert(result <= upperLimit);
-	return std::clamp(result, lowerLimit, upperLimit);
+	int8_t resultClamped = std::clamp(result, lowerLimit, upperLimit);
+	if (result != resultClamped)
+		logGlobal->warn("Map contains out of range value %d! Expected %d-%d", static_cast<int>(result), static_cast<int>(lowerLimit), static_cast<int>(upperLimit));
+
+	return resultClamped;
 }
 
 uint8_t MapReaderH3M::readUInt8()
diff --color -urN vcmi-1.5.7/lib/mapping/MapReaderH3M.h vcmi/lib/mapping/MapReaderH3M.h
--- vcmi-1.5.7/lib/mapping/MapReaderH3M.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapping/MapReaderH3M.h	2024-12-19 15:00:22.920148847 +0100
@@ -67,7 +67,7 @@
 	void skipUnused(size_t amount);
 	void skipZero(size_t amount);
 
-	void readResourses(TResources & resources);
+	void readResources(TResources & resources);
 
 	bool readBool();
 
diff --color -urN vcmi-1.5.7/lib/mapping/ObstacleProxy.cpp vcmi/lib/mapping/ObstacleProxy.cpp
--- vcmi-1.5.7/lib/mapping/ObstacleProxy.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapping/ObstacleProxy.cpp	2024-12-19 15:00:22.920148847 +0100
@@ -16,6 +16,9 @@
 #include "../mapObjects/CGObjectInstance.h"
 #include "../mapObjects/ObjectTemplate.h"
 #include "../mapObjects/ObstacleSetHandler.h"
+#include "../VCMI_Lib.h"
+
+#include <vstd/RNG.h>
 
 VCMI_LIB_NAMESPACE_BEGIN
 
@@ -52,7 +55,7 @@
 	});
 }
 
-bool ObstacleProxy::prepareBiome(const ObstacleSetFilter & filter, CRandomGenerator & rand)
+bool ObstacleProxy::prepareBiome(const ObstacleSetFilter & filter, vstd::RNG & rand)
 {
 	possibleObstacles.clear();
 
@@ -227,7 +230,7 @@
 	return false;
 };
 
-int ObstacleProxy::getWeightedObjects(const int3 & tile, CRandomGenerator & rand, IGameCallback * cb, std::list<rmg::Object> & allObjects, std::vector<std::pair<rmg::Object*, int3>> & weightedObjects)
+int ObstacleProxy::getWeightedObjects(const int3 & tile, vstd::RNG & rand, IGameCallback * cb, std::list<rmg::Object> & allObjects, std::vector<std::pair<rmg::Object*, int3>> & weightedObjects)
 {
 	int maxWeight = std::numeric_limits<int>::min();
 	for(auto & possibleObstacle : possibleObstacles)
@@ -308,7 +311,7 @@
 	return maxWeight;
 }
 
-std::set<CGObjectInstance*> ObstacleProxy::createObstacles(CRandomGenerator & rand, IGameCallback * cb)
+std::set<CGObjectInstance*> ObstacleProxy::createObstacles(vstd::RNG & rand, IGameCallback * cb)
 {
 	//reverse order, since obstacles begin in bottom-right corner, while the map coordinates begin in top-left
 	auto blockedTiles = blockedArea.getTilesVector();
@@ -381,7 +384,7 @@
 	return map->isInTheMap(tile);
 }
 
-std::set<CGObjectInstance*> EditorObstaclePlacer::placeObstacles(CRandomGenerator & rand)
+std::set<CGObjectInstance*> EditorObstaclePlacer::placeObstacles(vstd::RNG & rand)
 {
 	auto obstacles = createObstacles(rand, map->cb);
 	finalInsertion(map->getEditManager(), obstacles);
diff --color -urN vcmi-1.5.7/lib/mapping/ObstacleProxy.h vcmi/lib/mapping/ObstacleProxy.h
--- vcmi-1.5.7/lib/mapping/ObstacleProxy.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/mapping/ObstacleProxy.h	2024-12-19 15:00:22.920148847 +0100
@@ -18,7 +18,6 @@
 class CMapEditManager;
 class CGObjectInstance;
 class ObjectTemplate;
-class CRandomGenerator;
 class IGameCallback;
 class ObstacleSetFilter;
 
@@ -30,7 +29,7 @@
 	virtual ~ObstacleProxy() = default;
 
 	void collectPossibleObstacles(TerrainId terrain);
-	bool prepareBiome(const ObstacleSetFilter & filter, CRandomGenerator & rand);
+	bool prepareBiome(const ObstacleSetFilter & filter, vstd::RNG & rand);
 
 	void addBlockedTile(const int3 & tile);
 
@@ -44,7 +43,7 @@
 
 	virtual void placeObject(rmg::Object & object, std::set<CGObjectInstance*> & instances);
 
-	virtual std::set<CGObjectInstance*> createObstacles(CRandomGenerator & rand, IGameCallback * cb);
+	virtual std::set<CGObjectInstance*> createObstacles(vstd::RNG & rand, IGameCallback * cb);
 
 	virtual bool isInTheMap(const int3& tile) = 0;
 	
@@ -53,7 +52,7 @@
 	virtual void postProcess(const rmg::Object& object) {};
 
 protected:
-	int getWeightedObjects(const int3& tile, CRandomGenerator& rand, IGameCallback * cb, std::list<rmg::Object>& allObjects, std::vector<std::pair<rmg::Object*, int3>>& weightedObjects);
+	int getWeightedObjects(const int3& tile, vstd::RNG& rand, IGameCallback * cb, std::list<rmg::Object>& allObjects, std::vector<std::pair<rmg::Object*, int3>>& weightedObjects);
 	void sortObstacles();
 
 	rmg::Area blockedArea;
@@ -71,7 +70,7 @@
 
 	bool isInTheMap(const int3& tile) override;
 
-	std::set<CGObjectInstance*> placeObstacles(CRandomGenerator& rand);
+	std::set<CGObjectInstance*> placeObstacles(vstd::RNG& rand);
 
 private:
 	CMap* map;
diff --color -urN vcmi-1.5.7/lib/MetaString.cpp vcmi/lib/MetaString.cpp
--- vcmi-1.5.7/lib/MetaString.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/MetaString.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,433 +0,0 @@
-/*
- * MetaString.cpp, part of VCMI engine
- *
- * Authors: listed in file AUTHORS in main folder
- *
- * License: GNU General Public License v2.0 or later
- * Full text of license available in license.txt file, in main folder
- *
- */
-#include "StdInc.h"
-#include "MetaString.h"
-
-#include "CArtHandler.h"
-#include "CCreatureHandler.h"
-#include "CCreatureSet.h"
-#include "CGeneralTextHandler.h"
-#include "CSkillHandler.h"
-#include "GameConstants.h"
-#include "VCMI_Lib.h"
-#include "mapObjectConstructors/CObjectClassesHandler.h"
-#include "spells/CSpellHandler.h"
-#include "serializer/JsonSerializeFormat.h"
-
-VCMI_LIB_NAMESPACE_BEGIN
-
-MetaString MetaString::createFromRawString(const std::string & value)
-{
-	MetaString result;
-	result.appendRawString(value);
-	return result;
-}
-
-MetaString MetaString::createFromTextID(const std::string & value)
-{
-	MetaString result;
-	result.appendTextID(value);
-	return result;
-}
-
-void MetaString::appendLocalString(EMetaText type, ui32 serial)
-{
-	message.push_back(EMessage::APPEND_LOCAL_STRING);
-	localStrings.emplace_back(type, serial);
-}
-
-void MetaString::appendRawString(const std::string & value)
-{
-	message.push_back(EMessage::APPEND_RAW_STRING);
-	exactStrings.push_back(value);
-}
-
-void MetaString::appendTextID(const std::string & value)
-{
-	if (!value.empty())
-	{
-		message.push_back(EMessage::APPEND_TEXTID_STRING);
-		stringsTextID.push_back(value);
-	}
-}
-
-void MetaString::appendNumber(int64_t value)
-{
-	message.push_back(EMessage::APPEND_NUMBER);
-	numbers.push_back(value);
-}
-
-void MetaString::appendEOL()
-{
-	message.push_back(EMessage::APPEND_EOL);
-}
-
-void MetaString::replaceLocalString(EMetaText type, ui32 serial)
-{
-	message.push_back(EMessage::REPLACE_LOCAL_STRING);
-	localStrings.emplace_back(type, serial);
-}
-
-void MetaString::replaceRawString(const std::string &txt)
-{
-	message.push_back(EMessage::REPLACE_RAW_STRING);
-	exactStrings.push_back(txt);
-}
-
-void MetaString::replaceTextID(const std::string & value)
-{
-	message.push_back(EMessage::REPLACE_TEXTID_STRING);
-	stringsTextID.push_back(value);
-}
-
-void MetaString::replaceNumber(int64_t txt)
-{
-	message.push_back(EMessage::REPLACE_NUMBER);
-	numbers.push_back(txt);
-}
-
-void MetaString::replacePositiveNumber(int64_t txt)
-{
-	message.push_back(EMessage::REPLACE_POSITIVE_NUMBER);
-	numbers.push_back(txt);
-}
-
-void MetaString::clear()
-{
-	exactStrings.clear();
-	localStrings.clear();
-	stringsTextID.clear();
-	message.clear();
-	numbers.clear();
-}
-
-bool MetaString::empty() const
-{
-	return message.empty() || toString().empty();
-}
-
-std::string MetaString::getLocalString(const std::pair<EMetaText, ui32> & txt) const
-{
-	EMetaText type = txt.first;
-	int ser = txt.second;
-
-	switch(type)
-	{
-		case EMetaText::GENERAL_TXT:
-			return VLC->generaltexth->translate("core.genrltxt", ser);
-		case EMetaText::ARRAY_TXT:
-			return VLC->generaltexth->translate("core.arraytxt", ser);
-		case EMetaText::ADVOB_TXT:
-			return VLC->generaltexth->translate("core.advevent", ser);
-		case EMetaText::JK_TXT:
-			return VLC->generaltexth->translate("core.jktext", ser);
-		default:
-			logGlobal->error("Failed string substitution because type is %d", static_cast<int>(type));
-			return "#@#";
-	}
-}
-
-DLL_LINKAGE std::string MetaString::toString() const
-{
-	std::string dst;
-
-	size_t exSt = 0;
-	size_t loSt = 0;
-	size_t nums = 0;
-	size_t textID = 0;
-	dst.clear();
-
-	for(const auto & elem : message)
-	{
-		switch(elem)
-		{
-			case EMessage::APPEND_RAW_STRING:
-				dst += exactStrings.at(exSt++);
-				break;
-			case EMessage::APPEND_LOCAL_STRING:
-				dst += getLocalString(localStrings.at(loSt++));
-				break;
-			case EMessage::APPEND_TEXTID_STRING:
-				dst += VLC->generaltexth->translate(stringsTextID.at(textID++));
-				break;
-			case EMessage::APPEND_NUMBER:
-				dst += std::to_string(numbers.at(nums++));
-				break;
-			case EMessage::APPEND_EOL:
-				dst += '\n';
-				break;
-			case EMessage::REPLACE_RAW_STRING:
-				boost::replace_first(dst, "%s", exactStrings.at(exSt++));
-				break;
-			case EMessage::REPLACE_LOCAL_STRING:
-				boost::replace_first(dst, "%s", getLocalString(localStrings.at(loSt++)));
-				break;
-			case EMessage::REPLACE_TEXTID_STRING:
-				boost::replace_first(dst, "%s", VLC->generaltexth->translate(stringsTextID.at(textID++)));
-				break;
-			case EMessage::REPLACE_NUMBER:
-				boost::replace_first(dst, "%d", std::to_string(numbers.at(nums++)));
-				break;
-			case EMessage::REPLACE_POSITIVE_NUMBER:
-				if (dst.find("%+d") != std::string::npos)
-				{
-					int64_t value = numbers.at(nums);
-					if (value > 0)
-						boost::replace_first(dst, "%+d", '+' + std::to_string(value));
-					else
-						boost::replace_first(dst, "%+d", std::to_string(value));
-
-					nums++;
-				}
-				else
-					boost::replace_first(dst, "%d", std::to_string(numbers.at(nums++)));
-				break;
-			default:
-				logGlobal->error("MetaString processing error! Received message of type %d", static_cast<int>(elem));
-				assert(0);
-				break;
-		}
-	}
-	return dst;
-}
-
-DLL_LINKAGE std::string MetaString::buildList() const
-{
-	size_t exSt = 0;
-	size_t loSt = 0;
-	size_t nums = 0;
-	size_t textID = 0;
-	std::string lista;
-	for(int i = 0; i < message.size(); ++i)
-	{
-		if(i > 0 && (message.at(i) == EMessage::APPEND_RAW_STRING || message.at(i) == EMessage::APPEND_LOCAL_STRING))
-		{
-			if(exSt == exactStrings.size() - 1)
-				lista += VLC->generaltexth->allTexts[141]; //" and "
-			else
-				lista += ", ";
-		}
-		switch(message.at(i))
-		{
-			case EMessage::APPEND_RAW_STRING:
-				lista += exactStrings.at(exSt++);
-				break;
-			case EMessage::APPEND_LOCAL_STRING:
-				lista += getLocalString(localStrings.at(loSt++));
-				break;
-			case EMessage::APPEND_TEXTID_STRING:
-				lista += VLC->generaltexth->translate(stringsTextID.at(textID++));
-				break;
-			case EMessage::APPEND_NUMBER:
-				lista += std::to_string(numbers.at(nums++));
-				break;
-			case EMessage::APPEND_EOL:
-				lista += '\n';
-				break;
-			case EMessage::REPLACE_RAW_STRING:
-				lista.replace(lista.find("%s"), 2, exactStrings.at(exSt++));
-				break;
-			case EMessage::REPLACE_LOCAL_STRING:
-				lista.replace(lista.find("%s"), 2, getLocalString(localStrings.at(loSt++)));
-				break;
-			case EMessage::REPLACE_TEXTID_STRING:
-				lista.replace(lista.find("%s"), 2, VLC->generaltexth->translate(stringsTextID.at(textID++)));
-				break;
-			case EMessage::REPLACE_NUMBER:
-				lista.replace(lista.find("%d"), 2, std::to_string(numbers.at(nums++)));
-				break;
-			default:
-				logGlobal->error("MetaString processing error! Received message of type %d", int(message.at(i)));
-		}
-	}
-	return lista;
-}
-
-bool MetaString::operator == (const MetaString & other) const
-{
-	return message == other.message && localStrings == other.localStrings && exactStrings == other.exactStrings && stringsTextID == other.stringsTextID && numbers == other.numbers;
-}
-
-void MetaString::jsonSerialize(JsonNode & dest) const
-{
-	JsonNode jsonMessage;
-	JsonNode jsonLocalStrings;
-	JsonNode jsonExactStrings;
-	JsonNode jsonStringsTextID;
-	JsonNode jsonNumbers;
-
-	for (const auto & entry : message )
-	{
-		JsonNode value;
-		value.Float() = static_cast<int>(entry);
-		jsonMessage.Vector().push_back(value);
-	}
-
-	for (const auto & entry : localStrings )
-	{
-		JsonNode value;
-		value.Integer() = static_cast<int>(entry.first) * 10000 + entry.second;
-		jsonLocalStrings.Vector().push_back(value);
-	}
-
-	for (const auto & entry : exactStrings )
-	{
-		JsonNode value;
-		value.String() = entry;
-		jsonExactStrings.Vector().push_back(value);
-	}
-
-	for (const auto & entry : stringsTextID )
-	{
-		JsonNode value;
-		value.String() = entry;
-		jsonStringsTextID.Vector().push_back(value);
-	}
-
-	for (const auto & entry : numbers )
-	{
-		JsonNode value;
-		value.Integer() = entry;
-		jsonNumbers.Vector().push_back(value);
-	}
-
-	dest["message"] = jsonMessage;
-	dest["localStrings"] = jsonLocalStrings;
-	dest["exactStrings"] = jsonExactStrings;
-	dest["stringsTextID"] = jsonStringsTextID;
-	dest["numbers"] = jsonNumbers;
-}
-
-void MetaString::jsonDeserialize(const JsonNode & source)
-{
-	clear();
-
-	if (source.isString())
-	{
-		// compatibility with fields that were converted from string to MetaString
-		if(boost::starts_with(source.String(), "core.") || boost::starts_with(source.String(), "vcmi."))
-			appendTextID(source.String());
-		else
-			appendRawString(source.String());
-		return;
-	}
-
-	for (const auto & entry : source["message"].Vector() )
-		message.push_back(static_cast<EMessage>(entry.Integer()));
-
-	for (const auto & entry : source["localStrings"].Vector() )
-		localStrings.push_back({ static_cast<EMetaText>(entry.Integer() / 10000), entry.Integer() % 10000 });
-
-	for (const auto & entry : source["exactStrings"].Vector() )
-		exactStrings.push_back(entry.String());
-
-	for (const auto & entry : source["stringsTextID"].Vector() )
-		stringsTextID.push_back(entry.String());
-
-	for (const auto & entry : source["numbers"].Vector() )
-		numbers.push_back(entry.Integer());
-}
-
-void MetaString::serializeJson(JsonSerializeFormat & handler)
-{
-	if(handler.saving)
-		jsonSerialize(const_cast<JsonNode&>(handler.getCurrent()));
-
-	if(!handler.saving)
-		jsonDeserialize(handler.getCurrent());
-}
-
-void MetaString::appendName(const ArtifactID & id)
-{
-	appendTextID(id.toEntity(VLC)->getNameTextID());
-}
-
-void MetaString::appendName(const SpellID & id)
-{
-	appendTextID(id.toEntity(VLC)->getNameTextID());
-}
-
-void MetaString::appendName(const PlayerColor & id)
-{
-	appendTextID(TextIdentifier("vcmi.capitalColors", id.getNum()).get());
-}
-
-void MetaString::appendName(const CreatureID & id, TQuantity count)
-{
-	if(count == 1)
-		appendNameSingular(id);
-	else
-		appendNamePlural(id);
-}
-
-void MetaString::appendNameSingular(const CreatureID & id)
-{
-	appendTextID(id.toEntity(VLC)->getNameSingularTextID());
-}
-
-void MetaString::appendNamePlural(const CreatureID & id)
-{
-	appendTextID(id.toEntity(VLC)->getNamePluralTextID());
-}
-
-void MetaString::replaceName(const ArtifactID & id)
-{
-	replaceTextID(id.toEntity(VLC)->getNameTextID());
-}
-
-void MetaString::replaceName(const MapObjectID& id)
-{
-	replaceTextID(VLC->objtypeh->getObjectName(id, 0));
-}
-
-void MetaString::replaceName(const PlayerColor & id)
-{
-	replaceTextID(TextIdentifier("vcmi.capitalColors", id.getNum()).get());
-}
-
-void MetaString::replaceName(const SecondarySkill & id)
-{
-	replaceTextID(VLC->skillh->getById(id)->getNameTextID());
-}
-
-void MetaString::replaceName(const SpellID & id)
-{
-	replaceTextID(id.toEntity(VLC)->getNameTextID());
-}
-
-void MetaString::replaceName(const GameResID& id)
-{
-	replaceTextID(TextIdentifier("core.restypes", id.getNum()).get());
-}
-
-void MetaString::replaceNameSingular(const CreatureID & id)
-{
-	replaceTextID(id.toEntity(VLC)->getNameSingularTextID());
-}
-
-void MetaString::replaceNamePlural(const CreatureID & id)
-{
-	replaceTextID(id.toEntity(VLC)->getNamePluralTextID());
-}
-
-void MetaString::replaceName(const CreatureID & id, TQuantity count) //adds sing or plural name;
-{
-	if(count == 1)
-		replaceNameSingular(id);
-	else
-		replaceNamePlural(id);
-}
-
-void MetaString::replaceName(const CStackBasicDescriptor & stack)
-{
-	replaceName(stack.type->getId(), stack.count);
-}
-
-VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/MetaString.h vcmi/lib/MetaString.h
--- vcmi-1.5.7/lib/MetaString.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/MetaString.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,141 +0,0 @@
-/*
- * MetaString.h, part of VCMI engine
- *
- * Authors: listed in file AUTHORS in main folder
- *
- * License: GNU General Public License v2.0 or later
- * Full text of license available in license.txt file, in main folder
- *
- */
-#pragma once
-
-VCMI_LIB_NAMESPACE_BEGIN
-
-class JsonNode;
-class ArtifactID;
-class CreatureID;
-class CStackBasicDescriptor;
-class JsonSerializeFormat;
-class MapObjectID;
-class MapObjectSubID;
-class PlayerColor;
-class SecondarySkill;
-class SpellID;
-class GameResID;
-using TQuantity = si32;
-
-/// Strings classes that can be used as replacement in MetaString
-enum class EMetaText : uint8_t
-{
-	GENERAL_TXT = 1,
-	ARRAY_TXT,
-	ADVOB_TXT,
-	JK_TXT
-};
-
-/// Class for string formatting tools that also support transfer over network with localization using language of local install
-/// Can be used to compose resulting text from multiple line segments and with placeholder replacement
-class DLL_LINKAGE MetaString
-{
-private:
-	enum class EMessage : uint8_t
-	{
-		APPEND_RAW_STRING,
-		APPEND_LOCAL_STRING,
-		APPEND_TEXTID_STRING,
-		APPEND_NUMBER,
-		REPLACE_RAW_STRING,
-		REPLACE_LOCAL_STRING,
-		REPLACE_TEXTID_STRING,
-		REPLACE_NUMBER,
-		REPLACE_POSITIVE_NUMBER,
-                APPEND_EOL
-	};
-
-	std::vector<EMessage> message;
-
-	std::vector<std::pair<EMetaText,ui32> > localStrings;
-	std::vector<std::string> exactStrings;
-	std::vector<std::string> stringsTextID;
-	std::vector<int64_t> numbers;
-
-	std::string getLocalString(const std::pair<EMetaText, ui32> & txt) const;
-
-public:
-	/// Creates MetaString and appends provided raw string to it
-	static MetaString createFromRawString(const std::string & value);
-	/// Creates MetaString and appends provided text ID string to it
-	static MetaString createFromTextID(const std::string & value);
-
-	/// Appends local string to resulting string
-	void appendLocalString(EMetaText type, ui32 serial);
-	/// Appends raw string, without translation to resulting string
-	void appendRawString(const std::string & value);
-	/// Appends text ID that will be translated in output
-	void appendTextID(const std::string & value);
-	/// Appends specified number to resulting string
-	void appendNumber(int64_t value);
-
-	void appendName(const ArtifactID& id);
-	void appendName(const SpellID& id);
-	void appendName(const PlayerColor& id);
-	void appendName(const CreatureID & id, TQuantity count);
-	void appendNameSingular(const CreatureID & id);
-	void appendNamePlural(const CreatureID & id);
-	void appendEOL();
-
-	/// Replaces first '%s' placeholder in string with specified local string
-	void replaceLocalString(EMetaText type, ui32 serial);
-	/// Replaces first '%s' placeholder in string with specified fixed, untranslated string
-	void replaceRawString(const std::string & txt);
-	/// Repalces first '%s' placeholder with string ID that will be translated in output
-	void replaceTextID(const std::string & value);
-	/// Replaces first '%d' placeholder in string with specified number
-	void replaceNumber(int64_t txt);
-	/// Replaces first '%+d' placeholder in string with specified number using '+' sign as prefix
-	void replacePositiveNumber(int64_t txt);
-
-	void replaceName(const ArtifactID & id);
-	void replaceName(const MapObjectID& id);
-	void replaceName(const PlayerColor& id);
-	void replaceName(const SecondarySkill& id);
-	void replaceName(const SpellID& id);
-	void replaceName(const GameResID& id);
-
-	/// Replaces first '%s' placeholder with singular or plural name depending on creatures count
-	void replaceName(const CreatureID & id, TQuantity count);
-	void replaceNameSingular(const CreatureID & id);
-	void replaceNamePlural(const CreatureID & id);
-	/// Replaces first '%s' placeholder with singular or plural name depending on creatures count
-	void replaceName(const CStackBasicDescriptor & stack);
-
-	/// erases any existing content in the string
-	void clear();
-
-	///used to handle loot from creature bank
-	std::string buildList() const;
-
-	/// Convert all stored values into a single, user-readable string
-	std::string toString() const;
-
-	/// Returns true if current string is empty
-	bool empty() const;
-
-	bool operator == (const MetaString & other) const;
-
-	void jsonSerialize(JsonNode & dest) const;
-	void jsonDeserialize(const JsonNode & dest);
-	
-	void serializeJson(JsonSerializeFormat & handler);
-
-	template <typename Handler> void serialize(Handler & h)
-	{
-		h & exactStrings;
-		h & localStrings;
-		h & stringsTextID;
-		h & message;
-		h & numbers;
-	}
-};
-
-VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/minizip/ioapi.h vcmi/lib/minizip/ioapi.h
--- vcmi-1.5.7/lib/minizip/ioapi.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/minizip/ioapi.h	2024-12-19 15:00:22.920148847 +0100
@@ -90,7 +90,7 @@
 #include "mz64conf.h"
 #endif
 
-/* a type choosen by DEFINE */
+/* a type chosen by DEFINE */
 #ifdef HAVE_64BIT_INT_CUSTOM
 typedef  64BIT_INT_CUSTOM_TYPE ZPOS64_T;
 #else
diff --color -urN vcmi-1.5.7/lib/minizip/miniunz.c vcmi/lib/minizip/miniunz.c
--- vcmi-1.5.7/lib/minizip/miniunz.c	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/minizip/miniunz.c	2024-12-19 15:00:22.920148847 +0100
@@ -200,7 +200,7 @@
            "  -l  list files\n" \
            "  -d  directory to extract into\n" \
            "  -o  overwrite files without prompting\n" \
-           "  -p  extract crypted file using password\n\n");
+           "  -p  extract encrypted file using password\n\n");
 }
 
 void Display64BitsSize(ZPOS64_T n, int size_char)
@@ -259,7 +259,7 @@
         if (file_info.uncompressed_size>0)
             ratio = (uLong)((file_info.compressed_size*100)/file_info.uncompressed_size);
 
-        /* display a '*' if the file is crypted */
+        /* display a '*' if the file is encrypted */
         if ((file_info.flag & 1) != 0)
             charCrypt='*';
 
diff --color -urN vcmi-1.5.7/lib/minizip/MiniZip64_Changes.txt vcmi/lib/minizip/MiniZip64_Changes.txt
--- vcmi-1.5.7/lib/minizip/MiniZip64_Changes.txt	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/minizip/MiniZip64_Changes.txt	2024-12-19 15:00:22.920148847 +0100
@@ -1,5 +1,5 @@
 
-MiniZip 1.1 was derrived from MiniZip at version 1.01f
+MiniZip 1.1 was derived from MiniZip at version 1.01f
 
 Change in 1.0 (Okt 2009)
  - **TODO - Add history**
diff --color -urN vcmi-1.5.7/lib/minizip/minizip.cbp vcmi/lib/minizip/minizip.cbp
--- vcmi-1.5.7/lib/minizip/minizip.cbp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/minizip/minizip.cbp	1970-01-01 01:00:00.000000000 +0100
@@ -1,86 +0,0 @@
-<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
-<CodeBlocks_project_file>
-	<FileVersion major="1" minor="6" />
-	<Project>
-		<Option title="minizip" />
-		<Option pch_mode="2" />
-		<Option compiler="gcc" />
-		<Build>
-			<Target title="Debug-win32">
-				<Option platforms="Windows;" />
-				<Option output="../../minizip" prefix_auto="1" extension_auto="1" />
-				<Option object_output="../../obj/minizip/Debug/x86" />
-				<Option type="3" />
-				<Option compiler="gcc" />
-				<Option createStaticLib="1" />
-				<Compiler>
-					<Add option="-Wall" />
-					<Add option="-g" />
-					<Add option="-DBUILD_DLL" />
-				</Compiler>
-				<Linker>
-					<Add directory="$(#zlib.lib)" />
-				</Linker>
-			</Target>
-			<Target title="Release-win32">
-				<Option platforms="Windows;" />
-				<Option output="../../minizip" prefix_auto="1" extension_auto="1" />
-				<Option object_output="../../obj/minizip/Release/x86" />
-				<Option type="3" />
-				<Option compiler="gcc" />
-				<Option createStaticLib="1" />
-				<Compiler>
-					<Add option="-O2" />
-					<Add option="-Wall" />
-					<Add option="-DBUILD_DLL" />
-				</Compiler>
-				<Linker>
-					<Add option="-s" />
-					<Add directory="$(#zlib.lib)" />
-				</Linker>
-			</Target>
-			<Target title="Debug-win64">
-				<Option platforms="Windows;" />
-				<Option output="../../minizip" prefix_auto="1" extension_auto="1" />
-				<Option object_output="../../obj/minizip/Debug/x64" />
-				<Option type="3" />
-				<Option compiler="gnu_gcc_compiler_x64" />
-				<Option createStaticLib="1" />
-				<Compiler>
-					<Add option="-Og" />
-					<Add option="-Wall" />
-					<Add option="-g" />
-					<Add option="-DBUILD_DLL" />
-				</Compiler>
-				<Linker>
-					<Add directory="$(#zlib64.lib)" />
-				</Linker>
-			</Target>
-		</Build>
-		<Compiler>
-			<Add option="-Wno-unused-parameter" />
-			<Add directory="$(#zlib.include)" />
-		</Compiler>
-		<Linker>
-			<Add option="-lz" />
-		</Linker>
-		<Unit filename="ioapi.c">
-			<Option compilerVar="CC" />
-		</Unit>
-		<Unit filename="ioapi.h" />
-		<Unit filename="unzip.c">
-			<Option compilerVar="CC" />
-		</Unit>
-		<Unit filename="unzip.h" />
-		<Unit filename="zip.c">
-			<Option compilerVar="CC" />
-		</Unit>
-		<Unit filename="zip.h" />
-		<Extensions>
-			<code_completion />
-			<envvars />
-			<debugger />
-			<lib_finder disable_auto="1" />
-		</Extensions>
-	</Project>
-</CodeBlocks_project_file>
diff --color -urN vcmi-1.5.7/lib/minizip/minizip.vcxproj vcmi/lib/minizip/minizip.vcxproj
--- vcmi-1.5.7/lib/minizip/minizip.vcxproj	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/minizip/minizip.vcxproj	1970-01-01 01:00:00.000000000 +0100
@@ -1,190 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <ItemGroup Label="ProjectConfigurations">
-    <ProjectConfiguration Include="Debug|Win32">
-      <Configuration>Debug</Configuration>
-      <Platform>Win32</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Debug|x64">
-      <Configuration>Debug</Configuration>
-      <Platform>x64</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="RD|Win32">
-      <Configuration>RD</Configuration>
-      <Platform>Win32</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="RD|x64">
-      <Configuration>RD</Configuration>
-      <Platform>x64</Platform>
-    </ProjectConfiguration>
-  </ItemGroup>
-  <ItemGroup>
-    <ClInclude Include="ioapi.h" />
-    <ClInclude Include="unzip.h" />
-    <ClInclude Include="zip.h" />
-  </ItemGroup>
-  <ItemGroup>
-    <ClCompile Include="ioapi.c" />
-    <ClCompile Include="unzip.c" />
-    <ClCompile Include="zip.c" />
-  </ItemGroup>
-  <PropertyGroup Label="Globals">
-    <ProjectGuid>{AA3CC588-9D08-4178-A1E8-C71561E99723}</ProjectGuid>
-    <Keyword>Win32Proj</Keyword>
-    <RootNamespace>minizip</RootNamespace>
-    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
-  </PropertyGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
-    <ConfigurationType>DynamicLibrary</ConfigurationType>
-    <UseDebugLibraries>true</UseDebugLibraries>
-    <PlatformToolset>v142</PlatformToolset>
-    <CharacterSet>Unicode</CharacterSet>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
-    <ConfigurationType>DynamicLibrary</ConfigurationType>
-    <UseDebugLibraries>true</UseDebugLibraries>
-    <PlatformToolset>v142</PlatformToolset>
-    <CharacterSet>Unicode</CharacterSet>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='RD|Win32'" Label="Configuration">
-    <ConfigurationType>DynamicLibrary</ConfigurationType>
-    <UseDebugLibraries>false</UseDebugLibraries>
-    <PlatformToolset>v142</PlatformToolset>
-    <WholeProgramOptimization>true</WholeProgramOptimization>
-    <CharacterSet>Unicode</CharacterSet>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='RD|x64'" Label="Configuration">
-    <ConfigurationType>DynamicLibrary</ConfigurationType>
-    <UseDebugLibraries>false</UseDebugLibraries>
-    <PlatformToolset>v142</PlatformToolset>
-    <WholeProgramOptimization>true</WholeProgramOptimization>
-    <CharacterSet>Unicode</CharacterSet>
-  </PropertyGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
-  <ImportGroup Label="ExtensionSettings">
-  </ImportGroup>
-  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-    <Import Project="..\..\VCMI_global_debug.props" />
-    <Import Project="..\..\VCMI_global.props" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-    <Import Project="..\..\VCMI_global_debug.props" />
-    <Import Project="..\..\VCMI_global.props" />
-  </ImportGroup>
-  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='RD|Win32'">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-    <Import Project="..\..\VCMI_global_release.props" />
-    <Import Project="..\..\VCMI_global.props" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='RD|x64'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-    <Import Project="..\..\VCMI_global_release.props" />
-    <Import Project="..\..\VCMI_global.props" />
-  </ImportGroup>
-  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
-    <Import Project="..\..\VCMI_global_release.props" />
-    <Import Project="..\..\VCMI_global_release.props" />
-    <Import Project="..\..\VCMI_global_release.props" />
-    <Import Project="..\..\VCMI_global.props" />
-  </ImportGroup>
-  <PropertyGroup Label="UserMacros" />
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
-    <LinkIncremental>true</LinkIncremental>
-    <OutDir>$(VCMI_Out)\</OutDir>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
-    <LinkIncremental>true</LinkIncremental>
-    <OutDir>$(VCMI_Out)\</OutDir>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='RD|Win32'">
-    <IncludePath>$(SolutionDir)..\include;$(IncludePath)</IncludePath>
-    <OutDir>..</OutDir>
-    <LibraryPath>$(SolutionDir)..\libs\$(PlatformShortName);$(VCMI_Out);$(LibraryPath)</LibraryPath>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='RD|x64'">
-    <LibraryPath>$(SolutionDir)..\libs\$(PlatformShortName);$(VCMI_Out);$(LibraryPath)</LibraryPath>
-    <IncludePath>$(SolutionDir)..\include;$(IncludePath)</IncludePath>
-    <OutDir>$(VCMI_Out)\</OutDir>
-  </PropertyGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
-    <ClCompile>
-      <PrecompiledHeader>
-      </PrecompiledHeader>
-      <WarningLevel>Level3</WarningLevel>
-      <Optimization>Disabled</Optimization>
-      <PreprocessorDefinitions>MINIZIP_DLL;WIN32;_DEBUG;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <SDLCheck>true</SDLCheck>
-    </ClCompile>
-    <Link>
-      <SubSystem>Windows</SubSystem>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
-      <AdditionalDependencies>zlib.lib;%(AdditionalDependencies)</AdditionalDependencies>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
-    <ClCompile>
-      <PrecompiledHeader>
-      </PrecompiledHeader>
-      <WarningLevel>Level3</WarningLevel>
-      <Optimization>Disabled</Optimization>
-      <PreprocessorDefinitions>MINIZIP_DLL;WIN32;_DEBUG;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <SDLCheck>true</SDLCheck>
-    </ClCompile>
-    <Link>
-      <SubSystem>Windows</SubSystem>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
-      <AdditionalDependencies>zlib.lib;%(AdditionalDependencies)</AdditionalDependencies>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='RD|Win32'">
-    <ClCompile>
-      <WarningLevel>Level3</WarningLevel>
-      <PrecompiledHeader>
-      </PrecompiledHeader>
-      <Optimization>Full</Optimization>
-      <FunctionLevelLinking>
-      </FunctionLevelLinking>
-      <IntrinsicFunctions>true</IntrinsicFunctions>
-      <PreprocessorDefinitions>MINIZIP_DLL;ZLIB_DLL;ZLIB_INTERNAL;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <SDLCheck>true</SDLCheck>
-      <AdditionalIncludeDirectories>F:\Programowanie\VCMI\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <MultiProcessorCompilation>true</MultiProcessorCompilation>
-    </ClCompile>
-    <Link>
-      <SubSystem>Windows</SubSystem>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
-      <EnableCOMDATFolding>true</EnableCOMDATFolding>
-      <OptimizeReferences>true</OptimizeReferences>
-      <AdditionalLibraryDirectories>..\..\libs;..\..</AdditionalLibraryDirectories>
-      <AdditionalDependencies>zlib.lib;%(AdditionalDependencies)</AdditionalDependencies>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='RD|x64'">
-    <ClCompile>
-      <WarningLevel>Level3</WarningLevel>
-      <PrecompiledHeader>
-      </PrecompiledHeader>
-      <Optimization>Full</Optimization>
-      <FunctionLevelLinking>
-      </FunctionLevelLinking>
-      <IntrinsicFunctions>true</IntrinsicFunctions>
-      <PreprocessorDefinitions>MINIZIP_DLL;ZLIB_DLL;ZLIB_INTERNAL;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <SDLCheck>true</SDLCheck>
-      <AdditionalIncludeDirectories>F:\Programowanie\VCMI\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-    </ClCompile>
-    <Link>
-      <SubSystem>Windows</SubSystem>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
-      <EnableCOMDATFolding>true</EnableCOMDATFolding>
-      <OptimizeReferences>true</OptimizeReferences>
-      <AdditionalLibraryDirectories>..\..\libs;..\..</AdditionalLibraryDirectories>
-      <AdditionalDependencies>zlib.lib;%(AdditionalDependencies)</AdditionalDependencies>
-    </Link>
-  </ItemDefinitionGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
-  <ImportGroup Label="ExtensionTargets">
-  </ImportGroup>
-</Project>
\ No newline at end of file
diff --color -urN vcmi-1.5.7/lib/minizip/minizip.vcxproj.filters vcmi/lib/minizip/minizip.vcxproj.filters
--- vcmi-1.5.7/lib/minizip/minizip.vcxproj.filters	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/minizip/minizip.vcxproj.filters	1970-01-01 01:00:00.000000000 +0100
@@ -1,39 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <ItemGroup>
-    <Filter Include="Source Files">
-      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
-      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
-    </Filter>
-    <Filter Include="Header Files">
-      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
-      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
-    </Filter>
-    <Filter Include="Resource Files">
-      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
-      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
-    </Filter>
-  </ItemGroup>
-  <ItemGroup>
-    <ClInclude Include="unzip.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="zip.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="ioapi.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-  </ItemGroup>
-  <ItemGroup>
-    <ClCompile Include="zip.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="ioapi.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="unzip.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-  </ItemGroup>
-</Project>
\ No newline at end of file
diff --color -urN vcmi-1.5.7/lib/minizip/unzip.c vcmi/lib/minizip/unzip.c
--- vcmi-1.5.7/lib/minizip/unzip.c	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/minizip/unzip.c	2024-12-19 15:00:22.921148888 +0100
@@ -53,8 +53,8 @@
   Oct-2009 - Mathias Svensson - Fixed problem if uncompressed size was > 4G and compressed size was <4G
                                 should only read the compressed/uncompressed size from the Zip64 format if
                                 the size from normal header was 0xFFFFFFFF
-  Oct-2009 - Mathias Svensson - Applied some bug fixes from paches recived from Gilles Vollant
-        Oct-2009 - Mathias Svensson - Applied support to unzip files with compression mathod BZIP2 (bzip2 lib is required)
+  Oct-2009 - Mathias Svensson - Applied some bug fixes from patches received from Gilles Vollant
+        Oct-2009 - Mathias Svensson - Applied support to unzip files with compression method BZIP2 (bzip2 lib is required)
                                 Patch created by Daniel Borca
 
   Jan-2010 - back to unzip and minizip 1.0 name scheme, with compatibility layer
@@ -153,7 +153,7 @@
     ZPOS64_T rest_read_compressed; /* number of byte to be decompressed */
     ZPOS64_T rest_read_uncompressed;/*number of byte to be obtained after decomp*/
     zlib_filefunc64_32_def z_filefunc;
-    voidpf filestream;        /* io structore of the zipfile */
+    voidpf filestream;        /* io structure of the zipfile */
     uLong compression_method;   /* compression method (0==store) */
     ZPOS64_T byte_before_the_zipfile;/* byte before the zipfile, (>0 for sfx)*/
     int   raw;
@@ -166,7 +166,7 @@
 {
     zlib_filefunc64_32_def z_filefunc;
     int is64bitOpenFunction;
-    voidpf filestream;        /* io structore of the zipfile */
+    voidpf filestream;        /* io structure of the zipfile */
     unz_global_info64 gi;       /* public global information */
     ZPOS64_T byte_before_the_zipfile;/* byte before the zipfile, (>0 for sfx)*/
     ZPOS64_T num_file;             /* number of the current file in the zipfile*/
@@ -200,7 +200,7 @@
 /* ===========================================================================
      Read a byte from a gz_stream; update next_in and avail_in. Return EOF
    for end of file.
-   IN assertion: the stream s has been sucessfully opened for reading.
+   IN assertion: the stream s has been successfully opened for reading.
 */
 
 
@@ -380,10 +380,10 @@
 
 /*
    Compare two filename (fileName1,fileName2).
-   If iCaseSenisivity = 1, comparision is case sensitivity (like strcmp)
-   If iCaseSenisivity = 2, comparision is not case sensitivity (like strcmpi
+   If iCaseSenisivity = 1, comparison is case sensitivity (like strcmp)
+   If iCaseSenisivity = 2, comparison is not case sensitivity (like strcmpi
                                                                 or strcasecmp)
-   If iCaseSenisivity = 0, case sensitivity is defaut of your operating system
+   If iCaseSenisivity = 0, case sensitivity is default of your operating system
         (like 1 on Unix, 2 on Windows)
 
 */
@@ -591,9 +591,9 @@
     uLong   uL;
 
     uLong number_disk;          /* number of the current dist, used for
-                                   spaning ZIP, unsupported, always 0*/
+                                   spanning ZIP, unsupported, always 0*/
     uLong number_disk_with_CD;  /* number the the disk with central dir, used
-                                   for spaning ZIP, unsupported, always 0*/
+                                   for spanning ZIP, unsupported, always 0*/
     ZPOS64_T number_entry_CD;      /* total number of entries in
                                    the central dir
                                    (same than number_entry on nospan) */
@@ -847,7 +847,7 @@
     return UNZ_OK;
 }
 /*
-   Translate date/time from Dos format to tm_unz (readable more easilty)
+   Translate date/time from Dos format to tm_unz (readable more easily)
 */
 local void unz64local_DosDateToTmuDate (ZPOS64_T ulDosDate, tm_unz* ptm)
 {
diff --color -urN vcmi-1.5.7/lib/minizip/unzip.h vcmi/lib/minizip/unzip.h
--- vcmi-1.5.7/lib/minizip/unzip.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/minizip/unzip.h	2024-12-19 15:00:22.921148888 +0100
@@ -155,10 +155,10 @@
                                                  int iCaseSensitivity));
 /*
    Compare two filename (fileName1,fileName2).
-   If iCaseSenisivity = 1, comparision is case sensitivity (like strcmp)
-   If iCaseSenisivity = 2, comparision is not case sensitivity (like strcmpi
+   If iCaseSenisivity = 1, comparison is case sensitivity (like strcmp)
+   If iCaseSenisivity = 2, comparison is not case sensitivity (like strcmpi
                                 or strcasecmp)
-   If iCaseSenisivity = 0, case sensitivity is defaut of your operating system
+   If iCaseSenisivity = 0, case sensitivity is default of your operating system
     (like 1 on Unix, 2 on Windows)
 */
 
diff --color -urN vcmi-1.5.7/lib/minizip/zip.c vcmi/lib/minizip/zip.c
--- vcmi-1.5.7/lib/minizip/zip.c	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/minizip/zip.c	2024-12-19 15:00:22.922148929 +0100
@@ -14,8 +14,8 @@
    Oct-2009 - Mathias Svensson - Added Zip64 Support when creating new file archives
    Oct-2009 - Mathias Svensson - Did some code cleanup and refactoring to get better overview of some functions.
    Oct-2009 - Mathias Svensson - Added zipRemoveExtraInfoBlock to strip extra field data from its ZIP64 data
-                                 It is used when recreting zip archive with RAW when deleting items from a zip.
-                                 ZIP64 data is automaticly added to items that needs it, and existing ZIP64 data need to be removed.
+                                 It is used when recreating zip archive with RAW when deleting items from a zip.
+                                 ZIP64 data is automatically added to items that needs it, and existing ZIP64 data need to be removed.
    Oct-2009 - Mathias Svensson - Added support for BZIP2 as compression mode (bzip2 lib is required)
    Jan-2010 - back to unzip and minizip 1.0 name scheme, with compatibility layer
 
@@ -52,7 +52,7 @@
 /* compile with -Dlocal if your debugger can't find static symbols */
 
 #ifndef VERSIONMADEBY
-# define VERSIONMADEBY   (0x0) /* platform depedent */
+# define VERSIONMADEBY   (0x0) /* platform dependent */
 #endif
 
 #ifndef Z_BUFSIZE
@@ -121,7 +121,7 @@
   struct linkedlist_datablock_internal_s* next_datablock;
   uLong  avail_in_this_block;
   uLong  filled_in_this_block;
-  uLong  unused; /* for future use and alignement */
+  uLong  unused; /* for future use and alignment */
   unsigned char data[SIZEDATA_INDATABLOCK];
 } linkedlist_datablock_internal;
 
@@ -143,20 +143,20 @@
     uInt pos_in_buffered_data;  /* last written byte in buffered_data */
 
     ZPOS64_T pos_local_header;     /* offset of the local header of the file
-                                     currenty writing */
+                                     currently writing */
     char* central_header;       /* central header data for the current file */
     uLong size_centralExtra;
     uLong size_centralheader;   /* size of the central header for cur file */
     uLong size_centralExtraFree; /* Extra bytes allocated to the centralheader but that are not used */
     uLong flag;                 /* flag of the file currently writing */
 
-    int  method;                /* compression method of file currenty wr.*/
+    int  method;                /* compression method of file currently wr.*/
     int  raw;                   /* 1 for directly writing raw data */
     Byte buffered_data[Z_BUFSIZE];/* buffer contain compressed data to be writ*/
     uLong dosDate;
     uLong crc32;
     int  encrypt;
-    int  zip64;               /* Add ZIP64 extened information in the extra field */
+    int  zip64;               /* Add ZIP64 extended information in the extra field */
     ZPOS64_T pos_zip64extrainfo;
     ZPOS64_T totalCompressedData;
     ZPOS64_T totalUncompressedData;
@@ -170,13 +170,13 @@
 typedef struct
 {
     zlib_filefunc64_32_def z_filefunc;
-    voidpf filestream;        /* io structore of the zipfile */
+    voidpf filestream;        /* io structure of the zipfile */
     linkedlist_data central_dir;/* datablock with central dir in construction*/
     int  in_opened_file_inzip;  /* 1 if a file in the zip is currently writ.*/
-    curfile64_info ci;            /* info on the file curretly writing */
+    curfile64_info ci;            /* info on the file currently writing */
 
     ZPOS64_T begin_pos;            /* position of the beginning of the zipfile */
-    ZPOS64_T add_position_when_writting_offset;
+    ZPOS64_T add_position_when_writing_offset;
     ZPOS64_T number_entry;
 
 #ifndef NO_ADDFILEINEXISTINGZIP
@@ -653,9 +653,9 @@
   uLong uL;
 
   uLong number_disk;          /* number of the current dist, used for
-                              spaning ZIP, unsupported, always 0*/
+                              spanning ZIP, unsupported, always 0*/
   uLong number_disk_with_CD;  /* number the the disk with central dir, used
-                              for spaning ZIP, unsupported, always 0*/
+                              for spanning ZIP, unsupported, always 0*/
   ZPOS64_T number_entry;
   ZPOS64_T number_entry_CD;      /* total number of entries in
                                 the central dir
@@ -812,7 +812,7 @@
   }
 
   byte_before_the_zipfile = central_pos - (offset_central_dir+size_central_dir);
-  pziinit->add_position_when_writting_offset = byte_before_the_zipfile;
+  pziinit->add_position_when_writing_offset = byte_before_the_zipfile;
 
   {
     ZPOS64_T size_central_dir_to_read = size_central_dir;
@@ -880,7 +880,7 @@
     ziinit.in_opened_file_inzip = 0;
     ziinit.ci.stream_initialised = 0;
     ziinit.number_entry = 0;
-    ziinit.add_position_when_writting_offset = 0;
+    ziinit.add_position_when_writing_offset = 0;
     init_linkedlist(&(ziinit.central_dir));
 
 
@@ -1169,7 +1169,7 @@
     if(zi->ci.pos_local_header >= 0xffffffff)
       zip64local_putValue_inmemory(zi->ci.central_header+42,(uLong)0xffffffff,4);
     else
-      zip64local_putValue_inmemory(zi->ci.central_header+42,(uLong)zi->ci.pos_local_header - zi->add_position_when_writting_offset,4);
+      zip64local_putValue_inmemory(zi->ci.central_header+42,(uLong)zi->ci.pos_local_header - zi->add_position_when_writing_offset,4);
 
     for (i=0;i<size_filename;i++)
         *(zi->ci.central_header+SIZECENTRALHEADER+i) = *(filename+i);
@@ -1760,7 +1760,7 @@
 int Write_Zip64EndOfCentralDirectoryLocator(zip64_internal* zi, ZPOS64_T zip64eocd_pos_inzip)
 {
   int err = ZIP_OK;
-  ZPOS64_T pos = zip64eocd_pos_inzip - zi->add_position_when_writting_offset;
+  ZPOS64_T pos = zip64eocd_pos_inzip - zi->add_position_when_writing_offset;
 
   err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)ZIP64ENDLOCHEADERMAGIC,4);
 
@@ -1813,7 +1813,7 @@
 
   if (err==ZIP_OK) /* offset of start of central directory with respect to the starting disk number */
   {
-    ZPOS64_T pos = centraldir_pos_inzip - zi->add_position_when_writting_offset;
+    ZPOS64_T pos = centraldir_pos_inzip - zi->add_position_when_writing_offset;
     err = zip64local_putValue(&zi->z_filefunc,zi->filestream, (ZPOS64_T)pos,8);
   }
   return err;
@@ -1854,13 +1854,13 @@
 
   if (err==ZIP_OK) /* offset of start of central directory with respect to the starting disk number */
   {
-    ZPOS64_T pos = centraldir_pos_inzip - zi->add_position_when_writting_offset;
+    ZPOS64_T pos = centraldir_pos_inzip - zi->add_position_when_writing_offset;
     if(pos >= 0xffffffff)
     {
       err = zip64local_putValue(&zi->z_filefunc,zi->filestream, (uLong)0xffffffff,4);
     }
     else
-      err = zip64local_putValue(&zi->z_filefunc,zi->filestream, (uLong)(centraldir_pos_inzip - zi->add_position_when_writting_offset),4);
+      err = zip64local_putValue(&zi->z_filefunc,zi->filestream, (uLong)(centraldir_pos_inzip - zi->add_position_when_writing_offset),4);
   }
 
    return err;
@@ -1926,7 +1926,7 @@
     }
     free_linkedlist(&(zi->central_dir));
 
-    pos = centraldir_pos_inzip - zi->add_position_when_writting_offset;
+    pos = centraldir_pos_inzip - zi->add_position_when_writing_offset;
     if(pos >= 0xffffffff || zi->number_entry > 0xFFFF)
     {
       ZPOS64_T Zip64EOCDpos = ZTELL64(zi->z_filefunc,zi->filestream);
diff --color -urN vcmi-1.5.7/lib/minizip/zip.h vcmi/lib/minizip/zip.h
--- vcmi-1.5.7/lib/minizip/zip.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/minizip/zip.h	2024-12-19 15:00:22.922148929 +0100
@@ -131,7 +131,7 @@
 
 /* Note : there is no delete function into a zipfile.
    If you want delete file into a zipfile, you must open a zipfile, and create another
-   Of couse, you can use RAW reading and writing to copy the file you did not want delte
+   Of couse, you can use RAW reading and writing to copy the file you did not want delete
 */
 
 extern zipFile MINIZIP_EXPORT zipOpen2 OF((const char *pathname,
diff --color -urN vcmi-1.5.7/lib/modding/ActiveModsInSaveList.cpp vcmi/lib/modding/ActiveModsInSaveList.cpp
--- vcmi-1.5.7/lib/modding/ActiveModsInSaveList.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/modding/ActiveModsInSaveList.cpp	2024-12-19 15:00:22.922148929 +0100
@@ -11,7 +11,7 @@
 #include "ActiveModsInSaveList.h"
 
 #include "../VCMI_Lib.h"
-#include "CModInfo.h"
+#include "ModDescription.h"
 #include "CModHandler.h"
 #include "ModIncompatibility.h"
 
@@ -21,13 +21,13 @@
 {
 	std::vector<TModID> result;
 	for (auto const & entry : VLC->modh->getActiveMods())
-		if (VLC->modh->getModInfo(entry).checkModGameplayAffecting())
+		if (VLC->modh->getModInfo(entry).affectsGameplay())
 			result.push_back(entry);
 
 	return result;
 }
 
-const ModVerificationInfo & ActiveModsInSaveList::getVerificationInfo(TModID mod)
+ModVerificationInfo ActiveModsInSaveList::getVerificationInfo(TModID mod)
 {
 	return VLC->modh->getModInfo(mod).getVerificationInfo();
 }
@@ -44,10 +44,10 @@
 			missingMods.push_back(modList.at(compared.first).name);
 
 		if (compared.second == ModVerificationStatus::DISABLED)
-			missingMods.push_back(VLC->modh->getModInfo(compared.first).getVerificationInfo().name);
+			missingMods.push_back(VLC->modh->getModInfo(compared.first).getName());
 
 		if (compared.second == ModVerificationStatus::EXCESSIVE)
-			excessiveMods.push_back(VLC->modh->getModInfo(compared.first).getVerificationInfo().name);
+			excessiveMods.push_back(VLC->modh->getModInfo(compared.first).getName());
 	}
 
 	if(!missingMods.empty() || !excessiveMods.empty())
diff --color -urN vcmi-1.5.7/lib/modding/ActiveModsInSaveList.h vcmi/lib/modding/ActiveModsInSaveList.h
--- vcmi-1.5.7/lib/modding/ActiveModsInSaveList.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/modding/ActiveModsInSaveList.h	2024-12-19 15:00:22.922148929 +0100
@@ -17,7 +17,7 @@
 class ActiveModsInSaveList
 {
 	std::vector<TModID> getActiveGameplayAffectingMods();
-	const ModVerificationInfo & getVerificationInfo(TModID mod);
+	ModVerificationInfo getVerificationInfo(TModID mod);
 
 	/// Checks whether provided mod list is compatible with current VLC and throws on failure
 	void verifyActiveMods(const std::map<TModID, ModVerificationInfo> & modList);
@@ -29,7 +29,10 @@
 			std::vector<TModID> activeMods = getActiveGameplayAffectingMods();
 			h & activeMods;
 			for(const auto & m : activeMods)
-				h & getVerificationInfo(m);
+			{
+				ModVerificationInfo info = getVerificationInfo(m);
+				h & info;
+			}
 		}
 		else
 		{
diff --color -urN vcmi-1.5.7/lib/modding/CModHandler.cpp vcmi/lib/modding/CModHandler.cpp
--- vcmi-1.5.7/lib/modding/CModHandler.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/modding/CModHandler.cpp	2024-12-19 15:00:22.922148929 +0100
@@ -10,266 +10,45 @@
 #include "StdInc.h"
 #include "CModHandler.h"
 
-#include "CModInfo.h"
-#include "ModScope.h"
 #include "ContentTypeHandler.h"
 #include "IdentifierStorage.h"
-#include "ModIncompatibility.h"
+#include "ModDescription.h"
+#include "ModManager.h"
+#include "ModScope.h"
 
+#include "../CConfigHandler.h"
 #include "../CCreatureHandler.h"
-#include "../CGeneralTextHandler.h"
-#include "../CStopWatch.h"
 #include "../GameSettings.h"
-#include "../Languages.h"
-#include "../MetaString.h"
 #include "../ScriptHandler.h"
-#include "../constants/StringConstants.h"
+#include "../VCMI_Lib.h"
 #include "../filesystem/Filesystem.h"
 #include "../json/JsonUtils.h"
-#include "../spells/CSpellHandler.h"
+#include "../texts/CGeneralTextHandler.h"
+#include "../texts/Languages.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
-static JsonNode loadModSettings(const JsonPath & path)
-{
-	if (CResourceHandler::get("local")->existsResource(ResourcePath(path)))
-	{
-		return JsonNode(path);
-	}
-	// Probably new install. Create initial configuration
-	CResourceHandler::get("local")->createResource(path.getOriginalName() + ".json");
-	return JsonNode();
-}
-
 CModHandler::CModHandler()
 	: content(std::make_shared<CContentHandler>())
-	, coreMod(std::make_unique<CModInfo>())
+	, modManager(std::make_unique<ModManager>())
 {
 }
 
 CModHandler::~CModHandler() = default;
 
-// currentList is passed by value to get current list of depending mods
-bool CModHandler::hasCircularDependency(const TModID & modID, std::set<TModID> currentList) const
-{
-	const CModInfo & mod = allMods.at(modID);
-
-	// Mod already present? We found a loop
-	if (vstd::contains(currentList, modID))
-	{
-		logMod->error("Error: Circular dependency detected! Printing dependency list:");
-		logMod->error("\t%s -> ", mod.getVerificationInfo().name);
-		return true;
-	}
-
-	currentList.insert(modID);
-
-	// recursively check every dependency of this mod
-	for(const TModID & dependency : mod.dependencies)
-	{
-		if (hasCircularDependency(dependency, currentList))
-		{
-			logMod->error("\t%s ->\n", mod.getVerificationInfo().name); // conflict detected, print dependency list
-			return true;
-		}
-	}
-	return false;
-}
-
-// Returned vector affects the resource loaders call order (see CFilesystemList::load).
-// The loaders call order matters when dependent mod overrides resources in its dependencies.
-std::vector <TModID> CModHandler::validateAndSortDependencies(std::vector <TModID> modsToResolve) const
-{
-	// Topological sort algorithm.
-	// TODO: Investigate possible ways to improve performance.
-	boost::range::sort(modsToResolve); // Sort mods per name
-	std::vector <TModID> sortedValidMods; // Vector keeps order of elements (LIFO)
-	sortedValidMods.reserve(modsToResolve.size()); // push_back calls won't cause memory reallocation
-	std::set <TModID> resolvedModIDs; // Use a set for validation for performance reason, but set does not keep order of elements
-
-	// Mod is resolved if it has not dependencies or all its dependencies are already resolved
-	auto isResolved = [&](const CModInfo & mod) -> bool
-	{
-		if(mod.dependencies.size() > resolvedModIDs.size())
-			return false;
-
-		for(const TModID & dependency : mod.dependencies)
-		{
-			if(!vstd::contains(resolvedModIDs, dependency))
-				return false;
-		}
-
-		for(const TModID & conflict : mod.conflicts)
-		{
-			if(vstd::contains(resolvedModIDs, conflict))
-				return false;
-		}
-		for(const TModID & reverseConflict : resolvedModIDs)
-		{
-			if (vstd::contains(allMods.at(reverseConflict).conflicts, mod.identifier))
-				return false;
-		}
-		return true;
-	};
-
-	while(true)
-	{
-		std::set <TModID> resolvedOnCurrentTreeLevel;
-		for(auto it = modsToResolve.begin(); it != modsToResolve.end();) // One iteration - one level of mods tree
-		{
-			if(isResolved(allMods.at(*it)))
-			{
-				resolvedOnCurrentTreeLevel.insert(*it); // Not to the resolvedModIDs, so current node childs will be resolved on the next iteration
-				sortedValidMods.push_back(*it);
-				it = modsToResolve.erase(it);
-				continue;
-			}
-			it++;
-		}
-		if(!resolvedOnCurrentTreeLevel.empty())
-		{
-			resolvedModIDs.insert(resolvedOnCurrentTreeLevel.begin(), resolvedOnCurrentTreeLevel.end());
-					continue;
-		}
-		// If there're no valid mods on the current mods tree level, no more mod can be resolved, should be end.
-		break;
-	}
-
-	modLoadErrors = std::make_unique<MetaString>();
-
-	auto addErrorMessage = [this](const std::string & textID, const std::string & brokenModID, const std::string & missingModID)
-	{
-		modLoadErrors->appendTextID(textID);
-
-		if (allMods.count(brokenModID))
-			modLoadErrors->replaceRawString(allMods.at(brokenModID).getVerificationInfo().name);
-		else
-			modLoadErrors->replaceRawString(brokenModID);
-
-		if (allMods.count(missingModID))
-			modLoadErrors->replaceRawString(allMods.at(missingModID).getVerificationInfo().name);
-		else
-			modLoadErrors->replaceRawString(missingModID);
-
-	};
-
-	// Left mods have unresolved dependencies, output all to log.
-	for(const auto & brokenModID : modsToResolve)
-	{
-		const CModInfo & brokenMod = allMods.at(brokenModID);
-		for(const TModID & dependency : brokenMod.dependencies)
-		{
-			if(!vstd::contains(resolvedModIDs, dependency) && brokenMod.config["modType"].String() != "Compatibility")
-				addErrorMessage("vcmi.server.errors.modNoDependency", brokenModID, dependency);
-		}
-		for(const TModID & conflict : brokenMod.conflicts)
-		{
-			if(vstd::contains(resolvedModIDs, conflict))
-				addErrorMessage("vcmi.server.errors.modConflict", brokenModID, conflict);
-		}
-		for(const TModID & reverseConflict : resolvedModIDs)
-		{
-			if (vstd::contains(allMods.at(reverseConflict).conflicts, brokenModID))
-				addErrorMessage("vcmi.server.errors.modConflict", brokenModID, reverseConflict);
-		}
-	}
-	return sortedValidMods;
-}
-
-std::vector<std::string> CModHandler::getModList(const std::string & path) const
-{
-	std::string modDir = boost::to_upper_copy(path + "MODS/");
-	size_t depth = boost::range::count(modDir, '/');
-
-	auto list = CResourceHandler::get("initial")->getFilteredFiles([&](const ResourcePath & id) ->  bool
-	{
-		if (id.getType() != EResType::DIRECTORY)
-			return false;
-		if (!boost::algorithm::starts_with(id.getName(), modDir))
-			return false;
-		if (boost::range::count(id.getName(), '/') != depth )
-			return false;
-		return true;
-	});
-
-	//storage for found mods
-	std::vector<std::string> foundMods;
-	for(const auto & entry : list)
-	{
-		std::string name = entry.getName();
-		name.erase(0, modDir.size()); //Remove path prefix
-
-		if (!name.empty())
-			foundMods.push_back(name);
-	}
-	return foundMods;
-}
-
-
-
-void CModHandler::loadMods(const std::string & path, const std::string & parent, const JsonNode & modSettings, bool enableMods)
-{
-	for(const std::string & modName : getModList(path))
-		loadOneMod(modName, parent, modSettings, enableMods);
-}
-
-void CModHandler::loadOneMod(std::string modName, const std::string & parent, const JsonNode & modSettings, bool enableMods)
-{
-	boost::to_lower(modName);
-	std::string modFullName = parent.empty() ? modName : parent + '.' + modName;
-
-	if ( ModScope::isScopeReserved(modFullName))
-	{
-		logMod->error("Can not load mod %s - this name is reserved for internal use!", modFullName);
-		return;
-	}
-
-	if(CResourceHandler::get("initial")->existsResource(CModInfo::getModFile(modFullName)))
-	{
-		CModInfo mod(modFullName, modSettings[modName], JsonNode(CModInfo::getModFile(modFullName)));
-		if (!parent.empty()) // this is submod, add parent to dependencies
-			mod.dependencies.insert(parent);
-
-		allMods[modFullName] = mod;
-		if (mod.isEnabled() && enableMods)
-			activeMods.push_back(modFullName);
-
-		loadMods(CModInfo::getModDir(modFullName) + '/', modFullName, modSettings[modName]["mods"], enableMods && mod.isEnabled());
-	}
-}
-
-void CModHandler::loadMods()
-{
-	JsonNode modConfig;
-
-	modConfig = loadModSettings(JsonPath::builtin("config/modSettings.json"));
-	loadMods("", "", modConfig["activeMods"], true);
-
-	coreMod = std::make_unique<CModInfo>(ModScope::scopeBuiltin(), modConfig[ModScope::scopeBuiltin()], JsonNode(JsonPath::builtin("config/gameConfig.json")));
-}
-
 std::vector<std::string> CModHandler::getAllMods() const
 {
-	std::vector<std::string> modlist;
-	modlist.reserve(allMods.size());
-	for (auto & entry : allMods)
-		modlist.push_back(entry.first);
-	return modlist;
+	return modManager->getAllMods();
 }
 
-std::vector<std::string> CModHandler::getActiveMods() const
+const std::vector<std::string> & CModHandler::getActiveMods() const
 {
-	return activeMods;
+	return modManager->getActiveMods();
 }
 
-std::string CModHandler::getModLoadErrors() const
+const ModDescription & CModHandler::getModInfo(const TModID & modId) const
 {
-	return modLoadErrors->toString();
-}
-
-const CModInfo & CModHandler::getModInfo(const TModID & modId) const
-{
-	return allMods.at(modId);
+	return modManager->getModDescription(modId);
 }
 
 static JsonNode genDefaultFS()
@@ -284,57 +63,69 @@
 	return defaultFS;
 }
 
+static std::string getModDirectory(const TModID & modName)
+{
+	std::string result = modName;
+	boost::to_upper(result);
+	boost::algorithm::replace_all(result, ".", "/MODS/");
+	return "MODS/" + result;
+}
+
 static ISimpleResourceLoader * genModFilesystem(const std::string & modName, const JsonNode & conf)
 {
 	static const JsonNode defaultFS = genDefaultFS();
 
-	if (!conf["filesystem"].isNull())
-		return CResourceHandler::createFileSystem(CModInfo::getModDir(modName), conf["filesystem"]);
+	if (!conf.isNull())
+		return CResourceHandler::createFileSystem(getModDirectory(modName), conf);
 	else
-		return CResourceHandler::createFileSystem(CModInfo::getModDir(modName), defaultFS);
+		return CResourceHandler::createFileSystem(getModDirectory(modName), defaultFS);
 }
 
-static ui32 calculateModChecksum(const std::string & modName, ISimpleResourceLoader * filesystem)
+void CModHandler::loadModFilesystems()
 {
-	boost::crc_32_type modChecksum;
-	// first - add current VCMI version into checksum to force re-validation on VCMI updates
-	modChecksum.process_bytes(reinterpret_cast<const void*>(GameConstants::VCMI_VERSION.data()), GameConstants::VCMI_VERSION.size());
+	CGeneralTextHandler::detectInstallParameters();
 
-	// second - add mod.json into checksum because filesystem does not contains this file
-	// FIXME: remove workaround for core mod
-	if (modName != ModScope::scopeBuiltin())
-	{
-		auto modConfFile = CModInfo::getModFile(modName);
-		ui32 configChecksum = CResourceHandler::get("initial")->load(modConfFile)->calculateCRC32();
-		modChecksum.process_bytes(reinterpret_cast<const void *>(&configChecksum), sizeof(configChecksum));
-	}
-	// third - add all detected text files from this mod into checksum
-	auto files = filesystem->getFilteredFiles([](const ResourcePath & resID)
-	{
-		return (resID.getType() == EResType::TEXT || resID.getType() == EResType::JSON) &&
-			   ( boost::starts_with(resID.getName(), "DATA") || boost::starts_with(resID.getName(), "CONFIG"));
-	});
+	const auto & activeMods = modManager->getActiveMods();
 
-	for (const ResourcePath & file : files)
-	{
-		ui32 fileChecksum = filesystem->load(file)->calculateCRC32();
-		modChecksum.process_bytes(reinterpret_cast<const void *>(&fileChecksum), sizeof(fileChecksum));
-	}
-	return modChecksum.checksum();
+	std::map<TModID, ISimpleResourceLoader *> modFilesystems;
+
+	for(const TModID & modName : activeMods)
+		modFilesystems[modName] = genModFilesystem(modName, getModInfo(modName).getFilesystemConfig());
+
+	for(const TModID & modName : activeMods)
+		if (modName != "core") // virtual mod 'core' has no filesystem on its own - shared with base install
+			CResourceHandler::addFilesystem("data", modName, modFilesystems[modName]);
+
+	if (settings["mods"]["validation"].String() == "full")
+		checkModFilesystemsConflicts(modFilesystems);
 }
 
-void CModHandler::loadModFilesystems()
+void CModHandler::checkModFilesystemsConflicts(const std::map<TModID, ISimpleResourceLoader *> & modFilesystems)
 {
-	CGeneralTextHandler::detectInstallParameters();
+	for(const auto & [leftName, leftFilesystem] : modFilesystems)
+	{
+		for(const auto & [rightName, rightFilesystem] : modFilesystems)
+		{
+			if (leftName == rightName)
+				continue;
 
-	activeMods = validateAndSortDependencies(activeMods);
+			if (getModDependencies(leftName).count(rightName) || getModDependencies(rightName).count(leftName))
+				continue;
 
-	coreMod->updateChecksum(calculateModChecksum(ModScope::scopeBuiltin(), CResourceHandler::get(ModScope::scopeBuiltin())));
+			if (getModSoftDependencies(leftName).count(rightName) || getModSoftDependencies(rightName).count(leftName))
+				continue;
 
-	for(std::string & modName : activeMods)
-	{
-		CModInfo & mod = allMods[modName];
-		CResourceHandler::addFilesystem("data", modName, genModFilesystem(modName, mod.config));
+			const auto & filter = [](const ResourcePath &path){return path.getType() != EResType::DIRECTORY && path.getType() != EResType::JSON;};
+
+			std::unordered_set<ResourcePath> leftResources = leftFilesystem->getFilteredFiles(filter);
+			std::unordered_set<ResourcePath> rightResources = rightFilesystem->getFilteredFiles(filter);
+
+			for (auto const & leftFile : leftResources)
+			{
+				if (rightResources.count(leftFile))
+					logMod->warn("Potential confict detected between '%s' and '%s': both mods add file '%s'", leftName, rightName, leftFile.getOriginalName());
+			}
+		}
 	}
 }
 
@@ -342,7 +133,8 @@
 {
 	try
 	{
-		for(const auto & modID : boost::adaptors::reverse(activeMods))
+		auto activeMode = modManager->getActiveMods();
+		for(const auto & modID : boost::adaptors::reverse(activeMode))
 		{
 			if(CResourceHandler::get(modID)->existsResource(name))
 				return modID;
@@ -361,115 +153,140 @@
 	throw std::runtime_error("Resource with name " + name.getName() + " and type " + EResTypeHelper::getEResTypeAsString(name.getType()) + " wasn't found.");
 }
 
+std::string CModHandler::findResourceLanguage(const ResourcePath & name) const
+{
+	std::string modName = findResourceOrigin(name);
+	std::string modLanguage = getModLanguage(modName);
+	return modLanguage;
+}
+
+std::string CModHandler::findResourceEncoding(const ResourcePath & resource) const
+{
+	std::string modName = findResourceOrigin(resource);
+	std::string modLanguage = findResourceLanguage(resource);
+
+	bool potentiallyUserMadeContent = resource.getType() == EResType::MAP || resource.getType() == EResType::CAMPAIGN;
+	if (potentiallyUserMadeContent && modName == ModScope::scopeBuiltin() && modLanguage == "english")
+	{
+		// this might be a map or campaign that player downloaded manually and placed in Maps/ directory
+		// in this case, this file may be in user-preferred language, and not in same language as the rest of H3 data
+		// however at the moment we have no way to detect that for sure - file can be either in English or in user-preferred language
+		// but since all known H3 encodings (Win125X or GBK) are supersets of ASCII, we can safely load English data using encoding of user-preferred language
+		std::string preferredLanguage = VLC->generaltexth->getPreferredLanguage();
+		std::string fileEncoding = Languages::getLanguageOptions(preferredLanguage).encoding;
+		return fileEncoding;
+	}
+	else
+	{
+		std::string fileEncoding = Languages::getLanguageOptions(modLanguage).encoding;
+		return fileEncoding;
+	}
+}
+
 std::string CModHandler::getModLanguage(const TModID& modId) const
 {
 	if(modId == "core")
 		return VLC->generaltexth->getInstalledLanguage();
 	if(modId == "map")
 		return VLC->generaltexth->getPreferredLanguage();
-	return allMods.at(modId).baseLanguage;
+	return getModInfo(modId).getBaseLanguage();
 }
 
-std::set<TModID> CModHandler::getModDependencies(const TModID & modId, bool & isModFound) const
+std::set<TModID> CModHandler::getModDependencies(const TModID & modId) const
 {
-	auto it = allMods.find(modId);
-	isModFound = (it != allMods.end());
+	bool isModFound;
+	return getModDependencies(modId, isModFound);
+}
 
-	if(isModFound)
-		return it->second.dependencies;
+std::set<TModID> CModHandler::getModDependencies(const TModID & modId, bool & isModFound) const
+{
+	isModFound = modManager->isModActive(modId);
+	if (isModFound)
+		return modManager->getModDescription(modId).getDependencies();
 
 	logMod->error("Mod not found: '%s'", modId);
 	return {};
 }
 
-void CModHandler::initializeConfig()
+std::set<TModID> CModHandler::getModSoftDependencies(const TModID & modId) const
 {
-	VLC->settingsHandler->load(coreMod->config["settings"]);
-
-	for(const TModID & modName : activeMods)
-	{
-		const auto & mod = allMods[modName];
-		if (!mod.config["settings"].isNull())
-			VLC->settingsHandler->load(mod.config["settings"]);
-	}
+	return modManager->getModDescription(modId).getSoftDependencies();
 }
 
-CModVersion CModHandler::getModVersion(TModID modName) const
+std::set<TModID> CModHandler::getModEnabledSoftDependencies(const TModID & modId) const
 {
-	if (allMods.count(modName))
-		return allMods.at(modName).getVerificationInfo().version;
-	return {};
-}
+	std::set<TModID> softDependencies = getModSoftDependencies(modId);
 
-bool CModHandler::validateTranslations(TModID modName) const
-{
-	bool result = true;
-	const auto & mod = allMods.at(modName);
+	vstd::erase_if(softDependencies, [this](const TModID & dependency){ return !modManager->isModActive(dependency);});
 
-	{
-		auto fileList = mod.config["translations"].convertTo<std::vector<std::string> >();
-		JsonNode json = JsonUtils::assembleFromFiles(fileList);
-		result |= VLC->generaltexth->validateTranslation(mod.baseLanguage, modName, json);
-	}
+	return softDependencies;
+}
 
-	for(const auto & language : Languages::getLanguageList())
+void CModHandler::initializeConfig()
+{
+	for(const TModID & modName : getActiveMods())
 	{
-		if (mod.config[language.identifier].isNull())
-			continue;
-
-		if (mod.config[language.identifier]["skipValidation"].Bool())
-			continue;
-
-		auto fileList = mod.config[language.identifier]["translations"].convertTo<std::vector<std::string> >();
-		JsonNode json = JsonUtils::assembleFromFiles(fileList);
-		result |= VLC->generaltexth->validateTranslation(language.identifier, modName, json);
+		const auto & mod = getModInfo(modName);
+		if (!mod.getLocalConfig()["settings"].isNull())
+			VLC->settingsHandler->loadBase(mod.getLocalConfig()["settings"]);
 	}
-
-	return result;
 }
 
 void CModHandler::loadTranslation(const TModID & modName)
 {
-	const auto & mod = allMods[modName];
+	const auto & mod = getModInfo(modName);
 
 	std::string preferredLanguage = VLC->generaltexth->getPreferredLanguage();
-	std::string modBaseLanguage = allMods[modName].baseLanguage;
-
-	auto baseTranslationList = mod.config["translations"].convertTo<std::vector<std::string> >();
-	auto extraTranslationList = mod.config[preferredLanguage]["translations"].convertTo<std::vector<std::string> >();
+	std::string modBaseLanguage = getModInfo(modName).getBaseLanguage();
 
-	JsonNode baseTranslation = JsonUtils::assembleFromFiles(baseTranslationList);
-	JsonNode extraTranslation = JsonUtils::assembleFromFiles(extraTranslationList);
+	JsonNode baseTranslation = JsonUtils::assembleFromFiles(mod.getLocalConfig()["translations"]);
+	JsonNode extraTranslation = JsonUtils::assembleFromFiles(mod.getLocalConfig()[preferredLanguage]["translations"]);
 
-	VLC->generaltexth->loadTranslationOverrides(modBaseLanguage, modName, baseTranslation);
-	VLC->generaltexth->loadTranslationOverrides(preferredLanguage, modName, extraTranslation);
+	VLC->generaltexth->loadTranslationOverrides(modName, modBaseLanguage, baseTranslation);
+	VLC->generaltexth->loadTranslationOverrides(modName, preferredLanguage, extraTranslation);
 }
 
 void CModHandler::load()
 {
-	CStopWatch totalTime;
-	CStopWatch timer;
-
-	logMod->info("\tInitializing content handler: %d ms", timer.getDiff());
+	logMod->info("\tInitializing content handler");
 
 	content->init();
 
+	const auto & activeMods = getActiveMods();
+
+	validationPassed.insert(activeMods.begin(), activeMods.end());
+
 	for(const TModID & modName : activeMods)
 	{
-		logMod->trace("Generating checksum for %s", modName);
-		allMods[modName].updateChecksum(calculateModChecksum(modName, CResourceHandler::get(modName)));
+		modChecksums[modName] = this->modManager->computeChecksum(modName);
 	}
 
-	// first - load virtual builtin mod that contains all data
-	// TODO? move all data into real mods? RoE, AB, SoD, WoG
-	content->preloadData(*coreMod);
 	for(const TModID & modName : activeMods)
-		content->preloadData(allMods[modName]);
-	logMod->info("\tParsing mod data: %d ms", timer.getDiff());
+	{
+		const auto & modInfo = getModInfo(modName);
+		bool isValid = content->preloadData(modInfo, isModValidationNeeded(modInfo));
+		if (isValid)
+			logGlobal->info("\t\tParsing mod: OK (%s)", modInfo.getID());
+		else
+			logGlobal->warn("\t\tParsing mod: Issues found! (%s)", modInfo.getID());
+
+		if (!isValid)
+			validationPassed.erase(modName);
+	}
+	logMod->info("\tParsing mod data");
 
-	content->load(*coreMod);
 	for(const TModID & modName : activeMods)
-		content->load(allMods[modName]);
+	{
+		const auto & modInfo = getModInfo(modName);
+		bool isValid = content->load(getModInfo(modName), isModValidationNeeded(getModInfo(modName)));
+		if (isValid)
+			logGlobal->info("\t\tLoading mod: OK (%s)", modInfo.getID());
+		else
+			logGlobal->warn("\t\tLoading mod: Issues found! (%s)", modInfo.getID());
+
+		if (!isValid)
+			validationPassed.erase(modName);
+	}
 
 #if SCRIPTING_ENABLED
 	VLC->scriptHandler->performRegistration(VLC);//todo: this should be done before any other handlers load
@@ -480,39 +297,42 @@
 	for(const TModID & modName : activeMods)
 		loadTranslation(modName);
 
-#if 0
-	for(const TModID & modName : activeMods)
-		if (!validateTranslations(modName))
-			allMods[modName].validation = CModInfo::FAILED;
-#endif
-
-	logMod->info("\tLoading mod data: %d ms", timer.getDiff());
+	logMod->info("\tLoading mod data");
 	VLC->creh->loadCrExpMod();
 	VLC->identifiersHandler->finalize();
-	logMod->info("\tResolving identifiers: %d ms", timer.getDiff());
+	logMod->info("\tResolving identifiers");
 
 	content->afterLoadFinalization();
-	logMod->info("\tHandlers post-load finalization: %d ms ", timer.getDiff());
-	logMod->info("\tAll game content loaded in %d ms", totalTime.getDiff());
+	logMod->info("\tHandlers post-load finalization");
+	logMod->info("\tAll game content loaded");
 }
 
 void CModHandler::afterLoad(bool onlyEssential)
 {
 	JsonNode modSettings;
-	for (auto & modEntry : allMods)
+	for (const auto & modEntry : getActiveMods())
 	{
-		std::string pointer = "/" + boost::algorithm::replace_all_copy(modEntry.first, ".", "/mods/");
-
-		modSettings["activeMods"].resolvePointer(pointer) = modEntry.second.saveLocalData();
+		if (validationPassed.count(modEntry))
+			modManager->setValidatedChecksum(modEntry, modChecksums.at(modEntry));
+		else
+			modManager->setValidatedChecksum(modEntry, std::nullopt);
 	}
-	modSettings[ModScope::scopeBuiltin()] = coreMod->saveLocalData();
-	modSettings[ModScope::scopeBuiltin()]["name"].String() = "Original game files";
 
-	if(!onlyEssential)
-	{
-		std::fstream file(CResourceHandler::get()->getResourceName(ResourcePath("config/modSettings.json"))->c_str(), std::ofstream::out | std::ofstream::trunc);
-		file << modSettings.toString();
-	}
+	modManager->saveConfigurationState();
+}
+
+bool CModHandler::isModValidationNeeded(const ModDescription & mod) const
+{
+	if (settings["mods"]["validation"].String() == "full")
+		return true;
+
+	if (modManager->getValidatedChecksum(mod.getID()) == modChecksums.at(mod.getID()))
+		return false;
+
+	if (settings["mods"]["validation"].String() == "off")
+		return false;
+
+	return true;
 }
 
 VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/modding/CModHandler.h vcmi/lib/modding/CModHandler.h
--- vcmi-1.5.7/lib/modding/CModHandler.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/modding/CModHandler.h	2024-12-19 15:00:22.922148929 +0100
@@ -12,70 +12,53 @@
 VCMI_LIB_NAMESPACE_BEGIN
 
 class CModHandler;
-class CModIndentifier;
-class CModInfo;
-struct CModVersion;
-class JsonNode;
-class IHandlerBase;
-class CIdentifierStorage;
+class ModDescription;
 class CContentHandler;
-struct ModVerificationInfo;
 class ResourcePath;
-class MetaString;
+class ModManager;
+class ISimpleResourceLoader;
 
 using TModID = std::string;
 
 class DLL_LINKAGE CModHandler final : boost::noncopyable
 {
-	std::map <TModID, CModInfo> allMods;
-	std::vector <TModID> activeMods;//active mods, in order in which they were loaded
-	std::unique_ptr<CModInfo> coreMod;
-	mutable std::unique_ptr<MetaString> modLoadErrors;
-
-	bool hasCircularDependency(const TModID & mod, std::set<TModID> currentList = std::set<TModID>()) const;
-
-	/**
-	* 1. Set apart mods with resolved dependencies from mods which have unresolved dependencies
-	* 2. Sort resolved mods using topological algorithm
-	* 3. Log all problem mods and their unresolved dependencies
-	*
-	* @param modsToResolve list of valid mod IDs (checkDependencies returned true - TODO: Clarify it.)
-	* @return a vector of the topologically sorted resolved mods: child nodes (dependent mods) have greater index than parents
-	*/
-	std::vector <TModID> validateAndSortDependencies(std::vector <TModID> modsToResolve) const;
-
-	std::vector<std::string> getModList(const std::string & path) const;
-	void loadMods(const std::string & path, const std::string & parent, const JsonNode & modSettings, bool enableMods);
-	void loadOneMod(std::string modName, const std::string & parent, const JsonNode & modSettings, bool enableMods);
-	void loadTranslation(const TModID & modName);
+	std::unique_ptr<ModManager> modManager;
+	std::map<std::string, uint32_t> modChecksums;
+	std::set<std::string> validationPassed;
 
-	bool validateTranslations(TModID modName) const;
+	void loadTranslation(const TModID & modName);
+	void checkModFilesystemsConflicts(const std::map<TModID, ISimpleResourceLoader *> & modFilesystems);
 
-	CModVersion getModVersion(TModID modName) const;
+	bool isModValidationNeeded(const ModDescription & mod) const;
 
 public:
-	std::shared_ptr<CContentHandler> content; //(!)Do not serialize FIXME: make private
+	std::shared_ptr<CContentHandler> content;
 
 	/// receives list of available mods and trying to load mod.json from all of them
 	void initializeConfig();
-	void loadMods();
 	void loadModFilesystems();
 
 	/// returns ID of mod that provides selected file resource
 	TModID findResourceOrigin(const ResourcePath & name) const;
 
+	/// Returns assumed language ID of mod that provides selected file resource
+	std::string findResourceLanguage(const ResourcePath & name) const;
+
+	/// Returns assumed encoding of language of mod that provides selected file resource
+	std::string findResourceEncoding(const ResourcePath & name) const;
+
 	std::string getModLanguage(const TModID & modId) const;
 
+	std::set<TModID> getModDependencies(const TModID & modId) const;
 	std::set<TModID> getModDependencies(const TModID & modId, bool & isModFound) const;
+	std::set<TModID> getModSoftDependencies(const TModID & modId) const;
+	std::set<TModID> getModEnabledSoftDependencies(const TModID & modId) const;
 
 	/// returns list of all (active) mods
 	std::vector<std::string> getAllMods() const;
-	std::vector<std::string> getActiveMods() const;
+	const std::vector<std::string> & getActiveMods() const;
 
-	/// Returns human-readable string that describes erros encounter during mod loading, such as missing dependencies
-	std::string getModLoadErrors() const;
-	
-	const CModInfo & getModInfo(const TModID & modId) const;
+	const ModDescription & getModInfo(const TModID & modId) const;
 
 	/// load content from all available mods
 	void load();
diff --color -urN vcmi-1.5.7/lib/modding/CModInfo.cpp vcmi/lib/modding/CModInfo.cpp
--- vcmi-1.5.7/lib/modding/CModInfo.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/modding/CModInfo.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,205 +0,0 @@
-/*
- * CModInfo.cpp, part of VCMI engine
- *
- * Authors: listed in file AUTHORS in main folder
- *
- * License: GNU General Public License v2.0 or later
- * Full text of license available in license.txt file, in main folder
- *
- */
-#include "StdInc.h"
-#include "CModInfo.h"
-
-#include "../CGeneralTextHandler.h"
-#include "../VCMI_Lib.h"
-#include "../filesystem/Filesystem.h"
-
-VCMI_LIB_NAMESPACE_BEGIN
-
-static JsonNode addMeta(JsonNode config, const std::string & meta)
-{
-	config.setModScope(meta);
-	return config;
-}
-
-std::set<TModID> CModInfo::readModList(const JsonNode & input)
-{
-	std::set<TModID> result;
-
-	for (auto const & string : input.convertTo<std::set<std::string>>())
-		result.insert(boost::to_lower_copy(string));
-
-	return result;
-}
-
-CModInfo::CModInfo():
-	explicitlyEnabled(false),
-	implicitlyEnabled(true),
-	validation(PENDING)
-{
-
-}
-
-CModInfo::CModInfo(const std::string & identifier, const JsonNode & local, const JsonNode & config):
-	identifier(identifier),
-	dependencies(readModList(config["depends"])),
-	conflicts(readModList(config["conflicts"])),
-	explicitlyEnabled(false),
-	implicitlyEnabled(true),
-	validation(PENDING),
-	config(addMeta(config, identifier))
-{
-	if (!config["name"].String().empty())
-		verificationInfo.name = config["name"].String();
-	else
-		verificationInfo.name = identifier;
-
-	verificationInfo.version = CModVersion::fromString(config["version"].String());
-	verificationInfo.parent = identifier.substr(0, identifier.find_last_of('.'));
-	if(verificationInfo.parent == identifier)
-		verificationInfo.parent.clear();
-
-	if(!config["compatibility"].isNull())
-	{
-		vcmiCompatibleMin = CModVersion::fromString(config["compatibility"]["min"].String());
-		vcmiCompatibleMax = CModVersion::fromString(config["compatibility"]["max"].String());
-	}
-
-	if (!config["language"].isNull())
-		baseLanguage = config["language"].String();
-	else
-		baseLanguage = "english";
-
-	loadLocalData(local);
-}
-
-JsonNode CModInfo::saveLocalData() const
-{
-	std::ostringstream stream;
-	stream << std::noshowbase << std::hex << std::setw(8) << std::setfill('0') << verificationInfo.checksum;
-
-	JsonNode conf;
-	conf["active"].Bool() = explicitlyEnabled;
-	conf["validated"].Bool() = validation != FAILED;
-	conf["checksum"].String() = stream.str();
-	return conf;
-}
-
-std::string CModInfo::getModDir(const std::string & name)
-{
-	return "MODS/" + boost::algorithm::replace_all_copy(name, ".", "/MODS/");
-}
-
-JsonPath CModInfo::getModFile(const std::string & name)
-{
-	return JsonPath::builtinTODO(getModDir(name) + "/mod.json");
-}
-
-void CModInfo::updateChecksum(ui32 newChecksum)
-{
-	// comment-out next line to force validation of all mods ignoring checksum
-	if (newChecksum != verificationInfo.checksum)
-	{
-		verificationInfo.checksum = newChecksum;
-		validation = PENDING;
-	}
-}
-
-void CModInfo::loadLocalData(const JsonNode & data)
-{
-	bool validated = false;
-	implicitlyEnabled = true;
-	explicitlyEnabled = !config["keepDisabled"].Bool();
-	verificationInfo.checksum = 0;
-	if (data.isStruct())
-	{
-		explicitlyEnabled = data["active"].Bool();
-		validated = data["validated"].Bool();
-		updateChecksum(strtol(data["checksum"].String().c_str(), nullptr, 16));
-	}
-
-	//check compatibility
-	implicitlyEnabled &= (vcmiCompatibleMin.isNull() || CModVersion::GameVersion().compatible(vcmiCompatibleMin, true, true));
-	implicitlyEnabled &= (vcmiCompatibleMax.isNull() || vcmiCompatibleMax.compatible(CModVersion::GameVersion(), true, true));
-
-	if(!implicitlyEnabled)
-		logGlobal->warn("Mod %s is incompatible with current version of VCMI and cannot be enabled", verificationInfo.name);
-
-	if (config["modType"].String() == "Translation")
-	{
-		if (baseLanguage != CGeneralTextHandler::getPreferredLanguage())
-		{
-			if (identifier.find_last_of('.') == std::string::npos)
-				logGlobal->warn("Translation mod %s was not loaded: language mismatch!", verificationInfo.name);
-			implicitlyEnabled = false;
-		}
-	}
-	if (config["modType"].String() == "Compatibility")
-	{
-		// compatibility mods are always explicitly enabled
-		// however they may be implicitly disabled - if one of their dependencies is missing
-		explicitlyEnabled = true;
-	}
-
-	if (isEnabled())
-		validation = validated ? PASSED : PENDING;
-	else
-		validation = validated ? PASSED : FAILED;
-
-	verificationInfo.impactsGameplay = checkModGameplayAffecting();
-}
-
-bool CModInfo::checkModGameplayAffecting() const
-{
-	if (modGameplayAffecting.has_value())
-		return *modGameplayAffecting;
-
-	static const std::vector<std::string> keysToTest = {
-		"heroClasses",
-		"artifacts",
-		"creatures",
-		"factions",
-		"objects",
-		"heroes",
-		"spells",
-		"skills",
-		"templates",
-		"scripts",
-		"battlefields",
-		"terrains",
-		"rivers",
-		"roads",
-		"obstacles"
-	};
-
-	JsonPath modFileResource(CModInfo::getModFile(identifier));
-
-	if(CResourceHandler::get("initial")->existsResource(modFileResource))
-	{
-		const JsonNode modConfig(modFileResource);
-
-		for(const auto & key : keysToTest)
-		{
-			if (!modConfig[key].isNull())
-			{
-				modGameplayAffecting = true;
-				return *modGameplayAffecting;
-			}
-		}
-	}
-	modGameplayAffecting = false;
-	return *modGameplayAffecting;
-}
-
-const ModVerificationInfo & CModInfo::getVerificationInfo() const
-{
-	assert(!verificationInfo.name.empty());
-	return verificationInfo;
-}
-
-bool CModInfo::isEnabled() const
-{
-	return implicitlyEnabled && explicitlyEnabled;
-}
-
-VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/modding/CModInfo.h vcmi/lib/modding/CModInfo.h
--- vcmi-1.5.7/lib/modding/CModInfo.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/modding/CModInfo.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,82 +0,0 @@
-/*
- * CModInfo.h, part of VCMI engine
- *
- * Authors: listed in file AUTHORS in main folder
- *
- * License: GNU General Public License v2.0 or later
- * Full text of license available in license.txt file, in main folder
- *
- */
-#pragma once
-
-#include "../json/JsonNode.h"
-#include "ModVerificationInfo.h"
-
-VCMI_LIB_NAMESPACE_BEGIN
-
-class DLL_LINKAGE CModInfo
-{
-	/// cached result of checkModGameplayAffecting() call
-	/// Do not serialize - depends on local mod version, not server/save mod version
-	mutable std::optional<bool> modGameplayAffecting;
-
-	static std::set<TModID> readModList(const JsonNode & input);
-public:
-	enum EValidationStatus
-	{
-		PENDING,
-		FAILED,
-		PASSED
-	};
-	
-	/// identifier, identical to name of folder with mod
-	std::string identifier;
-
-	/// detailed mod description
-	std::string description;
-
-	/// Base language of mod, all mod strings are assumed to be in this language
-	std::string baseLanguage;
-
-	/// vcmi versions compatible with the mod
-	CModVersion vcmiCompatibleMin, vcmiCompatibleMax;
-
-	/// list of mods that should be loaded before this one
-	std::set <TModID> dependencies;
-
-	/// list of mods that can't be used in the same time as this one
-	std::set <TModID> conflicts;
-
-	EValidationStatus validation;
-
-	JsonNode config;
-
-	CModInfo();
-	CModInfo(const std::string & identifier, const JsonNode & local, const JsonNode & config);
-
-	JsonNode saveLocalData() const;
-	void updateChecksum(ui32 newChecksum);
-
-	bool isEnabled() const;
-
-	static std::string getModDir(const std::string & name);
-	static JsonPath getModFile(const std::string & name);
-
-	/// return true if this mod can affect gameplay, e.g. adds or modifies any game objects
-	bool checkModGameplayAffecting() const;
-	
-	const ModVerificationInfo & getVerificationInfo() const;
-
-private:
-	/// true if mod is enabled by user, e.g. in Launcher UI
-	bool explicitlyEnabled;
-
-	/// true if mod can be loaded - compatible and has no missing deps
-	bool implicitlyEnabled;
-	
-	ModVerificationInfo verificationInfo;
-
-	void loadLocalData(const JsonNode & data);
-};
-
-VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/modding/ContentTypeHandler.cpp vcmi/lib/modding/ContentTypeHandler.cpp
--- vcmi-1.5.7/lib/modding/ContentTypeHandler.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/modding/ContentTypeHandler.cpp	2024-12-19 15:00:22.922148929 +0100
@@ -11,20 +11,22 @@
 #include "ContentTypeHandler.h"
 
 #include "CModHandler.h"
-#include "CModInfo.h"
+#include "ModDescription.h"
+#include "ModManager.h"
 #include "ModScope.h"
 
 #include "../BattleFieldHandler.h"
 #include "../CArtHandler.h"
 #include "../CCreatureHandler.h"
-#include "../CGeneralTextHandler.h"
-#include "../CHeroHandler.h"
+#include "../CConfigHandler.h"
+#include "../entities/faction/CTownHandler.h"
+#include "../entities/hero/CHeroClassHandler.h"
+#include "../entities/hero/CHeroHandler.h"
+#include "../texts/CGeneralTextHandler.h"
 #include "../CSkillHandler.h"
 #include "../CStopWatch.h"
-#include "../CTownHandler.h"
-#include "../GameSettings.h"
+#include "../IGameSettings.h"
 #include "../IHandlerBase.h"
-#include "../Languages.h"
 #include "../ObstacleHandler.h"
 #include "../mapObjects/ObstacleSetHandler.h"
 #include "../RiverHandler.h"
@@ -36,12 +38,13 @@
 #include "../mapObjectConstructors/CObjectClassesHandler.h"
 #include "../rmg/CRmgTemplateStorage.h"
 #include "../spells/CSpellHandler.h"
+#include "../VCMI_Lib.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
-ContentTypeHandler::ContentTypeHandler(IHandlerBase * handler, const std::string & objectName):
+ContentTypeHandler::ContentTypeHandler(IHandlerBase * handler, const std::string & entityName):
 	handler(handler),
-	objectName(objectName),
+	entityName(entityName),
 	originalData(handler->loadLegacyData())
 {
 	for(auto & node : originalData)
@@ -50,9 +53,9 @@
 	}
 }
 
-bool ContentTypeHandler::preloadModData(const std::string & modName, const std::vector<std::string> & fileList, bool validate)
+bool ContentTypeHandler::preloadModData(const std::string & modName, const JsonNode & fileList, bool validate)
 {
-	bool result = false;
+	bool result = true;
 	JsonNode data = JsonUtils::assembleFromFiles(fileList, result);
 	data.setModScope(modName);
 
@@ -79,6 +82,9 @@
 			logMod->trace("Patching object %s (%s) from %s", objectName, remoteName, modName);
 			JsonNode & remoteConf = modData[remoteName].patches[objectName];
 
+			if (!remoteConf.isNull() && settings["mods"]["validation"].String() != "off")
+				JsonUtils::detectConflicts(conflictList, remoteConf, entry.second, objectName);
+
 			JsonUtils::merge(remoteConf, entry.second);
 		}
 	}
@@ -93,7 +99,7 @@
 	auto performValidate = [&,this](JsonNode & data, const std::string & name){
 		handler->beforeValidate(data);
 		if (validate)
-			result &= JsonUtils::validate(data, "vcmi:" + objectName, name);
+			result &= JsonUtils::validate(data, "vcmi:" + entityName, name);
 	};
 
 	// apply patches
@@ -113,7 +119,7 @@
 			// - another mod attempts to add object into this mod (technically can be supported, but might lead to weird edge cases)
 			// - another mod attempts to edit object from this mod that no longer exist - DANGER since such patch likely has very incomplete data
 			// so emit warning and skip such case
-			logMod->warn("Mod '%s' attempts to edit object '%s' of type '%s' from mod '%s' but no such object exist!", data.getModScope(), name, objectName, modName);
+			logMod->warn("Mod '%s' attempts to edit object '%s' of type '%s' from mod '%s' but no such object exist!", data.getModScope(), name, entityName, modName);
 			continue;
 		}
 
@@ -159,30 +165,72 @@
 
 void ContentTypeHandler::afterLoadFinalization()
 {
-	for (auto const & data : modData)
+	if (settings["mods"]["validation"].String() != "off")
 	{
-		if (data.second.modData.isNull())
+		for (auto const & data : modData)
 		{
-			for (auto node : data.second.patches.Struct())
-				logMod->warn("Mod '%s' have added patch for object '%s' from mod '%s', but this mod was not loaded or has no new objects.", node.second.getModScope(), node.first, data.first);
+			if (data.second.modData.isNull())
+			{
+				for (const auto & node : data.second.patches.Struct())
+					logMod->warn("Mod '%s' have added patch for object '%s' from mod '%s', but this mod was not loaded or has no new objects.", node.second.getModScope(), node.first, data.first);
+			}
+
+			for(auto & otherMod : modData)
+			{
+				if (otherMod.first == data.first)
+					continue;
+
+				if (otherMod.second.modData.isNull())
+					continue;
+
+				for(auto & otherObject : otherMod.second.modData.Struct())
+				{
+					if (data.second.modData.Struct().count(otherObject.first))
+					{
+						logMod->warn("Mod '%s' have added object with name '%s' that is also available in mod '%s'", data.first, otherObject.first, otherMod.first);
+						logMod->warn("Two objects with same name were loaded. Please use form '%s:%s' if mod '%s' needs to modify this object instead", otherMod.first, otherObject.first, data.first);
+					}
+				}
+			}
 		}
 
-		for(auto & otherMod : modData)
+		for (const auto& [conflictPath, conflictModData] : conflictList.Struct())
 		{
-			if (otherMod.first == data.first)
-				continue;
+			std::set<std::string> conflictingMods;
+			std::set<std::string> resolvedConflicts;
 
-			if (otherMod.second.modData.isNull())
-				continue;
+			for (auto const & conflictModEntry: conflictModData.Struct())
+				conflictingMods.insert(conflictModEntry.first);
 
-			for(auto & otherObject : otherMod.second.modData.Struct())
+			for (auto const & modID : conflictingMods)
 			{
-				if (data.second.modData.Struct().count(otherObject.first))
+				resolvedConflicts.merge(VLC->modh->getModDependencies(modID));
+				resolvedConflicts.merge(VLC->modh->getModEnabledSoftDependencies(modID));
+			}
+
+			vstd::erase_if(conflictingMods, [&resolvedConflicts](const std::string & entry){ return resolvedConflicts.count(entry);});
+
+			if (conflictingMods.size() < 2)
+				continue; // all conflicts were resolved - either via compatibility patch (mod that depends on 2 conflicting mods) or simple mod that depends on another one
+
+			bool allEqual = true;
+
+			for (auto const & modID : conflictingMods)
+			{
+				if (conflictModData[modID] != conflictModData[*conflictingMods.begin()])
 				{
-					logMod->warn("Mod '%s' have added object with name '%s' that is also available in mod '%s'", data.first, otherObject.first, otherMod.first);
-					logMod->warn("Two objects with same name were loaded. Please use form '%s:%s' if mod '%s' needs to modify this object instead", otherMod.first, otherObject.first, data.first);
+					allEqual = false;
+					break;
 				}
 			}
+
+			if (allEqual)
+				continue; // conflict still present, but all mods use the same value for conflicting entry - permit it
+
+			logMod->warn("Potential confict in '%s'", conflictPath);
+
+			for (auto const & modID : conflictingMods)
+				logMod->warn("Mod '%s' - value set to %s", modID, conflictModData[modID].toCompactString());
 		}
 	}
 
@@ -211,22 +259,26 @@
 	handlers.insert(std::make_pair("biomes", ContentTypeHandler(VLC->biomeHandler.get(), "biome")));
 }
 
-bool CContentHandler::preloadModData(const std::string & modName, JsonNode modConfig, bool validate)
+bool CContentHandler::preloadData(const ModDescription & mod, bool validate)
 {
 	bool result = true;
+
+	if (!JsonUtils::validate(mod.getLocalConfig(), "vcmi:mod", mod.getID()))
+		result = false;
+
 	for(auto & handler : handlers)
 	{
-		result &= handler.second.preloadModData(modName, modConfig[handler.first].convertTo<std::vector<std::string> >(), validate);
+		result &= handler.second.preloadModData(mod.getID(), mod.getLocalValue(handler.first), validate);
 	}
 	return result;
 }
 
-bool CContentHandler::loadMod(const std::string & modName, bool validate)
+bool CContentHandler::load(const ModDescription & mod, bool validate)
 {
 	bool result = true;
 	for(auto & handler : handlers)
 	{
-		result &= handler.second.loadMod(modName, validate);
+		result &= handler.second.loadMod(mod.getID(), validate);
 	}
 	return result;
 }
@@ -247,41 +299,6 @@
 	}
 }
 
-void CContentHandler::preloadData(CModInfo & mod)
-{
-	bool validate = (mod.validation != CModInfo::PASSED);
-
-	// print message in format [<8-symbols checksum>] <modname>
-	auto & info = mod.getVerificationInfo();
-	logMod->info("\t\t[%08x]%s", info.checksum, info.name);
-
-	if (validate && mod.identifier != ModScope::scopeBuiltin())
-	{
-		if (!JsonUtils::validate(mod.config, "vcmi:mod", mod.identifier))
-			mod.validation = CModInfo::FAILED;
-	}
-	if (!preloadModData(mod.identifier, mod.config, validate))
-		mod.validation = CModInfo::FAILED;
-}
-
-void CContentHandler::load(CModInfo & mod)
-{
-	bool validate = (mod.validation != CModInfo::PASSED);
-
-	if (!loadMod(mod.identifier, validate))
-		mod.validation = CModInfo::FAILED;
-
-	if (validate)
-	{
-		if (mod.validation != CModInfo::FAILED)
-			logMod->info("\t\t[DONE] %s", mod.getVerificationInfo().name);
-		else
-			logMod->error("\t\t[FAIL] %s", mod.getVerificationInfo().name);
-	}
-	else
-		logMod->info("\t\t[SKIP] %s", mod.getVerificationInfo().name);
-}
-
 const ContentTypeHandler & CContentHandler::operator[](const std::string & name) const
 {
 	return handlers.at(name);
diff --color -urN vcmi-1.5.7/lib/modding/ContentTypeHandler.h vcmi/lib/modding/ContentTypeHandler.h
--- vcmi-1.5.7/lib/modding/ContentTypeHandler.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/modding/ContentTypeHandler.h	2024-12-19 15:00:22.922148929 +0100
@@ -14,11 +14,13 @@
 VCMI_LIB_NAMESPACE_BEGIN
 
 class IHandlerBase;
-class CModInfo;
+class ModDescription;
 
 /// internal type to handle loading of one data type (e.g. artifacts, creatures)
 class DLL_LINKAGE ContentTypeHandler
 {
+	JsonNode conflictList;
+
 public:
 	struct ModInfo
 	{
@@ -29,7 +31,7 @@
 	};
 	/// handler to which all data will be loaded
 	IHandlerBase * handler;
-	std::string objectName;
+	std::string entityName;
 
 	/// contains all loaded H3 data
 	std::vector<JsonNode> originalData;
@@ -39,7 +41,7 @@
 
 	/// local version of methods in ContentHandler
 	/// returns true if loading was successful
-	bool preloadModData(const std::string & modName, const std::vector<std::string> & fileList, bool validate);
+	bool preloadModData(const std::string & modName, const JsonNode & fileList, bool validate);
 	bool loadMod(const std::string & modName, bool validate);
 	void loadCustom();
 	void afterLoadFinalization();
@@ -48,22 +50,16 @@
 /// class used to load all game data into handlers. Used only during loading
 class DLL_LINKAGE CContentHandler
 {
-	/// preloads all data from fileList as data from modName.
-	bool preloadModData(const std::string & modName, JsonNode modConfig, bool validate);
-
-	/// actually loads data in mod
-	bool loadMod(const std::string & modName, bool validate);
-
 	std::map<std::string, ContentTypeHandler> handlers;
 
 public:
 	void init();
 
 	/// preloads all data from fileList as data from modName.
-	void preloadData(CModInfo & mod);
+	bool preloadData(const ModDescription & mod, bool validateMod);
 
 	/// actually loads data in mod
-	void load(CModInfo & mod);
+	bool load(const ModDescription & mod, bool validateMod);
 
 	void loadCustom();
 
diff --color -urN vcmi-1.5.7/lib/modding/IdentifierStorage.cpp vcmi/lib/modding/IdentifierStorage.cpp
--- vcmi-1.5.7/lib/modding/IdentifierStorage.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/modding/IdentifierStorage.cpp	2024-12-19 15:00:22.923148971 +0100
@@ -190,6 +190,12 @@
 	requestIdentifier(ObjectCallback::fromNameWithType(name.getModScope(), name.String(), callback, false));
 }
 
+void CIdentifierStorage::requestIdentifierOptional(const std::string & type, const JsonNode & name, const std::function<void(si32)> & callback) const
+{
+	if (!name.isNull())
+		requestIdentifier(type, name, callback);
+}
+
 void CIdentifierStorage::tryRequestIdentifier(const std::string & scope, const std::string & type, const std::string & name, const std::function<void(si32)> & callback) const
 {
 	requestIdentifier(ObjectCallback::fromNameAndType(scope, type, name, callback, true));
@@ -430,7 +436,7 @@
 		return true;
 	}
 
-	if (request.optional && identifiers.empty()) // failed to resolve optinal ID
+	if (request.optional && identifiers.empty()) // failed to resolve optional ID
 	{
 		return true;
 	}
diff --color -urN vcmi-1.5.7/lib/modding/IdentifierStorage.h vcmi/lib/modding/IdentifierStorage.h
--- vcmi-1.5.7/lib/modding/IdentifierStorage.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/modding/IdentifierStorage.h	2024-12-19 15:00:22.923148971 +0100
@@ -84,6 +84,8 @@
 	void requestIdentifier(const std::string & type, const JsonNode & name, const std::function<void(si32)> & callback) const;
 	void requestIdentifier(const JsonNode & name, const std::function<void(si32)> & callback) const;
 
+	void requestIdentifierOptional(const std::string & type, const JsonNode & name, const std::function<void(si32)> & callback) const;
+
 	/// try to request ID. If ID with such name won't be loaded, callback function will not be called
 	void tryRequestIdentifier(const std::string & scope, const std::string & type, const std::string & name, const std::function<void(si32)> & callback) const;
 	void tryRequestIdentifier(const std::string & type, const JsonNode & name, const std::function<void(si32)> & callback) const;
diff --color -urN vcmi-1.5.7/lib/modding/ModDescription.cpp vcmi/lib/modding/ModDescription.cpp
--- vcmi-1.5.7/lib/modding/ModDescription.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/modding/ModDescription.cpp	2024-12-19 15:00:22.923148971 +0100
@@ -0,0 +1,233 @@
+/*
+ * ModDescription.cpp, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#include "StdInc.h"
+#include "ModDescription.h"
+
+#include "CModVersion.h"
+#include "ModVerificationInfo.h"
+
+#include "../json/JsonNode.h"
+#include "../texts/CGeneralTextHandler.h"
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+ModDescription::ModDescription(const TModID & fullID, const JsonNode & localConfig, const JsonNode & repositoryConfig)
+	: identifier(fullID)
+	, localConfig(std::make_unique<JsonNode>(localConfig))
+	, repositoryConfig(std::make_unique<JsonNode>(repositoryConfig))
+	, dependencies(loadModList(getValue("depends")))
+	, softDependencies(loadModList(getValue("softDepends")))
+	, conflicts(loadModList(getValue("conflicts")))
+{
+	if(getID() != "core")
+		dependencies.emplace("core");
+
+	if (!getParentID().empty())
+		dependencies.emplace(getParentID());
+}
+
+ModDescription::~ModDescription() = default;
+
+TModSet ModDescription::loadModList(const JsonNode & configNode) const
+{
+	TModSet result;
+	for(const auto & entry : configNode.Vector())
+		result.insert(boost::algorithm::to_lower_copy(entry.String()));
+	return result;
+}
+
+const TModID & ModDescription::getID() const
+{
+	return identifier;
+}
+
+TModID ModDescription::getParentID() const
+{
+	size_t dotPos = identifier.find_last_of('.');
+
+	if(dotPos == std::string::npos)
+		return {};
+
+	return identifier.substr(0, dotPos);
+}
+
+TModID ModDescription::getTopParentID() const
+{
+	size_t dotPos = identifier.find('.');
+
+	if(dotPos == std::string::npos)
+		return {};
+
+	return identifier.substr(0, dotPos);
+}
+
+const TModSet & ModDescription::getDependencies() const
+{
+	return dependencies;
+}
+
+const TModSet & ModDescription::getSoftDependencies() const
+{
+	return softDependencies;
+}
+
+const TModSet & ModDescription::getConflicts() const
+{
+	return conflicts;
+}
+
+const std::string & ModDescription::getBaseLanguage() const
+{
+	static const std::string defaultLanguage = "english";
+
+	return getValue("language").isString() ? getValue("language").String() : defaultLanguage;
+}
+
+const std::string & ModDescription::getName() const
+{
+	return getLocalizedValue("name").String();
+}
+
+const JsonNode & ModDescription::getFilesystemConfig() const
+{
+	return getLocalValue("filesystem");
+}
+
+const JsonNode & ModDescription::getLocalConfig() const
+{
+	return *localConfig;
+}
+
+const JsonNode & ModDescription::getLocalizedValue(const std::string & keyName) const
+{
+	const std::string language = CGeneralTextHandler::getPreferredLanguage();
+	const JsonNode & languageNode = getValue(language);
+	const JsonNode & baseValue = getValue(keyName);
+	const JsonNode & localizedValue = languageNode[keyName];
+
+	if (localizedValue.isNull())
+		return baseValue;
+	else
+		return localizedValue;
+}
+
+const JsonNode & ModDescription::getValue(const std::string & keyName) const
+{
+	const JsonNode & localValue = getLocalValue(keyName);
+	if (localValue.isNull())
+		return getRepositoryValue(keyName);
+	else
+		return getLocalValue(keyName);
+}
+
+const JsonNode & ModDescription::getLocalValue(const std::string & keyName) const
+{
+	return getLocalConfig()[keyName];
+}
+
+const JsonNode & ModDescription::getRepositoryValue(const std::string & keyName) const
+{
+	return (*repositoryConfig)[keyName];
+}
+
+CModVersion ModDescription::getVersion() const
+{
+	return CModVersion::fromString(getValue("version").String());
+}
+
+ModVerificationInfo ModDescription::getVerificationInfo() const
+{
+	ModVerificationInfo result;
+	result.name = getName();
+	result.version = getVersion();
+	result.impactsGameplay = affectsGameplay();
+	result.parent = getParentID();
+
+	return result;
+}
+
+bool ModDescription::isCompatible() const
+{
+	const JsonNode & compatibility = getValue("compatibility");
+
+	if (compatibility.isNull())
+		return true;
+
+	auto vcmiCompatibleMin = CModVersion::fromString(compatibility["min"].String());
+	auto vcmiCompatibleMax = CModVersion::fromString(compatibility["max"].String());
+
+	bool compatible = true;
+	compatible &= (vcmiCompatibleMin.isNull() || CModVersion::GameVersion().compatible(vcmiCompatibleMin, true, true));
+	compatible &= (vcmiCompatibleMax.isNull() || vcmiCompatibleMax.compatible(CModVersion::GameVersion(), true, true));
+
+	return compatible;
+}
+
+bool ModDescription::isCompatibility() const
+{
+	return getValue("modType").String() == "Compatibility";
+}
+
+bool ModDescription::isTranslation() const
+{
+	return getValue("modType").String() == "Translation";
+}
+
+bool ModDescription::keepDisabled() const
+{
+	return getValue("keepDisabled").Bool();
+}
+
+bool ModDescription::isInstalled() const
+{
+	return !localConfig->isNull();
+}
+
+bool ModDescription::affectsGameplay() const
+{
+	static const std::array keysToTest = {
+		"artifacts",
+		"battlefields",
+		"creatures",
+		"factions",
+		"heroClasses",
+		"heroes",
+		"objects",
+		"obstacles",
+		"rivers",
+		"roads",
+		"settings",
+		"skills",
+		"spells",
+		"terrains",
+	};
+
+	for(const auto & key : keysToTest)
+		if (!getLocalValue(key).isNull())
+			return true;
+
+	return false;
+}
+
+bool ModDescription::isUpdateAvailable() const
+{
+	if (getRepositoryValue("version").isNull())
+		return false;
+
+	if (getLocalValue("version").isNull())
+		return false;
+
+	auto localVersion = CModVersion::fromString(getLocalValue("version").String());
+	auto repositoryVersion = CModVersion::fromString(getRepositoryValue("version").String());
+
+	return localVersion < repositoryVersion;
+}
+
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/modding/ModDescription.h vcmi/lib/modding/ModDescription.h
--- vcmi-1.5.7/lib/modding/ModDescription.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/modding/ModDescription.h	2024-12-19 15:00:22.923148971 +0100
@@ -0,0 +1,70 @@
+/*
+ * ModDescription.h, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#pragma once
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+struct CModVersion;
+struct ModVerificationInfo;
+class JsonNode;
+
+using TModID = std::string;
+using TModList = std::vector<TModID>;
+using TModSet = std::set<TModID>;
+
+class DLL_LINKAGE ModDescription : boost::noncopyable
+{
+	TModID identifier;
+
+	std::unique_ptr<JsonNode> localConfig;
+	std::unique_ptr<JsonNode> repositoryConfig;
+
+	TModSet dependencies;
+	TModSet softDependencies;
+	TModSet conflicts;
+
+	TModSet loadModList(const JsonNode & configNode) const;
+
+public:
+	ModDescription(const TModID & fullID, const JsonNode & localConfig, const JsonNode & repositoryConfig);
+	~ModDescription();
+
+	const TModID & getID() const;
+	TModID getParentID() const;
+	TModID getTopParentID() const;
+
+	const TModSet & getDependencies() const;
+	const TModSet & getSoftDependencies() const;
+	const TModSet & getConflicts() const;
+
+	const std::string & getBaseLanguage() const;
+	const std::string & getName() const;
+
+	const JsonNode & getFilesystemConfig() const;
+	const JsonNode & getLocalConfig() const;
+	const JsonNode & getValue(const std::string & keyName) const;
+	const JsonNode & getLocalizedValue(const std::string & keyName) const;
+	const JsonNode & getLocalValue(const std::string & keyName) const;
+	const JsonNode & getRepositoryValue(const std::string & keyName) const;
+
+	CModVersion getVersion() const;
+	ModVerificationInfo getVerificationInfo() const;
+
+	bool isCompatible() const;
+	bool isUpdateAvailable() const;
+
+	bool affectsGameplay() const;
+	bool isCompatibility() const;
+	bool isTranslation() const;
+	bool keepDisabled() const;
+	bool isInstalled() const;
+};
+
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/modding/ModIncompatibility.h vcmi/lib/modding/ModIncompatibility.h
--- vcmi-1.5.7/lib/modding/ModIncompatibility.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/modding/ModIncompatibility.h	2024-12-19 15:00:22.923148971 +0100
@@ -24,7 +24,7 @@
 		messageMissingMods = _ss.str();
 	}
 	
-	ModIncompatibility(const ModList & _missingMods, ModList & _excessiveMods)
+	ModIncompatibility(const ModList & _missingMods, const ModList & _excessiveMods)
 		: ModIncompatibility(_missingMods)
 	{
 		std::ostringstream _ss;
diff --color -urN vcmi-1.5.7/lib/modding/ModManager.cpp vcmi/lib/modding/ModManager.cpp
--- vcmi-1.5.7/lib/modding/ModManager.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/modding/ModManager.cpp	2024-12-19 15:00:22.923148971 +0100
@@ -0,0 +1,706 @@
+/*
+ * ModManager.cpp, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#include "StdInc.h"
+#include "ModManager.h"
+
+#include "ModDescription.h"
+#include "ModScope.h"
+
+#include "../constants/StringConstants.h"
+#include "../filesystem/Filesystem.h"
+#include "../json/JsonNode.h"
+#include "../texts/CGeneralTextHandler.h"
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+static std::string getModDirectory(const TModID & modName)
+{
+	std::string result = modName;
+	boost::to_upper(result);
+	boost::algorithm::replace_all(result, ".", "/MODS/");
+	return "MODS/" + result;
+}
+
+static std::string getModSettingsDirectory(const TModID & modName)
+{
+	return getModDirectory(modName) + "/MODS/";
+}
+
+static JsonPath getModDescriptionFile(const TModID & modName)
+{
+	return JsonPath::builtin(getModDirectory(modName) + "/mod");
+}
+
+ModsState::ModsState()
+{
+	modList.push_back(ModScope::scopeBuiltin());
+
+	std::vector<TModID> testLocations = scanModsDirectory("MODS/");
+
+	while(!testLocations.empty())
+	{
+		std::string target = testLocations.back();
+		testLocations.pop_back();
+		modList.push_back(boost::algorithm::to_lower_copy(target));
+
+		for(const auto & submod : scanModsDirectory(getModSettingsDirectory(target)))
+			testLocations.push_back(target + '.' + submod);
+	}
+}
+
+TModList ModsState::getInstalledMods() const
+{
+	return modList;
+}
+
+uint32_t ModsState::computeChecksum(const TModID & modName) const
+{
+	boost::crc_32_type modChecksum;
+	// first - add current VCMI version into checksum to force re-validation on VCMI updates
+	modChecksum.process_bytes(static_cast<const void*>(GameConstants::VCMI_VERSION.data()), GameConstants::VCMI_VERSION.size());
+
+	// second - add mod.json into checksum because filesystem does not contains this file
+	if (modName != ModScope::scopeBuiltin())
+	{
+		auto modConfFile = getModDescriptionFile(modName);
+		ui32 configChecksum = CResourceHandler::get("initial")->load(modConfFile)->calculateCRC32();
+		modChecksum.process_bytes(static_cast<const void *>(&configChecksum), sizeof(configChecksum));
+	}
+
+	// third - add all detected text files from this mod into checksum
+	const auto & filesystem = CResourceHandler::get(modName);
+
+	auto files = filesystem->getFilteredFiles([](const ResourcePath & resID)
+	{
+		return resID.getType() == EResType::JSON && boost::starts_with(resID.getName(), "CONFIG");
+	});
+
+	for (const ResourcePath & file : files)
+	{
+		ui32 fileChecksum = filesystem->load(file)->calculateCRC32();
+		modChecksum.process_bytes(static_cast<const void *>(&fileChecksum), sizeof(fileChecksum));
+	}
+	return modChecksum.checksum();
+}
+
+double ModsState::getInstalledModSizeMegabytes(const TModID & modName) const
+{
+	ResourcePath resDir(getModDirectory(modName), EResType::DIRECTORY);
+	std::string path = CResourceHandler::get()->getResourceName(resDir)->string();
+
+	size_t sizeBytes = 0;
+	for(boost::filesystem::recursive_directory_iterator it(path); it != boost::filesystem::recursive_directory_iterator(); ++it)
+	{
+		if(!boost::filesystem::is_directory(*it))
+			sizeBytes += boost::filesystem::file_size(*it);
+	}
+
+	double sizeMegabytes = sizeBytes / static_cast<double>(1024*1024);
+	return sizeMegabytes;
+}
+
+std::vector<TModID> ModsState::scanModsDirectory(const std::string & modDir) const
+{
+	size_t depth = boost::range::count(modDir, '/');
+
+	const auto & modScanFilter = [&](const ResourcePath & id) -> bool
+	{
+		if(id.getType() != EResType::DIRECTORY)
+			return false;
+		if(!boost::algorithm::starts_with(id.getName(), modDir))
+			return false;
+		if(boost::range::count(id.getName(), '/') != depth)
+			return false;
+		return true;
+	};
+
+	auto list = CResourceHandler::get("initial")->getFilteredFiles(modScanFilter);
+
+	//storage for found mods
+	std::vector<TModID> foundMods;
+	for(const auto & entry : list)
+	{
+		std::string name = entry.getName();
+		name.erase(0, modDir.size()); //Remove path prefix
+
+		if(name.empty())
+			continue;
+
+		if(name.find('.') != std::string::npos)
+			continue;
+
+		if (ModScope::isScopeReserved(boost::to_lower_copy(name)))
+			continue;
+
+		if(!CResourceHandler::get("initial")->existsResource(JsonPath::builtin(entry.getName() + "/MOD")))
+			continue;
+
+		foundMods.push_back(name);
+	}
+	return foundMods;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+ModsPresetState::ModsPresetState()
+{
+	static const JsonPath settingsPath = JsonPath::builtin("config/modSettings.json");
+
+	if(CResourceHandler::get("local")->existsResource(ResourcePath(settingsPath)))
+	{
+		modConfig = JsonNode(settingsPath);
+	}
+	else
+	{
+		// Probably new install. Create initial configuration
+		CResourceHandler::get("local")->createResource(settingsPath.getOriginalName() + ".json");
+	}
+
+	if(modConfig["presets"].isNull())
+	{
+		modConfig["activePreset"] = JsonNode("default");
+		if(modConfig["activeMods"].isNull())
+			createInitialPreset(); // new install
+		else
+			importInitialPreset(); // 1.5 format import
+	}
+}
+
+void ModsPresetState::createInitialPreset()
+{
+	// TODO: scan mods directory for all its content? Probably unnecessary since this looks like new install, but who knows?
+	modConfig["presets"]["default"]["mods"].Vector().emplace_back("vcmi");
+}
+
+void ModsPresetState::importInitialPreset()
+{
+	JsonNode preset;
+
+	for(const auto & mod : modConfig["activeMods"].Struct())
+	{
+		if(mod.second["active"].Bool())
+			preset["mods"].Vector().emplace_back(mod.first);
+
+		for(const auto & submod : mod.second["mods"].Struct())
+			preset["settings"][mod.first][submod.first] = submod.second["active"];
+	}
+	modConfig["presets"]["default"] = preset;
+}
+
+const JsonNode & ModsPresetState::getActivePresetConfig() const
+{
+	const std::string & currentPresetName = modConfig["activePreset"].String();
+	const JsonNode & currentPreset = modConfig["presets"][currentPresetName];
+	return currentPreset;
+}
+
+TModList ModsPresetState::getActiveRootMods() const
+{
+	const JsonNode & modsToActivateJson = getActivePresetConfig()["mods"];
+	auto modsToActivate = modsToActivateJson.convertTo<std::vector<TModID>>();
+	if (!vstd::contains(modsToActivate, ModScope::scopeBuiltin()))
+		modsToActivate.push_back(ModScope::scopeBuiltin());
+	return modsToActivate;
+}
+
+std::map<TModID, bool> ModsPresetState::getModSettings(const TModID & modID) const
+{
+	const JsonNode & modSettingsJson = getActivePresetConfig()["settings"][modID];
+	auto modSettings = modSettingsJson.convertTo<std::map<TModID, bool>>();
+	return modSettings;
+}
+
+std::optional<uint32_t> ModsPresetState::getValidatedChecksum(const TModID & modName) const
+{
+	const JsonNode & node = modConfig["validatedMods"][modName];
+	if (node.isNull())
+		return std::nullopt;
+	else
+		return node.Integer();
+}
+
+void ModsPresetState::setModActive(const TModID & modID, bool isActive)
+{
+	size_t dotPos = modID.find('.');
+
+	if(dotPos != std::string::npos)
+	{
+		std::string rootMod = modID.substr(0, dotPos);
+		std::string settingID = modID.substr(dotPos + 1);
+		setSettingActive(rootMod, settingID, isActive);
+	}
+	else
+	{
+		if (isActive)
+			addRootMod(modID);
+		else
+			eraseRootMod(modID);
+	}
+}
+
+void ModsPresetState::addRootMod(const TModID & modName)
+{
+	const std::string & currentPresetName = modConfig["activePreset"].String();
+	JsonNode & currentPreset = modConfig["presets"][currentPresetName];
+
+	if (!vstd::contains(currentPreset["mods"].Vector(), JsonNode(modName)))
+		currentPreset["mods"].Vector().emplace_back(modName);
+}
+
+void ModsPresetState::setSettingActive(const TModID & modName, const TModID & settingName, bool isActive)
+{
+	const std::string & currentPresetName = modConfig["activePreset"].String();
+	JsonNode & currentPreset = modConfig["presets"][currentPresetName];
+
+	currentPreset["settings"][modName][settingName].Bool() = isActive;
+}
+
+void ModsPresetState::removeOldMods(const TModList & modsToKeep)
+{
+	const std::string & currentPresetName = modConfig["activePreset"].String();
+	JsonNode & currentPreset = modConfig["presets"][currentPresetName];
+
+	vstd::erase_if(currentPreset["mods"].Vector(), [&](const JsonNode & entry){
+		return !vstd::contains(modsToKeep, entry.String());
+	});
+
+	vstd::erase_if(currentPreset["settings"].Struct(), [&](const auto & entry){
+		return !vstd::contains(modsToKeep, entry.first);
+	});
+}
+
+void ModsPresetState::eraseRootMod(const TModID & modName)
+{
+	const std::string & currentPresetName = modConfig["activePreset"].String();
+	JsonNode & currentPreset = modConfig["presets"][currentPresetName];
+	vstd::erase(currentPreset["mods"].Vector(), JsonNode(modName));
+}
+
+void ModsPresetState::eraseModSetting(const TModID & modName, const TModID & settingName)
+{
+	const std::string & currentPresetName = modConfig["activePreset"].String();
+	JsonNode & currentPreset = modConfig["presets"][currentPresetName];
+	currentPreset["settings"][modName].Struct().erase(settingName);
+}
+
+std::vector<TModID> ModsPresetState::getActiveMods() const
+{
+	TModList activeRootMods = getActiveRootMods();
+	TModList allActiveMods;
+
+	for(const auto & activeMod : activeRootMods)
+	{
+		assert(!vstd::contains(allActiveMods, activeMod));
+		allActiveMods.push_back(activeMod);
+
+		for(const auto & submod : getModSettings(activeMod))
+		{
+			if(submod.second)
+			{
+				assert(!vstd::contains(allActiveMods, activeMod + '.' + submod.first));
+				allActiveMods.push_back(activeMod + '.' + submod.first);
+			}
+		}
+	}
+	return allActiveMods;
+}
+
+void ModsPresetState::setValidatedChecksum(const TModID & modName, std::optional<uint32_t> value)
+{
+	if (value.has_value())
+		modConfig["validatedMods"][modName].Integer() = *value;
+	else
+		modConfig["validatedMods"].Struct().erase(modName);
+}
+
+void ModsPresetState::saveConfigurationState() const
+{
+	std::fstream file(CResourceHandler::get()->getResourceName(ResourcePath("config/modSettings.json"))->c_str(), std::ofstream::out | std::ofstream::trunc);
+	file << modConfig.toCompactString();
+}
+
+ModsStorage::ModsStorage(const std::vector<TModID> & modsToLoad, const JsonNode & repositoryList)
+{
+	JsonNode coreModConfig(JsonPath::builtin("config/gameConfig.json"));
+	coreModConfig.setModScope(ModScope::scopeBuiltin());
+	mods.try_emplace(ModScope::scopeBuiltin(), ModScope::scopeBuiltin(), coreModConfig, JsonNode());
+
+	for(auto modID : modsToLoad)
+	{
+		if(ModScope::isScopeReserved(modID))
+			continue;
+
+		JsonNode modConfig(getModDescriptionFile(modID));
+		modConfig.setModScope(modID);
+
+		if(modConfig["modType"].isNull())
+		{
+			logMod->error("Can not load mod %s - invalid mod config file!", modID);
+			continue;
+		}
+
+		mods.try_emplace(modID, modID, modConfig, repositoryList[modID]);
+	}
+
+	for(const auto & mod : repositoryList.Struct())
+	{
+		if (vstd::contains(modsToLoad, mod.first))
+			continue;
+
+		if (mod.second["modType"].isNull() || mod.second["name"].isNull())
+			continue;
+
+		mods.try_emplace(mod.first, mod.first, JsonNode(), mod.second);
+	}
+}
+
+const ModDescription & ModsStorage::getMod(const TModID & fullID) const
+{
+	return mods.at(fullID);
+}
+
+TModList ModsStorage::getAllMods() const
+{
+	TModList result;
+	for (const auto & mod : mods)
+		result.push_back(mod.first);
+
+	return result;
+}
+
+ModManager::ModManager()
+	:ModManager(JsonNode())
+{
+}
+
+ModManager::ModManager(const JsonNode & repositoryList)
+	: modsState(std::make_unique<ModsState>())
+	, modsPreset(std::make_unique<ModsPresetState>())
+{
+	modsStorage = std::make_unique<ModsStorage>(modsState->getInstalledMods(), repositoryList);
+
+	eraseMissingModsFromPreset();
+	addNewModsToPreset();
+
+	std::vector<TModID> desiredModList = modsPreset->getActiveMods();
+	ModDependenciesResolver newResolver(desiredModList, *modsStorage);
+	updatePreset(newResolver);
+}
+
+ModManager::~ModManager() = default;
+
+const ModDescription & ModManager::getModDescription(const TModID & modID) const
+{
+	assert(boost::to_lower_copy(modID) == modID);
+	return modsStorage->getMod(modID);
+}
+
+bool ModManager::isModSettingActive(const TModID & rootModID, const TModID & modSettingID) const
+{
+	return modsPreset->getModSettings(rootModID).at(modSettingID);
+}
+
+bool ModManager::isModActive(const TModID & modID) const
+{
+	return vstd::contains(getActiveMods(), modID);
+}
+
+const TModList & ModManager::getActiveMods() const
+{
+	return depedencyResolver->getActiveMods();
+}
+
+uint32_t ModManager::computeChecksum(const TModID & modName) const
+{
+	return modsState->computeChecksum(modName);
+}
+
+std::optional<uint32_t> ModManager::getValidatedChecksum(const TModID & modName) const
+{
+	return modsPreset->getValidatedChecksum(modName);
+}
+
+void ModManager::setValidatedChecksum(const TModID & modName, std::optional<uint32_t> value)
+{
+	modsPreset->setValidatedChecksum(modName, value);
+}
+
+void ModManager::saveConfigurationState() const
+{
+	modsPreset->saveConfigurationState();
+}
+
+TModList ModManager::getAllMods() const
+{
+	return modsStorage->getAllMods();
+}
+
+double ModManager::getInstalledModSizeMegabytes(const TModID & modName) const
+{
+	return modsState->getInstalledModSizeMegabytes(modName);
+}
+
+void ModManager::eraseMissingModsFromPreset()
+{
+	const TModList & installedMods = modsState->getInstalledMods();
+	const TModList & rootMods = modsPreset->getActiveRootMods();
+
+	modsPreset->removeOldMods(installedMods);
+
+	for(const auto & rootMod : rootMods)
+	{
+		const auto & modSettings = modsPreset->getModSettings(rootMod);
+
+		for(const auto & modSetting : modSettings)
+		{
+			TModID fullModID = rootMod + '.' + modSetting.first;
+			if(!vstd::contains(installedMods, fullModID))
+			{
+				modsPreset->eraseModSetting(rootMod, modSetting.first);
+				continue;
+			}
+		}
+	}
+}
+
+void ModManager::addNewModsToPreset()
+{
+	const TModList & installedMods = modsState->getInstalledMods();
+
+	for(const auto & modID : installedMods)
+	{
+		size_t dotPos = modID.find('.');
+
+		if(dotPos == std::string::npos)
+			continue; // only look up submods aka mod settings
+
+		std::string rootMod = modID.substr(0, dotPos);
+		std::string settingID = modID.substr(dotPos + 1);
+
+		const auto & modSettings = modsPreset->getModSettings(rootMod);
+
+		if (!modSettings.count(settingID))
+			modsPreset->setSettingActive(rootMod, settingID, !modsStorage->getMod(modID).keepDisabled());
+	}
+}
+
+TModList ModManager::collectDependenciesRecursive(const TModID & modID) const
+{
+	TModList result;
+	TModList toTest;
+
+	toTest.push_back(modID);
+	while (!toTest.empty())
+	{
+		TModID currentModID = toTest.back();
+		const auto & currentMod = getModDescription(currentModID);
+		toTest.pop_back();
+		result.push_back(currentModID);
+
+		if (!currentMod.isInstalled())
+			throw std::runtime_error("Unable to enable mod " + modID + "! Dependency " + currentModID + " is not installed!");
+
+		for (const auto & dependency : currentMod.getDependencies())
+		{
+			if (!vstd::contains(result, dependency))
+				toTest.push_back(dependency);
+		}
+	}
+
+	return result;
+}
+
+void ModManager::tryEnableMods(const TModList & modList)
+{
+	TModList requiredActiveMods;
+	TModList additionalActiveMods = getActiveMods();
+
+	for (const auto & modName : modList)
+	{
+		for (const auto & dependency : collectDependenciesRecursive(modName))
+		{
+			if (!vstd::contains(requiredActiveMods, dependency))
+			{
+				requiredActiveMods.push_back(dependency);
+				vstd::erase(additionalActiveMods, dependency);
+			}
+		}
+
+		assert(!vstd::contains(additionalActiveMods, modName));
+		assert(vstd::contains(requiredActiveMods, modName));// FIXME: fails on attempt to enable broken mod / translation to other language
+	}
+
+	ModDependenciesResolver testResolver(requiredActiveMods, *modsStorage);
+
+	testResolver.tryAddMods(additionalActiveMods, *modsStorage);
+
+	TModList additionalActiveSubmods;
+	for (const auto & modName : modList)
+	{
+		if (modName.find('.') != std::string::npos)
+			continue;
+
+		auto modSettings = modsPreset->getModSettings(modName);
+		for (const auto & entry : modSettings)
+		{
+			TModID fullModID = modName + '.' + entry.first;
+			if (entry.second && !vstd::contains(requiredActiveMods, fullModID))
+				additionalActiveSubmods.push_back(fullModID);
+		}
+	}
+
+	testResolver.tryAddMods(additionalActiveSubmods, *modsStorage);
+
+	for (const auto & modName : modList)
+		if (!vstd::contains(testResolver.getActiveMods(), modName))
+			throw std::runtime_error("Failed to enable mod! Mod " + modName + " remains disabled!");
+
+	updatePreset(testResolver);
+}
+
+void ModManager::tryDisableMod(const TModID & modName)
+{
+	auto desiredActiveMods = getActiveMods();
+	assert(vstd::contains(desiredActiveMods, modName));
+
+	vstd::erase(desiredActiveMods, modName);
+
+	ModDependenciesResolver testResolver(desiredActiveMods, *modsStorage);
+
+	if (vstd::contains(testResolver.getActiveMods(), modName))
+		throw std::runtime_error("Failed to disable mod! Mod " + modName + " remains enabled!");
+
+	modsPreset->setModActive(modName, false);
+	updatePreset(testResolver);
+}
+
+void ModManager::updatePreset(const ModDependenciesResolver & testResolver)
+{
+	const auto & newActiveMods = testResolver.getActiveMods();
+	const auto & newBrokenMods = testResolver.getBrokenMods();
+
+	for (const auto & modID : newActiveMods)
+	{
+		assert(vstd::contains(modsState->getInstalledMods(), modID));
+		modsPreset->setModActive(modID, true);
+	}
+
+	for (const auto & modID : newBrokenMods)
+	{
+		const auto & mod = getModDescription(modID);
+		if (vstd::contains(newActiveMods, mod.getTopParentID()))
+			modsPreset->setModActive(modID, false);
+	}
+
+	std::vector<TModID> desiredModList = modsPreset->getActiveMods();
+
+	// Try to enable all existing compatibility patches. Ignore on failure
+	for (const auto & rootMod : modsPreset->getActiveRootMods())
+	{
+		for (const auto & modSetting : modsPreset->getModSettings(rootMod))
+		{
+			if (modSetting.second)
+				continue;
+
+			TModID fullModID = rootMod + '.' + modSetting.first;
+			const auto & modDescription = modsStorage->getMod(fullModID);
+
+			if (modDescription.isCompatibility())
+				desiredModList.push_back(fullModID);
+		}
+	}
+
+	depedencyResolver = std::make_unique<ModDependenciesResolver>(desiredModList, *modsStorage);
+	modsPreset->saveConfigurationState();
+}
+
+ModDependenciesResolver::ModDependenciesResolver(const TModList & modsToResolve, const ModsStorage & storage)
+{
+	tryAddMods(modsToResolve, storage);
+}
+
+const TModList & ModDependenciesResolver::getActiveMods() const
+{
+	return activeMods;
+}
+
+const TModList & ModDependenciesResolver::getBrokenMods() const
+{
+	return brokenMods;
+}
+
+void ModDependenciesResolver::tryAddMods(TModList modsToResolve, const ModsStorage & storage)
+{
+	// Topological sort algorithm.
+	boost::range::sort(modsToResolve); // Sort mods per name
+	std::vector<TModID> sortedValidMods(activeMods.begin(), activeMods.end()); // Vector keeps order of elements (LIFO)
+	std::set<TModID> resolvedModIDs(activeMods.begin(), activeMods.end()); // Use a set for validation for performance reason, but set does not keep order of elements
+	std::set<TModID> notResolvedModIDs(modsToResolve.begin(), modsToResolve.end()); // Use a set for validation for performance reason
+
+	// Mod is resolved if it has no dependencies or all its dependencies are already resolved
+	auto isResolved = [&](const ModDescription & mod) -> bool
+	{
+		if (mod.isTranslation() && CGeneralTextHandler::getPreferredLanguage() != mod.getBaseLanguage())
+			return false;
+
+		if(mod.getDependencies().size() > resolvedModIDs.size())
+			return false;
+
+		for(const TModID & dependency : mod.getDependencies())
+			if(!vstd::contains(resolvedModIDs, dependency))
+				return false;
+
+		for(const TModID & softDependency : mod.getSoftDependencies())
+			if(vstd::contains(notResolvedModIDs, softDependency))
+				return false;
+
+		for(const TModID & conflict : mod.getConflicts())
+			if(vstd::contains(resolvedModIDs, conflict))
+				return false;
+
+		for(const TModID & reverseConflict : resolvedModIDs)
+			if(vstd::contains(storage.getMod(reverseConflict).getConflicts(), mod.getID()))
+				return false;
+
+		return true;
+	};
+
+	while(true)
+	{
+		std::set<TModID> resolvedOnCurrentTreeLevel;
+		for(auto it = modsToResolve.begin(); it != modsToResolve.end();) // One iteration - one level of mods tree
+		{
+			if(isResolved(storage.getMod(*it)))
+			{
+				resolvedOnCurrentTreeLevel.insert(*it); // Not to the resolvedModIDs, so current node children will be resolved on the next iteration
+				assert(!vstd::contains(sortedValidMods, *it));
+				sortedValidMods.push_back(*it);
+				it = modsToResolve.erase(it);
+				continue;
+			}
+			it++;
+		}
+		if(!resolvedOnCurrentTreeLevel.empty())
+		{
+			resolvedModIDs.insert(resolvedOnCurrentTreeLevel.begin(), resolvedOnCurrentTreeLevel.end());
+			for(const auto & it : resolvedOnCurrentTreeLevel)
+				notResolvedModIDs.erase(it);
+			continue;
+		}
+		// If there are no valid mods on the current mods tree level, no more mod can be resolved, should be ended.
+		break;
+	}
+
+	assert(!sortedValidMods.empty());
+	activeMods = sortedValidMods;
+	brokenMods.insert(brokenMods.end(), modsToResolve.begin(), modsToResolve.end());
+}
+
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/modding/ModManager.h vcmi/lib/modding/ModManager.h
--- vcmi-1.5.7/lib/modding/ModManager.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/modding/ModManager.h	2024-12-19 15:00:22.923148971 +0100
@@ -0,0 +1,144 @@
+/*
+ * ModManager.h, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#pragma once
+
+#include "../json/JsonNode.h"
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+class JsonNode;
+class ModDescription;
+struct CModVersion;
+
+using TModID = std::string;
+using TModList = std::vector<TModID>;
+using TModSet = std::set<TModID>;
+
+/// Provides interface to access list of locally installed mods
+class ModsState : boost::noncopyable
+{
+	TModList modList;
+
+	TModList scanModsDirectory(const std::string & modDir) const;
+
+public:
+	ModsState();
+
+	TModList getInstalledMods() const;
+	double getInstalledModSizeMegabytes(const TModID & modName) const;
+
+	uint32_t computeChecksum(const TModID & modName) const;
+};
+
+/// Provides interface to access or change current mod preset
+class ModsPresetState : boost::noncopyable
+{
+	JsonNode modConfig;
+
+	void createInitialPreset();
+	void importInitialPreset();
+
+	const JsonNode & getActivePresetConfig() const;
+
+public:
+	ModsPresetState();
+
+	void setModActive(const TModID & modName, bool isActive);
+
+	void addRootMod(const TModID & modName);
+	void eraseRootMod(const TModID & modName);
+	void removeOldMods(const TModList & modsToKeep);
+
+	void setSettingActive(const TModID & modName, const TModID & settingName, bool isActive);
+	void eraseModSetting(const TModID & modName, const TModID & settingName);
+
+	/// Returns list of all mods active in current preset. Mod order is unspecified
+	TModList getActiveMods() const;
+
+	/// Returns list of currently active root mods (non-submod)
+	TModList getActiveRootMods() const;
+
+	/// Returns list of all known settings (submods) for a specified mod
+	std::map<TModID, bool> getModSettings(const TModID & modID) const;
+	std::optional<uint32_t> getValidatedChecksum(const TModID & modName) const;
+	void setValidatedChecksum(const TModID & modName, std::optional<uint32_t> value);
+
+	void saveConfigurationState() const;
+};
+
+/// Provides access to mod properties
+class ModsStorage : boost::noncopyable
+{
+	std::map<TModID, ModDescription> mods;
+
+public:
+	ModsStorage(const TModList & modsToLoad, const JsonNode & repositoryList);
+
+	const ModDescription & getMod(const TModID & fullID) const;
+
+	TModList getAllMods() const;
+};
+
+class ModDependenciesResolver : boost::noncopyable
+{
+	/// all currently active mods, in their load order
+	TModList activeMods;
+
+	/// Mods from current preset that failed to load due to invalid dependencies
+	TModList brokenMods;
+
+public:
+	ModDependenciesResolver(const TModList & modsToResolve, const ModsStorage & storage);
+
+	void tryAddMods(TModList modsToResolve, const ModsStorage & storage);
+
+	const TModList & getActiveMods() const;
+	const TModList & getBrokenMods() const;
+};
+
+/// Provides public interface to access mod state
+class DLL_LINKAGE ModManager : boost::noncopyable
+{
+	std::unique_ptr<ModsState> modsState;
+	std::unique_ptr<ModsPresetState> modsPreset;
+	std::unique_ptr<ModsStorage> modsStorage;
+	std::unique_ptr<ModDependenciesResolver> depedencyResolver;
+
+	void generateLoadOrder(TModList desiredModList);
+	void eraseMissingModsFromPreset();
+	void addNewModsToPreset();
+	void updatePreset(const ModDependenciesResolver & newData);
+
+	TModList collectDependenciesRecursive(const TModID & modID) const;
+
+	void tryEnableMod(const TModID & modList);
+
+public:
+	ModManager(const JsonNode & repositoryList);
+	ModManager();
+	~ModManager();
+
+	const ModDescription & getModDescription(const TModID & modID) const;
+	const TModList & getActiveMods() const;
+	TModList getAllMods() const;
+
+	bool isModSettingActive(const TModID & rootModID, const TModID & modSettingID) const;
+	bool isModActive(const TModID & modID) const;
+	uint32_t computeChecksum(const TModID & modName) const;
+	std::optional<uint32_t> getValidatedChecksum(const TModID & modName) const;
+	void setValidatedChecksum(const TModID & modName, std::optional<uint32_t> value);
+	void saveConfigurationState() const;
+	double getInstalledModSizeMegabytes(const TModID & modName) const;
+
+	void tryEnableMods(const TModList & modList);
+	void tryDisableMod(const TModID & modName);
+};
+
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/modding/ModVerificationInfo.cpp vcmi/lib/modding/ModVerificationInfo.cpp
--- vcmi-1.5.7/lib/modding/ModVerificationInfo.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/modding/ModVerificationInfo.cpp	2024-12-19 15:00:22.923148971 +0100
@@ -10,9 +10,10 @@
 #include "StdInc.h"
 #include "ModVerificationInfo.h"
 
-#include "CModInfo.h"
 #include "CModHandler.h"
+#include "ModDescription.h"
 #include "ModIncompatibility.h"
+#include "ModScope.h"
 
 #include "../json/JsonNode.h"
 #include "../VCMI_Lib.h"
@@ -68,7 +69,10 @@
 		if(modList.count(m))
 			continue;
 
-		if(VLC->modh->getModInfo(m).checkModGameplayAffecting())
+		if (m == ModScope::scopeBuiltin())
+			continue;
+
+		if(VLC->modh->getModInfo(m).affectsGameplay())
 			result[m] = ModVerificationStatus::EXCESSIVE;
 	}
 
@@ -77,6 +81,9 @@
 		auto & remoteModId = infoPair.first;
 		auto & remoteModInfo = infoPair.second;
 
+		if (remoteModId == ModScope::scopeBuiltin())
+			continue;
+
 		bool modAffectsGameplay = remoteModInfo.impactsGameplay;
 		//parent mod affects gameplay if child affects too
 		for(const auto & subInfoPair : modList)
@@ -88,8 +95,8 @@
 			continue;
 		}
 
-		auto & localModInfo = VLC->modh->getModInfo(remoteModId).getVerificationInfo();
-		modAffectsGameplay |= VLC->modh->getModInfo(remoteModId).checkModGameplayAffecting();
+		const auto & localVersion = VLC->modh->getModInfo(remoteModId).getVersion();
+		modAffectsGameplay |= VLC->modh->getModInfo(remoteModId).affectsGameplay();
 
 		// skip it. Such mods should only be present in old saves or if mod changed and no longer affects gameplay
 		if (!modAffectsGameplay)
@@ -101,7 +108,7 @@
 			continue;
 		}
 
-		if(remoteModInfo.version != localModInfo.version)
+		if(remoteModInfo.version != localVersion)
 		{
 			result[remoteModId] = ModVerificationStatus::VERSION_MISMATCH;
 			continue;
diff --color -urN vcmi-1.5.7/lib/network/NetworkConnection.cpp vcmi/lib/network/NetworkConnection.cpp
--- vcmi-1.5.7/lib/network/NetworkConnection.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/network/NetworkConnection.cpp	2024-12-19 15:00:22.923148971 +0100
@@ -136,7 +136,7 @@
 
 void NetworkConnection::sendPacket(const std::vector<std::byte> & message)
 {
-	std::lock_guard<std::mutex> lock(writeMutex);
+	std::lock_guard lock(writeMutex);
 	std::vector<std::byte> headerVector(sizeof(uint32_t));
 	uint32_t messageSize = message.size();
 	std::memcpy(headerVector.data(), &messageSize, sizeof(uint32_t));
@@ -148,7 +148,7 @@
 
 		bool messageQueueEmpty = dataToSend.empty();
 		dataToSend.push_back(headerVector);
-		if (message.size() > 0)
+		if (!message.empty())
 			dataToSend.push_back(message);
 
 		if (messageQueueEmpty)
@@ -159,7 +159,7 @@
 	{
 		boost::system::error_code ec;
 		boost::asio::write(*socket, boost::asio::buffer(headerVector), ec );
-		if (message.size() > 0)
+		if (!message.empty())
 			boost::asio::write(*socket, boost::asio::buffer(message), ec );
 	}
 }
@@ -177,7 +177,7 @@
 
 void NetworkConnection::onDataSent(const boost::system::error_code & ec)
 {
-	std::lock_guard<std::mutex> lock(writeMutex);
+	std::lock_guard lock(writeMutex);
 	dataToSend.pop_front();
 	if (ec)
 	{
diff --color -urN vcmi-1.5.7/lib/network/NetworkInterface.h vcmi/lib/network/NetworkInterface.h
--- vcmi-1.5.7/lib/network/NetworkInterface.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/network/NetworkInterface.h	2024-12-19 15:00:22.924149012 +0100
@@ -40,7 +40,7 @@
 public:
 	virtual ~INetworkServer() = default;
 
-	virtual void start(uint16_t port) = 0;
+	virtual uint16_t start(uint16_t port) = 0;
 };
 
 /// Base interface that must be implemented by user of networking API to handle any connection callbacks
diff --color -urN vcmi-1.5.7/lib/network/NetworkServer.cpp vcmi/lib/network/NetworkServer.cpp
--- vcmi-1.5.7/lib/network/NetworkServer.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/network/NetworkServer.cpp	2024-12-19 15:00:22.924149012 +0100
@@ -19,16 +19,17 @@
 {
 }
 
-void NetworkServer::start(uint16_t port)
+uint16_t NetworkServer::start(uint16_t port)
 {
 	acceptor = std::make_shared<NetworkAcceptor>(*io, boost::asio::ip::tcp::endpoint(boost::asio::ip::tcp::v4(), port));
-	startAsyncAccept();
+	return startAsyncAccept();
 }
 
-void NetworkServer::startAsyncAccept()
+uint16_t NetworkServer::startAsyncAccept()
 {
 	auto upcomingConnection = std::make_shared<NetworkSocket>(*io);
 	acceptor->async_accept(*upcomingConnection, [this, upcomingConnection](const auto & ec) { connectionAccepted(upcomingConnection, ec); });
+	return acceptor->local_endpoint().port();
 }
 
 void NetworkServer::connectionAccepted(std::shared_ptr<NetworkSocket> upcomingConnection, const boost::system::error_code & ec)
diff --color -urN vcmi-1.5.7/lib/network/NetworkServer.h vcmi/lib/network/NetworkServer.h
--- vcmi-1.5.7/lib/network/NetworkServer.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/network/NetworkServer.h	2024-12-19 15:00:22.924149012 +0100
@@ -22,14 +22,14 @@
 	INetworkServerListener & listener;
 
 	void connectionAccepted(std::shared_ptr<NetworkSocket>, const boost::system::error_code & ec);
-	void startAsyncAccept();
+	uint16_t startAsyncAccept();
 
 	void onDisconnected(const std::shared_ptr<INetworkConnection> & connection, const std::string & errorMessage) override;
 	void onPacketReceived(const std::shared_ptr<INetworkConnection> & connection, const std::vector<std::byte> & message) override;
 public:
 	NetworkServer(INetworkServerListener & listener, const std::shared_ptr<NetworkContext> & context);
 
-	void start(uint16_t port) override;
+	uint16_t start(uint16_t port) override;
 };
 
 VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/networkPacks/ArtifactLocation.h vcmi/lib/networkPacks/ArtifactLocation.h
--- vcmi-1.5.7/lib/networkPacks/ArtifactLocation.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/networkPacks/ArtifactLocation.h	2024-12-19 15:00:22.924149012 +0100
@@ -37,6 +37,12 @@
 		, creature(creatureSlot)
 	{
 	}
+	ArtifactLocation(const ObjectInstanceID id, const std::optional<SlotID> creatureSlot, const ArtifactPosition & slot)
+		: artHolder(id)
+		, slot(slot)
+		, creature(creatureSlot)
+	{
+	}
 
 	template <typename Handler> void serialize(Handler & h)
 	{
diff --color -urN vcmi-1.5.7/lib/networkPacks/NetPacksBase.h vcmi/lib/networkPacks/NetPacksBase.h
--- vcmi-1.5.7/lib/networkPacks/NetPacksBase.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/networkPacks/NetPacksBase.h	2024-12-19 15:00:22.924149012 +0100
@@ -10,6 +10,7 @@
 #pragma once
 
 #include "../constants/EntityIdentifiers.h"
+#include "../serializer/Serializeable.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
@@ -18,7 +19,7 @@
 
 class ICPackVisitor;
 
-struct DLL_LINKAGE CPack
+struct DLL_LINKAGE CPack : public Serializeable
 {
 	/// Pointer to connection that pack received from
 	/// Only set & used on server
@@ -33,9 +34,6 @@
 		throw std::runtime_error("CPack serialized... this should not happen!");
 	}
 
-	void applyGs(CGameState * gs)
-	{}
-
 	void visit(ICPackVisitor & cpackVisitor);
 
 protected:
@@ -52,6 +50,8 @@
 
 struct DLL_LINKAGE CPackForClient : public CPack
 {
+	virtual void applyGs(CGameState * gs) = 0;
+
 protected:
 	void visitBasic(ICPackVisitor & cpackVisitor) override;
 };
diff --color -urN vcmi-1.5.7/lib/networkPacks/NetPacksLib.cpp vcmi/lib/networkPacks/NetPacksLib.cpp
--- vcmi-1.5.7/lib/networkPacks/NetPacksLib.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/networkPacks/NetPacksLib.cpp	2024-12-19 15:00:22.924149012 +0100
@@ -12,13 +12,14 @@
 #include "PacksForClient.h"
 #include "PacksForClientBattle.h"
 #include "PacksForServer.h"
+#include "SaveLocalState.h"
+#include "SetRewardableConfiguration.h"
 #include "StackLocation.h"
 #include "PacksForLobby.h"
 #include "SetStackEffect.h"
 #include "NetPackVisitor.h"
-#include "CGeneralTextHandler.h"
+#include "texts/CGeneralTextHandler.h"
 #include "CArtHandler.h"
-#include "CHeroHandler.h"
 #include "VCMI_Lib.h"
 #include "mapping/CMap.h"
 #include "spells/CSpellHandler.h"
@@ -27,20 +28,24 @@
 #include "gameState/TavernHeroesPool.h"
 #include "CStack.h"
 #include "battle/BattleInfo.h"
-#include "CTownHandler.h"
 #include "mapping/CMapInfo.h"
 #include "StartInfo.h"
 #include "CPlayerState.h"
 #include "TerrainHandler.h"
+#include "entities/building/CBuilding.h"
+#include "entities/building/TownFortifications.h"
+#include "mapObjects/CBank.h"
 #include "mapObjects/CGCreature.h"
 #include "mapObjects/CGMarket.h"
+#include "mapObjects/TownBuildingInstance.h"
 #include "mapObjects/CGTownInstance.h"
 #include "mapObjects/CQuest.h"
 #include "mapObjects/MiscObjects.h"
 #include "mapObjectConstructors/AObjectTypeHandler.h"
 #include "mapObjectConstructors/CObjectClassesHandler.h"
 #include "campaign/CampaignState.h"
-#include "GameSettings.h"
+#include "IGameSettings.h"
+#include "mapObjects/FlaggableMapObject.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
@@ -88,6 +93,12 @@
 	return true;
 }
 
+void SaveLocalState::visitTyped(ICPackVisitor & visitor)
+{
+	visitor.visitSaveLocalState(*this);
+}
+
+
 void PackageApplied::visitTyped(ICPackVisitor & visitor)
 {
 	visitor.visitPackageApplied(*this);
@@ -123,6 +134,16 @@
 	visitor.visitEntitiesChanged(*this);
 }
 
+void SetRewardableConfiguration::visitTyped(ICPackVisitor & visitor)
+{
+	visitor.visitSetRewardableConfiguration(*this);
+}
+
+void SetBankConfiguration::visitTyped(ICPackVisitor & visitor)
+{
+	visitor.visitSetBankConfiguration(*this);
+}
+
 void SetResources::visitTyped(ICPackVisitor & visitor)
 {
 	visitor.visitSetResources(*this);
@@ -148,6 +169,10 @@
 	visitor.visitChangeSpells(*this);
 }
 
+void SetResearchedSpells::visitTyped(ICPackVisitor & visitor)
+{
+	visitor.visitSetResearchedSpells(*this);
+}
 void SetMana::visitTyped(ICPackVisitor & visitor)
 {
 	visitor.visitSetMana(*this);
@@ -213,16 +238,6 @@
 	visitor.visitUpdateArtHandlerLists(*this);
 }
 
-void UpdateMapEvents::visitTyped(ICPackVisitor & visitor)
-{
-	visitor.visitUpdateMapEvents(*this);
-}
-
-void UpdateCastleEvents::visitTyped(ICPackVisitor & visitor)
-{
-	visitor.visitUpdateCastleEvents(*this);
-}
-
 void ChangeFormation::visitTyped(ICPackVisitor & visitor)
 {
 	visitor.visitChangeFormation(*this);
@@ -333,16 +348,11 @@
 	visitor.visitPutArtifact(*this);
 }
 
-void EraseArtifact::visitTyped(ICPackVisitor & visitor)
+void BulkEraseArtifacts::visitTyped(ICPackVisitor & visitor)
 {
 	visitor.visitEraseArtifact(*this);
 }
 
-void MoveArtifact::visitTyped(ICPackVisitor & visitor)
-{
-	visitor.visitMoveArtifact(*this);
-}
-
 void BulkMoveArtifacts::visitTyped(ICPackVisitor & visitor)
 {
 	visitor.visitBulkMoveArtifacts(*this);
@@ -583,11 +593,21 @@
 	visitor.visitBuildStructure(*this);
 }
 
+void VisitTownBuilding::visitTyped(ICPackVisitor & visitor)
+{
+	visitor.visitVisitTownBuilding(*this);
+}
+
 void RazeStructure::visitTyped(ICPackVisitor & visitor)
 {
 	visitor.visitRazeStructure(*this);
 }
 
+void SpellResearch::visitTyped(ICPackVisitor & visitor)
+{
+	visitor.visitSpellResearch(*this);
+}
+
 void RecruitCreatures::visitTyped(ICPackVisitor & visitor)
 {
 	visitor.visitRecruitCreatures(*this);
@@ -783,6 +803,11 @@
 	visitor.visitLobbySetPlayerName(*this);
 }
 
+void LobbySetPlayerHandicap::visitTyped(ICPackVisitor & visitor)
+{
+	visitor.visitLobbySetPlayerHandicap(*this);
+}
+
 void LobbySetSimturns::visitTyped(ICPackVisitor & visitor)
 {
 	visitor.visitLobbySetSimturns(*this);
@@ -818,7 +843,12 @@
 	visitor.visitLobbyPvPAction(*this);
 }
 
-void SetResources::applyGs(CGameState * gs) const
+void LobbyDelete::visitTyped(ICPackVisitor & visitor)
+{
+	visitor.visitLobbyDelete(*this);
+}
+
+void SetResources::applyGs(CGameState *gs)
 {
 	assert(player.isValidPlayer());
 	if(abs)
@@ -833,14 +863,14 @@
 	gs->getPlayerState(player)->resources.positive();
 }
 
-void SetPrimSkill::applyGs(CGameState * gs) const
+void SetPrimSkill::applyGs(CGameState *gs)
 {
 	CGHeroInstance * hero = gs->getHero(id);
 	assert(hero);
 	hero->setPrimarySkill(which, val, abs);
 }
 
-void SetSecSkill::applyGs(CGameState * gs) const
+void SetSecSkill::applyGs(CGameState *gs)
 {
 	CGHeroInstance *hero = gs->getHero(id);
 	hero->setSecSkillLevel(which, val, abs);
@@ -875,7 +905,7 @@
 	}
 }
 
-void AddQuest::applyGs(CGameState * gs) const
+void AddQuest::applyGs(CGameState *gs)
 {
 	assert (vstd::contains(gs->players, player));
 	auto * vec = &gs->players[player].quests;
@@ -885,28 +915,17 @@
 		logNetwork->warn("Warning! Attempt to add duplicated quest");
 }
 
-void UpdateArtHandlerLists::applyGs(CGameState * gs) const
+void UpdateArtHandlerLists::applyGs(CGameState *gs)
 {
 	gs->allocatedArtifacts = allocatedArtifacts;
 }
 
-void UpdateMapEvents::applyGs(CGameState * gs) const
-{
-	gs->map->events = events;
-}
-
-void UpdateCastleEvents::applyGs(CGameState * gs) const
-{
-	auto * t = gs->getTown(town);
-	t->events = events;
-}
-
-void ChangeFormation::applyGs(CGameState * gs) const
+void ChangeFormation::applyGs(CGameState *gs)
 {
 	gs->getHero(hid)->setFormation(formation);
 }
 
-void HeroVisitCastle::applyGs(CGameState * gs) const
+void HeroVisitCastle::applyGs(CGameState *gs)
 {
 	CGHeroInstance *h = gs->getHero(hid);
 	CGTownInstance *t = gs->getTown(tid);
@@ -932,7 +951,17 @@
 			hero->removeSpellFromSpellbook(sid);
 }
 
-void SetMana::applyGs(CGameState * gs) const
+void SetResearchedSpells::applyGs(CGameState *gs)
+{
+	CGTownInstance *town = gs->getTown(tid);
+
+	town->spells[level] = spells;
+	town->spellResearchCounterDay++;
+	if(accepted)
+		town->spellResearchAcceptedCounter++;
+}
+
+void SetMana::applyGs(CGameState *gs)
 {
 	CGHeroInstance * hero = gs->getHero(hid);
 
@@ -946,7 +975,7 @@
 	vstd::amax(hero->mana, 0); //not less than 0
 }
 
-void SetMovePoints::applyGs(CGameState * gs) const
+void SetMovePoints::applyGs(CGameState *gs)
 {
 	CGHeroInstance *hero = gs->getHero(hid);
 
@@ -963,7 +992,7 @@
 	TeamState * team = gs->getPlayerTeam(player);
 	auto & fogOfWarMap = team->fogOfWarMap;
 	for(const int3 & t : tiles)
-		(*fogOfWarMap)[t.z][t.x][t.y] = mode != ETileVisibility::HIDDEN;
+		fogOfWarMap[t.z][t.x][t.y] = mode != ETileVisibility::HIDDEN;
 
 	if (mode == ETileVisibility::HIDDEN) //do not hide too much
 	{
@@ -986,7 +1015,7 @@
 			}
 		}
 		for(const int3 & t : tilesRevealed) //probably not the most optimal solution ever
-			(*fogOfWarMap)[t.z][t.x][t.y] = 1;
+			fogOfWarMap[t.z][t.x][t.y] = 1;
 	}
 }
 
@@ -1030,39 +1059,39 @@
 		return;
 	}
 	gs->map->removeBlockVisTiles(obj);
-	obj->pos = nPos + obj->getVisitableOffset();
+	obj->setAnchorPos(nPos + obj->getVisitableOffset());
 	gs->map->addBlockVisTiles(obj);
 }
 
-void ChangeObjectVisitors::applyGs(CGameState * gs) const
+void ChangeObjectVisitors::applyGs(CGameState *gs)
 {
 	switch (mode) {
-		case VISITOR_ADD:
+		case VISITOR_ADD_HERO:
+			gs->getPlayerTeam(gs->getHero(hero)->tempOwner)->scoutedObjects.insert(object);
 			gs->getHero(hero)->visitedObjects.insert(object);
 			gs->getPlayerState(gs->getHero(hero)->tempOwner)->visitedObjects.insert(object);
 			break;
-		case VISITOR_ADD_TEAM:
-			{
-				TeamState *ts = gs->getPlayerTeam(gs->getHero(hero)->tempOwner);
-				for(const auto & color : ts->players)
-				{
-					gs->getPlayerState(color)->visitedObjects.insert(object);
-				}
-			}
+		case VISITOR_ADD_PLAYER:
+			gs->getPlayerTeam(gs->getHero(hero)->tempOwner)->scoutedObjects.insert(object);
+			for(const auto & color : gs->getPlayerTeam(gs->getHero(hero)->tempOwner)->players)
+				gs->getPlayerState(color)->visitedObjects.insert(object);
+
 			break;
 		case VISITOR_CLEAR:
+			// remove visit info from all heroes, including those that are not present on map
 			for (CGHeroInstance * hero : gs->map->allHeroes)
-			{
 				if (hero)
-				{
-					hero->visitedObjects.erase(object); // remove visit info from all heroes, including those that are not present on map
-				}
-			}
+					hero->visitedObjects.erase(object);
 
 			for(auto &elem : gs->players)
-			{
 				elem.second.visitedObjects.erase(object);
-			}
+
+			for(auto &elem : gs->teams)
+				elem.second.scoutedObjects.erase(object);
+
+			break;
+		case VISITOR_SCOUTED:
+			gs->getPlayerTeam(gs->getHero(hero)->tempOwner)->scoutedObjects.insert(object);
 
 			break;
 		case VISITOR_GLOBAL:
@@ -1071,13 +1100,10 @@
 				gs->getPlayerState(gs->getHero(hero)->tempOwner)->visitedObjectsGlobal.insert({objectPtr->ID, objectPtr->subID});
 				break;
 			}
-		case VISITOR_REMOVE:
-			gs->getHero(hero)->visitedObjects.erase(object);
-			break;
 	}
 }
 
-void ChangeArtifactsCostume::applyGs(CGameState * gs) const
+void ChangeArtifactsCostume::applyGs(CGameState *gs)
 {
 	auto & allCostumes = gs->getPlayerState(player)->costumesArtifacts;
 	if(const auto & costume = allCostumes.find(costumeIdx); costume != allCostumes.end())
@@ -1086,7 +1112,7 @@
 		allCostumes.try_emplace(costumeIdx, costumeSet);
 }
 
-void PlayerEndsGame::applyGs(CGameState * gs) const
+void PlayerEndsGame::applyGs(CGameState *gs)
 {
 	PlayerState *p = gs->getPlayerState(player);
 	if(victoryLossCheckResult.victory())
@@ -1159,7 +1185,6 @@
 
 void RemoveObject::applyGs(CGameState *gs)
 {
-
 	CGObjectInstance *obj = gs->getObjInstance(objectID);
 	logGlobal->debug("removing object id=%d; address=%x; name=%s", objectID, (intptr_t)obj, obj->getObjectName());
 	//unblock tiles
@@ -1172,10 +1197,7 @@
 	{
 		auto * beatenHero = dynamic_cast<CGHeroInstance *>(obj);
 		assert(beatenHero);
-		PlayerState * p = gs->getPlayerState(beatenHero->tempOwner);
 		gs->map->heroesOnMap -= beatenHero;
-		p->heroes -= beatenHero;
-
 
 		auto * siegeNode = beatenHero->whereShouldBeAttachedOnSiege(gs);
 
@@ -1188,7 +1210,7 @@
 		beatenHero->tempOwner = PlayerColor::NEUTRAL; //no one owns beaten hero
 		vstd::erase_if(beatenHero->artifactsInBackpack, [](const ArtSlotInfo& asi)
 		{
-			return asi.artifact->artType->getId() == ArtifactID::GRAIL;
+			return asi.artifact->getTypeId() == ArtifactID::GRAIL;
 		});
 
 		if(beatenHero->visitedTown)
@@ -1229,6 +1251,18 @@
 		}
 	}
 
+	if(obj->getOwner().isValidPlayer())
+	{
+		gs->getPlayerState(obj->getOwner())->removeOwnedObject(obj); //object removed via map event or hero got beaten
+
+		FlaggableMapObject* flaggableObject = dynamic_cast<FlaggableMapObject*>(obj);
+		if(flaggableObject)
+		{
+			flaggableObject->markAsDeleted();
+		}
+	}
+
+
 	gs->map->instanceNames.erase(obj->instanceName);
 	gs->map->objects[objectID.getNum()].dellNull();
 	gs->map->calculateGuardingGreaturePositions();//FIXME: excessive, update only affected tiles
@@ -1325,7 +1359,7 @@
 
 	auto & fogOfWarMap = gs->getPlayerTeam(h->getOwner())->fogOfWarMap;
 	for(const int3 & t : fowRevealed)
-		(*fogOfWarMap)[t.z][t.x][t.y] = 1;
+		fogOfWarMap[t.z][t.x][t.y] = 1;
 }
 
 void NewStructures::applyGs(CGameState *gs)
@@ -1334,21 +1368,11 @@
 
 	for(const auto & id : bid)
 	{
-		assert(t->town->buildings.at(id) != nullptr);
-		t->builtBuildings.insert(id);
-		t->updateAppearance();
-		auto currentBuilding = t->town->buildings.at(id);
-
-		if(currentBuilding->overrideBids.empty())
-			continue;
-
-		for(const auto & overrideBid : currentBuilding->overrideBids)
-		{
-			t->overriddenBuildings.insert(overrideBid);
-			t->deleteTownBonus(overrideBid);
-		}
+		assert(t->getTown()->buildings.at(id) != nullptr);
+		t->addBuilding(id);
 	}
-	t->builded = builded;
+	t->updateAppearance();
+	t->built = built;
 	t->recreateBuildingsBonuses();
 }
 
@@ -1357,7 +1381,7 @@
 	CGTownInstance *t = gs->getTown(tid);
 	for(const auto & id : bid)
 	{
-		t->builtBuildings.erase(id);
+		t->removeBuilding(id);
 
 		t->updateAppearance();
 	}
@@ -1365,14 +1389,14 @@
 	t->recreateBuildingsBonuses();
 }
 
-void SetAvailableCreatures::applyGs(CGameState * gs) const
+void SetAvailableCreatures::applyGs(CGameState *gs)
 {
 	auto * dw = dynamic_cast<CGDwelling *>(gs->getObjInstance(tid));
 	assert(dw);
 	dw->creatures = creatures;
 }
 
-void SetHeroesInTown::applyGs(CGameState * gs) const
+void SetHeroesInTown::applyGs(CGameState *gs)
 {
 	CGTownInstance *t = gs->getTown(tid);
 
@@ -1401,7 +1425,7 @@
 	}
 }
 
-void HeroRecruited::applyGs(CGameState * gs) const
+void HeroRecruited::applyGs(CGameState *gs)
 {
 	CGHeroInstance *h = gs->heroesPool->takeHeroFromPool(hid);
 	CGTownInstance *t = gs->getTown(tid);
@@ -1420,7 +1444,7 @@
 
 	h->setOwner(player);
 	h->pos = tile;
-	h->initObj(gs->getRandomGenerator());
+	h->updateAppearance();
 
 	if(h->id == ObjectInstanceID())
 	{
@@ -1431,7 +1455,7 @@
 		gs->map->objects[h->id.getNum()] = h;
 
 	gs->map->heroesOnMap.emplace_back(h);
-	p->heroes.emplace_back(h);
+	p->addOwnedObject(h);
 	h->attachTo(*p);
 	gs->map->addBlockVisTiles(h);
 
@@ -1439,7 +1463,7 @@
 		t->setVisitingHero(h);
 }
 
-void GiveHero::applyGs(CGameState * gs) const
+void GiveHero::applyGs(CGameState *gs)
 {
 	CGHeroInstance *h = gs->getHero(id);
 
@@ -1460,13 +1484,13 @@
 
 	auto oldVisitablePos = h->visitablePos();
 	gs->map->removeBlockVisTiles(h,true);
-	h->appearance = VLC->objtypeh->getHandlerFor(Obj::HERO, h->type->heroClass->getIndex())->getTemplates().front();
+	h->updateAppearance();
 
 	h->setOwner(player);
 	h->setMovementPoints(h->movementPointsLimit(true));
-	h->pos = h->convertFromVisitablePos(oldVisitablePos);
+	h->setAnchorPos(h->convertFromVisitablePos(oldVisitablePos));
 	gs->map->heroesOnMap.emplace_back(h);
-	gs->getPlayerState(h->getOwner())->heroes.emplace_back(h);
+	gs->getPlayerState(h->getOwner())->addOwnedObject(h);
 
 	gs->map->addBlockVisTiles(h);
 	h->inTownGarrison = false;
@@ -1474,74 +1498,21 @@
 
 void NewObject::applyGs(CGameState *gs)
 {
-	TerrainId terrainType = ETerrainId::NONE;
-
-	if (!gs->isInTheMap(targetPos))
-	{
-		logGlobal->error("Attempt to create object outside map at %s!", targetPos.toString());
-		return;
-	}
-
-	const TerrainTile & t = gs->map->getTile(targetPos);
-	terrainType = t.terType->getId();
-
-	auto handler = VLC->objtypeh->getHandlerFor(ID, subID);
-
-	CGObjectInstance * o = handler->create(gs->callback, nullptr);
-	handler->configureObject(o, gs->getRandomGenerator());
-	assert(o->ID == this->ID);
-	
-	if (ID == Obj::MONSTER) //probably more options will be needed
-	{
-		//CStackInstance hlp;
-		auto * cre = dynamic_cast<CGCreature *>(o);
-		//cre->slots[0] = hlp;
-		assert(cre);
-		cre->notGrowingTeam = cre->neverFlees = false;
-		cre->character = 2;
-		cre->gainedArtifact = ArtifactID::NONE;
-		cre->identifier = -1;
-		cre->addToSlot(SlotID(0), new CStackInstance(subID.getNum(), -1)); //add placeholder stack
-	}
-
-	assert(!handler->getTemplates(terrainType).empty());
-	if (handler->getTemplates().empty())
-	{
-		logGlobal->error("Attempt to create object (%d %d) with no templates!", ID, subID.getNum());
-		return;
-	}
-
-	if (!handler->getTemplates(terrainType).empty())
-		o->appearance = handler->getTemplates(terrainType).front();
-	else
-		o->appearance = handler->getTemplates().front();
+	newObject->id = ObjectInstanceID(static_cast<si32>(gs->map->objects.size()));
 
-	o->id = ObjectInstanceID(static_cast<si32>(gs->map->objects.size()));
-	o->pos = targetPos + o->getVisitableOffset();
-
-	gs->map->objects.emplace_back(o);
-	gs->map->addBlockVisTiles(o);
-	o->initObj(gs->getRandomGenerator());
+	gs->map->objects.emplace_back(newObject);
+	gs->map->addBlockVisTiles(newObject);
 	gs->map->calculateGuardingGreaturePositions();
 
-	createdObjectID = o->id;
-
-	logGlobal->debug("Added object id=%d; address=%x; name=%s", o->id, (intptr_t)o, o->getObjectName());
+	logGlobal->debug("Added object id=%d; name=%s", newObject->id, newObject->getObjectName());
 }
 
 void NewArtifact::applyGs(CGameState *gs)
 {
-	assert(!vstd::contains(gs->map->artInstances, art));
-	assert(!art->getParentNodes().size());
-	assert(art->artType);
-
-	art->setType(art->artType);
-	if(art->isCombined())
-	{
-		for(const auto & part : art->artType->getConstituents())
-			art->addPart(ArtifactUtils::createNewArtifactInstance(part), ArtifactPosition::PRE_FIRST);
-	}
+	auto art = ArtifactUtils::createArtifact(artId, spellId);
 	gs->map->addNewArtifactInstance(art);
+	PutArtifact pa(art->getId(), ArtifactLocation(artHolder, pos), false);
+	pa.applyGs(gs);
 }
 
 const CStackInstance * StackLocation::getStack()
@@ -1575,7 +1546,7 @@
 	}
 };
 
-void ChangeStackCount::applyGs(CGameState * gs)
+void ChangeStackCount::applyGs(CGameState *gs)
 {
 	auto * srcObj = gs->getArmyInstance(army);
 	if(!srcObj)
@@ -1587,7 +1558,7 @@
 		srcObj->changeStackCount(slot, count);
 }
 
-void SetStackType::applyGs(CGameState * gs)
+void SetStackType::applyGs(CGameState *gs)
 {
 	auto * srcObj = gs->getArmyInstance(army);
 	if(!srcObj)
@@ -1596,7 +1567,7 @@
 	srcObj->setStackType(slot, type);
 }
 
-void EraseStack::applyGs(CGameState * gs)
+void EraseStack::applyGs(CGameState *gs)
 {
 	auto * srcObj = gs->getArmyInstance(army);
 	if(!srcObj)
@@ -1605,7 +1576,7 @@
 	srcObj->eraseStack(slot);
 }
 
-void SwapStacks::applyGs(CGameState * gs)
+void SwapStacks::applyGs(CGameState *gs)
 {
 	auto * srcObj = gs->getArmyInstance(srcArmy);
 	if(!srcObj)
@@ -1630,7 +1601,7 @@
 		throw std::runtime_error("InsertNewStack: invalid army object " + std::to_string(army.getNum()) + ", possible game state corruption.");
 }
 
-void RebalanceStacks::applyGs(CGameState * gs)
+void RebalanceStacks::applyGs(CGameState *gs)
 {
 	auto * srcObj = gs->getArmyInstance(srcArmy);
 	if(!srcObj)
@@ -1645,7 +1616,7 @@
 
 	const CCreature * srcType = src.army->getCreature(src.slot);
 	TQuantity srcCount = src.army->getStackCount(src.slot);
-	bool stackExp = VLC->settings()->getBoolean(EGameSettings::MODULE_STACK_EXPERIENCE);
+	bool stackExp = gs->getSettings().getBoolean(EGameSettings::MODULE_STACK_EXPERIENCE);
 
 	if(srcCount == count) //moving whole stack
 	{
@@ -1659,30 +1630,31 @@
 			const auto dstHero = dynamic_cast<CGHeroInstance*>(dst.army.get());
 			auto srcStack = const_cast<CStackInstance*>(src.getStack());
 			auto dstStack = const_cast<CStackInstance*>(dst.getStack());
-			if(auto srcArt = srcStack->getArt(ArtifactPosition::CREATURE_SLOT))
+			if(srcStack->getArt(ArtifactPosition::CREATURE_SLOT))
 			{
 				if(auto dstArt = dstStack->getArt(ArtifactPosition::CREATURE_SLOT))
 				{
 					auto dstSlot = ArtifactUtils::getArtBackpackPosition(srcHero, dstArt->getTypeId());
 					if(srcHero && dstSlot != ArtifactPosition::PRE_FIRST)
 					{
-						dstArt->move(*dstStack, ArtifactPosition::CREATURE_SLOT, *srcHero, dstSlot);
+						gs->map->moveArtifactInstance(*dstStack, ArtifactPosition::CREATURE_SLOT, *srcHero, dstSlot);
 					}
-					//else - artifact cna be lost :/
+					//else - artifact can be lost :/
 					else
 					{
-						EraseArtifact ea;
-						ea.al = ArtifactLocation(dstHero->id, ArtifactPosition::CREATURE_SLOT);
-						ea.al.creature = dst.slot;
+						BulkEraseArtifacts ea;
+						ea.artHolder = dstHero->id;
+						ea.posPack.emplace_back(ArtifactPosition::CREATURE_SLOT);
+						ea.creature = dst.slot;
 						ea.applyGs(gs);
 						logNetwork->warn("Cannot move artifact! No free slots");
 					}
-					srcArt->move(*srcStack, ArtifactPosition::CREATURE_SLOT, *dstStack, ArtifactPosition::CREATURE_SLOT);
+					gs->map->moveArtifactInstance(*srcStack, ArtifactPosition::CREATURE_SLOT, *dstStack, ArtifactPosition::CREATURE_SLOT);
 					//TODO: choose from dialog
 				}
 				else //just move to the other slot before stack gets erased
 				{
-					srcArt->move(*srcStack, ArtifactPosition::CREATURE_SLOT, *dstStack, ArtifactPosition::CREATURE_SLOT);
+					gs->map->moveArtifactInstance(*srcStack, ArtifactPosition::CREATURE_SLOT, *dstStack, ArtifactPosition::CREATURE_SLOT);
 				}
 			}
 			if (stackExp)
@@ -1735,13 +1707,13 @@
 	CBonusSystemNode::treeHasChanged();
 }
 
-void BulkRebalanceStacks::applyGs(CGameState * gs)
+void BulkRebalanceStacks::applyGs(CGameState *gs)
 {
 	for(auto & move : moves)
 		move.applyGs(gs);
 }
 
-void BulkSmartRebalanceStacks::applyGs(CGameState * gs)
+void BulkSmartRebalanceStacks::applyGs(CGameState *gs)
 {
 	for(auto & move : moves)
 		move.applyGs(gs);
@@ -1752,62 +1724,58 @@
 
 void PutArtifact::applyGs(CGameState *gs)
 {
-	// Ensure that artifact has been correctly added via NewArtifact pack
-	assert(vstd::contains(gs->map->artInstances, art));
+	auto art = gs->getArtInstance(id);
 	assert(!art->getParentNodes().empty());
 	auto hero = gs->getHero(al.artHolder);
 	assert(hero);
 	assert(art && art->canBePutAt(hero, al.slot));
-	art->putAt(*hero, al.slot);
+	assert(ArtifactUtils::checkIfSlotValid(*hero, al.slot));
+	gs->map->putArtifactInstance(*hero, art, al.slot);
 }
 
-void EraseArtifact::applyGs(CGameState *gs)
+void BulkEraseArtifacts::applyGs(CGameState *gs)
 {
-	const auto artSet = gs->getArtSet(al.artHolder);
+	const auto artSet = gs->getArtSet(artHolder);
 	assert(artSet);
-	const auto slot = artSet->getSlot(al.slot);
-	if(slot->locked)
+
+	std::sort(posPack.begin(), posPack.end(), [](const ArtifactPosition & slot0, const ArtifactPosition & slot1) -> bool
+		{
+			return slot0.num > slot1.num;
+		});
+
+	for(const auto & slot : posPack)
 	{
-		logGlobal->debug("Erasing locked artifact: %s", slot->artifact->artType->getNameTranslated());
-		DisassembledArtifact dis;
-		dis.al.artHolder = al.artHolder;
-		
-		for(auto & slotInfo : artSet->artifactsWorn)
+		const auto slotInfo = artSet->getSlot(slot);
+		if(slotInfo->locked)
 		{
-			auto art = slotInfo.second.artifact;
-			if(art->isCombined() && art->isPart(slot->artifact))
+			logGlobal->debug("Erasing locked artifact: %s", slotInfo->artifact->getType()->getNameTranslated());
+			DisassembledArtifact dis;
+			dis.al.artHolder = artHolder;
+
+			for(auto & slotInfoWorn : artSet->artifactsWorn)
 			{
-				dis.al.slot = artSet->getArtPos(art);
-				break;
+				auto art = slotInfoWorn.second.artifact;
+				if(art->isCombined() && art->isPart(slotInfo->artifact))
+				{
+					dis.al.slot = artSet->getArtPos(art);
+					break;
+				}
 			}
+			assert((dis.al.slot != ArtifactPosition::PRE_FIRST) && "Failed to determine the assembly this locked artifact belongs to");
+			logGlobal->debug("Found the corresponding assembly: %s", artSet->getArt(dis.al.slot)->getType()->getNameTranslated());
+			dis.applyGs(gs);
 		}
-		assert((dis.al.slot != ArtifactPosition::PRE_FIRST) && "Failed to determine the assembly this locked artifact belongs to");
-		logGlobal->debug("Found the corresponding assembly: %s", artSet->getArt(dis.al.slot)->artType->getNameTranslated());
-		dis.applyGs(gs);
-	}
-	else
-	{
-		logGlobal->debug("Erasing artifact %s", slot->artifact->artType->getNameTranslated());
+		else
+		{
+			logGlobal->debug("Erasing artifact %s", slotInfo->artifact->getType()->getNameTranslated());
+		}
+		gs->map->removeArtifactInstance(*artSet, slot);
 	}
-	auto art = artSet->getArt(al.slot);
-	assert(art);
-	art->removeFrom(*artSet, al.slot);
-}
-
-void MoveArtifact::applyGs(CGameState * gs)
-{
-	auto srcHero = gs->getArtSet(src);
-	auto dstHero = gs->getArtSet(dst);
-	assert(srcHero);
-	assert(dstHero);
-	auto art = srcHero->getArt(src.slot);
-	assert(art && art->canBePutAt(dstHero, dst.slot));
-	art->move(*srcHero, src.slot, *dstHero, dst.slot);
 }
 
-void BulkMoveArtifacts::applyGs(CGameState * gs)
+void BulkMoveArtifacts::applyGs(CGameState *gs)
 {
-	const auto bulkArtsRemove = [](std::vector<LinkedSlots> & artsPack, CArtifactSet & artSet)
+	const auto bulkArtsRemove = [gs](std::vector<LinkedSlots> & artsPack, CArtifactSet & artSet)
 	{
 		std::vector<ArtifactPosition> packToRemove;
 		for(const auto & slotsPair : artsPack)
@@ -1818,20 +1786,16 @@
 			});
 
 		for(const auto & slot : packToRemove)
-		{
-			auto * art = artSet.getArt(slot);
-			assert(art);
-			art->removeFrom(artSet, slot);
-		}
+			gs->map->removeArtifactInstance(artSet, slot);
 	};
 
-	const auto bulkArtsPut = [](std::vector<LinkedSlots> & artsPack, CArtifactSet & initArtSet, CArtifactSet & dstArtSet)
+	const auto bulkArtsPut = [gs](std::vector<LinkedSlots> & artsPack, CArtifactSet & initArtSet, CArtifactSet & dstArtSet)
 	{
 		for(const auto & slotsPair : artsPack)
 		{
 			auto * art = initArtSet.getArt(slotsPair.srcPos);
 			assert(art);
-			art->putAt(dstArtSet, slotsPair.dstPos);
+			gs->map->putArtifactInstance(dstArtSet, art, slotsPair.dstPos);
 		}
 	};
 	
@@ -1852,72 +1816,71 @@
 
 void AssembledArtifact::applyGs(CGameState *gs)
 {
-	auto hero = gs->getHero(al.artHolder);
-	assert(hero);
-	const auto transformedArt = hero->getArt(al.slot);
+	auto artSet = gs->getArtSet(al.artHolder);
+	assert(artSet);
+	const auto transformedArt = artSet->getArt(al.slot);
 	assert(transformedArt);
-	assert(vstd::contains_if(ArtifactUtils::assemblyPossibilities(hero, transformedArt->getTypeId()), [=](const CArtifact * art)->bool
+	const auto builtArt = artId.toArtifact();
+	assert(vstd::contains_if(ArtifactUtils::assemblyPossibilities(artSet, transformedArt->getTypeId()), [=](const CArtifact * art)->bool
 		{
 			return art->getId() == builtArt->getId();
 		}));
 
-	const auto transformedArtSlot = hero->getSlotByInstance(transformedArt);
 	auto * combinedArt = new CArtifactInstance(builtArt);
 	gs->map->addNewArtifactInstance(combinedArt);
 
 	// Find slots for all involved artifacts
-	std::vector<ArtifactPosition> slotsInvolved;
-	for(const auto constituent : builtArt->getConstituents())
+	std::set<ArtifactPosition, std::greater<>> slotsInvolved = { al.slot };
+	CArtifactFittingSet fittingSet(*artSet);
+	auto parts = builtArt->getConstituents();
+	parts.erase(std::find(parts.begin(), parts.end(), transformedArt->getType()));
+	for(const auto constituent : parts)
 	{
-		ArtifactPosition slot;
-		if(transformedArt->getTypeId() == constituent->getId())
-			slot = transformedArtSlot;
-		else
-			slot = hero->getArtPos(constituent->getId(), false, false);
-
+		const auto slot = fittingSet.getArtPos(constituent->getId(), false, false);
+		fittingSet.lockSlot(slot);
 		assert(slot != ArtifactPosition::PRE_FIRST);
-		slotsInvolved.emplace_back(slot);
+		slotsInvolved.insert(slot);
 	}
-	std::sort(slotsInvolved.begin(), slotsInvolved.end(), std::greater<>());
 
 	// Find a slot for combined artifact
-	al.slot = transformedArtSlot;
-	for(const auto slot : slotsInvolved)
+	if(ArtifactUtils::isSlotEquipment(al.slot) && ArtifactUtils::isSlotBackpack(*slotsInvolved.begin()))
 	{
-		if(ArtifactUtils::isSlotEquipment(transformedArtSlot))
-		{
-
+		al.slot = ArtifactPosition::BACKPACK_START;
+	}
+	else if(ArtifactUtils::isSlotBackpack(al.slot))
+	{
+		for(const auto & slot : slotsInvolved)
 			if(ArtifactUtils::isSlotBackpack(slot))
+				al.slot = slot;
+	}
+	else
+	{
+		for(const auto & slot : slotsInvolved)
+			if(!vstd::contains(builtArt->getPossibleSlots().at(artSet->bearerType()), al.slot)
+				&& vstd::contains(builtArt->getPossibleSlots().at(artSet->bearerType()), slot))
 			{
-				al.slot = ArtifactPosition::BACKPACK_START;
+				al.slot = slot;
 				break;
 			}
-
-			if(!vstd::contains(combinedArt->artType->getPossibleSlots().at(hero->bearerType()), al.slot)
-				&& vstd::contains(combinedArt->artType->getPossibleSlots().at(hero->bearerType()), slot))
-				al.slot = slot;
-		}
-		else
-		{
-			if(ArtifactUtils::isSlotBackpack(slot))
-				al.slot = std::min(al.slot, slot);
-		}
 	}
 
 	// Delete parts from hero
-	for(const auto slot : slotsInvolved)
+	for(const auto & slot : slotsInvolved)
 	{
-		const auto constituentInstance = hero->getArt(slot);
-		constituentInstance->removeFrom(*hero, slot);
+		const auto constituentInstance = artSet->getArt(slot);
+		gs->map->removeArtifactInstance(*artSet, slot);
 
-		if(ArtifactUtils::isSlotEquipment(al.slot) && slot != al.slot)
-			combinedArt->addPart(constituentInstance, slot);
-		else
-			combinedArt->addPart(constituentInstance, ArtifactPosition::PRE_FIRST);
+		if(!combinedArt->getType()->isFused())
+		{
+			if(ArtifactUtils::isSlotEquipment(al.slot) && slot != al.slot)
+				combinedArt->addPart(constituentInstance, slot);
+			else
+				combinedArt->addPart(constituentInstance, ArtifactPosition::PRE_FIRST);
+		}
 	}
 
 	// Put new combined artifacts
-	combinedArt->putAt(*hero, al.slot);
+	gs->map->putArtifactInstance(*artSet, combinedArt, al.slot);
 }
 
 void DisassembledArtifact::applyGs(CGameState *gs)
@@ -1927,14 +1890,14 @@
 	auto disassembledArt = hero->getArt(al.slot);
 	assert(disassembledArt);
 
-	auto parts = disassembledArt->getPartsInfo();
-	disassembledArt->removeFrom(*hero, al.slot);
+	const auto parts = disassembledArt->getPartsInfo();
+	gs->map->removeArtifactInstance(*hero, al.slot);
 	for(auto & part : parts)
 	{
 		// ArtifactPosition::PRE_FIRST is value of main part slot -> it'll replace combined artifact in its pos
 		auto slot = (ArtifactUtils::isSlotEquipment(part.slot) ? part.slot : al.slot);
 		disassembledArt->detachFrom(*part.art);
-		part.art->putAt(*hero, slot);
+		gs->map->putArtifactInstance(*hero, part.art, slot);
 	}
 	gs->map->eraseArtifactInstance(disassembledArt);
 }
@@ -1943,7 +1906,7 @@
 {
 }
 
-void SetAvailableArtifacts::applyGs(CGameState * gs) const
+void SetAvailableArtifacts::applyGs(CGameState *gs)
 {
 	if(id != ObjectInstanceID::NONE)
 	{
@@ -1972,39 +1935,34 @@
 	gs->globalEffects.reduceBonusDurations(Bonus::OneWeek);
 	//TODO not really a single root hierarchy, what about bonuses placed elsewhere? [not an issue with H3 mechanics but in the future...]
 
-	for(const NewTurn::Hero & h : heroes) //give mana/movement point
-	{
-		CGHeroInstance *hero = gs->getHero(h.id);
-		if(!hero)
-		{
-			logGlobal->error("Hero %d not found in NewTurn::applyGs", h.id.getNum());
-			continue;
-		}
+	for(auto & manaPack : heroesMana)
+		manaPack.applyGs(gs);
 
-		hero->setMovementPoints(h.move);
-		hero->mana = h.mana;
-	}
+	for(auto & movePack : heroesMovement)
+		movePack.applyGs(gs);
 
 	gs->heroesPool->onNewDay();
 
-	for(const auto & re : res)
+	for(auto & entry : playerIncome)
 	{
-		assert(re.first.isValidPlayer());
-		gs->getPlayerState(re.first)->resources = re.second;
-		gs->getPlayerState(re.first)->resources.amin(GameConstants::PLAYER_RESOURCES_CAP);
+		gs->getPlayerState(entry.first)->resources += entry.second;
+		gs->getPlayerState(entry.first)->resources.amin(GameConstants::PLAYER_RESOURCES_CAP);
 	}
 
-	for(const auto & creatureSet : cres) //set available creatures in towns
-		creatureSet.second.applyGs(gs);
+	for(auto & creatureSet : availableCreatures) //set available creatures in towns
+		creatureSet.applyGs(gs);
 
 	for(CGTownInstance* t : gs->map->towns)
-		t->builded = 0;
+	{
+		t->built = 0;
+		t->spellResearchCounterDay = 0;
+	}
 
-	if(gs->getDate(Date::DAY_OF_WEEK) == 1)
-		gs->updateRumor();
+	if(newRumor)
+		gs->currentRumor = *newRumor;
 }
 
-void SetObjectProperty::applyGs(CGameState * gs) const
+void SetObjectProperty::applyGs(CGameState *gs)
 {
 	CGObjectInstance *obj = gs->getObjInstance(id);
 	if(!obj)
@@ -2014,6 +1972,18 @@
 	}
 
 	auto * cai = dynamic_cast<CArmedInstance *>(obj);
+
+	if(what == ObjProperty::OWNER && obj->asOwnable())
+	{
+		PlayerColor oldOwner = obj->getOwner();
+		PlayerColor newOwner = identifier.as<PlayerColor>();
+		if(oldOwner.isValidPlayer())
+			gs->getPlayerState(oldOwner)->removeOwnedObject(obj);;
+
+		if(newOwner.isValidPlayer())
+			gs->getPlayerState(newOwner)->addOwnedObject(obj);;
+	}
+
 	if(what == ObjProperty::OWNER && cai)
 	{
 		if(obj->ID == Obj::TOWN)
@@ -2025,17 +1995,13 @@
 			if(oldOwner.isValidPlayer())
 			{
 				auto * state = gs->getPlayerState(oldOwner);
-				state->towns -= t;
-
-				if(state->towns.empty())
+				if(state->getTowns().empty())
 					state->daysWithoutCastle = 0;
 			}
 			if(identifier.as<PlayerColor>().isValidPlayer())
 			{
-				PlayerState * p = gs->getPlayerState(identifier.as<PlayerColor>());
-				p->towns.emplace_back(t);
-
 				//reset counter before NewTurn to avoid no town message if game loaded at turn when one already captured
+				PlayerState * p = gs->getPlayerState(identifier.as<PlayerColor>());
 				if(p->daysWithoutCastle)
 					p->daysWithoutCastle = std::nullopt;
 			}
@@ -2052,14 +2018,14 @@
 	}
 }
 
-void HeroLevelUp::applyGs(CGameState * gs) const
+void HeroLevelUp::applyGs(CGameState *gs)
 {
 	auto * hero = gs->getHero(heroId);
 	assert(hero);
 	hero->levelUp(skills);
 }
 
-void CommanderLevelUp::applyGs(CGameState * gs) const
+void CommanderLevelUp::applyGs(CGameState *gs)
 {
 	auto * hero = gs->getHero(heroId);
 	assert(hero);
@@ -2068,7 +2034,7 @@
 	commander->levelUp();
 }
 
-void BattleStart::applyGs(CGameState * gs) const
+void BattleStart::applyGs(CGameState *gs)
 {
 	assert(battleID == gs->nextBattleID);
 
@@ -2080,17 +2046,17 @@
 	gs->nextBattleID = BattleID(gs->nextBattleID.getNum() + 1);
 }
 
-void BattleNextRound::applyGs(CGameState * gs) const
+void BattleNextRound::applyGs(CGameState *gs)
 {
 	gs->getBattle(battleID)->nextRound();
 }
 
-void BattleSetActiveStack::applyGs(CGameState * gs) const
+void BattleSetActiveStack::applyGs(CGameState *gs)
 {
 	gs->getBattle(battleID)->nextTurn(stack);
 }
 
-void BattleTriggerEffect::applyGs(CGameState * gs) const
+void BattleTriggerEffect::applyGs(CGameState *gs)
 {
 	CStack * st = gs->getBattle(battleID)->getStack(stackID);
 	assert(st);
@@ -2129,13 +2095,13 @@
 	}
 }
 
-void BattleUpdateGateState::applyGs(CGameState * gs) const
+void BattleUpdateGateState::applyGs(CGameState *gs)
 {
 	if(gs->getBattle(battleID))
 		gs->getBattle(battleID)->si.gateState = state;
 }
 
-void BattleCancelled::applyGs(CGameState * gs) const
+void BattleCancelled::applyGs(CGameState *gs)
 {
 	auto currentBattle = boost::range::find_if(gs->currentBattles, [&](const auto & battle)
 	{
@@ -2146,7 +2112,7 @@
 	gs->currentBattles.erase(currentBattle);
 }
 
-void BattleResultAccepted::applyGs(CGameState * gs) const
+void BattleResultAccepted::applyGs(CGameState *gs)
 {
 	// Remove any "until next battle" bonuses
 	for(auto & res : heroResult)
@@ -2155,7 +2121,7 @@
 			res.hero->removeBonusesRecursive(Bonus::OneBattle);
 	}
 
-	if(winnerSide != 2)
+	if(winnerSide != BattleSide::NONE)
 	{
 		// Grow up growing artifacts
 		const auto hero = heroResult[winnerSide].hero;
@@ -2174,12 +2140,12 @@
 		}
 	}
 
-	if(VLC->settings()->getBoolean(EGameSettings::MODULE_STACK_EXPERIENCE))
+	if(gs->getSettings().getBoolean(EGameSettings::MODULE_STACK_EXPERIENCE))
 	{
-		if(heroResult[0].army)
-			heroResult[0].army->giveStackExp(heroResult[0].exp);
-		if(heroResult[1].army)
-			heroResult[1].army->giveStackExp(heroResult[1].exp);
+		if(heroResult[BattleSide::ATTACKER].army)
+			heroResult[BattleSide::ATTACKER].army->giveStackExp(heroResult[BattleSide::ATTACKER].exp);
+		if(heroResult[BattleSide::DEFENDER].army)
+			heroResult[BattleSide::DEFENDER].army->giveStackExp(heroResult[BattleSide::DEFENDER].exp);
 		CBonusSystemNode::treeHasChanged();
 	}
 
@@ -2212,7 +2178,7 @@
 	battleState->moveUnit(stack, tilesToMove.back());
 }
 
-void BattleStackAttacked::applyGs(CGameState * gs)
+void BattleStackAttacked::applyGs(CGameState *gs)
 {
 	applyBattle(gs->getBattle(battleID));
 }
@@ -2222,7 +2188,7 @@
 	battleState->setUnitState(newState.id, newState.data, newState.healthDelta);
 }
 
-void BattleAttack::applyGs(CGameState * gs)
+void BattleAttack::applyGs(CGameState *gs)
 {
 	CStack * attacker = gs->getBattle(battleID)->getStack(stackAttacking);
 	assert(attacker);
@@ -2277,25 +2243,21 @@
 				st->waiting = false;
 				st->defendingAnim = false;
 				st->movedThisRound = true;
+				st->castSpellThisTurn = ba.actionType == EActionType::MONSTER_SPELL;
 				break;
 		}
 	}
 	else
 	{
 		if(ba.actionType == EActionType::HERO_SPELL)
-			gs->getBattle(battleID)->sides[ba.side].usedSpellsHistory.push_back(ba.spell);
+			gs->getBattle(battleID)->getSide(ba.side).usedSpellsHistory.push_back(ba.spell);
 	}
 }
 
-void BattleSpellCast::applyGs(CGameState * gs) const
+void BattleSpellCast::applyGs(CGameState *gs)
 {
-	if(castByHero)
-	{
-		if(side < 2)
-		{
-			gs->getBattle(battleID)->sides[side].castSpellsCount++;
-		}
-	}
+	if(castByHero && side != BattleSide::NONE)
+		gs->getBattle(battleID)->getSide(side).castSpellsCount++;
 }
 
 void SetStackEffect::applyGs(CGameState *gs)
@@ -2357,7 +2319,7 @@
 	}
 }
 
-void BattleObstaclesChanged::applyGs(CGameState * gs)
+void BattleObstaclesChanged::applyGs(CGameState *gs)
 {
 	applyBattle(gs->getBattle(battleID));
 }
@@ -2388,7 +2350,7 @@
 
 CatapultAttack::~CatapultAttack() = default;
 
-void CatapultAttack::applyGs(CGameState * gs)
+void CatapultAttack::applyGs(CGameState *gs)
 {
 	applyBattle(gs->getBattle(battleID));
 }
@@ -2404,7 +2366,7 @@
 	if(!town)
 		return;
 
-	if(town->fortLevel() == CGTownInstance::NONE)
+	if(town->fortificationsLevel().wallsHealth == 0)
 		return;
 
 	for(const auto & part : attackedParts)
@@ -2414,7 +2376,7 @@
 	}
 }
 
-void BattleSetStackProperty::applyGs(CGameState * gs) const
+void BattleSetStackProperty::applyGs(CGameState *gs)
 {
 	CStack * stack = gs->getBattle(battleID)->getStack(stackID, false);
 	switch(which)
@@ -2429,7 +2391,7 @@
 		}
 		case ENCHANTER_COUNTER:
 		{
-			auto & counter = gs->getBattle(battleID)->sides[gs->getBattle(battleID)->whatSide(stack->unitOwner())].enchanterCounter;
+			auto & counter = gs->getBattle(battleID)->getSide(gs->getBattle(battleID)->whatSide(stack->unitOwner())).enchanterCounter;
 			if(absolute)
 				counter = val;
 			else
@@ -2455,7 +2417,7 @@
 	}
 }
 
-void PlayerCheated::applyGs(CGameState * gs) const
+void PlayerCheated::applyGs(CGameState *gs)
 {
 	if(!player.isValidPlayer())
 		return;
@@ -2465,43 +2427,76 @@
 	gs->getPlayerState(player)->cheated = true;
 }
 
-void PlayerStartsTurn::applyGs(CGameState * gs) const
+void PlayerStartsTurn::applyGs(CGameState *gs)
 {
 	//assert(gs->actingPlayers.count(player) == 0);//Legal - may happen after loading of deserialized map state
 	gs->actingPlayers.insert(player);
 }
 
-void PlayerEndsTurn::applyGs(CGameState * gs) const
+void PlayerEndsTurn::applyGs(CGameState *gs)
 {
 	assert(gs->actingPlayers.count(player) == 1);
 	gs->actingPlayers.erase(player);
 }
 
-void DaysWithoutTown::applyGs(CGameState * gs) const
+void DaysWithoutTown::applyGs(CGameState *gs)
 {
 	auto & playerState = gs->players[player];
 	playerState.daysWithoutCastle = daysWithoutCastle;
 }
 
-void TurnTimeUpdate::applyGs(CGameState *gs) const
+void TurnTimeUpdate::applyGs(CGameState *gs)
 {
 	auto & playerState = gs->players[player];
 	playerState.turnTimer = turnTimer;
 }
 
-void EntitiesChanged::applyGs(CGameState * gs)
+void EntitiesChanged::applyGs(CGameState *gs)
 {
 	for(const auto & change : changes)
 		gs->updateEntity(change.metatype, change.entityIndex, change.data);
 }
 
+void SetRewardableConfiguration::applyGs(CGameState *gs)
+{
+	auto * objectPtr = gs->getObjInstance(objectID);
+
+	if (!buildingID.hasValue())
+	{
+		auto * rewardablePtr = dynamic_cast<CRewardableObject *>(objectPtr);
+		assert(rewardablePtr);
+		rewardablePtr->configuration = configuration;
+		rewardablePtr->initializeGuards();
+	}
+	else
+	{
+		auto * townPtr = dynamic_cast<CGTownInstance*>(objectPtr);
+		TownBuildingInstance * buildingPtr = nullptr;
+
+		for (auto & building : townPtr->rewardableBuildings)
+			if (building.second->getBuildingType() == buildingID)
+				buildingPtr = building.second;
+
+		auto * rewardablePtr = dynamic_cast<TownRewardableBuildingInstance *>(buildingPtr);
+		assert(rewardablePtr);
+		rewardablePtr->configuration = configuration;
+	}
+}
+
+void SetBankConfiguration::applyGs(CGameState *gs)
+{
+	auto * objectPtr = gs->getObjInstance(objectID);
+	auto * bankPtr = dynamic_cast<CBank *>(objectPtr);
+
+	assert(bankPtr);
+
+	bankPtr->setConfig(configuration);
+}
+
 const CArtifactInstance * ArtSlotInfo::getArt() const
 {
 	if(locked)
-	{
-		logNetwork->warn("ArtifactLocation::getArt: This location is locked!");
 		return nullptr;
-	}
 	return artifact;
 }
 
diff --color -urN vcmi-1.5.7/lib/networkPacks/NetPackVisitor.h vcmi/lib/networkPacks/NetPackVisitor.h
--- vcmi-1.5.7/lib/networkPacks/NetPackVisitor.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/networkPacks/NetPackVisitor.h	2024-12-19 15:00:22.924149012 +0100
@@ -13,6 +13,8 @@
 #include "PacksForClientBattle.h"
 #include "PacksForServer.h"
 #include "PacksForLobby.h"
+#include "SaveLocalState.h"
+#include "SetRewardableConfiguration.h"
 #include "SetStackEffect.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
@@ -34,11 +36,14 @@
 	virtual void visitTurnTimeUpdate(TurnTimeUpdate & pack) {}
 	virtual void visitGamePause(GamePause & pack) {}
 	virtual void visitEntitiesChanged(EntitiesChanged & pack) {}
+	virtual void visitSetRewardableConfiguration(SetRewardableConfiguration & pack) {}
+	virtual void visitSetBankConfiguration(SetBankConfiguration & pack) {}
 	virtual void visitSetResources(SetResources & pack) {}
 	virtual void visitSetPrimSkill(SetPrimSkill & pack) {}
 	virtual void visitSetSecSkill(SetSecSkill & pack) {}
 	virtual void visitHeroVisitCastle(HeroVisitCastle & pack) {}
 	virtual void visitChangeSpells(ChangeSpells & pack) {}
+	virtual void visitSetResearchedSpells(SetResearchedSpells & pack) {}
 	virtual void visitSetMana(SetMana & pack) {}
 	virtual void visitSetMovePoints(SetMovePoints & pack) {}
 	virtual void visitFoWChange(FoWChange & pack) {}
@@ -52,8 +57,6 @@
 	virtual void visitSetCommanderProperty(SetCommanderProperty & pack) {}
 	virtual void visitAddQuest(AddQuest & pack) {}
 	virtual void visitUpdateArtHandlerLists(UpdateArtHandlerLists & pack) {}
-	virtual void visitUpdateMapEvents(UpdateMapEvents & pack) {}
-	virtual void visitUpdateCastleEvents(UpdateCastleEvents & pack) {}
 	virtual void visitChangeFormation(ChangeFormation & pack) {}
 	virtual void visitRemoveObject(RemoveObject & pack) {}
 	virtual void visitTryMoveHero(TryMoveHero & pack) {}
@@ -77,8 +80,7 @@
 	virtual void visitBulkRebalanceStacks(BulkRebalanceStacks & pack) {}
 	virtual void visitBulkSmartRebalanceStacks(BulkSmartRebalanceStacks & pack) {}
 	virtual void visitPutArtifact(PutArtifact & pack) {}
-	virtual void visitEraseArtifact(EraseArtifact & pack) {}
-	virtual void visitMoveArtifact(MoveArtifact & pack) {}
+	virtual void visitEraseArtifact(BulkEraseArtifacts & pack) {}
 	virtual void visitBulkMoveArtifacts(BulkMoveArtifacts & pack) {}
 	virtual void visitAssembledArtifact(AssembledArtifact & pack) {}
 	virtual void visitDisassembledArtifact(DisassembledArtifact & pack) {}
@@ -126,7 +128,9 @@
 	virtual void visitBulkSmartSplitStack(BulkSmartSplitStack & pack) {}
 	virtual void visitDisbandCreature(DisbandCreature & pack) {}
 	virtual void visitBuildStructure(BuildStructure & pack) {}
+	virtual void visitVisitTownBuilding(VisitTownBuilding & pack) {}
 	virtual void visitRazeStructure(RazeStructure & pack) {}
+	virtual void visitSpellResearch(SpellResearch & pack) {}
 	virtual void visitRecruitCreatures(RecruitCreatures & pack) {}
 	virtual void visitUpgradeCreature(UpgradeCreature & pack) {}
 	virtual void visitGarrisonHeroSwap(GarrisonHeroSwap & pack) {}
@@ -166,6 +170,7 @@
 	virtual void visitLobbyChangePlayerOption(LobbyChangePlayerOption & pack) {}
 	virtual void visitLobbySetPlayer(LobbySetPlayer & pack) {}
 	virtual void visitLobbySetPlayerName(LobbySetPlayerName & pack) {}
+	virtual void visitLobbySetPlayerHandicap(LobbySetPlayerHandicap & pack) {}
 	virtual void visitLobbySetSimturns(LobbySetSimturns & pack) {}
 	virtual void visitLobbySetTurnTime(LobbySetTurnTime & pack) {}
 	virtual void visitLobbySetExtraOptions(LobbySetExtraOptions & pack) {}
@@ -173,6 +178,8 @@
 	virtual void visitLobbyForceSetPlayer(LobbyForceSetPlayer & pack) {}
 	virtual void visitLobbyShowMessage(LobbyShowMessage & pack) {}
 	virtual void visitLobbyPvPAction(LobbyPvPAction & pack) {}
+	virtual void visitLobbyDelete(LobbyDelete & pack) {}
+	virtual void visitSaveLocalState(SaveLocalState & pack) {}
 };
 
 VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/networkPacks/ObjProperty.h vcmi/lib/networkPacks/ObjProperty.h
--- vcmi-1.5.7/lib/networkPacks/ObjProperty.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/networkPacks/ObjProperty.h	2024-12-19 15:00:22.924149012 +0100
@@ -43,11 +43,9 @@
 
 	//creature-bank specific
 	BANK_DAYCOUNTER,
-	BANK_RESET,
 	BANK_CLEAR,
 
 	//object with reward
-	REWARD_RANDOMIZE,
 	REWARD_SELECT,
 	REWARD_CLEARED
 };
diff --color -urN vcmi-1.5.7/lib/networkPacks/PacksForClientBattle.h vcmi/lib/networkPacks/PacksForClientBattle.h
--- vcmi-1.5.7/lib/networkPacks/PacksForClientBattle.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/networkPacks/PacksForClientBattle.h	2024-12-19 15:00:22.925149053 +0100
@@ -11,8 +11,8 @@
 
 #include "NetPacksBase.h"
 #include "BattleChanges.h"
-#include "../MetaString.h"
 #include "../battle/BattleAction.h"
+#include "../texts/MetaString.h"
 
 class CClient;
 
@@ -25,7 +25,7 @@
 
 struct DLL_LINKAGE BattleStart : public CPackForClient
 {
-	void applyGs(CGameState * gs) const;
+	void applyGs(CGameState * gs) override;
 
 	BattleID battleID = BattleID::NONE;
 	BattleInfo * info = nullptr;
@@ -42,7 +42,7 @@
 
 struct DLL_LINKAGE BattleNextRound : public CPackForClient
 {
-	void applyGs(CGameState * gs) const;
+	void applyGs(CGameState * gs) override;
 
 	BattleID battleID = BattleID::NONE;
 
@@ -57,7 +57,7 @@
 
 struct DLL_LINKAGE BattleSetActiveStack : public CPackForClient
 {
-	void applyGs(CGameState * gs) const;
+	void applyGs(CGameState * gs) override;
 
 	BattleID battleID = BattleID::NONE;
 	ui32 stack = 0;
@@ -76,7 +76,7 @@
 
 struct DLL_LINKAGE BattleCancelled: public CPackForClient
 {
-	void applyGs(CGameState * gs) const;
+	void applyGs(CGameState * gs) override;
 
 	BattleID battleID = BattleID::NONE;
 
@@ -89,7 +89,7 @@
 
 struct DLL_LINKAGE BattleResultAccepted : public CPackForClient
 {
-	void applyGs(CGameState * gs) const;
+	void applyGs(CGameState * gs) override;
 
 	struct HeroBattleResults
 	{
@@ -109,8 +109,8 @@
 	};
 
 	BattleID battleID = BattleID::NONE;
-	std::array<HeroBattleResults, 2> heroResult;
-	ui8 winnerSide;
+	BattleSideArray<HeroBattleResults> heroResult;
+	BattleSide winnerSide;
 
 	template <typename Handler> void serialize(Handler & h)
 	{
@@ -127,12 +127,13 @@
 
 	BattleID battleID = BattleID::NONE;
 	EBattleResult result = EBattleResult::NORMAL;
-	ui8 winner = 2; //0 - attacker, 1 - defender, [2 - draw (should be possible?)]
-	std::map<CreatureID, si32> casualties[2]; //first => casualties of attackers - map crid => number
-	TExpType exp[2] = {0, 0}; //exp for attacker and defender
+	BattleSide winner = BattleSide::NONE; //0 - attacker, 1 - defender, [2 - draw (should be possible?)]
+	BattleSideArray<std::map<CreatureID, si32>> casualties; //first => casualties of attackers - map crid => number
+	BattleSideArray<TExpType> exp{0,0}; //exp for attacker and defender
 	std::set<ArtifactInstanceID> artifacts; //artifacts taken from loser to winner - currently unused
 
 	void visitTyped(ICPackVisitor & visitor) override;
+	void applyGs(CGameState *gs) override {}
 
 	template <typename Handler> void serialize(Handler & h)
 	{
@@ -140,8 +141,7 @@
 		h & queryID;
 		h & result;
 		h & winner;
-		h & casualties[0];
-		h & casualties[1];
+		h & casualties;
 		h & exp;
 		h & artifacts;
 		assert(battleID != BattleID::NONE);
@@ -153,7 +153,7 @@
 	BattleID battleID = BattleID::NONE;
 	std::vector<MetaString> lines;
 
-	void applyGs(CGameState * gs);
+	void applyGs(CGameState * gs) override;
 	void applyBattle(IBattleState * battleState);
 
 	void visitTyped(ICPackVisitor & visitor) override;
@@ -174,7 +174,7 @@
 	int distance = 0;
 	bool teleporting = false;
 
-	void applyGs(CGameState * gs);
+	void applyGs(CGameState * gs) override;
 	void applyBattle(IBattleState * battleState);
 
 	void visitTyped(ICPackVisitor & visitor) override;
@@ -192,7 +192,7 @@
 
 struct DLL_LINKAGE BattleUnitsChanged : public CPackForClient
 {
-	void applyGs(CGameState * gs);
+	void applyGs(CGameState * gs) override;
 	void applyBattle(IBattleState * battleState);
 
 	BattleID battleID = BattleID::NONE;
@@ -268,7 +268,7 @@
 
 struct DLL_LINKAGE BattleAttack : public CPackForClient
 {
-	void applyGs(CGameState * gs);
+	void applyGs(CGameState * gs) override;
 	BattleUnitsChanged attackerChanges;
 
 	BattleID battleID = BattleID::NONE;
@@ -336,7 +336,7 @@
 	{
 	}
 	void applyFirstCl(CClient * cl);
-	void applyGs(CGameState * gs);
+	void applyGs(CGameState * gs) override;
 
 	BattleID battleID = BattleID::NONE;
 	BattleAction ba;
@@ -354,6 +354,7 @@
 struct DLL_LINKAGE EndAction : public CPackForClient
 {
 	void visitTyped(ICPackVisitor & visitor) override;
+	void applyGs(CGameState *gs) override {}
 
 	BattleID battleID = BattleID::NONE;
 
@@ -365,11 +366,11 @@
 
 struct DLL_LINKAGE BattleSpellCast : public CPackForClient
 {
-	void applyGs(CGameState * gs) const;
+	void applyGs(CGameState * gs) override;
 
 	BattleID battleID = BattleID::NONE;
 	bool activeCast = true;
-	ui8 side = 0; //which hero did cast spell: 0 - attacker, 1 - defender
+	BattleSide side = BattleSide::NONE; //which hero did cast spell
 	SpellID spellID; //id of spell
 	ui8 manaGained = 0; //mana channeling ability
 	BattleHex tile; //destination tile (may not be set in some global/mass spells
@@ -400,7 +401,7 @@
 
 struct DLL_LINKAGE StacksInjured : public CPackForClient
 {
-	void applyGs(CGameState * gs);
+	void applyGs(CGameState * gs) override;
 	void applyBattle(IBattleState * battleState);
 
 	BattleID battleID = BattleID::NONE;
@@ -421,6 +422,7 @@
 	BattleID battleID = BattleID::NONE;
 	PlayerColor player1, player2;
 	void visitTyped(ICPackVisitor & visitor) override;
+	void applyGs(CGameState *gs) override {}
 
 	template <typename Handler> void serialize(Handler & h)
 	{
@@ -433,7 +435,7 @@
 
 struct DLL_LINKAGE BattleObstaclesChanged : public CPackForClient
 {
-	void applyGs(CGameState * gs);
+	void applyGs(CGameState * gs) override;
 	void applyBattle(IBattleState * battleState);
 
 	BattleID battleID = BattleID::NONE;
@@ -468,7 +470,7 @@
 	CatapultAttack();
 	~CatapultAttack() override;
 
-	void applyGs(CGameState * gs);
+	void applyGs(CGameState * gs) override;
 	void applyBattle(IBattleState * battleState);
 
 	BattleID battleID = BattleID::NONE;
@@ -490,7 +492,7 @@
 {
 	enum BattleStackProperty { CASTS, ENCHANTER_COUNTER, UNBIND, CLONED, HAS_CLONE };
 
-	void applyGs(CGameState * gs) const;
+	void applyGs(CGameState * gs) override;
 
 	BattleID battleID = BattleID::NONE;
 	int stackID = 0;
@@ -515,7 +517,7 @@
 ///activated at the beginning of turn
 struct DLL_LINKAGE BattleTriggerEffect : public CPackForClient
 {
-	void applyGs(CGameState * gs) const; //effect
+	void applyGs(CGameState * gs) override; //effect
 
 	BattleID battleID = BattleID::NONE;
 	int stackID = 0;
@@ -539,7 +541,7 @@
 
 struct DLL_LINKAGE BattleUpdateGateState : public CPackForClient
 {
-	void applyGs(CGameState * gs) const;
+	void applyGs(CGameState * gs) override;
 
 	BattleID battleID = BattleID::NONE;
 	EGateState state = EGateState::NONE;
diff --color -urN vcmi-1.5.7/lib/networkPacks/PacksForClient.h vcmi/lib/networkPacks/PacksForClient.h
--- vcmi-1.5.7/lib/networkPacks/PacksForClient.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/networkPacks/PacksForClient.h	2024-12-19 15:00:22.925149053 +0100
@@ -18,12 +18,13 @@
 #include "ObjProperty.h"
 
 #include "../CCreatureSet.h"
-#include "../MetaString.h"
 #include "../ResourceSet.h"
 #include "../TurnTimerInfo.h"
 #include "../gameState/EVictoryLossCheckResult.h"
+#include "../gameState/RumorState.h"
 #include "../gameState/QuestInfo.h"
 #include "../gameState/TavernSlot.h"
+#include "../gameState/GameStatistics.h"
 #include "../int3.h"
 #include "../mapping/CMapDefines.h"
 #include "../spells/ViewSpellInt.h"
@@ -56,6 +57,7 @@
 	{
 	}
 	void visitTyped(ICPackVisitor & visitor) override;
+	void applyGs(CGameState *gs) override {}
 
 	ui8 result = 0; //0 - something went wrong, request hasn't been realized; 1 - OK
 	ui32 packType = 0; //type id of applied package
@@ -80,6 +82,7 @@
 	SystemMessage() = default;
 
 	void visitTyped(ICPackVisitor & visitor) override;
+	void applyGs(CGameState *gs) override {}
 
 	MetaString text;
 
@@ -99,6 +102,7 @@
 	PlayerColor player;
 
 	void visitTyped(ICPackVisitor & visitor) override;
+	void applyGs(CGameState *gs) override {}
 
 	template <typename Handler> void serialize(Handler & h)
 	{
@@ -110,7 +114,7 @@
 
 struct DLL_LINKAGE PlayerCheated : public CPackForClient
 {
-	void applyGs(CGameState * gs) const;
+	void applyGs(CGameState * gs) override;
 
 	PlayerColor player;
 	bool losingCheatCode = false;
@@ -128,7 +132,7 @@
 
 struct DLL_LINKAGE TurnTimeUpdate : public CPackForClient
 {
-	void applyGs(CGameState * gs) const;
+	void applyGs(CGameState * gs) override;
 	
 	PlayerColor player;
 	TurnTimerInfo turnTimer;
@@ -142,7 +146,7 @@
 
 struct DLL_LINKAGE PlayerStartsTurn : public Query
 {
-	void applyGs(CGameState * gs) const;
+	void applyGs(CGameState * gs) override;
 
 	PlayerColor player;
 
@@ -157,7 +161,7 @@
 
 struct DLL_LINKAGE DaysWithoutTown : public CPackForClient
 {
-	void applyGs(CGameState * gs) const;
+	void applyGs(CGameState * gs) override;
 
 	PlayerColor player;
 	std::optional<int32_t> daysWithoutCastle;
@@ -175,7 +179,7 @@
 {
 	std::vector<EntityChanges> changes;
 
-	void applyGs(CGameState * gs);
+	void applyGs(CGameState * gs) override;
 
 	void visitTyped(ICPackVisitor & visitor) override;
 
@@ -187,7 +191,7 @@
 
 struct DLL_LINKAGE SetResources : public CPackForClient
 {
-	void applyGs(CGameState * gs) const;
+	void applyGs(CGameState * gs) override;
 
 	void visitTyped(ICPackVisitor & visitor) override;
 
@@ -205,7 +209,7 @@
 
 struct DLL_LINKAGE SetPrimSkill : public CPackForClient
 {
-	void applyGs(CGameState * gs) const;
+	void applyGs(CGameState * gs) override;
 
 	void visitTyped(ICPackVisitor & visitor) override;
 
@@ -225,7 +229,7 @@
 
 struct DLL_LINKAGE SetSecSkill : public CPackForClient
 {
-	void applyGs(CGameState * gs) const;
+	void applyGs(CGameState * gs) override;
 
 	void visitTyped(ICPackVisitor & visitor) override;
 
@@ -245,7 +249,7 @@
 
 struct DLL_LINKAGE HeroVisitCastle : public CPackForClient
 {
-	void applyGs(CGameState * gs) const;
+	void applyGs(CGameState * gs) override;
 
 	void visitTyped(ICPackVisitor & visitor) override;
 
@@ -268,7 +272,7 @@
 
 struct DLL_LINKAGE ChangeSpells : public CPackForClient
 {
-	void applyGs(CGameState * gs);
+	void applyGs(CGameState * gs) override;
 
 	void visitTyped(ICPackVisitor & visitor) override;
 
@@ -284,12 +288,39 @@
 	}
 };
 
+struct DLL_LINKAGE SetResearchedSpells : public CPackForClient
+{
+	void applyGs(CGameState * gs) override;
+
+	void visitTyped(ICPackVisitor & visitor) override;
+
+	ui8 level = 0;
+	ObjectInstanceID tid;
+	std::vector<SpellID> spells;
+	bool accepted;
+
+	template <typename Handler> void serialize(Handler & h)
+	{
+		h & level;
+		h & tid;
+		h & spells;
+		h & accepted;
+	}
+};
+
 struct DLL_LINKAGE SetMana : public CPackForClient
 {
-	void applyGs(CGameState * gs) const;
+	void applyGs(CGameState * gs) override;
 
 	void visitTyped(ICPackVisitor & visitor) override;
 
+	SetMana() = default;
+	SetMana(ObjectInstanceID hid, si32 val, bool absolute)
+		: hid(hid)
+		, val(val)
+		, absolute(absolute)
+	{}
+
 	ObjectInstanceID hid;
 	si32 val = 0;
 	bool absolute = true;
@@ -304,7 +335,14 @@
 
 struct DLL_LINKAGE SetMovePoints : public CPackForClient
 {
-	void applyGs(CGameState * gs) const;
+	void applyGs(CGameState * gs) override;
+
+	SetMovePoints() = default;
+	SetMovePoints(ObjectInstanceID hid, si32 val, bool absolute)
+		: hid(hid)
+		, val(val)
+		, absolute(absolute)
+	{}
 
 	ObjectInstanceID hid;
 	si32 val = 0;
@@ -322,7 +360,7 @@
 
 struct DLL_LINKAGE FoWChange : public CPackForClient
 {
-	void applyGs(CGameState * gs);
+	void applyGs(CGameState * gs) override;
 
 	std::unordered_set<int3> tiles;
 	PlayerColor player;
@@ -346,7 +384,7 @@
 	{
 		army.clearSlots();
 	}
-	void applyGs(CGameState * gs);
+	void applyGs(CGameState * gs) override;
 
 	TavernHeroSlot slotID;
 	TavernSlotRole roleID;
@@ -377,7 +415,7 @@
 	{
 	}
 
-	void applyGs(CGameState * gs);
+	void applyGs(CGameState * gs) override;
 
 	ETarget who = ETarget::OBJECT;
 	VariantIdentifier<ObjectInstanceID, PlayerColor, BattleID> id;
@@ -396,7 +434,7 @@
 
 struct DLL_LINKAGE ChangeObjPos : public CPackForClient
 {
-	void applyGs(CGameState * gs);
+	void applyGs(CGameState * gs) override;
 
 	/// Object to move
 	ObjectInstanceID objid;
@@ -417,7 +455,7 @@
 
 struct DLL_LINKAGE PlayerEndsTurn : public CPackForClient
 {
-	void applyGs(CGameState * gs) const;
+	void applyGs(CGameState * gs) override;
 
 	PlayerColor player;
 
@@ -431,10 +469,11 @@
 
 struct DLL_LINKAGE PlayerEndsGame : public CPackForClient
 {
-	void applyGs(CGameState * gs) const;
+	void applyGs(CGameState * gs) override;
 
 	PlayerColor player;
 	EVictoryLossCheckResult victoryLossCheckResult;
+	StatisticDataSet statistic;
 
 	void visitTyped(ICPackVisitor & visitor) override;
 
@@ -442,12 +481,14 @@
 	{
 		h & player;
 		h & victoryLossCheckResult;
+		if (h.version >= Handler::Version::STATISTICS_SCREEN)
+			h & statistic;
 	}
 };
 
 struct DLL_LINKAGE PlayerReinitInterface : public CPackForClient
 {
-	void applyGs(CGameState * gs);
+	void applyGs(CGameState * gs) override;
 
 	std::vector<PlayerColor> players;
 	ui8 playerConnectionId; //PLAYER_AI for AI player
@@ -468,7 +509,7 @@
 	{
 	}
 
-	void applyGs(CGameState * gs);
+	void applyGs(CGameState * gs) override;
 
 	GiveBonus::ETarget who; //who receives bonus
 	VariantIdentifier<HeroTypeID, PlayerColor, BattleID, ObjectInstanceID> whoID;
@@ -495,7 +536,7 @@
 {
 	enum ECommanderProperty { ALIVE, BONUS, SECONDARY_SKILL, EXPERIENCE, SPECIAL_SKILL };
 
-	void applyGs(CGameState * gs);
+	void applyGs(CGameState * gs) override;
 
 	ObjectInstanceID heroid;
 
@@ -518,7 +559,7 @@
 
 struct DLL_LINKAGE AddQuest : public CPackForClient
 {
-	void applyGs(CGameState * gs) const;
+	void applyGs(CGameState * gs) override;
 
 	PlayerColor player;
 	QuestInfo quest;
@@ -536,7 +577,7 @@
 {
 	std::map<ArtifactID, int> allocatedArtifacts;
 
-	void applyGs(CGameState * gs) const;
+	void applyGs(CGameState * gs) override;
 	void visitTyped(ICPackVisitor & visitor) override;
 
 	template <typename Handler> void serialize(Handler & h)
@@ -545,40 +586,12 @@
 	}
 };
 
-struct DLL_LINKAGE UpdateMapEvents : public CPackForClient
-{
-	std::list<CMapEvent> events;
-
-	void applyGs(CGameState * gs) const;
-	void visitTyped(ICPackVisitor & visitor) override;
-
-	template <typename Handler> void serialize(Handler & h)
-	{
-		h & events;
-	}
-};
-
-struct DLL_LINKAGE UpdateCastleEvents : public CPackForClient
-{
-	ObjectInstanceID town;
-	std::list<CCastleEvent> events;
-
-	void applyGs(CGameState * gs) const;
-	void visitTyped(ICPackVisitor & visitor) override;
-
-	template <typename Handler> void serialize(Handler & h)
-	{
-		h & town;
-		h & events;
-	}
-};
-
 struct DLL_LINKAGE ChangeFormation : public CPackForClient
 {
 	ObjectInstanceID hid;
 	EArmyFormation formation{};
 
-	void applyGs(CGameState * gs) const;
+	void applyGs(CGameState * gs) override;
 	void visitTyped(ICPackVisitor & visitor) override;
 
 	template <typename Handler> void serialize(Handler & h)
@@ -597,7 +610,7 @@
 	{
 	}
 
-	void applyGs(CGameState * gs);
+	void applyGs(CGameState * gs) override;
 	void visitTyped(ICPackVisitor & visitor) override;
 
 	/// ID of removed object
@@ -615,7 +628,7 @@
 
 struct DLL_LINKAGE TryMoveHero : public CPackForClient
 {
-	void applyGs(CGameState * gs);
+	void applyGs(CGameState * gs) override;
 
 	enum EResult
 	{
@@ -656,11 +669,11 @@
 
 struct DLL_LINKAGE NewStructures : public CPackForClient
 {
-	void applyGs(CGameState * gs);
+	void applyGs(CGameState * gs) override;
 
 	ObjectInstanceID tid;
 	std::set<BuildingID> bid;
-	si16 builded = 0;
+	si16 built = 0;
 
 	void visitTyped(ICPackVisitor & visitor) override;
 
@@ -668,13 +681,13 @@
 	{
 		h & tid;
 		h & bid;
-		h & builded;
+		h & built;
 	}
 };
 
 struct DLL_LINKAGE RazeStructures : public CPackForClient
 {
-	void applyGs(CGameState * gs);
+	void applyGs(CGameState * gs) override;
 
 	ObjectInstanceID tid;
 	std::set<BuildingID> bid;
@@ -692,7 +705,7 @@
 
 struct DLL_LINKAGE SetAvailableCreatures : public CPackForClient
 {
-	void applyGs(CGameState * gs) const;
+	void applyGs(CGameState * gs) override;
 
 	ObjectInstanceID tid;
 	std::vector<std::pair<ui32, std::vector<CreatureID> > > creatures;
@@ -708,7 +721,7 @@
 
 struct DLL_LINKAGE SetHeroesInTown : public CPackForClient
 {
-	void applyGs(CGameState * gs) const;
+	void applyGs(CGameState * gs) override;
 
 	ObjectInstanceID tid; //id of town
 	ObjectInstanceID visiting; //id of visiting hero
@@ -726,7 +739,7 @@
 
 struct DLL_LINKAGE HeroRecruited : public CPackForClient
 {
-	void applyGs(CGameState * gs) const;
+	void applyGs(CGameState * gs) override;
 
 	HeroTypeID hid; //subID of hero
 	ObjectInstanceID tid;
@@ -748,7 +761,7 @@
 
 struct DLL_LINKAGE GiveHero : public CPackForClient
 {
-	void applyGs(CGameState * gs) const;
+	void applyGs(CGameState * gs) override;
 
 	ObjectInstanceID id; //object id
 	ObjectInstanceID boatId;
@@ -771,6 +784,7 @@
 	ObjectInstanceID visitor;
 
 	void visitTyped(ICPackVisitor & visitor) override;
+	void applyGs(CGameState *gs) override {}
 
 	template <typename Handler> void serialize(Handler & h)
 	{
@@ -783,37 +797,29 @@
 
 struct DLL_LINKAGE NewObject : public CPackForClient
 {
-	void applyGs(CGameState * gs);
+	void applyGs(CGameState * gs) override;
 
 	/// Object ID to create
-	MapObjectID ID;
-	/// Object secondary ID to create
-	MapObjectSubID subID;
-	/// Position of visitable tile of created object
-	int3 targetPos;
+	CGObjectInstance * newObject;
 	/// Which player initiated creation of this object
 	PlayerColor initiator;
 
-	ObjectInstanceID createdObjectID; //used locally, filled during applyGs
-
 	void visitTyped(ICPackVisitor & visitor) override;
 
 	template <typename Handler> void serialize(Handler & h)
 	{
-		h & ID;
-		subID.serializeIdentifier(h, ID);
-		h & targetPos;
+		h & newObject;
 		h & initiator;
 	}
 };
 
 struct DLL_LINKAGE SetAvailableArtifacts : public CPackForClient
 {
-	void applyGs(CGameState * gs) const;
+	void applyGs(CGameState * gs) override;
 
 	//two variants: id < 0: set artifact pool for Artifact Merchants in towns; id >= 0: set pool for adv. map Black Market (id is the id of Black Market instance then)
 	ObjectInstanceID id;
-	std::vector<const CArtifact *> arts;
+	std::vector<ArtifactID> arts;
 
 	void visitTyped(ICPackVisitor & visitor) override;
 
@@ -835,7 +841,7 @@
 	TQuantity count;
 	bool absoluteValue; //if not -> count will be added (or subtracted if negative)
 
-	void applyGs(CGameState * gs);
+	void applyGs(CGameState * gs) override;
 
 	void visitTyped(ICPackVisitor & visitor) override;
 
@@ -854,7 +860,7 @@
 	SlotID slot;
 	CreatureID type;
 
-	void applyGs(CGameState * gs);
+	void applyGs(CGameState * gs) override;
 
 	void visitTyped(ICPackVisitor & visitor) override;
 
@@ -871,7 +877,7 @@
 	ObjectInstanceID army;
 	SlotID slot;
 
-	void applyGs(CGameState * gs);
+	void applyGs(CGameState * gs) override;
 	void visitTyped(ICPackVisitor & visitor) override;
 
 	template <typename Handler> void serialize(Handler & h)
@@ -888,7 +894,7 @@
 	SlotID srcSlot;
 	SlotID dstSlot;
 
-	void applyGs(CGameState * gs);
+	void applyGs(CGameState * gs) override;
 	void visitTyped(ICPackVisitor & visitor) override;
 
 	template <typename Handler> void serialize(Handler & h)
@@ -907,7 +913,7 @@
 	CreatureID type;
 	TQuantity count = 0;
 
-	void applyGs(CGameState * gs);
+	void applyGs(CGameState * gs) override;
 	void visitTyped(ICPackVisitor & visitor) override;
 
 	template <typename Handler> void serialize(Handler & h)
@@ -929,7 +935,7 @@
 
 	TQuantity count;
 
-	void applyGs(CGameState * gs);
+	void applyGs(CGameState * gs) override;
 	void visitTyped(ICPackVisitor & visitor) override;
 
 	template <typename Handler> void serialize(Handler & h)
@@ -946,7 +952,7 @@
 {
 	std::vector<RebalanceStacks> moves;
 
-	void applyGs(CGameState * gs);
+	void applyGs(CGameState * gs) override;
 	void visitTyped(ICPackVisitor & visitor) override;
 
 	template <typename Handler>
@@ -961,7 +967,7 @@
 	std::vector<RebalanceStacks> moves;
 	std::vector<ChangeStackCount> changes;
 
-	void applyGs(CGameState * gs);
+	void applyGs(CGameState * gs) override;
 	void visitTyped(ICPackVisitor & visitor) override;
 
 	template <typename Handler>
@@ -979,73 +985,59 @@
 struct DLL_LINKAGE PutArtifact : CArtifactOperationPack
 {
 	PutArtifact() = default;
-	explicit PutArtifact(ArtifactLocation & dst, bool askAssemble = true)
-		: al(dst), askAssemble(askAssemble)
+	explicit PutArtifact(const ArtifactInstanceID & id, const ArtifactLocation & dst, bool askAssemble = true)
+		: al(dst), askAssemble(askAssemble), id(id)
 	{
 	}
 
 	ArtifactLocation al;
 	bool askAssemble;
-	ConstTransitivePtr<CArtifactInstance> art;
+	ArtifactInstanceID id;
 
-	void applyGs(CGameState * gs);
+	void applyGs(CGameState * gs) override;
 	void visitTyped(ICPackVisitor & visitor) override;
 
 	template <typename Handler> void serialize(Handler & h)
 	{
 		h & al;
 		h & askAssemble;
-		h & art;
+		h & id;
 	}
 };
 
 struct DLL_LINKAGE NewArtifact : public CArtifactOperationPack
 {
-	ConstTransitivePtr<CArtifactInstance> art;
+	ObjectInstanceID artHolder;
+	ArtifactID artId;
+	SpellID spellId;
+	ArtifactPosition pos;
 
-	void applyGs(CGameState * gs);
+	void applyGs(CGameState * gs) override;
 	void visitTyped(ICPackVisitor & visitor) override;
 
 	template <typename Handler> void serialize(Handler & h)
 	{
-		h & art;
+		h & artHolder;
+		h & artId;
+		h & spellId;
+		h & pos;
 	}
 };
 
-struct DLL_LINKAGE EraseArtifact : CArtifactOperationPack
+struct DLL_LINKAGE BulkEraseArtifacts : CArtifactOperationPack
 {
-	ArtifactLocation al;
+	ObjectInstanceID artHolder;
+	std::vector<ArtifactPosition> posPack;
+	std::optional<SlotID> creature;
 
-	void applyGs(CGameState * gs);
+	void applyGs(CGameState * gs) override;
 	void visitTyped(ICPackVisitor & visitor) override;
 
 	template <typename Handler> void serialize(Handler & h)
 	{
-		h & al;
-	}
-};
-
-struct DLL_LINKAGE MoveArtifact : CArtifactOperationPack
-{
-	MoveArtifact() = default;
-	MoveArtifact(const PlayerColor & interfaceOwner, const ArtifactLocation & src, const ArtifactLocation & dst, bool askAssemble = true)
-		: interfaceOwner(interfaceOwner), src(src), dst(dst), askAssemble(askAssemble)
-	{
-	}
-	PlayerColor interfaceOwner;
-	ArtifactLocation src;
-	ArtifactLocation dst;
-	bool askAssemble = true;
-
-	void applyGs(CGameState * gs);
-	void visitTyped(ICPackVisitor & visitor) override;
-
-	template <typename Handler> void serialize(Handler & h)
-	{
-		h & interfaceOwner;
-		h & src;
-		h & dst;
-		h & askAssemble;
+		h & artHolder;
+		h & posPack;
+		h & creature;
 	}
 };
 
@@ -1055,17 +1047,20 @@
 	{
 		ArtifactPosition srcPos;
 		ArtifactPosition dstPos;
+		bool askAssemble;
 
 		LinkedSlots() = default;
-		LinkedSlots(const ArtifactPosition & srcPos, const ArtifactPosition & dstPos)
+		LinkedSlots(const ArtifactPosition & srcPos, const ArtifactPosition & dstPos, bool askAssemble = false)
 			: srcPos(srcPos)
 			, dstPos(dstPos)
+			, askAssemble(askAssemble)
 		{
 		}
 		template <typename Handler> void serialize(Handler & h)
 		{
 			h & srcPos;
 			h & dstPos;
+			h & askAssemble;
 		}
 	};
 
@@ -1079,8 +1074,6 @@
 		: interfaceOwner(PlayerColor::NEUTRAL)
 		, srcArtHolder(ObjectInstanceID::NONE)
 		, dstArtHolder(ObjectInstanceID::NONE)
-		, swap(false)
-		, askAssemble(false)
 		, srcCreature(std::nullopt)
 		, dstCreature(std::nullopt)
 	{
@@ -1089,19 +1082,15 @@
 		: interfaceOwner(interfaceOwner)
 		, srcArtHolder(srcArtHolder)
 		, dstArtHolder(dstArtHolder)
-		, swap(swap)
-		, askAssemble(false)
 		, srcCreature(std::nullopt)
 		, dstCreature(std::nullopt)
 	{
 	}
 
-	void applyGs(CGameState * gs);
+	void applyGs(CGameState * gs) override;
 
 	std::vector<LinkedSlots> artsPack0;
 	std::vector<LinkedSlots> artsPack1;
-	bool swap;
-	bool askAssemble;
 
 	void visitTyped(ICPackVisitor & visitor) override;
 
@@ -1114,24 +1103,22 @@
 		h & dstArtHolder;
 		h & srcCreature;
 		h & dstCreature;
-		h & swap;
-		h & askAssemble;
 	}
 };
 
 struct DLL_LINKAGE AssembledArtifact : CArtifactOperationPack
 {
-	ArtifactLocation al; //where assembly will be put
-	const CArtifact * builtArt;
+	ArtifactLocation al;
+	ArtifactID artId;
 
-	void applyGs(CGameState * gs);
+	void applyGs(CGameState * gs) override;
 
 	void visitTyped(ICPackVisitor & visitor) override;
 
 	template <typename Handler> void serialize(Handler & h)
 	{
 		h & al;
-		h & builtArt;
+		h & artId;
 	}
 };
 
@@ -1139,7 +1126,7 @@
 {
 	ArtifactLocation al;
 
-	void applyGs(CGameState * gs);
+	void applyGs(CGameState * gs) override;
 
 	void visitTyped(ICPackVisitor & visitor) override;
 
@@ -1157,7 +1144,7 @@
 
 	bool starting; //false -> ending
 
-	void applyGs(CGameState * gs);
+	void applyGs(CGameState * gs) override;
 
 	void visitTyped(ICPackVisitor & visitor) override;
 
@@ -1170,48 +1157,6 @@
 	}
 };
 
-struct DLL_LINKAGE NewTurn : public CPackForClient
-{
-	enum weekType { NORMAL, DOUBLE_GROWTH, BONUS_GROWTH, DEITYOFFIRE, PLAGUE, NO_ACTION };
-
-	void applyGs(CGameState * gs);
-
-	void visitTyped(ICPackVisitor & visitor) override;
-
-	struct Hero
-	{
-		ObjectInstanceID id; //id is a general serial id
-		ui32 move;
-		ui32 mana;
-		template <typename Handler> void serialize(Handler & h)
-		{
-			h & id;
-			h & move;
-			h & mana;
-		}
-		bool operator<(const Hero & h)const { return id < h.id; }
-	};
-
-	std::set<Hero> heroes; //updates movement and mana points
-	std::map<PlayerColor, ResourceSet> res; //player ID => resource value[res_id]
-	std::map<ObjectInstanceID, SetAvailableCreatures> cres;//creatures to be placed in towns
-	ui32 day = 0;
-	ui8 specialWeek = 0; //weekType
-	CreatureID creatureid; //for creature weeks
-
-	NewTurn() = default;
-
-	template <typename Handler> void serialize(Handler & h)
-	{
-		h & heroes;
-		h & cres;
-		h & res;
-		h & day;
-		h & specialWeek;
-		h & creatureid;
-	}
-};
-
 struct DLL_LINKAGE InfoWindow : public CPackForClient //103  - displays simple info window
 {
 	EInfoWindowMode type = EInfoWindowMode::MODAL;
@@ -1221,6 +1166,7 @@
 	ui16 soundID = 0;
 
 	void visitTyped(ICPackVisitor & visitor) override;
+	void applyGs(CGameState * gs) override {}
 
 	template <typename Handler> void serialize(Handler & h)
 	{
@@ -1233,9 +1179,42 @@
 	InfoWindow() = default;
 };
 
+struct DLL_LINKAGE NewTurn : public CPackForClient
+{
+	void applyGs(CGameState * gs) override;
+
+	void visitTyped(ICPackVisitor & visitor) override;
+
+	ui32 day = 0;
+	CreatureID creatureid; //for creature weeks
+	EWeekType specialWeek = EWeekType::NORMAL;
+
+	std::vector<SetMovePoints> heroesMovement;
+	std::vector<SetMana> heroesMana;
+	std::vector<SetAvailableCreatures> availableCreatures;
+	std::map<PlayerColor, ResourceSet> playerIncome;
+	std::optional<RumorState> newRumor; // only on new weeks
+	std::optional<InfoWindow> newWeekNotification; // only on new week
+
+	NewTurn() = default;
+
+	template <typename Handler> void serialize(Handler & h)
+	{
+		h & day;
+		h & creatureid;
+		h & specialWeek;
+		h & heroesMovement;
+		h & heroesMana;
+		h & availableCreatures;
+		h & playerIncome;
+		h & newRumor;
+		h & newWeekNotification;
+	}
+};
+
 struct DLL_LINKAGE SetObjectProperty : public CPackForClient
 {
-	void applyGs(CGameState * gs) const;
+	void applyGs(CGameState * gs) override;
 	ObjectInstanceID id;
 	ObjProperty what{};
 
@@ -1257,17 +1236,17 @@
 {
 	enum VisitMode
 	{
-		VISITOR_ADD,      // mark hero as one that have visited this object
-		VISITOR_ADD_TEAM, // mark team as one that have visited this object
-		VISITOR_GLOBAL,   // mark player as one that have visited object of this type
-		VISITOR_REMOVE,   // unmark visitor, reversed to ADD
-		VISITOR_CLEAR     // clear all visitors from this object (object reset)
+		VISITOR_ADD_HERO,   // mark hero as one that have visited this object
+		VISITOR_ADD_PLAYER, // mark player as one that have visited this object instance
+		VISITOR_GLOBAL,     // mark player as one that have visited object of this type
+		VISITOR_SCOUTED,    // marks targeted team as having scouted this object
+		VISITOR_CLEAR,      // clear all visitors from this object (object reset)
 	};
 	VisitMode mode = VISITOR_CLEAR; // uses VisitMode enum
 	ObjectInstanceID object;
 	ObjectInstanceID hero; // note: hero owner will be also marked as "visited" this object
 
-	void applyGs(CGameState * gs) const;
+	void applyGs(CGameState * gs) override;
 
 	void visitTyped(ICPackVisitor & visitor) override;
 
@@ -1294,7 +1273,7 @@
 	uint32_t costumeIdx = 0;
 	const PlayerColor player = PlayerColor::NEUTRAL;
 
-	void applyGs(CGameState * gs) const;
+	void applyGs(CGameState * gs) override;
 	void visitTyped(ICPackVisitor & visitor) override;
 
 	ChangeArtifactsCostume() = default;
@@ -1320,7 +1299,7 @@
 	PrimarySkill primskill = PrimarySkill::ATTACK;
 	std::vector<SecondarySkill> skills;
 
-	void applyGs(CGameState * gs) const;
+	void applyGs(CGameState * gs) override;
 
 	void visitTyped(ICPackVisitor & visitor) override;
 
@@ -1341,7 +1320,7 @@
 
 	std::vector<ui32> skills; //0-5 - secondary skills, val-100 - special skill
 
-	void applyGs(CGameState * gs) const;
+	void applyGs(CGameState * gs) override;
 
 	void visitTyped(ICPackVisitor & visitor) override;
 
@@ -1388,6 +1367,7 @@
 	BlockingDialog() = default;
 
 	void visitTyped(ICPackVisitor & visitor) override;
+	void applyGs(CGameState * gs) override {}
 
 	template <typename Handler> void serialize(Handler & h)
 	{
@@ -1407,6 +1387,7 @@
 	bool removableUnits = false;
 
 	void visitTyped(ICPackVisitor & visitor) override;
+	void applyGs(CGameState * gs) override {}
 
 	template <typename Handler> void serialize(Handler & h)
 	{
@@ -1425,6 +1406,7 @@
 	ObjectInstanceID hero2;
 
 	void visitTyped(ICPackVisitor & visitor) override;
+	void applyGs(CGameState * gs) override {}
 
 	template <typename Handler> void serialize(Handler & h)
 	{
@@ -1450,6 +1432,7 @@
 	bool impassable = false;
 
 	void visitTyped(ICPackVisitor & visitor) override;
+	void applyGs(CGameState * gs) override {}
 
 	template <typename Handler> void serialize(Handler & h)
 	{
@@ -1470,6 +1453,7 @@
 	std::vector<ObjectInstanceID> objects;
 
 	void visitTyped(ICPackVisitor & visitor) override;
+	void applyGs(CGameState * gs) override {}
 
 	template <typename Handler> void serialize(Handler & h)
 	{
@@ -1494,6 +1478,7 @@
 
 protected:
 	void visitTyped(ICPackVisitor & visitor) override;
+	void applyGs(CGameState * gs) override {}
 };
 
 struct DLL_LINKAGE ShowWorldViewEx : public CPackForClient
@@ -1503,6 +1488,8 @@
 
 	std::vector<ObjectPosInfo> objectPositions;
 
+	void applyGs(CGameState * gs) override {}
+
 	template <typename Handler> void serialize(Handler & h)
 	{
 		h & player;
@@ -1523,6 +1510,7 @@
 	{
 	}
 	void visitTyped(ICPackVisitor & visitor) override;
+	void applyGs(CGameState * gs) override {}
 
 	PlayerColor player;
 	std::string text;
@@ -1541,6 +1529,7 @@
 	ui32 focusTime = 0; //ms
 
 	void visitTyped(ICPackVisitor & visitor) override;
+	void applyGs(CGameState * gs) override {}
 
 	template <typename Handler> void serialize(Handler & h)
 	{
diff --color -urN vcmi-1.5.7/lib/networkPacks/PacksForLobby.h vcmi/lib/networkPacks/PacksForLobby.h
--- vcmi-1.5.7/lib/networkPacks/PacksForLobby.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/networkPacks/PacksForLobby.h	2024-12-19 15:00:22.925149053 +0100
@@ -11,8 +11,8 @@
 
 #include "StartInfo.h"
 #include "NetPacksBase.h"
-#include "../MetaString.h"
 #include "../serializer/ESerializationVersion.h"
+#include "../texts/MetaString.h"
 
 class CServerHandler;
 class CVCMIServer;
@@ -55,18 +55,7 @@
 
 		h & clientId;
 		h & hostClientId;
-
-		try
-		{
-			if (h.version >= Handler::Version::RELEASE_152)
-				h & version;
-			else
-				version = ESerializationVersion::RELEASE_150;
-		}
-		 catch (const std::runtime_error & e)
-		{
-			version = ESerializationVersion::RELEASE_150;
-		}
+		h & version;
 	}
 };
 
@@ -155,12 +144,13 @@
 
 	template <typename Handler> void serialize(Handler &h)
 	{
+		if (!h.saving)
+			h.loadingGamestate = true;
 		h & clientId;
 		h & initializedStartInfo;
-		bool sps = h.smartPointerSerialization;
-		h.smartPointerSerialization = true;
 		h & initializedGameState;
-		h.smartPointerSerialization = sps;
+		if (!h.saving)
+			h.loadingGamestate = false;
 	}
 };
 
@@ -180,12 +170,14 @@
 {
 	LobbyState state;
 	bool hostChanged = false; // Used on client-side only
+	bool refreshList = false;
 
 	void visitTyped(ICPackVisitor & visitor) override;
 
 	template <typename Handler> void serialize(Handler &h)
 	{
 		h & state;
+		h & refreshList;
 	}
 };
 
@@ -284,6 +276,20 @@
 	}
 };
 
+struct DLL_LINKAGE LobbySetPlayerHandicap : public CLobbyPackToServer
+{
+	PlayerColor color = PlayerColor::CANNOT_DETERMINE;
+	Handicap handicap = Handicap();
+
+	void visitTyped(ICPackVisitor & visitor) override;
+
+	template <typename Handler> void serialize(Handler &h)
+	{
+		h & color;
+		h & handicap;
+	}
+};
+
 struct DLL_LINKAGE LobbySetSimturns : public CLobbyPackToServer
 {
 	SimturnsInfo simturnsInfo;
@@ -362,7 +368,9 @@
 {
 	enum EAction : ui8 {
 		NONE, COIN, RANDOM_TOWN, RANDOM_TOWN_VS
-	} action = NONE;
+	};
+
+	EAction action = NONE;
 	std::vector<FactionID> bannedTowns;
 
 
@@ -375,4 +383,22 @@
 	}
 };
 
+struct DLL_LINKAGE LobbyDelete : public CLobbyPackToServer
+{
+	enum class EType : ui8 {
+		SAVEGAME, SAVEGAME_FOLDER, RANDOMMAP
+	};
+
+	EType type = EType::SAVEGAME;
+	std::string name;
+
+	void visitTyped(ICPackVisitor & visitor) override;
+
+	template <typename Handler> void serialize(Handler &h)
+	{
+		h & type;
+		h & name;
+	}
+};
+
 VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/networkPacks/PacksForServer.h vcmi/lib/networkPacks/PacksForServer.h
--- vcmi-1.5.7/lib/networkPacks/PacksForServer.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/networkPacks/PacksForServer.h	2024-12-19 15:00:22.925149053 +0100
@@ -280,11 +280,54 @@
 	}
 };
 
+struct DLL_LINKAGE VisitTownBuilding : public CPackForServer
+{
+	VisitTownBuilding() = default;
+	VisitTownBuilding(const ObjectInstanceID & TID, const BuildingID BID)
+		: tid(TID)
+		, bid(BID)
+	{
+	}
+	ObjectInstanceID tid;
+	BuildingID bid;
+
+	void visitTyped(ICPackVisitor & visitor) override;
+
+	template <typename Handler> void serialize(Handler & h)
+	{
+		h & static_cast<CPackForServer &>(*this);
+		h & tid;
+		h & bid;
+	}
+};
+
 struct DLL_LINKAGE RazeStructure : public BuildStructure
 {
 	void visitTyped(ICPackVisitor & visitor) override;
 };
 
+struct DLL_LINKAGE SpellResearch : public CPackForServer
+{
+	SpellResearch() = default;
+	SpellResearch(const ObjectInstanceID & TID, SpellID spellAtSlot, bool accepted)
+		: tid(TID), spellAtSlot(spellAtSlot), accepted(accepted)
+	{
+	}
+	ObjectInstanceID tid;
+	SpellID spellAtSlot;
+	bool accepted;
+
+	void visitTyped(ICPackVisitor & visitor) override;
+
+	template <typename Handler> void serialize(Handler & h)
+	{
+		h & static_cast<CPackForServer &>(*this);
+		h & tid;
+		h & spellAtSlot;
+		h & accepted;
+	}
+};
+
 struct DLL_LINKAGE RecruitCreatures : public CPackForServer
 {
 	RecruitCreatures() = default;
diff --color -urN vcmi-1.5.7/lib/networkPacks/SaveLocalState.h vcmi/lib/networkPacks/SaveLocalState.h
--- vcmi-1.5.7/lib/networkPacks/SaveLocalState.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/networkPacks/SaveLocalState.h	2024-12-19 15:00:22.925149053 +0100
@@ -0,0 +1,31 @@
+/*
+ * SaveLocalState.h, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#pragma once
+
+#include "NetPacksBase.h"
+
+#include "../json/JsonNode.h"
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+struct DLL_LINKAGE SaveLocalState : public CPackForServer
+{
+	JsonNode data;
+
+	void visitTyped(ICPackVisitor & visitor) override;
+
+	template <typename Handler> void serialize(Handler & h)
+	{
+		h & static_cast<CPackForServer &>(*this);
+		h & data;
+	}
+};
+
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/networkPacks/SetRewardableConfiguration.h vcmi/lib/networkPacks/SetRewardableConfiguration.h
--- vcmi-1.5.7/lib/networkPacks/SetRewardableConfiguration.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/networkPacks/SetRewardableConfiguration.h	2024-12-19 15:00:22.925149053 +0100
@@ -0,0 +1,51 @@
+/*
+ * SetRewardableConfiguration.h, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#pragma once
+
+#include "NetPacksBase.h"
+
+#include "../rewardable/Configuration.h"
+#include "../mapObjectConstructors/CBankInstanceConstructor.h"
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+struct DLL_LINKAGE SetRewardableConfiguration : public CPackForClient
+{
+	void applyGs(CGameState * gs) override;
+	void visitTyped(ICPackVisitor & visitor) override;
+
+	ObjectInstanceID objectID;
+	BuildingID buildingID;
+	Rewardable::Configuration configuration;
+
+	template <typename Handler> void serialize(Handler & h)
+	{
+		h & objectID;
+		h & buildingID;
+		h & configuration;
+	}
+};
+
+struct DLL_LINKAGE SetBankConfiguration : public CPackForClient
+{
+	void applyGs(CGameState * gs) override;
+	void visitTyped(ICPackVisitor & visitor) override;
+
+	ObjectInstanceID objectID;
+	BankConfig configuration;
+
+	template <typename Handler> void serialize(Handler & h)
+	{
+		h & objectID;
+		h & configuration;
+	}
+};
+
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/networkPacks/SetStackEffect.h vcmi/lib/networkPacks/SetStackEffect.h
--- vcmi-1.5.7/lib/networkPacks/SetStackEffect.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/networkPacks/SetStackEffect.h	2024-12-19 15:00:22.925149053 +0100
@@ -19,7 +19,7 @@
 
 struct DLL_LINKAGE SetStackEffect : public CPackForClient
 {
-	void applyGs(CGameState * gs);
+	void applyGs(CGameState * gs) override;
 	void applyBattle(IBattleState * battleState);
 
 	BattleID battleID = BattleID::NONE;
diff --color -urN vcmi-1.5.7/lib/ObstacleHandler.cpp vcmi/lib/ObstacleHandler.cpp
--- vcmi-1.5.7/lib/ObstacleHandler.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/ObstacleHandler.cpp	2024-12-19 15:00:22.866146615 +0100
@@ -12,6 +12,7 @@
 #include "BattleFieldHandler.h"
 #include "json/JsonNode.h"
 #include "modding/IdentifierStorage.h"
+#include "VCMI_Lib.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
@@ -27,7 +28,12 @@
 
 std::string ObstacleInfo::getJsonKey() const
 {
-	return identifier;
+	return modScope + ':' + identifier;
+}
+
+std::string ObstacleInfo::getModScope() const
+{
+	return modScope;
 }
 
 std::string ObstacleInfo::getNameTranslated() const
@@ -84,12 +90,13 @@
 	return vstd::contains(allowedTerrains, terrainType);
 }
 
-ObstacleInfo * ObstacleHandler::loadFromJson(const std::string & scope, const JsonNode & json, const std::string & identifier, size_t index)
+std::shared_ptr<ObstacleInfo> ObstacleHandler::loadFromJson(const std::string & scope, const JsonNode & json, const std::string & identifier, size_t index)
 {
 	assert(identifier.find(':') == std::string::npos);
 
-	auto * info = new ObstacleInfo(Obstacle(index), identifier);
+	auto info = std::make_shared<ObstacleInfo>(Obstacle(index), identifier);
 	
+	info->modScope = scope;
 	info->animation = AnimationPath::fromJson(json["animation"]);
 	info->width = json["width"].Integer();
 	info->height = json["height"].Integer();
diff --color -urN vcmi-1.5.7/lib/ObstacleHandler.h vcmi/lib/ObstacleHandler.h
--- vcmi-1.5.7/lib/ObstacleHandler.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/ObstacleHandler.h	2024-12-19 15:00:22.866146615 +0100
@@ -31,6 +31,7 @@
 	
 	Obstacle obstacle;
 	si32 iconIndex;
+	std::string modScope;
 	std::string identifier;
 	AudioPath appearSound;
 	AnimationPath appearAnimation;
@@ -47,6 +48,7 @@
 	int32_t getIndex() const override;
 	int32_t getIconIndex() const override;
 	std::string getJsonKey() const override;
+	std::string getModScope() const override;
 	std::string getNameTranslated() const override;
 	std::string getNameTextID() const override;
 	void registerIcons(const IconRegistar & cb) const override;
@@ -64,8 +66,8 @@
 
 class ObstacleHandler: public CHandlerBase<Obstacle, ObstacleInfo, ObstacleInfo, ObstacleService>
 {
-public:	
-	ObstacleInfo * loadFromJson(const std::string & scope,
+public:
+	std::shared_ptr<ObstacleInfo> loadFromJson(const std::string & scope,
 										const JsonNode & json,
 										const std::string & identifier,
 										size_t index) override;
diff --color -urN vcmi-1.5.7/lib/pathfinder/CGPathNode.h vcmi/lib/pathfinder/CGPathNode.h
--- vcmi-1.5.7/lib/pathfinder/CGPathNode.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/pathfinder/CGPathNode.h	2024-12-19 15:00:22.925149053 +0100
@@ -59,18 +59,22 @@
 
 struct DLL_LINKAGE CGPathNode
 {
+	using TFibHeap = boost::heap::fibonacci_heap<CGPathNode *, boost::heap::compare<NodeComparer<CGPathNode>>>;
 	using ELayer = EPathfindingLayer;
 
+	TFibHeap::handle_type pqHandle;
+	TFibHeap * pq;
 	CGPathNode * theNodeBefore;
+
 	int3 coord; //coordinates
 	ELayer layer;
+
+	float cost; //total cost of the path to this tile measured in turns with fractions
 	int moveRemains; //remaining movement points after hero reaches the tile
 	ui8 turns; //how many turns we have to wait before reaching the tile - 0 means current turn
-
 	EPathAccessibility accessible;
 	EPathNodeAction action;
 	bool locked;
-	bool inPQ;
 
 	CGPathNode()
 		: coord(-1),
@@ -89,9 +93,14 @@
 		cost = std::numeric_limits<float>::max();
 		turns = 255;
 		theNodeBefore = nullptr;
-		action = EPathNodeAction::UNKNOWN;
-		inPQ = false;
 		pq = nullptr;
+		action = EPathNodeAction::UNKNOWN;
+	}
+
+	STRONG_INLINE
+	bool inPQ() const
+	{
+		return pq != nullptr;
 	}
 
 	STRONG_INLINE
@@ -109,7 +118,7 @@
 		bool getUpNode = value < cost;
 		cost = value;
 		// If the node is in the heap, update the heap.
-		if(inPQ && pq != nullptr)
+		if(inPQ())
 		{
 			if(getUpNode)
 			{
@@ -155,14 +164,6 @@
 
 		return true;
 	}
-
-	using TFibHeap = boost::heap::fibonacci_heap<CGPathNode *, boost::heap::compare<NodeComparer<CGPathNode>>>;
-
-	TFibHeap::handle_type pqHandle;
-	TFibHeap* pq;
-
-private:
-	float cost; //total cost of the path to this tile measured in turns with fractions
 };
 
 struct DLL_LINKAGE CGPath
diff --color -urN vcmi-1.5.7/lib/pathfinder/CPathfinder.cpp vcmi/lib/pathfinder/CPathfinder.cpp
--- vcmi-1.5.7/lib/pathfinder/CPathfinder.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/pathfinder/CPathfinder.cpp	2024-12-19 15:00:22.926149095 +0100
@@ -82,9 +82,8 @@
 
 void CPathfinder::push(CGPathNode * node)
 {
-	if(node && !node->inPQ)
+	if(node && !node->inPQ())
 	{
-		node->inPQ = true;
 		node->pq = &this->pq;
 		auto handle = pq.push(node);
 		node->pqHandle = handle;
@@ -96,14 +95,13 @@
 	auto * node = pq.top();
 
 	pq.pop();
-	node->inPQ = false;
 	node->pq = nullptr;
 	return node;
 }
 
 void CPathfinder::calculatePaths()
 {
-	//logGlobal->info("Calculating paths for hero %s (adress  %d) of player %d", hero->name, hero , hero->tempOwner);
+	//logGlobal->info("Calculating paths for hero %s (address  %d) of player %d", hero->name, hero , hero->tempOwner);
 
 	//initial tile - set cost on 0 and add to the queue
 	std::vector<CGPathNode *> initialNodes = config->nodeStorage->getInitialNodes();
@@ -175,7 +173,7 @@
 				if(!hlp->isPatrolMovementAllowed(neighbour->coord))
 					continue;
 
-				/// Check transition without tile accessability rules
+				/// Check transition without tile accessibility rules
 				if(source.node->layer != neighbour->layer && !isLayerTransitionPossible())
 					continue;
 
@@ -266,8 +264,7 @@
 {
 	TeleporterTilesVector allowedExits;
 
-	auto towns = getPlayerState(hero->tempOwner)->towns;
-	for(const auto & town : towns)
+	for(const auto & town : getPlayerState(hero->tempOwner)->getTowns())
 	{
 		if(town->id != source.nodeObject->id && town->visitingHero == nullptr
 			&& town->hasBuilt(BuildingID::CASTLE_GATE, ETownType::INFERNO))
@@ -295,7 +292,7 @@
 	{
 		auto * town = dynamic_cast<const CGTownInstance *>(source.nodeObject);
 		assert(town);
-		if (town && town->getFaction() == FactionID::INFERNO)
+		if (town && town->getFactionID() == FactionID::INFERNO)
 		{
 			/// TODO: Find way to reuse CPlayerSpecificInfoCallback::getTownsInfo
 			/// This may be handy if we allow to use teleportation to friendly towns
@@ -468,7 +465,7 @@
 
 bool CPathfinderHelper::addTeleportWhirlpool(const CGWhirlpool * obj) const
 {
-	return options.useTeleportWhirlpool && hasBonusOfType(BonusType::WHIRLPOOL_PROTECTION) && obj;
+	return options.useTeleportWhirlpool && (whirlpoolProtection || options.forceUseTeleportWhirlpool) && obj;
 }
 
 int CPathfinderHelper::movementPointsAfterEmbark(int movement, int basicCost, bool disembark) const
@@ -508,6 +505,8 @@
 	updateTurnInfo();
 	initializePatrol();
 
+	whirlpoolProtection = Hero->hasBonusOfType(BonusType::WHIRLPOOL_PROTECTION);
+
 	SpellID flySpell = SpellID::FLY;
 	canCastFly = Hero->canCastThisSpell(flySpell.toSpell());
 
@@ -597,25 +596,19 @@
 			continue;
 
 		const TerrainTile & destTile = map->getTile(destCoord);
-		if(!destTile.terType->isPassable())
+		if(!destTile.getTerrain()->isPassable())
 			continue;
 
-// 		//we cannot visit things from blocked tiles
-// 		if(srcTile.blocked && !srcTile.visitable && destTile.visitable && srcTile.blockingObjects.front()->ID != HEROI_TYPE)
-// 		{
-// 			continue;
-// 		}
-
 		/// Following condition let us avoid diagonal movement over coast when sailing
-		if(srcTile.terType->isWater() && limitCoastSailing && destTile.terType->isWater() && dir.x && dir.y) //diagonal move through water
+		if(srcTile.isWater() && limitCoastSailing && destTile.isWater() && dir.x && dir.y) //diagonal move through water
 		{
 			const int3 horizontalNeighbour = srcCoord + int3{dir.x, 0, 0};
 			const int3 verticalNeighbour = srcCoord + int3{0, dir.y, 0};
-			if(map->getTile(horizontalNeighbour).terType->isLand() || map->getTile(verticalNeighbour).terType->isLand())
+			if(map->getTile(horizontalNeighbour).isLand() || map->getTile(verticalNeighbour).isLand())
 				continue;
 		}
 
-		if(indeterminate(onLand) || onLand == destTile.terType->isLand())
+		if(indeterminate(onLand) || onLand == destTile.isLand())
 		{
 			vec.push_back(destCoord);
 		}
@@ -663,13 +656,13 @@
 
 	bool isSailLayer;
 	if(indeterminate(isDstSailLayer))
-		isSailLayer = hero->boat && hero->boat->layer == EPathfindingLayer::SAIL && dt->terType->isWater();
+		isSailLayer = hero->boat && hero->boat->layer == EPathfindingLayer::SAIL && dt->isWater();
 	else
 		isSailLayer = static_cast<bool>(isDstSailLayer);
 
 	bool isWaterLayer;
 	if(indeterminate(isDstWaterLayer))
-		isWaterLayer = ((hero->boat && hero->boat->layer == EPathfindingLayer::WATER) || ti->hasBonusOfType(BonusType::WATER_WALKING)) && dt->terType->isWater();
+		isWaterLayer = ((hero->boat && hero->boat->layer == EPathfindingLayer::WATER) || ti->hasBonusOfType(BonusType::WATER_WALKING)) && dt->isWater();
 	else
 		isWaterLayer = static_cast<bool>(isDstWaterLayer);
 	
@@ -704,7 +697,7 @@
 	{
 		NeighbourTilesVector vec;
 
-		getNeighbours(*dt, dst, vec, ct->terType->isLand(), true);
+		getNeighbours(*dt, dst, vec, ct->isLand(), true);
 		for(const auto & elem : vec)
 		{
 			int fcost = getMovementCost(dst, elem, nullptr, nullptr, left, false);
diff --color -urN vcmi-1.5.7/lib/pathfinder/CPathfinder.h vcmi/lib/pathfinder/CPathfinder.h
--- vcmi-1.5.7/lib/pathfinder/CPathfinder.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/pathfinder/CPathfinder.h	2024-12-19 15:00:22.926149095 +0100
@@ -85,6 +85,7 @@
 	const PathfinderOptions & options;
 	bool canCastFly;
 	bool canCastWaterWalk;
+	bool whirlpoolProtection;
 
 	CPathfinderHelper(CGameState * gs, const CGHeroInstance * Hero, const PathfinderOptions & Options);
 	virtual ~CPathfinderHelper();
diff --color -urN vcmi-1.5.7/lib/pathfinder/NodeStorage.cpp vcmi/lib/pathfinder/NodeStorage.cpp
--- vcmi-1.5.7/lib/pathfinder/NodeStorage.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/pathfinder/NodeStorage.cpp	2024-12-19 15:00:22.926149095 +0100
@@ -41,7 +41,7 @@
 			for(pos.y=0; pos.y < sizes.y; ++pos.y)
 			{
 				const TerrainTile & tile = gs->map->getTile(pos);
-				if(tile.terType->isWater())
+				if(tile.isWater())
 				{
 					resetTile(pos, ELayer::SAIL, PathfinderUtil::evaluateAccessibility<ELayer::SAIL>(pos, tile, fow, player, gs));
 					if(useFlying)
@@ -49,7 +49,7 @@
 					if(useWaterWalking)
 						resetTile(pos, ELayer::WATER, PathfinderUtil::evaluateAccessibility<ELayer::WATER>(pos, tile, fow, player, gs));
 				}
-				if(tile.terType->isLand())
+				if(tile.isLand())
 				{
 					resetTile(pos, ELayer::LAND, PathfinderUtil::evaluateAccessibility<ELayer::LAND>(pos, tile, fow, player, gs));
 					if(useFlying)
diff --color -urN vcmi-1.5.7/lib/pathfinder/PathfinderOptions.cpp vcmi/lib/pathfinder/PathfinderOptions.cpp
--- vcmi-1.5.7/lib/pathfinder/PathfinderOptions.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/pathfinder/PathfinderOptions.cpp	2024-12-19 15:00:22.926149095 +0100
@@ -10,7 +10,8 @@
 #include "StdInc.h"
 #include "PathfinderOptions.h"
 
-#include "../GameSettings.h"
+#include "../gameState/CGameState.h"
+#include "../IGameSettings.h"
 #include "../VCMI_Lib.h"
 #include "NodeStorage.h"
 #include "PathfindingRules.h"
@@ -18,28 +19,30 @@
 
 VCMI_LIB_NAMESPACE_BEGIN
 
-PathfinderOptions::PathfinderOptions()
+PathfinderOptions::PathfinderOptions(const CGameInfoCallback * cb)
 	: useFlying(true)
 	, useWaterWalking(true)
-	, ignoreGuards(VLC->settings()->getBoolean(EGameSettings::PATHFINDER_IGNORE_GUARDS))
-	, useEmbarkAndDisembark(VLC->settings()->getBoolean(EGameSettings::PATHFINDER_USE_BOAT))
-	, useTeleportTwoWay(VLC->settings()->getBoolean(EGameSettings::PATHFINDER_USE_MONOLITH_TWO_WAY))
-	, useTeleportOneWay(VLC->settings()->getBoolean(EGameSettings::PATHFINDER_USE_MONOLITH_ONE_WAY_UNIQUE))
-	, useTeleportOneWayRandom(VLC->settings()->getBoolean(EGameSettings::PATHFINDER_USE_MONOLITH_ONE_WAY_RANDOM))
-	, useTeleportWhirlpool(VLC->settings()->getBoolean(EGameSettings::PATHFINDER_USE_WHIRLPOOL))
-	, originalFlyRules(VLC->settings()->getBoolean(EGameSettings::PATHFINDER_ORIGINAL_FLY_RULES))
+	, ignoreGuards(cb->getSettings().getBoolean(EGameSettings::PATHFINDER_IGNORE_GUARDS))
+	, useEmbarkAndDisembark(cb->getSettings().getBoolean(EGameSettings::PATHFINDER_USE_BOAT))
+	, useTeleportTwoWay(cb->getSettings().getBoolean(EGameSettings::PATHFINDER_USE_MONOLITH_TWO_WAY))
+	, useTeleportOneWay(cb->getSettings().getBoolean(EGameSettings::PATHFINDER_USE_MONOLITH_ONE_WAY_UNIQUE))
+	, useTeleportOneWayRandom(cb->getSettings().getBoolean(EGameSettings::PATHFINDER_USE_MONOLITH_ONE_WAY_RANDOM))
+	, useTeleportWhirlpool(cb->getSettings().getBoolean(EGameSettings::PATHFINDER_USE_WHIRLPOOL))
+	, originalFlyRules(cb->getSettings().getBoolean(EGameSettings::PATHFINDER_ORIGINAL_FLY_RULES))
 	, useCastleGate(false)
 	, lightweightFlyingMode(false)
 	, oneTurnSpecialLayersLimit(true)
 	, turnLimit(std::numeric_limits<uint8_t>::max())
 	, canUseCast(false)
 	, allowLayerTransitioningAfterBattle(false)
+	, forceUseTeleportWhirlpool(false)
 {
 }
 
-PathfinderConfig::PathfinderConfig(std::shared_ptr<INodeStorage> nodeStorage, std::vector<std::shared_ptr<IPathfindingRule>> rules):
+PathfinderConfig::PathfinderConfig(std::shared_ptr<INodeStorage> nodeStorage, const CGameInfoCallback * callback, std::vector<std::shared_ptr<IPathfindingRule>> rules):
 	nodeStorage(std::move(nodeStorage)),
-	rules(std::move(rules))
+	rules(std::move(rules)),
+	options(callback)
 {
 }
 
@@ -57,7 +60,7 @@
 SingleHeroPathfinderConfig::~SingleHeroPathfinderConfig() = default;
 
 SingleHeroPathfinderConfig::SingleHeroPathfinderConfig(CPathsInfo & out, CGameState * gs, const CGHeroInstance * hero)
-	: PathfinderConfig(std::make_shared<NodeStorage>(out, hero), buildRuleSet())
+	: PathfinderConfig(std::make_shared<NodeStorage>(out, hero), gs, buildRuleSet())
 {
 	pathfinderHelper = std::make_unique<CPathfinderHelper>(gs, hero, options);
 }
diff --color -urN vcmi-1.5.7/lib/pathfinder/PathfinderOptions.h vcmi/lib/pathfinder/PathfinderOptions.h
--- vcmi-1.5.7/lib/pathfinder/PathfinderOptions.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/pathfinder/PathfinderOptions.h	2024-12-19 15:00:22.926149095 +0100
@@ -16,7 +16,7 @@
 class CPathfinderHelper;
 class CGameState;
 class CGHeroInstance;
-
+class CGameInfoCallback;
 struct PathNodeInfo;
 struct CPathsInfo;
 
@@ -30,6 +30,7 @@
 	bool useTeleportOneWay; // One-way monoliths with one known exit only
 	bool useTeleportOneWayRandom; // One-way monoliths with more than one known exit
 	bool useTeleportWhirlpool; // Force enabled if hero protected or unaffected (have one stack of one creature)
+	bool forceUseTeleportWhirlpool; // Force enabled if hero protected or unaffected (have one stack of one creature)
 
 							   /// TODO: Find out with client and server code, merge with normal teleporters.
 							   /// Likely proper implementation would require some refactoring of CGTeleport.
@@ -84,7 +85,7 @@
 	/// </summary>
 	bool allowLayerTransitioningAfterBattle;
 
-	PathfinderOptions();
+	PathfinderOptions(const CGameInfoCallback * callback);
 };
 
 class DLL_LINKAGE PathfinderConfig
@@ -96,6 +97,7 @@
 
 	PathfinderConfig(
 		std::shared_ptr<INodeStorage> nodeStorage,
+		const CGameInfoCallback * callback,
 		std::vector<std::shared_ptr<IPathfindingRule>> rules);
 	virtual ~PathfinderConfig() = default;
 
diff --color -urN vcmi-1.5.7/lib/pathfinder/PathfinderUtil.h vcmi/lib/pathfinder/PathfinderUtil.h
--- vcmi-1.5.7/lib/pathfinder/PathfinderUtil.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/pathfinder/PathfinderUtil.h	2024-12-19 15:00:22.926149095 +0100
@@ -19,20 +19,20 @@
 
 namespace PathfinderUtil
 {
-	using FoW = std::unique_ptr<boost::multi_array<ui8, 3>>;
+	using FoW = boost::multi_array<ui8, 3>;
 	using ELayer = EPathfindingLayer;
 
 	template<EPathfindingLayer::Type layer>
 	EPathAccessibility evaluateAccessibility(const int3 & pos, const TerrainTile & tinfo, const FoW & fow, const PlayerColor player, const CGameState * gs)
 	{
-		if(!(*fow)[pos.z][pos.x][pos.y])
+		if(!fow[pos.z][pos.x][pos.y])
 			return EPathAccessibility::BLOCKED;
 
 		switch(layer)
 		{
 		case ELayer::LAND:
 		case ELayer::SAIL:
-			if(tinfo.visitable)
+			if(tinfo.visitable())
 			{
 				if(tinfo.visitableObjects.front()->ID == Obj::SANCTUARY && tinfo.visitableObjects.back()->ID == Obj::HERO && tinfo.visitableObjects.back()->tempOwner != player) //non-owned hero stands on Sanctuary
 				{
@@ -51,7 +51,7 @@
 					}
 				}
 			}
-			else if(tinfo.blocked)
+			else if(tinfo.blocked())
 			{
 				return EPathAccessibility::BLOCKED;
 			}
@@ -64,7 +64,7 @@
 			break;
 
 		case ELayer::WATER:
-			if(tinfo.blocked || tinfo.terType->isLand())
+			if(tinfo.blocked() || tinfo.isLand())
 				return EPathAccessibility::BLOCKED;
 
 			break;
diff --color -urN vcmi-1.5.7/lib/pathfinder/PathfindingRules.cpp vcmi/lib/pathfinder/PathfindingRules.cpp
--- vcmi-1.5.7/lib/pathfinder/PathfindingRules.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/pathfinder/PathfindingRules.cpp	2024-12-19 15:00:22.926149095 +0100
@@ -380,7 +380,7 @@
 
 	case EPathfindingLayer::SAIL:
 		// have to disembark first before visiting objects on land
-		if (destination.tile->visitable)
+		if (destination.tile->visitable())
 			destination.blocked = true;
 
 		//can disembark only on accessible tiles or tiles guarded by nearby monster
@@ -397,7 +397,7 @@
 				if (destination.node->accessible == EPathAccessibility::BLOCKVIS)
 				{
 					// Can't visit 'blockvisit' objects on coast if hero will end up on water terrain
-					if (source.tile->blocked || !destination.tile->entrableTerrain(source.tile))
+					if (source.tile->blocked() || !destination.tile->entrableTerrain(source.tile))
 						destination.blocked = true;
 				}
 			}
diff --color -urN vcmi-1.5.7/lib/pathfinder/TurnInfo.cpp vcmi/lib/pathfinder/TurnInfo.cpp
--- vcmi-1.5.7/lib/pathfinder/TurnInfo.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/pathfinder/TurnInfo.cpp	2024-12-19 15:00:22.927149136 +0100
@@ -41,7 +41,7 @@
 	maxMovePointsWater(-1),
 	turn(turn)
 {
-	bonuses = hero->getAllBonuses(Selector::days(turn), Selector::all, nullptr, "");
+	bonuses = hero->getAllBonuses(Selector::days(turn), Selector::all, "");
 	bonusCache = std::make_unique<BonusCache>(bonuses);
 	nativeTerrain = hero->getNativeTerrain();
 }
@@ -144,7 +144,7 @@
 		bonusCache->pathfindingVal = bonuses->valOfBonuses(Selector::type()(BonusType::ROUGH_TERRAIN_DISCOUNT));
 		break;
 	default:
-		bonuses = hero->getAllBonuses(Selector::days(turn), Selector::all, nullptr, "");
+		bonuses = hero->getAllBonuses(Selector::days(turn), Selector::all, "");
 	}
 }
 
diff --color -urN vcmi-1.5.7/lib/Rect.h vcmi/lib/Rect.h
--- vcmi-1.5.7/lib/Rect.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/Rect.h	2024-12-19 15:00:22.868146698 +0100
@@ -119,6 +119,13 @@
 		return Rect(x-p.x,y-p.y,w,h);
 	}
 
+	template<typename T>
+	Rect operator*(const T &mul) const
+	{
+		return Rect(x*mul, y*mul, w*mul, h*mul);
+	}
+
+
 	Rect& operator=(const Rect &p)
 	{
 		x = p.x;
diff --color -urN vcmi-1.5.7/lib/registerTypes/RegisterTypesClientPacks.h vcmi/lib/registerTypes/RegisterTypesClientPacks.h
--- vcmi-1.5.7/lib/registerTypes/RegisterTypesClientPacks.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/registerTypes/RegisterTypesClientPacks.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,125 +0,0 @@
-/*
- * RegisterTypesClientPacks.h, part of VCMI engine
- *
- * Authors: listed in file AUTHORS in main folder
- *
- * License: GNU General Public License v2.0 or later
- * Full text of license available in license.txt file, in main folder
- *
- */
-#pragma once
-
-#include "../networkPacks/PacksForClient.h"
-#include "../networkPacks/PacksForClientBattle.h"
-#include "../networkPacks/SetStackEffect.h"
-
-VCMI_LIB_NAMESPACE_BEGIN
-
-template<typename Serializer>
-void registerTypesClientPacks(Serializer &s)
-{
-	s.template registerType<CPack, CPackForClient>();
-
-	s.template registerType<CPackForClient, PackageApplied>();
-	s.template registerType<CPackForClient, SystemMessage>();
-	s.template registerType<CPackForClient, PlayerBlocked>();
-	s.template registerType<CPackForClient, PlayerCheated>();
-	s.template registerType<CPackForClient, PlayerStartsTurn>();
-	s.template registerType<CPackForClient, DaysWithoutTown>();
-	s.template registerType<CPackForClient, TurnTimeUpdate>();
-	s.template registerType<CPackForClient, SetResources>();
-	s.template registerType<CPackForClient, SetPrimSkill>();
-	s.template registerType<CPackForClient, SetSecSkill>();
-	s.template registerType<CPackForClient, HeroVisitCastle>();
-	s.template registerType<CPackForClient, ChangeSpells>();
-	s.template registerType<CPackForClient, SetMana>();
-	s.template registerType<CPackForClient, SetMovePoints>();
-	s.template registerType<CPackForClient, FoWChange>();
-	s.template registerType<CPackForClient, SetAvailableHero>();
-	s.template registerType<CPackForClient, GiveBonus>();
-	s.template registerType<CPackForClient, ChangeObjPos>();
-	s.template registerType<CPackForClient, PlayerEndsTurn>();
-	s.template registerType<CPackForClient, PlayerEndsGame>();
-	s.template registerType<CPackForClient, PlayerReinitInterface>();
-	s.template registerType<CPackForClient, RemoveBonus>();
-	s.template registerType<CPackForClient, UpdateArtHandlerLists>();
-	s.template registerType<CPackForClient, UpdateMapEvents>();
-	s.template registerType<CPackForClient, UpdateCastleEvents>();
-	s.template registerType<CPackForClient, ChangeFormation>();
-	s.template registerType<CPackForClient, RemoveObject>();
-	s.template registerType<CPackForClient, TryMoveHero>();
-	s.template registerType<CPackForClient, NewStructures>();
-	s.template registerType<CPackForClient, RazeStructures>();
-	s.template registerType<CPackForClient, SetAvailableCreatures>();
-	s.template registerType<CPackForClient, SetHeroesInTown>();
-	s.template registerType<CPackForClient, HeroRecruited>();
-	s.template registerType<CPackForClient, GiveHero>();
-	s.template registerType<CPackForClient, NewTurn>();
-	s.template registerType<CPackForClient, InfoWindow>();
-	s.template registerType<CPackForClient, SetObjectProperty>();
-	s.template registerType<CPackForClient, AdvmapSpellCast>();
-	s.template registerType<CPackForClient, OpenWindow>();
-	s.template registerType<CPackForClient, NewObject>();
-	s.template registerType<CPackForClient, NewArtifact>();
-	s.template registerType<CPackForClient, AddQuest>();
-	s.template registerType<CPackForClient, SetAvailableArtifacts>();
-	s.template registerType<CPackForClient, CenterView>();
-	s.template registerType<CPackForClient, HeroVisit>();
-	s.template registerType<CPackForClient, SetCommanderProperty>();
-	s.template registerType<CPackForClient, ChangeObjectVisitors>();
-	s.template registerType<CPackForClient, ChangeArtifactsCostume>();
-	s.template registerType<CPackForClient, ShowWorldViewEx>();
-	s.template registerType<CPackForClient, EntitiesChanged>();
-	s.template registerType<CPackForClient, BattleStart>();
-	s.template registerType<CPackForClient, BattleNextRound>();
-	s.template registerType<CPackForClient, BattleSetActiveStack>();
-	s.template registerType<CPackForClient, BattleResult>();
-	s.template registerType<CPackForClient, BattleResultAccepted>();
-	s.template registerType<CPackForClient, BattleCancelled>();
-	s.template registerType<CPackForClient, BattleLogMessage>();
-	s.template registerType<CPackForClient, BattleStackMoved>();
-	s.template registerType<CPackForClient, BattleAttack>();
-	s.template registerType<CPackForClient, StartAction>();
-	s.template registerType<CPackForClient, EndAction>();
-	s.template registerType<CPackForClient, BattleSpellCast>();
-	s.template registerType<CPackForClient, SetStackEffect>();
-	s.template registerType<CPackForClient, BattleTriggerEffect>();
-	s.template registerType<CPackForClient, BattleUpdateGateState>();
-	s.template registerType<CPackForClient, BattleSetStackProperty>();
-	s.template registerType<CPackForClient, StacksInjured>();
-	s.template registerType<CPackForClient, BattleResultsApplied>();
-	s.template registerType<CPackForClient, BattleUnitsChanged>();
-	s.template registerType<CPackForClient, BattleObstaclesChanged>();
-	s.template registerType<CPackForClient, CatapultAttack>();
-
-	s.template registerType<CPackForClient, Query>();
-	s.template registerType<Query, HeroLevelUp>();
-	s.template registerType<Query, CommanderLevelUp>();
-	s.template registerType<Query, BlockingDialog>();
-	s.template registerType<Query, GarrisonDialog>();
-	s.template registerType<Query, ExchangeDialog>();
-	s.template registerType<Query, TeleportDialog>();
-	s.template registerType<Query, MapObjectSelectDialog>();
-
-	s.template registerType<CPackForClient, CGarrisonOperationPack>();
-	s.template registerType<CGarrisonOperationPack, ChangeStackCount>();
-	s.template registerType<CGarrisonOperationPack, SetStackType>();
-	s.template registerType<CGarrisonOperationPack, EraseStack>();
-	s.template registerType<CGarrisonOperationPack, SwapStacks>();
-	s.template registerType<CGarrisonOperationPack, InsertNewStack>();
-	s.template registerType<CGarrisonOperationPack, RebalanceStacks>();
-
-	s.template registerType<CPackForClient, CArtifactOperationPack>();
-	s.template registerType<CArtifactOperationPack, PutArtifact>();
-	s.template registerType<CArtifactOperationPack, EraseArtifact>();
-	s.template registerType<CArtifactOperationPack, MoveArtifact>();
-	s.template registerType<CArtifactOperationPack, AssembledArtifact>();
-	s.template registerType<CArtifactOperationPack, DisassembledArtifact>();
-	s.template registerType<CArtifactOperationPack, BulkMoveArtifacts>();
-
-	s.template registerType<CPackForClient, PlayerMessageClient>();
-	s.template registerType<CGarrisonOperationPack, BulkRebalanceStacks>();
-	s.template registerType<CGarrisonOperationPack, BulkSmartRebalanceStacks>();
-}
-
-VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/registerTypes/RegisterTypes.h vcmi/lib/registerTypes/RegisterTypes.h
--- vcmi-1.5.7/lib/registerTypes/RegisterTypes.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/registerTypes/RegisterTypes.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,28 +0,0 @@
-/*
- * RegisterTypes.h, part of VCMI engine
- *
- * Authors: listed in file AUTHORS in main folder
- *
- * License: GNU General Public License v2.0 or later
- * Full text of license available in license.txt file, in main folder
- *
- */
-#pragma once
-
-#include "RegisterTypesClientPacks.h"
-#include "RegisterTypesLobbyPacks.h"
-#include "RegisterTypesMapObjects.h"
-#include "RegisterTypesServerPacks.h"
-
-VCMI_LIB_NAMESPACE_BEGIN
-
-template<typename Serializer>
-void registerTypes(Serializer &s)
-{
-	registerTypesMapObjects(s);
-	registerTypesClientPacks(s);
-	registerTypesServerPacks(s);
-	registerTypesLobbyPacks(s);
-}
-
-VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/registerTypes/RegisterTypesLobbyPacks.h vcmi/lib/registerTypes/RegisterTypesLobbyPacks.h
--- vcmi-1.5.7/lib/registerTypes/RegisterTypesLobbyPacks.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/registerTypes/RegisterTypesLobbyPacks.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,65 +0,0 @@
-/*
- * RegisterTypesLobbyPacks.h, part of VCMI engine
- *
- * Authors: listed in file AUTHORS in main folder
- *
- * License: GNU General Public License v2.0 or later
- * Full text of license available in license.txt file, in main folder
- *
- */
-#pragma once
-
-#include "../networkPacks/PacksForLobby.h"
-#include "../gameState/CGameState.h"
-#include "../campaign/CampaignState.h"
-#include "../mapping/CMapInfo.h"
-#include "../rmg/CMapGenOptions.h"
-#include "../gameState/TavernHeroesPool.h"
-#include "../gameState/CGameStateCampaign.h"
-#include "../mapping/CMap.h"
-#include "../TerrainHandler.h"
-#include "../RiverHandler.h"
-#include "../RoadHandler.h"
-
-VCMI_LIB_NAMESPACE_BEGIN
-
-template<typename Serializer>
-void registerTypesLobbyPacks(Serializer &s)
-{
-	s.template registerType<CPack, CPackForLobby>();
-	s.template registerType<CPackForLobby, CLobbyPackToPropagate>();
-	s.template registerType<CPackForLobby, CLobbyPackToServer>();
-
-	// Any client can sent
-	s.template registerType<CLobbyPackToPropagate, LobbyClientConnected>();
-	s.template registerType<CLobbyPackToPropagate, LobbyClientDisconnected>();
-	s.template registerType<CLobbyPackToPropagate, LobbyChatMessage>();
-	s.template registerType<CLobbyPackToServer, LobbyPvPAction>();
-	// Only host client send
-	s.template registerType<CLobbyPackToPropagate, LobbyGuiAction>();
-	s.template registerType<CLobbyPackToPropagate, LobbyLoadProgress>();
-	s.template registerType<CLobbyPackToPropagate, LobbyRestartGame>();
-	s.template registerType<CLobbyPackToPropagate, LobbyPrepareStartGame>();
-	s.template registerType<CLobbyPackToPropagate, LobbyStartGame>();
-	s.template registerType<CLobbyPackToPropagate, LobbyChangeHost>();
-	// Only server send
-	s.template registerType<CLobbyPackToPropagate, LobbyUpdateState>();
-	s.template registerType<CLobbyPackToPropagate, LobbyShowMessage>();
-
-	// For client with permissions
-	s.template registerType<CLobbyPackToServer, LobbyChangePlayerOption>();
-	// Only for host client
-	s.template registerType<CLobbyPackToServer, LobbySetMap>();
-	s.template registerType<CLobbyPackToServer, LobbySetCampaign>();
-	s.template registerType<CLobbyPackToServer, LobbySetCampaignMap>();
-	s.template registerType<CLobbyPackToServer, LobbySetCampaignBonus>();
-	s.template registerType<CLobbyPackToServer, LobbySetPlayer>();
-	s.template registerType<CLobbyPackToServer, LobbySetPlayerName>();
-	s.template registerType<CLobbyPackToServer, LobbySetTurnTime>();
-	s.template registerType<CLobbyPackToServer, LobbySetSimturns>();
-	s.template registerType<CLobbyPackToServer, LobbySetDifficulty>();
-	s.template registerType<CLobbyPackToServer, LobbyForceSetPlayer>();
-	s.template registerType<CLobbyPackToServer, LobbySetExtraOptions>();
-}
-
-VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/registerTypes/RegisterTypesMapObjects.h vcmi/lib/registerTypes/RegisterTypesMapObjects.h
--- vcmi-1.5.7/lib/registerTypes/RegisterTypesMapObjects.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/registerTypes/RegisterTypesMapObjects.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,139 +0,0 @@
-/*
- * RegisterTypesMapObjects.h, part of VCMI engine
- *
- * Authors: listed in file AUTHORS in main folder
- *
- * License: GNU General Public License v2.0 or later
- * Full text of license available in license.txt file, in main folder
- *
- */
-#pragma once
-
-#include "../mapObjectConstructors/CBankInstanceConstructor.h"
-#include "../mapObjects/MapObjects.h"
-#include "../mapObjects/CGCreature.h"
-#include "../mapObjects/CGTownBuilding.h"
-#include "../mapObjects/ObjectTemplate.h"
-#include "../battle/BattleInfo.h"
-#include "../battle/CObstacleInstance.h"
-#include "../bonuses/Limiters.h"
-#include "../bonuses/Updaters.h"
-#include "../bonuses/Propagators.h"
-#include "../CPlayerState.h"
-#include "../CStack.h"
-#include "../CHeroHandler.h"
-
-VCMI_LIB_NAMESPACE_BEGIN
-
-template<typename Serializer>
-void registerTypesMapObjects(Serializer &s)
-{
-	//////////////////////////////////////////////////////////////////////////
-	// Adventure map objects
-	//////////////////////////////////////////////////////////////////////////
-	s.template registerType<IObjectInterface, CGObjectInstance>();
-
-	// Non-armed objects
-	s.template registerType<CGObjectInstance, CGTeleport>();
-		s.template registerType<CGTeleport, CGMonolith>();
-			s.template registerType<CGMonolith, CGSubterraneanGate>();
-			s.template registerType<CGMonolith, CGWhirlpool>();
-	s.template registerType<CGObjectInstance, CGSignBottle>();
-	s.template registerType<CGObjectInstance, CGKeys>();
-		s.template registerType<CGKeys, CGKeymasterTent>();
-		s.template registerType<CGKeys, CGBorderGuard>(); s.template registerType<IQuestObject, CGBorderGuard>();
-			s.template registerType<CGBorderGuard, CGBorderGate>();
-	s.template registerType<CGObjectInstance, CGBoat>();
-	s.template registerType<CGObjectInstance, CGMagi>();
-	s.template registerType<CGObjectInstance, CGSirens>();
-	s.template registerType<CGObjectInstance, CGShipyard>();
-	s.template registerType<CGObjectInstance, CGDenOfthieves>();
-	s.template registerType<CGObjectInstance, CGLighthouse>();
-	s.template registerType<CGObjectInstance, CGTerrainPatch>();
-	s.template registerType<CGObjectInstance, HillFort>();
-	s.template registerType<CGObjectInstance, CGMarket>();
-		s.template registerType<CGMarket, CGBlackMarket>();
-		s.template registerType<CGMarket, CGUniversity>();
-	s.template registerType<CGObjectInstance, CGHeroPlaceholder>();
-
-	s.template registerType<CGObjectInstance, CArmedInstance>(); s.template registerType<CBonusSystemNode, CArmedInstance>(); s.template registerType<CCreatureSet, CArmedInstance>();
-
-	// Armed objects
-	s.template registerType<CArmedInstance, CGHeroInstance>(); s.template registerType<CArtifactSet, CGHeroInstance>();
-	s.template registerType<CArmedInstance, CGDwelling>();
-		s.template registerType<CGDwelling, CGTownInstance>();
-	s.template registerType<CArmedInstance, CGPandoraBox>();
-		s.template registerType<CGPandoraBox, CGEvent>();
-	s.template registerType<CArmedInstance, CGCreature>();
-	s.template registerType<CArmedInstance, CGGarrison>();
-	s.template registerType<CArmedInstance, CGArtifact>();
-	s.template registerType<CArmedInstance, CGResource>();
-	s.template registerType<CArmedInstance, CGMine>();
-	s.template registerType<CArmedInstance, CBank>();
-	s.template registerType<CArmedInstance, CGSeerHut>(); s.template registerType<IQuestObject, CGSeerHut>();
-	s.template registerType<CGSeerHut, CGQuestGuard>();
-
-	s.template registerType<IUpdater, GrowsWithLevelUpdater>();
-	s.template registerType<IUpdater, TimesHeroLevelUpdater>();
-	s.template registerType<IUpdater, TimesStackLevelUpdater>();
-	s.template registerType<IUpdater, OwnerUpdater>();
-	s.template registerType<IUpdater, ArmyMovementUpdater>();
-
-	s.template registerType<ILimiter, AnyOfLimiter>();
-	s.template registerType<ILimiter, NoneOfLimiter>();
-	s.template registerType<ILimiter, OppositeSideLimiter>();
-	//new types (other than netpacks) must register here
-	//order of type registration is critical for loading old savegames
-
-	//Other object-related
-	s.template registerType<IObjectInterface, CGTownBuilding>();
-		s.template registerType<CGTownBuilding, CTownBonus>();
-		s.template registerType<CGTownBuilding, COPWBonus>();
-		s.template registerType<CGTownBuilding, CTownRewardableBuilding>();
-
-	s.template registerType<CGObjectInstance, CRewardableObject>();
-
-	s.template registerType<CGObjectInstance, CTeamVisited>();
-		s.template registerType<CTeamVisited, CGObelisk>();
-
-	//end of objects
-
-	//////////////////////////////////////////////////////////////////////////
-	// Bonus system
-	//////////////////////////////////////////////////////////////////////////
-	//s.template registerType<IPropagator>();
-	s.template registerType<IPropagator, CPropagatorNodeType>();
-
-	// Limiters
-	//s.template registerType<ILimiter>();
-	s.template registerType<ILimiter, AllOfLimiter>();
-	s.template registerType<ILimiter, CCreatureTypeLimiter>();
-	s.template registerType<ILimiter, HasAnotherBonusLimiter>();
-	s.template registerType<ILimiter, CreatureTerrainLimiter>();
-	s.template registerType<ILimiter, FactionLimiter>();
-	s.template registerType<ILimiter, CreatureLevelLimiter>();
-	s.template registerType<ILimiter, CreatureAlignmentLimiter>();
-	s.template registerType<ILimiter, RankRangeLimiter>();
-	s.template registerType<ILimiter, UnitOnHexLimiter>();
-
-//	s.template registerType<CBonusSystemNode>();
-	s.template registerType<CBonusSystemNode, CArtifact>();
-	s.template registerType<CBonusSystemNode, CCreature>();
-	s.template registerType<CBonusSystemNode, CStackInstance>();
-	s.template registerType<CStackInstance, CCommanderInstance>();
-	s.template registerType<CBonusSystemNode, PlayerState>();
-	s.template registerType<CBonusSystemNode, TeamState>();
-	//s.template registerType<CGameState>(); //TODO
-	//s.template registerType<CArmedInstance>();
-	s.template registerType<CBonusSystemNode, CStack>();
-	s.template registerType<CBonusSystemNode, BattleInfo>();
-	//s.template registerType<QuestInfo>();
-	s.template registerType<CBonusSystemNode, CArtifactInstance>();
-
-	//s.template registerType<CObstacleInstance>();
-		s.template registerType<CObstacleInstance, SpellCreatedObstacle>();
-
-	s.template registerType<CGMarket, CGArtifactsAltar>();
-}
-
-VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/registerTypes/RegisterTypesServerPacks.h vcmi/lib/registerTypes/RegisterTypesServerPacks.h
--- vcmi-1.5.7/lib/registerTypes/RegisterTypesServerPacks.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/registerTypes/RegisterTypesServerPacks.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,58 +0,0 @@
-/*
- * RegisterTypesServerPacks.h, part of VCMI engine
- *
- * Authors: listed in file AUTHORS in main folder
- *
- * License: GNU General Public License v2.0 or later
- * Full text of license available in license.txt file, in main folder
- *
- */
-#pragma once
-
-#include "../networkPacks/PacksForServer.h"
-
-VCMI_LIB_NAMESPACE_BEGIN
-
-class BinarySerializer;
-class BinaryDeserializer;
-class CTypeList;
-
-template<typename Serializer>
-void registerTypesServerPacks(Serializer &s)
-{
-	s.template registerType<CPack, CPackForServer>();
-	s.template registerType<CPackForServer, EndTurn>();
-	s.template registerType<CPackForServer, DismissHero>();
-	s.template registerType<CPackForServer, MoveHero>();
-	s.template registerType<CPackForServer, ArrangeStacks>();
-	s.template registerType<CPackForServer, DisbandCreature>();
-	s.template registerType<CPackForServer, BuildStructure>();
-	s.template registerType<CPackForServer, RecruitCreatures>();
-	s.template registerType<CPackForServer, UpgradeCreature>();
-	s.template registerType<CPackForServer, GarrisonHeroSwap>();
-	s.template registerType<CPackForServer, ExchangeArtifacts>();
-	s.template registerType<CPackForServer, AssembleArtifacts>();
-	s.template registerType<CPackForServer, BuyArtifact>();
-	s.template registerType<CPackForServer, TradeOnMarketplace>();
-	s.template registerType<CPackForServer, SetFormation>();
-	s.template registerType<CPackForServer, HireHero>();
-	s.template registerType<CPackForServer, BuildBoat>();
-	s.template registerType<CPackForServer, QueryReply>();
-	s.template registerType<CPackForServer, MakeAction>();
-	s.template registerType<CPackForServer, DigWithHero>();
-	s.template registerType<CPackForServer, CastAdvSpell>();
-	s.template registerType<CPackForServer, CastleTeleportHero>();
-	s.template registerType<CPackForServer, SaveGame>();
-	s.template registerType<CPackForServer, PlayerMessage>();
-	s.template registerType<CPackForServer, BulkSplitStack>();
-	s.template registerType<CPackForServer, BulkMergeStacks>();
-	s.template registerType<CPackForServer, BulkSmartSplitStack>();
-	s.template registerType<CPackForServer, BulkMoveArmy>();
-	s.template registerType<CPackForServer, BulkExchangeArtifacts>();
-	s.template registerType<CPackForServer, ManageBackpackArtifacts>();
-	s.template registerType<CPackForServer, ManageEquippedArtifacts>();
-	s.template registerType<CPackForServer, EraseArtifactByClient>();
-	s.template registerType<CPackForServer, GamePause>();
-}
-
-VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/ResourceSet.cpp vcmi/lib/ResourceSet.cpp
--- vcmi-1.5.7/lib/ResourceSet.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/ResourceSet.cpp	2024-12-19 15:00:22.869146739 +0100
@@ -64,6 +64,12 @@
 		vstd::amax(elem, 0);
 }
 
+void ResourceSet::applyHandicap(int percentage)
+{
+	for(auto & elem : *this)
+		elem = vstd::divideAndCeil(elem * percentage, 100);
+}
+
 static bool canAfford(const ResourceSet &res, const ResourceSet &price)
 {
 	assert(res.size() == price.size() && price.size() == GameConstants::RESOURCE_QUANTITY);
diff --color -urN vcmi-1.5.7/lib/ResourceSet.h vcmi/lib/ResourceSet.h
--- vcmi-1.5.7/lib/ResourceSet.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/ResourceSet.h	2024-12-19 15:00:22.870146780 +0100
@@ -148,6 +148,26 @@
 		return ret;
 	}
 
+	//Returns how many items of "this" we can afford with provided funds
+	int maxPurchasableCount(const ResourceSet& availableFunds) {
+		int ret = 0; // Initialize to 0 because we want the maximum number of accumulations
+
+		for (size_t i = 0; i < container.size(); ++i) {
+			if (container.at(i) > 0) { // We only care about fulfilling positive needs
+				if (availableFunds[i] == 0) {
+					// If income is 0 and we need a positive amount, it's impossible to fulfill
+					return INT_MAX;
+				}
+				else {
+					// Calculate the number of times we need to accumulate income to fulfill the need
+					int ceiledResult = vstd::divideAndCeil(container.at(i), availableFunds[i]);
+					ret = std::max(ret, ceiledResult);
+				}
+			}
+		}
+		return ret;
+	}
+
 	ResourceSet & operator=(const TResource &rhs)
 	{
 		for(int & i : container)
@@ -169,17 +189,6 @@
 		return this->container == rhs.container;
 	}
 
-// WARNING: comparison operators are used for "can afford" relation: a <= b means that foreach i a[i] <= b[i]
-// that doesn't work the other way: a > b doesn't mean that a cannot be afforded with b, it's still b can afford a
-// 		bool operator<(const ResourceSet &rhs)
-// 		{
-// 			for(int i = 0; i < size(); i++)
-// 				if(at(i) >= rhs[i])
-// 					return false;
-//
-// 			return true;
-// 		}
-
 	template <typename Handler> void serialize(Handler &h)
 	{
 		h & container;
@@ -190,6 +199,7 @@
 	DLL_LINKAGE void amax(const TResourceCap &val); //performs vstd::amax on each element
 	DLL_LINKAGE void amin(const TResourceCap &val); //performs vstd::amin on each element
 	DLL_LINKAGE void positive(); //values below 0 are set to 0 - upgrade cost can't be negative, for example
+	DLL_LINKAGE void applyHandicap(int percentage);
 	DLL_LINKAGE bool nonZero() const; //returns true if at least one value is non-zero;
 	DLL_LINKAGE bool canAfford(const ResourceSet &price) const;
 	DLL_LINKAGE bool canBeAfforded(const ResourceSet &res) const;
diff --color -urN vcmi-1.5.7/lib/rewardable/Configuration.cpp vcmi/lib/rewardable/Configuration.cpp
--- vcmi-1.5.7/lib/rewardable/Configuration.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/rewardable/Configuration.cpp	2024-12-19 15:00:22.927149136 +0100
@@ -103,6 +103,7 @@
 	handler.serializeStruct("resetParameters", resetParameters);
 	handler.serializeBool("canRefuse", canRefuse);
 	handler.serializeBool("showScoutedPreview", showScoutedPreview);
+	handler.serializeBool("coastVisitable", coastVisitable);
 	handler.serializeInt("infoWindowType", infoWindowType);
 }
 
diff --color -urN vcmi-1.5.7/lib/rewardable/Configuration.h vcmi/lib/rewardable/Configuration.h
--- vcmi-1.5.7/lib/rewardable/Configuration.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/rewardable/Configuration.h	2024-12-19 15:00:22.927149136 +0100
@@ -11,9 +11,9 @@
 #pragma once
 
 #include "Limiter.h"
-#include "MetaString.h"
 #include "Reward.h"
 #include "../networkPacks/EInfoWindowMode.h"
+#include "../texts/MetaString.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
@@ -35,7 +35,7 @@
 {
 	SELECT_FIRST,  // first reward that matches limiters
 	SELECT_PLAYER, // player can select from all allowed rewards
-	SELECT_RANDOM, // one random reward from all mathing limiters
+	SELECT_RANDOM, // one random reward from all matching limiters
 	SELECT_ALL // grant all rewards that match limiters
 };
 
@@ -44,7 +44,8 @@
 	EVENT_INVALID = 0,
 	EVENT_FIRST_VISIT,
 	EVENT_ALREADY_VISITED,
-	EVENT_NOT_AVAILABLE
+	EVENT_NOT_AVAILABLE,
+	EVENT_GUARDED
 };
 
 constexpr std::array<std::string_view, 4> SelectModeString{"selectFirst", "selectPlayer", "selectRandom", "selectAll"};
@@ -143,7 +144,7 @@
 	/// how reward will be selected, uses ESelectMode enum
 	ui8 selectMode = Rewardable::SELECT_FIRST;
 
-	/// contols who can visit an object, uses EVisitMode enum
+	/// controls who can visit an object, uses EVisitMode enum
 	ui8 visitMode = Rewardable::VISIT_UNLIMITED;
 
 	/// how and when should the object be reset
@@ -155,12 +156,16 @@
 	/// Limiter that will be used to determine that object is visited. Only if visit mode is set to "limiter"
 	Rewardable::Limiter visitLimiter;
 
+	std::string guardsLayout;
+
 	/// if true - player can refuse visiting an object (e.g. Tomb)
 	bool canRefuse = false;
 
 	/// if true - right-clicking object will show preview of object rewards
 	bool showScoutedPreview = false;
 
+	bool coastVisitable = false;
+
 	/// if true - object info will shown in infobox (like resource pickup)
 	EInfoWindowMode infoWindowType = EInfoWindowMode::AUTO;
 	
@@ -189,6 +194,13 @@
 		h & canRefuse;
 		h & showScoutedPreview;
 		h & infoWindowType;
+		if (h.version >= Handler::Version::REWARDABLE_BANKS)
+		{
+			h & coastVisitable;
+			h & guardsLayout;
+		}
+		else
+			coastVisitable = false;
 	}
 };
 
diff --color -urN vcmi-1.5.7/lib/rewardable/Info.cpp vcmi/lib/rewardable/Info.cpp
--- vcmi-1.5.7/lib/rewardable/Info.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/rewardable/Info.cpp	2024-12-19 15:00:22.927149136 +0100
@@ -15,12 +15,13 @@
 #include "Limiter.h"
 #include "Reward.h"
 
-#include "../CGeneralTextHandler.h"
+#include "../texts/CGeneralTextHandler.h"
 #include "../IGameCallback.h"
 #include "../json/JsonRandom.h"
 #include "../mapObjects/IObjectInterface.h"
 #include "../modding/IdentifierStorage.h"
-#include "../CRandomGenerator.h"
+
+#include <vstd/RNG.h>
 
 VCMI_LIB_NAMESPACE_BEGIN
 
@@ -75,7 +76,7 @@
 
 	auto loadString = [&](const JsonNode & entry, const TextIdentifier & textID){
 		if (entry.isString() && !entry.String().empty() && entry.String()[0] != '@')
-			VLC->generaltexth->registerString(entry.getModScope(), textID, entry.String());
+			VLC->generaltexth->registerString(entry.getModScope(), textID, entry);
 	};
 
 	parameters = objectConfig;
@@ -104,9 +105,10 @@
 	loadString(parameters["visitedTooltip"], TextIdentifier(objectName, "visitedTooltip"));
 	loadString(parameters["onVisitedMessage"], TextIdentifier(objectName, "onVisited"));
 	loadString(parameters["onEmptyMessage"], TextIdentifier(objectName, "onEmpty"));
+	loadString(parameters["onGuardedMessage"], TextIdentifier(objectName, "onGuarded"));
 }
 
-Rewardable::LimitersList Rewardable::Info::configureSublimiters(Rewardable::Configuration & object, CRandomGenerator & rng, IGameCallback * cb, const JsonNode & source) const
+Rewardable::LimitersList Rewardable::Info::configureSublimiters(Rewardable::Configuration & object, vstd::RNG & rng, IGameCallback * cb, const JsonNode & source) const
 {
 	Rewardable::LimitersList result;
 	for (const auto & input : source.Vector())
@@ -121,7 +123,7 @@
 	return result;
 }
 
-void Rewardable::Info::configureLimiter(Rewardable::Configuration & object, CRandomGenerator & rng, IGameCallback * cb, Rewardable::Limiter & limiter, const JsonNode & source) const
+void Rewardable::Info::configureLimiter(Rewardable::Configuration & object, vstd::RNG & rng, IGameCallback * cb, Rewardable::Limiter & limiter, const JsonNode & source) const
 {
 	auto const & variables = object.variables.values;
 	JsonRandom randomizer(cb);
@@ -153,7 +155,7 @@
 	limiter.noneOf = configureSublimiters(object, rng, cb, source["noneOf"] );
 }
 
-void Rewardable::Info::configureReward(Rewardable::Configuration & object, CRandomGenerator & rng, IGameCallback * cb, Rewardable::Reward & reward, const JsonNode & source) const
+void Rewardable::Info::configureReward(Rewardable::Configuration & object, vstd::RNG & rng, IGameCallback * cb, Rewardable::Reward & reward, const JsonNode & source) const
 {
 	auto const & variables = object.variables.values;
 	JsonRandom randomizer(cb);
@@ -173,6 +175,8 @@
 	reward.removeObject = source["removeObject"].Bool();
 	reward.bonuses = randomizer.loadBonuses(source["bonuses"]);
 
+	reward.guards = randomizer.loadCreatures(source["guards"], rng, variables);
+
 	reward.primary = randomizer.loadPrimaries(source["primary"], rng, variables);
 	reward.secondary = randomizer.loadSecondaries(source["secondary"], rng, variables);
 
@@ -210,14 +214,14 @@
 	}
 }
 
-void Rewardable::Info::configureResetInfo(Rewardable::Configuration & object, CRandomGenerator & rng, Rewardable::ResetInfo & resetParameters, const JsonNode & source) const
+void Rewardable::Info::configureResetInfo(Rewardable::Configuration & object, vstd::RNG & rng, Rewardable::ResetInfo & resetParameters, const JsonNode & source) const
 {
 	resetParameters.period   = static_cast<ui32>(source["period"].Float());
 	resetParameters.visitors = source["visitors"].Bool();
 	resetParameters.rewards  = source["rewards"].Bool();
 }
 
-void Rewardable::Info::configureVariables(Rewardable::Configuration & object, CRandomGenerator & rng, IGameCallback * cb, const JsonNode & source) const
+void Rewardable::Info::configureVariables(Rewardable::Configuration & object, vstd::RNG & rng, IGameCallback * cb, const JsonNode & source) const
 {
 	JsonRandom randomizer(cb);
 
@@ -263,21 +267,69 @@
 
 void Rewardable::Info::replaceTextPlaceholders(MetaString & target, const Variables & variables, const VisitInfo & info) const
 {
-	for (const auto & artifact : info.reward.artifacts )
-		target.replaceName(artifact);
+	if (!info.reward.guards.empty())
+	{
+		replaceTextPlaceholders(target, variables);
+
+		CreatureID strongest = info.reward.guards.at(0).getId();
+
+		for (const auto & guard : info.reward.guards )
+		{
+			if (strongest.toEntity(VLC)->getFightValue() < guard.getId().toEntity(VLC)->getFightValue())
+				strongest = guard.getId();
+		}
+		target.replaceNamePlural(strongest); // FIXME: use singular if only 1 such unit is in guards
+
+		MetaString loot;
+
+		for (GameResID it : GameResID::ALL_RESOURCES())
+		{
+			if (info.reward.resources[it] != 0)
+			{
+				loot.appendRawString("%d %s");
+				loot.replaceNumber(info.reward.resources[it]);
+				loot.replaceName(it);
+			}
+		}
+
+		for (const auto & artifact : info.reward.artifacts )
+		{
+			loot.appendRawString("%s");
+			loot.replaceName(artifact);
+		}
+
+		for (const auto & spell : info.reward.spells )
+		{
+			loot.appendRawString("%s");
+			loot.replaceName(spell);
+		}
+
+		for (const auto & secondary : info.reward.secondary )
+		{
+			loot.appendRawString("%s");
+			loot.replaceName(secondary.first);
+		}
+
+		target.replaceRawString(loot.buildList());
+	}
+	else
+	{
+		for (const auto & artifact : info.reward.artifacts )
+			target.replaceName(artifact);
 
-	for (const auto & spell : info.reward.spells )
-		target.replaceName(spell);
+		for (const auto & spell : info.reward.spells )
+			target.replaceName(spell);
 
-	for (const auto & secondary : info.reward.secondary )
-		target.replaceName(secondary.first);
+		for (const auto & secondary : info.reward.secondary )
+			target.replaceName(secondary.first);
 
-	replaceTextPlaceholders(target, variables);
+		replaceTextPlaceholders(target, variables);
+	}
 }
 
 void Rewardable::Info::configureRewards(
 		Rewardable::Configuration & object,
-		CRandomGenerator & rng,
+		vstd::RNG & rng,
 		IGameCallback * cb,
 		const JsonNode & source,
 		Rewardable::EEventType event,
@@ -298,7 +350,7 @@
 			{
 				const JsonNode & preset = object.getPresetVariable("dice", diceID);
 				if (preset.isNull())
-					object.initVariable("dice", diceID, rng.getIntRange(0, 99)());
+					object.initVariable("dice", diceID, rng.nextInt(0, 99));
 				else
 					object.initVariable("dice", diceID, preset.Integer());
 
@@ -335,7 +387,7 @@
 	}
 }
 
-void Rewardable::Info::configureObject(Rewardable::Configuration & object, CRandomGenerator & rng, IGameCallback * cb) const
+void Rewardable::Info::configureObject(Rewardable::Configuration & object, vstd::RNG & rng, IGameCallback * cb) const
 {
 	object.info.clear();
 	object.variables.values.clear();
@@ -377,10 +429,22 @@
 		object.info.push_back(onEmpty);
 	}
 
+	if (!parameters["onGuardedMessage"].isNull())
+	{
+		Rewardable::VisitInfo onGuarded;
+		onGuarded.visitType = Rewardable::EEventType::EVENT_GUARDED;
+		onGuarded.message = loadMessage(parameters["onGuardedMessage"], TextIdentifier(objectTextID, "onGuarded"));
+		replaceTextPlaceholders(onGuarded.message, object.variables);
+
+		object.info.push_back(onGuarded);
+	}
+
 	configureResetInfo(object, rng, object.resetParameters, parameters["resetParameters"]);
 
 	object.canRefuse = parameters["canRefuse"].Bool();
 	object.showScoutedPreview = parameters["showScoutedPreview"].Bool();
+	object.guardsLayout = parameters["guardsLayout"].String();
+	object.coastVisitable = parameters["coastVisitable"].Bool();
 
 	if(parameters["showInInfobox"].isNull())
 		object.infoWindowType = EInfoWindowMode::AUTO;
@@ -462,6 +526,11 @@
 	return testForKey(parameters, "bonuses");
 }
 
+bool Rewardable::Info::hasGuards() const
+{
+	return testForKey(parameters, "guards");
+}
+
 const JsonNode & Rewardable::Info::getParameters() const
 {
 	return parameters;
diff --color -urN vcmi-1.5.7/lib/rewardable/Info.h vcmi/lib/rewardable/Info.h
--- vcmi-1.5.7/lib/rewardable/Info.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/rewardable/Info.h	2024-12-19 15:00:22.927149136 +0100
@@ -15,13 +15,16 @@
 
 VCMI_LIB_NAMESPACE_BEGIN
 
-class CRandomGenerator;
+namespace vstd
+{
+class RNG;
+}
+
 class MetaString;
 class IGameCallback;
 
 namespace Rewardable
 {
-
 struct Limiter;
 using LimitersList = std::vector<std::shared_ptr<Rewardable::Limiter>>;
 struct Reward;
@@ -39,14 +42,14 @@
 	void replaceTextPlaceholders(MetaString & target, const Variables & variables) const;
 	void replaceTextPlaceholders(MetaString & target, const Variables & variables, const VisitInfo & info) const;
 
-	void configureVariables(Rewardable::Configuration & object, CRandomGenerator & rng, IGameCallback * cb, const JsonNode & source) const;
-	void configureRewards(Rewardable::Configuration & object, CRandomGenerator & rng, IGameCallback * cb, const JsonNode & source, Rewardable::EEventType mode, const std::string & textPrefix) const;
+	void configureVariables(Rewardable::Configuration & object, vstd::RNG & rng, IGameCallback * cb, const JsonNode & source) const;
+	void configureRewards(Rewardable::Configuration & object, vstd::RNG & rng, IGameCallback * cb, const JsonNode & source, Rewardable::EEventType mode, const std::string & textPrefix) const;
 
-	void configureLimiter(Rewardable::Configuration & object, CRandomGenerator & rng, IGameCallback * cb, Rewardable::Limiter & limiter, const JsonNode & source) const;
-	Rewardable::LimitersList configureSublimiters(Rewardable::Configuration & object, CRandomGenerator & rng, IGameCallback * cb, const JsonNode & source) const;
+	void configureLimiter(Rewardable::Configuration & object, vstd::RNG & rng, IGameCallback * cb, Rewardable::Limiter & limiter, const JsonNode & source) const;
+	Rewardable::LimitersList configureSublimiters(Rewardable::Configuration & object, vstd::RNG & rng, IGameCallback * cb, const JsonNode & source) const;
 
-	void configureReward(Rewardable::Configuration & object, CRandomGenerator & rng, IGameCallback * cb, Rewardable::Reward & info, const JsonNode & source) const;
-	void configureResetInfo(Rewardable::Configuration & object, CRandomGenerator & rng, Rewardable::ResetInfo & info, const JsonNode & source) const;
+	void configureReward(Rewardable::Configuration & object, vstd::RNG & rng, IGameCallback * cb, Rewardable::Reward & info, const JsonNode & source) const;
+	void configureResetInfo(Rewardable::Configuration & object, vstd::RNG & rng, Rewardable::ResetInfo & info, const JsonNode & source) const;
 public:
 	const JsonNode & getParameters() const;
 
@@ -65,7 +68,9 @@
 
 	bool givesBonuses() const override;
 
-	void configureObject(Rewardable::Configuration & object, CRandomGenerator & rng, IGameCallback * cb) const;
+	bool hasGuards() const override;
+
+	void configureObject(Rewardable::Configuration & object, vstd::RNG & rng, IGameCallback * cb) const;
 
 	void init(const JsonNode & objectConfig, const std::string & objectTextID);
 
diff --color -urN vcmi-1.5.7/lib/rewardable/Interface.cpp vcmi/lib/rewardable/Interface.cpp
--- vcmi-1.5.7/lib/rewardable/Interface.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/rewardable/Interface.cpp	2024-12-19 15:00:22.927149136 +0100
@@ -11,10 +11,10 @@
 #include "StdInc.h"
 #include "Interface.h"
 
-#include "../CHeroHandler.h"
 #include "../TerrainHandler.h"
 #include "../CPlayerState.h"
 #include "../CSoundBase.h"
+#include "../entities/hero/CHeroHandler.h"
 #include "../gameState/CGameState.h"
 #include "../spells/CSpellHandler.h"
 #include "../spells/ISpellMechanics.h"
@@ -25,6 +25,8 @@
 #include "../networkPacks/PacksForClient.h"
 #include "../IGameCallback.h"
 
+#include <vstd/RNG.h>
+
 VCMI_LIB_NAMESPACE_BEGIN
 
 std::vector<ui32> Rewardable::Interface::getAvailableRewards(const CGHeroInstance * hero, Rewardable::EEventType event) const
@@ -44,8 +46,10 @@
 	return ret;
 }
 
-void Rewardable::Interface::grantRewardBeforeLevelup(IGameCallback * cb, const Rewardable::VisitInfo & info, const CGHeroInstance * hero) const
+void Rewardable::Interface::grantRewardBeforeLevelup(const Rewardable::VisitInfo & info, const CGHeroInstance * hero) const
 {
+	auto cb = getObject()->cb;
+
 	assert(hero);
 	assert(hero->tempOwner.isValidPlayer());
 	assert(info.reward.creatures.size() <= GameConstants::ARMY_SIZE);
@@ -59,16 +63,16 @@
 		const auto functor = [&props](const TerrainTile * tile)
 		{
 			int score = 0;
-			if (tile->terType->isSurface())
+			if (tile->getTerrain()->isSurface())
 				score += props.scoreSurface;
 
-			if (tile->terType->isUnderground())
+			if (tile->getTerrain()->isUnderground())
 				score += props.scoreSubterra;
 
-			if (tile->terType->isWater())
+			if (tile->getTerrain()->isWater())
 				score += props.scoreWater;
 
-			if (tile->terType->isRock())
+			if (tile->getTerrain()->isRock())
 				score += props.scoreRock;
 
 			return score > 0;
@@ -129,8 +133,10 @@
 		cb->giveExperience(hero, expToGive);
 }
 
-void Rewardable::Interface::grantRewardAfterLevelup(IGameCallback * cb, const Rewardable::VisitInfo & info, const CArmedInstance * army, const CGHeroInstance * hero) const
+void Rewardable::Interface::grantRewardAfterLevelup(const Rewardable::VisitInfo & info, const CArmedInstance * army, const CGHeroInstance * hero) const
 {
+	auto cb = getObject()->cb;
+
 	if(info.reward.manaDiff || info.reward.manaPercentage >= 0)
 		cb->setManaPoints(hero->id, info.reward.calculateManaPoints(hero));
 
@@ -157,7 +163,7 @@
 	}
 
 	for(const ArtifactID & art : info.reward.artifacts)
-		cb->giveHeroNewArtifact(hero, art.toArtifact(), ArtifactPosition::FIRST_AVAILABLE);
+		cb->giveHeroNewArtifact(hero, art, ArtifactPosition::FIRST_AVAILABLE);
 
 	if(!info.reward.spells.empty())
 	{
@@ -179,7 +185,7 @@
 
 			for(const auto & change : info.reward.creaturesChange)
 			{
-				if (heroStack->type->getId() == change.first)
+				if (heroStack->getId() == change.first)
 				{
 					StackLocation location(hero, slot.first);
 					cb->changeStackType(location, change.second.toCreature());
@@ -193,9 +199,9 @@
 	{
 		CCreatureSet creatures;
 		for(const auto & crea : info.reward.creatures)
-			creatures.addToSlot(creatures.getFreeSlot(), new CStackInstance(crea.type, crea.count));
+			creatures.addToSlot(creatures.getFreeSlot(), new CStackInstance(crea.getCreature(), crea.count));
 
-		if(auto * army = dynamic_cast<const CArmedInstance*>(this)) //TODO: to fix that, CArmedInstance must be splitted on map instance part and interface part
+		if(auto * army = dynamic_cast<const CArmedInstance*>(this)) //TODO: to fix that, CArmedInstance must be split on map instance part and interface part
 			cb->giveCreatures(army, hero, creatures, false);
 	}
 	
@@ -216,4 +222,165 @@
 	configuration.serializeJson(handler);
 }
 
+void Rewardable::Interface::grantRewardWithMessage(const CGHeroInstance * contextHero, int index, bool markAsVisit) const
+{
+	auto vi = configuration.info.at(index);
+	logGlobal->debug("Granting reward %d. Message says: %s", index, vi.message.toString());
+	// show message only if it is not empty or in infobox
+	if (configuration.infoWindowType != EInfoWindowMode::MODAL || !vi.message.toString().empty())
+	{
+		InfoWindow iw;
+		iw.player = contextHero->tempOwner;
+		iw.text = vi.message;
+		vi.reward.loadComponents(iw.components, contextHero);
+		iw.type = configuration.infoWindowType;
+		if(!iw.components.empty() || !iw.text.toString().empty())
+			getObject()->cb->showInfoDialog(&iw);
+	}
+	// grant reward afterwards. Note that it may remove object
+	if(markAsVisit)
+		markAsVisited(contextHero);
+	grantReward(index, contextHero);
+}
+
+void Rewardable::Interface::selectRewardWithMessage(const CGHeroInstance * contextHero, const std::vector<ui32> & rewardIndices, const MetaString & dialog) const
+{
+	BlockingDialog sd(configuration.canRefuse, rewardIndices.size() > 1);
+	sd.player = contextHero->tempOwner;
+	sd.text = dialog;
+	sd.components = loadComponents(contextHero, rewardIndices);
+	getObject()->cb->showBlockingDialog(getObject(), &sd);
+}
+
+std::vector<Component> Rewardable::Interface::loadComponents(const CGHeroInstance * contextHero, const std::vector<ui32> & rewardIndices) const
+{
+	std::vector<Component> result;
+
+	if (rewardIndices.empty())
+		return result;
+
+	if (configuration.selectMode != Rewardable::SELECT_FIRST && rewardIndices.size() > 1)
+	{
+		for (auto index : rewardIndices)
+			result.push_back(configuration.info.at(index).reward.getDisplayedComponent(contextHero));
+	}
+	else
+	{
+		configuration.info.at(rewardIndices.front()).reward.loadComponents(result, contextHero);
+	}
+
+	return result;
+}
+
+void Rewardable::Interface::grantAllRewardsWithMessage(const CGHeroInstance * contextHero, const std::vector<ui32> & rewardIndices, bool markAsVisit) const
+{
+	if (rewardIndices.empty())
+		return;
+
+	for (auto index : rewardIndices)
+	{
+		// TODO: Merge all rewards of same type, with single message?
+		grantRewardWithMessage(contextHero, index, false);
+	}
+	// Mark visited only after all rewards were processed
+	if(markAsVisit)
+		markAsVisited(contextHero);
+}
+
+void Rewardable::Interface::doHeroVisit(const CGHeroInstance *h) const
+{
+	if(!wasVisitedBefore(h))
+	{
+		auto rewards = getAvailableRewards(h, Rewardable::EEventType::EVENT_FIRST_VISIT);
+		bool objectRemovalPossible = false;
+		for(auto index : rewards)
+		{
+			if(configuration.info.at(index).reward.removeObject)
+				objectRemovalPossible = true;
+		}
+
+		logGlobal->debug("Visiting object with %d possible rewards", rewards.size());
+		switch (rewards.size())
+		{
+			case 0: // no available rewards, e.g. visiting School of War without gold
+			{
+				auto emptyRewards = getAvailableRewards(h, Rewardable::EEventType::EVENT_NOT_AVAILABLE);
+				if (!emptyRewards.empty())
+					grantRewardWithMessage(h, emptyRewards[0], false);
+				else
+					logMod->warn("No applicable message for visiting empty object!");
+				break;
+			}
+			case 1: // one reward. Just give it with message
+			{
+				if (configuration.canRefuse)
+					selectRewardWithMessage(h, rewards, configuration.info.at(rewards.front()).message);
+				else
+					grantRewardWithMessage(h, rewards.front(), true);
+				break;
+			}
+			default: // multiple rewards. Act according to select mode
+			{
+				switch (configuration.selectMode) {
+					case Rewardable::SELECT_PLAYER: // player must select
+						selectRewardWithMessage(h, rewards, configuration.onSelect);
+						break;
+					case Rewardable::SELECT_FIRST: // give first available
+						if (configuration.canRefuse)
+							selectRewardWithMessage(h, { rewards.front() }, configuration.info.at(rewards.front()).message);
+						else
+							grantRewardWithMessage(h, rewards.front(), true);
+						break;
+					case Rewardable::SELECT_RANDOM: // give random
+					{
+						ui32 rewardIndex = *RandomGeneratorUtil::nextItem(rewards, getObject()->cb->getRandomGenerator());
+						if (configuration.canRefuse)
+							selectRewardWithMessage(h, { rewardIndex }, configuration.info.at(rewardIndex).message);
+						else
+							grantRewardWithMessage(h, rewardIndex, true);
+						break;
+					}
+					case Rewardable::SELECT_ALL: // grant all possible
+						grantAllRewardsWithMessage(h, rewards, true);
+						break;
+				}
+				break;
+			}
+		}
+
+		if(!objectRemovalPossible && getAvailableRewards(h, Rewardable::EEventType::EVENT_FIRST_VISIT).empty())
+			markAsScouted(h);
+	}
+	else
+	{
+		logGlobal->debug("Revisiting already visited object");
+
+		if (!wasVisited(h->getOwner()))
+			markAsScouted(h);
+
+		auto visitedRewards = getAvailableRewards(h, Rewardable::EEventType::EVENT_ALREADY_VISITED);
+		if (!visitedRewards.empty())
+			grantRewardWithMessage(h, visitedRewards[0], false);
+		else
+			logMod->warn("No applicable message for visiting already visited object!");
+	}
+}
+
+void Rewardable::Interface::onBlockingDialogAnswered(const CGHeroInstance * hero, int32_t answer) const
+{
+	if (answer == 0)
+		return; //Player refused
+
+	if(answer > 0 && answer - 1 < configuration.info.size())
+	{
+		auto list = getAvailableRewards(hero, Rewardable::EEventType::EVENT_FIRST_VISIT);
+		markAsVisited(hero);
+		grantReward(list[answer - 1], hero);
+	}
+	else
+	{
+		throw std::runtime_error("Unhandled choice");
+	}
+}
+
 VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/rewardable/Interface.h vcmi/lib/rewardable/Interface.h
--- vcmi-1.5.7/lib/rewardable/Interface.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/rewardable/Interface.h	2024-12-19 15:00:22.927149136 +0100
@@ -15,7 +15,7 @@
 
 VCMI_LIB_NAMESPACE_BEGIN
 
-class IGameCallback;
+class IObjectInterface;
 
 namespace Rewardable
 {
@@ -29,16 +29,31 @@
 	
 protected:
 	
-	/// filters list of visit info and returns rewards that can be granted to current hero
-	std::vector<ui32> getAvailableRewards(const CGHeroInstance * hero, Rewardable::EEventType event) const;
-	
 	/// function that must be called if hero got level-up during grantReward call
-	virtual void grantRewardAfterLevelup(IGameCallback * cb, const Rewardable::VisitInfo & reward, const CArmedInstance * army, const CGHeroInstance * hero) const;
+	void grantRewardAfterLevelup(const Rewardable::VisitInfo & reward, const CArmedInstance * army, const CGHeroInstance * hero) const;
 
 	/// grants reward to hero
-	virtual void grantRewardBeforeLevelup(IGameCallback * cb, const Rewardable::VisitInfo & reward, const CGHeroInstance * hero) const;
+	void grantRewardBeforeLevelup(const Rewardable::VisitInfo & reward, const CGHeroInstance * hero) const;
 	
+	virtual void grantRewardWithMessage(const CGHeroInstance * contextHero, int rewardIndex, bool markAsVisit) const;
+	void selectRewardWithMessage(const CGHeroInstance * contextHero, const std::vector<ui32> & rewardIndices, const MetaString & dialog) const;
+	void grantAllRewardsWithMessage(const CGHeroInstance * contextHero, const std::vector<ui32>& rewardIndices, bool markAsVisit) const;
+	std::vector<Component> loadComponents(const CGHeroInstance * contextHero, const std::vector<ui32> & rewardIndices) const;
+
+	void doHeroVisit(const CGHeroInstance *h) const;
+
+	virtual const IObjectInterface * getObject() const = 0;
+	virtual bool wasVisitedBefore(const CGHeroInstance * hero) const = 0;
+	virtual bool wasVisited(PlayerColor player) const = 0;
+	virtual void markAsVisited(const CGHeroInstance * hero) const = 0;
+	virtual void markAsScouted(const CGHeroInstance * hero) const = 0;
+	virtual void grantReward(ui32 rewardID, const CGHeroInstance * hero) const = 0;
+
+	void onBlockingDialogAnswered(const CGHeroInstance * hero, int32_t answer) const;
 public:
+
+	/// filters list of visit info and returns rewards that can be granted to current hero
+	std::vector<ui32> getAvailableRewards(const CGHeroInstance * hero, Rewardable::EEventType event) const;
 	
 	Rewardable::Configuration configuration;
 	
diff --color -urN vcmi-1.5.7/lib/rewardable/Limiter.cpp vcmi/lib/rewardable/Limiter.cpp
--- vcmi-1.5.7/lib/rewardable/Limiter.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/rewardable/Limiter.cpp	2024-12-19 15:00:22.927149136 +0100
@@ -17,7 +17,6 @@
 #include "../networkPacks/Component.h"
 #include "../serializer/JsonSerializeFormat.h"
 #include "../constants/StringConstants.h"
-#include "../CHeroHandler.h"
 #include "../CSkillHandler.h"
 #include "../ArtifactUtils.h"
 
@@ -85,7 +84,7 @@
 		for(const auto & slot : hero->Slots())
 		{
 			const CStackInstance * heroStack = slot.second;
-			if (heroStack->type == reqStack.type)
+			if (heroStack->getType() == reqStack.getType())
 				count += heroStack->count;
 		}
 		if (count < reqStack.count) //not enough creatures of this kind
@@ -107,7 +106,7 @@
 	if (canLearnSkills && !hero->canLearnSkill())
 		return false;
 
-	if(manaPercentage > 100 * hero->mana / hero->manaLimit())
+	if (hero->manaLimit() != 0 && manaPercentage > 100 * hero->mana / hero->manaLimit())
 		return false;
 
 	for(size_t i=0; i<primary.size(); i++)
@@ -143,10 +142,28 @@
 		for(const auto & elem : artifactsRequirements)
 		{
 			// check required amount of artifacts
-			if(hero->getArtPosCount(elem.first, false, true, true) < elem.second)
+			size_t artCnt = 0;
+			for(const auto & [slot, slotInfo] : hero->artifactsWorn)
+				if(slotInfo.artifact->getTypeId() == elem.first)
+					artCnt++;
+
+			for(auto & slotInfo : hero->artifactsInBackpack)
+				if(slotInfo.artifact->getTypeId() == elem.first)
+				{
+					artCnt++;
+				}
+				else if(slotInfo.artifact->isCombined())
+				{
+					for(const auto & partInfo : slotInfo.artifact->getPartsInfo())
+						if(partInfo.art->getTypeId() == elem.first)
+							artCnt++;
+				}
+
+			if(artCnt < elem.second)
 				return false;
-			if(!hero->hasArt(elem.first))
-				reqSlots += hero->getAssemblyByConstituent(elem.first)->getPartsInfo().size() - 2;
+			// Check if art has no own slot. (As part of combined in backpack)
+			if(hero->getArtPos(elem.first, false) == ArtifactPosition::PRE_FIRST)
+				reqSlots += hero->getCombinedArtWithPart(elem.first)->getPartsInfo().size() - 2;
 		}
 		if(!ArtifactUtils::isBackpackFreeSlots(hero, reqSlots))
 			return false;
@@ -155,10 +172,10 @@
 	if(!players.empty() && !vstd::contains(players, hero->getOwner()))
 		return false;
 	
-	if(!heroes.empty() && !vstd::contains(heroes, hero->type->getId()))
+	if(!heroes.empty() && !vstd::contains(heroes, hero->getHeroTypeID()))
 		return false;
 	
-	if(!heroClasses.empty() && !vstd::contains(heroClasses, hero->type->heroClass->getId()))
+	if(!heroClasses.empty() && !vstd::contains(heroClasses, hero->getHeroClassID()))
 		return false;
 		
 	
@@ -216,7 +233,7 @@
 		comps.emplace_back(ComponentType::SPELL, entry);
 
 	for(const auto & entry : creatures)
-		comps.emplace_back(ComponentType::CREATURE, entry.type->getId(), entry.count);
+		comps.emplace_back(ComponentType::CREATURE, entry.getId(), entry.count);
 	
 	for(const auto & entry : players)
 		comps.emplace_back(ComponentType::FLAG, entry);
@@ -244,6 +261,7 @@
 	handler.serializeIdArray("colors", players);
 	handler.serializeInt("manaPoints", manaPoints);
 	handler.serializeIdArray("artifacts", artifacts);
+	handler.serializeIdArray("spells", spells);
 	handler.enterArray("creatures").serializeStruct(creatures);
 	handler.enterArray("primary").serializeArray(primary);
 	{
diff --color -urN vcmi-1.5.7/lib/rewardable/Limiter.h vcmi/lib/rewardable/Limiter.h
--- vcmi-1.5.7/lib/rewardable/Limiter.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/rewardable/Limiter.h	2024-12-19 15:00:22.928149177 +0100
@@ -12,6 +12,7 @@
 
 #include "../GameConstants.h"
 #include "../ResourceSet.h"
+#include "../serializer/Serializeable.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
@@ -26,7 +27,7 @@
 
 /// Limiters of rewards. Rewards will be granted to hero only if he satisfies requirements
 /// Note: for this is only a test - it won't remove anything from hero (e.g. artifacts or creatures)
-struct DLL_LINKAGE Limiter final
+struct DLL_LINKAGE Limiter final : public Serializeable
 {
 	/// day of week, unused if 0, 1-7 will test for current day of week
 	si32 dayOfWeek;
diff --color -urN vcmi-1.5.7/lib/rewardable/Reward.cpp vcmi/lib/rewardable/Reward.cpp
--- vcmi-1.5.7/lib/rewardable/Reward.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/rewardable/Reward.cpp	2024-12-19 15:00:22.928149177 +0100
@@ -121,7 +121,7 @@
 	}
 
 	for(const auto & entry : creatures)
-		comps.emplace_back(ComponentType::CREATURE, entry.type->getId(), entry.count);
+		comps.emplace_back(ComponentType::CREATURE, entry.getId(), entry.count);
 
 	for (size_t i=0; i<resources.size(); i++)
 	{
diff --color -urN vcmi-1.5.7/lib/rewardable/Reward.h vcmi/lib/rewardable/Reward.h
--- vcmi-1.5.7/lib/rewardable/Reward.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/rewardable/Reward.h	2024-12-19 15:00:22.928149177 +0100
@@ -82,6 +82,9 @@
 	/// fixed value, in form of percentage from max
 	si32 movePercentage;
 
+	/// Guards that must be defeated in order to access this reward, empty if not guarded
+	std::vector<CStackBasicDescriptor> guards;
+
 	/// list of bonuses, e.g. morale/luck
 	std::vector<Bonus> bonuses;
 
@@ -126,6 +129,8 @@
 		h & removeObject;
 		h & manaPercentage;
 		h & movePercentage;
+		if (h.version >= Handler::Version::REWARDABLE_GUARDS)
+			h & guards;
 		h & heroExperience;
 		h & heroLevel;
 		h & manaDiff;
diff --color -urN vcmi-1.5.7/lib/RiverHandler.cpp vcmi/lib/RiverHandler.cpp
--- vcmi-1.5.7/lib/RiverHandler.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/RiverHandler.cpp	2024-12-19 15:00:22.870146780 +0100
@@ -10,20 +10,21 @@
 
 #include "StdInc.h"
 #include "RiverHandler.h"
-#include "CGeneralTextHandler.h"
-#include "GameSettings.h"
+#include "texts/CGeneralTextHandler.h"
+#include "IGameSettings.h"
 #include "json/JsonNode.h"
+#include "VCMI_Lib.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
 RiverTypeHandler::RiverTypeHandler()
 {
-	objects.push_back(new RiverType());
+	objects.emplace_back(new RiverType());
 
 	VLC->generaltexth->registerString("core", objects[0]->getNameTextID(), "");
 }
 
-RiverType * RiverTypeHandler::loadFromJson(
+std::shared_ptr<RiverType> RiverTypeHandler::loadFromJson(
 	const std::string & scope,
 	const JsonNode & json,
 	const std::string & identifier,
@@ -31,7 +32,7 @@
 {
 	assert(identifier.find(':') == std::string::npos);
 
-	auto * info = new RiverType;
+	auto info = std::make_shared<RiverType>();
 
 	info->id              = RiverId(index);
 	info->identifier      = identifier;
@@ -49,7 +50,7 @@
 		info->paletteAnimation.push_back(element);
 	}
 
-	VLC->generaltexth->registerString(scope, info->getNameTextID(), json["text"].String());
+	VLC->generaltexth->registerString(scope, info->getNameTextID(), json["text"]);
 
 	return info;
 }
@@ -62,7 +63,7 @@
 
 std::vector<JsonNode> RiverTypeHandler::loadLegacyData()
 {
-	size_t dataSize = VLC->settings()->getInteger(EGameSettings::TEXTS_RIVER);
+	size_t dataSize = VLC->engineSettings()->getInteger(EGameSettings::TEXTS_RIVER);
 
 	objects.resize(dataSize);
 	return {};
@@ -73,6 +74,11 @@
 	return modScope + ":" + identifier;
 }
 
+std::string RiverType::getModScope() const
+{
+	return modScope;
+}
+
 std::string RiverType::getNameTextID() const
 {
 	return TextIdentifier( "river", modScope, identifier, "name" ).get();
diff --color -urN vcmi-1.5.7/lib/RiverHandler.h vcmi/lib/RiverHandler.h
--- vcmi-1.5.7/lib/RiverHandler.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/RiverHandler.h	2024-12-19 15:00:22.870146780 +0100
@@ -37,6 +37,7 @@
 	int32_t getIndex() const override { return id.getNum(); }
 	int32_t getIconIndex() const override { return 0; }
 	std::string getJsonKey() const override;
+	std::string getModScope() const override;
 	void registerIcons(const IconRegistar & cb) const override {}
 	RiverId getId() const override { return id;}
 	void updateFrom(const JsonNode & data) {};
@@ -61,7 +62,7 @@
 class DLL_LINKAGE RiverTypeHandler : public CHandlerBase<RiverId, RiverType, RiverType, RiverTypeService>
 {
 public:
-	virtual RiverType * loadFromJson(
+	std::shared_ptr<RiverType> loadFromJson(
 		const std::string & scope,
 		const JsonNode & json,
 		const std::string & identifier,
diff --color -urN vcmi-1.5.7/lib/rmg/CMapGenerator.cpp vcmi/lib/rmg/CMapGenerator.cpp
--- vcmi-1.5.7/lib/rmg/CMapGenerator.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/rmg/CMapGenerator.cpp	2024-12-19 15:00:22.928149177 +0100
@@ -13,13 +13,15 @@
 #include "../mapping/CMap.h"
 #include "../mapping/MapFormat.h"
 #include "../VCMI_Lib.h"
-#include "../CGeneralTextHandler.h"
+#include "../texts/CGeneralTextHandler.h"
+#include "../CRandomGenerator.h"
+#include "../entities/faction/CTownHandler.h"
+#include "../entities/faction/CFaction.h"
+#include "../entities/hero/CHero.h"
 #include "../mapObjectConstructors/AObjectTypeHandler.h"
 #include "../mapObjectConstructors/CObjectClassesHandler.h"
 #include "../mapping/CMapEditManager.h"
 #include "../CArtHandler.h"
-#include "../CTownHandler.h"
-#include "../CHeroHandler.h"
 #include "../constants/StringConstants.h"
 #include "../filesystem/Filesystem.h"
 #include "CZonePlacer.h"
@@ -32,15 +34,18 @@
 #include "modificators/TreasurePlacer.h"
 #include "modificators/RoadPlacer.h"
 
+#include <vstd/RNG.h>
+#include <vcmi/HeroTypeService.h>
+
 VCMI_LIB_NAMESPACE_BEGIN
 
 CMapGenerator::CMapGenerator(CMapGenOptions& mapGenOptions, IGameCallback * cb, int RandomSeed) :
 	mapGenOptions(mapGenOptions), randomSeed(RandomSeed),
-	monolithIndex(0)
+	monolithIndex(0),
+	rand(std::make_unique<CRandomGenerator>(RandomSeed))
 {
 	loadConfig();
-	rand.setSeed(this->randomSeed);
-	mapGenOptions.finalize(rand);
+	mapGenOptions.finalize(*rand);
 	map = std::make_unique<RmgMap>(mapGenOptions, cb);
 	placer = std::make_shared<CZonePlacer>(*map);
 }
@@ -100,8 +105,9 @@
 void CMapGenerator::initQuestArtsRemaining()
 {
 	//TODO: Move to QuestArtifactPlacer?
-	for (auto art : VLC->arth->objects)
+	for (auto artID : VLC->arth->getDefaultAllowed())
 	{
+		auto art = artID.toArtifact();
 		//Don't use parts of combined artifacts
 		if (art->aClass == CArtifact::ART_TREASURE && VLC->arth->legalArtifact(art->getId()) && art->getPartOf().empty())
 			questArtifacts.push_back(art->getId());
@@ -115,7 +121,7 @@
 	try
 	{
 		addHeaderInfo();
-		map->initTiles(*this, rand);
+		map->initTiles(*this, *rand);
 		Load::Progress::step();
 		initQuestArtsRemaining();
 		genZones();
@@ -136,44 +142,65 @@
 		throw;
 	}
 	Load::Progress::finish();
+
+	map->mapInstance->creationDateTime = std::time(nullptr);
+	map->mapInstance->author = MetaString::createFromTextID("core.genrltxt.740");
+	const auto * mapTemplate = mapGenOptions.getMapTemplate();
+	if(mapTemplate)
+		map->mapInstance->mapVersion = MetaString::createFromRawString(mapTemplate->getName());
+
 	return std::move(map->mapInstance);
 }
 
-std::string CMapGenerator::getMapDescription() const
+MetaString CMapGenerator::getMapDescription() const
 {
-	assert(map);
-
-	const std::string waterContentStr[3] = { "none", "normal", "islands" };
-	const std::string monsterStrengthStr[3] = { "weak", "normal", "strong" };
+	const TextIdentifier mainPattern("vcmi", "randomMap", "description");
+	const TextIdentifier isHuman("vcmi", "randomMap", "description", "isHuman");
+	const TextIdentifier townChoiceIs("vcmi", "randomMap", "description", "townChoice");
+	const std::array waterContent = {
+		TextIdentifier("vcmi", "randomMap", "description", "water", "none"),
+		TextIdentifier("vcmi", "randomMap", "description", "water", "normal"),
+		TextIdentifier("vcmi", "randomMap", "description", "water", "islands")
+	};
+	const std::array monsterStrength = {
+		TextIdentifier("vcmi", "randomMap", "description", "monster", "weak"),
+		TextIdentifier("vcmi", "randomMap", "description", "monster", "normal"),
+		TextIdentifier("vcmi", "randomMap", "description", "monster", "strong")
+	};
 
-	int monsterStrengthIndex = mapGenOptions.getMonsterStrength() - EMonsterStrength::GLOBAL_WEAK; //does not start from 0
 	const auto * mapTemplate = mapGenOptions.getMapTemplate();
+	int monsterStrengthIndex = mapGenOptions.getMonsterStrength() - EMonsterStrength::GLOBAL_WEAK; //does not start from 0
 
-	if(!mapTemplate)
-		throw rmgException("Map template for Random Map Generator is not found. Could not start the game.");
+	MetaString result = MetaString::createFromTextID(mainPattern.get());
 
-    std::stringstream ss;
-    ss << boost::str(boost::format(std::string("Map created by the Random Map Generator.\nTemplate was %s, size %dx%d") +
-        ", levels %d, players %d, computers %d, water %s, monster %s, VCMI map") % mapTemplate->getName() %
-		map->width() % map->height() % static_cast<int>(map->levels()) % static_cast<int>(mapGenOptions.getHumanOrCpuPlayerCount()) %
-		static_cast<int>(mapGenOptions.getCompOnlyPlayerCount()) % waterContentStr[mapGenOptions.getWaterContent()] %
-		monsterStrengthStr[monsterStrengthIndex]);
+	result.replaceRawString(mapTemplate->getName());
+	result.replaceNumber(map->width());
+	result.replaceNumber(map->height());
+	result.replaceNumber(map->levels());
+	result.replaceNumber(mapGenOptions.getHumanOrCpuPlayerCount());
+	result.replaceNumber(mapGenOptions.getCompOnlyPlayerCount());
+	result.replaceTextID(waterContent.at(mapGenOptions.getWaterContent()).get());
+	result.replaceTextID(monsterStrength.at(monsterStrengthIndex).get());
 
 	for(const auto & pair : mapGenOptions.getPlayersSettings())
 	{
 		const auto & pSettings = pair.second;
+
 		if(pSettings.getPlayerType() == EPlayerType::HUMAN)
 		{
-			ss << ", " << GameConstants::PLAYER_COLOR_NAMES[pSettings.getColor().getNum()] << " is human";
+			result.appendTextID(isHuman.get());
+			result.replaceName(pSettings.getColor());
 		}
+
 		if(pSettings.getStartingTown() != FactionID::RANDOM)
 		{
-			ss << ", " << GameConstants::PLAYER_COLOR_NAMES[pSettings.getColor().getNum()]
-			   << " town choice is " << (*VLC->townh)[pSettings.getStartingTown()]->getNameTranslated();
+			result.appendTextID(townChoiceIs.get());
+			result.replaceName(pSettings.getColor());
+			result.replaceName(pSettings.getStartingTown());
 		}
 	}
 
-	return ss.str();
+	return result;
 }
 
 void CMapGenerator::addPlayerInfo()
@@ -278,7 +305,7 @@
 					logGlobal->error("Not enough places in team for %s player", ((j == CPUONLY) ? "CPU" : "CPU or human"));
 					assert (teamNumbers[j].size());
 				}
-				auto itTeam = RandomGeneratorUtil::nextItem(teamNumbers[j], rand);
+				auto itTeam = RandomGeneratorUtil::nextItem(teamNumbers[j], *rand);
 				player.team = TeamID(*itTeam);
 				teamNumbers[j].erase(itTeam);
 			}
@@ -298,8 +325,8 @@
 
 void CMapGenerator::genZones()
 {
-	placer->placeZones(&rand);
-	placer->assignZones(&rand);
+	placer->placeZones(rand.get());
+	placer->assignZones(rand.get());
 
 	logGlobal->info("Zones generated successfully");
 }
@@ -420,9 +447,9 @@
 			if (it.second->getType() != ETemplateZoneType::WATER)
 				treasureZones.push_back(it.second);
 	}
-	auto grailZone = *RandomGeneratorUtil::nextItem(treasureZones, rand);
+	auto grailZone = *RandomGeneratorUtil::nextItem(treasureZones, *rand);
 
-	map->getMap(this).grailPos = *RandomGeneratorUtil::nextItem(grailZone->freePaths()->getTiles(), rand);
+	map->getMap(this).grailPos = *RandomGeneratorUtil::nextItem(grailZone->freePaths()->getTiles(), *rand);
 	map->getMap(this).reindexObjects();
 
 	logGlobal->info("Zones filled successfully");
@@ -438,11 +465,12 @@
 	m.height = mapGenOptions.getHeight();
 	m.twoLevel = mapGenOptions.getHasTwoLevels();
 	m.name.appendLocalString(EMetaText::GENERAL_TXT, 740);
-	m.description.appendRawString(getMapDescription());
+	m.description = getMapDescription();
 	m.difficulty = EMapDifficulty::NORMAL;
 	addPlayerInfo();
 	m.waterMap = (mapGenOptions.getWaterContent() != EWaterContent::EWaterContent::NONE);
 	m.banWaterContent();
+	m.overrideGameSettings(mapGenOptions.getMapTemplate()->getMapSettings());
 }
 
 int CMapGenerator::getNextMonlithIndex()
diff --color -urN vcmi-1.5.7/lib/rmg/CMapGenerator.h vcmi/lib/rmg/CMapGenerator.h
--- vcmi-1.5.7/lib/rmg/CMapGenerator.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/rmg/CMapGenerator.h	2024-12-19 15:00:22.928149177 +0100
@@ -10,15 +10,12 @@
 
 #pragma once
 
-#include "../GameConstants.h"
-#include "../CRandomGenerator.h"
 #include "CMapGenOptions.h"
-#include "../int3.h"
-#include "CRmgTemplate.h"
 #include "../LoadProgress.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
+class MetaString;
 class CRmgTemplate;
 class CMapGenOptions;
 class JsonNode;
@@ -67,7 +64,7 @@
 	std::unique_ptr<CMap> generate();
 
 	int getNextMonlithIndex();
-	int getPrisonsRemaning() const;
+	int getPrisonsRemaining() const;
 	std::shared_ptr<CZonePlacer> getZonePlacer() const;
 	const std::vector<ArtifactID> & getAllPossibleQuestArtifacts() const;
 	const std::vector<HeroTypeID> getAllPossibleHeroes() const;
@@ -79,7 +76,7 @@
 	int getRandomSeed() const;
 	
 private:
-	CRandomGenerator rand;
+	std::unique_ptr<vstd::RNG> rand;
 	int randomSeed;
 	CMapGenOptions& mapGenOptions;
 	Config config;
@@ -94,7 +91,7 @@
 	/// Generation methods
 	void loadConfig();
 	
-	std::string getMapDescription() const;
+	MetaString getMapDescription() const;
 
 	void initPrisonsRemaining();
 	void initQuestArtsRemaining();
diff --color -urN vcmi-1.5.7/lib/rmg/CMapGenOptions.cpp vcmi/lib/rmg/CMapGenOptions.cpp
--- vcmi-1.5.7/lib/rmg/CMapGenOptions.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/rmg/CMapGenOptions.cpp	2024-12-19 15:00:22.928149177 +0100
@@ -11,14 +11,16 @@
 #include "StdInc.h"
 #include "CMapGenOptions.h"
 
+#include "../entities/faction/CTownHandler.h"
+#include "../entities/faction/CFaction.h"
 #include "../mapping/CMapHeader.h"
 #include "CRmgTemplateStorage.h"
 #include "CRmgTemplate.h"
-#include "CRandomGenerator.h"
 #include "../VCMI_Lib.h"
-#include "../CTownHandler.h"
 #include "serializer/JsonSerializeFormat.h"
 
+#include <vstd/RNG.h>
+
 VCMI_LIB_NAMESPACE_BEGIN
 
 CMapGenOptions::CMapGenOptions()
@@ -28,9 +30,6 @@
 	customizedPlayers(false)
 {
 	initPlayersMap();
-	setRoadEnabled(RoadId(Road::DIRT_ROAD), true);
-	setRoadEnabled(RoadId(Road::GRAVEL_ROAD), true);
-	setRoadEnabled(RoadId(Road::COBBLESTONE_ROAD), true);
 }
 
 si32 CMapGenOptions::getWidth() const
@@ -487,7 +486,7 @@
 	customizedPlayers = true;
 }
 
-void CMapGenOptions::finalize(CRandomGenerator & rand)
+void CMapGenOptions::finalize(vstd::RNG & rand)
 {
 	logGlobal->info("RMG map: %dx%d, %s underground", getWidth(), getHeight(), getHasTwoLevels() ? "WITH" : "NO");
 	logGlobal->info("RMG settings: players %d, teams %d, computer players %d, computer teams %d, water %d, monsters %d",
@@ -690,8 +689,7 @@
 	}
 	else
 	{
-		CRandomGenerator gen;
-		return getPossibleTemplate(gen) != nullptr;
+		return !getPossibleTemplates().empty();
 	}
 }
 
@@ -750,7 +748,7 @@
 	return templates;
 }
 
-const CRmgTemplate * CMapGenOptions::getPossibleTemplate(CRandomGenerator & rand) const
+const CRmgTemplate * CMapGenOptions::getPossibleTemplate(vstd::RNG & rand) const
 {
 	auto templates = getPossibleTemplates();
 
diff --color -urN vcmi-1.5.7/lib/rmg/CMapGenOptions.h vcmi/lib/rmg/CMapGenOptions.h
--- vcmi-1.5.7/lib/rmg/CMapGenOptions.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/rmg/CMapGenOptions.h	2024-12-19 15:00:22.928149177 +0100
@@ -11,11 +11,15 @@
 #pragma once
 
 #include "../GameConstants.h"
+#include "../serializer/Serializeable.h"
 #include "CRmgTemplate.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
-class CRandomGenerator;
+namespace vstd
+{
+class RNG;
+}
 
 enum class EPlayerType
 {
@@ -26,7 +30,7 @@
 
 /// The map gen options class holds values about general map generation settings
 /// e.g. the size of the map, the count of players,...
-class DLL_LINKAGE CMapGenOptions
+class DLL_LINKAGE CMapGenOptions : public Serializeable
 {
 public:
 	/// The player settings class maps the player color, starting town and human player flag.
@@ -73,10 +77,7 @@
 			h & startingTown;
 			h & playerType;
 			h & team;
-			if (h.version >= Handler::Version::RELEASE_143)
-				h & startingHero;
-			else
-				startingHero = HeroTypeID::RANDOM;
+			h & startingHero;
 		}
 	};
 
@@ -147,7 +148,7 @@
 	/// Finalizes the options. All random sizes for various properties will be overwritten by numbers from
 	/// a random number generator by keeping the options in a valid state. Check options should return true, otherwise
 	/// this function fails.
-	void finalize(CRandomGenerator & rand);
+	void finalize(vstd::RNG & rand);
 
 	/// Returns false if there is no template available which fits to the currently selected options.
 	bool checkOptions() const;
@@ -165,7 +166,7 @@
 	PlayerColor getNextPlayerColor() const;
 	void updateCompOnlyPlayers();
 	void updatePlayers();
-	const CRmgTemplate * getPossibleTemplate(CRandomGenerator & rand) const;
+	const CRmgTemplate * getPossibleTemplate(vstd::RNG & rand) const;
 
 	si32 width;
 	si32 height;
diff --color -urN vcmi-1.5.7/lib/rmg/CRmgTemplate.cpp vcmi/lib/rmg/CRmgTemplate.cpp
--- vcmi-1.5.7/lib/rmg/CRmgTemplate.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/rmg/CRmgTemplate.cpp	2024-12-19 15:00:22.928149177 +0100
@@ -14,12 +14,12 @@
 #include "CRmgTemplate.h"
 #include "Functions.h"
 
-#include "../VCMI_Lib.h"
-#include "../CTownHandler.h"
 #include "../TerrainHandler.h"
-#include "../serializer/JsonSerializeFormat.h"
-#include "../modding/ModScope.h"
+#include "../VCMI_Lib.h"
 #include "../constants/StringConstants.h"
+#include "../entities/faction/CTownHandler.h"
+#include "../modding/ModScope.h"
+#include "../serializer/JsonSerializeFormat.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
@@ -102,6 +102,7 @@
 	handler.serializeInt("castles", castleCount, 0);
 	handler.serializeInt("townDensity", townDensity, 0);
 	handler.serializeInt("castleDensity", castleDensity, 0);
+	handler.serializeInt("sourceZone", sourceZone, NO_ZONE);
 }
 
 ZoneOptions::ZoneOptions():
@@ -156,7 +157,7 @@
 	return owner;
 }
 
-const std::set<TerrainId> ZoneOptions::getTerrainTypes() const
+std::set<TerrainId> ZoneOptions::getTerrainTypes() const
 {
 	if (terrainTypes.empty())
 	{
@@ -176,7 +177,7 @@
 std::set<TerrainId> ZoneOptions::getDefaultTerrainTypes() const
 {
 	std::set<TerrainId> terrains;
-	for (auto terrain : VLC->terrainTypeHandler->objects)
+	for(const auto & terrain : VLC->terrainTypeHandler->objects)
 	{
 		if (terrain->isLand() && terrain->isPassable())
 		{
@@ -191,7 +192,7 @@
 	return VLC->townh->getDefaultAllowed();
 }
 
-const std::set<FactionID> ZoneOptions::getTownTypes() const
+std::set<FactionID> ZoneOptions::getTownTypes() const
 {
 	if (townTypes.empty())
 	{
@@ -214,7 +215,7 @@
 	monsterTypes = value;
 }
 
-const std::set<FactionID> ZoneOptions::getMonsterTypes() const
+std::set<FactionID> ZoneOptions::getMonsterTypes() const
 {
 	return vstd::difference(monsterTypes, bannedMonsters);
 }
@@ -250,7 +251,7 @@
 	vstd::amax(maxTreasureValue, value.max);
 }
 
-const std::vector<CTreasureInfo> & ZoneOptions::getTreasureInfo() const
+std::vector<CTreasureInfo> ZoneOptions::getTreasureInfo() const
 {
 	return treasureInfo;
 }
@@ -272,7 +273,22 @@
 
 TRmgTemplateZoneId ZoneOptions::getTreasureLikeZone() const
 {
-    return treasureLikeZone;
+	return treasureLikeZone;
+}
+
+ObjectConfig ZoneOptions::getCustomObjects() const
+{
+	return objectConfig;
+}
+
+void ZoneOptions::setCustomObjects(const ObjectConfig & value)
+{
+	objectConfig = value;
+}
+
+TRmgTemplateZoneId ZoneOptions::getCustomObjectsLikeZone() const
+{
+	return customObjectsLikeZone;
 }
 
 void ZoneOptions::addConnection(const ZoneConnection & connection)
@@ -319,7 +335,8 @@
 		"cpuStart",
 		"treasure",
 		"junction",
-		"water"
+		"water",
+		"sealed"
 	};
 
 	handler.serializeEnum("type", type, zoneTypes);
@@ -334,6 +351,7 @@
 	SERIALIZE_ZONE_LINK(minesLikeZone);
 	SERIALIZE_ZONE_LINK(terrainTypeLikeZone);
 	SERIALIZE_ZONE_LINK(treasureLikeZone);
+	SERIALIZE_ZONE_LINK(customObjectsLikeZone);
 
 	#undef SERIALIZE_ZONE_LINK
 
@@ -398,9 +416,12 @@
 			handler.serializeInt(GameConstants::RESOURCE_NAMES[idx], mines[idx], 0);
 		}
 	}
+
+	handler.serializeStruct("customObjects", objectConfig);
 }
 
 ZoneConnection::ZoneConnection():
+	id(-1),
 	zoneA(-1),
 	zoneB(-1),
 	guardStrength(0),
@@ -410,6 +431,16 @@
 
 }
 
+int ZoneConnection::getId() const
+{
+	return id;
+}
+
+void ZoneConnection::setId(int id)
+{
+	this->id = id;
+}
+
 TRmgTemplateZoneId ZoneConnection::getZoneA() const
 {
 	return zoneA;
@@ -453,7 +484,7 @@
 	
 bool operator==(const ZoneConnection & l, const ZoneConnection & r)
 {
-	return l.zoneA == r.zoneA && l.zoneB == r.zoneB && l.guardStrength == r.guardStrength;
+	return l.id == r.id;
 }
 
 void ZoneConnection::serializeJson(JsonSerializeFormat & handler)
@@ -463,7 +494,8 @@
 		"guarded",
 		"fictive",
 		"repulsive",
-		"wide"
+		"wide",
+		"forcePortal"
 	};
 
 	static const std::vector<std::string> roadOptions =
@@ -500,9 +532,12 @@
 
 using namespace rmg;//todo: remove
 
+CRmgTemplate::~CRmgTemplate() = default;
+
 CRmgTemplate::CRmgTemplate()
 	: minSize(72, 72, 2),
-	maxSize(72, 72, 2)
+	maxSize(72, 72, 2),
+	mapSettings(std::make_unique<JsonNode>())
 {
 
 }
@@ -568,7 +603,7 @@
 
 const std::vector<ZoneConnection> & CRmgTemplate::getConnectedZoneIds() const
 {
-	return connectedZoneIds;
+	return connections;
 }
 
 void CRmgTemplate::validate() const
@@ -693,9 +728,18 @@
 	serializePlayers(handler, players, "players");
 	serializePlayers(handler, humanPlayers, "humans"); // TODO: Rename this parameter
 
+	*mapSettings = handler.getCurrent()["settings"];
+
 	{
 		auto connectionsData = handler.enterArray("connections");
-		connectionsData.serializeStruct(connectedZoneIds);
+		connectionsData.serializeStruct(connections);
+		if(!handler.saving)
+		{
+			for(size_t i = 0; i < connections.size(); ++i)
+			{
+				connections[i].setId(i);
+			}
+		}
 	}
 	
 	{
@@ -748,53 +792,34 @@
 	}
 }
 
-std::set<TerrainId> CRmgTemplate::inheritTerrainType(std::shared_ptr<ZoneOptions> zone, uint32_t iteration /* = 0 */)
-{
-	if (iteration >= 50)
-	{
-		logGlobal->error("Infinite recursion for terrain types detected in template %s", name);
-		return std::set<TerrainId>();
-	}
-	if (zone->getTerrainTypeLikeZone() != ZoneOptions::NO_ZONE)
-	{
-		iteration++;
-		const auto otherZone = zones.at(zone->getTerrainTypeLikeZone());
-		zone->setTerrainTypes(inheritTerrainType(otherZone, iteration));
-	}
-	//This implicitely excludes banned terrains
-	return zone->getTerrainTypes();
-}
-
-std::map<TResource, ui16> CRmgTemplate::inheritMineTypes(std::shared_ptr<ZoneOptions> zone, uint32_t iteration /* = 0 */)
+const JsonNode & CRmgTemplate::getMapSettings() const
 {
-	if (iteration >= 50)
-	{
-		logGlobal->error("Infinite recursion for mine types detected in template %s", name);
-		return std::map<TResource, ui16>();
-	}
-	if (zone->getMinesLikeZone() != ZoneOptions::NO_ZONE)
-	{
-		iteration++;
-		const auto otherZone = zones.at(zone->getMinesLikeZone());
-		zone->setMinesInfo(inheritMineTypes(otherZone, iteration));
-	}
-	return zone->getMinesInfo();
+	return *mapSettings;
 }
 
-std::vector<CTreasureInfo> CRmgTemplate::inheritTreasureInfo(std::shared_ptr<ZoneOptions> zone, uint32_t iteration /* = 0 */)
+template<typename T>
+T CRmgTemplate::inheritZoneProperty(std::shared_ptr<rmg::ZoneOptions> zone, 
+									T (rmg::ZoneOptions::*getter)() const,
+									void (rmg::ZoneOptions::*setter)(const T&),
+									TRmgTemplateZoneId (rmg::ZoneOptions::*inheritFrom)() const,
+									const std::string& propertyString,
+									uint32_t iteration)
 {
 	if (iteration >= 50)
 	{
-		logGlobal->error("Infinite recursion for treasures detected in template %s", name);
-		return std::vector<CTreasureInfo>();
+		logGlobal->error("Infinite recursion for %s detected in template %s", propertyString, name);
+		return T();
 	}
-	if (zone->getTreasureLikeZone() != ZoneOptions::NO_ZONE)
+	
+	if (((*zone).*inheritFrom)() != rmg::ZoneOptions::NO_ZONE)
 	{
 		iteration++;
-		const auto otherZone = zones.at(zone->getTreasureLikeZone());
-		zone->setTreasureInfo(inheritTreasureInfo(otherZone, iteration));
+		const auto otherZone = zones.at(((*zone).*inheritFrom)());
+		T inheritedValue = inheritZoneProperty(otherZone, getter, setter, inheritFrom, propertyString, iteration);
+		((*zone).*setter)(inheritedValue);
 	}
-	return zone->getTreasureInfo();
+	
+	return ((*zone).*getter)();
 }
 
 void CRmgTemplate::afterLoad()
@@ -803,12 +828,32 @@
 	{
 		auto zone = idAndZone.second;
 
-		//Inherit properties recursively.
-		inheritTerrainType(zone);
-		inheritMineTypes(zone);
-		inheritTreasureInfo(zone);
+		// Inherit properties recursively
+		inheritZoneProperty(zone, 
+							&rmg::ZoneOptions::getTerrainTypes, 
+							&rmg::ZoneOptions::setTerrainTypes, 
+							&rmg::ZoneOptions::getTerrainTypeLikeZone,
+							"terrain types");
+		
+		inheritZoneProperty(zone, 
+							&rmg::ZoneOptions::getMinesInfo, 
+							&rmg::ZoneOptions::setMinesInfo, 
+							&rmg::ZoneOptions::getMinesLikeZone,
+							"mine types");
+		
+		inheritZoneProperty(zone, 
+							&rmg::ZoneOptions::getTreasureInfo, 
+							&rmg::ZoneOptions::setTreasureInfo, 
+							&rmg::ZoneOptions::getTreasureLikeZone,
+							"treasure info");
+
+		inheritZoneProperty(zone, 
+							&rmg::ZoneOptions::getCustomObjects, 
+							&rmg::ZoneOptions::setCustomObjects, 
+							&rmg::ZoneOptions::getCustomObjectsLikeZone,
+							"custom objects");
 
-		//TODO: Inherit monster types as well
+				//TODO: Inherit monster types as well
 		auto monsterTypes = zone->getMonsterTypes();
 		if (monsterTypes.empty())
 		{
@@ -816,7 +861,7 @@
 		}
 	}
 
-	for(const auto & connection : connectedZoneIds)
+	for(const auto & connection : connections)
 	{
 		auto id1 = connection.getZoneA();
 		auto id2 = connection.getZoneB();
@@ -837,6 +882,7 @@
 	allowedWaterContent.erase(EWaterContent::RANDOM);
 }
 
+// TODO: Allow any integer size which does not match enum, as well
 void CRmgTemplate::serializeSize(JsonSerializeFormat & handler, int3 & value, const std::string & fieldName)
 {
 	static const std::map<std::string, int3> sizeMapping =
@@ -905,5 +951,19 @@
 		value.fromString(encodedValue);
 }
 
+const std::vector<CompoundMapObjectID> & ZoneOptions::getBannedObjects() const
+{
+	return objectConfig.getBannedObjects();
+}
+
+const std::vector<ObjectConfig::EObjectCategory> & ZoneOptions::getBannedObjectCategories() const
+{
+	return objectConfig.getBannedObjectCategories();
+}
+
+const std::vector<ObjectInfo> & ZoneOptions::getConfiguredObjects() const
+{
+	return objectConfig.getConfiguredObjects();
+}
 
 VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/rmg/CRmgTemplate.h vcmi/lib/rmg/CRmgTemplate.h
--- vcmi-1.5.7/lib/rmg/CRmgTemplate.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/rmg/CRmgTemplate.h	2024-12-19 15:00:22.928149177 +0100
@@ -13,10 +13,14 @@
 #include "../int3.h"
 #include "../GameConstants.h"
 #include "../ResourceSet.h"
+#include "ObjectInfo.h"
+#include "ObjectConfig.h"
+#include "../mapObjectConstructors/CObjectClassesHandler.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
 class JsonSerializeFormat;
+struct CompoundMapObjectID;
 
 enum class ETemplateZoneType
 {
@@ -24,7 +28,8 @@
 	CPU_START,
 	TREASURE,
 	JUNCTION,
-	WATER
+	WATER,
+	SEALED
 };
 
 namespace EWaterContent // Not enum class, because it's used in method RandomMapTab::setMapGenOptions
@@ -75,7 +80,8 @@
 	GUARDED = 0, //default
 	FICTIVE,
 	REPULSIVE,
-	WIDE
+	WIDE,
+	FORCE_PORTAL
 };
 
 enum class ERoadOption
@@ -91,6 +97,8 @@
 
 	ZoneConnection();
 
+	int getId() const;
+	void setId(int id);
 	TRmgTemplateZoneId getZoneA() const;
 	TRmgTemplateZoneId getZoneB() const;
 	TRmgTemplateZoneId getOtherZoneId(TRmgTemplateZoneId id) const;
@@ -102,6 +110,7 @@
 	
 	friend bool operator==(const ZoneConnection &, const ZoneConnection &);
 private:
+	int id;
 	TRmgTemplateZoneId zoneA;
 	TRmgTemplateZoneId zoneB;
 	int guardStrength;
@@ -131,6 +140,9 @@
 		int castleCount;
 		int townDensity;
 		int castleDensity;
+
+		// TODO: Copy from another zone once its randomized
+		TRmgTemplateZoneId sourceZone = NO_ZONE;
 	};
 
 	ZoneOptions();
@@ -145,15 +157,15 @@
 	void setSize(int value);
 	std::optional<int> getOwner() const;
 
-	const std::set<TerrainId> getTerrainTypes() const;
+	std::set<TerrainId> getTerrainTypes() const;
 	void setTerrainTypes(const std::set<TerrainId> & value);
 	std::set<TerrainId> getDefaultTerrainTypes() const;
 
 	const CTownInfo & getPlayerTowns() const;
 	const CTownInfo & getNeutralTowns() const;
 	std::set<FactionID> getDefaultTownTypes() const;
-	const std::set<FactionID> getTownTypes() const;
-	const std::set<FactionID> getMonsterTypes() const;
+	std::set<FactionID> getTownTypes() const;
+	std::set<FactionID> getMonsterTypes() const;
 
 	void setTownTypes(const std::set<FactionID> & value);
 	void setMonsterTypes(const std::set<FactionID> & value);
@@ -163,7 +175,7 @@
 
 	void setTreasureInfo(const std::vector<CTreasureInfo> & value);
 	void addTreasureInfo(const CTreasureInfo & value);
-	const std::vector<CTreasureInfo> & getTreasureInfo() const;
+	std::vector<CTreasureInfo> getTreasureInfo() const;
 	ui32 getMaxTreasureValue() const;
 	void recalculateMaxTreasureValue();
 
@@ -182,12 +194,24 @@
 	bool areTownsSameType() const;
 	bool isMatchTerrainToTown() const;
 
+	// Get a group of configured objects
+	const std::vector<CompoundMapObjectID> & getBannedObjects() const;
+	const std::vector<ObjectConfig::EObjectCategory> & getBannedObjectCategories() const;
+	const std::vector<ObjectInfo> & getConfiguredObjects() const;
+
+	// Copy whole custom object config from another zone
+	ObjectConfig getCustomObjects() const;
+	void setCustomObjects(const ObjectConfig & value);
+	TRmgTemplateZoneId	getCustomObjectsLikeZone() const;
+
 protected:
 	TRmgTemplateZoneId id;
 	ETemplateZoneType type;
 	int size;
 	ui32 maxTreasureValue;
 	std::optional<int> owner;
+
+	ObjectConfig objectConfig;
 	CTownInfo playerTowns;
 	CTownInfo neutralTowns;
 	bool matchTerrainToTown;
@@ -210,12 +234,13 @@
 	TRmgTemplateZoneId minesLikeZone;
 	TRmgTemplateZoneId terrainTypeLikeZone;
 	TRmgTemplateZoneId treasureLikeZone;
+	TRmgTemplateZoneId customObjectsLikeZone;
 };
 
 }
 
 /// The CRmgTemplate describes a random map template.
-class DLL_LINKAGE CRmgTemplate
+class DLL_LINKAGE CRmgTemplate : boost::noncopyable
 {
 public:
 	using Zones = std::map<TRmgTemplateZoneId, std::shared_ptr<rmg::ZoneOptions>>;
@@ -239,6 +264,7 @@
 	};
 
 	CRmgTemplate();
+	~CRmgTemplate();
 
 	bool matchesSize(const int3 & value) const;
 	bool isWaterContentAllowed(EWaterContent::EWaterContent waterContent) const;
@@ -254,6 +280,7 @@
 	const CPlayerCountRange & getHumanPlayers() const;
 	std::pair<int3, int3> getMapSizes() const;
 	const Zones & getZones() const;
+	const JsonNode & getMapSettings() const;
 	const std::vector<rmg::ZoneConnection> & getConnectedZoneIds() const;
 
 	void validate() const; /// Tests template on validity and throws exception on failure
@@ -270,14 +297,28 @@
 	CPlayerCountRange players;
 	CPlayerCountRange humanPlayers;
 	Zones zones;
-	std::vector<rmg::ZoneConnection> connectedZoneIds;
+	std::vector<rmg::ZoneConnection> connections;
 	std::set<EWaterContent::EWaterContent> allowedWaterContent;
+	std::unique_ptr<JsonNode> mapSettings;
 
 	std::set<TerrainId> inheritTerrainType(std::shared_ptr<rmg::ZoneOptions> zone, uint32_t iteration = 0);
 	std::map<TResource, ui16> inheritMineTypes(std::shared_ptr<rmg::ZoneOptions> zone, uint32_t iteration = 0);
 	std::vector<CTreasureInfo> inheritTreasureInfo(std::shared_ptr<rmg::ZoneOptions> zone, uint32_t iteration = 0);
+
+	// TODO: Copy custom object settings
+	// TODO: Copy town type after source town is actually randomized
+
 	void serializeSize(JsonSerializeFormat & handler, int3 & value, const std::string & fieldName);
 	void serializePlayers(JsonSerializeFormat & handler, CPlayerCountRange & value, const std::string & fieldName);
+
+	template<typename T>
+	T inheritZoneProperty(std::shared_ptr<rmg::ZoneOptions> zone, 
+						  T (rmg::ZoneOptions::*getter)() const,
+						  void (rmg::ZoneOptions::*setter)(const T&),
+						  TRmgTemplateZoneId (rmg::ZoneOptions::*inheritFrom)() const,
+						  const std::string& propertyString,
+						  uint32_t iteration = 0);
+
 };
 
-VCMI_LIB_NAMESPACE_END
+VCMI_LIB_NAMESPACE_END
\ No newline at end of file
diff --color -urN vcmi-1.5.7/lib/rmg/CZonePlacer.cpp vcmi/lib/rmg/CZonePlacer.cpp
--- vcmi-1.5.7/lib/rmg/CZonePlacer.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/rmg/CZonePlacer.cpp	2024-12-19 15:00:22.929149219 +0100
@@ -11,23 +11,24 @@
 #include "StdInc.h"
 #include "CZonePlacer.h"
 
-#include "../CRandomGenerator.h"
-#include "../CTownHandler.h"
 #include "../TerrainHandler.h"
+#include "../entities/faction/CFaction.h"
+#include "../entities/faction/CTownHandler.h"
 #include "../mapping/CMap.h"
 #include "../mapping/CMapEditManager.h"
+#include "../VCMI_Lib.h"
 #include "CMapGenOptions.h"
 #include "RmgMap.h"
 #include "Zone.h"
 #include "Functions.h"
 #include "PenroseTiling.h"
 
+#include <vstd/RNG.h>
+
 VCMI_LIB_NAMESPACE_BEGIN
 
 //#define ZONE_PLACEMENT_LOG true
 
-class CRandomGenerator;
-
 CZonePlacer::CZonePlacer(RmgMap & map)
 	: width(0), height(0), mapSize(0),
 	gravityConstant(1e-3f),
@@ -79,12 +80,21 @@
 
 			for (auto & connection : connectedZoneIds)
 			{
-				if (connection.getConnectionType() == rmg::EConnectionType::REPULSIVE)
+				switch (connection.getConnectionType())
 				{
 					//Do not consider virtual connections for graph distance
-					continue;
+					case rmg::EConnectionType::REPULSIVE:
+					case rmg::EConnectionType::FORCE_PORTAL:
+						continue;
 				}
 				auto neighbor = connection.getOtherZoneId(current);
+
+				if (current == neighbor)
+				{
+					//Do not consider self-connections
+					continue;
+				}
+
 				if (!visited[neighbor])
 				{
 					visited[neighbor] = true;
@@ -96,7 +106,7 @@
 	}
 }
 
-void CZonePlacer::placeOnGrid(CRandomGenerator* rand)
+void CZonePlacer::placeOnGrid(vstd::RNG* rand)
 {
 	auto zones = map.getZones();
 	assert(zones.size());
@@ -117,7 +127,7 @@
 
 	auto getRandomEdge = [rand, gridSize](size_t& x, size_t& y)
 	{
-		switch (rand->nextInt() % 4)
+		switch (rand->nextInt(0, 3) % 4)
 		{
 		case 0:
 			x = 0;
@@ -149,7 +159,7 @@
 			else
 			{
 				//Random corner
-				if (rand->nextInt() % 2)
+				if (rand->nextInt(0, 1) == 1)
 				{
 					x = 0;
 				}
@@ -157,7 +167,7 @@
 				{
 					x = gridSize - 1;
 				}
-				if (rand->nextInt() % 2)
+				if (rand->nextInt(0, 1) == 1)
 				{
 					y = 0;
 				}
@@ -175,8 +185,8 @@
 			else
 			{
 				//One of 4 squares in the middle
-				x = (gridSize / 2) - 1 + rand->nextInt() % 2;
-				y = (gridSize / 2) - 1 + rand->nextInt() % 2;
+				x = (gridSize / 2) - 1 + rand->nextInt(0, 1);
+				y = (gridSize / 2) - 1 + rand->nextInt(0, 1);
 			}
 			break;
 		case ETemplateZoneType::JUNCTION:
@@ -307,7 +317,7 @@
 	}
 }
 
-void CZonePlacer::placeZones(CRandomGenerator * rand)
+void CZonePlacer::placeZones(vstd::RNG * rand)
 {
 	logGlobal->info("Starting zone placement");
 
@@ -431,7 +441,7 @@
 	}
 }
 
-void CZonePlacer::prepareZones(TZoneMap &zones, TZoneVector &zonesVector, const bool underground, CRandomGenerator * rand)
+void CZonePlacer::prepareZones(TZoneMap &zones, TZoneVector &zonesVector, const bool underground, vstd::RNG * rand)
 {
 	std::vector<float> totalSize = { 0, 0 }; //make sure that sum of zone sizes on surface and uderground match size of the map
 
@@ -551,8 +561,16 @@
 
 		for (const auto & connection : zone.second->getConnections())
 		{
-			if (connection.getConnectionType() == rmg::EConnectionType::REPULSIVE)
+			switch (connection.getConnectionType())
+			{
+				//Do not consider virtual connections for graph distance
+				case rmg::EConnectionType::REPULSIVE:
+				case rmg::EConnectionType::FORCE_PORTAL:
+					continue;
+			}
+			if (connection.getZoneA() == connection.getZoneB())
 			{
+				//Do not consider self-connections
 				continue;
 			}
 
@@ -693,7 +711,7 @@
 
 	boost::sort(misplacedZones, [](const Misplacement& lhs, Misplacement& rhs)
 	{
-		return lhs.first > rhs.first; //Largest dispalcement first
+		return lhs.first > rhs.first; //Largest displacement first
 	});
 
 #ifdef ZONE_PLACEMENT_LOG
@@ -709,11 +727,19 @@
 		std::set<TRmgTemplateZoneId> connectedZones;
 		for (const auto& connection : firstZone->getConnections())
 		{
-			//FIXME: Should we also exclude fictive connections?
-			if (connection.getConnectionType() != rmg::EConnectionType::REPULSIVE)
+			switch (connection.getConnectionType())
 			{
-				connectedZones.insert(connection.getOtherZoneId(firstZone->getId()));
+				//Do not consider virtual connections for graph distance
+				case rmg::EConnectionType::REPULSIVE:
+				case rmg::EConnectionType::FORCE_PORTAL:
+					continue;
+			}
+			if (connection.getZoneA() == connection.getZoneB())
+			{
+				//Do not consider self-connections
+				continue;
 			}
+			connectedZones.insert(connection.getOtherZoneId(firstZone->getId()));
 		}
 
 		auto level = firstZone->getCenter().z;
@@ -823,7 +849,7 @@
 
 }
 
-void CZonePlacer::assignZones(CRandomGenerator * rand)
+void CZonePlacer::assignZones(vstd::RNG * rand)
 {
 	logGlobal->info("Starting zone colouring");
 
@@ -973,7 +999,7 @@
 	{
 		moveZoneToCenterOfMass(zone.second);
 
-		//TODO: similiar for islands
+		//TODO: similar for islands
 		#define	CREATE_FULL_UNDERGROUND true //consider linking this with water amount
 		if (zone.second->isUnderground())
 		{
diff --color -urN vcmi-1.5.7/lib/rmg/CZonePlacer.h vcmi/lib/rmg/CZonePlacer.h
--- vcmi-1.5.7/lib/rmg/CZonePlacer.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/rmg/CZonePlacer.h	2024-12-19 15:00:22.929149219 +0100
@@ -16,9 +16,13 @@
 
 VCMI_LIB_NAMESPACE_BEGIN
 
+namespace vstd
+{
+class RNG;
+}
+
 class CZoneGraph;
 class CMap;
-class CRandomGenerator;
 class RmgMap;
 class Zone;
 
@@ -34,19 +38,19 @@
 	explicit CZonePlacer(RmgMap & map);
 	int3 cords(const float3 & f) const;
 	float metric (const int3 &a, const int3 &b) const;
-	float getDistance(float distance) const; //additional scaling without 0 divison
+	float getDistance(float distance) const; //additional scaling without 0 division
 	~CZonePlacer() = default;
 
-	void placeZones(CRandomGenerator * rand);
+	void placeZones(vstd::RNG * rand);
 	void findPathsBetweenZones();
-	void placeOnGrid(CRandomGenerator* rand);
+	void placeOnGrid(vstd::RNG* rand);
 	float scaleForceBetweenZones(const std::shared_ptr<Zone> zoneA, const std::shared_ptr<Zone> zoneB) const;
-	void assignZones(CRandomGenerator * rand);
+	void assignZones(vstd::RNG * rand);
 
 	const TDistanceMap & getDistanceMap();
 	
 private:
-	void prepareZones(TZoneMap &zones, TZoneVector &zonesVector, const bool underground, CRandomGenerator * rand);
+	void prepareZones(TZoneMap &zones, TZoneVector &zonesVector, const bool underground, vstd::RNG * rand);
 	void attractConnectedZones(TZoneMap & zones, TForceVector & forces, TDistanceVector & distances) const;
 	void separateOverlappingZones(TZoneMap &zones, TForceVector &forces, TDistanceVector &overlaps);
 	void moveOneZone(TZoneMap & zones, TForceVector & totalForces, TDistanceVector & distances, TDistanceVector & overlaps);
@@ -54,7 +58,7 @@
 private:
 	int width;
 	int height;
-	//metric coeficient
+	//metric coefficient
 	float mapSize;
 
 	float gravityConstant;
diff --color -urN vcmi-1.5.7/lib/rmg/float3.h vcmi/lib/rmg/float3.h
--- vcmi-1.5.7/lib/rmg/float3.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/rmg/float3.h	2024-12-19 15:00:22.931149301 +0100
@@ -27,16 +27,16 @@
 
 	// returns float3 with coordinates increased by corresponding coordinate of given float3
 	float3 operator+(const float3 & i) const { return float3(x + i.x, y + i.y, z + i.z); }
-	// returns float3 with coordinates increased by given numer
+	// returns float3 with coordinates increased by given number
 	float3 operator+(const float i) const { return float3(x + i, y + i, z + (si32)i); }
 	// returns float3 with coordinates decreased by corresponding coordinate of given float3
 	float3 operator-(const float3 & i) const { return float3(x - i.x, y - i.y, z - i.z); }
-	// returns float3 with coordinates decreased by given numer
+	// returns float3 with coordinates decreased by given number
 	float3 operator-(const float i) const { return float3(x - i, y - i, z - (si32)i); }
 
-	// returns float3 with plane coordinates decreased by given numer
+	// returns float3 with plane coordinates decreased by given number
 	float3 operator*(const float i) const {return float3(x * i, y * i, z);}
-	// returns float3 with plane coordinates decreased by given numer
+	// returns float3 with plane coordinates decreased by given number
 	float3 operator/(const float i) const {return float3(x / i, y / i, z);}
 
 	// returns opposite position
diff --color -urN vcmi-1.5.7/lib/rmg/Functions.cpp vcmi/lib/rmg/Functions.cpp
--- vcmi-1.5.7/lib/rmg/Functions.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/rmg/Functions.cpp	2024-12-19 15:00:22.929149219 +0100
@@ -15,14 +15,32 @@
 #include "TileInfo.h"
 #include "RmgPath.h"
 #include "../TerrainHandler.h"
-#include "../CTownHandler.h"
 #include "../mapping/CMap.h"
 #include "../mapObjectConstructors/AObjectTypeHandler.h"
 #include "../mapObjectConstructors/CObjectClassesHandler.h"
 #include "../VCMI_Lib.h"
 
+#include <vstd/RNG.h>
+
 VCMI_LIB_NAMESPACE_BEGIN
 
+void replaceWithCurvedPath(rmg::Path & path, const Zone & zone, const int3 & src, bool onlyStraight)
+{
+	auto costFunction = rmg::Path::createCurvedCostFunction(zone.area()->getBorder());
+	auto pathArea = zone.areaForRoads();
+	rmg::Path curvedPath(pathArea);
+	curvedPath.connect(zone.freePaths().get());
+	curvedPath = curvedPath.search(src, onlyStraight, costFunction);
+	if (curvedPath.valid())
+	{
+		path = curvedPath;
+	}
+	else
+	{
+		logGlobal->warn("Failed to create curved path to %s", src.toString());
+	}
+}
+
 rmg::Tileset collectDistantTiles(const Zone& zone, int distance)
 {
 	uint32_t distanceSq = distance * distance;
@@ -34,7 +52,7 @@
 	return subarea.getTiles();
 }
 
-int chooseRandomAppearance(CRandomGenerator & generator, si32 ObjID, TerrainId terrain)
+int chooseRandomAppearance(vstd::RNG & generator, si32 ObjID, TerrainId terrain)
 {
 	auto factories = VLC->objtypeh->knownSubObjects(ObjID);
 	vstd::erase_if(factories, [ObjID, &terrain](si32 f)
diff --color -urN vcmi-1.5.7/lib/rmg/Functions.h vcmi/lib/rmg/Functions.h
--- vcmi-1.5.7/lib/rmg/Functions.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/rmg/Functions.h	2024-12-19 15:00:22.929149219 +0100
@@ -19,7 +19,6 @@
 class ObjectManager;
 class ObjectTemplate;
 class CMapGenerator;
-class CRandomGenerator;
 
 class rmgException : public std::exception
 {
@@ -35,9 +34,11 @@
 	}
 };
 
+void replaceWithCurvedPath(rmg::Path & path, const Zone & zone, const int3 & src, bool onlyStraight = true);
+
 rmg::Tileset collectDistantTiles(const Zone & zone, int distance);
 
-int chooseRandomAppearance(CRandomGenerator & generator, si32 ObjID, TerrainId terrain);
+int chooseRandomAppearance(vstd::RNG & generator, si32 ObjID, TerrainId terrain);
 
 
 VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/rmg/modificators/ConnectionsPlacer.cpp vcmi/lib/rmg/modificators/ConnectionsPlacer.cpp
--- vcmi-1.5.7/lib/rmg/modificators/ConnectionsPlacer.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/rmg/modificators/ConnectionsPlacer.cpp	2024-12-19 15:00:22.931149301 +0100
@@ -26,6 +26,8 @@
 #include "WaterProxy.h"
 #include "TownPlacer.h"
 
+#include <vstd/RNG.h>
+
 VCMI_LIB_NAMESPACE_BEGIN
 
 std::pair<Zone::Lock, Zone::Lock> ConnectionsPlacer::lockZones(std::shared_ptr<Zone> otherZone)
@@ -53,6 +55,17 @@
 	{
 		for (auto& c : dConnections)
 		{
+			if (c.getZoneA() == c.getZoneB())
+			{
+				// Zone can always be connected to itself, but only by monolith pair
+				RecursiveLock lock(externalAccessMutex);
+				if (!vstd::contains(dCompleted, c))
+				{
+					placeMonolithConnection(c);
+					continue;
+				}
+			}
+
 			auto otherZone = map.getZones().at(c.getZoneB());
 			auto* cp = otherZone->getModificator<ConnectionsPlacer>();
 
@@ -74,6 +87,11 @@
 
 	diningPhilosophers([this](const rmg::ZoneConnection& c)
 	{
+		forcePortalConnection(c);
+	});
+
+	diningPhilosophers([this](const rmg::ZoneConnection& c)
+	{
 		selfSideDirectConnection(c);
 	});
 
@@ -113,10 +131,19 @@
 	dCompleted.push_back(connection);
 }
 
+void ConnectionsPlacer::forcePortalConnection(const rmg::ZoneConnection & connection)
+{
+	// This should always succeed
+	if (connection.getConnectionType() == rmg::EConnectionType::FORCE_PORTAL)
+	{
+		placeMonolithConnection(connection);
+	}
+}
+
 void ConnectionsPlacer::selfSideDirectConnection(const rmg::ZoneConnection & connection)
 {
 	bool success = false;
-	auto otherZoneId = (connection.getZoneA() == zone.getId() ? connection.getZoneB() : connection.getZoneA());
+	auto otherZoneId = connection.getOtherZoneId(zone.getId());
 	auto & otherZone = map.getZones().at(otherZoneId);
 	bool createRoad = shouldGenerateRoad(connection);
 	
@@ -158,8 +185,8 @@
 							return 1.f / (1.f + border.distanceSqr(d));
 						};
 
-						auto ourArea = zone.areaPossible() + zone.freePaths();
-						auto theirArea = otherZone->areaPossible() + otherZone->freePaths();
+						auto ourArea = zone.areaForRoads();
+						auto theirArea = otherZone->areaForRoads();
 						theirArea.add(potentialPos);
 						rmg::Path ourPath(ourArea);
 						rmg::Path theirPath(theirArea);
@@ -251,24 +278,22 @@
 			assert(zone.getModificator<ObjectManager>());
 			auto & manager = *zone.getModificator<ObjectManager>();
 			auto * monsterType = manager.chooseGuard(connection.getGuardStrength(), true);
-			
+		
 			rmg::Area border(zone.area()->getBorder());
 			border.unite(otherZone->area()->getBorder());
-			
-			auto costFunction = [&border](const int3 & s, const int3 & d)
-			{
-				return 1.f / (1.f + border.distanceSqr(d));
-			};
-			
-			auto ourArea = zone.areaPossible() + zone.freePaths();
-			auto theirArea = otherZone->areaPossible() + otherZone->freePaths();
+
+			auto localCostFunction = rmg::Path::createCurvedCostFunction(zone.area()->getBorder());
+			auto otherCostFunction = rmg::Path::createCurvedCostFunction(otherZone->area()->getBorder());
+
+			auto ourArea = zone.areaForRoads();
+			auto theirArea = otherZone->areaForRoads();
 			theirArea.add(guardPos);
 			rmg::Path ourPath(ourArea);
 			rmg::Path theirPath(theirArea);
 			ourPath.connect(zone.freePaths().get());
-			ourPath = ourPath.search(guardPos, true, costFunction);
+			ourPath = ourPath.search(guardPos, true, localCostFunction);
 			theirPath.connect(otherZone->freePaths().get());
-			theirPath = theirPath.search(guardPos, true, costFunction);
+			theirPath = theirPath.search(guardPos, true, otherCostFunction);
 			
 			if(ourPath.valid() && theirPath.valid())
 			{
@@ -300,10 +325,9 @@
 
 					assert(otherZone->getModificator<RoadPlacer>());
 					otherZone->getModificator<RoadPlacer>()->addRoadNode(roadNode);
-
-					assert(otherZone->getModificator<ConnectionsPlacer>());
-					otherZone->getModificator<ConnectionsPlacer>()->otherSideConnection(connection);
 				}
+				assert(otherZone->getModificator<ConnectionsPlacer>());
+				otherZone->getModificator<ConnectionsPlacer>()->otherSideConnection(connection);
 
 				success = true;
 			}
@@ -391,11 +415,14 @@
 			
 			if(path1.valid() && path2.valid())
 			{
-				zone.connectPath(path1);
-				otherZone->connectPath(path2);
-				
 				manager.placeObject(rmgGate1, guarded1, true, allowRoad);
 				managerOther.placeObject(rmgGate2, guarded2, true, allowRoad);
+
+				replaceWithCurvedPath(path1, zone, rmgGate1.getVisitablePosition());
+				replaceWithCurvedPath(path2, *otherZone, rmgGate2.getVisitablePosition());
+
+				zone.connectPath(path1);
+				otherZone->connectPath(path2);
 				
 				assert(otherZone->getModificator<ConnectionsPlacer>());
 				otherZone->getModificator<ConnectionsPlacer>()->otherSideConnection(connection);
@@ -408,23 +435,30 @@
 	//4. place monoliths/portals
 	if(!success)
 	{
-		auto factory = VLC->objtypeh->getHandlerFor(Obj::MONOLITH_TWO_WAY, generator.getNextMonlithIndex());
-		auto * teleport1 = factory->create(map.mapInstance->cb, nullptr);
-		auto * teleport2 = factory->create(map.mapInstance->cb, nullptr);
-
-		RequiredObjectInfo obj1(teleport1, connection.getGuardStrength(), allowRoad);
-		RequiredObjectInfo obj2(teleport2, connection.getGuardStrength(), allowRoad);
-		zone.getModificator<ObjectManager>()->addRequiredObject(obj1);
-		otherZone->getModificator<ObjectManager>()->addRequiredObject(obj2);
-		
-		assert(otherZone->getModificator<ConnectionsPlacer>());
-		otherZone->getModificator<ConnectionsPlacer>()->otherSideConnection(connection);
-		
-		success = true;
+		placeMonolithConnection(connection);
 	}
+}
+
+void ConnectionsPlacer::placeMonolithConnection(const rmg::ZoneConnection & connection)
+{
+	auto otherZoneId = (connection.getZoneA() == zone.getId() ? connection.getZoneB() : connection.getZoneA());
+	auto & otherZone = map.getZones().at(otherZoneId);
+
+	bool allowRoad = shouldGenerateRoad(connection);
+
+	auto factory = VLC->objtypeh->getHandlerFor(Obj::MONOLITH_TWO_WAY, generator.getNextMonlithIndex());
+	auto * teleport1 = factory->create(map.mapInstance->cb, nullptr);
+	auto * teleport2 = factory->create(map.mapInstance->cb, nullptr);
+
+	RequiredObjectInfo obj1(teleport1, connection.getGuardStrength(), allowRoad);
+	RequiredObjectInfo obj2(teleport2, connection.getGuardStrength(), allowRoad);
+	zone.getModificator<ObjectManager>()->addRequiredObject(obj1);
+	otherZone->getModificator<ObjectManager>()->addRequiredObject(obj2);
+
+	dCompleted.push_back(connection);
 	
-	if(success)
-		dCompleted.push_back(connection);
+	assert(otherZone->getModificator<ConnectionsPlacer>());
+	otherZone->getModificator<ConnectionsPlacer>()->otherSideConnection(connection);
 }
 
 void ConnectionsPlacer::collectNeighbourZones()
@@ -444,7 +478,7 @@
 bool ConnectionsPlacer::shouldGenerateRoad(const rmg::ZoneConnection& connection) const
 {
 	return connection.getRoadOption() == rmg::ERoadOption::ROAD_TRUE ||
-		(connection.getRoadOption() == rmg::ERoadOption::ROAD_RANDOM && zone.getRand().nextDouble() >= 0.5f);
+		(connection.getRoadOption() == rmg::ERoadOption::ROAD_RANDOM && zone.getRand().nextDouble(0, 1) >= 0.5f);
 }
 
 void ConnectionsPlacer::createBorder()
diff --color -urN vcmi-1.5.7/lib/rmg/modificators/ConnectionsPlacer.h vcmi/lib/rmg/modificators/ConnectionsPlacer.h
--- vcmi-1.5.7/lib/rmg/modificators/ConnectionsPlacer.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/rmg/modificators/ConnectionsPlacer.h	2024-12-19 15:00:22.931149301 +0100
@@ -23,7 +23,8 @@
 	void init() override;
 	
 	void addConnection(const rmg::ZoneConnection& connection);
-	
+	void placeMonolithConnection(const rmg::ZoneConnection& connection);
+	void forcePortalConnection(const rmg::ZoneConnection & connection);
 	void selfSideDirectConnection(const rmg::ZoneConnection & connection);
 	void selfSideIndirectConnection(const rmg::ZoneConnection & connection);
 	void otherSideConnection(const rmg::ZoneConnection & connection);
diff --color -urN vcmi-1.5.7/lib/rmg/modificators/MinePlacer.cpp vcmi/lib/rmg/modificators/MinePlacer.cpp
--- vcmi-1.5.7/lib/rmg/modificators/MinePlacer.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/rmg/modificators/MinePlacer.cpp	2024-12-19 15:00:22.931149301 +0100
@@ -22,6 +22,8 @@
 #include "WaterAdopter.h"
 #include "../TileInfo.h"
 
+#include <vstd/RNG.h>
+
 VCMI_LIB_NAMESPACE_BEGIN
 
 void MinePlacer::process()
diff --color -urN vcmi-1.5.7/lib/rmg/modificators/ObjectDistributor.cpp vcmi/lib/rmg/modificators/ObjectDistributor.cpp
--- vcmi-1.5.7/lib/rmg/modificators/ObjectDistributor.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/rmg/modificators/ObjectDistributor.cpp	2024-12-19 15:00:22.931149301 +0100
@@ -25,6 +25,8 @@
 #include "../Functions.h"
 #include "../RmgObject.h"
 
+#include <vstd/RNG.h>
+
 VCMI_LIB_NAMESPACE_BEGIN
 
 void ObjectDistributor::process()
@@ -43,7 +45,6 @@
 
 void ObjectDistributor::distributeLimitedObjects()
 {
-	ObjectInfo oi;
 	auto zones = map.getZones();
 
 	for (auto primaryID : VLC->objtypeh->knownObjects())
@@ -79,6 +80,8 @@
 					RandomGeneratorUtil::randomShuffle(matchingZones, zone.getRand());
 					for (auto& zone : matchingZones)
 					{
+						ObjectInfo oi(primaryID, secondaryID);
+						
 						oi.generateObject = [cb=map.mapInstance->cb, primaryID, secondaryID]() -> CGObjectInstance *
 						{
 							return VLC->objtypeh->getHandlerFor(primaryID, secondaryID)->create(cb, nullptr);
@@ -157,7 +160,7 @@
 		}
 	}
 
-	size_t allowedPrisons = prisonHeroPlacer->getPrisonsRemaning();
+	size_t allowedPrisons = prisonHeroPlacer->getPrisonsRemaining();
 	for (int i = zones.size() - 1; i >= 0; i--)
 	{
 		auto zone = zones[i].second;
diff --color -urN vcmi-1.5.7/lib/rmg/modificators/ObjectManager.cpp vcmi/lib/rmg/modificators/ObjectManager.cpp
--- vcmi-1.5.7/lib/rmg/modificators/ObjectManager.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/rmg/modificators/ObjectManager.cpp	2024-12-19 15:00:22.932149343 +0100
@@ -29,6 +29,8 @@
 #include "../Functions.h"
 #include "../RmgObject.h"
 
+#include <vstd/RNG.h>
+
 VCMI_LIB_NAMESPACE_BEGIN
 
 void ObjectManager::process()
@@ -342,7 +344,7 @@
 {
 	int3 pos;
 	auto possibleArea = searchArea;
-	auto cachedArea = zone.areaPossible() + zone.freePaths();
+	auto cachedArea = zone.areaForRoads();
 	while(true)
 	{
 		pos = findPlaceForObject(possibleArea, obj, weightFunction, optimizer);
@@ -417,6 +419,9 @@
 			return false;
 		}
 		
+		// Once it can be created, replace with curved path
+		replaceWithCurvedPath(path, zone, rmgObject.getVisitablePosition());
+		
 		zone.connectPath(path);
 		placeObject(rmgObject, guarded, true, objInfo.createRoad);
 	}
@@ -447,6 +452,11 @@
 			logGlobal->error("Failed to fill zone %d due to lack of space", zone.getId());
 			return false;
 		}
+		if (objInfo.createRoad)
+		{
+			// Once valid path can be created, replace with curved path
+			replaceWithCurvedPath(path, zone, rmgObject.getVisitablePosition());
+		}
 		
 		zone.connectPath(path);
 		placeObject(rmgObject, guarded, true, objInfo.createRoad);
@@ -481,7 +491,7 @@
 										  [this, &rmgObject](const int3 & tile)
 		{
 			float dist = rmgObject.getArea().distanceSqr(zone.getPos());
-			dist *= (dist > 12.f * 12.f) ? 10.f : 1.f; //tiles closer 12 are preferrable
+			dist *= (dist > 12.f * 12.f) ? 10.f : 1.f; //tiles closer 12 are preferable
 			dist = 1000000.f - dist; //some big number
 			return dist + map.getNearestObjectDistance(tile);
 		}, guarded, false, OptimizeType::WEIGHT);
@@ -725,13 +735,13 @@
 	CreatureID creId = CreatureID::NONE;
 	int amount = 0;
 	std::vector<CreatureID> possibleCreatures;
-	for(auto cre : VLC->creh->objects)
+	for(auto const & cre : VLC->creh->objects)
 	{
 		if(cre->special)
 			continue;
 		if(!cre->getAIValue()) //bug #2681
 			continue;
-		if(!vstd::contains(zone.getMonsterTypes(), cre->getFaction()))
+		if(!vstd::contains(zone.getMonsterTypes(), cre->getFactionID()))
 			continue;
 		if((static_cast<si32>(cre->getAIValue() * (cre->ammMin + cre->ammMax) / 2) < strength) && (strength < static_cast<si32>(cre->getAIValue()) * 100)) //at least one full monster. size between average size of given stack and 100
 		{
diff --color -urN vcmi-1.5.7/lib/rmg/modificators/ObstaclePlacer.cpp vcmi/lib/rmg/modificators/ObstaclePlacer.cpp
--- vcmi-1.5.7/lib/rmg/modificators/ObstaclePlacer.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/rmg/modificators/ObstaclePlacer.cpp	2024-12-19 15:00:22.932149343 +0100
@@ -19,14 +19,13 @@
 #include "RiverPlacer.h"
 #include "../RmgMap.h"
 #include "../CMapGenerator.h"
-#include "../../CRandomGenerator.h"
 #include "../Functions.h"
+#include "../../entities/faction/CFaction.h"
 #include "../../mapping/CMapEditManager.h"
 #include "../../mapping/CMap.h"
 #include "../../mapping/ObstacleProxy.h"
 #include "../../mapObjects/CGObjectInstance.h"
 #include "../../mapObjects/ObstacleSetHandler.h"
-#include "../../CTownHandler.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
@@ -40,7 +39,7 @@
 
 	ObstacleSetFilter filter(ObstacleSet::EObstacleType::INVALID,
 							zone.getTerrainType(),
-							static_cast<ObstacleSet::EMapLevel>(zone.isUnderground()),
+							static_cast<EMapLevel>(zone.isUnderground()),
 							faction->getId(),
 							faction->alignment);
 
@@ -154,7 +153,7 @@
 	riverManager = zone.getModificator<RiverPlacer>();
 	if(riverManager)
 	{
-		const auto objTypeName = object.instances().front()->object().typeName;
+		const auto objTypeName = object.instances().front()->object().getTypeName();
 		if(objTypeName == "mountain")
 			riverManager->riverSource().unite(object.getArea());
 		else if(objTypeName == "lake")
diff --color -urN vcmi-1.5.7/lib/rmg/modificators/PrisonHeroPlacer.cpp vcmi/lib/rmg/modificators/PrisonHeroPlacer.cpp
--- vcmi-1.5.7/lib/rmg/modificators/PrisonHeroPlacer.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/rmg/modificators/PrisonHeroPlacer.cpp	2024-12-19 15:00:22.932149343 +0100
@@ -17,7 +17,9 @@
 #include "../../VCMI_Lib.h"
 #include "../../mapObjectConstructors/AObjectTypeHandler.h"
 #include "../../mapObjectConstructors/CObjectClassesHandler.h"
-#include "../../mapObjects/MapObjects.h" 
+#include "../../mapObjects/MapObjects.h"
+
+#include <vstd/RNG.h>
 
 VCMI_LIB_NAMESPACE_BEGIN
 
@@ -43,7 +45,7 @@
 	}
 }
 
-int PrisonHeroPlacer::getPrisonsRemaning() const
+int PrisonHeroPlacer::getPrisonsRemaining() const
 {
 	return std::max<int>(allowedHeroes.size() - reservedHeroes, 0);
 }
@@ -51,7 +53,7 @@
 HeroTypeID PrisonHeroPlacer::drawRandomHero()
 {
 	RecursiveLock lock(externalAccessMutex);
-	if (getPrisonsRemaning() > 0)
+	if (getPrisonsRemaining() > 0)
 	{
 		RandomGeneratorUtil::randomShuffle(allowedHeroes, zone.getRand());
         HeroTypeID ret = allowedHeroes.back();
diff --color -urN vcmi-1.5.7/lib/rmg/modificators/PrisonHeroPlacer.h vcmi/lib/rmg/modificators/PrisonHeroPlacer.h
--- vcmi-1.5.7/lib/rmg/modificators/PrisonHeroPlacer.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/rmg/modificators/PrisonHeroPlacer.h	2024-12-19 15:00:22.932149343 +0100
@@ -15,8 +15,6 @@
 
 VCMI_LIB_NAMESPACE_BEGIN
 
-class CRandomGenerator;
-
 class PrisonHeroPlacer : public Modificator
 {
 public:
@@ -25,7 +23,7 @@
 	void process() override;
 	void init() override;
 
-	int getPrisonsRemaning() const;
+	int getPrisonsRemaining() const;
 	[[nodiscard]] HeroTypeID drawRandomHero();
 	void restoreDrawnHero(const HeroTypeID & hid);
 
diff --color -urN vcmi-1.5.7/lib/rmg/modificators/QuestArtifactPlacer.cpp vcmi/lib/rmg/modificators/QuestArtifactPlacer.cpp
--- vcmi-1.5.7/lib/rmg/modificators/QuestArtifactPlacer.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/rmg/modificators/QuestArtifactPlacer.cpp	2024-12-19 15:00:22.932149343 +0100
@@ -17,7 +17,9 @@
 #include "../../VCMI_Lib.h"
 #include "../../mapObjectConstructors/AObjectTypeHandler.h"
 #include "../../mapObjectConstructors/CObjectClassesHandler.h"
-#include "../../mapObjects/MapObjects.h" 
+#include "../../mapObjects/MapObjects.h"
+
+#include <vstd/RNG.h>
 
 VCMI_LIB_NAMESPACE_BEGIN
 
@@ -95,7 +97,7 @@
 	logGlobal->trace("Number of nearby zones suitable for quest artifacts: %d", questArtZones.size());
 }
 
-void QuestArtifactPlacer::placeQuestArtifacts(CRandomGenerator & rand)
+void QuestArtifactPlacer::placeQuestArtifacts(vstd::RNG & rand)
 {
 	for (const auto & artifactToPlace : questArtifactsToPlace)
 	{
@@ -110,7 +112,7 @@
 
 			logGlobal->trace("Replacing %s at %s with the quest artifact %s",
 				objectToReplace->getObjectName(),
-				objectToReplace->getPosition().toString(),
+				objectToReplace->anchorPos().toString(),
 				VLC->artifacts()->getById(artifactToPlace)->getNameTranslated());
 
 			//Update appearance. Terrain is irrelevant.
@@ -119,7 +121,7 @@
 			auto templates = handler->getTemplates();
 			//artifactToReplace->appearance = templates.front();
 			newObj->appearance  = templates.front();
-			newObj->pos = objectToReplace->pos;
+			newObj->setAnchorPos(objectToReplace->anchorPos());
 			mapProxy->insertObject(newObj);
 			mapProxy->removeObject(objectToReplace);
 			break;
diff --color -urN vcmi-1.5.7/lib/rmg/modificators/QuestArtifactPlacer.h vcmi/lib/rmg/modificators/QuestArtifactPlacer.h
--- vcmi-1.5.7/lib/rmg/modificators/QuestArtifactPlacer.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/rmg/modificators/QuestArtifactPlacer.h	2024-12-19 15:00:22.932149343 +0100
@@ -15,8 +15,6 @@
 
 VCMI_LIB_NAMESPACE_BEGIN
 
-class CRandomGenerator;
-
 class QuestArtifactPlacer : public Modificator
 {
 public:
@@ -33,7 +31,7 @@
 	void rememberPotentialArtifactToReplace(CGObjectInstance* obj);
 	CGObjectInstance * drawObjectToReplace();
 	std::vector<CGObjectInstance*> getPossibleArtifactsToReplace() const;
-	void placeQuestArtifacts(CRandomGenerator & rand);
+	void placeQuestArtifacts(vstd::RNG & rand);
 	void dropReplacedArtifact(CGObjectInstance* obj);
 
 	size_t getMaxQuestArtifactCount() const;
@@ -50,4 +48,4 @@
 	std::vector<ArtifactID> questArtifacts;
 };
 
-VCMI_LIB_NAMESPACE_END
\ No newline at end of file
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/rmg/modificators/RiverPlacer.cpp vcmi/lib/rmg/modificators/RiverPlacer.cpp
--- vcmi-1.5.7/lib/rmg/modificators/RiverPlacer.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/rmg/modificators/RiverPlacer.cpp	2024-12-19 15:00:22.932149343 +0100
@@ -20,12 +20,15 @@
 #include "../../mapObjects/ObjectTemplate.h"
 #include "../../mapping/CMap.h"
 #include "../../mapping/CMapEditManager.h"
+#include "../../VCMI_Lib.h"
 #include "../RmgPath.h"
 #include "ObjectManager.h"
 #include "ObstaclePlacer.h"
 #include "WaterProxy.h"
 #include "RoadPlacer.h"
 
+#include <vstd/RNG.h>
+
 VCMI_LIB_NAMESPACE_BEGIN
 
 const int RIVER_DELTA_ID = 143;
@@ -209,7 +212,7 @@
 	{
 		auto river = VLC->terrainTypeHandler->getById(zone.getTerrainType())->river;
 		auto & a = neighbourZonesTiles[connectedToWaterZoneId];
-		auto availableArea = zone.areaPossible() + zone.freePaths();
+		auto availableArea = zone.areaForRoads();
 		for(const auto & tileToProcess : availableArea.getTilesVector())
 		{
 			int templateId = -1;
diff --color -urN vcmi-1.5.7/lib/rmg/modificators/RoadPlacer.cpp vcmi/lib/rmg/modificators/RoadPlacer.cpp
--- vcmi-1.5.7/lib/rmg/modificators/RoadPlacer.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/rmg/modificators/RoadPlacer.cpp	2024-12-19 15:00:22.932149343 +0100
@@ -21,6 +21,7 @@
 #include "../../modding/IdentifierStorage.h"
 #include "../../modding/ModScope.h"
 #include "../../TerrainHandler.h"
+#include "../../VCMI_Lib.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
@@ -148,7 +149,7 @@
 	//Do not draw roads on underground rock or water
 	roads.erase_if([this](const int3& pos) -> bool
 	{
-		const auto* terrain = map.getTile(pos).terType;
+		const auto* terrain = map.getTile(pos).getTerrain();
 		return !terrain->isPassable() || !terrain->isLand();
 	});
 
diff --color -urN vcmi-1.5.7/lib/rmg/modificators/RockFiller.cpp vcmi/lib/rmg/modificators/RockFiller.cpp
--- vcmi-1.5.7/lib/rmg/modificators/RockFiller.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/rmg/modificators/RockFiller.cpp	2024-12-19 15:00:22.933149384 +0100
@@ -19,7 +19,6 @@
 #include "../CMapGenerator.h"
 #include "../Functions.h"
 #include "../../TerrainHandler.h"
-#include "../../CRandomGenerator.h"
 #include "../lib/mapping/CMapEditManager.h"
 #include "../TileInfo.h"
 #include "../threadpool/MapProxy.h"
@@ -73,7 +72,7 @@
 
 char RockFiller::dump(const int3 & t)
 {
-	if(!map.getTile(t).terType->isPassable())
+	if(!map.getTile(t).getTerrain()->isPassable())
 	{
 		return zone.area()->contains(t) ? 'R' : 'E';
 	}
diff --color -urN vcmi-1.5.7/lib/rmg/modificators/RockPlacer.cpp vcmi/lib/rmg/modificators/RockPlacer.cpp
--- vcmi-1.5.7/lib/rmg/modificators/RockPlacer.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/rmg/modificators/RockPlacer.cpp	2024-12-19 15:00:22.933149384 +0100
@@ -18,8 +18,8 @@
 #include "../CMapGenerator.h"
 #include "../Functions.h"
 #include "../../TerrainHandler.h"
-#include "../../CRandomGenerator.h"
 #include "../../mapping/CMapEditManager.h"
+#include "../../VCMI_Lib.h"
 #include "../TileInfo.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
@@ -60,7 +60,7 @@
 		//Finally mark rock tiles as occupied, spawn no obstacles there
 		rockArea = zone.area()->getSubarea([this](const int3 & t)
 		{
-			return !map.getTile(t).terType->isPassable();
+			return !map.getTile(t).getTerrain()->isPassable();
 		});
 
 		// Do not place rock on roads
@@ -96,7 +96,7 @@
 
 char RockPlacer::dump(const int3 & t)
 {
-	if(!map.getTile(t).terType->isPassable())
+	if(!map.getTile(t).getTerrain()->isPassable())
 	{
 		return zone.area()->contains(t) ? 'R' : 'E';
 	}
diff --color -urN vcmi-1.5.7/lib/rmg/modificators/TerrainPainter.cpp vcmi/lib/rmg/modificators/TerrainPainter.cpp
--- vcmi-1.5.7/lib/rmg/modificators/TerrainPainter.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/rmg/modificators/TerrainPainter.cpp	2024-12-19 15:00:22.933149384 +0100
@@ -20,7 +20,10 @@
 #include "../RmgMap.h"
 #include "../../VCMI_Lib.h"
 #include "../../TerrainHandler.h"
-#include "../../CTownHandler.h"
+#include "../../entities/faction/CFaction.h"
+#include "../../entities/faction/CTownHandler.h"
+
+#include <vstd/RNG.h>
 
 VCMI_LIB_NAMESPACE_BEGIN
 
@@ -76,7 +79,7 @@
 			{
 				//Fill with all terain types by default
 				{
-					for (auto terrain : VLC->terrainTypeHandler->objects)
+					for (const auto & terrain : VLC->terrainTypeHandler->objects)
 					{
 						if (terrain->isLand() && terrain->isPassable())
 						{
diff --color -urN vcmi-1.5.7/lib/rmg/modificators/TownPlacer.cpp vcmi/lib/rmg/modificators/TownPlacer.cpp
--- vcmi-1.5.7/lib/rmg/modificators/TownPlacer.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/rmg/modificators/TownPlacer.cpp	2024-12-19 15:00:22.933149384 +0100
@@ -12,6 +12,7 @@
 #include "TownPlacer.h"
 #include "../CMapGenerator.h"
 #include "../RmgMap.h"
+#include "../../entities/faction/CTownHandler.h"
 #include "../../mapObjectConstructors/AObjectTypeHandler.h"
 #include "../../mapObjectConstructors/CObjectClassesHandler.h"
 #include "../../mapObjects/CGTownInstance.h"
@@ -27,6 +28,8 @@
 #include "WaterAdopter.h"
 #include "../TileInfo.h"
 
+#include <vstd/RNG.h>
+
 VCMI_LIB_NAMESPACE_BEGIN
 
 void TownPlacer::process()
@@ -76,20 +79,18 @@
 
 		CGTownInstance * town = dynamic_cast<CGTownInstance *>(townFactory->create(map.mapInstance->cb, nullptr));
 		town->tempOwner = player;
-		town->builtBuildings.insert(BuildingID::FORT);
-		town->builtBuildings.insert(BuildingID::DEFAULT);
+		town->addBuilding(BuildingID::FORT);
+		town->addBuilding(BuildingID::DEFAULT);
 		
-		for(auto spell : VLC->spellh->objects) //add all regular spells to town
-		{
-			if(!spell->isSpecial() && !spell->isCreatureAbility())
-				town->possibleSpells.push_back(spell->id);
-		}
+
+		for(auto spellID : VLC->spellh->getDefaultAllowed()) //add all regular spells to town
+			town->possibleSpells.push_back(spellID);
 		
 		auto position = placeMainTown(manager, *town);
 		
 		totalTowns++;
 		//register MAIN town of zone only
-		map.registerZone(town->getFaction());
+		map.registerZone(town->getFactionID());
 		
 		if(player.isValidPlayer()) //configure info for owning player
 		{
@@ -202,20 +203,17 @@
 		
 		town->tempOwner = player;
 		if (hasFort)
-			town->builtBuildings.insert(BuildingID::FORT);
-		town->builtBuildings.insert(BuildingID::DEFAULT);
+			town->addBuilding(BuildingID::FORT);
+		town->addBuilding(BuildingID::DEFAULT);
 		
-		for(auto spell : VLC->spellh->objects) //add all regular spells to town
-		{
-			if(!spell->isSpecial() && !spell->isCreatureAbility())
-				town->possibleSpells.push_back(spell->id);
-		}
+		for(auto spellID : VLC->spellh->getDefaultAllowed()) //add all regular spells to town
+			town->possibleSpells.push_back(spellID);
 		
 		if(totalTowns <= 0)
 		{
 			//FIXME: discovered bug with small zones - getPos is close to map boarder and we have outOfMap exception
 			//register MAIN town of zone
-			map.registerZone(town->getFaction());
+			map.registerZone(town->getFactionID());
 			//first town in zone goes in the middle
 			placeMainTown(manager, *town);
 		}
diff --color -urN vcmi-1.5.7/lib/rmg/modificators/TreasurePlacer.cpp vcmi/lib/rmg/modificators/TreasurePlacer.cpp
--- vcmi-1.5.7/lib/rmg/modificators/TreasurePlacer.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/rmg/modificators/TreasurePlacer.cpp	2024-12-19 15:00:22.933149384 +0100
@@ -10,6 +10,7 @@
 
 #include "StdInc.h"
 #include "TreasurePlacer.h"
+#include "../CRmgTemplate.h"
 #include "../CMapGenerator.h"
 #include "../Functions.h"
 #include "ObjectManager.h"
@@ -24,6 +25,7 @@
 #include "../../mapObjectConstructors/AObjectTypeHandler.h"
 #include "../../mapObjectConstructors/CObjectClassesHandler.h"
 #include "../../mapObjectConstructors/DwellingInstanceConstructor.h"
+#include "../../rewardable/Info.h"
 #include "../../mapObjects/CGHeroInstance.h"
 #include "../../mapObjects/CGPandoraBox.h"
 #include "../../mapObjects/CQuest.h"
@@ -33,17 +35,33 @@
 #include "../../mapping/CMap.h"
 #include "../../mapping/CMapEditManager.h"
 
+#include <vstd/RNG.h>
+
 VCMI_LIB_NAMESPACE_BEGIN
 
-ObjectInfo::ObjectInfo():
-	destroyObject([](CGObjectInstance * obj){})
+void TreasurePlacer::process()
 {
+	if (zone.getMaxTreasureValue() == 0)
+	{
+		//No treasures at all
+		return;
+	}
 
-}
+	tierValues = generator.getConfig().pandoraCreatureValues;
+	// Add all native creatures
+	for(auto const & cre : VLC->creh->objects)
+	{
+		if(!cre->special && cre->getFactionID() == zone.getTownType())
+		{
+			creatures.push_back(cre.get());
+		}
+	}
 
-void TreasurePlacer::process()
-{
+	// Get default objects
 	addAllPossibleObjects();
+	// Override with custom objects
+	objects.patchWithZoneConfig(zone, this);
+
 	auto * m = zone.getModificator<ObjectManager>();
 	if(m)
 		createTreasures(*m);
@@ -60,14 +78,37 @@
 
 void TreasurePlacer::addObjectToRandomPool(const ObjectInfo& oi)
 {
+	if (oi.templates.empty())
+	{
+		logGlobal->error("Attempt to add ObjectInfo with no templates! Value: %d", oi.value);
+		return;
+	}
+	if (!oi.generateObject)
+	{
+		logGlobal->error("Attempt to add ObjectInfo with no generateObject function! Value: %d", oi.value);
+		return;
+	}
+	if (!oi.maxPerZone)
+	{
+		logGlobal->warn("Attempt to add ObjectInfo with 0 maxPerZone! Value: %d", oi.value);
+		return;
+	}
 	RecursiveLock lock(externalAccessMutex);
-	possibleObjects.push_back(oi);
+	objects.addObject(oi);
 }
 
 void TreasurePlacer::addAllPossibleObjects()
 {
-	ObjectInfo oi;
-	
+	addCommonObjects();
+	addDwellings();
+	addPandoraBoxes();
+	addSeerHuts();
+	addPrisons();
+	addScrolls();
+}
+
+void TreasurePlacer::addCommonObjects()
+{
 	for(auto primaryID : VLC->objtypeh->knownObjects())
 	{
 		for(auto secondaryID : VLC->objtypeh->knownSubObjects(primaryID))
@@ -81,21 +122,31 @@
 					//Skip objects with per-map limit here
 					continue;
 				}
+				ObjectInfo oi(primaryID, secondaryID);
+				setBasicProperties(oi, CompoundMapObjectID(primaryID, secondaryID));
 
-				oi.generateObject = [this, primaryID, secondaryID]() -> CGObjectInstance *
-				{
-					return VLC->objtypeh->getHandlerFor(primaryID, secondaryID)->create(map.mapInstance->cb, nullptr);
-				};
 				oi.value = rmgInfo.value;
 				oi.probability = rmgInfo.rarity;
-				oi.setTemplates(primaryID, secondaryID, zone.getTerrainType());
 				oi.maxPerZone = rmgInfo.zoneLimit;
+
 				if(!oi.templates.empty())
 					addObjectToRandomPool(oi);
 			}
 		}
 	}
+}
+
+void TreasurePlacer::setBasicProperties(ObjectInfo & oi, CompoundMapObjectID objid) const
+{
+	oi.generateObject = [this, objid]() -> CGObjectInstance *
+	{
+		return VLC->objtypeh->getHandlerFor(objid)->create(map.mapInstance->cb, nullptr);
+	};
+	oi.setTemplates(objid.primaryID, objid.secondaryID, zone.getTerrainType());
+}
 
+void TreasurePlacer::addPrisons()
+{
 	//Generate Prison on water only if it has a template
 	auto prisonTemplates = VLC->objtypeh->getHandlerFor(Obj::PRISON, 0)->getTemplates(zone.getTerrainType());
 	if (!prisonTemplates.empty())
@@ -117,7 +168,7 @@
 		size_t prisonsLeft = getMaxPrisons();
 		for (int i = prisonsLevels - 1; i >= 0; i--)
 		{
-			ObjectInfo oi; // Create new instance which will hold destructor operation
+			ObjectInfo oi(Obj::PRISON, 0); // Create new instance which will hold destructor operation
 
 			oi.value = generator.getConfig().prisonValues[i];
 			if (oi.value > zone.getMaxTreasureValue())
@@ -141,7 +192,7 @@
 			{
 				// Hero can be used again
 				auto* hero = dynamic_cast<CGHeroInstance*>(obj);
-				prisonHeroPlacer->restoreDrawnHero(hero->getHeroType());
+				prisonHeroPlacer->restoreDrawnHero(hero->getHeroTypeID());
 			};
 
 			oi.setTemplates(Obj::PRISON, 0, zone.getTerrainType());
@@ -155,22 +206,13 @@
 				addObjectToRandomPool(oi);
 		}
 	}
+}
 
+void TreasurePlacer::addDwellings()
+{
 	if(zone.getType() == ETemplateZoneType::WATER)
 		return;
-	
-	//all following objects are unlimited
-	oi.maxPerZone = std::numeric_limits<ui32>::max();
 
-	std::vector<const CCreature *> creatures; //native creatures for this zone
-	for(auto cre : VLC->creh->objects)
-	{
-		if(!cre->special && cre->getFaction() == zone.getTownType())
-		{
-			creatures.push_back(cre.get());
-		}
-	}
-	
 	//dwellings
 	auto dwellingTypes = {Obj::CREATURE_GENERATOR1, Obj::CREATURE_GENERATOR4};
 	
@@ -194,9 +236,12 @@
 				continue;
 
 			const auto * cre = creatures.front();
-			if(cre->getFaction() == zone.getTownType())
+			if(cre->getFactionID() == zone.getTownType())
 			{
-				auto nativeZonesCount = static_cast<float>(map.getZoneCount(cre->getFaction()));
+				auto nativeZonesCount = static_cast<float>(map.getZoneCount(cre->getFactionID()));
+				ObjectInfo oi(dwellingType, secondaryID);
+				setBasicProperties(oi, CompoundMapObjectID(dwellingType, secondaryID));
+
 				oi.value = static_cast<ui32>(cre->getAIValue() * cre->getGrowth() * (1 + (nativeZonesCount / map.getTotalZoneCount()) + (nativeZonesCount / 2)));
 				oi.probability = 40;
 				
@@ -206,13 +251,20 @@
 					obj->tempOwner = PlayerColor::NEUTRAL;
 					return obj;
 				};
-				oi.setTemplates(dwellingType, secondaryID, zone.getTerrainType());
 				if(!oi.templates.empty())
 					addObjectToRandomPool(oi);
 			}
 		}
 	}
-	
+}
+
+void TreasurePlacer::addScrolls()
+{
+	if(zone.getType() == ETemplateZoneType::WATER)
+		return;
+
+	ObjectInfo oi(Obj::SPELL_SCROLL, 0);
+
 	for(int i = 0; i < generator.getConfig().scrollValues.size(); i++)
 	{
 		oi.generateObject = [i, this]() -> CGObjectInstance *
@@ -221,12 +273,10 @@
 			auto * obj = dynamic_cast<CGArtifact *>(factory->create(map.mapInstance->cb, nullptr));
 			std::vector<SpellID> out;
 			
-			for(auto spell : VLC->spellh->objects) //spellh size appears to be greater (?)
+			for(auto spellID : VLC->spellh->getDefaultAllowed())
 			{
-				if(map.isAllowedSpell(spell->id) && spell->getLevel() == i + 1)
-				{
-					out.push_back(spell->id);
-				}
+				if(map.isAllowedSpell(spellID) && spellID.toSpell()->getLevel() == i + 1)
+					out.push_back(spellID);
 			}
 			auto * a = ArtifactUtils::createScroll(*RandomGeneratorUtil::nextItem(out, zone.getRand()));
 			obj->storedArtifact = a;
@@ -239,7 +289,22 @@
 			addObjectToRandomPool(oi);
 	}
 	
-	//pandora box with gold
+}
+
+void TreasurePlacer::addPandoraBoxes()
+{
+	if(zone.getType() == ETemplateZoneType::WATER)
+		return;
+
+	addPandoraBoxesWithGold();
+	addPandoraBoxesWithExperience();
+	addPandoraBoxesWithCreatures();
+	addPandoraBoxesWithSpells();
+}
+
+void TreasurePlacer::addPandoraBoxesWithGold()
+{
+	ObjectInfo oi(Obj::PANDORAS_BOX, 0);
 	for(int i = 1; i < 5; i++)
 	{
 		oi.generateObject = [this, i]() -> CGObjectInstance *
@@ -260,8 +325,11 @@
 		if(!oi.templates.empty())
 			addObjectToRandomPool(oi);
 	}
-	
-	//pandora box with experience
+}
+
+void TreasurePlacer::addPandoraBoxesWithExperience()
+{
+	ObjectInfo oi(Obj::PANDORAS_BOX, 0);
 	for(int i = 1; i < 5; i++)
 	{
 		oi.generateObject = [this, i]() -> CGObjectInstance *
@@ -282,49 +350,17 @@
 		if(!oi.templates.empty())
 			addObjectToRandomPool(oi);
 	}
-	
-	//pandora box with creatures
-	const std::vector<int> & tierValues = generator.getConfig().pandoraCreatureValues;
-	
-	auto creatureToCount = [tierValues](const CCreature * creature) -> int
-	{
-		if(!creature->getAIValue() || tierValues.empty()) //bug #2681
-			return 0; //this box won't be generated
-		
-		//Follow the rules from https://heroes.thelazy.net/index.php/Pandora%27s_Box
-
-		int actualTier = creature->getLevel() > tierValues.size() ?
-			tierValues.size() - 1 :
-			creature->getLevel() - 1;
-		float creaturesAmount = std::floor((static_cast<float>(tierValues[actualTier])) / creature->getAIValue());
-		if (creaturesAmount < 1)
-		{
-			return 0;
-		}
-		else if(creaturesAmount <= 5)
-		{
-			//No change
-		}
-		else if(creaturesAmount <= 12)
-		{
-			creaturesAmount = std::ceil(creaturesAmount / 2) * 2;
-		}
-		else if(creaturesAmount <= 50)
-		{
-			creaturesAmount = std::round(creaturesAmount / 5) * 5;
-		}
-		else
-		{
-			creaturesAmount = std::round(creaturesAmount / 10) * 10;
-		}
-		return static_cast<int>(creaturesAmount);
-	};
+}
 
+void TreasurePlacer::addPandoraBoxesWithCreatures()
+{
 	for(auto * creature : creatures)
 	{
 		int creaturesAmount = creatureToCount(creature);
 		if(!creaturesAmount)
 			continue;
+
+		ObjectInfo oi(Obj::PANDORAS_BOX, 0);
 		
 		oi.generateObject = [this, creature, creaturesAmount]() -> CGObjectInstance *
 		{
@@ -339,12 +375,16 @@
 			return obj;
 		};
 		oi.setTemplates(Obj::PANDORAS_BOX, 0, zone.getTerrainType());
-		oi.value = static_cast<ui32>((2 * (creature->getAIValue()) * creaturesAmount * (1 + static_cast<float>(map.getZoneCount(creature->getFaction())) / map.getTotalZoneCount())) / 3);
+		oi.value = static_cast<ui32>(creature->getAIValue() * creaturesAmount * (1 + static_cast<float>(map.getZoneCount(creature->getFactionID())) / map.getTotalZoneCount()));
 		oi.probability = 3;
 		if(!oi.templates.empty())
 			addObjectToRandomPool(oi);
 	}
-	
+}
+
+void TreasurePlacer::addPandoraBoxesWithSpells()
+{
+	ObjectInfo oi(Obj::PANDORAS_BOX, 0);
 	//Pandora with 12 spells of certain level
 	for(int i = 1; i <= GameConstants::SPELL_LEVELS; i++)
 	{
@@ -354,10 +394,10 @@
 			auto * obj = dynamic_cast<CGPandoraBox *>(factory->create(map.mapInstance->cb, nullptr));
 
 			std::vector <const CSpell *> spells;
-			for(auto spell : VLC->spellh->objects)
+			for(auto spellID : VLC->spellh->getDefaultAllowed())
 			{
-				if(map.isAllowedSpell(spell->id) && spell->getLevel() == i)
-					spells.push_back(spell.get());
+				if(map.isAllowedSpell(spellID) && spellID.toSpell()->getLevel() == i)
+					spells.push_back(spellID.toSpell());
 			}
 			
 			RandomGeneratorUtil::randomShuffle(spells, zone.getRand());
@@ -387,10 +427,10 @@
 			auto * obj = dynamic_cast<CGPandoraBox *>(factory->create(map.mapInstance->cb, nullptr));
 
 			std::vector <const CSpell *> spells;
-			for(auto spell : VLC->spellh->objects)
+			for(auto spellID : VLC->spellh->getDefaultAllowed())
 			{
-				if(map.isAllowedSpell(spell->id) && spell->hasSchool(SpellSchool(i)))
-					spells.push_back(spell.get());
+				if(map.isAllowedSpell(spellID) && spellID.toSpell()->hasSchool(SpellSchool(i)))
+					spells.push_back(spellID.toSpell());
 			}
 			
 			RandomGeneratorUtil::randomShuffle(spells, zone.getRand());
@@ -419,10 +459,10 @@
 		auto * obj = dynamic_cast<CGPandoraBox *>(factory->create(map.mapInstance->cb, nullptr));
 
 		std::vector <const CSpell *> spells;
-		for(auto spell : VLC->spellh->objects)
+		for(auto spellID : VLC->spellh->getDefaultAllowed())
 		{
-			if(map.isAllowedSpell(spell->id))
-				spells.push_back(spell.get());
+			if(map.isAllowedSpell(spellID))
+				spells.push_back(spellID.toSpell());
 		}
 		
 		RandomGeneratorUtil::randomShuffle(spells, zone.getRand());
@@ -441,9 +481,14 @@
 	oi.probability = 2;
 	if(!oi.templates.empty())
 		addObjectToRandomPool(oi);
-	
+}
+
+void TreasurePlacer::addSeerHuts()
+{
 	//Seer huts with creatures or generic rewards
 
+	ObjectInfo oi(Obj::SEER_HUT, 0);
+
 	if(zone.getConnectedZoneIds().size()) //Unlikely, but...
 	{
 		auto * qap = zone.getModificator<QuestArtifactPlacer>();
@@ -510,7 +555,7 @@
 			oi.destroyObject = destroyObject;
 			oi.probability = 3;
 			oi.setTemplates(Obj::SEER_HUT, randomAppearance, zone.getTerrainType());
-			oi.value = static_cast<ui32>(((2 * (creature->getAIValue()) * creaturesAmount * (1 + static_cast<float>(map.getZoneCount(creature->getFaction())) / map.getTotalZoneCount())) - 4000) / 3);
+			oi.value = static_cast<ui32>(((2 * (creature->getAIValue()) * creaturesAmount * (1 + static_cast<float>(map.getZoneCount(creature->getFactionID())) / map.getTotalZoneCount())) - 4000) / 3);
 			if (oi.value > zone.getMaxTreasureValue())
 			{
 				continue;
@@ -523,7 +568,7 @@
 		}
 		
 		static const int seerLevels = std::min(generator.getConfig().questValues.size(), generator.getConfig().questRewardValues.size());
-		for(int i = 0; i < seerLevels; i++) //seems that code for exp and gold reward is similiar
+		for(int i = 0; i < seerLevels; i++) //seems that code for exp and gold reward is similar
 		{
 			int randomAppearance = chooseRandomAppearance(zone.getRand(), Obj::SEER_HUT, zone.getTerrainType());
 			
@@ -588,12 +633,6 @@
 	}
 }
 
-size_t TreasurePlacer::getPossibleObjectsSize() const
-{
-	RecursiveLock lock(externalAccessMutex);
-	return possibleObjects.size();
-}
-
 void TreasurePlacer::setMaxPrisons(size_t count)
 {
 	RecursiveLock lock(externalAccessMutex);
@@ -606,6 +645,40 @@
 	return maxPrisons;
 }
 
+int TreasurePlacer::creatureToCount(const CCreature * creature) const
+{
+	if(!creature->getAIValue() || tierValues.empty()) //bug #2681
+		return 0; //this box won't be generated
+	
+	//Follow the rules from https://heroes.thelazy.net/index.php/Pandora%27s_Box
+
+	int actualTier = creature->getLevel() > tierValues.size() ?
+		tierValues.size() - 1 :
+		creature->getLevel() - 1;
+	float creaturesAmount = std::floor((static_cast<float>(tierValues[actualTier])) / creature->getAIValue());
+	if (creaturesAmount < 1)
+	{
+		return 0;
+	}
+	else if(creaturesAmount <= 5)
+	{
+		//No change
+	}
+	else if(creaturesAmount <= 12)
+	{
+		creaturesAmount = std::ceil(creaturesAmount / 2) * 2;
+	}
+	else if(creaturesAmount <= 50)
+	{
+		creaturesAmount = std::round(creaturesAmount / 5) * 5;
+	}
+	else
+	{
+		creaturesAmount = std::round(creaturesAmount / 10) * 10;
+	}
+	return static_cast<int>(creaturesAmount);
+};
+
 bool TreasurePlacer::isGuardNeededForTreasure(int value)
 {// no guard in a zone with "monsters: none" and for small treasures; water zones cen get monster strength ZONE_NONE elsewhere if needed
 	return zone.monsterStrength != EMonsterStrength::ZONE_NONE && value > minGuardedValue;
@@ -623,6 +696,7 @@
 	bool hasLargeObject = false;
 	while(currentValue <= static_cast<int>(desiredValue) - 100) //no objects with value below 100 are available
 	{
+		// FIXME: Pointer might be invalidated after this
 		auto * oi = getRandomObject(desiredValue, currentValue, !hasLargeObject);
 		if(!oi) //fail
 			break;
@@ -651,7 +725,7 @@
 		if (currentValue >= minValue)
 		{
 			// 50% chance to end right here
-			if (zone.getRand().nextInt() & 1)
+			if (zone.getRand().nextInt(0, 1) == 1)
 				break;
 		}
 	}
@@ -674,12 +748,21 @@
 			accessibleArea.add(int3());
 		}
 		
-		auto * object = oi->generateObject();
-		if(oi->templates.empty())
+		CGObjectInstance * object = nullptr;
+		if (oi->generateObject)
 		{
-			logGlobal->warn("Deleting randomized object with no templates: %s", object->getObjectName());
-			oi->destroyObject(object);
-			delete object;
+			object = oi->generateObject();
+			if(oi->templates.empty())
+			{
+				logGlobal->warn("Deleting randomized object with no templates: %s", object->getObjectName());
+				oi->destroyObject(object);
+				delete object;
+				continue;
+			}
+		}
+		else
+		{
+			logGlobal->error("ObjectInfo has no generateObject function! Templates: %d", oi->templates.size());
 			continue;
 		}
 		
@@ -785,7 +868,7 @@
 	ui32 maxVal = desiredValue - currentValue;
 	ui32 minValue = static_cast<ui32>(0.25f * (desiredValue - currentValue));
 	
-	for(ObjectInfo & oi : possibleObjects) //copy constructor turned out to be costly
+	for(ObjectInfo & oi : objects.getPossibleObjects()) //copy constructor turned out to be costly
 	{
 		if(oi.value > maxVal)
 			break; //this assumes values are sorted in ascending order
@@ -859,24 +942,19 @@
 	boost::sort(treasureInfo, valueComparator);
 
 	//sort treasures by ascending value so we can stop checking treasures with too high value
-	boost::sort(possibleObjects, [](const ObjectInfo& oi1, const ObjectInfo& oi2) -> bool
-	{
-		return oi1.value < oi2.value;
-	});
+	objects.sortPossibleObjects();
 
 	const size_t size = zone.area()->getTilesVector().size();
 
 	int totalDensity = 0;
 
+	// FIXME: No need to use iterator here
 	for (auto t  = treasureInfo.begin(); t != treasureInfo.end(); t++)
 	{
 		std::vector<rmg::Object> treasures;
 
 		//discard objects with too high value to be ever placed
-		vstd::erase_if(possibleObjects, [t](const ObjectInfo& oi) -> bool
-		{
-			return oi.value > t->max;
-		});
+		objects.discardObjectsAboveValue(t->max);
 
 		totalDensity += t->density;
 
@@ -895,17 +973,21 @@
 				continue;
 			}
 
-			int value = std::accumulate(treasurePileInfos.begin(), treasurePileInfos.end(), 0, [](int v, const ObjectInfo* oi) {return v + oi->value; });
+			int value = std::accumulate(treasurePileInfos.begin(), treasurePileInfos.end(), 0,
+				[](int v, const ObjectInfo* oi)
+			{
+				return v + oi->value;
+			});
 
-			const ui32 maxPileGenerationAttemps = 2;
-			for (ui32 attempt = 0; attempt < maxPileGenerationAttemps; attempt++)
+			const ui32 maxPileGenerationAttempts = 2;
+			for (ui32 attempt = 0; attempt < maxPileGenerationAttempts; attempt++)
 			{
 				auto rmgObject = constructTreasurePile(treasurePileInfos, attempt == maxAttempts);
 
 				if (rmgObject.instances().empty())
 				{
-					// Restore once if all attemps failed
-					if (attempt == (maxPileGenerationAttemps - 1))
+					// Restore once if all attempts failed
+					if (attempt == (maxPileGenerationAttempts - 1))
 					{
 						restoreZoneLimits(treasurePileInfos);
 					}
@@ -1016,13 +1098,222 @@
 	return Modificator::dump(t);
 }
 
-void ObjectInfo::setTemplates(MapObjectID type, MapObjectSubID subtype, TerrainId terrainType)
+void TreasurePlacer::ObjectPool::addObject(const ObjectInfo & info)
 {
-	auto templHandler = VLC->objtypeh->getHandlerFor(type, subtype);
-	if(!templHandler)
-		return;
-	
-	templates = templHandler->getTemplates(terrainType);
+	possibleObjects.push_back(info);
+}
+
+void TreasurePlacer::ObjectPool::updateObject(MapObjectID id, MapObjectSubID subid, ObjectInfo info)
+{
+	/*
+	Handle separately:
+		- Dwellings
+		- Prisons
+		- Seer huts (quests)
+		- Pandora Boxes
+	*/
+	// FIXME: This will drop all templates
+	customObjects.insert(std::make_pair(CompoundMapObjectID(id, subid), info));
+}
+
+void TreasurePlacer::ObjectPool::patchWithZoneConfig(const Zone & zone, TreasurePlacer * tp)
+{
+	// FIXME: Wycina wszystkie obiekty poza pandorami i dwellami :?
+
+	// Copy standard objects if they are not already modified
+	/*
+	for (const auto & object : possibleObjects)
+	{
+		for (const auto & templ : object.templates)
+		{
+			// FIXME: Objects with same temmplates (Pandora boxes) are not added
+			CompoundMapObjectID key(templ->id, templ->subid);
+			if (!vstd::contains(customObjects, key))
+			{
+				customObjects[key] = object;
+			}
+		}
+	}
+	*/
+	auto bannedObjectCategories = zone.getBannedObjectCategories();
+	auto categoriesSet = std::unordered_set<ObjectConfig::EObjectCategory>(bannedObjectCategories.begin(), bannedObjectCategories.end());
+
+	if (categoriesSet.count(ObjectConfig::EObjectCategory::ALL))
+	{
+		possibleObjects.clear();
+	}
+	else
+	{
+		vstd::erase_if(possibleObjects, [this, &categoriesSet](const ObjectInfo & oi) -> bool
+
+		{
+			auto category = getObjectCategory(oi.getCompoundID());
+			if (categoriesSet.count(category))
+			{
+				logGlobal->info("Removing object %s from possible objects", oi.templates.front()->stringID);
+				return true;
+			}
+			return false;
+		});
+
+		auto bannedObjects = zone.getBannedObjects();
+		auto bannedObjectsSet = std::set<CompoundMapObjectID>(bannedObjects.begin(), bannedObjects.end());
+		vstd::erase_if(possibleObjects, [&bannedObjectsSet](const ObjectInfo & object)
+		{
+			for (const auto & templ : object.templates)
+			{
+				CompoundMapObjectID key = object.getCompoundID();
+				if (bannedObjectsSet.count(key))
+				{
+					// FIXME: Stopped working, nothing is banned
+					logGlobal->info("Banning object %s from possible objects", templ->stringID);
+					return true;
+				}
+			}
+			return false;
+		});
+	}
+
+	auto configuredObjects = zone.getConfiguredObjects();
+
+	// FIXME: Access TreasurePlacer from ObjectPool
+	for (auto & object : configuredObjects)
+	{
+		tp->setBasicProperties(object, object.getCompoundID());
+		addObject(object);
+		logGlobal->info("Added custom object of type %d.%d", object.primaryID, object.secondaryID);
+	}
+	// TODO: Overwrite or add to possibleObjects
+
+	// FIXME: Protect with mutex as well?
+	/*
+	for (const auto & customObject : customObjects)
+	{
+		addObject(customObject.second);
+	}
+	*/
+	// TODO: Consider adding custom Pandora boxes with arbitrary content
+}
+
+std::vector<ObjectInfo> & TreasurePlacer::ObjectPool::getPossibleObjects()
+{
+	return possibleObjects;
+}
+
+void TreasurePlacer::ObjectPool::sortPossibleObjects()
+{
+	boost::sort(possibleObjects, [](const ObjectInfo& oi1, const ObjectInfo& oi2) -> bool
+	{
+		return oi1.value < oi2.value;
+	});
+}
+
+void TreasurePlacer::ObjectPool::discardObjectsAboveValue(ui32 value)
+{
+	vstd::erase_if(possibleObjects, [value](const ObjectInfo& oi) -> bool
+	{
+		return oi.value > value;
+	});
+}
+
+ObjectConfig::EObjectCategory TreasurePlacer::ObjectPool::getObjectCategory(CompoundMapObjectID id)
+{
+	auto name = VLC->objtypeh->getObjectHandlerName(id.primaryID);
+
+	if (name == "configurable")
+	{
+		auto handler = VLC->objtypeh->getHandlerFor(id.primaryID, id.secondaryID);
+		if (!handler)
+		{
+			return ObjectConfig::EObjectCategory::NONE;
+		}
+
+		auto temp = handler->getTemplates().front();
+		auto info = handler->getObjectInfo(temp);
+
+		if (info->hasGuards())
+		{
+			return ObjectConfig::EObjectCategory::CREATURE_BANK;
+		}
+		else if (info->givesResources())
+		{
+			return ObjectConfig::EObjectCategory::RESOURCE;
+		}
+		else if (info->givesArtifacts())
+		{
+			return ObjectConfig::EObjectCategory::RANDOM_ARTIFACT;
+		}
+		else if (info->givesBonuses())
+		{
+			return ObjectConfig::EObjectCategory::BONUS;
+		}
+
+		return ObjectConfig::EObjectCategory::OTHER;
+	}
+	else if (name == "dwelling" || name == "randomDwelling")
+	{
+		// TODO: Special handling for different tiers
+		return ObjectConfig::EObjectCategory::DWELLING;
+	}
+	else if (name == "bank")
+		return ObjectConfig::EObjectCategory::CREATURE_BANK;
+	else if (name == "market")
+		return ObjectConfig::EObjectCategory::OTHER;
+	else if (name == "hillFort")
+		return ObjectConfig::EObjectCategory::OTHER;
+	else if (name == "resource" || name == "randomResource")
+		return ObjectConfig::EObjectCategory::RESOURCE;
+	else if (name == "randomArtifact") //"artifact"
+		return ObjectConfig::EObjectCategory::RANDOM_ARTIFACT;
+	else if (name == "artifact")
+	{
+		if (id.primaryID == Obj::SPELL_SCROLL ) // randomArtifactTreasure
+		{
+			return ObjectConfig::EObjectCategory::SPELL_SCROLL;
+		}
+		else
+		{
+			return ObjectConfig::EObjectCategory::QUEST_ARTIFACT;
+		}
+	}
+	else if (name == "denOfThieves")
+		return ObjectConfig::EObjectCategory::OTHER;
+	else if (name == "lighthouse")
+	{
+		return ObjectConfig::EObjectCategory::BONUS;
+	}
+	else if (name == "magi")
+	{
+		// TODO: By default, both eye and hut are banned in every zone
+		return ObjectConfig::EObjectCategory::OTHER;
+	}
+	else if (name == "mine")
+		return ObjectConfig::EObjectCategory::RESOURCE_GENERATOR;
+	else if (name == "pandora")
+		return ObjectConfig::EObjectCategory::PANDORAS_BOX;
+	else if (name == "prison")
+	{
+		// TODO: Prisons should be configurable
+		return ObjectConfig::EObjectCategory::OTHER;
+	}
+	else if (name == "questArtifact")
+	{
+		// TODO: There are no dedicated quest artifacts, needs extra logic
+		return ObjectConfig::EObjectCategory::QUEST_ARTIFACT;
+	}
+	else if (name == "seerHut")
+	{
+		return ObjectConfig::EObjectCategory::SEER_HUT;
+	}
+	else if (name == "siren")
+		return ObjectConfig::EObjectCategory::BONUS;
+	else if (name == "obelisk")
+		return ObjectConfig::EObjectCategory::OTHER;
+
+	// TODO: ObjectConfig::EObjectCategory::SPELL_SCROLL
+
+	// Not interesting for us
+	return ObjectConfig::EObjectCategory::NONE;
 }
 
 VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/rmg/modificators/TreasurePlacer.h vcmi/lib/rmg/modificators/TreasurePlacer.h
--- vcmi-1.5.7/lib/rmg/modificators/TreasurePlacer.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/rmg/modificators/TreasurePlacer.h	2024-12-19 15:00:22.934149425 +0100
@@ -9,6 +9,8 @@
  */
 
 #pragma once
+
+#include "../ObjectInfo.h"
 #include "../Zone.h"
 #include "../../mapObjects/ObjectTemplate.h"
 
@@ -18,22 +20,7 @@
 class ObjectManager;
 class RmgMap;
 class CMapGenerator;
-class CRandomGenerator;
-
-struct ObjectInfo
-{
-	ObjectInfo();
-
-	std::vector<std::shared_ptr<const ObjectTemplate>> templates;
-	ui32 value = 0;
-	ui16 probability = 0;
-	ui32 maxPerZone = 1;
-	//ui32 maxPerMap; //unused
-	std::function<CGObjectInstance *()> generateObject;
-	std::function<void(CGObjectInstance *)> destroyObject;
-	
-	void setTemplates(MapObjectID type, MapObjectSubID subtype, TerrainId terrain);
-};
+class ObjectConfig;
 
 class TreasurePlacer: public Modificator
 {
@@ -46,11 +33,27 @@
 	
 	void createTreasures(ObjectManager & manager);
 	void addObjectToRandomPool(const ObjectInfo& oi);
+	void setBasicProperties(ObjectInfo & oi, CompoundMapObjectID objid) const;
+
+	// TODO: Can be defaulted to addAllPossibleObjects, but then each object will need to be configured
+	void addCommonObjects();
+	void addDwellings();
+	void addPandoraBoxes();
+	void addPandoraBoxesWithGold();
+	void addPandoraBoxesWithExperience();
+	void addPandoraBoxesWithCreatures();
+	void addPandoraBoxesWithSpells();
+	void addSeerHuts();
+	void addPrisons();
+	void addScrolls();
 	void addAllPossibleObjects(); //add objects, including zone-specific, to possibleObjects
+	// TODO: Read custom object config from zone file
+
+	/// Get all objects for this terrain
 
-	size_t getPossibleObjectsSize() const;
 	void setMaxPrisons(size_t count);
 	size_t getMaxPrisons() const;
+	int creatureToCount(const CCreature * creature) const;
 	
 protected:
 	bool isGuardNeededForTreasure(int value);
@@ -60,7 +63,26 @@
 	rmg::Object constructTreasurePile(const std::vector<ObjectInfo*> & treasureInfos, bool densePlacement = false);
 
 protected:
-	std::vector<ObjectInfo> possibleObjects;
+	class ObjectPool
+	{
+	public:
+		void addObject(const ObjectInfo & info);
+		void updateObject(MapObjectID id, MapObjectSubID subid, ObjectInfo info);
+		std::vector<ObjectInfo> & getPossibleObjects();
+		void patchWithZoneConfig(const Zone & zone, TreasurePlacer * tp);
+		void sortPossibleObjects();
+		void discardObjectsAboveValue(ui32 value);
+
+		ObjectConfig::EObjectCategory getObjectCategory(CompoundMapObjectID id);
+
+	private:
+
+		std::vector<ObjectInfo> possibleObjects;
+		std::map<CompoundMapObjectID, ObjectInfo> customObjects;
+
+	} objects;
+	// TODO: Need to nagivate and update these
+
 	int minGuardedValue = 0;
 	
 	rmg::Area treasureArea;
@@ -68,6 +90,9 @@
 	rmg::Area guards;
 
 	size_t maxPrisons;
+
+	std::vector<const CCreature *> creatures; //native creatures for this zone
+	std::vector<int> tierValues;
 };
 
 VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/rmg/modificators/WaterAdopter.cpp vcmi/lib/rmg/modificators/WaterAdopter.cpp
--- vcmi-1.5.7/lib/rmg/modificators/WaterAdopter.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/rmg/modificators/WaterAdopter.cpp	2024-12-19 15:00:22.934149425 +0100
@@ -23,6 +23,8 @@
 #include "ConnectionsPlacer.h"
 #include "../TileInfo.h"
 
+#include <vstd/RNG.h>
+
 VCMI_LIB_NAMESPACE_BEGIN
 
 void WaterAdopter::process()
@@ -133,13 +135,13 @@
 	
 	waterArea.subtract(noWaterArea);
 	
-	//start filtering of narrow places and coast atrifacts
+	//start filtering of narrow places and coast artifacts
 	rmg::Area waterAdd;
 	for(int coastId = 1; coastId <= coastIdMax; ++coastId)
 	{
 		for(const auto & tile : reverseDistanceMap[coastId])
 		{
-			//collect neighbout water tiles
+			//collect neighbour water tiles
 			auto collectionLambda = [this](const int3 & t, std::set<int3> & outCollection)
 			{
 				if(waterArea.contains(t))
diff --color -urN vcmi-1.5.7/lib/rmg/modificators/WaterProxy.cpp vcmi/lib/rmg/modificators/WaterProxy.cpp
--- vcmi-1.5.7/lib/rmg/modificators/WaterProxy.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/rmg/modificators/WaterProxy.cpp	2024-12-19 15:00:22.934149425 +0100
@@ -30,6 +30,8 @@
 #include "WaterAdopter.h"
 #include "../RmgArea.h"
 
+#include <vstd/RNG.h>
+
 VCMI_LIB_NAMESPACE_BEGIN
 
 void WaterProxy::process()
@@ -49,7 +51,7 @@
 	for([[maybe_unused]] const auto & t : area->getTilesVector())
 	{
 		assert(map.isOnMap(t));
-		assert(map.getTile(t).terType->getId() == zone.getTerrainType());
+		assert(map.getTile(t).getTerrainID() == zone.getTerrainType());
 	}
 
 	// FIXME: Possible deadlock for 2 zones
@@ -64,7 +66,7 @@
 		auto secondAreaPossible = z.second->areaPossible();
 		for(const auto & t : secondArea->getTilesVector())
 		{
-			if(map.getTile(t).terType->getId() == zone.getTerrainType())
+			if(map.getTile(t).getTerrainID() == zone.getTerrainType())
 			{
 				secondArea->erase(t);
 				secondAreaPossible->erase(t);
@@ -264,9 +266,9 @@
 	rmg::Object rmgObject(*boat);
 	rmgObject.setTemplate(zone.getTerrainType(), zone.getRand());
 
-	auto waterAvailable = zone.areaPossible() + zone.freePaths();
+	auto waterAvailable = zone.areaForRoads();
 	rmg::Area coast = lake.neighbourZones.at(land.getId()); //having land tiles
-	coast.intersect(land.areaPossible() + land.freePaths()); //having only available land tiles
+	coast.intersect(land.areaForRoads()); //having only available land tiles
 	auto boardingPositions = coast.getSubarea([&waterAvailable, this](const int3 & tile) //tiles where boarding is possible
 		{
 			//We don't want place boat right to any land object, especiallly the zone guard
@@ -330,10 +332,10 @@
 	rmgObject.setTemplate(land.getTerrainType(), zone.getRand());
 	bool guarded = manager->addGuard(rmgObject, guard);
 	
-	auto waterAvailable = zone.areaPossible() + zone.freePaths();
+	auto waterAvailable = zone.areaForRoads();
 	waterAvailable.intersect(lake.area);
 	rmg::Area coast = lake.neighbourZones.at(land.getId()); //having land tiles
-	coast.intersect(land.areaPossible() + land.freePaths()); //having only available land tiles
+	coast.intersect(land.areaForRoads()); //having only available land tiles
 	auto boardingPositions = coast.getSubarea([&waterAvailable](const int3 & tile) //tiles where boarding is possible
 	{
 		rmg::Area a({tile});
diff --color -urN vcmi-1.5.7/lib/rmg/ObjectConfig.cpp vcmi/lib/rmg/ObjectConfig.cpp
--- vcmi-1.5.7/lib/rmg/ObjectConfig.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/rmg/ObjectConfig.cpp	2024-12-19 15:00:22.929149219 +0100
@@ -0,0 +1,189 @@
+/*
+ * ObjectConfig.cpp, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+
+#include "StdInc.h"
+#include <boost/bimap.hpp>
+#include <boost/assign.hpp>
+#include "ObjectInfo.h"
+#include "ObjectConfig.h"
+
+#include "../VCMI_Lib.h"
+#include "../mapObjectConstructors/CObjectClassesHandler.h"
+#include "../mapObjectConstructors/AObjectTypeHandler.h"
+#include "../serializer/JsonSerializeFormat.h"
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+void ObjectConfig::addBannedObject(const CompoundMapObjectID & objid)
+{
+	// FIXME: We do not need to store the object info, just the id
+
+	bannedObjects.push_back(objid);
+
+	logGlobal->info("Banned object of type %d.%d", objid.primaryID, objid.secondaryID);
+}
+
+void ObjectConfig::addCustomObject(const ObjectInfo & object, const CompoundMapObjectID & objid)
+{
+	customObjects.push_back(object);
+	auto & lastObject = customObjects.back();
+	lastObject.setAllTemplates(objid.primaryID, objid.secondaryID);
+
+	assert(lastObject.templates.size() > 0);
+	logGlobal->info("Added custom object of type %d.%d", objid.primaryID, objid.secondaryID);
+}
+
+void ObjectConfig::serializeJson(JsonSerializeFormat & handler)
+{
+	// TODO: We need serializer utility for list of enum values
+
+	static const boost::bimap<EObjectCategory, std::string> OBJECT_CATEGORY_STRINGS = boost::assign::list_of<boost::bimap<EObjectCategory, std::string>::relation>
+		(EObjectCategory::OTHER, "other")
+		(EObjectCategory::ALL, "all")
+		(EObjectCategory::NONE, "none")
+		(EObjectCategory::CREATURE_BANK, "creatureBank")
+		(EObjectCategory::BONUS, "bonus")
+		(EObjectCategory::DWELLING, "dwelling")
+		(EObjectCategory::RESOURCE, "resource")
+		(EObjectCategory::RESOURCE_GENERATOR, "resourceGenerator")
+		(EObjectCategory::SPELL_SCROLL, "spellScroll")
+		(EObjectCategory::RANDOM_ARTIFACT, "randomArtifact")
+		(EObjectCategory::PANDORAS_BOX, "pandorasBox")
+		(EObjectCategory::QUEST_ARTIFACT, "questArtifact")
+		(EObjectCategory::SEER_HUT, "seerHut");
+
+
+	// TODO: Separate into individual methods to enforce RAII destruction?
+	{
+		auto categories = handler.enterArray("bannedCategories");
+		if (handler.saving)
+		{
+			for (const auto& category : bannedObjectCategories)
+			{
+				auto str = OBJECT_CATEGORY_STRINGS.left.at(category);
+				categories.serializeString(categories.size(), str);
+			}
+		}
+		else
+		{
+			std::vector<std::string> categoryNames;
+			categories.serializeArray(categoryNames);
+
+			for (const auto & categoryName : categoryNames)
+			{
+				auto it = OBJECT_CATEGORY_STRINGS.right.find(categoryName);
+				if (it != OBJECT_CATEGORY_STRINGS.right.end())
+				{
+					bannedObjectCategories.push_back(it->second);
+				}
+			}
+		}
+	}
+
+	// FIXME: Doesn't seem to use this field at all
+	
+	{
+		auto bannedObjectData = handler.enterArray("bannedObjects");	
+		if (handler.saving)
+		{
+
+			// FIXME: Do we even need to serialize / store banned objects?
+			/*
+			for (const auto & object : bannedObjects)
+			{
+				// TODO: Translate id back to string?
+
+
+				JsonNode node;
+				node.String() = VLC->objtypeh->getHandlerFor(object.primaryID, object.secondaryID);
+				// TODO: Check if AI-generated code is right
+
+
+			}
+			// handler.serializeRaw("bannedObjects", node, std::nullopt);
+
+			*/
+		}
+		else
+		{
+			std::vector<std::string> objectNames;
+			bannedObjectData.serializeArray(objectNames);
+
+			for (const auto & objectName : objectNames)
+			{
+				VLC->objtypeh->resolveObjectCompoundId(objectName,
+					[this](CompoundMapObjectID objid)
+					{
+						addBannedObject(objid);
+					}
+				);
+				
+			}
+		}
+	}
+
+	auto commonObjectData = handler.getCurrent()["commonObjects"].Vector();	
+	if (handler.saving)
+	{
+
+		//TODO?
+	}
+	else
+	{
+		for (const auto & objectConfig : commonObjectData)
+		{
+			auto objectName = objectConfig["id"].String();
+			auto rmg = objectConfig["rmg"].Struct();
+
+			// TODO: Use common code with default rmg config
+			auto objectValue = rmg["value"].Integer();
+			auto objectProbability = rmg["rarity"].Integer();
+
+			auto objectMaxPerZone = rmg["zoneLimit"].Integer();
+			if (objectMaxPerZone == 0)
+			{
+				objectMaxPerZone = std::numeric_limits<int>::max();
+			}
+
+			VLC->objtypeh->resolveObjectCompoundId(objectName,
+
+				[this, objectValue, objectProbability, objectMaxPerZone](CompoundMapObjectID objid)
+				{
+					ObjectInfo object(objid.primaryID, objid.secondaryID);
+					
+					// TODO: Configure basic generateObject function
+
+					object.value = objectValue;
+					object.probability = objectProbability;
+					object.maxPerZone = objectMaxPerZone;
+					addCustomObject(object, objid);
+				}
+			);
+			
+		}
+	}
+}
+
+const std::vector<ObjectInfo> & ObjectConfig::getConfiguredObjects() const
+{
+	return customObjects;
+}
+
+const std::vector<CompoundMapObjectID> & ObjectConfig::getBannedObjects() const
+{
+	return bannedObjects;
+}
+
+const std::vector<ObjectConfig::EObjectCategory> & ObjectConfig::getBannedObjectCategories() const
+{
+	return bannedObjectCategories;
+}
+
+VCMI_LIB_NAMESPACE_END
\ No newline at end of file
diff --color -urN vcmi-1.5.7/lib/rmg/ObjectConfig.h vcmi/lib/rmg/ObjectConfig.h
--- vcmi-1.5.7/lib/rmg/ObjectConfig.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/rmg/ObjectConfig.h	2024-12-19 15:00:22.929149219 +0100
@@ -0,0 +1,57 @@
+/*
+ * ObjectInfo.h, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+
+#pragma once
+
+#include "../mapObjects/CompoundMapObjectID.h"
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+class DLL_LINKAGE ObjectConfig
+{
+public:
+
+	enum class EObjectCategory
+	{
+		OTHER = -2,
+		ALL = -1,
+		NONE = 0,
+		CREATURE_BANK = 1,
+		BONUS,
+		DWELLING,
+		RESOURCE,
+		RESOURCE_GENERATOR,
+		SPELL_SCROLL,
+		RANDOM_ARTIFACT,
+		PANDORAS_BOX,
+		QUEST_ARTIFACT,
+		SEER_HUT
+	};
+
+	void addBannedObject(const CompoundMapObjectID & objid);
+	void addCustomObject(const ObjectInfo & object, const CompoundMapObjectID & objid);
+	void clearBannedObjects();
+	void clearCustomObjects();
+	const std::vector<CompoundMapObjectID> & getBannedObjects() const;
+	const std::vector<EObjectCategory> & getBannedObjectCategories() const;
+	const std::vector<ObjectInfo> & getConfiguredObjects() const;
+
+	void serializeJson(JsonSerializeFormat & handler);
+private:
+	// TODO: Add convenience method for banning objects by name
+	std::vector<CompoundMapObjectID> bannedObjects;
+	std::vector<EObjectCategory> bannedObjectCategories;
+
+	// TODO: In what format should I store custom objects?
+	// Need to convert map serialization format to ObjectInfo
+	std::vector<ObjectInfo> customObjects;
+};
+
+VCMI_LIB_NAMESPACE_END
\ No newline at end of file
diff --color -urN vcmi-1.5.7/lib/rmg/ObjectInfo.cpp vcmi/lib/rmg/ObjectInfo.cpp
--- vcmi-1.5.7/lib/rmg/ObjectInfo.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/rmg/ObjectInfo.cpp	2024-12-19 15:00:22.929149219 +0100
@@ -0,0 +1,85 @@
+/*
+ * ObjectInfo.cpp, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+
+#include "StdInc.h"
+#include "ObjectInfo.h"
+
+#include "../VCMI_Lib.h"
+#include "../mapObjectConstructors/CObjectClassesHandler.h"
+#include "../mapObjectConstructors/AObjectTypeHandler.h"
+#include "../serializer/JsonSerializeFormat.h"
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+ObjectInfo::ObjectInfo(si32 ID, si32 subID):
+	primaryID(ID),
+	secondaryID(subID),
+	destroyObject([](CGObjectInstance * obj){}),
+	maxPerZone(std::numeric_limits<ui32>::max())
+{
+}
+
+ObjectInfo::ObjectInfo(CompoundMapObjectID id):
+	ObjectInfo(id.primaryID, id.secondaryID)
+{
+}
+
+ObjectInfo::ObjectInfo(const ObjectInfo & other)
+{
+	templates = other.templates;
+	primaryID = other.primaryID;
+	secondaryID = other.secondaryID;
+	value = other.value;
+	probability = other.probability;
+	maxPerZone = other.maxPerZone;
+	generateObject = other.generateObject;
+	destroyObject = other.destroyObject;
+}
+
+ObjectInfo & ObjectInfo::operator=(const ObjectInfo & other)
+{
+	if (this == &other)
+		return *this;
+
+	templates = other.templates;
+	primaryID = other.primaryID;
+	secondaryID = other.secondaryID;
+	value = other.value;
+	probability = other.probability;
+	maxPerZone = other.maxPerZone;
+	generateObject = other.generateObject;
+	destroyObject = other.destroyObject;
+	return *this;
+}
+
+void ObjectInfo::setAllTemplates(MapObjectID type, MapObjectSubID subtype)
+{
+	auto templHandler = VLC->objtypeh->getHandlerFor(type, subtype);
+	if(!templHandler)
+		return;
+	
+	templates = templHandler->getTemplates();
+}
+
+void ObjectInfo::setTemplates(MapObjectID type, MapObjectSubID subtype, TerrainId terrainType)
+{
+	auto templHandler = VLC->objtypeh->getHandlerFor(type, subtype);
+	if(!templHandler)
+		return;
+	
+	templates = templHandler->getTemplates(terrainType);
+}
+
+CompoundMapObjectID ObjectInfo::getCompoundID() const
+{
+	return CompoundMapObjectID(primaryID, secondaryID);
+}
+
+VCMI_LIB_NAMESPACE_END
\ No newline at end of file
diff --color -urN vcmi-1.5.7/lib/rmg/ObjectInfo.h vcmi/lib/rmg/ObjectInfo.h
--- vcmi-1.5.7/lib/rmg/ObjectInfo.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/rmg/ObjectInfo.h	2024-12-19 15:00:22.929149219 +0100
@@ -0,0 +1,45 @@
+/*
+ * ObjectInfo.h, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+
+#pragma once
+
+#include "../mapObjects/ObjectTemplate.h"
+#include "../mapObjects/CompoundMapObjectID.h"
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+struct CompoundMapObjectID;
+class CGObjectInstance;
+
+struct DLL_LINKAGE ObjectInfo
+{
+	ObjectInfo(si32 ID, si32 subID);
+	ObjectInfo(CompoundMapObjectID id);
+	ObjectInfo(const ObjectInfo & other);
+	ObjectInfo & operator=(const ObjectInfo & other);
+
+	std::vector<std::shared_ptr<const ObjectTemplate>> templates;
+	si32 primaryID;
+	si32 secondaryID;
+	ui32 value = 0;
+	ui16 probability = 0;
+	ui32 maxPerZone = 1;
+	//ui32 maxPerMap; //unused
+	std::function<CGObjectInstance *()> generateObject;
+	std::function<void(CGObjectInstance *)> destroyObject;
+	
+	void setAllTemplates(MapObjectID type, MapObjectSubID subtype);
+	void setTemplates(MapObjectID type, MapObjectSubID subtype, TerrainId terrain);
+
+	CompoundMapObjectID getCompoundID() const;
+	//bool matchesId(const CompoundMapObjectID & id) const;
+};
+
+VCMI_LIB_NAMESPACE_END
\ No newline at end of file
diff --color -urN vcmi-1.5.7/lib/rmg/PenroseTiling.cpp vcmi/lib/rmg/PenroseTiling.cpp
--- vcmi-1.5.7/lib/rmg/PenroseTiling.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/rmg/PenroseTiling.cpp	2024-12-19 15:00:22.929149219 +0100
@@ -13,6 +13,8 @@
 #include "StdInc.h"
 #include "PenroseTiling.h"
 
+#include <vstd/RNG.h>
+
 VCMI_LIB_NAMESPACE_BEGIN
 
 
@@ -143,7 +145,7 @@
 	return;
 }
 
-std::set<Point2D> PenroseTiling::generatePenroseTiling(size_t numZones, CRandomGenerator * rand)
+std::set<Point2D> PenroseTiling::generatePenroseTiling(size_t numZones, vstd::RNG * rand)
 {
 	float scale = 173.2f / (numZones * 1.5f + 20);
 	float polyAngle = (2 * PI_CONSTANT) / POLY;
@@ -181,7 +183,7 @@
 	for (auto & point : points)
 	{
 		point = point + Point2D(0.5f, 0.5f);
-	};
+	}
 
 	// For 8XM8 map, only 650 out of 15971 points are in the range
 
@@ -193,4 +195,4 @@
 	return finalPoints;
 }
 
-VCMI_LIB_NAMESPACE_END
\ No newline at end of file
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/rmg/PenroseTiling.h vcmi/lib/rmg/PenroseTiling.h
--- vcmi-1.5.7/lib/rmg/PenroseTiling.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/rmg/PenroseTiling.h	2024-12-19 15:00:22.929149219 +0100
@@ -11,12 +11,16 @@
 #pragma once
 
 #include "../GameConstants.h"
-#include "../CRandomGenerator.h"
 #include <boost/geometry.hpp>
 #include <boost/geometry/geometries/point_xy.hpp>
 
 VCMI_LIB_NAMESPACE_BEGIN
 
+namespace vstd
+{
+class RNG;
+}
+
 using namespace boost::geometry;
 typedef std::array<uint32_t, 3> TIndices;
 
@@ -66,11 +70,11 @@
 	
 	const bool P2 = false; // Tiling type
 
-	std::set<Point2D> generatePenroseTiling(size_t numZones, CRandomGenerator * rand);
+	std::set<Point2D> generatePenroseTiling(size_t numZones, vstd::RNG * rand);
 
 private:
 	void split(Triangle& p, std::vector<Point2D>& points, std::array<std::vector<uint32_t>, 5>& indices, uint32_t depth); 
 
 };
 
-VCMI_LIB_NAMESPACE_END
\ No newline at end of file
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/rmg/RmgArea.h vcmi/lib/rmg/RmgArea.h
--- vcmi-1.5.7/lib/rmg/RmgArea.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/rmg/RmgArea.h	2024-12-19 15:00:22.929149219 +0100
@@ -58,7 +58,7 @@
 		int3 nearest(const Area & area) const;
 		
 		void clear();
-		void assign(const Tileset tiles); //do not use reference to allow assigment of cached data
+		void assign(const Tileset tiles); //do not use reference to allow assignment of cached data
 		void add(const int3 & tile);
 		void erase(const int3 & tile);
 		void unite(const Area & area);
diff --color -urN vcmi-1.5.7/lib/rmg/RmgMap.cpp vcmi/lib/rmg/RmgMap.cpp
--- vcmi-1.5.7/lib/rmg/RmgMap.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/rmg/RmgMap.cpp	2024-12-19 15:00:22.929149219 +0100
@@ -13,9 +13,10 @@
 #include "TileInfo.h"
 #include "CMapGenOptions.h"
 #include "Zone.h"
+#include "../entities/faction/CTownHandler.h"
 #include "../mapping/CMapEditManager.h"
 #include "../mapping/CMap.h"
-#include "../CTownHandler.h"
+#include "../VCMI_Lib.h"
 #include "modificators/ObjectManager.h"
 #include "modificators/RoadPlacer.h"
 #include "modificators/TreasurePlacer.h"
@@ -83,7 +84,7 @@
 	}
 }
 
-void RmgMap::initTiles(CMapGenerator & generator, CRandomGenerator & rand)
+void RmgMap::initTiles(CMapGenerator & generator, vstd::RNG & rand)
 {
 	mapInstance->initTerrain();
 	
diff --color -urN vcmi-1.5.7/lib/rmg/RmgMap.h vcmi/lib/rmg/RmgMap.h
--- vcmi-1.5.7/lib/rmg/RmgMap.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/rmg/RmgMap.h	2024-12-19 15:00:22.929149219 +0100
@@ -17,7 +17,6 @@
 
 class CMap;
 class CMapEditManager;
-class CRandomGenerator;
 class TileInfo;
 class CMapGenOptions;
 class Zone;
@@ -25,6 +24,11 @@
 class MapProxy;
 class playerInfo;
 
+namespace vstd
+{
+class RNG;
+}
+
 class RmgMap
 {
 public:
@@ -79,7 +83,7 @@
 	void registerZone(FactionID faction);
 	ui32 getZoneCount(FactionID faction);
 	ui32 getTotalZoneCount() const;
-	void initTiles(CMapGenerator & generator, CRandomGenerator & rand);
+	void initTiles(CMapGenerator & generator, vstd::RNG & rand);
 	void addModificators();
 
 	bool isAllowedSpell(const SpellID & sid) const;
diff --color -urN vcmi-1.5.7/lib/rmg/RmgObject.cpp vcmi/lib/rmg/RmgObject.cpp
--- vcmi-1.5.7/lib/rmg/RmgObject.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/rmg/RmgObject.cpp	2024-12-19 15:00:22.930149260 +0100
@@ -21,6 +21,8 @@
 #include "Functions.h"
 #include "../TerrainHandler.h"
 
+#include <vstd/RNG.h>
+
 VCMI_LIB_NAMESPACE_BEGIN
 
 using namespace rmg;
@@ -85,7 +87,7 @@
 void Object::Instance::setPosition(const int3 & position)
 {
 	dPosition = position;
-	dObject.pos = dPosition + dParent.getPosition();
+	dObject.setAnchorPos(dPosition + dParent.getPosition());
 	
 	dBlockedAreaCache.clear();
 	dAccessibleAreaCache.clear();
@@ -94,24 +96,24 @@
 
 void Object::Instance::setPositionRaw(const int3 & position)
 {
-	if(!dObject.pos.valid())
+	if(!dObject.anchorPos().valid())
 	{
-		dObject.pos = dPosition + dParent.getPosition();
+		dObject.setAnchorPos(dPosition + dParent.getPosition());
 		dBlockedAreaCache.clear();
 		dAccessibleAreaCache.clear();
 		dParent.clearCachedArea();
 	}
 		
-	auto shift = position + dParent.getPosition() - dObject.pos;
+	auto shift = position + dParent.getPosition() - dObject.anchorPos();
 	
 	dAccessibleAreaCache.translate(shift);
 	dBlockedAreaCache.translate(shift);
 	
 	dPosition = position;
-	dObject.pos = dPosition + dParent.getPosition();
+	dObject.setAnchorPos(dPosition + dParent.getPosition());
 }
 
-void Object::Instance::setAnyTemplate(CRandomGenerator & rng)
+void Object::Instance::setAnyTemplate(vstd::RNG & rng)
 {
 	auto templates = dObject.getObjectHandler()->getTemplates();
 	if(templates.empty())
@@ -122,7 +124,7 @@
 	setPosition(getPosition(false));
 }
 
-void Object::Instance::setTemplate(TerrainId terrain, CRandomGenerator & rng)
+void Object::Instance::setTemplate(TerrainId terrain, vstd::RNG & rng)
 {
 	auto templates = dObject.getObjectHandler()->getMostSpecificTemplates(terrain);
 
@@ -326,7 +328,7 @@
 	{
 		for(const auto & i : dInstances)
 		{
-			// FIXME: Account for bjects with multiple visitable tiles
+			// FIXME: Account for objects with multiple visitable tiles
 			dVisitableCache.add(i.getVisitablePosition());
 		}
 	}
@@ -366,7 +368,7 @@
 		i.setPositionRaw(i.getPosition());
 }
 
-void Object::setTemplate(const TerrainId & terrain, CRandomGenerator & rng)
+void Object::setTemplate(const TerrainId & terrain, vstd::RNG & rng)
 {
 	for(auto& i : dInstances)
 		i.setTemplate(terrain, rng);
@@ -474,7 +476,7 @@
 	return borderAbove;
 }
 
-void Object::Instance::finalize(RmgMap & map, CRandomGenerator & rng)
+void Object::Instance::finalize(RmgMap & map, vstd::RNG & rng)
 {
 	if(!map.isOnMap(getPosition(true)))
 		throw rmgException(boost::str(boost::format("Position of object %d at %s is outside the map") % dObject.id % getPosition(true).toString()));
@@ -482,7 +484,7 @@
 	//If no specific template was defined for this object, select any matching
 	if (!dObject.appearance)
 	{
-		const auto * terrainType = map.getTile(getPosition(true)).terType;
+		const auto * terrainType = map.getTile(getPosition(true)).getTerrain();
 		auto templates = dObject.getObjectHandler()->getTemplates(terrainType->getId());
 		if (templates.empty())
 		{
@@ -495,12 +497,12 @@
 	}
 
 	if (dObject.isVisitable() && !map.isOnMap(dObject.visitablePos()))
-		throw rmgException(boost::str(boost::format("Visitable tile %s of object %d at %s is outside the map") % dObject.visitablePos().toString() % dObject.id % dObject.pos.toString()));
+		throw rmgException(boost::str(boost::format("Visitable tile %s of object %d at %s is outside the map") % dObject.visitablePos().toString() % dObject.id % dObject.anchorPos().toString()));
 
 	for(const auto & tile : dObject.getBlockedPos())
 	{
 		if(!map.isOnMap(tile))
-			throw rmgException(boost::str(boost::format("Tile %s of object %d at %s is outside the map") % tile.toString() % dObject.id % dObject.pos.toString()));
+			throw rmgException(boost::str(boost::format("Tile %s of object %d at %s is outside the map") % tile.toString() % dObject.id % dObject.anchorPos().toString()));
 	}
 
 	for(const auto & tile : getBlockedArea().getTilesVector())
@@ -511,7 +513,7 @@
 	map.getMapProxy()->insertObject(&dObject);
 }
 
-void Object::finalize(RmgMap & map, CRandomGenerator & rng)
+void Object::finalize(RmgMap & map, vstd::RNG & rng)
 {
 	if(dInstances.empty())
 		throw rmgException("Cannot finalize object without instances");
diff --color -urN vcmi-1.5.7/lib/rmg/RmgObject.h vcmi/lib/rmg/RmgObject.h
--- vcmi-1.5.7/lib/rmg/RmgObject.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/rmg/RmgObject.h	2024-12-19 15:00:22.930149260 +0100
@@ -16,8 +16,12 @@
 
 VCMI_LIB_NAMESPACE_BEGIN
 
+namespace vstd
+{
+class RNG;
+}
+
 class CGObjectInstance;
-class CRandomGenerator;
 class RmgMap;
 
 namespace rmg {
@@ -39,8 +43,8 @@
 		bool isRemovable() const;
 		const Area & getAccessibleArea() const;
 		Area getBorderAbove() const;
-		void setTemplate(TerrainId terrain, CRandomGenerator &); //cache invalidation
-		void setAnyTemplate(CRandomGenerator &); //cache invalidation
+		void setTemplate(TerrainId terrain, vstd::RNG &); //cache invalidation
+		void setAnyTemplate(vstd::RNG &); //cache invalidation
 		
 		int3 getTopTile() const;
 		int3 getPosition(bool isAbsolute = false) const;
@@ -49,7 +53,7 @@
 		const CGObjectInstance & object() const;
 		CGObjectInstance & object();
 		
-		void finalize(RmgMap & map, CRandomGenerator &); //cache invalidation
+		void finalize(RmgMap & map, vstd::RNG &); //cache invalidation
 		void clear();
 		
 		std::function<void(CGObjectInstance *)> onCleared;
@@ -83,7 +87,7 @@
 	
 	const int3 & getPosition() const;
 	void setPosition(const int3 & position);
-	void setTemplate(const TerrainId & terrain, CRandomGenerator &);
+	void setTemplate(const TerrainId & terrain, vstd::RNG &);
 	
 	const Area & getArea() const;  //lazy cache invalidation
 	const int3 getVisibleTop() const;
@@ -94,7 +98,7 @@
 	void setValue(uint32_t value);
 	uint32_t getValue() const;
 	
-	void finalize(RmgMap & map, CRandomGenerator &);
+	void finalize(RmgMap & map, vstd::RNG &);
 	void clearCachedArea() const;
 	void clear();
 	
diff --color -urN vcmi-1.5.7/lib/rmg/RmgPath.cpp vcmi/lib/rmg/RmgPath.cpp
--- vcmi-1.5.7/lib/rmg/RmgPath.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/rmg/RmgPath.cpp	2024-12-19 15:00:22.930149260 +0100
@@ -116,8 +116,7 @@
 				if(!result.dArea->contains(pos))
 					return;
 				
-				float movementCost = moveCostFunction(currentNode, pos) + currentNode.dist2d(pos);
-				
+				float movementCost = moveCostFunction(currentNode, pos);
 				float distance = distances[currentNode] + movementCost; //we prefer to use already free paths
 				int bestDistanceSoFar = std::numeric_limits<int>::max();
 				auto it = distances.find(pos);
@@ -190,4 +189,21 @@
 	return dPath;
 }
 
+Path::MoveCostFunction Path::createCurvedCostFunction(const Area & border)
+{
+	// Capture by value to ensure the Area object persists
+	return [border = border](const int3& src, const int3& dst) -> float
+	{
+		// Route main roads far from border
+		float ret = dst.dist2d(src);
+		float dist = border.distanceSqr(dst);
+
+		if(dist > 1.0f)
+		{
+			ret /= dist;
+		}
+		return ret;
+	};
+}
+
 VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/rmg/RmgPath.h vcmi/lib/rmg/RmgPath.h
--- vcmi-1.5.7/lib/rmg/RmgPath.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/rmg/RmgPath.h	2024-12-19 15:00:22.930149260 +0100
@@ -21,7 +21,8 @@
 class Path
 {
 public:
-	const static std::function<float(const int3 &, const int3 &)> DEFAULT_MOVEMENT_FUNCTION;
+	using MoveCostFunction = std::function<float(const int3 &, const int3 &)>;
+	const static MoveCostFunction DEFAULT_MOVEMENT_FUNCTION;
 	
 	Path(const Area & area);
 	Path(const Area & area, const int3 & src);
@@ -42,6 +43,7 @@
 	const Area & getPathArea() const;
 	
 	static Path invalid();
+	static MoveCostFunction createCurvedCostFunction(const Area & border);
 	
 private:
 	
diff --color -urN vcmi-1.5.7/lib/rmg/threadpool/MapProxy.cpp vcmi/lib/rmg/threadpool/MapProxy.cpp
--- vcmi-1.5.7/lib/rmg/threadpool/MapProxy.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/rmg/threadpool/MapProxy.cpp	2024-12-19 15:00:22.934149425 +0100
@@ -10,6 +10,7 @@
 
 #include "MapProxy.h"
 #include "../../TerrainHandler.h"
+#include "../../VCMI_Lib.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
@@ -36,21 +37,21 @@
 	map.getEditManager()->removeObject(obj);
 }
 
-void MapProxy::drawTerrain(CRandomGenerator & generator, std::vector<int3> & tiles, TerrainId terrain)
+void MapProxy::drawTerrain(vstd::RNG & generator, std::vector<int3> & tiles, TerrainId terrain)
 {
 	Lock lock(mx);
 	map.getEditManager()->getTerrainSelection().setSelection(tiles);
 	map.getEditManager()->drawTerrain(terrain, map.getDecorationsPercentage(), &generator);
 }
 
-void MapProxy::drawRivers(CRandomGenerator & generator, std::vector<int3> & tiles, TerrainId terrain)
+void MapProxy::drawRivers(vstd::RNG & generator, std::vector<int3> & tiles, TerrainId terrain)
 {
 	Lock lock(mx);
 	map.getEditManager()->getTerrainSelection().setSelection(tiles);
 	map.getEditManager()->drawRiver(VLC->terrainTypeHandler->getById(terrain)->river, &generator);
 }
 
-void MapProxy::drawRoads(CRandomGenerator & generator, std::vector<int3> & tiles, RoadId roadType)
+void MapProxy::drawRoads(vstd::RNG & generator, std::vector<int3> & tiles, RoadId roadType)
 {
 	Lock lock(mx);
 	map.getEditManager()->getTerrainSelection().setSelection(tiles);
diff --color -urN vcmi-1.5.7/lib/rmg/threadpool/MapProxy.h vcmi/lib/rmg/threadpool/MapProxy.h
--- vcmi-1.5.7/lib/rmg/threadpool/MapProxy.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/rmg/threadpool/MapProxy.h	2024-12-19 15:00:22.934149425 +0100
@@ -28,9 +28,9 @@
 	void insertObjects(std::set<CGObjectInstance*>& objects);
 	void removeObject(CGObjectInstance* obj);
 
-	void drawTerrain(CRandomGenerator & generator, std::vector<int3> & tiles, TerrainId terrain);
-	void drawRivers(CRandomGenerator & generator, std::vector<int3> & tiles, TerrainId terrain);
-	void drawRoads(CRandomGenerator & generator, std::vector<int3> & tiles, RoadId roadType);
+	void drawTerrain(vstd::RNG & generator, std::vector<int3> & tiles, TerrainId terrain);
+	void drawRivers(vstd::RNG & generator, std::vector<int3> & tiles, TerrainId terrain);
+	void drawRoads(vstd::RNG & generator, std::vector<int3> & tiles, RoadId roadType);
 
 private:
 	mutable boost::shared_mutex mx;
diff --color -urN vcmi-1.5.7/lib/rmg/TileInfo.cpp vcmi/lib/rmg/TileInfo.cpp
--- vcmi-1.5.7/lib/rmg/TileInfo.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/rmg/TileInfo.cpp	2024-12-19 15:00:22.930149260 +0100
@@ -26,7 +26,7 @@
 
 void TileInfo::setNearestObjectDistance(float value)
 {
-	nearestObjectDistance = std::max<float>(0, value); //never negative (or unitialized)
+	nearestObjectDistance = std::max<float>(0, value); //never negative (or uninitialized)
 }
 bool TileInfo::shouldBeBlocked() const
 {
diff --color -urN vcmi-1.5.7/lib/rmg/Zone.cpp vcmi/lib/rmg/Zone.cpp
--- vcmi-1.5.7/lib/rmg/Zone.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/rmg/Zone.cpp	2024-12-19 15:00:22.930149260 +0100
@@ -17,6 +17,10 @@
 #include "RmgPath.h"
 #include "modificators/ObjectManager.h"
 
+#include "../CRandomGenerator.h"
+
+#include <vstd/RNG.h>
+
 VCMI_LIB_NAMESPACE_BEGIN
 
 const std::function<bool(const int3 &)> AREA_NO_FILTER = [](const int3 & t)
@@ -24,16 +28,18 @@
 	return true;
 };
 
-Zone::Zone(RmgMap & map, CMapGenerator & generator, CRandomGenerator & r)
+Zone::Zone(RmgMap & map, CMapGenerator & generator, vstd::RNG & r)
 	: finished(false)
 	, townType(ETownType::NEUTRAL)
 	, terrainType(ETerrainId::GRASS)
 	, map(map)
+	, rand(std::make_unique<CRandomGenerator>(r.nextInt()))
 	, generator(generator)
 {
-	rand.setSeed(r.nextInt());
 }
 
+Zone::~Zone() = default;
+
 bool Zone::isUnderground() const
 {
 	return getPos().z;
@@ -115,6 +121,11 @@
 	return ThreadSafeProxy<const rmg::Area>(dAreaUsed, areaMutex);
 }
 
+rmg::Area Zone::areaForRoads() const
+{
+	return areaPossible() + freePaths();
+}
+
 void Zone::clearTiles()
 {
 	Lock lock(areaMutex);
@@ -132,7 +143,7 @@
 	});
 	dAreaPossible.assign(possibleTiles);
 	
-	if(dAreaFree.empty())
+	if(dAreaFree.empty() && getType() != ETemplateZoneType::SEALED)
 	{
 		// Fixme: This might fail fot water zone, which doesn't need to have a tile in its center of the mass
 		dAreaPossible.erase(pos);
@@ -269,7 +280,7 @@
 	{
 		if (treasureValue > 250)
 		{
-			// A quater at max density - means more free space
+			// A quarter at max density - means more free space
 			marginFactor = (0.6f + ((std::max(0, (600 - treasureValue))) / (600.f - 250)) * 0.4f);
 
 			// Low value - dense obstacles
@@ -293,7 +304,6 @@
 	logGlobal->trace("Zone %d: treasureValue %d blockDistance: %2.f, freeDistance: %2.f", getId(), treasureValue, blockDistance, freeDistance);
 
 	Lock lock(areaMutex);
-	// FIXME: Do not access Area directly
 
 	rmg::Area clearedTiles(dAreaFree);
 	rmg::Area possibleTiles(dAreaPossible);
@@ -342,6 +352,16 @@
 			tilesToIgnore.clear();
 		}
 	}
+	else if (type == ETemplateZoneType::SEALED)
+	{
+		//Completely block all the tiles in the zone
+		auto tiles = areaPossible()->getTiles();
+		for(const auto & t : tiles)
+			map.setOccupied(t, ETileType::BLOCKED);
+		possibleTiles.clear();
+		dAreaFree.clear();
+		return;
+	}
 	else
 	{
 		// Handle special case - place Monoliths at the edge of a zone
@@ -401,9 +421,9 @@
 	}
 }
 
-CRandomGenerator& Zone::getRand()
+vstd::RNG& Zone::getRand()
 {
-	return rand;
+	return *rand;
 }
 
 VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/rmg/Zone.h vcmi/lib/rmg/Zone.h
--- vcmi-1.5.7/lib/rmg/Zone.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/rmg/Zone.h	2024-12-19 15:00:22.931149301 +0100
@@ -13,7 +13,6 @@
 #include "../GameConstants.h"
 #include "float3.h"
 #include "../int3.h"
-#include "../CRandomGenerator.h"
 #include "CRmgTemplate.h"
 #include "RmgArea.h"
 #include "RmgPath.h"
@@ -28,7 +27,6 @@
 class RmgMap;
 class CMapGenerator;
 class Modificator;
-class CRandomGenerator;
 
 extern const std::function<bool(const int3 &)> AREA_NO_FILTER;
 
@@ -74,8 +72,9 @@
 class Zone : public rmg::ZoneOptions
 {
 public:
-	Zone(RmgMap & map, CMapGenerator & generator, CRandomGenerator & rand);
+	Zone(RmgMap & map, CMapGenerator & generator, vstd::RNG & rand);
 	Zone(const Zone &) = delete;
+	~Zone();
 	
 	void setOptions(const rmg::ZoneOptions & options);
 	bool isUnderground() const;
@@ -93,6 +92,8 @@
 	ThreadSafeProxy<const rmg::Area> freePaths() const;
 	ThreadSafeProxy<rmg::Area> areaUsed();
 	ThreadSafeProxy<const rmg::Area> areaUsed() const;
+	
+	rmg::Area areaForRoads() const;
 
 	void initFreeTiles();
 	void clearTiles();
@@ -127,14 +128,14 @@
 	
 	void initModificators();
 	
-	CRandomGenerator & getRand();
+	vstd::RNG & getRand();
 public:
 	mutable boost::recursive_mutex areaMutex;
 	using Lock = boost::unique_lock<boost::recursive_mutex>;
 	
 protected:
 	CMapGenerator & generator;
-	CRandomGenerator rand;
+	std::unique_ptr<vstd::RNG> rand;
 	RmgMap & map;
 	TModificators modificators;
 	bool finished;
@@ -142,7 +143,7 @@
 	//placement info
 	int3 pos;
 	float3 center;
-	rmg::Area dArea; //irregular area assined to zone
+	rmg::Area dArea; //irregular area assigned to zone
 	rmg::Area dAreaPossible;
 	rmg::Area dAreaFree; //core paths of free tiles that all other objects will be linked to
 	rmg::Area dAreaUsed;
diff --color -urN vcmi-1.5.7/lib/RoadHandler.cpp vcmi/lib/RoadHandler.cpp
--- vcmi-1.5.7/lib/RoadHandler.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/RoadHandler.cpp	2024-12-19 15:00:22.871146822 +0100
@@ -10,20 +10,21 @@
 
 #include "StdInc.h"
 #include "RoadHandler.h"
-#include "CGeneralTextHandler.h"
-#include "GameSettings.h"
+#include "texts/CGeneralTextHandler.h"
+#include "IGameSettings.h"
 #include "json/JsonNode.h"
+#include "VCMI_Lib.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
 RoadTypeHandler::RoadTypeHandler()
 {
-	objects.push_back(new RoadType());
+	objects.emplace_back(new RoadType());
 
 	VLC->generaltexth->registerString("core", objects[0]->getNameTextID(), "");
 }
 
-RoadType * RoadTypeHandler::loadFromJson(
+std::shared_ptr<RoadType> RoadTypeHandler::loadFromJson(
 	const std::string & scope,
 	const JsonNode & json,
 	const std::string & identifier,
@@ -31,7 +32,7 @@
 {
 	assert(identifier.find(':') == std::string::npos);
 
-	auto * info = new RoadType;
+	auto info = std::make_shared<RoadType>();
 
 	info->id              = RoadId(index);
 	info->identifier      = identifier;
@@ -40,7 +41,7 @@
 	info->shortIdentifier = json["shortIdentifier"].String();
 	info->movementCost    = json["moveCost"].Integer();
 
-	VLC->generaltexth->registerString(scope,info->getNameTextID(), json["text"].String());
+	VLC->generaltexth->registerString(scope,info->getNameTextID(), json["text"]);
 
 	return info;
 }
@@ -53,7 +54,7 @@
 
 std::vector<JsonNode> RoadTypeHandler::loadLegacyData()
 {
-	size_t dataSize = VLC->settings()->getInteger(EGameSettings::TEXTS_ROAD);
+	size_t dataSize = VLC->engineSettings()->getInteger(EGameSettings::TEXTS_ROAD);
 
 	objects.resize(dataSize);
 	return {};
@@ -64,6 +65,11 @@
 	return modScope + ":" + identifier;
 }
 
+std::string RoadType::getModScope() const
+{
+	return modScope;
+}
+
 std::string RoadType::getNameTextID() const
 {
 	return TextIdentifier( "road", modScope, identifier, "name" ).get();
diff --color -urN vcmi-1.5.7/lib/RoadHandler.h vcmi/lib/RoadHandler.h
--- vcmi-1.5.7/lib/RoadHandler.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/RoadHandler.h	2024-12-19 15:00:22.871146822 +0100
@@ -29,6 +29,7 @@
 	int32_t getIndex() const override { return id.getNum(); }
 	int32_t getIconIndex() const override { return 0; }
 	std::string getJsonKey() const override;
+	std::string getModScope() const override;
 	void registerIcons(const IconRegistar & cb) const override {}
 	RoadId getId() const override { return id;}
 	void updateFrom(const JsonNode & data) {};
@@ -51,7 +52,7 @@
 class DLL_LINKAGE RoadTypeHandler : public CHandlerBase<RoadId, RoadType, RoadType, RoadTypeService>
 {
 public:
-	virtual RoadType * loadFromJson(
+	std::shared_ptr<RoadType> loadFromJson(
 		const std::string & scope,
 		const JsonNode & json,
 		const std::string & identifier,
diff --color -urN vcmi-1.5.7/lib/serializer/BinaryDeserializer.cpp vcmi/lib/serializer/BinaryDeserializer.cpp
--- vcmi-1.5.7/lib/serializer/BinaryDeserializer.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/serializer/BinaryDeserializer.cpp	2024-12-19 15:00:22.934149425 +0100
@@ -9,18 +9,13 @@
  */
 #include "StdInc.h"
 #include "BinaryDeserializer.h"
-#include "../registerTypes/RegisterTypes.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
 BinaryDeserializer::BinaryDeserializer(IBinaryReader * r): CLoaderBase(r)
 {
-	saving = false;
 	version = Version::NONE;
-	smartPointerSerialization = true;
 	reverseEndianness = false;
-
-	registerTypes(*this);
 }
 
 VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/serializer/BinaryDeserializer.h vcmi/lib/serializer/BinaryDeserializer.h
--- vcmi-1.5.7/lib/serializer/BinaryDeserializer.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/serializer/BinaryDeserializer.h	2024-12-19 15:00:22.935149467 +0100
@@ -10,7 +10,7 @@
 #pragma once
 
 #include "CSerializer.h"
-#include "CTypeList.h"
+#include "SerializerReflection.h"
 #include "ESerializationVersion.h"
 #include "../mapObjects/CGHeroInstance.h"
 
@@ -35,75 +35,50 @@
 
 /// Main class for deserialization of classes from binary form
 /// Effectively revesed version of BinarySerializer
-class DLL_LINKAGE BinaryDeserializer : public CLoaderBase
+class BinaryDeserializer : public CLoaderBase
 {
-	template<typename Ser,typename T>
-	struct LoadIfStackInstance
+	template<typename Fake, typename T>
+	static bool loadIfStackInstance(T &data)
 	{
-		static bool invoke(Ser &s, T &data)
-		{
-			return false;
-		}
-	};
+		return false;
+	}
 
-	template<typename Ser>
-	struct LoadIfStackInstance<Ser, CStackInstance *>
+	template<typename Fake>
+	bool loadIfStackInstance(const CStackInstance* &data)
 	{
-		static bool invoke(Ser &s, CStackInstance* &data)
-		{
-			CArmedInstance *armedObj;
-			SlotID slot;
-			s.load(armedObj);
-			s.load(slot);
-			if(slot != SlotID::COMMANDER_SLOT_PLACEHOLDER)
-			{
-				assert(armedObj->hasStackAtSlot(slot));
-				data = armedObj->stacks[slot];
-			}
-			else
-			{
-				auto * hero = dynamic_cast<CGHeroInstance *>(armedObj);
-				assert(hero);
-				assert(hero->commander);
-				data = hero->commander;
-			}
-			return true;
-		}
-	};
+		CArmedInstance * armyPtr = nullptr;
+		ObjectInstanceID armyID;
+		SlotID slot;
+		load(armyID);
+		load(slot);
 
-	template <typename T, typename Enable = void>
-	struct ClassObjectCreator
-	{
-		static T *invoke(IGameCallback *cb)
+		if (armyID == ObjectInstanceID::NONE)
+			return false;
+
+		if(reader->smartVectorMembersSerialization)
 		{
-			static_assert(!std::is_base_of_v<GameCallbackHolder, T>, "Cannot call new upon map objects!");
-			static_assert(!std::is_abstract_v<T>, "Cannot call new upon abstract classes!");
-			return new T();
+			if(const auto *info = reader->getVectorizedTypeInfo<CArmedInstance, ObjectInstanceID>())
+				armyPtr = reader->getVectorItemFromId<CArmedInstance, ObjectInstanceID>(*info, armyID);
 		}
-	};
 
-	template<typename T>
-	struct ClassObjectCreator<T, typename std::enable_if_t<std::is_abstract_v<T>>>
-	{
-		static T *invoke(IGameCallback *cb)
+		if(slot != SlotID::COMMANDER_SLOT_PLACEHOLDER)
 		{
-			throw std::runtime_error("Something went really wrong during deserialization. Attempted creating an object of an abstract class " + std::string(typeid(T).name()));
+			assert(armyPtr->hasStackAtSlot(slot));
+			data = armyPtr->stacks[slot];
 		}
-	};
-
-	template<typename T>
-	struct ClassObjectCreator<T, typename std::enable_if_t<std::is_base_of_v<GameCallbackHolder, T> && !std::is_abstract_v<T>>>
-	{
-		static T *invoke(IGameCallback *cb)
+		else
 		{
-			static_assert(!std::is_abstract_v<T>, "Cannot call new upon abstract classes!");
-			return new T(cb);
+			auto * hero = dynamic_cast<CGHeroInstance *>(armyPtr);
+			assert(hero);
+			assert(hero->commander);
+			data = hero->commander;
 		}
-	};
+		return true;
+	}
 
-	STRONG_INLINE ui32 readAndCheckLength()
+	STRONG_INLINE uint32_t readAndCheckLength()
 	{
-		ui32 length;
+		uint32_t length;
 		load(length);
 		//NOTE: also used for h3m's embedded in campaigns, so it may be quite large in some cases (e.g. XXL maps with multiple objects)
 		if(length > 1000000)
@@ -114,40 +89,6 @@
 		return length;
 	}
 
-	template <typename Type> class CPointerLoader;
-
-	class IPointerLoader
-	{
-	public:
-		virtual void * loadPtr(CLoaderBase &ar, IGameCallback * cb, ui32 pid) const =0; //data is pointer to the ACTUAL POINTER
-		virtual ~IPointerLoader() = default;
-
-		template<typename Type> static IPointerLoader *getApplier(const Type * t = nullptr)
-		{
-			return new CPointerLoader<Type>();
-		}
-	};
-
-	template <typename Type>
-	class CPointerLoader : public IPointerLoader
-	{
-	public:
-		void * loadPtr(CLoaderBase &ar, IGameCallback * cb, ui32 pid) const override //data is pointer to the ACTUAL POINTER
-		{
-			auto & s = static_cast<BinaryDeserializer &>(ar);
-
-			//create new object under pointer
-			Type * ptr = ClassObjectCreator<Type>::invoke(cb); //does new npT or throws for abstract classes
-			s.ptrAllocated(ptr, pid);
-
-			ptr->serialize(s);
-
-			return static_cast<void*>(ptr);
-		}
-	};
-
-	CApplier<IPointerLoader> applier;
-
 	int write(const void * data, unsigned size);
 
 public:
@@ -156,13 +97,20 @@
 	bool reverseEndianness; //if source has different endianness than us, we reverse bytes
 	Version version;
 
-	std::map<ui32, void*> loadedPointers;
-	std::map<const void*, std::shared_ptr<void>> loadedSharedPointers;
+	std::vector<std::string> loadedStrings;
+	std::map<uint32_t, Serializeable*> loadedPointers;
+	std::map<const Serializeable*, std::shared_ptr<Serializeable>> loadedSharedPointers;
 	IGameCallback * cb = nullptr;
-	bool smartPointerSerialization;
-	bool saving;
+	static constexpr bool trackSerializedPointers = true;
+	static constexpr bool saving = false;
+	bool loadingGamestate = false;
 
-	BinaryDeserializer(IBinaryReader * r);
+	bool hasFeature(Version what) const
+	{
+		return version >= what;
+	};
+
+	DLL_LINKAGE BinaryDeserializer(IBinaryReader * r);
 
 	template<class T>
 	BinaryDeserializer & operator&(T & t)
@@ -171,12 +119,56 @@
 		return * this;
 	}
 
-	template < class T, typename std::enable_if_t < std::is_fundamental_v<T> && !std::is_same_v<T, bool>, int  > = 0 >
+	int64_t loadEncodedInteger()
+	{
+		uint64_t valueUnsigned = 0;
+		uint_fast8_t offset = 0;
+
+		for (;;)
+		{
+			uint8_t byteValue;
+			load(byteValue);
+
+			if ((byteValue & 0x80) != 0)
+			{
+				valueUnsigned |= static_cast<uint64_t>(byteValue & 0x7f) << offset;
+				offset += 7;
+			}
+			else
+			{
+				valueUnsigned |= static_cast<uint64_t>(byteValue & 0x3f) << offset;
+				bool isNegative = (byteValue & 0x40) != 0;
+				if (isNegative)
+					return -static_cast<int64_t>(valueUnsigned);
+				else
+					return valueUnsigned;
+			}
+		}
+	}
+
+	template < class T, typename std::enable_if_t < std::is_floating_point_v<T>, int  > = 0 >
 	void load(T &data)
 	{
 		this->read(static_cast<void *>(&data), sizeof(data), reverseEndianness);
 	}
 
+	template < class T, typename std::enable_if_t < std::is_integral_v<T> && !std::is_same_v<T, bool>, int  > = 0 >
+	void load(T &data)
+	{
+		if constexpr (sizeof(T) == 1)
+		{
+			this->read(static_cast<void *>(&data), sizeof(data), reverseEndianness);
+		}
+		else
+		{
+			static_assert(!std::is_same_v<uint64_t, T>, "Serialization of unsigned 64-bit value may not work in some cases");
+			if (hasFeature(Version::COMPACT_INTEGER_SERIALIZATION))
+				data = loadEncodedInteger();
+			else
+				this->read(static_cast<void *>(&data), sizeof(data), reverseEndianness);
+		}
+	}
+
 	template < typename T, typename std::enable_if_t < is_serializeable<BinaryDeserializer, T>::value, int  > = 0 >
 	void load(T &data)
 	{
@@ -188,15 +180,20 @@
 	template < typename T, typename std::enable_if_t < std::is_array_v<T>, int  > = 0 >
 	void load(T &data)
 	{
-		ui32 size = std::size(data);
-		for(ui32 i = 0; i < size; i++)
+		uint32_t size = std::size(data);
+		for(uint32_t i = 0; i < size; i++)
 			load(data[i]);
 	}
 
+	void load(Version &data)
+	{
+		this->read(static_cast<void *>(&data), sizeof(data), reverseEndianness);
+	}
+
 	template < typename T, typename std::enable_if_t < std::is_enum_v<T>, int  > = 0 >
 	void load(T &data)
 	{
-		si32 read;
+		int32_t read;
 		load( read );
 		data = static_cast<T>(read);
 	}
@@ -204,7 +201,7 @@
 	template < typename T, typename std::enable_if_t < std::is_same_v<T, bool>, int > = 0 >
 	void load(T &data)
 	{
-		ui8 read;
+		uint8_t read;
 		load( read );
 		data = static_cast<bool>(read);
 	}
@@ -212,18 +209,18 @@
 	template <typename T, typename std::enable_if_t < !std::is_same_v<T, bool >, int  > = 0>
 	void load(std::vector<T> &data)
 	{
-		ui32 length = readAndCheckLength();
+		uint32_t length = readAndCheckLength();
 		data.resize(length);
-		for(ui32 i=0;i<length;i++)
+		for(uint32_t i=0;i<length;i++)
 			load( data[i]);
 	}
 
 	template <typename T, typename std::enable_if_t < !std::is_same_v<T, bool >, int  > = 0>
 	void load(std::deque<T> & data)
 	{
-		ui32 length = readAndCheckLength();
+		uint32_t length = readAndCheckLength();
 		data.resize(length);
-		for(ui32 i = 0; i < length; i++)
+		for(uint32_t i = 0; i < length; i++)
 			load(data[i]);
 	}
 
@@ -238,25 +235,6 @@
 			return;
 		}
 
-		loadPointerImpl(data);
-	}
-
-	template < typename T, typename std::enable_if_t < std::is_base_of_v<Entity, std::remove_pointer_t<T>>, int  > = 0 >
-	void loadPointerImpl(T &data)
-	{
-		using DataType = std::remove_pointer_t<T>;
-
-		typename DataType::IdentifierType index;
-		load(index);
-
-		auto * constEntity = index.toEntity(VLC);
-		auto * constData = dynamic_cast<const DataType *>(constEntity);
-		data = const_cast<DataType *>(constData);
-	}
-
-	template < typename T, typename std::enable_if_t < !std::is_base_of_v<Entity, std::remove_pointer_t<T>>, int  > = 0 >
-	void loadPointerImpl(T &data)
-	{
 		if(reader->smartVectorMembersSerialization)
 		{
 			typedef typename std::remove_const_t<typename std::remove_pointer_t<T>> TObjectType; //eg: const CGHeroInstance * => CGHeroInstance
@@ -276,13 +254,13 @@
 
 		if(reader->sendStackInstanceByIds)
 		{
-			bool gotLoaded = LoadIfStackInstance<BinaryDeserializer,T>::invoke(* this, data);
+			bool gotLoaded = loadIfStackInstance<void>(data);
 			if(gotLoaded)
 				return;
 		}
 
-		ui32 pid = 0xffffffff; //pointer id (or maybe rather pointee id)
-		if(smartPointerSerialization)
+		uint32_t pid = 0xffffffff; //pointer id (or maybe rather pointee id)
+		if(trackSerializedPointers)
 		{
 			load( pid ); //get the id
 			auto i = loadedPointers.find(pid); //lookup
@@ -291,45 +269,43 @@
 			{
 				// We already got this pointer
 				// Cast it in case we are loading it to a non-first base pointer
-				data = static_cast<T>(i->second);
+				data = dynamic_cast<T>(i->second);
 				return;
 			}
 		}
 		//get type id
-		ui16 tid;
+		uint16_t tid;
 		load( tid );
 
+		typedef typename std::remove_pointer_t<T> npT;
+		typedef typename std::remove_const_t<npT> ncpT;
 		if(!tid)
 		{
-			typedef typename std::remove_pointer_t<T> npT;
-			typedef typename std::remove_const_t<npT> ncpT;
 			data = ClassObjectCreator<ncpT>::invoke(cb);
 			ptrAllocated(data, pid);
 			load(*data);
 		}
 		else
 		{
-			auto * app = applier.getApplier(tid);
+			auto * app = CSerializationApplier::getInstance().getApplier(tid);
 			if(app == nullptr)
 			{
 				logGlobal->error("load %d %d - no loader exists", tid, pid);
 				data = nullptr;
 				return;
 			}
-			data = static_cast<T>(app->loadPtr(*this, cb, pid));
+			auto dataNonConst = dynamic_cast<ncpT*>(app->createPtr(*this, cb));
+			data = dataNonConst;
+			ptrAllocated(data, pid);
+			app->loadPtr(*this, cb, dataNonConst);
 		}
 	}
 
 	template <typename T>
-	void ptrAllocated(const T *ptr, ui32 pid)
+	void ptrAllocated(T *ptr, uint32_t pid)
 	{
-		if(smartPointerSerialization && pid != 0xffffffff)
-			loadedPointers[pid] = (void*)ptr; //add loaded pointer to our lookup map; cast is to avoid errors with const T* pt
-	}
-
-	template<typename Base, typename Derived> void registerType(const Base * b = nullptr, const Derived * d = nullptr)
-	{
-		applier.registerType(b, d);
+		if(trackSerializedPointers && pid != 0xffffffff)
+			loadedPointers[pid] = const_cast<Serializeable*>(dynamic_cast<const Serializeable*>(ptr)); //add loaded pointer to our lookup map; cast is to avoid errors with const T* pt
 	}
 
 	template <typename T>
@@ -339,7 +315,7 @@
 		NonConstT *internalPtr;
 		load(internalPtr);
 
-		void * internalPtrDerived = static_cast<void*>(internalPtr);
+		const auto * internalPtrDerived = static_cast<Serializeable*>(internalPtr);
 
 		if(internalPtr)
 		{
@@ -354,7 +330,7 @@
 			{
 				auto hlp = std::shared_ptr<NonConstT>(internalPtr);
 				data = hlp;
-				loadedSharedPointers[internalPtrDerived] = std::static_pointer_cast<void>(hlp);
+				loadedSharedPointers[internalPtrDerived] = std::static_pointer_cast<Serializeable>(hlp);
 			}
 		}
 		else
@@ -386,16 +362,16 @@
 	template <typename T, size_t N>
 	void load(std::array<T, N> &data)
 	{
-		for(ui32 i = 0; i < N; i++)
+		for(uint32_t i = 0; i < N; i++)
 			load( data[i] );
 	}
 	template <typename T>
 	void load(std::set<T> &data)
 	{
-		ui32 length = readAndCheckLength();
+		uint32_t length = readAndCheckLength();
 		data.clear();
 		T ins;
-		for(ui32 i=0;i<length;i++)
+		for(uint32_t i=0;i<length;i++)
 		{
 			load( ins );
 			data.insert(ins);
@@ -404,10 +380,10 @@
 	template <typename T, typename U>
 	void load(std::unordered_set<T, U> &data)
 	{
-		ui32 length = readAndCheckLength();
+		uint32_t length = readAndCheckLength();
 		data.clear();
 		T ins;
-		for(ui32 i=0;i<length;i++)
+		for(uint32_t i=0;i<length;i++)
 		{
 			load(ins);
 			data.insert(ins);
@@ -416,10 +392,10 @@
 	template <typename T>
 	void load(std::list<T> &data)
 	{
-		ui32 length = readAndCheckLength();
+		uint32_t length = readAndCheckLength();
 		data.clear();
 		T ins;
-		for(ui32 i=0;i<length;i++)
+		for(uint32_t i=0;i<length;i++)
 		{
 			load(ins);
 			data.push_back(ins);
@@ -433,12 +409,25 @@
 	}
 
 	template <typename T1, typename T2>
+	void load(std::unordered_map<T1,T2> &data)
+	{
+		uint32_t length = readAndCheckLength();
+		data.clear();
+		T1 key;
+		for(uint32_t i=0;i<length;i++)
+		{
+			load(key);
+			load(data[key]);
+		}
+	}
+
+	template <typename T1, typename T2>
 	void load(std::map<T1,T2> &data)
 	{
-		ui32 length = readAndCheckLength();
+		uint32_t length = readAndCheckLength();
 		data.clear();
 		T1 key;
-		for(ui32 i=0;i<length;i++)
+		for(uint32_t i=0;i<length;i++)
 		{
 			load(key);
 			load(data[key]);
@@ -446,15 +435,39 @@
 	}
 	void load(std::string &data)
 	{
-		ui32 length = readAndCheckLength();
-		data.resize(length);
-		this->read(static_cast<void *>(data.data()), length, false);
+		if (hasFeature(Version::COMPACT_STRING_SERIALIZATION))
+		{
+			int32_t length;
+			load(length);
+
+			if (length < 0)
+			{
+				int32_t stringID = -length - 1; // -1, -2 ... -> 0, 1 ...
+				data = loadedStrings[stringID];
+			}
+			if (length == 0)
+			{
+				data = {};
+			}
+			if (length > 0)
+			{
+				data.resize(length);
+				this->read(static_cast<void *>(data.data()), length, false);
+				loadedStrings.push_back(data);
+			}
+		}
+		else
+		{
+			uint32_t length = readAndCheckLength();
+			data.resize(length);
+			this->read(static_cast<void *>(data.data()), length, false);
+		}
 	}
 
 	template<typename... TN>
 	void load(std::variant<TN...> & data)
 	{
-		si32 which;
+		int32_t which;
 		load( which );
 		assert(which < sizeof...(TN));
 
@@ -469,7 +482,7 @@
 	template<typename T>
 	void load(std::optional<T> & data)
 	{
-		ui8 present;
+		uint8_t present;
 		load( present );
 		if(present)
 		{
@@ -487,16 +500,16 @@
 	template <typename T>
 	void load(boost::multi_array<T, 3> & data)
 	{
-		ui32 length = readAndCheckLength();
-		ui32 x;
-		ui32 y;
-		ui32 z;
+		uint32_t length = readAndCheckLength();
+		uint32_t x;
+		uint32_t y;
+		uint32_t z;
 		load(x);
 		load(y);
 		load(z);
 		data.resize(boost::extents[x][y][z]);
 		assert(length == data.num_elements()); //x*y*z should be equal to number of elements
-		for(ui32 i = 0; i < length; i++)
+		for(uint32_t i = 0; i < length; i++)
 			load(data.data()[i]);
 	}
 	template <std::size_t T>
diff --color -urN vcmi-1.5.7/lib/serializer/BinarySerializer.cpp vcmi/lib/serializer/BinarySerializer.cpp
--- vcmi-1.5.7/lib/serializer/BinarySerializer.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/serializer/BinarySerializer.cpp	2024-12-19 15:00:22.935149467 +0100
@@ -9,15 +9,11 @@
  */
 #include "StdInc.h"
 #include "BinarySerializer.h"
-#include "../registerTypes/RegisterTypes.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
 BinarySerializer::BinarySerializer(IBinaryWriter * w): CSaverBase(w)
 {
-	saving=true;
-	smartPointerSerialization = true;
-	registerTypes(*this);
 }
 
 VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/serializer/BinarySerializer.h vcmi/lib/serializer/BinarySerializer.h
--- vcmi-1.5.7/lib/serializer/BinarySerializer.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/serializer/BinarySerializer.h	2024-12-19 15:00:22.935149467 +0100
@@ -11,7 +11,9 @@
 
 #include "CSerializer.h"
 #include "CTypeList.h"
+#include "SerializerReflection.h"
 #include "ESerializationVersion.h"
+#include "Serializeable.h"
 #include "../mapObjects/CArmedInstance.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
@@ -23,7 +25,7 @@
 public:
 	CSaverBase(IBinaryWriter * w): writer(w){};
 
-	inline void write(const void * data, unsigned size)
+	void write(const void * data, unsigned size)
 	{
 		writer->write(reinterpret_cast<const std::byte*>(data), size);
 	};
@@ -34,7 +36,7 @@
 /// Primitives:    copy memory into underlying stream (defined in CSaverBase)
 /// Containers:    custom overloaded method that decouples class into primitives
 /// VCMI Classes:  recursively serialize them via ClassName::serialize( BinarySerializer &, int version) call
-class DLL_LINKAGE BinarySerializer : public CSaverBase
+class BinarySerializer : public CSaverBase
 {
 	template<typename Handler>
 	struct VariantVisitorSaver
@@ -51,81 +53,51 @@
 		}
 	};
 
-	template<typename Ser,typename T>
-	struct SaveIfStackInstance
+	template<typename Fake, typename T>
+	bool saveIfStackInstance(const T &data)
 	{
-		static bool invoke(Ser &s, const T &data)
-		{
-			return false;
-		}
-	};
-
-	template<typename Ser>
-	struct SaveIfStackInstance<Ser, CStackInstance *>
-	{
-		static bool invoke(Ser &s, const CStackInstance* const &data)
-		{
-			assert(data->armyObj);
-			SlotID slot;
-
-			if(data->getNodeType() == CBonusSystemNode::COMMANDER)
-				slot = SlotID::COMMANDER_SLOT_PLACEHOLDER;
-			else
-				slot = data->armyObj->findStack(data);
-
-			assert(slot != SlotID());
-			s & data->armyObj & slot;
-			return true;
-		}
-	};
-
-	template <typename T> class CPointerSaver;
+		return false;
+	}
 
-	class CBasicPointerSaver
+	template<typename Fake>
+	bool saveIfStackInstance(const CStackInstance* const &data)
 	{
-	public:
-		virtual void savePtr(CSaverBase &ar, const void *data) const =0;
-		virtual ~CBasicPointerSaver(){}
-
-		template<typename T> static CBasicPointerSaver *getApplier(const T * t=nullptr)
-		{
-			return new CPointerSaver<T>();
-		}
-	};
+		assert(data->armyObj);
 
+		SlotID slot;
 
-	template <typename T>
-	class CPointerSaver : public CBasicPointerSaver
-	{
-	public:
-		void savePtr(CSaverBase &ar, const void *data) const override
-		{
-			auto & s = static_cast<BinarySerializer &>(ar);
-			const T *ptr = static_cast<const T*>(data);
+		if(data->getNodeType() == CBonusSystemNode::COMMANDER)
+			slot = SlotID::COMMANDER_SLOT_PLACEHOLDER;
+		else
+			slot = data->armyObj->findStack(data);
 
-			//T is most derived known type, it's time to call actual serialize
-			const_cast<T*>(ptr)->serialize(s);
-		}
-	};
+		assert(slot != SlotID());
+		save(data->armyObj->id);
+		save(slot);
 
-	CApplier<CBasicPointerSaver> applier;
+		if (data->armyObj->id != ObjectInstanceID::NONE)
+			return true;
+		else
+			return false;
+	}
 
 public:
 	using Version = ESerializationVersion;
 
-	std::map<const void*, ui32> savedPointers;
+	std::map<std::string, uint32_t> savedStrings;
+	std::map<const Serializeable*, uint32_t> savedPointers;
 
 	Version version = Version::CURRENT;
-	bool smartPointerSerialization;
-	bool saving;
-
-	BinarySerializer(IBinaryWriter * w);
+	static constexpr bool trackSerializedPointers = true;
+	static constexpr bool saving = true;
+	bool loadingGamestate = false;
 
-	template<typename Base, typename Derived>
-	void registerType(const Base * b = nullptr, const Derived * d = nullptr)
+	bool hasFeature(Version what) const
 	{
-		applier.registerType(b, d);
-	}
+		return version >= what;
+	};
+
+	DLL_LINKAGE BinarySerializer(IBinaryWriter * w);
 
 	template<class T>
 	BinarySerializer & operator&(const T & t)
@@ -134,32 +106,72 @@
 		return * this;
 	}
 
+	void saveEncodedInteger(int64_t value)
+	{
+		uint64_t valueUnsigned = std::abs(value);
+
+		while (valueUnsigned > 0x3f)
+		{
+			uint8_t byteValue = (valueUnsigned & 0x7f) | 0x80;
+			valueUnsigned = valueUnsigned >> 7;
+			save(byteValue);
+		}
+
+		uint8_t lastByteValue = valueUnsigned & 0x3f;
+		if (value < 0)
+			lastByteValue |= 0x40;
+
+		save(lastByteValue);
+	}
+
 	template < typename T, typename std::enable_if_t < std::is_same_v<T, bool>, int > = 0 >
 	void save(const T &data)
 	{
-		ui8 writ = static_cast<ui8>(data);
+		uint8_t writ = static_cast<uint8_t>(data);
 		save(writ);
 	}
 
-	template < class T, typename std::enable_if_t < std::is_fundamental_v<T> && !std::is_same_v<T, bool>, int  > = 0 >
+	template < class T, typename std::enable_if_t < std::is_floating_point_v<T>, int  > = 0 >
 	void save(const T &data)
 	{
 		// save primitive - simply dump binary data to output
 		this->write(static_cast<const void *>(&data), sizeof(data));
 	}
 
+	template < class T, typename std::enable_if_t < std::is_integral_v<T> && !std::is_same_v<T, bool>, int  > = 0 >
+	void save(const T &data)
+	{
+		if constexpr (sizeof(T) == 1)
+		{
+			// save primitive - simply dump binary data to output
+			this->write(static_cast<const void *>(&data), sizeof(data));
+		}
+		else
+		{
+			if (hasFeature(Version::COMPACT_INTEGER_SERIALIZATION))
+				saveEncodedInteger(data);
+			else
+				this->write(static_cast<const void *>(&data), sizeof(data));
+		}
+	}
+
+	void save(const Version &data)
+	{
+		this->write(static_cast<const void *>(&data), sizeof(data));
+	}
+
 	template < typename T, typename std::enable_if_t < std::is_enum_v<T>, int  > = 0 >
 	void save(const T &data)
 	{
-		si32 writ = static_cast<si32>(data);
+		int32_t writ = static_cast<int32_t>(data);
 		*this & writ;
 	}
 
 	template < typename T, typename std::enable_if_t < std::is_array_v<T>, int  > = 0 >
 	void save(const T &data)
 	{
-		ui32 size = std::size(data);
-		for(ui32 i=0; i < size; i++)
+		uint32_t size = std::size(data);
+		for(uint32_t i=0; i < size; i++)
 			*this & data[i];
 	}
 
@@ -174,19 +186,6 @@
 		if(data == nullptr)
 			return;
 
-		savePointerImpl(data);
-	}
-
-	template < typename T, typename std::enable_if_t < std::is_base_of_v<Entity, std::remove_pointer_t<T>>, int  > = 0 >
-	void savePointerImpl(const T &data)
-	{
-		auto index = data->getId();
-		save(index);
-	}
-
-	template < typename T, typename std::enable_if_t < !std::is_base_of_v<Entity, std::remove_pointer_t<T>>, int  > = 0 >
-	void savePointerImpl(const T &data)
-	{
 		typedef typename std::remove_const_t<typename std::remove_pointer_t<T>> TObjectType;
 
 		if(writer->smartVectorMembersSerialization)
@@ -205,16 +204,16 @@
 
 		if(writer->sendStackInstanceByIds)
 		{
-			const bool gotSaved = SaveIfStackInstance<BinarySerializer,T>::invoke(*this, data);
+			const bool gotSaved = saveIfStackInstance<void>(data);
 			if(gotSaved)
 				return;
 		}
 
-		if(smartPointerSerialization)
+		if(trackSerializedPointers)
 		{
 			// We might have an object that has multiple inheritance and store it via the non-first base pointer.
 			// Therefore, all pointers need to be normalized to the actual object address.
-			const void * actualPointer = static_cast<const void*>(data);
+			const auto * actualPointer = static_cast<const Serializeable*>(data);
 			auto i = savedPointers.find(actualPointer);
 			if(i != savedPointers.end())
 			{
@@ -224,7 +223,7 @@
 			}
 
 			//give id to this pointer
-			ui32 pid = (ui32)savedPointers.size();
+			uint32_t pid = savedPointers.size();
 			savedPointers[actualPointer] = pid;
 			save(pid);
 		}
@@ -236,7 +235,7 @@
 		if(!tid)
 			save(*data); //if type is unregistered simply write all data in a standard way
 		else
-			applier.getApplier(tid)->savePtr(*this, static_cast<const void*>(data));  //call serializer specific for our real type
+			CSerializationApplier::getInstance().getApplier(tid)->savePtr(*this, static_cast<const Serializeable*>(data));  //call serializer specific for our real type
 	}
 
 	template < typename T, typename std::enable_if_t < is_serializeable<BinarySerializer, T>::value, int  > = 0 >
@@ -271,30 +270,30 @@
 	template <typename T, typename std::enable_if_t < !std::is_same_v<T, bool >, int  > = 0>
 	void save(const std::vector<T> &data)
 	{
-		ui32 length = (ui32)data.size();
+		uint32_t length = data.size();
 		*this & length;
-		for(ui32 i=0;i<length;i++)
+		for(uint32_t i=0;i<length;i++)
 			save(data[i]);
 	}
 	template <typename T, typename std::enable_if_t < !std::is_same_v<T, bool >, int  > = 0>
 	void save(const std::deque<T> & data)
 	{
-		ui32 length = (ui32)data.size();
+		uint32_t length = data.size();
 		*this & length;
-		for(ui32 i = 0; i < length; i++)
+		for(uint32_t i = 0; i < length; i++)
 			save(data[i]);
 	}
 	template <typename T, size_t N>
 	void save(const std::array<T, N> &data)
 	{
-		for(ui32 i=0; i < N; i++)
+		for(uint32_t i=0; i < N; i++)
 			save(data[i]);
 	}
 	template <typename T>
 	void save(const std::set<T> &data)
 	{
 		auto & d = const_cast<std::set<T> &>(data);
-		ui32 length = (ui32)d.size();
+		uint32_t length = d.size();
 		save(length);
 		for(auto i = d.begin(); i != d.end(); i++)
 			save(*i);
@@ -303,7 +302,7 @@
 	void save(const std::unordered_set<T, U> &data)
 	{
 		auto & d = const_cast<std::unordered_set<T, U> &>(data);
-		ui32 length = (ui32)d.size();
+		uint32_t length = d.size();
 		*this & length;
 		for(auto i = d.begin(); i != d.end(); i++)
 			save(*i);
@@ -312,16 +311,47 @@
 	void save(const std::list<T> &data)
 	{
 		auto & d = const_cast<std::list<T> &>(data);
-		ui32 length = (ui32)d.size();
+		uint32_t length = d.size();
 		*this & length;
 		for(auto i = d.begin(); i != d.end(); i++)
 			save(*i);
 	}
+
 	void save(const std::string &data)
 	{
-		save(ui32(data.length()));
-		this->write(static_cast<const void *>(data.data()), data.size());
+		if (hasFeature(Version::COMPACT_STRING_SERIALIZATION))
+		{
+			if (data.empty())
+			{
+				save(static_cast<uint32_t>(0));
+				return;
+			}
+
+			auto it = savedStrings.find(data);
+
+			if (it == savedStrings.end())
+			{
+				save(static_cast<uint32_t>(data.length()));
+				this->write(static_cast<const void *>(data.data()), data.size());
+
+				// -1, -2...
+				int32_t newStringID = -1 - savedStrings.size();
+
+				savedStrings[data] = newStringID;
+			}
+			else
+			{
+				int32_t index = it->second;
+				save(index);
+			}
+		}
+		else
+		{
+			save(static_cast<uint32_t>(data.length()));
+			this->write(static_cast<const void *>(data.data()), data.size());
+		}
 	}
+
 	template <typename T1, typename T2>
 	void save(const std::pair<T1,T2> &data)
 	{
@@ -329,9 +359,19 @@
 		save(data.second);
 	}
 	template <typename T1, typename T2>
+	void save(const std::unordered_map<T1,T2> &data)
+	{
+		*this & static_cast<uint32_t>(data.size());
+		for(auto i = data.begin(); i != data.end(); i++)
+		{
+			save(i->first);
+			save(i->second);
+		}
+	}
+	template <typename T1, typename T2>
 	void save(const std::map<T1,T2> &data)
 	{
-		*this & ui32(data.size());
+		*this & static_cast<uint32_t>(data.size());
 		for(auto i = data.begin(); i != data.end(); i++)
 		{
 			save(i->first);
@@ -341,7 +381,7 @@
 	template <typename T1, typename T2>
 	void save(const std::multimap<T1, T2> &data)
 	{
-		*this & ui32(data.size());
+		*this & static_cast<uint32_t>(data.size());
 		for(auto i = data.begin(); i != data.end(); i++)
 		{
 			save(i->first);
@@ -351,7 +391,7 @@
 	template<typename T0, typename... TN>
 	void save(const std::variant<T0, TN...> & data)
 	{
-		si32 which = data.index();
+		int32_t which = data.index();
 		save(which);
 
 		VariantVisitorSaver<BinarySerializer> visitor(*this);
@@ -362,26 +402,26 @@
 	{
 		if(data)
 		{
-			save((ui8)1);
+			save(static_cast<uint8_t>(1));
 			save(*data);
 		}
 		else
 		{
-			save((ui8)0);
+			save(static_cast<uint32_t>(0));
 		}
 	}
 
 	template <typename T>
 	void save(const boost::multi_array<T, 3> &data)
 	{
-		ui32 length = data.num_elements();
+		uint32_t length = data.num_elements();
 		*this & length;
 		auto shape = data.shape();
-		ui32 x = shape[0];
-		ui32 y = shape[1];
-		ui32 z = shape[2];
+		uint32_t x = shape[0];
+		uint32_t y = shape[1];
+		uint32_t z = shape[2];
 		*this & x & y & z;
-		for(ui32 i = 0; i < length; i++)
+		for(uint32_t i = 0; i < length; i++)
 			save(data.data()[i]);
 	}
 	template <std::size_t T>
diff --color -urN vcmi-1.5.7/lib/serializer/Cast.h vcmi/lib/serializer/Cast.h
--- vcmi-1.5.7/lib/serializer/Cast.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/serializer/Cast.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,26 +0,0 @@
-/*
- * Cast.h, part of VCMI engine
- *
- * Authors: listed in file AUTHORS in main folder
- *
- * License: GNU General Public License v2.0 or later
- * Full text of license available in license.txt file, in main folder
- *
- */
-#pragma once
-
-VCMI_LIB_NAMESPACE_BEGIN
-
-template<class T, class F>
-inline const T * dynamic_ptr_cast(const F * ptr)
-{
-	return dynamic_cast<const T *>(ptr);
-}
-
-template<class T, class F>
-inline T * dynamic_ptr_cast(F * ptr)
-{
-	return dynamic_cast<T *>(ptr);
-}
-
-VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/serializer/CLoadFile.cpp vcmi/lib/serializer/CLoadFile.cpp
--- vcmi-1.5.7/lib/serializer/CLoadFile.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/serializer/CLoadFile.cpp	2024-12-19 15:00:22.935149467 +0100
@@ -29,6 +29,7 @@
 
 void CLoadFile::openNextFile(const boost::filesystem::path & fname, ESerializationVersion minimalVersion)
 {
+	serializer.loadingGamestate = true;
 	assert(!serializer.reverseEndianness);
 	assert(minimalVersion <= ESerializationVersion::CURRENT);
 
diff --color -urN vcmi-1.5.7/lib/serializer/Connection.cpp vcmi/lib/serializer/Connection.cpp
--- vcmi-1.5.7/lib/serializer/Connection.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/serializer/Connection.cpp	2024-12-19 15:00:22.936149508 +0100
@@ -68,7 +68,7 @@
 
 CConnection::~CConnection() = default;
 
-void CConnection::sendPack(const CPack * pack)
+void CConnection::sendPack(const CPack & pack)
 {
 	boost::mutex::scoped_lock lock(writeMutex);
 
@@ -78,17 +78,18 @@
 		throw std::runtime_error("Attempt to send packet on a closed connection!");
 
 	packWriter->buffer.clear();
-	*serializer & pack;
+	(*serializer) & (&pack);
 
-	logNetwork->trace("Sending a pack of type %s", typeid(*pack).name());
+	logNetwork->trace("Sending a pack of type %s", typeid(pack).name());
 
 	connectionPtr->sendPacket(packWriter->buffer);
 	packWriter->buffer.clear();
+	serializer->savedPointers.clear();
 }
 
-CPack * CConnection::retrievePack(const std::vector<std::byte> & data)
+std::unique_ptr<CPack> CConnection::retrievePack(const std::vector<std::byte> & data)
 {
-	CPack * result;
+	std::unique_ptr<CPack> result;
 
 	packReader->buffer = &data;
 	packReader->position = 0;
@@ -101,7 +102,9 @@
 	if (packReader->position != data.size())
 		throw std::runtime_error("Failed to retrieve pack! Not all data has been read!");
 
-	logNetwork->trace("Received CPack of type %s", typeid(*result).name());
+	logNetwork->trace("Received CPack of type %s", typeid(result.get()).name());
+	deserializer->loadedPointers.clear();
+	deserializer->loadedSharedPointers.clear();
 	return result;
 }
 
@@ -132,7 +135,6 @@
 	deserializer->loadedPointers.clear();
 	serializer->savedPointers.clear();
 	disableSmartVectorMemberSerialization();
-	disableSmartPointerSerialization();
 	disableStackSendingByID();
 }
 
@@ -144,24 +146,11 @@
 void CConnection::enterGameplayConnectionMode(CGameState * gs)
 {
 	enableStackSendingByID();
-	disableSmartPointerSerialization();
 
 	setCallback(gs->callback);
 	enableSmartVectorMemberSerializatoin(gs);
 }
 
-void CConnection::disableSmartPointerSerialization()
-{
-	deserializer->smartPointerSerialization = false;
-	serializer->smartPointerSerialization = false;
-}
-
-void CConnection::enableSmartPointerSerialization()
-{
-	deserializer->smartPointerSerialization = true;
-	serializer->smartPointerSerialization = true;
-}
-
 void CConnection::disableSmartVectorMemberSerialization()
 {
 	packReader->smartVectorMembersSerialization = false;
diff --color -urN vcmi-1.5.7/lib/serializer/Connection.h vcmi/lib/serializer/Connection.h
--- vcmi-1.5.7/lib/serializer/Connection.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/serializer/Connection.h	2024-12-19 15:00:22.936149508 +0100
@@ -38,8 +38,6 @@
 
 	void disableStackSendingByID();
 	void enableStackSendingByID();
-	void disableSmartPointerSerialization();
-	void enableSmartPointerSerialization();
 	void disableSmartVectorMemberSerialization();
 	void enableSmartVectorMemberSerializatoin(CGameState * gs);
 
@@ -53,8 +51,8 @@
 	explicit CConnection(std::weak_ptr<INetworkConnection> networkConnection);
 	~CConnection();
 
-	void sendPack(const CPack * pack);
-	CPack * retrievePack(const std::vector<std::byte> & data);
+	void sendPack(const CPack & pack);
+	std::unique_ptr<CPack> retrievePack(const std::vector<std::byte> & data);
 
 	void enterLobbyConnectionMode();
 	void setCallback(IGameCallback * cb);
diff --color -urN vcmi-1.5.7/lib/serializer/CSerializer.cpp vcmi/lib/serializer/CSerializer.cpp
--- vcmi-1.5.7/lib/serializer/CSerializer.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/serializer/CSerializer.cpp	2024-12-19 15:00:22.935149467 +0100
@@ -10,9 +10,9 @@
 #include "StdInc.h"
 #include "CSerializer.h"
 
+#include "../entities/hero/CHero.h"
 #include "../gameState/CGameState.h"
 #include "../mapping/CMap.h"
-#include "../CHeroHandler.h"
 #include "../mapObjects/CGHeroInstance.h"
 #include "../mapObjects/CQuest.h"
 
@@ -25,14 +25,8 @@
 {
 	registerVectoredType<CGObjectInstance, ObjectInstanceID>(&gs->map->objects,
 		[](const CGObjectInstance &obj){ return obj.id; });
-	registerVectoredType<CHero, HeroTypeID>(&lib->heroh->objects,
-		[](const CHero &h){ return h.getId(); });
 	registerVectoredType<CGHeroInstance, HeroTypeID>(&gs->map->allHeroes,
-		[](const CGHeroInstance &h){ return h.type->getId(); });
-	registerVectoredType<CCreature, CreatureID>(&lib->creh->objects,
-		[](const CCreature &cre){ return cre.getId(); });
-	registerVectoredType<CArtifact, ArtifactID>(&lib->arth->objects,
-		[](const CArtifact &art){ return art.getId(); });
+		[](const CGHeroInstance &h){ return h.getHeroType()->getId(); });
 	registerVectoredType<CArtifactInstance, ArtifactInstanceID>(&gs->map->artInstances,
 		[](const CArtifactInstance &artInst){ return artInst.getId(); });
 	registerVectoredType<CQuest, si32>(&gs->map->quests,
diff --color -urN vcmi-1.5.7/lib/serializer/CTypeList.cpp vcmi/lib/serializer/CTypeList.cpp
--- vcmi-1.5.7/lib/serializer/CTypeList.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/serializer/CTypeList.cpp	2024-12-19 15:00:22.935149467 +0100
@@ -10,7 +10,7 @@
 #include "StdInc.h"
 #include "CTypeList.h"
 
-#include "../registerTypes/RegisterTypes.h"
+#include "RegisterTypes.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
diff --color -urN vcmi-1.5.7/lib/serializer/CTypeList.h vcmi/lib/serializer/CTypeList.h
--- vcmi-1.5.7/lib/serializer/CTypeList.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/serializer/CTypeList.h	2024-12-19 15:00:22.936149508 +0100
@@ -36,22 +36,15 @@
 		return registry;
 	}
 
-	template<typename T, typename U>
-	void registerType()
-	{
-		registerType<T>();
-		registerType<U>();
-	}
-
 	template<typename T>
-	void registerType()
+	void registerType(uint16_t index)
 	{
 		const std::type_info & typeInfo = typeid(T);
 
 		if (typeInfos.count(typeInfo.name()) != 0)
 			return;
 
-		typeInfos[typeInfo.name()] = typeInfos.size() + 1;
+		typeInfos[typeInfo.name()] = index;
 	}
 
 	template<typename T>
@@ -69,37 +62,4 @@
 	}
 };
 
-/// Wrapper over CTypeList. Allows execution of templated class T for any type
-/// that was resgistered for this applier
-template<typename T>
-class CApplier : boost::noncopyable
-{
-	std::map<int32_t, std::unique_ptr<T>> apps;
-
-	template<typename RegisteredType>
-	void addApplier(ui16 ID)
-	{
-		if(!apps.count(ID))
-		{
-			RegisteredType * rtype = nullptr;
-			apps[ID].reset(T::getApplier(rtype));
-		}
-	}
-
-public:
-	T * getApplier(ui16 ID)
-	{
-		if(!apps.count(ID))
-			throw std::runtime_error("No applier found.");
-		return apps[ID].get();
-	}
-
-	template<typename Base, typename Derived>
-	void registerType(const Base * b = nullptr, const Derived * d = nullptr)
-	{
-		addApplier<Base>(CTypeList::getInstance().getTypeID<Base>(nullptr));
-		addApplier<Derived>(CTypeList::getInstance().getTypeID<Derived>(nullptr));
-	}
-};
-
 VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/serializer/ESerializationVersion.h vcmi/lib/serializer/ESerializationVersion.h
--- vcmi-1.5.7/lib/serializer/ESerializationVersion.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/serializer/ESerializationVersion.h	2024-12-19 15:00:22.936149508 +0100
@@ -31,25 +31,45 @@
 {
 	NONE = 0,
 
-	MINIMAL = 831,
-
-	RELEASE_143, // 832 +text container in campaigns, +starting hero in RMG options
-	HAS_EXTRA_OPTIONS, // 833 +extra options struct as part of startinfo
-	DESTROYED_OBJECTS, // 834 +list of objects destroyed by player
-	CAMPAIGN_MAP_TRANSLATIONS, // 835 +campaigns include translations for its maps
-	JSON_FLAGS, // 836 json uses new format for flags
-	MANA_LIMIT,	// 837 change MANA_PER_KNOWLEGDE to percentage
-	BONUS_META_STRING,	// 838 bonuses use MetaString instead of std::string for descriptions
-	TURN_TIMERS_STATE, // 839 current state of turn timers is serialized
-	ARTIFACT_COSTUMES, // 840 swappable artifacts set added
-
-	RELEASE_150 = ARTIFACT_COSTUMES, // for convenience
+	RELEASE_150 = 840,
+	MINIMAL = RELEASE_150,
 
 	VOTING_SIMTURNS, // 841 - allow modification of simturns duration via vote
 	REMOVE_TEXT_CONTAINER_SIZE_T, // 842 Fixed serialization of size_t from text containers
 	BANK_UNIT_PLACEMENT, // 843 Banks have unit placement flag
 
-	RELEASE_152 = BANK_UNIT_PLACEMENT,
+	RELEASE_156 = BANK_UNIT_PLACEMENT,
 
-	CURRENT = BANK_UNIT_PLACEMENT
+	COMPACT_STRING_SERIALIZATION, // 844 - optimized serialization of previously encountered strings
+	COMPACT_INTEGER_SERIALIZATION, // 845 - serialize integers in forms similar to protobuf
+	REMOVE_FOG_OF_WAR_POINTER, // 846 - fog of war is serialized as reference instead of pointer
+	SIMPLE_TEXT_CONTAINER_SERIALIZATION, // 847 - text container is serialized using common routine instead of custom approach
+	MAP_FORMAT_ADDITIONAL_INFOS, // 848 - serialize new infos in map format
+	REMOVE_LIB_RNG, // 849 - removed random number generators from library classes
+	HIGHSCORE_PARAMETERS, // 850 - saves parameter for campaign
+	PLAYER_HANDICAP, // 851 - player handicap selection at game start
+	STATISTICS, // 852 - removed random number generators from library classes
+	CAMPAIGN_REGIONS, // 853 - configurable campaign regions
+	EVENTS_PLAYER_SET, // 854 - map & town events use std::set instead of bitmask to store player list
+	NEW_TOWN_BUILDINGS, // 855 - old bonusing buildings have been removed
+	STATISTICS_SCREEN, // 856 - extent statistic functions
+	NEW_MARKETS, // 857 - reworked market classes
+	PLAYER_STATE_OWNED_OBJECTS, // 858 - player state stores all owned objects in a single list
+	SAVE_COMPATIBILITY_FIXES, // 859 - implementation of previoulsy postponed changes to serialization
+	CHRONICLES_SUPPORT, // 860 - support for heroes chronicles
+	PER_MAP_GAME_SETTINGS, // 861 - game settings are now stored per-map
+	CAMPAIGN_OUTRO_SUPPORT, // 862 - support for campaign outro video
+	REWARDABLE_BANKS, // 863 - team state contains list of scouted objects, coast visitable rewardable objects
+	REGION_LABEL, // 864 - labels for campaign regions
+	SPELL_RESEARCH, // 865 - spell research
+	LOCAL_PLAYER_STATE_DATA, // 866 - player state contains arbitrary client-side data
+	REMOVE_TOWN_PTR, // 867 - removed pointer to CTown from CGTownInstance
+	REMOVE_OBJECT_TYPENAME, // 868 - remove typename from CGObjectInstance
+	REMOVE_VLC_POINTERS, // 869 removed remaining pointers to VLC entities
+	FOLDER_NAME_REWORK, // 870 - rework foldername
+	REWARDABLE_GUARDS, // 871 - fix missing serialization of guards in rewardable objects
+	MARKET_TRANSLATION_FIX, // 872 - remove serialization of markets translateable strings
+	EVENT_OBJECTS_DELETION, //873 - allow events to remove map objects
+	
+	CURRENT = EVENT_OBJECTS_DELETION
 };
diff --color -urN vcmi-1.5.7/lib/serializer/RegisterTypes.h vcmi/lib/serializer/RegisterTypes.h
--- vcmi-1.5.7/lib/serializer/RegisterTypes.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/serializer/RegisterTypes.h	2024-12-19 15:00:22.937149549 +0100
@@ -0,0 +1,300 @@
+/*
+ * RegisterTypes.h, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#pragma once
+
+#include "../CPlayerState.h"
+#include "../CStack.h"
+#include "../battle/BattleInfo.h"
+#include "../battle/CObstacleInstance.h"
+#include "../bonuses/Limiters.h"
+#include "../bonuses/Propagators.h"
+#include "../bonuses/Updaters.h"
+#include "../campaign/CampaignState.h"
+#include "../gameState/CGameState.h"
+#include "../gameState/CGameStateCampaign.h"
+#include "../gameState/TavernHeroesPool.h"
+
+#include "../mapObjects/CGCreature.h"
+#include "../mapObjects/CGDwelling.h"
+#include "../mapObjects/CGMarket.h"
+#include "../mapObjects/CGPandoraBox.h"
+#include "../mapObjects/CGTownInstance.h"
+#include "../mapObjects/CQuest.h"
+#include "../mapObjects/FlaggableMapObject.h"
+#include "../mapObjects/MiscObjects.h"
+#include "../mapObjects/TownBuildingInstance.h"
+
+#include "../mapping/CMap.h"
+#include "../networkPacks/PacksForClient.h"
+#include "../networkPacks/PacksForClientBattle.h"
+#include "../networkPacks/PacksForLobby.h"
+#include "../networkPacks/PacksForServer.h"
+#include "../networkPacks/SaveLocalState.h"
+#include "../networkPacks/SetRewardableConfiguration.h"
+#include "../networkPacks/SetStackEffect.h"
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+/// This method defines all types that are part of Serializeable hieararchy and can be serialized as their base type
+/// Each class is registered with a unique index that is used to determine correct type on deserialization
+/// For example, if CGHeroInstance is serialized as pointer to CGObjectInstance serializer will write type index for CGHeroInstance, followed by CGHeroInstance::serialize() call
+/// Similarly, on deserialize, game will look up type index of object that was serialized as this CGObjectInstance and will load it as CGHeroInstance instead
+/// Meaning, these type indexes must NEVER change.
+/// If type is removed please only remove corresponding type, without adjusting indexes of following types
+/// NOTE: when removing type please consider potential save compatibility handling
+/// Similarly, when adding new type make sure to add it to the very end of this list with new type index
+template<typename Serializer>
+void registerTypes(Serializer &s)
+{
+	static_assert(std::is_abstract_v<IObjectInterface>, "If this type is no longer abstract consider registering it for serialization with ID 1");
+	static_assert(std::is_abstract_v<CGTeleport>, "If this type is no longer abstract consider registering it for serialization with ID 3");
+	static_assert(std::is_abstract_v<IQuestObject>, "If this type is no longer abstract consider registering it for serialization with ID 11");
+	static_assert(std::is_abstract_v<CArtifactSet>, "If this type is no longer abstract consider registering it for serialization with ID 29");
+	static_assert(std::is_abstract_v<CPackForClient>, "If this type is no longer abstract consider registering it for serialization with ID 83");
+	static_assert(std::is_abstract_v<Query>, "If this type is no longer abstract consider registering it for serialization with ID 153");
+	static_assert(std::is_abstract_v<CGarrisonOperationPack>, "If this type is no longer abstract consider registering it for serialization with ID 161");
+	static_assert(std::is_abstract_v<CArtifactOperationPack>, "If this type is no longer abstract consider registering it for serialization with ID 168");
+
+	s.template registerType<CGObjectInstance>(2);
+	s.template registerType<CGMonolith>(4);
+	s.template registerType<CGSubterraneanGate>(5);
+	s.template registerType<CGWhirlpool>(6);
+	s.template registerType<CGSignBottle>(7);
+	s.template registerType<CGKeys>(8);
+	s.template registerType<CGKeymasterTent>(9);
+	s.template registerType<CGBorderGuard>(10);
+	s.template registerType<CGBorderGate>(12);
+	s.template registerType<CGBoat>(13);
+	s.template registerType<CGMagi>(14);
+	s.template registerType<CGSirens>(15);
+	s.template registerType<CGShipyard>(16);
+	s.template registerType<CGDenOfthieves>(17);
+	s.template registerType<FlaggableMapObject>(18);
+	s.template registerType<CGTerrainPatch>(19);
+	s.template registerType<HillFort>(20);
+	s.template registerType<CGMarket>(21);
+	s.template registerType<CGBlackMarket>(22);
+	s.template registerType<CGUniversity>(23);
+	s.template registerType<CGHeroPlaceholder>(24);
+	s.template registerType<CArmedInstance>(25);
+	s.template registerType<CBonusSystemNode>(26);
+	s.template registerType<CCreatureSet>(27);
+	s.template registerType<CGHeroInstance>(28);
+	s.template registerType<CGDwelling>(30);
+	s.template registerType<CGTownInstance>(31);
+	s.template registerType<CGPandoraBox>(32);
+	s.template registerType<CGEvent>(33);
+	s.template registerType<CGCreature>(34);
+	s.template registerType<CGGarrison>(35);
+	s.template registerType<CGArtifact>(36);
+	s.template registerType<CGResource>(37);
+	s.template registerType<CGMine>(38);
+	s.template registerType<CBank>(39);
+	s.template registerType<CGSeerHut>(40);
+	s.template registerType<CGQuestGuard>(41);
+	s.template registerType<IUpdater>(42);
+	s.template registerType<GrowsWithLevelUpdater>(43);
+	s.template registerType<TimesHeroLevelUpdater>(44);
+	s.template registerType<TimesStackLevelUpdater>(45);
+	s.template registerType<OwnerUpdater>(46);
+	s.template registerType<ArmyMovementUpdater>(47);
+	s.template registerType<ILimiter>(48);
+	s.template registerType<AnyOfLimiter>(49);
+	s.template registerType<NoneOfLimiter>(50);
+	s.template registerType<OppositeSideLimiter>(51);
+	s.template registerType<TownBuildingInstance>(52);
+	s.template registerType<TownRewardableBuildingInstance>(53);
+	s.template registerType<CRewardableObject>(56);
+	s.template registerType<CTeamVisited>(57);
+	s.template registerType<CGObelisk>(58);
+	s.template registerType<IPropagator>(59);
+	s.template registerType<CPropagatorNodeType>(60);
+	s.template registerType<AllOfLimiter>(61);
+	s.template registerType<CCreatureTypeLimiter>(62);
+	s.template registerType<HasAnotherBonusLimiter>(63);
+	s.template registerType<CreatureTerrainLimiter>(64);
+	s.template registerType<FactionLimiter>(65);
+	s.template registerType<CreatureLevelLimiter>(66);
+	s.template registerType<CreatureAlignmentLimiter>(67);
+	s.template registerType<RankRangeLimiter>(68);
+	s.template registerType<UnitOnHexLimiter>(69);
+	s.template registerType<CArtifact>(70);
+	s.template registerType<CCreature>(71);
+	s.template registerType<CStackInstance>(72);
+	s.template registerType<CCommanderInstance>(73);
+	s.template registerType<PlayerState>(74);
+	s.template registerType<TeamState>(75);
+	s.template registerType<CStack>(76);
+	s.template registerType<BattleInfo>(77);
+	s.template registerType<CArtifactInstance>(78);
+	s.template registerType<CObstacleInstance>(79);
+	s.template registerType<SpellCreatedObstacle>(80);
+	s.template registerType<CPack>(82);
+	s.template registerType<PackageApplied>(84);
+	s.template registerType<SystemMessage>(85);
+	s.template registerType<PlayerBlocked>(86);
+	s.template registerType<PlayerCheated>(87);
+	s.template registerType<PlayerStartsTurn>(88);
+	s.template registerType<DaysWithoutTown>(89);
+	s.template registerType<TurnTimeUpdate>(90);
+	s.template registerType<SetResources>(91);
+	s.template registerType<SetPrimSkill>(92);
+	s.template registerType<SetSecSkill>(93);
+	s.template registerType<HeroVisitCastle>(94);
+	s.template registerType<ChangeSpells>(95);
+	s.template registerType<SetMana>(96);
+	s.template registerType<SetMovePoints>(97);
+	s.template registerType<FoWChange>(98);
+	s.template registerType<SetAvailableHero>(99);
+	s.template registerType<GiveBonus>(100);
+	s.template registerType<ChangeObjPos>(101);
+	s.template registerType<PlayerEndsTurn>(102);
+	s.template registerType<PlayerEndsGame>(103);
+	s.template registerType<PlayerReinitInterface>(104);
+	s.template registerType<RemoveBonus>(105);
+	s.template registerType<UpdateArtHandlerLists>(106);
+	s.template registerType<ChangeFormation>(107);
+	s.template registerType<RemoveObject>(108);
+	s.template registerType<TryMoveHero>(109);
+	s.template registerType<NewStructures>(110);
+	s.template registerType<RazeStructures>(111);
+	s.template registerType<SetAvailableCreatures>(112);
+	s.template registerType<SetHeroesInTown>(113);
+	s.template registerType<HeroRecruited>(114);
+	s.template registerType<GiveHero>(115);
+	s.template registerType<NewTurn>(116);
+	s.template registerType<InfoWindow>(117);
+	s.template registerType<SetObjectProperty>(118);
+	s.template registerType<AdvmapSpellCast>(119);
+	s.template registerType<OpenWindow>(120);
+	s.template registerType<NewObject>(121);
+	s.template registerType<NewArtifact>(122);
+	s.template registerType<AddQuest>(123);
+	s.template registerType<SetAvailableArtifacts>(124);
+	s.template registerType<CenterView>(125);
+	s.template registerType<HeroVisit>(126);
+	s.template registerType<SetCommanderProperty>(127);
+	s.template registerType<ChangeObjectVisitors>(128);
+	s.template registerType<ChangeArtifactsCostume>(129);
+	s.template registerType<ShowWorldViewEx>(130);
+	s.template registerType<EntitiesChanged>(131);
+	s.template registerType<BattleStart>(132);
+	s.template registerType<BattleNextRound>(133);
+	s.template registerType<BattleSetActiveStack>(134);
+	s.template registerType<BattleResult>(135);
+	s.template registerType<BattleResultAccepted>(136);
+	s.template registerType<BattleCancelled>(137);
+	s.template registerType<BattleLogMessage>(138);
+	s.template registerType<BattleStackMoved>(139);
+	s.template registerType<BattleAttack>(140);
+	s.template registerType<StartAction>(141);
+	s.template registerType<EndAction>(142);
+	s.template registerType<BattleSpellCast>(143);
+	s.template registerType<SetStackEffect>(144);
+	s.template registerType<BattleTriggerEffect>(145);
+	s.template registerType<BattleUpdateGateState>(146);
+	s.template registerType<BattleSetStackProperty>(147);
+	s.template registerType<StacksInjured>(148);
+	s.template registerType<BattleResultsApplied>(149);
+	s.template registerType<BattleUnitsChanged>(150);
+	s.template registerType<BattleObstaclesChanged>(151);
+	s.template registerType<CatapultAttack>(152);
+	s.template registerType<HeroLevelUp>(154);
+	s.template registerType<CommanderLevelUp>(155);
+	s.template registerType<BlockingDialog>(156);
+	s.template registerType<GarrisonDialog>(157);
+	s.template registerType<ExchangeDialog>(158);
+	s.template registerType<TeleportDialog>(159);
+	s.template registerType<MapObjectSelectDialog>(160);
+	s.template registerType<ChangeStackCount>(162);
+	s.template registerType<SetStackType>(163);
+	s.template registerType<EraseStack>(164);
+	s.template registerType<SwapStacks>(165);
+	s.template registerType<InsertNewStack>(166);
+	s.template registerType<RebalanceStacks>(167);
+	s.template registerType<PutArtifact>(169);
+	s.template registerType<BulkEraseArtifacts>(170);
+	s.template registerType<AssembledArtifact>(171);
+	s.template registerType<DisassembledArtifact>(172);
+	s.template registerType<BulkMoveArtifacts>(173);
+	s.template registerType<PlayerMessageClient>(174);
+	s.template registerType<BulkRebalanceStacks>(175);
+	s.template registerType<BulkSmartRebalanceStacks>(176);
+	s.template registerType<SetRewardableConfiguration>(177);
+	s.template registerType<SetBankConfiguration>(178);
+	s.template registerType<CPackForServer>(179);
+	s.template registerType<EndTurn>(180);
+	s.template registerType<DismissHero>(181);
+	s.template registerType<MoveHero>(182);
+	s.template registerType<ArrangeStacks>(183);
+	s.template registerType<DisbandCreature>(184);
+	s.template registerType<BuildStructure>(185);
+	s.template registerType<VisitTownBuilding>(186);
+	s.template registerType<RecruitCreatures>(187);
+	s.template registerType<UpgradeCreature>(188);
+	s.template registerType<GarrisonHeroSwap>(189);
+	s.template registerType<ExchangeArtifacts>(190);
+	s.template registerType<AssembleArtifacts>(191);
+	s.template registerType<BuyArtifact>(192);
+	s.template registerType<TradeOnMarketplace>(193);
+	s.template registerType<SetFormation>(194);
+	s.template registerType<HireHero>(195);
+	s.template registerType<BuildBoat>(196);
+	s.template registerType<QueryReply>(197);
+	s.template registerType<MakeAction>(198);
+	s.template registerType<DigWithHero>(199);
+	s.template registerType<CastAdvSpell>(200);
+	s.template registerType<CastleTeleportHero>(201);
+	s.template registerType<SaveGame>(202);
+	s.template registerType<PlayerMessage>(203);
+	s.template registerType<BulkSplitStack>(204);
+	s.template registerType<BulkMergeStacks>(205);
+	s.template registerType<BulkSmartSplitStack>(206);
+	s.template registerType<BulkMoveArmy>(207);
+	s.template registerType<BulkExchangeArtifacts>(208);
+	s.template registerType<ManageBackpackArtifacts>(209);
+	s.template registerType<ManageEquippedArtifacts>(210);
+	s.template registerType<EraseArtifactByClient>(211);
+	s.template registerType<GamePause>(212);
+	s.template registerType<CPackForLobby>(213);
+	s.template registerType<CLobbyPackToPropagate>(214);
+	s.template registerType<CLobbyPackToServer>(215);
+	s.template registerType<LobbyClientConnected>(216);
+	s.template registerType<LobbyClientDisconnected>(217);
+	s.template registerType<LobbyChatMessage>(218);
+	s.template registerType<LobbyPvPAction>(219);
+	s.template registerType<LobbyGuiAction>(220);
+	s.template registerType<LobbyLoadProgress>(221);
+	s.template registerType<LobbyRestartGame>(222);
+	s.template registerType<LobbyPrepareStartGame>(223);
+	s.template registerType<LobbyStartGame>(224);
+	s.template registerType<LobbyChangeHost>(225);
+	s.template registerType<LobbyUpdateState>(226);
+	s.template registerType<LobbyShowMessage>(227);
+	s.template registerType<LobbyChangePlayerOption>(228);
+	s.template registerType<LobbySetMap>(229);
+	s.template registerType<LobbySetCampaign>(230);
+	s.template registerType<LobbySetCampaignMap>(231);
+	s.template registerType<LobbySetCampaignBonus>(232);
+	s.template registerType<LobbySetPlayer>(233);
+	s.template registerType<LobbySetPlayerName>(234);
+	s.template registerType<LobbySetPlayerHandicap>(235);
+	s.template registerType<LobbySetTurnTime>(236);
+	s.template registerType<LobbySetSimturns>(237);
+	s.template registerType<LobbySetDifficulty>(238);
+	s.template registerType<LobbyForceSetPlayer>(239);
+	s.template registerType<LobbySetExtraOptions>(240);
+	s.template registerType<SpellResearch>(241);
+	s.template registerType<SetResearchedSpells>(242);
+	s.template registerType<SaveLocalState>(243);
+	s.template registerType<LobbyDelete>(244);
+}
+
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/serializer/Serializeable.h vcmi/lib/serializer/Serializeable.h
--- vcmi-1.5.7/lib/serializer/Serializeable.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/serializer/Serializeable.h	2024-12-19 15:00:22.937149549 +0100
@@ -0,0 +1,21 @@
+/*
+ * Serializeable.h, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#pragma once
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+// Tag class that acts as base for all classes that can be serialized by pointer
+class Serializeable
+{
+public:
+    virtual ~Serializeable() = default;
+};
+
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/serializer/SerializerReflection.cpp vcmi/lib/serializer/SerializerReflection.cpp
--- vcmi-1.5.7/lib/serializer/SerializerReflection.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/serializer/SerializerReflection.cpp	2024-12-19 15:00:22.937149549 +0100
@@ -0,0 +1,106 @@
+/*
+ * SerializerReflection.cpp, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#include "StdInc.h"
+#include "SerializerReflection.h"
+
+#include "BinaryDeserializer.h"
+#include "BinarySerializer.h"
+
+#include "RegisterTypes.h"
+
+#include "../GameSettings.h"
+#include "../RiverHandler.h"
+#include "../RoadHandler.h"
+#include "../TerrainHandler.h"
+#include "../entities/hero/CHero.h"
+#include "../mapObjects/ObjectTemplate.h"
+#include "../mapping/CMapInfo.h"
+#include "../rmg/CMapGenOptions.h"
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+template<typename Type>
+class SerializerReflection final : public ISerializerReflection
+{
+public:
+	Serializeable * createPtr(BinaryDeserializer &ar, IGameCallback * cb) const override
+	{
+		return ClassObjectCreator<Type>::invoke(cb);
+	}
+
+	void loadPtr(BinaryDeserializer &ar, IGameCallback * cb, Serializeable * data) const override
+	{
+		auto * realPtr = dynamic_cast<Type *>(data);
+		realPtr->serialize(ar);
+	}
+
+	void savePtr(BinarySerializer &s, const Serializeable *data) const override
+	{
+		const Type *ptr = dynamic_cast<const Type*>(data);
+		const_cast<Type*>(ptr)->serialize(s);
+	}
+};
+
+template<typename Type, ESerializationVersion maxVersion>
+class SerializerCompatibility : public ISerializerReflection
+{
+public:
+	Serializeable * createPtr(BinaryDeserializer &ar, IGameCallback * cb) const override
+	{
+		return ClassObjectCreator<Type>::invoke(cb);
+	}
+
+	void savePtr(BinarySerializer &s, const Serializeable *data) const override
+	{
+		throw std::runtime_error("Illegal call to savePtr - this type should not be used for serialization!");
+	}
+};
+
+class SerializerCompatibilityBonusingBuilding final : public SerializerCompatibility<TownRewardableBuildingInstance, ESerializationVersion::NEW_TOWN_BUILDINGS>
+{
+	void loadPtr(BinaryDeserializer &ar, IGameCallback * cb, Serializeable * data) const override
+	{
+		auto * realPtr = dynamic_cast<TownRewardableBuildingInstance *>(data);
+		realPtr->serialize(ar);
+	}
+};
+
+class SerializerCompatibilityArtifactsAltar final : public SerializerCompatibility<CGMarket, ESerializationVersion::NEW_MARKETS>
+{
+	void loadPtr(BinaryDeserializer &ar, IGameCallback * cb, Serializeable * data) const override
+	{
+		auto * realPtr = dynamic_cast<CGMarket *>(data);
+		realPtr->serializeArtifactsAltar(ar);
+	}
+};
+
+template<typename Type>
+void CSerializationApplier::registerType(uint16_t ID)
+{
+	assert(!apps.count(ID));
+	apps[ID].reset(new SerializerReflection<Type>);
+}
+
+CSerializationApplier::CSerializationApplier()
+{
+	registerTypes(*this);
+
+	apps[54].reset(new SerializerCompatibilityBonusingBuilding);
+	apps[55].reset(new SerializerCompatibilityBonusingBuilding);
+	apps[81].reset(new SerializerCompatibilityArtifactsAltar);
+}
+
+CSerializationApplier & CSerializationApplier::getInstance()
+{
+	static CSerializationApplier registry;
+	return registry;
+}
+
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/serializer/SerializerReflection.h vcmi/lib/serializer/SerializerReflection.h
--- vcmi-1.5.7/lib/serializer/SerializerReflection.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/serializer/SerializerReflection.h	2024-12-19 15:00:22.937149549 +0100
@@ -0,0 +1,70 @@
+/*
+ * SerializerReflection.h, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#pragma once
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+class IGameCallback;
+class Serializeable;
+class GameCallbackHolder;
+class BinaryDeserializer;
+class BinarySerializer;
+class GameCallbackHolder;
+
+template <typename T, typename Enable = void>
+struct ClassObjectCreator
+{
+	static T *invoke(IGameCallback *cb)
+	{
+		static_assert(!std::is_base_of_v<GameCallbackHolder, T>, "Cannot call new upon map objects!");
+		static_assert(!std::is_abstract_v<T>, "Cannot call new upon abstract classes!");
+		return new T();
+	}
+};
+
+template<typename T>
+struct ClassObjectCreator<T, typename std::enable_if_t<std::is_base_of_v<GameCallbackHolder, T>>>
+{
+	static T *invoke(IGameCallback *cb)
+	{
+		static_assert(!std::is_abstract_v<T>, "Cannot call new upon abstract classes!");
+		return new T(cb);
+	}
+};
+
+class ISerializerReflection
+{
+public:
+	virtual Serializeable * createPtr(BinaryDeserializer &ar, IGameCallback * cb) const =0;
+	virtual void loadPtr(BinaryDeserializer &ar, IGameCallback * cb, Serializeable * data) const =0;
+	virtual void savePtr(BinarySerializer &ar, const Serializeable *data) const =0;
+	virtual ~ISerializerReflection() = default;
+};
+
+class DLL_LINKAGE CSerializationApplier : boost::noncopyable
+{
+	std::map<int32_t, std::unique_ptr<ISerializerReflection>> apps;
+
+	CSerializationApplier();
+public:
+	ISerializerReflection * getApplier(uint16_t ID)
+	{
+		if(!apps.count(ID))
+			throw std::runtime_error("No applier found.");
+		return apps[ID].get();
+	}
+
+	template<typename Type>
+	void registerType(uint16_t index);
+
+	static CSerializationApplier & getInstance();
+};
+
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/spells/AdventureSpellMechanics.cpp vcmi/lib/spells/AdventureSpellMechanics.cpp
--- vcmi-1.5.7/lib/spells/AdventureSpellMechanics.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/spells/AdventureSpellMechanics.cpp	2024-12-19 15:00:22.937149549 +0100
@@ -17,14 +17,15 @@
 
 #include "../CGameInfoCallback.h"
 #include "../CPlayerState.h"
-#include "../CRandomGenerator.h"
-#include "../GameSettings.h"
+#include "../IGameSettings.h"
 #include "../mapObjects/CGHeroInstance.h"
 #include "../mapObjects/CGTownInstance.h"
 #include "../mapObjects/MiscObjects.h"
 #include "../mapping/CMap.h"
 #include "../networkPacks/PacksForClient.h"
 
+#include <vstd/RNG.h>
+
 VCMI_LIB_NAMESPACE_BEGIN
 
 ///AdventureSpellMechanics
@@ -104,7 +105,7 @@
 			GiveBonus gb;
 			gb.id = ObjectInstanceID(parameters.caster->getCasterUnitId());
 			gb.bonus = b;
-			env->apply(&gb);
+			env->apply(gb);
 		}
 
 		return ESpellCastResult::OK;
@@ -135,7 +136,7 @@
 	AdvmapSpellCast asc;
 	asc.casterID = ObjectInstanceID(parameters.caster->getCasterUnitId());
 	asc.spellID = owner->id;
-	env->apply(&asc);
+	env->apply(asc);
 
 	ESpellCastResult result = applyAdventureEffects(env, parameters);
 
@@ -187,13 +188,13 @@
 	const auto schoolLevel = parameters.caster->getSpellSchoolLevel(owner);
 
 	//check if spell works at all
-	if(env->getRNG()->getInt64Range(0, 99)() >= owner->getLevelPower(schoolLevel)) //power is % chance of success
+	if(env->getRNG()->nextInt(0, 99) >= owner->getLevelPower(schoolLevel)) //power is % chance of success
 	{
 		InfoWindow iw;
 		iw.player = parameters.caster->getCasterOwner();
 		iw.text.appendLocalString(EMetaText::GENERAL_TXT, 336); //%s tried to summon a boat, but failed.
 		parameters.caster->getCasterName(iw.text);
-		env->apply(&iw);
+		env->apply(iw);
 		return ESpellCastResult::OK;
 	}
 
@@ -208,7 +209,7 @@
 			if(b->hero || b->layer != EPathfindingLayer::SAIL)
 				continue; //we're looking for unoccupied boat
 
-			double nDist = b->pos.dist2d(parameters.caster->getHeroCaster()->visitablePos());
+			double nDist = b->visitablePos().dist2d(parameters.caster->getHeroCaster()->visitablePos());
 			if(!nearest || nDist < dist) //it's first boat or closer than previous
 			{
 				nearest = b;
@@ -225,24 +226,19 @@
 		cop.objid = nearest->id;
 		cop.nPos = summonPos;
 		cop.initiator = parameters.caster->getCasterOwner();
-		env->apply(&cop);
+		env->apply(cop);
 	}
 	else if(schoolLevel < 2) //none or basic level -> cannot create boat :(
 	{
 		InfoWindow iw;
 		iw.player = parameters.caster->getCasterOwner();
 		iw.text.appendLocalString(EMetaText::GENERAL_TXT, 335); //There are no boats to summon.
-		env->apply(&iw);
+		env->apply(iw);
 		return ESpellCastResult::ERROR;
 	}
 	else //create boat
 	{
-		NewObject no;
-		no.ID = Obj::BOAT;
-		no.subID = BoatId::NECROPOLIS;
-		no.targetPos = summonPos;
-		no.initiator = parameters.caster->getCasterOwner();
-		env->apply(&no);
+		env->createBoat(summonPos, BoatId::NECROPOLIS, parameters.caster->getCasterOwner());
 	}
 	return ESpellCastResult::OK;
 }
@@ -280,13 +276,13 @@
 {
 	const auto schoolLevel = parameters.caster->getSpellSchoolLevel(owner);
 	//check if spell works at all
-	if(env->getRNG()->getInt64Range(0, 99)() >= owner->getLevelPower(schoolLevel)) //power is % chance of success
+	if(env->getRNG()->nextInt(0, 99) >= owner->getLevelPower(schoolLevel)) //power is % chance of success
 	{
 		InfoWindow iw;
 		iw.player = parameters.caster->getCasterOwner();
 		iw.text.appendLocalString(EMetaText::GENERAL_TXT, 337); //%s tried to scuttle the boat, but failed
 		parameters.caster->getCasterName(iw.text);
-		env->apply(&iw);
+		env->apply(iw);
 		return ESpellCastResult::OK;
 	}
 
@@ -295,7 +291,7 @@
 	RemoveObject ro;
 	ro.initiator = parameters.caster->getCasterOwner();
 	ro.objectID = t.visitableObjects.back()->id;
-	env->apply(&ro);
+	env->apply(ro);
 	return ESpellCastResult::OK;
 }
 
@@ -324,7 +320,7 @@
 	int castsAlreadyPerformedThisTurn = caster->getHeroCaster()->getBonuses(Selector::source(BonusSource::SPELL_EFFECT, BonusSourceID(owner->id)), Selector::all, cachingStr.str())->size();
 	int castsLimit = owner->getLevelPower(schoolLevel);
 
-	bool isTournamentRulesLimitEnabled = VLC->settings()->getBoolean(EGameSettings::DIMENSION_DOOR_TOURNAMENT_RULES_LIMIT);
+	bool isTournamentRulesLimitEnabled = cb->getSettings().getBoolean(EGameSettings::DIMENSION_DOOR_TOURNAMENT_RULES_LIMIT);
 	if(isTournamentRulesLimitEnabled)
 	{
 		int3 mapSize = cb->getMapSize();
@@ -351,7 +347,7 @@
 	if(!cb->isInTheMap(pos))
 		return false;
 
-	if(VLC->settings()->getBoolean(EGameSettings::DIMENSION_DOOR_ONLY_TO_UNCOVERED_TILES))
+	if(cb->getSettings().getBoolean(EGameSettings::DIMENSION_DOOR_ONLY_TO_UNCOVERED_TILES))
 	{
 		if(!cb->isVisible(pos, caster->getCasterOwner()))
 			return false;
@@ -371,14 +367,14 @@
 	if(!isInScreenRange(casterPosition, pos))
 		return false;
 
-	if(VLC->settings()->getBoolean(EGameSettings::DIMENSION_DOOR_EXPOSES_TERRAIN_TYPE))
+	if(cb->getSettings().getBoolean(EGameSettings::DIMENSION_DOOR_EXPOSES_TERRAIN_TYPE))
 	{
 		if(!dest->isClear(curr))
 			return false;
 	}
 	else
 	{
-		if (dest->blocked)
+		if (dest->blocked())
 			return false;
 	}
 
@@ -400,18 +396,18 @@
 		iw.player = parameters.caster->getCasterOwner();
 
 		// tile is either blocked or not possible to move (e.g. water <-> land)
-		if(VLC->settings()->getBoolean(EGameSettings::DIMENSION_DOOR_FAILURE_SPENDS_POINTS))
+		if(env->getCb()->getSettings().getBoolean(EGameSettings::DIMENSION_DOOR_FAILURE_SPENDS_POINTS))
 		{
 			// SOD: DD to such "wrong" terrain results in mana and move points spending, but fails to move hero
 			iw.text = MetaString::createFromTextID("core.genrltxt.70"); // Dimension Door failed!
-			env->apply(&iw);
+			env->apply(iw);
 			// no return - resources will be spent
 		}
 		else
 		{
 			// HotA: game will show error message without taking mana or move points, even when DD into terra incognita
 			iw.text = MetaString::createFromTextID("vcmi.dimensionDoor.seaToLandError");
-			env->apply(&iw);
+			env->apply(iw);
 			return ESpellCastResult::CANCEL;
 		}
 	}
@@ -419,7 +415,7 @@
 	GiveBonus gb;
 	gb.id = ObjectInstanceID(parameters.caster->getCasterUnitId());
 	gb.bonus = Bonus(BonusDuration::ONE_DAY, BonusType::NONE, BonusSource::SPELL_EFFECT, 0, BonusSourceID(owner->id));
-	env->apply(&gb);
+	env->apply(gb);
 
 	SetMovePoints smp;
 	smp.hid = ObjectInstanceID(parameters.caster->getCasterUnitId());
@@ -427,7 +423,7 @@
 		smp.val = parameters.caster->getHeroCaster()->movementPointsRemaining() - movementCost;
 	else
 		smp.val = 0;
-	env->apply(&smp);
+	env->apply(smp);
 
 	return ESpellCastResult::OK;
 }
@@ -475,7 +471,7 @@
 			InfoWindow iw;
 			iw.player = parameters.caster->getCasterOwner();
 			iw.text.appendLocalString(EMetaText::GENERAL_TXT, 123);
-			env->apply(&iw);
+			env->apply(iw);
 			return ESpellCastResult::CANCEL;
 		}
 	}
@@ -543,7 +539,7 @@
 		InfoWindow iw;
 		iw.player = parameters.caster->getCasterOwner();
 		iw.text.appendLocalString(EMetaText::GENERAL_TXT, 135);
-		env->apply(&iw);
+		env->apply(iw);
 		return ESpellCastResult::ERROR;
 	}
 
@@ -572,7 +568,7 @@
 		SetMovePoints smp;
 		smp.hid = ObjectInstanceID(parameters.caster->getCasterUnitId());
 		smp.val = std::max<ui32>(0, parameters.caster->getHeroCaster()->movementPointsRemaining() - moveCost);
-		env->apply(&smp);
+		env->apply(smp);
 	}
 }
 
@@ -591,7 +587,7 @@
 		InfoWindow iw;
 		iw.player = parameters.caster->getCasterOwner();
 		iw.text.appendLocalString(EMetaText::GENERAL_TXT, 124);
-		env->apply(&iw);
+		env->apply(iw);
 		return ESpellCastResult::CANCEL;
 	}
 
@@ -602,7 +598,7 @@
 		InfoWindow iw;
 		iw.player = parameters.caster->getCasterOwner();
 		iw.text.appendLocalString(EMetaText::GENERAL_TXT, 125);
-		env->apply(&iw);
+		env->apply(iw);
 		return ESpellCastResult::CANCEL;
 	}
 
@@ -647,7 +643,7 @@
 			InfoWindow iw;
 			iw.player = parameters.caster->getCasterOwner();
 			iw.text.appendLocalString(EMetaText::GENERAL_TXT, 124);
-			env->apply(&iw);
+			env->apply(iw);
 			return ESpellCastResult::CANCEL;
 		}
 
@@ -673,11 +669,11 @@
 		return nullptr;
 
 	auto nearest = pool.cbegin(); //nearest town's iterator
-	si32 dist = (*nearest)->pos.dist2dSQ(parameters.caster->getHeroCaster()->pos);
+	si32 dist = (*nearest)->visitablePos().dist2dSQ(parameters.caster->getHeroCaster()->visitablePos());
 
 	for(auto i = nearest + 1; i != pool.cend(); ++i)
 	{
-		si32 curDist = (*i)->pos.dist2dSQ(parameters.caster->getHeroCaster()->pos);
+		si32 curDist = (*i)->visitablePos().dist2dSQ(parameters.caster->getHeroCaster()->visitablePos());
 
 		if(curDist < dist)
 		{
@@ -696,9 +692,9 @@
 
 	for(const auto & color : team->players)
 	{
-		for(auto currTown : env->getCb()->getPlayerState(color)->towns)
+		for(auto currTown : env->getCb()->getPlayerState(color)->getTowns())
 		{
-			ret.push_back(currTown.get());
+			ret.push_back(currTown);
 		}
 	}
 	return ret;
@@ -735,13 +731,13 @@
 		{
 			ObjectPosInfo posInfo(obj);
 
-			if((*fowMap)[posInfo.pos.z][posInfo.pos.x][posInfo.pos.y] == 0)
+			if(fowMap[posInfo.pos.z][posInfo.pos.x][posInfo.pos.y] == 0)
 				pack.objectPositions.push_back(posInfo);
 		}
 	}
 	pack.showTerrain = showTerrain(spellLevel);
 
-	env->apply(&pack);
+	env->apply(pack);
 
 	return ESpellCastResult::OK;
 }
diff --color -urN vcmi-1.5.7/lib/spells/AdventureSpellMechanics.h vcmi/lib/spells/AdventureSpellMechanics.h
--- vcmi-1.5.7/lib/spells/AdventureSpellMechanics.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/spells/AdventureSpellMechanics.h	2024-12-19 15:00:22.938149591 +0100
@@ -21,7 +21,7 @@
 	OK, // cast successful
 	CANCEL, // cast failed but it is not an error, no mana has been spent
 	PENDING,
-	ERROR// error occured, for example invalid request from player
+	ERROR// error occurred, for example invalid request from player
 };
 
 class AdventureSpellMechanics : public IAdventureSpellMechanics
diff --color -urN vcmi-1.5.7/lib/spells/BattleSpellMechanics.cpp vcmi/lib/spells/BattleSpellMechanics.cpp
--- vcmi-1.5.7/lib/spells/BattleSpellMechanics.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/spells/BattleSpellMechanics.cpp	2024-12-19 15:00:22.938149591 +0100
@@ -19,7 +19,8 @@
 #include "../networkPacks/PacksForClientBattle.h"
 #include "../networkPacks/SetStackEffect.h"
 #include "../CStack.h"
-#include "../CRandomGenerator.h"
+
+#include <vstd/RNG.h>
 
 VCMI_LIB_NAMESPACE_BEGIN
 
@@ -192,16 +193,16 @@
 		return adaptProblem(ESpellCastProblem::ADVMAP_SPELL_INSTEAD_OF_BATTLE_SPELL, problem);
 
 	const PlayerColor player = caster->getCasterOwner();
-	const auto side = battle()->playerToSide(player);
+	const BattleSide side = battle()->playerToSide(player);
 
-	if(!side)
+	if(side == BattleSide::NONE)
 		return adaptProblem(ESpellCastProblem::INVALID, problem);
 
 	//effect like Recanter's Cloak. Blocks also passive casting.
 	//TODO: check creature abilities to block
 	//TODO: check any possible caster
 
-	if(battle()->battleMaxSpellLevel(side.value()) < getSpellLevel() || battle()->battleMinSpellLevel(side.value()) > getSpellLevel())
+	if(battle()->battleMaxSpellLevel(side) < getSpellLevel() || battle()->battleMinSpellLevel(side) > getSpellLevel())
 		return adaptProblem(ESpellCastProblem::SPELL_LEVEL_LIMIT_EXCEEDED, problem);
 
 	return effects->applicable(problem, this);
@@ -216,19 +217,27 @@
 
 	const battle::Unit * mainTarget = nullptr;
 
-	if (!getSpell()->canCastOnSelf())
+	if(spellTarget.front().unitValue)
 	{
-		if(spellTarget.front().unitValue)
-		{
-			mainTarget = target.front().unitValue;
-		}
-		else if(spellTarget.front().hexValue.isValid())
-		{
-			mainTarget = battle()->battleGetUnitByPos(target.front().hexValue, true);
-		}
+		mainTarget = target.front().unitValue;
+	}
+	else if(spellTarget.front().hexValue.isValid())
+	{
+		mainTarget = battle()->battleGetUnitByPos(target.front().hexValue, true);
+	}
 
-		if (mainTarget && mainTarget == caster)
+	if (!getSpell()->canCastOnSelf() && !getSpell()->canCastOnlyOnSelf())
+	{
+		if(mainTarget && mainTarget == caster)
 			return false; // can't cast on self
+
+		if(mainTarget && mainTarget->hasBonusOfType(BonusType::INVINCIBLE) && !getSpell()->getPositiveness())
+			return false;
+	}
+	else if(getSpell()->canCastOnlyOnSelf())
+	{
+		if(mainTarget && mainTarget != caster)
+			return false; // can't cast on others
 	}
 
 	return effects->applicable(problem, this, target, spellTarget);
@@ -250,7 +259,7 @@
 
 	for(const Destination & dest : all)
 	{
-		if(dest.unitValue)
+		if(dest.unitValue && !dest.unitValue->hasBonusOfType(BonusType::INVINCIBLE))
 		{
 			//FIXME: remove and return battle::Unit
 			stacks.insert(battle()->battleGetStackByID(dest.unitValue->unitId(), false));
@@ -283,7 +292,7 @@
 	const CGHeroInstance * otherHero = nullptr;
 	{
 		//check it there is opponent hero
-		const ui8 otherSide = battle()->otherSide(casterSide);
+		const BattleSide otherSide = battle()->otherSide(casterSide);
 
 		if(battle()->battleHasHero(otherSide))
 			otherHero = battle()->battleGetFightingHero(otherSide);
@@ -344,9 +353,9 @@
 		sc.affectedCres.insert(unit->unitId());
 
 	if(!castDescription.lines.empty())
-		server->apply(&castDescription);
+		server->apply(castDescription);
 
-	server->apply(&sc);
+	server->apply(sc);
 
 	for(auto & p : effectsToApply)
 		p.first->apply(server, this, p.second);
@@ -366,7 +375,7 @@
 	// temporary(?) workaround to force animations to trigger
 	StacksInjured fakeEvent;
 	fakeEvent.battleID = battle()->getBattle()->getBattleID();
-	server->apply(&fakeEvent);
+	server->apply(fakeEvent);
 }
 
 void BattleSpellMechanics::beforeCast(BattleSpellCast & sc, vstd::RNG & rng, const Target & target)
@@ -377,15 +386,13 @@
 
 	std::vector <const battle::Unit *> resisted;
 
-	auto rangeGen = rng.getInt64Range(0, 99);
-
 	auto filterResisted = [&, this](const battle::Unit * unit) -> bool
 	{
 		if(isNegativeSpell() && isMagicalEffect())
 		{
 			//magic resistance
 			const int prob = std::min(unit->magicResistance(), 100); //probability of resistance in %
-			if(rangeGen() < prob)
+			if(rng.nextInt(0, 99) < prob)
 				return true;
 		}
 		return false;
@@ -484,7 +491,7 @@
 	}
 
 	if(!sse.toRemove.empty())
-		server->apply(&sse);
+		server->apply(sse);
 }
 
 bool BattleSpellMechanics::counteringSelector(const Bonus * bonus) const
@@ -506,62 +513,14 @@
 	using namespace SRSLPraserHelpers;
 
 	std::set<BattleHex> ret;
-	std::string rng = owner->getLevelInfo(getRangeLevel()).range + ','; //copy + artificial comma for easier handling
+	std::vector<int> rng = owner->getLevelInfo(getRangeLevel()).range;
 
-	if(rng.size() >= 2 && rng[0] != 'X') //there is at least one hex in range (+artificial comma)
+	for(auto & elem : rng)
 	{
-		std::string number1;
-		std::string number2;
-		int beg = 0;
-		int end = 0;
-		bool readingFirst = true;
-		for(auto & elem : rng)
-		{
-			if(std::isdigit(elem) ) //reading number
-			{
-				if(readingFirst)
-					number1 += elem;
-				else
-					number2 += elem;
-			}
-			else if(elem == ',') //comma
-			{
-				//calculating variables
-				if(readingFirst)
-				{
-					beg = std::stoi(number1);
-					number1 = "";
-				}
-				else
-				{
-					end = std::stoi(number2);
-					number2 = "";
-				}
-				//obtaining new hexes
-				std::set<ui16> curLayer;
-				if(readingFirst)
-				{
-					curLayer = getInRange(centralHex, beg, beg);
-				}
-				else
-				{
-					curLayer = getInRange(centralHex, beg, end);
-					readingFirst = true;
-				}
-				//adding obtained hexes
-				for(const auto & curLayer_it : curLayer)
-				{
-					ret.insert(curLayer_it);
-				}
-
-			}
-			else if(elem == '-') //dash
-			{
-				beg = std::stoi(number1);
-				number1 = "";
-				readingFirst = false;
-			}
-		}
+		std::set<ui16> curLayer = getInRange(centralHex, elem, elem);
+		//adding obtained hexes
+		for(const auto & curLayer_it : curLayer)
+			ret.insert(curLayer_it);
 	}
 
 	return ret;
diff --color -urN vcmi-1.5.7/lib/spells/BattleSpellMechanics.h vcmi/lib/spells/BattleSpellMechanics.h
--- vcmi-1.5.7/lib/spells/BattleSpellMechanics.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/spells/BattleSpellMechanics.h	2024-12-19 15:00:22.938149591 +0100
@@ -33,7 +33,7 @@
 	/// Returns false if spell can not be cast at all, e.g. due to not having any possible target on battlefield
 	bool canBeCast(Problem & problem) const override;
 
-	/// Returns false if spell can not be cast at specifid target
+	/// Returns false if spell can not be cast at specified target
 	bool canBeCastAt(const Target & target, Problem & problem) const override;
 
 	// TODO: ??? (what's the difference compared to applyEffects?)
diff --color -urN vcmi-1.5.7/lib/spells/BonusCaster.cpp vcmi/lib/spells/BonusCaster.cpp
--- vcmi-1.5.7/lib/spells/BonusCaster.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/spells/BonusCaster.cpp	2024-12-19 15:00:22.938149591 +0100
@@ -12,13 +12,12 @@
 #include "BonusCaster.h"
 
 #include <vcmi/spells/Spell.h>
+#include <vcmi/HeroType.h>
 
-#include "../MetaString.h"
 #include "../battle/Unit.h"
 #include "../bonuses/Bonus.h"
 #include "../VCMI_Lib.h"
 #include "../CSkillHandler.h"
-#include "../CHeroHandler.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
diff --color -urN vcmi-1.5.7/lib/spells/CSpellHandler.cpp vcmi/lib/spells/CSpellHandler.cpp
--- vcmi-1.5.7/lib/spells/CSpellHandler.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/spells/CSpellHandler.cpp	2024-12-19 15:00:22.938149591 +0100
@@ -17,7 +17,6 @@
 
 #include <vcmi/spells/Caster.h>
 
-#include "../CGeneralTextHandler.h"
 #include "../filesystem/Filesystem.h"
 
 #include "../constants/StringConstants.h"
@@ -28,9 +27,11 @@
 #include "../json/JsonBonus.h"
 #include "../json/JsonUtils.h"
 #include "../mapObjects/CGHeroInstance.h" //todo: remove
-#include "../serializer/CSerializer.h"
 #include "../modding/IdentifierStorage.h"
 #include "../modding/ModUtility.h"
+#include "../serializer/CSerializer.h"
+#include "../texts/CLegacyConfigParser.h"
+#include "../texts/CGeneralTextHandler.h"
 
 #include "ISpellMechanics.h"
 
@@ -78,6 +79,8 @@
 	combat(false),
 	creatureAbility(false),
 	castOnSelf(false),
+	castOnlyOnSelf(false),
+	castWithoutSkip(false),
 	positiveness(ESpellPositiveness::NEUTRAL),
 	defaultProbability(0),
 	rising(false),
@@ -199,6 +202,11 @@
 	return modScope + ':' + identifier;
 }
 
+std::string CSpell::getModScope() const
+{
+	return modScope;
+}
+
 int32_t CSpell::getIndex() const
 {
 	return id.toEnum();
@@ -292,6 +300,16 @@
 	return castOnSelf;
 }
 
+bool CSpell::canCastOnlyOnSelf() const
+{
+	return castOnlyOnSelf;
+}
+
+bool CSpell::canCastWithoutSkip() const
+{
+	return castWithoutSkip;
+}
+
 const std::string & CSpell::getIconImmune() const
 {
 	return iconImmune;
@@ -414,6 +432,10 @@
 			ret *= 100 + bearer->valOfBonuses(BonusType::MORE_DAMAGE_FROM_SPELL, BonusSubtypeID(id));
 			ret /= 100;
 		}
+
+		//invincible
+		if(bearer->hasBonusOfType(BonusType::INVINCIBLE))
+			ret = 0;
 	}
 	ret = caster->getSpellBonus(this, ret, affectedCreature);
 	return ret;
@@ -522,6 +544,7 @@
 ///CSpell::AnimationInfo
 CSpell::AnimationItem::AnimationItem() :
 	verticalPosition(VerticalPosition::TOP),
+	transparency(1),
 	pause(0)
 {
 
@@ -556,7 +579,7 @@
 	const auto & levelInfo = spell->getLevelInfo(level);
 
 	smart = levelInfo.smartTarget;
-	massive = levelInfo.range == "X";
+	massive = levelInfo.range.empty();
 	clearAffected = levelInfo.clearAffected;
 	clearTarget = levelInfo.clearTarget;
 }
@@ -676,7 +699,65 @@
 	return typeNames;
 }
 
-CSpell * CSpellHandler::loadFromJson(const std::string & scope, const JsonNode & json, const std::string & identifier, size_t index)
+std::vector<int> CSpellHandler::spellRangeInHexes(std::string input) const
+{
+	std::set<BattleHex> ret;
+	std::string rng = input + ','; //copy + artificial comma for easier handling
+
+	if(rng.size() >= 2 && std::tolower(rng[0]) != 'x') //there is at least one hex in range (+artificial comma)
+	{
+		std::string number1;
+		std::string number2;
+		int beg = 0;
+		int end = 0;
+		bool readingFirst = true;
+		for(auto & elem : rng)
+		{
+			if(std::isdigit(elem) ) //reading number
+			{
+				if(readingFirst)
+					number1 += elem;
+				else
+					number2 += elem;
+			}
+			else if(elem == ',') //comma
+			{
+				//calculating variables
+				if(readingFirst)
+				{
+					beg = std::stoi(number1);
+					number1 = "";
+				}
+				else
+				{
+					end = std::stoi(number2);
+					number2 = "";
+				}
+				//obtaining new hexes
+				std::set<ui16> curLayer;
+				if(readingFirst)
+				{
+					ret.insert(beg);
+				}
+				else
+				{
+					for(int i = beg; i <= end; ++i)
+						ret.insert(i);
+				}
+			}
+			else if(elem == '-') //dash
+			{
+				beg = std::stoi(number1);
+				number1 = "";
+				readingFirst = false;
+			}
+		}
+	}
+
+	return std::vector<int>(ret.begin(), ret.end());
+}
+
+std::shared_ptr<CSpell> CSpellHandler::loadFromJson(const std::string & scope, const JsonNode & json, const std::string & identifier, size_t index)
 {
 	assert(identifier.find(':') == std::string::npos);
 	assert(!scope.empty());
@@ -685,7 +766,7 @@
 
 	SpellID id(static_cast<si32>(index));
 
-	auto * spell = new CSpell();
+	auto spell = std::make_shared<CSpell>();
 	spell->id = id;
 	spell->identifier = identifier;
 	spell->modScope = scope;
@@ -703,7 +784,7 @@
 		spell->combat = type == "combat";
 	}
 
-	VLC->generaltexth->registerString(scope, spell->getNameTextID(), json["name"].String());
+	VLC->generaltexth->registerString(scope, spell->getNameTextID(), json["name"]);
 
 	logMod->trace("%s: loading spell %s", __FUNCTION__, spell->getNameTranslated());
 
@@ -715,6 +796,8 @@
 	}
 
 	spell->castOnSelf = json["canCastOnSelf"].Bool();
+	spell->castOnlyOnSelf = json["canCastOnlyOnSelf"].Bool();
+	spell->castWithoutSkip = json["canCastWithoutSkip"].Bool();
 	spell->level = static_cast<si32>(json["level"].Integer());
 	spell->power = static_cast<si32>(json["power"].Integer());
 
@@ -883,10 +966,15 @@
 				auto vPosStr = item["verticalPosition"].String();
 				if("bottom" == vPosStr)
 					newItem.verticalPosition = VerticalPosition::BOTTOM;
+
+				if (item["transparency"].isNumber())
+					newItem.transparency = item["transparency"].Float();
+				else
+					newItem.transparency = 1.0;
 			}
 			else if(item.isNumber())
 			{
-				newItem.pause = static_cast<int>(item.Float());
+				newItem.pause = item.Integer();
 			}
 
 			q.push_back(newItem);
@@ -923,14 +1011,14 @@
 		const si32 levelPower     = levelObject.power = static_cast<si32>(levelNode["power"].Integer());
 
 		if (!spell->isCreatureAbility())
-			VLC->generaltexth->registerString(scope, spell->getDescriptionTextID(levelIndex), levelNode["description"].String());
+			VLC->generaltexth->registerString(scope, spell->getDescriptionTextID(levelIndex), levelNode["description"]);
 
 		levelObject.cost          = static_cast<si32>(levelNode["cost"].Integer());
 		levelObject.AIValue       = static_cast<si32>(levelNode["aiValue"].Integer());
 		levelObject.smartTarget   = levelNode["targetModifier"]["smart"].Bool();
 		levelObject.clearTarget   = levelNode["targetModifier"]["clearTarget"].Bool();
 		levelObject.clearAffected = levelNode["targetModifier"]["clearAffected"].Bool();
-		levelObject.range         = levelNode["range"].String();
+		levelObject.range         = spellRangeInHexes(levelNode["range"].String());
 
 		for(const auto & elem : levelNode["effects"].Struct())
 		{
diff --color -urN vcmi-1.5.7/lib/spells/CSpellHandler.h vcmi/lib/spells/CSpellHandler.h
--- vcmi-1.5.7/lib/spells/CSpellHandler.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/spells/CSpellHandler.h	2024-12-19 15:00:22.938149591 +0100
@@ -67,12 +67,6 @@
 
 		///resource name
 		AnimationPath resourceName;
-
-		template <typename Handler> void serialize(Handler & h)
-		{
-			h & minimumAngle;
-			h & resourceName;
-		}
 	};
 
 	struct AnimationItem
@@ -80,17 +74,10 @@
 		AnimationPath resourceName;
 		std::string effectName;
 		VerticalPosition verticalPosition;
+		float transparency;
 		int pause;
 
 		AnimationItem();
-
-		template <typename Handler> void serialize(Handler & h)
-		{
-			h & resourceName;
-			h & effectName;
-			h & verticalPosition;
-			h & pause;
-		}
 	};
 
 	using TAnimation = AnimationItem;
@@ -111,14 +98,6 @@
 		///use selectProjectile to access
 		std::vector<ProjectileInfo> projectile;
 
-		template <typename Handler> void serialize(Handler & h)
-		{
-			h & projectile;
-			h & hit;
-			h & cast;
-			h & affect;
-		}
-
 		AnimationPath selectProjectile(const double angle) const;
 	} animationInfo;
 
@@ -132,27 +111,13 @@
 		bool smartTarget = true;
 		bool clearTarget = false;
 		bool clearAffected = false;
-		std::string range = "0";
+		std::vector<int> range = { 0 };
 
 		//TODO: remove these two when AI will understand special effects
 		std::vector<std::shared_ptr<Bonus>> effects; //deprecated
 		std::vector<std::shared_ptr<Bonus>> cumulativeEffects; //deprecated
 
 		JsonNode battleEffects;
-
-		template <typename Handler> void serialize(Handler & h)
-		{
-			h & cost;
-			h & power;
-			h & AIValue;
-			h & smartTarget;
-			h & range;
-			h & effects;
-			h & cumulativeEffects;
-			h & clearTarget;
-			h & clearAffected;
-			h & battleEffects;
-		}
 	};
 
 	/** \brief Low level accessor. Don`t use it if absolutely necessary
@@ -203,6 +168,8 @@
 
 	bool hasSchool(SpellSchool school) const override;
 	bool canCastOnSelf() const override;
+	bool canCastOnlyOnSelf() const override;
+	bool canCastWithoutSkip() const override;
 
 	/**
 	 * Calls cb for each school this spell belongs to
@@ -228,6 +195,7 @@
 	int32_t getIndex() const override;
 	int32_t getIconIndex() const override;
 	std::string getJsonKey() const override;
+	std::string getModScope() const override;
 	SpellID getId() const override;
 
 	std::string getNameTextID() const override;
@@ -331,6 +299,8 @@
 	bool combat; //is this spell combat (true) or adventure (false)
 	bool creatureAbility; //if true, only creatures can use this spell
 	bool castOnSelf; // if set, creature caster can cast this spell on itself
+	bool castOnlyOnSelf; // if set, creature caster can cast this spell on itself
+	bool castWithoutSkip; // if set the creature will not skip the turn after casting a spell
 	si8 positiveness; //1 if spell is positive for influenced stacks, 0 if it is indifferent, -1 if it's negative
 
 	std::unique_ptr<spells::ISpellMechanicsFactory> mechanics;//(!) do not serialize
@@ -341,6 +311,8 @@
 
 class DLL_LINKAGE CSpellHandler: public CHandlerBase<SpellID, spells::Spell, CSpell, spells::Service>
 {
+	std::vector<int> spellRangeInHexes(std::string rng) const;
+
 public:
 	///IHandler base
 	std::vector<JsonNode> loadLegacyData() override;
@@ -355,7 +327,7 @@
 
 protected:
 	const std::vector<std::string> & getTypeNames() const override;
-	CSpell * loadFromJson(const std::string & scope, const JsonNode & json, const std::string & identifier, size_t index) override;
+	std::shared_ptr<CSpell> loadFromJson(const std::string & scope, const JsonNode & json, const std::string & identifier, size_t index) override;
 };
 
 VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/spells/effects/Catapult.cpp vcmi/lib/spells/effects/Catapult.cpp
--- vcmi-1.5.7/lib/spells/effects/Catapult.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/spells/effects/Catapult.cpp	2024-12-19 15:00:22.940149673 +0100
@@ -18,9 +18,11 @@
 #include "../../battle/CBattleInfoCallback.h"
 #include "../../battle/Unit.h"
 #include "../../mapObjects/CGTownInstance.h"
+#include "../../entities/building/TownFortifications.h"
 #include "../../networkPacks/PacksForClientBattle.h"
 #include "../../serializer/JsonSerializeFormat.h"
-#include "../../CRandomGenerator.h"
+
+#include <vstd/RNG.h>
 
 VCMI_LIB_NAMESPACE_BEGIN
 
@@ -38,7 +40,7 @@
 		return m->adaptProblem(ESpellCastProblem::NO_APPROPRIATE_TARGET, problem);
 	}
 
-	if(CGTownInstance::NONE == town->fortLevel())
+	if(town->fortificationsLevel().wallsHealth == 0)
 	{
 		return m->adaptProblem(ESpellCastProblem::NO_APPROPRIATE_TARGET, problem);
 	}
@@ -102,7 +104,7 @@
 			attackInfo->damageDealt += getRandomDamage(server);
 		}
 	}
-	server->apply(&ca);
+	server->apply(ca);
 
 	removeTowerShooters(server, m);
 }
@@ -118,7 +120,7 @@
 		auto actualTarget = EWallPart::INVALID;
 
 		if ( m->battle()->isWallPartAttackable(desiredTarget) &&
-				server->getRNG()->getInt64Range(0, 99)() < getCatapultHitChance(desiredTarget))
+				server->getRNG()->nextInt(0, 99) < getCatapultHitChance(desiredTarget))
 		{
 			actualTarget = desiredTarget;
 		}
@@ -142,7 +144,7 @@
 		ca.battleID = m->battle()->getBattle()->getBattleID();
 		ca.attacker = m->caster->getHeroCaster() ? -1 : m->caster->getCasterUnitId();
 		ca.attackedParts.push_back(attack);
-		server->apply(&ca);
+		server->apply(ca);
 		removeTowerShooters(server, m);
 	}
 }
@@ -172,7 +174,7 @@
 {
 	std::array<int, 3> damageChances = { noDmg, hit, crit }; //dmgChance[i] - chance for doing i dmg when hit is successful
 	int totalChance = std::accumulate(damageChances.begin(), damageChances.end(), 0);
-	int damageRandom = server->getRNG()->getInt64Range(0, totalChance - 1)();
+	int damageRandom = server->getRNG()->nextInt(0, totalChance - 1);
 	int dealtDamage = 0;
 
 	//calculating dealt damage
@@ -226,7 +228,7 @@
 	}
 
 	if(!removeUnits.changedStacks.empty())
-		server->apply(&removeUnits);
+		server->apply(removeUnits);
 }
 
 std::vector<EWallPart> Catapult::getPotentialTargets(const Mechanics * m, bool bypassGateCheck, bool bypassTowerCheck) const
diff --color -urN vcmi-1.5.7/lib/spells/effects/Clone.cpp vcmi/lib/spells/effects/Clone.cpp
--- vcmi-1.5.7/lib/spells/effects/Clone.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/spells/effects/Clone.cpp	2024-12-19 15:00:22.940149673 +0100
@@ -43,7 +43,7 @@
 		if(clonedStack->getCount() < 1)
 			continue;
 
-		auto hex = m->battle()->getAvaliableHex(clonedStack->creatureId(), m->casterSide, clonedStack->getPosition());
+		auto hex = m->battle()->getAvailableHex(clonedStack->creatureId(), m->casterSide, clonedStack->getPosition());
 
 		if(!hex.isValid())
 		{
@@ -65,7 +65,7 @@
 		pack.battleID = m->battle()->getBattle()->getBattleID();
 		pack.changedStacks.emplace_back(info.id, UnitChanges::EOperation::ADD);
 		info.save(pack.changedStacks.back().data);
-		server->apply(&pack);
+		server->apply(pack);
 
 		//TODO: use BattleUnitsChanged with UPDATE operation
 
@@ -90,7 +90,7 @@
 		cloneFlags.changedStacks.emplace_back(originalState->unitId(), UnitChanges::EOperation::RESET_STATE);
 		originalState->save(cloneFlags.changedStacks.back().data);
 
-		server->apply(&cloneFlags);
+		server->apply(cloneFlags);
 
 		SetStackEffect sse;
 		sse.battleID = m->battle()->getBattle()->getBattleID();
@@ -100,7 +100,7 @@
 		std::vector<Bonus> buffer;
 		buffer.push_back(lifeTimeMarker);
 		sse.toAdd.emplace_back(unitId, buffer);
-		server->apply(&sse);
+		server->apply(sse);
 	}
 }
 
diff --color -urN vcmi-1.5.7/lib/spells/effects/Damage.cpp vcmi/lib/spells/effects/Damage.cpp
--- vcmi-1.5.7/lib/spells/effects/Damage.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/spells/effects/Damage.cpp	2024-12-19 15:00:22.940149673 +0100
@@ -14,13 +14,12 @@
 #include "../CSpellHandler.h"
 #include "../ISpellMechanics.h"
 
-#include "../../MetaString.h"
 #include "../../CStack.h"
 #include "../../battle/IBattleState.h"
 #include "../../battle/CBattleInfoCallback.h"
 #include "../../networkPacks/PacksForClientBattle.h"
-#include "../../CGeneralTextHandler.h"
-#include "../../Languages.h"
+#include "../../texts/CGeneralTextHandler.h"
+#include "../../texts/Languages.h"
 #include "../../serializer/JsonSerializeFormat.h"
 
 #include <vcmi/spells/Spell.h>
@@ -81,10 +80,10 @@
 	}
 
 	if(!stacksInjured.stacks.empty())
-		server->apply(&stacksInjured);
+		server->apply(stacksInjured);
 
 	if(!blm.lines.empty())
-		server->apply(&blm);
+		server->apply(blm);
 }
 
 bool Damage::isReceptive(const Mechanics * m, const battle::Unit * unit) const
diff --color -urN vcmi-1.5.7/lib/spells/effects/DemonSummon.cpp vcmi/lib/spells/effects/DemonSummon.cpp
--- vcmi-1.5.7/lib/spells/effects/DemonSummon.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/spells/effects/DemonSummon.cpp	2024-12-19 15:00:22.940149673 +0100
@@ -65,7 +65,7 @@
 			continue;
 		}
 
-		auto hex = m->battle()->getAvaliableHex(targetStack->creatureId(), m->casterSide, targetStack->getPosition());
+		auto hex = m->battle()->getAvailableHex(targetStack->creatureId(), m->casterSide, targetStack->getPosition());
 
 		if(!hex.isValid())
 		{
@@ -98,7 +98,7 @@
 	}
 
 	if(!pack.changedStacks.empty())
-		server->apply(&pack);
+		server->apply(pack);
 }
 
 bool DemonSummon::isValidTarget(const Mechanics * m, const battle::Unit * unit) const
diff --color -urN vcmi-1.5.7/lib/spells/effects/Dispel.cpp vcmi/lib/spells/effects/Dispel.cpp
--- vcmi-1.5.7/lib/spells/effects/Dispel.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/spells/effects/Dispel.cpp	2024-12-19 15:00:22.940149673 +0100
@@ -16,7 +16,6 @@
 
 #include "../ISpellMechanics.h"
 
-#include "../../MetaString.h"
 #include "../../battle/IBattleState.h"
 #include "../../battle/CBattleInfoCallback.h"
 #include "../../battle/Unit.h"
@@ -66,10 +65,10 @@
 	}
 
 	if(!sse.toRemove.empty())
-		server->apply(&sse);
+		server->apply(sse);
 
 	if(describe && !blm.lines.empty())
-		server->apply(&blm);
+		server->apply(blm);
 }
 
 bool Dispel::isValidTarget(const Mechanics * m, const battle::Unit * unit) const
@@ -97,7 +96,7 @@
 			if(!sourceSpell)
 				return false;//error
 
-			//Special case: DISRUPTING_RAY and ACID_BREATH_DEFENSE are "immune" to dispell
+			//Special case: DISRUPTING_RAY and ACID_BREATH_DEFENSE are "immune" to dispel
 			//Other even PERMANENT effects can be removed (f.e. BIND)
 			if(sourceSpell->getIndex() == SpellID::DISRUPTING_RAY || sourceSpell->getIndex() == SpellID::ACID_BREATH_DEFENSE)
 				return false;
diff --color -urN vcmi-1.5.7/lib/spells/effects/Heal.cpp vcmi/lib/spells/effects/Heal.cpp
--- vcmi-1.5.7/lib/spells/effects/Heal.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/spells/effects/Heal.cpp	2024-12-19 15:00:22.941149715 +0100
@@ -13,7 +13,6 @@
 #include "Registry.h"
 #include "../ISpellMechanics.h"
 
-#include "../../MetaString.h"
 #include "../../battle/IBattleState.h"
 #include "../../battle/CUnitState.h"
 #include "../../battle/CBattleInfoCallback.h"
@@ -43,9 +42,9 @@
 
 	prepareHealEffect(value, pack, logMessage, *server->getRNG(), m, target);
 	if(!pack.changedStacks.empty())
-		server->apply(&pack);
+		server->apply(pack);
 	if(!logMessage.lines.empty())
-		server->apply(&logMessage);
+		server->apply(logMessage);
 }
 
 bool Heal::isValidTarget(const Mechanics * m, const battle::Unit * unit) const
diff --color -urN vcmi-1.5.7/lib/spells/effects/Moat.cpp vcmi/lib/spells/effects/Moat.cpp
--- vcmi-1.5.7/lib/spells/effects/Moat.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/spells/effects/Moat.cpp	2024-12-19 15:00:22.941149715 +0100
@@ -14,10 +14,12 @@
 #include "Registry.h"
 #include "../ISpellMechanics.h"
 
+#include "../../entities/building/CBuilding.h"
 #include "../../mapObjects/CGTownInstance.h"
 #include "../../bonuses/Limiters.h"
 #include "../../battle/IBattleState.h"
 #include "../../battle/CBattleInfoCallback.h"
+#include "../../entities/building/TownFortifications.h"
 #include "../../json/JsonBonus.h"
 #include "../../serializer/JsonSerializeFormat.h"
 #include "../../networkPacks/PacksForClient.h"
@@ -84,9 +86,9 @@
 		//Moat battlefield effect is always permanent
 		nb.duration = BonusDuration::ONE_BATTLE;
 
-		if(m->battle()->battleGetDefendedTown() && m->battle()->battleGetSiegeLevel() >= CGTownInstance::CITADEL)
+		if(m->battle()->battleGetDefendedTown() && m->battle()->battleGetFortifications().hasMoat)
 		{
-			nb.sid = BonusSourceID(m->battle()->battleGetDefendedTown()->town->buildings.at(BuildingID::CITADEL)->getUniqueTypeID());
+			nb.sid = BonusSourceID(m->battle()->battleGetDefendedTown()->getTown()->buildings.at(BuildingID::CITADEL)->getUniqueTypeID());
 			nb.source = BonusSource::TOWN_STRUCTURE;
 		}
 		else
@@ -108,7 +110,7 @@
 {
 	assert(m->isMassive());
 	assert(m->battle()->battleGetDefendedTown());
-	if(m->isMassive() && m->battle()->battleGetSiegeLevel() >= CGTownInstance::CITADEL)
+	if(m->isMassive() && m->battle()->battleGetFortifications().hasMoat)
 	{
 		EffectTarget moat;
 		placeObstacles(server, m, moat);
@@ -120,7 +122,7 @@
 			GiveBonus gb(GiveBonus::ETarget::BATTLE);
 			gb.id = m->battle()->getBattle()->getBattleID();
 			gb.bonus = b;
-			server->apply(&gb);
+			server->apply(gb);
 		}
 	}
 }
@@ -133,7 +135,7 @@
 	BattleObstaclesChanged pack;
 	pack.battleID = m->battle()->getBattle()->getBattleID();
 
-	auto all = m->battle()->battleGetAllObstacles(BattlePerspective::ALL_KNOWING);
+	auto all = m->battle()->battleGetAllObstacles(BattleSide::ALL_KNOWING);
 
 	int obstacleIdToGive = 1;
 	for(auto & one : all)
@@ -169,7 +171,7 @@
 	}
 
 	if(!pack.changes.empty())
-		server->apply(&pack);
+		server->apply(pack);
 }
 
 }
diff --color -urN vcmi-1.5.7/lib/spells/effects/Obstacle.cpp vcmi/lib/spells/effects/Obstacle.cpp
--- vcmi-1.5.7/lib/spells/effects/Obstacle.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/spells/effects/Obstacle.cpp	2024-12-19 15:00:22.941149715 +0100
@@ -16,9 +16,11 @@
 
 #include "../../battle/IBattleState.h"
 #include "../../battle/CBattleInfoCallback.h"
+#include "../../entities/building/TownFortifications.h"
 #include "../../networkPacks/PacksForClientBattle.h"
 #include "../../serializer/JsonSerializeFormat.h"
-#include "../../CRandomGenerator.h"
+
+#include <vstd/RNG.h>
 
 VCMI_LIB_NAMESPACE_BEGIN
 
@@ -101,11 +103,11 @@
 
 	for(auto & destination : effectTarget)
 	{
-		for(const auto & trasformation : options.shape)
+		for(const auto & transformation : options.shape)
 		{
 			BattleHex hex = destination.hexValue;
 
-			for(auto direction : trasformation)
+			for(auto direction : transformation)
 				hex.moveInDirection(direction, false);
 
 			if(hex.isValid())
@@ -134,10 +136,10 @@
 
 		for(const auto & destination : target)
 		{
-			for(const auto & trasformation : options.shape)
+			for(const auto & transformation : options.shape)
 			{
 				BattleHex hex = destination.hexValue;
-				for(auto direction : trasformation)
+				for(auto direction : transformation)
 					hex.moveInDirection(direction, false);
 
 				if(!isHexAvailable(m->battle(), hex, requiresClearTiles))
@@ -238,7 +240,7 @@
 		if(i->obstacleType != CObstacleInstance::MOAT)
 			return false;
 
-	if(cb->battleGetSiegeLevel() != 0)
+	if(cb->battleGetFortifications().wallsHealth != 0)
 	{
 		EWallPart part = cb->battleHexToWallPart(hex);
 
@@ -273,7 +275,7 @@
 	BattleObstaclesChanged pack;
 	pack.battleID = m->battle()->getBattle()->getBattleID();
 
-	auto all = m->battle()->battleGetAllObstacles(BattlePerspective::ALL_KNOWING);
+	auto all = m->battle()->battleGetAllObstacles(BattleSide::ALL_KNOWING);
 
 	int obstacleIdToGive = 1;
 	for(auto & one : all)
@@ -324,7 +326,7 @@
 	}
 
 	if(!pack.changes.empty())
-		server->apply(&pack);
+		server->apply(pack);
 }
 
 }
diff --color -urN vcmi-1.5.7/lib/spells/effects/Obstacle.h vcmi/lib/spells/effects/Obstacle.h
--- vcmi-1.5.7/lib/spells/effects/Obstacle.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/spells/effects/Obstacle.h	2024-12-19 15:00:22.941149715 +0100
@@ -66,7 +66,7 @@
 	bool passable = false;
 	int32_t turnsRemaining = -1;
 
-	std::array<ObstacleSideOptions, 2> sideOptions;
+	BattleSideArray<ObstacleSideOptions> sideOptions;
 
 	static bool isHexAvailable(const CBattleInfoCallback * cb, const BattleHex & hex, const bool mustBeClear);
 	static bool noRoomToPlace(Problem & problem, const Mechanics * m);
diff --color -urN vcmi-1.5.7/lib/spells/effects/RemoveObstacle.cpp vcmi/lib/spells/effects/RemoveObstacle.cpp
--- vcmi-1.5.7/lib/spells/effects/RemoveObstacle.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/spells/effects/RemoveObstacle.cpp	2024-12-19 15:00:22.942149756 +0100
@@ -54,7 +54,7 @@
 	}
 
 	if(!pack.changes.empty())
-		server->apply(&pack);
+		server->apply(pack);
 }
 
 void RemoveObstacle::serializeJsonEffect(JsonSerializeFormat & handler)
@@ -90,7 +90,7 @@
 	std::set<const CObstacleInstance *> possibleTargets;
 	if(m->isMassive() || alwaysMassive)
 	{
-		for(const auto & obstacle : m->battle()->battleGetAllObstacles(BattlePerspective::ALL_KNOWING))
+		for(const auto & obstacle : m->battle()->battleGetAllObstacles(BattleSide::ALL_KNOWING))
 			if(canRemove(obstacle.get()))
 				possibleTargets.insert(obstacle.get());
 	}
diff --color -urN vcmi-1.5.7/lib/spells/effects/Sacrifice.cpp vcmi/lib/spells/effects/Sacrifice.cpp
--- vcmi-1.5.7/lib/spells/effects/Sacrifice.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/spells/effects/Sacrifice.cpp	2024-12-19 15:00:22.942149756 +0100
@@ -125,7 +125,7 @@
 	BattleUnitsChanged removeUnits;
 	removeUnits.battleID = m->battle()->getBattle()->getBattleID();
 	removeUnits.changedStacks.emplace_back(victim->unitId(), UnitChanges::EOperation::REMOVE);
-	server->apply(&removeUnits);
+	server->apply(removeUnits);
 }
 
 bool Sacrifice::isValidTarget(const Mechanics * m, const battle::Unit * unit) const
diff --color -urN vcmi-1.5.7/lib/spells/effects/Summon.cpp vcmi/lib/spells/effects/Summon.cpp
--- vcmi-1.5.7/lib/spells/effects/Summon.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/spells/effects/Summon.cpp	2024-12-19 15:00:22.942149756 +0100
@@ -13,13 +13,11 @@
 #include "Registry.h"
 
 #include "../ISpellMechanics.h"
-#include "../../MetaString.h"
 #include "../../battle/CBattleInfoCallback.h"
 #include "../../battle/BattleInfo.h"
 #include "../../battle/Unit.h"
 #include "../../serializer/JsonSerializeFormat.h"
 #include "../../CCreatureHandler.h"
-#include "../../CHeroHandler.h"
 #include "../../mapObjects/CGHeroInstance.h"
 #include "../../networkPacks/PacksForClientBattle.h"
 
@@ -80,7 +78,7 @@
 
 				text.replaceNamePlural(elemental->creatureId());
 
-				if(caster->type->gender == EHeroGender::FEMALE)
+				if(caster->gender == EHeroGender::FEMALE)
 					text.replaceLocalString(EMetaText::GENERAL_TXT, 540);
 				else
 					text.replaceLocalString(EMetaText::GENERAL_TXT, 539);
@@ -160,7 +158,7 @@
 	}
 
 	if(!pack.changedStacks.empty())
-		server->apply(&pack);
+		server->apply(pack);
 }
 
 EffectTarget Summon::filterTarget(const Mechanics * m, const EffectTarget & target) const
@@ -192,7 +190,7 @@
 
 	if(sameSummoned.empty() || !summonSameUnit)
 	{
-		BattleHex hex = m->battle()->getAvaliableHex(creature, m->casterSide);
+		BattleHex hex = m->battle()->getAvailableHex(creature, m->casterSide);
 		if(!hex.isValid())
 			logGlobal->error("No free space to summon creature!");
 		else
diff --color -urN vcmi-1.5.7/lib/spells/effects/Teleport.cpp vcmi/lib/spells/effects/Teleport.cpp
--- vcmi-1.5.7/lib/spells/effects/Teleport.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/spells/effects/Teleport.cpp	2024-12-19 15:00:22.942149756 +0100
@@ -15,6 +15,7 @@
 #include "../../battle/IBattleState.h"
 #include "../../battle/CBattleInfoCallback.h"
 #include "../../battle/Unit.h"
+#include "../../entities/building/TownFortifications.h"
 #include "../../networkPacks/PacksForClientBattle.h"
 #include "../../serializer/JsonSerializeFormat.h"
 
@@ -61,10 +62,10 @@
 	if(!targetUnit)
 		return m->adaptProblem(ESpellCastProblem::WRONG_SPELL_TARGET, problem);
 
-	if(!targetHex.isValid() || !m->battle()->getAccesibility(targetUnit).accessible(targetHex, targetUnit))
+	if(!targetHex.isValid() || !m->battle()->getAccessibility(targetUnit).accessible(targetHex, targetUnit))
 		return m->adaptProblem(ESpellCastProblem::WRONG_SPELL_TARGET, problem);
 
-	if(m->battle()->battleGetSiegeLevel() && !(isWallPassable && isMoatPassable))
+	if(m->battle()->battleGetFortifications().wallsHealth > 0 && !(isWallPassable && isMoatPassable))
 	{
 		return !m->battle()->battleHasPenaltyOnLine(target[0].hexValue, target[1].hexValue, !isWallPassable, !isMoatPassable);
 	}
@@ -84,7 +85,7 @@
 	tiles.push_back(destination);
 	pack.tilesToMove = tiles;
 	pack.teleporting = true;
-	server->apply(&pack);
+	server->apply(pack);
 
 	if(triggerObstacles)
 	{
diff --color -urN vcmi-1.5.7/lib/spells/effects/Timed.cpp vcmi/lib/spells/effects/Timed.cpp
--- vcmi-1.5.7/lib/spells/effects/Timed.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/spells/effects/Timed.cpp	2024-12-19 15:00:22.942149756 +0100
@@ -13,7 +13,6 @@
 #include "Registry.h"
 #include "../ISpellMechanics.h"
 
-#include "../../MetaString.h"
 #include "../../battle/IBattleState.h"
 #include "../../battle/CBattleInfoCallback.h"
 #include "../../battle/Unit.h"
@@ -206,10 +205,10 @@
 	}
 
 	if(!(sse.toAdd.empty() && sse.toUpdate.empty()))
-		server->apply(&sse);
+		server->apply(sse);
 
 	if(describe && !blm.lines.empty())
-		server->apply(&blm);
+		server->apply(blm);
 }
 
 void Timed::convertBonus(const Mechanics * m, int32_t & duration, std::vector<Bonus> & converted) const
diff --color -urN vcmi-1.5.7/lib/spells/effects/UnitEffect.cpp vcmi/lib/spells/effects/UnitEffect.cpp
--- vcmi-1.5.7/lib/spells/effects/UnitEffect.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/spells/effects/UnitEffect.cpp	2024-12-19 15:00:22.942149756 +0100
@@ -164,10 +164,9 @@
 
 	if(m->alwaysHitFirstTarget())
 	{
+		//TODO: examine if adjustments needed related to INVINCIBLE bonus
 		if(!aimPoint.empty() && aimPoint.front().unitValue)
 			targets.insert(aimPoint.front().unitValue);
-		else
-			logGlobal->error("Spell-like attack with no primary target.");
 	}
 
 	EffectTarget effectTarget;
@@ -198,7 +197,7 @@
 
 	auto possibleTargets = m->battle()->battleGetUnitsIf([&](const battle::Unit * unit) -> bool
 	{
-		return isValidTarget(m, unit);
+		return isReceptive(m, unit) && isValidTarget(m, unit);
 	});
 
 	for(const auto *unit : possibleTargets)
diff --color -urN vcmi-1.5.7/lib/spells/ISpellMechanics.cpp vcmi/lib/spells/ISpellMechanics.cpp
--- vcmi-1.5.7/lib/spells/ISpellMechanics.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/spells/ISpellMechanics.cpp	2024-12-19 15:00:22.939149632 +0100
@@ -11,7 +11,6 @@
 #include "StdInc.h"
 #include "ISpellMechanics.h"
 
-#include "../CRandomGenerator.h"
 #include "../VCMI_Lib.h"
 
 #include "../bonuses/Bonus.h"
@@ -37,10 +36,11 @@
 
 #include "CSpellHandler.h"
 
-#include "../CHeroHandler.h"//todo: remove
 #include "../IGameCallback.h"//todo: remove
 #include "../BattleFieldHandler.h"
 
+#include <vstd/RNG.h>
+
 VCMI_LIB_NAMESPACE_BEGIN
 
 namespace spells
@@ -268,11 +268,9 @@
 		const std::string magicMirrorCacheStr = "type_MAGIC_MIRROR";
 		static const auto magicMirrorSelector = Selector::type()(BonusType::MAGIC_MIRROR);
 
-		auto rangeGen = server->getRNG()->getInt64Range(0, 99);
-
 		const int mirrorChance = mainTarget->valOfBonuses(magicMirrorSelector, magicMirrorCacheStr);
 
-		if(rangeGen() < mirrorChance)
+		if(server->getRNG()->nextInt(0, 99) < mirrorChance)
 		{
 			auto mirrorTargets = cb->battleGetUnitsIf([this](const battle::Unit * unit)
 			{
@@ -398,7 +396,7 @@
 ///Mechanics
 Mechanics::Mechanics()
 	: caster(nullptr),
-	casterSide(0)
+	casterSide(BattleSide::NONE)
 {
 
 }
@@ -414,8 +412,7 @@
 {
 	caster = event->getCaster();
 
-	//FIXME: do not crash on invalid side
-	casterSide = cb->playerToSide(caster->getCasterOwner()).value();
+	casterSide = cb->playerToSide(caster->getCasterOwner());
 
 	{
 		auto value = event->getSpellLevel();
diff --color -urN vcmi-1.5.7/lib/spells/ISpellMechanics.h vcmi/lib/spells/ISpellMechanics.h
--- vcmi-1.5.7/lib/spells/ISpellMechanics.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/spells/ISpellMechanics.h	2024-12-19 15:00:22.939149632 +0100
@@ -22,7 +22,6 @@
 
 struct Query;
 class IBattleState;
-class CRandomGenerator;
 class CreatureService;
 class CMap;
 class CGameInfoCallback;
@@ -59,6 +58,7 @@
 	virtual const CMap * getMap() const = 0;
 	virtual const CGameInfoCallback * getCb() const = 0;
 
+	virtual void createBoat(const int3 & visitablePosition, BoatId type, PlayerColor initiator) = 0;
 	virtual bool moveHero(ObjectInstanceID hid, int3 dst, EMovementMode mode) = 0;	//TODO: remove
 
 	virtual void genericQuery(Query * request, PlayerColor color, std::function<void(std::optional<int32_t>)> callback) = 0;//TODO: type safety on query, use generic query packet when implemented
@@ -252,7 +252,7 @@
 
 	const Caster * caster;
 
-	ui8 casterSide;
+	BattleSide casterSide;
 
 protected:
 	Mechanics();
diff --color -urN vcmi-1.5.7/lib/spells/Problem.cpp vcmi/lib/spells/Problem.cpp
--- vcmi-1.5.7/lib/spells/Problem.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/spells/Problem.cpp	2024-12-19 15:00:22.939149632 +0100
@@ -10,6 +10,8 @@
 #include "StdInc.h"
 #include "Problem.h"
 
+#include "../texts/MetaString.h"
+
 VCMI_LIB_NAMESPACE_BEGIN
 
 namespace spells
diff --color -urN vcmi-1.5.7/lib/spells/Problem.h vcmi/lib/spells/Problem.h
--- vcmi-1.5.7/lib/spells/Problem.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/spells/Problem.h	2024-12-19 15:00:22.939149632 +0100
@@ -12,8 +12,6 @@
 
 #include <vcmi/spells/Magic.h>
 
-#include "../MetaString.h"
-
 VCMI_LIB_NAMESPACE_BEGIN
 
 namespace spells
diff --color -urN vcmi-1.5.7/lib/StartInfo.cpp vcmi/lib/StartInfo.cpp
--- vcmi-1.5.7/lib/StartInfo.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/StartInfo.cpp	2024-12-19 15:00:22.873146904 +0100
@@ -10,10 +10,11 @@
 #include "StdInc.h"
 #include "StartInfo.h"
 
-#include "CGeneralTextHandler.h"
-#include "CTownHandler.h"
-#include "CHeroHandler.h"
+#include "texts/CGeneralTextHandler.h"
 #include "VCMI_Lib.h"
+#include "entities/faction/CFaction.h"
+#include "entities/faction/CTownHandler.h"
+#include "entities/hero/CHeroHandler.h"
 #include "rmg/CMapGenOptions.h"
 #include "mapping/CMapInfo.h"
 #include "campaign/CampaignState.h"
@@ -24,7 +25,7 @@
 VCMI_LIB_NAMESPACE_BEGIN
 
 PlayerSettings::PlayerSettings()
-	: bonus(PlayerStartingBonus::RANDOM), color(0), handicap(NO_HANDICAP), compOnly(false)
+	: bonus(PlayerStartingBonus::RANDOM), color(0), compOnly(false)
 {
 }
 
@@ -89,18 +90,22 @@
 		return VLC->generaltexth->allTexts[508];
 }
 
-bool StartInfo::isSteadwickFallCampaignMission() const
+bool StartInfo::isRestorationOfErathiaCampaign() const
 {
-	if (!campState)
-		return false;
+	constexpr std::array roeCampaigns = {
+		"DATA/GOOD1",
+		"DATA/EVIL1",
+		"DATA/GOOD2",
+		"DATA/NEUTRAL1",
+		"DATA/EVIL2",
+		"DATA/GOOD3",
+		"DATA/SECRET1",
+	};
 
-	if (campState->getFilename() != "DATA/EVIL1")
-		return false;
-
-	if (campState->currentScenario() != CampaignScenarioID(2))
+	if (!campState)
 		return false;
 
-	return true;
+	return vstd::contains(roeCampaigns, campState->getFilename());
 }
 
 void LobbyInfo::verifyStateBeforeStart(bool ignoreNoHuman) const
diff --color -urN vcmi-1.5.7/lib/StartInfo.h vcmi/lib/StartInfo.h
--- vcmi-1.5.7/lib/StartInfo.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/StartInfo.h	2024-12-19 15:00:22.874146946 +0100
@@ -15,6 +15,8 @@
 #include "TurnTimerInfo.h"
 #include "ExtraOptionsInfo.h"
 #include "campaign/CampaignConstants.h"
+#include "serializer/Serializeable.h"
+#include "ResourceSet.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
@@ -50,9 +52,10 @@
 		h & optionalTurns;
 		h & allowHumanWithAI;
 
-		static_assert(Handler::Version::RELEASE_143 < Handler::Version::CURRENT, "Please add ignoreAlliedContacts to serialization for 1.6");
-		// disabled to allow multiplayer compatibility between 1.5.2 and 1.5.1
-		// h & ignoreAlliedContacts
+		if (h.version >= Handler::Version::SAVE_COMPATIBILITY_FIXES)
+			h & ignoreAlliedContacts;
+		else
+			ignoreAlliedContacts = true;
 	}
 };
 
@@ -64,6 +67,20 @@
 	RESOURCE =  2
 };
 
+struct DLL_LINKAGE Handicap {
+	TResources startBonus = TResources();
+	int percentIncome = 100;
+	int percentGrowth = 100;
+
+	template <typename Handler>
+	void serialize(Handler &h)
+	{
+		h & startBonus;
+		h & percentIncome;
+		h & percentGrowth;
+	}
+};
+
 /// Struct which describes the name, the color, the starting bonus of a player
 struct DLL_LINKAGE PlayerSettings
 {
@@ -76,8 +93,8 @@
 
 	std::string heroNameTextId;
 	PlayerColor color; //from 0 -
-	enum EHandicap {NO_HANDICAP, MILD, SEVERE};
-	EHandicap handicap;//0-no, 1-mild, 2-severe
+
+	Handicap handicap;
 
 	std::string name;
 	std::set<ui8> connectedPlayerIDs; //Empty - AI, or connectrd player ids
@@ -91,7 +108,14 @@
 		h & heroNameTextId;
 		h & bonus;
 		h & color;
-		h & handicap;
+		if (h.version >= Handler::Version::PLAYER_HANDICAP)
+			h & handicap;
+		else
+		{
+			enum EHandicap {NO_HANDICAP, MILD, SEVERE};
+			EHandicap handicapLegacy = NO_HANDICAP;
+			h & handicapLegacy;
+		}
 		h & name;
 		h & connectedPlayerIDs;
 		h & compOnly;
@@ -114,7 +138,7 @@
 };
 
 /// Struct which describes the difficulty, the turn time,.. of a heroes match.
-struct DLL_LINKAGE StartInfo
+struct DLL_LINKAGE StartInfo : public Serializeable
 {
 	EStartMode mode;
 	ui8 difficulty; //0=easy; 4=impossible
@@ -122,10 +146,7 @@
 	using TPlayerInfos = std::map<PlayerColor, PlayerSettings>;
 	TPlayerInfos playerInfos; //color indexed
 
-	ui32 seedToBeUsed; //0 if not sure (client requests server to decide, will be send in reply pack)
-	ui32 seedPostInit; //so we know that game is correctly synced at the start; 0 if not known yet
-	ui32 mapfileChecksum; //0 if not relevant
-	std::string startTimeIso8601;
+	time_t startTime;
 	std::string fileURI;
 	SimturnsInfo simturnsInfo;
 	TurnTimerInfo turnTimerInfo;
@@ -143,8 +164,8 @@
 	// TODO: Must be client-side
 	std::string getCampaignName() const;
 
-	/// Controls hardcoded check for "Steadwick's Fall" scenario from "Dungeon and Devils" campaign
-	bool isSteadwickFallCampaignMission() const;
+	/// Controls hardcoded check for handling of garrisons by AI in Restoration of Erathia campaigns to match H3 behavior
+	bool isRestorationOfErathiaCampaign() const;
 
 	template <typename Handler>
 	void serialize(Handler &h)
@@ -152,24 +173,37 @@
 		h & mode;
 		h & difficulty;
 		h & playerInfos;
-		h & seedToBeUsed;
-		h & seedPostInit;
-		h & mapfileChecksum;
-		h & startTimeIso8601;
+		if (h.version < Handler::Version::REMOVE_LIB_RNG)
+		{
+			uint32_t oldSeeds = 0;
+			h & oldSeeds;
+			h & oldSeeds;
+			h & oldSeeds;
+		}
+		if (h.version < Handler::Version::FOLDER_NAME_REWORK)
+		{
+			std::string startTimeLegacy;
+			h & startTimeLegacy;
+			struct std::tm tm;
+			std::istringstream ss(startTimeLegacy);
+			ss >> std::get_time(&tm, "%Y%m%dT%H%M%S");
+			startTime = mktime(&tm);
+		}
+		else
+			h & startTime;
 		h & fileURI;
 		h & simturnsInfo;
 		h & turnTimerInfo;
-		if(h.version >= Handler::Version::HAS_EXTRA_OPTIONS)
-			h & extraOptionsInfo;
-		else
-			extraOptionsInfo = ExtraOptionsInfo();
+		h & extraOptionsInfo;
 		h & mapname;
 		h & mapGenOptions;
 		h & campState;
 	}
 
-	StartInfo() : mode(EStartMode::INVALID), difficulty(1), seedToBeUsed(0), seedPostInit(0),
-		mapfileChecksum(0), startTimeIso8601(vstd::getDateTimeISO8601Basic(std::time(nullptr))), fileURI("")
+	StartInfo()
+		: mode(EStartMode::INVALID)
+		, difficulty(1)
+		, startTime(std::time(nullptr))
 	{
 
 	}
diff --color -urN vcmi-1.5.7/lib/TerrainHandler.cpp vcmi/lib/TerrainHandler.cpp
--- vcmi-1.5.7/lib/TerrainHandler.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/TerrainHandler.cpp	2024-12-19 15:00:22.874146946 +0100
@@ -10,31 +10,42 @@
 
 #include "StdInc.h"
 #include "TerrainHandler.h"
-#include "CGeneralTextHandler.h"
-#include "GameSettings.h"
+#include "IGameSettings.h"
 #include "json/JsonNode.h"
 #include "modding/IdentifierStorage.h"
+#include "texts/CGeneralTextHandler.h"
+#include "texts/CLegacyConfigParser.h"
+#include "VCMI_Lib.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
-TerrainType * TerrainTypeHandler::loadFromJson( const std::string & scope, const JsonNode & json, const std::string & identifier, size_t index)
+std::shared_ptr<TerrainType> TerrainTypeHandler::loadFromJson( const std::string & scope, const JsonNode & json, const std::string & identifier, size_t index)
 {
 	assert(identifier.find(':') == std::string::npos);
 
-	auto * info = new TerrainType;
+	auto info = std::make_shared<TerrainType>();
 
 	info->id = TerrainId(index);
 	info->identifier = identifier;
 	info->modScope = scope;
 	info->moveCost = static_cast<int>(json["moveCost"].Integer());
-	info->musicFilename = AudioPath::fromJson(json["music"]);
+	if (json["music"].isVector())
+	{
+		for (auto const & entry : json["music"].Vector())
+			info->musicFilename.push_back(AudioPath::fromJson(entry));
+	}
+	else
+	{
+		info->musicFilename.push_back(AudioPath::fromJson(json["music"]));
+	}
+
 	info->tilesFilename = AnimationPath::fromJson(json["tiles"]);
 	info->horseSound = AudioPath::fromJson(json["horseSound"]);
 	info->horseSoundPenalty = AudioPath::fromJson(json["horseSoundPenalty"]);
 	info->transitionRequired = json["transitionRequired"].Bool();
 	info->terrainViewPatterns = json["terrainViewPatterns"].String();
 
-	VLC->generaltexth->registerString(scope, info->getNameTextID(), json["text"].String());
+	VLC->generaltexth->registerString(scope, info->getNameTextID(), json["text"]);
 
 	const JsonVector & unblockedVec = json["minimapUnblocked"].Vector();
 	info->minimapUnblocked =
@@ -122,7 +133,7 @@
 
 std::vector<JsonNode> TerrainTypeHandler::loadLegacyData()
 {
-	size_t dataSize = VLC->settings()->getInteger(EGameSettings::TEXTS_TERRAIN);
+	size_t dataSize = VLC->engineSettings()->getInteger(EGameSettings::TEXTS_TERRAIN);
 
 	objects.resize(dataSize);
 
@@ -180,6 +191,11 @@
 	return modScope + ":" + identifier;
 }
 
+std::string TerrainType::getModScope() const
+{
+	return modScope;
+}
+
 std::string TerrainType::getNameTextID() const
 {
 	return TextIdentifier( "terrain", modScope, identifier, "name" ).get();
diff --color -urN vcmi-1.5.7/lib/TerrainHandler.h vcmi/lib/TerrainHandler.h
--- vcmi-1.5.7/lib/TerrainHandler.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/TerrainHandler.h	2024-12-19 15:00:22.875146987 +0100
@@ -55,6 +55,7 @@
 	int32_t getIndex() const override { return id.getNum(); }
 	int32_t getIconIndex() const override { return 0; }
 	std::string getJsonKey() const override;
+	std::string getModScope() const override;
 	void registerIcons(const IconRegistar & cb) const override {}
 	TerrainId getId() const override { return id;}
 	void updateFrom(const JsonNode & data) {};
@@ -67,7 +68,7 @@
 	ColorRGBA minimapBlocked;
 	ColorRGBA minimapUnblocked;
 	std::string shortIdentifier;
-	AudioPath musicFilename;
+	std::vector<AudioPath> musicFilename;
 	AnimationPath tilesFilename;
 	std::string terrainViewPatterns;
 	AudioPath horseSound;
@@ -101,7 +102,7 @@
 class DLL_LINKAGE TerrainTypeHandler : public CHandlerBase<TerrainId, TerrainType, TerrainType, TerrainTypeService>
 {
 public:
-	virtual TerrainType * loadFromJson(
+	std::shared_ptr<TerrainType> loadFromJson(
 		const std::string & scope,
 		const JsonNode & json,
 		const std::string & identifier,
diff --color -urN vcmi-1.5.7/lib/TextOperations.cpp vcmi/lib/TextOperations.cpp
--- vcmi-1.5.7/lib/TextOperations.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/TextOperations.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,240 +0,0 @@
-/*
- * TextOperations.cpp, part of VCMI engine
- *
- * Authors: listed in file AUTHORS in main folder
- *
- * License: GNU General Public License v2.0 or later
- * Full text of license available in license.txt file, in main folder
- *
- */
-#include "StdInc.h"
-#include "TextOperations.h"
-
-#include "CGeneralTextHandler.h"
-#include "Languages.h"
-#include "CConfigHandler.h"
-
-#include <vstd/DateUtils.h>
-
-#include <boost/locale.hpp>
-
-VCMI_LIB_NAMESPACE_BEGIN
-
-size_t TextOperations::getUnicodeCharacterSize(char firstByte)
-{
-	// length of utf-8 character can be determined from 1st byte by counting number of highest bits set to 1:
-	// 0xxxxxxx -> 1 -  ASCII chars
-	// 110xxxxx -> 2
-	// 1110xxxx -> 3
-	// 11110xxx -> 4 - last allowed in current standard
-
-	auto value = static_cast<uint8_t>(firstByte);
-
-	if ((value & 0b10000000) == 0)
-		return 1; // ASCII
-
-	if ((value & 0b11100000) == 0b11000000)
-		return 2;
-
-	if ((value & 0b11110000) == 0b11100000)
-		return 3;
-
-	if ((value & 0b11111000) == 0b11110000)
-		return 4;
-
-	assert(0);// invalid unicode sequence
-	return 4;
-}
-
-bool TextOperations::isValidUnicodeCharacter(const char * character, size_t maxSize)
-{
-	assert(maxSize > 0);
-
-	auto value = static_cast<uint8_t>(character[0]);
-
-	// ASCII
-	if ( value < 0b10000000)
-		return maxSize > 0;
-
-	// can't be first byte in UTF8
-	if (value < 0b11000000)
-		return false;
-
-	// above maximum allowed in standard (UTF codepoints are capped at 0x0010FFFF)
-	if (value > 0b11110000)
-		return false;
-
-	// first character must follow rules checked in getUnicodeCharacterSize
-	size_t size = getUnicodeCharacterSize(character[0]);
-
-	if (size > maxSize)
-		return false;
-
-	// remaining characters must have highest bit set to 1
-	for (size_t i = 1; i < size; i++)
-	{
-		auto characterValue = static_cast<uint8_t>(character[i]);
-		if (characterValue < 0b10000000)
-			return false;
-	}
-	return true;
-}
-
-bool TextOperations::isValidASCII(const std::string & text)
-{
-	for (const char & ch : text)
-		if (static_cast<uint8_t>(ch) >= 0x80 )
-			return false;
-	return true;
-}
-
-bool TextOperations::isValidASCII(const char * data, size_t size)
-{
-	for (size_t i=0; i<size; i++)
-		if (static_cast<uint8_t>(data[i]) >= 0x80 )
-			return false;
-	return true;
-}
-
-bool TextOperations::isValidUnicodeString(const std::string & text)
-{
-	for (size_t i=0; i<text.size(); i += getUnicodeCharacterSize(text[i]))
-	{
-		if (!isValidUnicodeCharacter(text.data() + i, text.size() - i))
-			return false;
-	}
-	return true;
-}
-
-bool TextOperations::isValidUnicodeString(const char * data, size_t size)
-{
-	for (size_t i=0; i<size; i += getUnicodeCharacterSize(data[i]))
-	{
-		if (!isValidUnicodeCharacter(data + i, size - i))
-			return false;
-	}
-	return true;
-}
-
-uint32_t TextOperations::getUnicodeCodepoint(const char * data, size_t maxSize)
-{
-	assert(isValidUnicodeCharacter(data, maxSize));
-	if (!isValidUnicodeCharacter(data, maxSize))
-		return 0;
-
-	// https://en.wikipedia.org/wiki/UTF-8#Encoding
-	switch (getUnicodeCharacterSize(data[0]))
-	{
-		case 1:
-			return static_cast<uint8_t>(data[0]) & 0b1111111;
-		case 2:
-			return
-				((static_cast<uint8_t>(data[0]) & 0b11111 ) << 6) +
-				((static_cast<uint8_t>(data[1]) & 0b111111) << 0) ;
-		case 3:
-			return
-				((static_cast<uint8_t>(data[0]) & 0b1111 )  << 12) +
-				((static_cast<uint8_t>(data[1]) & 0b111111) << 6) +
-				((static_cast<uint8_t>(data[2]) & 0b111111) << 0) ;
-		case 4:
-			return
-				((static_cast<uint8_t>(data[0]) & 0b111 )   << 18) +
-				((static_cast<uint8_t>(data[1]) & 0b111111) << 12) +
-				((static_cast<uint8_t>(data[2]) & 0b111111) << 6) +
-				((static_cast<uint8_t>(data[3]) & 0b111111) << 0) ;
-	}
-
-	assert(0);
-	return 0;
-}
-
-uint32_t TextOperations::getUnicodeCodepoint(char data, const std::string & encoding )
-{
-	std::string stringNative(1, data);
-	std::string stringUnicode = toUnicode(stringNative, encoding);
-
-	if (stringUnicode.empty())
-		return 0;
-
-	return getUnicodeCodepoint(stringUnicode.data(), stringUnicode.size());
-}
-
-std::string TextOperations::toUnicode(const std::string &text, const std::string &encoding)
-{
-	return boost::locale::conv::to_utf<char>(text, encoding);
-}
-
-std::string TextOperations::fromUnicode(const std::string &text, const std::string &encoding)
-{
-	return boost::locale::conv::from_utf<char>(text, encoding);
-}
-
-void TextOperations::trimRightUnicode(std::string & text, const size_t amount)
-{
-	if(text.empty())
-		return;
-	//todo: more efficient algorithm
-	for(int i = 0; i< amount; i++){
-		auto b = text.begin();
-		auto e = text.end();
-		size_t lastLen = 0;
-		size_t len = 0;
-		while (b != e) {
-			lastLen = len;
-			size_t n = getUnicodeCharacterSize(*b);
-
-			if(!isValidUnicodeCharacter(&(*b),e-b))
-			{
-				logGlobal->error("Invalid UTF8 sequence");
-				break;//invalid sequence will be trimmed
-			}
-
-			len += n;
-			b += n;
-		}
-
-		text.resize(lastLen);
-	}
-}
-
-size_t TextOperations::getUnicodeCharactersCount(const std::string & text)
-{
-	std::wstring_convert<std::codecvt_utf8<char32_t>, char32_t> conv;
-	return conv.from_bytes(text).size(); 
-}
-
-std::string TextOperations::escapeString(std::string input)
-{
-	boost::replace_all(input, "\\", "\\\\");
-	boost::replace_all(input, "\n", "\\n");
-	boost::replace_all(input, "\r", "\\r");
-	boost::replace_all(input, "\t", "\\t");
-	boost::replace_all(input, "\"", "\\\"");
-
-	return input;
-}
-
-std::string TextOperations::getFormattedDateTimeLocal(std::time_t dt)
-{
-	return vstd::getFormattedDateTime(dt, Languages::getLanguageOptions(settings["general"]["language"].String()).dateTimeFormat);
-}
-
-std::string TextOperations::getFormattedTimeLocal(std::time_t dt)
-{
-	return vstd::getFormattedDateTime(dt, "%H:%M");
-}
-
-std::string TextOperations::getCurrentFormattedTimeLocal(std::chrono::seconds timeOffset)
-{
-	auto timepoint = std::chrono::system_clock::now() + timeOffset;
-	return TextOperations::getFormattedTimeLocal(std::chrono::system_clock::to_time_t(timepoint));
-}
-
-std::string TextOperations::getCurrentFormattedDateTimeLocal(std::chrono::seconds timeOffset)
-{
-	auto timepoint = std::chrono::system_clock::now() + timeOffset;
-	return TextOperations::getFormattedDateTimeLocal(std::chrono::system_clock::to_time_t(timepoint));
-}
-
-
-VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/TextOperations.h vcmi/lib/TextOperations.h
--- vcmi-1.5.7/lib/TextOperations.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/TextOperations.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,97 +0,0 @@
-/*
- * TextOperations.h, part of VCMI engine
- *
- * Authors: listed in file AUTHORS in main folder
- *
- * License: GNU General Public License v2.0 or later
- * Full text of license available in license.txt file, in main folder
- *
- */
-#pragma once
-
-VCMI_LIB_NAMESPACE_BEGIN
-
-/// Namespace that provides utilites for unicode support (UTF-8)
-namespace TextOperations
-{
-	/// returns 32-bit UTF codepoint for UTF-8 character symbol
-	uint32_t DLL_LINKAGE getUnicodeCodepoint(const char *data, size_t maxSize);
-
-	/// returns 32-bit UTF codepoint for character symbol in selected single-byte encoding
-	uint32_t DLL_LINKAGE getUnicodeCodepoint(char data, const std::string & encoding );
-
-	/// returns length (in bytes) of UTF-8 character starting from specified character
-	size_t DLL_LINKAGE getUnicodeCharacterSize(char firstByte);
-
-	/// test if character is a valid UTF-8 symbol
-	/// maxSize - maximum number of bytes this symbol may consist from ( = remainer of string)
-	bool DLL_LINKAGE isValidUnicodeCharacter(const char * character, size_t maxSize);
-
-	/// returns true if text contains valid ASCII-string
-	/// Note that since UTF-8 extends ASCII, any ASCII string is also UTF-8 string
-	bool DLL_LINKAGE isValidASCII(const std::string & text);
-	bool DLL_LINKAGE isValidASCII(const char * data, size_t size);
-
-	/// test if text contains valid UTF-8 sequence
-	bool DLL_LINKAGE isValidUnicodeString(const std::string & text);
-	bool DLL_LINKAGE isValidUnicodeString(const char * data, size_t size);
-
-	/// converts text to UTF-8 from specified encoding or from one specified in settings
-	std::string DLL_LINKAGE toUnicode(const std::string & text, const std::string & encoding);
-
-	/// converts text from unicode to specified encoding or to one specified in settings
-	/// NOTE: usage of these functions should be avoided if possible
-	std::string DLL_LINKAGE fromUnicode(const std::string & text, const std::string & encoding);
-
-	///delete specified amount of UTF-8 characters from right
-	DLL_LINKAGE void trimRightUnicode(std::string & text, size_t amount = 1);
-
-	/// give back amount of unicode characters
-	size_t DLL_LINKAGE getUnicodeCharactersCount(const std::string & text);
-
-	/// converts number into string using metric system prefixes, e.g. 'k' or 'M' to keep resulting strings within specified size
-	/// Note that resulting string may have more symbols than digits: minus sign and prefix symbol
-	template<typename Arithmetic>
-	inline std::string formatMetric(Arithmetic number, int maxDigits);
-
-	/// replaces all symbols that normally need escaping with appropriate escape sequences
-	std::string escapeString(std::string input);
-
-	/// get formatted DateTime depending on the language selected
-	DLL_LINKAGE std::string getFormattedDateTimeLocal(std::time_t dt);
-
-	/// get formatted current DateTime depending on the language selected
-	/// timeOffset - optional parameter to modify current time by specified time in seconds
-	DLL_LINKAGE std::string getCurrentFormattedDateTimeLocal(std::chrono::seconds timeOffset = {});
-
-	/// get formatted time (without date)
-	DLL_LINKAGE std::string getFormattedTimeLocal(std::time_t dt);
-
-	/// get formatted time (without date)
-	/// timeOffset - optional parameter to modify current time by specified time in seconds
-	DLL_LINKAGE std::string getCurrentFormattedTimeLocal(std::chrono::seconds timeOffset = {});
-};
-
-
-
-template<typename Arithmetic>
-inline std::string TextOperations::formatMetric(Arithmetic number, int maxDigits)
-{
-	Arithmetic max = std::pow(10, maxDigits);
-	if (std::abs(number) < max)
-		return std::to_string(number);
-
-	std::string symbols = " kMGTPE";
-	auto iter = symbols.begin();
-
-	while (std::abs(number) >= max)
-	{
-		number /= 1000;
-		iter++;
-
-		assert(iter != symbols.end());//should be enough even for int64
-	}
-	return std::to_string(number) + *iter;
-}
-
-VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/texts/CGeneralTextHandler.cpp vcmi/lib/texts/CGeneralTextHandler.cpp
--- vcmi-1.5.7/lib/texts/CGeneralTextHandler.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/texts/CGeneralTextHandler.cpp	2024-12-19 15:00:22.943149797 +0100
@@ -0,0 +1,373 @@
+/*
+ * CGeneralTextHandler.cpp, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#include "StdInc.h"
+#include "texts/CGeneralTextHandler.h"
+
+#include "CLegacyConfigParser.h"
+#include "CConfigHandler.h"
+#include "IGameSettings.h"
+#include "Languages.h"
+#include "../filesystem/Filesystem.h"
+#include "../mapObjects/CQuest.h"
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+/// Detects language and encoding of H3 text files based on matching against pregenerated footprints of H3 file
+void CGeneralTextHandler::detectInstallParameters()
+{
+	using LanguageFootprint = std::array<double, 16>;
+
+	static const std::array<LanguageFootprint, 7> knownFootprints =
+	{ {
+		{ { 0.1602, 0.0000, 0.0357, 0.0054, 0.0038, 0.0017, 0.0077, 0.0214, 0.0000, 0.0000, 0.1264, 0.1947, 0.2012, 0.1406, 0.0480, 0.0532 } },
+		{ { 0.0559, 0.0000, 0.1983, 0.0051, 0.0222, 0.0183, 0.4596, 0.2405, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000 } },
+		{ { 0.0493, 0.0000, 0.1926, 0.0047, 0.0230, 0.0121, 0.4133, 0.2780, 0.0002, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0259, 0.0008 } },
+		{ { 0.0534, 0.0000, 0.1705, 0.0047, 0.0418, 0.0208, 0.4775, 0.2191, 0.0001, 0.0000, 0.0000, 0.0000, 0.0000, 0.0005, 0.0036, 0.0080 } },
+		{ { 0.0534, 0.0000, 0.1701, 0.0067, 0.0157, 0.0133, 0.4328, 0.2540, 0.0001, 0.0043, 0.0000, 0.0244, 0.0000, 0.0000, 0.0181, 0.0071 } },
+		{ { 0.0548, 0.0000, 0.1744, 0.0061, 0.0031, 0.0009, 0.0046, 0.0136, 0.0000, 0.0004, 0.0000, 0.0000, 0.0227, 0.0061, 0.4882, 0.2252 } },
+		{ { 0.0559, 0.0000, 0.1807, 0.0059, 0.0036, 0.0013, 0.0046, 0.0134, 0.0000, 0.0004, 0.0000, 0.0487, 0.0209, 0.0060, 0.4615, 0.1972 } },
+	} };
+
+	static const std::array<std::string, 7> knownLanguages =
+	{ {
+		"chinese",
+		"english",
+		"french",
+		"german",
+		"polish",
+		"russian",
+		"ukrainian"
+	} };
+
+	if(!CResourceHandler::get("core")->existsResource(TextPath::builtin("DATA/GENRLTXT.TXT")))
+	{
+		Settings language = settings.write["session"]["language"];
+		language->String() = "english";
+
+		Settings confidence = settings.write["session"]["languageDeviation"];
+		confidence->Float() = 1.0;
+
+		Settings encoding = settings.write["session"]["encoding"];
+		encoding->String() = Languages::getLanguageOptions("english").encoding;
+
+		return;
+	}
+
+	// load file that will be used for footprint generation
+	// this is one of the most text-heavy files in game and consists solely from translated texts
+	auto resource = CResourceHandler::get("core")->load(TextPath::builtin("DATA/GENRLTXT.TXT"));
+
+	std::array<size_t, 256> charCount{};
+	std::array<double, 16> footprint{};
+	std::array<double, 6> deviations{};
+
+	auto data = resource->readAll();
+
+	// compute how often each character occurs in input file
+	for (si64 i = 0; i < data.second; ++i)
+		charCount[data.first[i]] += 1;
+
+	// and convert computed data into weights
+	// to reduce amount of data, group footprint data into 16-char blocks.
+	// While this will reduce precision, it should not affect output
+	// since we expect only tiny differences compared to reference footprints
+	for (size_t i = 0; i < 256; ++i)
+		footprint[i/16] += static_cast<double>(charCount[i]) / data.second;
+
+	logGlobal->debug("Language footprint: %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f",
+			footprint[0], footprint[1], footprint[2],  footprint[3],  footprint[4],  footprint[5],  footprint[6],  footprint[7],
+			footprint[8], footprint[9], footprint[10], footprint[11], footprint[12], footprint[13], footprint[14], footprint[15]
+		);
+
+	for (size_t i = 0; i < deviations.size(); ++i)
+	{
+		for (size_t j = 0; j < footprint.size(); ++j)
+			deviations[i] += std::abs((footprint[j] - knownFootprints[i][j]));
+	}
+
+	size_t bestIndex = boost::range::min_element(deviations) - deviations.begin();
+
+	for (size_t i = 0; i < deviations.size(); ++i)
+		logGlobal->debug("Comparing to %s: %f", knownLanguages[i], deviations[i]);
+
+	Settings language = settings.write["session"]["language"];
+	language->String() = knownLanguages[bestIndex];
+
+	Settings confidence = settings.write["session"]["languageDeviation"];
+	confidence->Float() = deviations[bestIndex];
+
+	Settings encoding = settings.write["session"]["encoding"];
+	encoding->String() =  Languages::getLanguageOptions(knownLanguages[bestIndex]).encoding;
+}
+
+void CGeneralTextHandler::readToVector(const std::string & sourceID, const std::string & sourceName)
+{
+	CLegacyConfigParser parser(TextPath::builtin(sourceName));
+	size_t index = 0;
+	do
+	{
+		registerString( "core", {sourceID, index}, parser.readString());
+		index += 1;
+	}
+	while (parser.endLine());
+}
+
+CGeneralTextHandler::CGeneralTextHandler():
+	tcommands        (*this, "core.tcommand" ),
+	hcommands        (*this, "core.hallinfo" ),
+	fcommands        (*this, "core.castinfo" ),
+	advobtxt         (*this, "core.advevent" ),
+	restypes         (*this, "core.restypes" ),
+	overview         (*this, "core.overview" ),
+	arraytxt         (*this, "core.arraytxt" ),
+	primarySkillNames(*this, "core.priskill" ),
+	jktexts          (*this, "core.jktext"   ),
+	tavernInfo       (*this, "core.tvrninfo" ),
+	turnDurations    (*this, "core.turndur"  ),
+	heroscrn         (*this, "core.heroscrn" ),
+	tentColors       (*this, "core.tentcolr" ),
+	levels           (*this, "core.skilllev" ),
+	zelp             (*this, "core.help"     ),
+	allTexts         (*this, "core.genrltxt" ),
+	// pseudo-array, that don't have H3 file with same name
+	seerEmpty        (*this, "core.seerhut.empty"  ),
+	seerNames        (*this, "core.seerhut.names"  ),
+	capColors        (*this, "vcmi.capitalColors"  )
+{
+	readToVector("core.vcdesc",   "DATA/VCDESC.TXT"   );
+	readToVector("core.lcdesc",   "DATA/LCDESC.TXT"   );
+	readToVector("core.tcommand", "DATA/TCOMMAND.TXT" );
+	readToVector("core.hallinfo", "DATA/HALLINFO.TXT" );
+	readToVector("core.castinfo", "DATA/CASTINFO.TXT" );
+	readToVector("core.advevent", "DATA/ADVEVENT.TXT" );
+	readToVector("core.restypes", "DATA/RESTYPES.TXT" );
+	readToVector("core.randsign", "DATA/RANDSIGN.TXT" );
+	readToVector("core.overview", "DATA/OVERVIEW.TXT" );
+	readToVector("core.arraytxt", "DATA/ARRAYTXT.TXT" );
+	readToVector("core.priskill", "DATA/PRISKILL.TXT" );
+	readToVector("core.plcolors", "DATA/PLCOLORS.TXT" );
+	readToVector("core.jktext",   "DATA/JKTEXT.TXT"   );
+	readToVector("core.tvrninfo", "DATA/TVRNINFO.TXT" );
+	readToVector("core.turndur",  "DATA/TURNDUR.TXT"  );
+	readToVector("core.heroscrn", "DATA/HEROSCRN.TXT" );
+	readToVector("core.tentcolr", "DATA/TENTCOLR.TXT" );
+	readToVector("core.skilllev", "DATA/SKILLLEV.TXT" );
+	readToVector("core.cmpmusic", "DATA/CMPMUSIC.TXT" );
+	readToVector("core.minename", "DATA/MINENAME.TXT" );
+	readToVector("core.mineevnt", "DATA/MINEEVNT.TXT" );
+	readToVector("core.xtrainfo", "DATA/XTRAINFO.TXT" );
+
+	{
+		CLegacyConfigParser parser(TextPath::builtin("DATA/RANDTVRN.TXT"));
+		parser.endLine();
+		size_t index = 0;
+		do
+		{
+			std::string line = parser.readString();
+			if(!line.empty())
+			{
+				registerString("core", {"core.randtvrn", index}, line);
+				index += 1;
+			}
+		}
+		while (parser.endLine());
+	}
+	{
+		CLegacyConfigParser parser(TextPath::builtin("DATA/GENRLTXT.TXT"));
+		parser.endLine();
+		size_t index = 0;
+		do
+		{
+			registerString("core", {"core.genrltxt", index}, parser.readString());
+			index += 1;
+		}
+		while (parser.endLine());
+	}
+	{
+		CLegacyConfigParser parser(TextPath::builtin("DATA/HELP.TXT"));
+		size_t index = 0;
+		do
+		{
+			std::string first = parser.readString();
+			std::string second = parser.readString();
+			registerString("core", "core.help." + std::to_string(index) + ".hover", first);
+			registerString("core", "core.help." + std::to_string(index) + ".help",  second);
+			index += 1;
+		}
+		while (parser.endLine());
+	}
+	{
+		CLegacyConfigParser parser(TextPath::builtin("DATA/SEERHUT.TXT"));
+
+		//skip header
+		parser.endLine();
+
+		for (size_t i = 0; i < 6; ++i)
+		{
+			registerString("core", {"core.seerhut.empty", i}, parser.readString());
+		}
+		parser.endLine();
+
+		for (size_t i = 0; i < 9; ++i) //9 types of quests
+		{
+			EQuestMission missionID = static_cast<EQuestMission>(i+1);
+
+			std::string questName = CQuest::missionName(missionID);
+
+			for (size_t j = 0; j < 5; ++j)
+			{
+				std::string questState = CQuest::missionState(j);
+
+				parser.readString(); //front description
+				for (size_t k = 0; k < 6; ++k)
+				{
+					registerString("core", {"core.seerhut.quest", questName, questState, k}, parser.readString());
+				}
+				parser.endLine();
+			}
+		}
+
+		for (size_t k = 0; k < 6; ++k) //Time limit
+		{
+			registerString("core", {"core.seerhut.time", k}, parser.readString());
+		}
+		parser.endLine();
+
+		parser.endLine(); // empty line
+		parser.endLine(); // header
+
+		for (size_t i = 0; i < 48; ++i)
+		{
+			registerString("core", {"core.seerhut.names", i}, parser.readString());
+			parser.endLine();
+		}
+	}
+	{
+		CLegacyConfigParser parser(TextPath::builtin("DATA/CAMPTEXT.TXT"));
+
+		//skip header
+		parser.endLine();
+
+		std::string text;
+		size_t campaignsCount = 0;
+		do
+		{
+			text = parser.readString();
+			if (!text.empty())
+			{
+				registerString("core", {"core.camptext.names", campaignsCount}, text);
+				campaignsCount += 1;
+			}
+		}
+		while (parser.endLine() && !text.empty());
+
+		for (size_t campaign=0; campaign<campaignsCount; campaign++)
+		{
+			size_t region = 0;
+
+			do // skip empty space and header
+			{
+				text = parser.readString();
+			}
+			while (parser.endLine() && text.empty());
+
+			do
+			{
+				text = parser.readString();
+				if (!text.empty())
+				{
+					registerString("core", {"core.camptext.regions", std::to_string(campaign), region}, text);
+					region += 1;
+				}
+			}
+			while (parser.endLine() && !text.empty());
+
+			scenariosCountPerCampaign.push_back(region);
+		}
+	}
+}
+
+int32_t CGeneralTextHandler::pluralText(const int32_t textIndex, const int32_t count) const
+{
+	if(textIndex == 0)
+		return 0;
+	if(textIndex < 0)
+		return -textIndex;
+	if(count == 1)
+		return textIndex;
+
+	return textIndex + 1;
+}
+
+size_t CGeneralTextHandler::getCampaignLength(size_t campaignID) const
+{
+	assert(campaignID < scenariosCountPerCampaign.size());
+
+	if(campaignID < scenariosCountPerCampaign.size())
+		return scenariosCountPerCampaign[campaignID];
+	return 0;
+}
+
+std::string CGeneralTextHandler::getPreferredLanguage()
+{
+	assert(!settings["general"]["language"].String().empty());
+	return settings["general"]["language"].String();
+}
+
+std::string CGeneralTextHandler::getInstalledLanguage()
+{
+	assert(!settings["session"]["language"].String().empty());
+	return settings["session"]["language"].String();
+}
+
+std::string CGeneralTextHandler::getInstalledEncoding()
+{
+	assert(!settings["session"]["encoding"].String().empty());
+	return settings["session"]["encoding"].String();
+}
+
+std::vector<std::string> CGeneralTextHandler::findStringsWithPrefix(const std::string & prefix)
+{
+	std::lock_guard globalLock(globalTextMutex);
+	std::vector<std::string> result;
+
+	for(const auto & entry : stringsLocalizations)
+	{
+		if(boost::algorithm::starts_with(entry.first, prefix))
+			result.push_back(entry.first);
+	}
+
+	return result;
+}
+
+LegacyTextContainer::LegacyTextContainer(CGeneralTextHandler & owner, std::string basePath):
+	owner(owner),
+	basePath(std::move(basePath))
+{}
+
+std::string LegacyTextContainer::operator[](size_t index) const
+{
+	return owner.translate(basePath, index);
+}
+
+LegacyHelpContainer::LegacyHelpContainer(CGeneralTextHandler & owner, std::string basePath):
+	owner(owner),
+	basePath(std::move(basePath))
+{}
+
+std::pair<std::string, std::string> LegacyHelpContainer::operator[](size_t index) const
+{
+	return {
+		owner.translate(basePath + "." + std::to_string(index) + ".hover"),
+		owner.translate(basePath + "." + std::to_string(index) + ".help")
+	};
+}
+
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/texts/CGeneralTextHandler.h vcmi/lib/texts/CGeneralTextHandler.h
--- vcmi-1.5.7/lib/texts/CGeneralTextHandler.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/texts/CGeneralTextHandler.h	2024-12-19 15:00:22.943149797 +0100
@@ -0,0 +1,100 @@
+/*
+ * CGeneralTextHandler.h, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#pragma once
+
+#include "TextLocalizationContainer.h"
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+class CGeneralTextHandler;
+
+/// Small wrapper that provides text access API compatible with old code
+class DLL_LINKAGE LegacyTextContainer
+{
+	CGeneralTextHandler & owner;
+	std::string basePath;
+
+public:
+	LegacyTextContainer(CGeneralTextHandler & owner, std::string basePath);
+	std::string operator [](size_t index) const;
+};
+
+/// Small wrapper that provides help text access API compatible with old code
+class DLL_LINKAGE LegacyHelpContainer
+{
+	CGeneralTextHandler & owner;
+	std::string basePath;
+
+public:
+	LegacyHelpContainer(CGeneralTextHandler & owner, std::string basePath);
+	std::pair<std::string, std::string> operator[](size_t index) const;
+};
+
+/// Handles all text-related data in game
+class DLL_LINKAGE CGeneralTextHandler: public TextLocalizationContainer
+{
+	void readToVector(const std::string & sourceID, const std::string & sourceName);
+
+	/// number of scenarios in specific campaign. TODO: move to a better location
+	std::vector<size_t> scenariosCountPerCampaign;
+
+public:
+	LegacyTextContainer allTexts;
+
+	LegacyTextContainer arraytxt;
+	LegacyTextContainer primarySkillNames;
+	LegacyTextContainer jktexts;
+	LegacyTextContainer heroscrn;
+	LegacyTextContainer overview;//text for Kingdom Overview window
+	LegacyTextContainer capColors; //names of player colors with first letter capitalized ("Red",...)
+	LegacyTextContainer turnDurations; //turn durations for pregame (1 Minute ... Unlimited)
+
+	//towns
+	LegacyTextContainer tcommands; //texts for town screen,
+	LegacyTextContainer hcommands; // town hall screen
+	LegacyTextContainer fcommands; // fort screen
+	LegacyTextContainer tavernInfo;
+
+	LegacyHelpContainer zelp;
+
+	//objects
+	LegacyTextContainer advobtxt;
+	LegacyTextContainer restypes; //names of resources
+	LegacyTextContainer seerEmpty;
+	LegacyTextContainer seerNames;
+	LegacyTextContainer tentColors;
+
+	//sec skills
+	LegacyTextContainer levels;
+
+	std::vector<std::string> findStringsWithPrefix(const std::string & prefix);
+
+	int32_t pluralText(int32_t textIndex, int32_t count) const;
+
+	size_t getCampaignLength(size_t campaignID) const;
+
+	CGeneralTextHandler();
+	CGeneralTextHandler(const CGeneralTextHandler&) = delete;
+	CGeneralTextHandler operator=(const CGeneralTextHandler&) = delete;
+
+	/// Attempts to detect encoding & language of H3 files
+	static void detectInstallParameters();
+
+	/// Returns name of language preferred by user
+	static std::string getPreferredLanguage();
+
+	/// Returns name of language of Heroes III text files
+	static std::string getInstalledLanguage();
+
+	/// Returns name of encoding of Heroes III text files
+	static std::string getInstalledEncoding();
+};
+
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/texts/CLegacyConfigParser.cpp vcmi/lib/texts/CLegacyConfigParser.cpp
--- vcmi-1.5.7/lib/texts/CLegacyConfigParser.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/texts/CLegacyConfigParser.cpp	2024-12-19 15:00:22.943149797 +0100
@@ -0,0 +1,158 @@
+/*
+ * CLegacyConfigParser.cpp, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#include "StdInc.h"
+#include "CLegacyConfigParser.h"
+
+#include "TextOperations.h"
+#include "Languages.h"
+
+#include "../VCMI_Lib.h"
+#include "filesystem/Filesystem.h"
+#include "../modding/CModHandler.h"
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+//Helper for string -> float conversion
+class LocaleWithComma: public std::numpunct<char>
+{
+protected:
+	char do_decimal_point() const override
+	{
+		return ',';
+	}
+};
+
+CLegacyConfigParser::CLegacyConfigParser(const TextPath & resource)
+{
+	auto input = CResourceHandler::get()->load(resource);
+	fileEncoding = VLC->modh->findResourceEncoding(resource);
+
+	data.reset(new char[input->getSize()]);
+	input->read(reinterpret_cast<uint8_t*>(data.get()), input->getSize());
+
+	curr = data.get();
+	end = curr + input->getSize();
+}
+
+std::string CLegacyConfigParser::extractQuotedPart()
+{
+	assert(*curr == '\"');
+
+	curr++; // skip quote
+	const char * begin = curr;
+
+	while (curr != end && *curr != '\"' && *curr != '\t')
+		curr++;
+
+	return std::string(begin, curr++); //increment curr to close quote
+}
+
+std::string CLegacyConfigParser::extractQuotedString()
+{
+	assert(*curr == '\"');
+
+	std::string ret;
+	while (true)
+	{
+		ret += extractQuotedPart();
+
+		// double quote - add it to string and continue quoted part
+		if (curr < end && *curr == '\"')
+		{
+			ret += '\"';
+		}
+		//extract normal part
+		else if(curr < end && *curr != '\t' && *curr != '\r')
+		{
+			const char * begin = curr;
+
+			while (curr < end && *curr != '\t' && *curr != '\r' && *curr != '\"')//find end of string or next quoted part start
+				curr++;
+
+			ret += std::string(begin, curr);
+
+			if(curr>=end || *curr != '\"')
+				return ret;
+		}
+		else // end of string
+			return ret;
+	}
+}
+
+std::string CLegacyConfigParser::extractNormalString()
+{
+	const char * begin = curr;
+
+	while (curr < end && *curr != '\t' && *curr != '\r')//find end of string
+		curr++;
+
+	return std::string(begin, curr);
+}
+
+std::string CLegacyConfigParser::readRawString()
+{
+	if (curr >= end || *curr == '\n')
+		return "";
+
+	std::string ret;
+
+	if (*curr == '\"')
+		ret = extractQuotedString();// quoted text - find closing quote
+	else
+		ret = extractNormalString();//string without quotes - copy till \t or \r
+
+	curr++;
+	return ret;
+}
+
+std::string CLegacyConfigParser::readString()
+{
+	// do not convert strings that are already in ASCII - this will only slow down loading process
+	std::string str = readRawString();
+	if (TextOperations::isValidASCII(str))
+		return str;
+	return TextOperations::toUnicode(str, fileEncoding);
+}
+
+float CLegacyConfigParser::readNumber()
+{
+	std::string input = readRawString();
+
+	std::istringstream stream(input);
+
+	if(input.find(',') != std::string::npos) // code to handle conversion with comma as decimal separator
+		stream.imbue(std::locale(std::locale(), new LocaleWithComma()));
+
+	float result;
+	if ( !(stream >> result) )
+		return 0;
+	return result;
+}
+
+bool CLegacyConfigParser::isNextEntryEmpty() const
+{
+	const char * nextSymbol = curr;
+	while (nextSymbol < end && *nextSymbol == ' ')
+		nextSymbol++; //find next meaningful symbol
+
+	return nextSymbol >= end || *nextSymbol == '\n' || *nextSymbol == '\r' || *nextSymbol == '\t';
+}
+
+bool CLegacyConfigParser::endLine()
+{
+	while (curr < end && *curr !=  '\n')
+		readString();
+
+	curr++;
+
+	return curr < end;
+}
+
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/texts/CLegacyConfigParser.h vcmi/lib/texts/CLegacyConfigParser.h
--- vcmi-1.5.7/lib/texts/CLegacyConfigParser.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/texts/CLegacyConfigParser.h	2024-12-19 15:00:22.943149797 +0100
@@ -0,0 +1,61 @@
+/*
+ * CLegacyConfigParser.h, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#pragma once
+
+#include "filesystem/ResourcePath.h"
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+/// Parser for any text files from H3
+class DLL_LINKAGE CLegacyConfigParser
+{
+	std::string fileEncoding;
+
+	std::unique_ptr<char[]> data;
+	const char * curr;
+	const char * end;
+
+	/// extracts part of quoted string.
+	std::string extractQuotedPart();
+
+	/// extracts quoted string. Any end of lines are ignored, double-quote is considered as "escaping"
+	std::string extractQuotedString();
+
+	/// extracts non-quoted string
+	std::string extractNormalString();
+
+	/// reads "raw" string without encoding conversion
+	std::string readRawString();
+
+public:
+	/// read one entry from current line. Return ""/0 if end of line reached
+	std::string readString();
+	float readNumber();
+
+	template <typename numeric>
+	std::vector<numeric> readNumArray(size_t size)
+	{
+		std::vector<numeric> ret;
+		ret.reserve(size);
+		while (size--)
+			ret.push_back(readNumber());
+		return ret;
+	}
+
+	/// returns true if next entry is empty
+	bool isNextEntryEmpty() const;
+
+	/// end current line
+	bool endLine();
+
+	explicit CLegacyConfigParser(const TextPath & URI);
+};
+
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/texts/Languages.h vcmi/lib/texts/Languages.h
--- vcmi-1.5.7/lib/texts/Languages.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/texts/Languages.h	2024-12-19 15:00:22.943149797 +0100
@@ -0,0 +1,163 @@
+/*
+ * Languages.h, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#pragma once
+
+namespace Languages
+{
+
+enum class EPluralForms
+{
+	NONE,
+	VI_1, // Single plural form, (Vietnamese)
+	EN_2, // Two forms, singular used for one only (English)
+	FR_2, // Two forms, singular used for zero and one (French)
+	UK_3, // Three forms, special cases for numbers ending in 1 and 2, 3, 4, except those ending in 1[1-4] (Ukrainian)
+	CZ_3, // Three forms, special cases for 1 and 2, 3, 4 (Czech)
+	PL_3, // Three forms, special case for one and some numbers ending in 2, 3, or 4 (Polish)
+};
+
+enum class ELanguages
+{
+	CZECH,
+	CHINESE,
+	ENGLISH,
+	FINNISH,
+	FRENCH,
+	GERMAN,
+	HUNGARIAN,
+	ITALIAN,
+	KOREAN,
+	POLISH,
+	PORTUGUESE,
+	RUSSIAN,
+	SPANISH,
+	SWEDISH,
+	TURKISH,
+	UKRAINIAN,
+	VIETNAMESE,
+
+	COUNT
+};
+
+struct Options
+{
+	/// string identifier (ascii, lower-case), e.g. "english"
+	std::string identifier;
+
+	/// human-readable name of language in English
+	std::string nameEnglish;
+
+	/// human-readable name of language in its own language
+	std::string nameNative;
+
+	/// encoding that is used by H3 for this language
+	std::string encoding;
+
+	/// primary IETF language tag
+	std::string tagIETF;
+
+	/// ISO 639-2 (B) language code
+	std::string tagISO2;
+
+	/// DateTime format
+	std::string dateTimeFormat;
+
+	/// Ruleset for plural forms in this language
+	EPluralForms pluralForms = EPluralForms::NONE;
+};
+
+inline const auto & getLanguageList()
+{
+	static const std::array<Options, 17> languages
+	{ {
+		{ "czech",       "Czech",       "etina",    "CP1250", "cs", "cze", "%d.%m.%Y %H:%M", EPluralForms::CZ_3 },
+		{ "chinese",     "Chinese",     "",       "GBK",    "zh", "chi", "%Y-%m-%d %H:%M", EPluralForms::VI_1 }, // Note: actually Simplified Chinese
+		{ "english",     "English",     "English",    "CP1252", "en", "eng", "%Y-%m-%d %H:%M", EPluralForms::EN_2 }, // English uses international date/time format here
+		{ "finnish",     "Finnish",     "Suomi",      "CP1252", "fi", "fin", "%d.%m.%Y %H:%M", EPluralForms::EN_2, },
+		{ "french",      "French",      "Franais",   "CP1252", "fr", "fre", "%d/%m/%Y %H:%M", EPluralForms::FR_2, },
+		{ "german",      "German",      "Deutsch",    "CP1252", "de", "ger", "%d.%m.%Y %H:%M", EPluralForms::EN_2, },
+		{ "hungarian",   "Hungarian",   "Magyar",     "CP1250", "hu", "hun", "%Y. %m. %d. %H:%M", EPluralForms::EN_2 },
+		{ "italian",     "Italian",     "Italiano",   "CP1250", "it", "ita", "%d/%m/%Y %H:%M", EPluralForms::EN_2 },
+		{ "korean",      "Korean",      "",        "CP949",  "ko", "kor", "%Y-%m-%d %H:%M", EPluralForms::VI_1 },
+		{ "polish",      "Polish",      "Polski",     "CP1250", "pl", "pol", "%d.%m.%Y %H:%M", EPluralForms::PL_3 },
+		{ "portuguese",  "Portuguese",  "Portugus",  "CP1252", "pt", "por", "%d/%m/%Y %H:%M", EPluralForms::EN_2 }, // Note: actually Brazilian Portuguese
+		{ "russian",     "Russian",     "",    "CP1251", "ru", "rus", "%d.%m.%Y %H:%M", EPluralForms::UK_3 },
+		{ "spanish",     "Spanish",     "Espaol",    "CP1252", "es", "spa", "%d/%m/%Y %H:%M", EPluralForms::EN_2 },
+		{ "swedish",     "Swedish",     "Svenska",    "CP1252", "sv", "swe", "%Y-%m-%d %H:%M", EPluralForms::EN_2 },
+		{ "turkish",     "Turkish",     "Trke",     "CP1254", "tr", "tur", "%d.%m.%Y %H:%M", EPluralForms::EN_2 },
+		{ "ukrainian",   "Ukrainian",   "", "CP1251", "uk", "ukr", "%d.%m.%Y %H:%M", EPluralForms::UK_3 },
+		{ "vietnamese",  "Vietnamese",  "Ting Vit", "UTF-8",  "vi", "vie", "%d/%m/%Y %H:%M", EPluralForms::VI_1 }, // Fan translation uses special encoding
+	} };
+	static_assert(languages.size() == static_cast<size_t>(ELanguages::COUNT), "Languages array is missing a value!");
+
+	return languages;
+}
+
+inline const Options & getLanguageOptions(ELanguages language)
+{
+	return getLanguageList().at(static_cast<size_t>(language));
+}
+
+inline const Options & getLanguageOptions(const std::string & language)
+{
+	for(const auto & entry : getLanguageList())
+		if(entry.identifier == language)
+			return entry;
+
+	throw std::out_of_range("Language " + language + " does not exists!");
+}
+
+template<typename Numeric>
+inline constexpr int getPluralFormIndex(EPluralForms form, Numeric value)
+{
+	// Based on https://www.gnu.org/software/gettext/manual/html_node/Plural-forms.html
+	switch(form)
+	{
+		case EPluralForms::NONE:
+		case EPluralForms::VI_1:
+			return 0;
+		case EPluralForms::EN_2:
+			if (value == 1)
+				return 1;
+			return 2;
+		case EPluralForms::FR_2:
+			if (value == 1 || value == 0)
+				return 1;
+			return 2;
+		case EPluralForms::UK_3:
+			if (value % 10 == 1 && value % 100 != 11)
+				return 1;
+			if (value%10>=2 && value%10<=4 && (value%100<10 || value%100>=20))
+				return 2;
+			return 0;
+		case EPluralForms::CZ_3:
+			if (value == 1)
+				return 1;
+			if (value>=2 && value<=4)
+				return 2;
+			return 0;
+		case EPluralForms::PL_3:
+			if (value == 1)
+				return 1;
+			if (value%10>=2 && value%10<=4 && (value%100<10 || value%100>=20))
+				return 2;
+			return 0;
+	}
+	throw std::runtime_error("Invalid plural form enumeration received!");
+}
+
+template<typename Numeric>
+inline std::string getPluralFormTextID(std::string languageName, Numeric value, std::string textID)
+{
+	int formIndex = getPluralFormIndex(getLanguageOptions(languageName).pluralForms, value);
+	return textID + '.' + std::to_string(formIndex);
+}
+
+}
diff --color -urN vcmi-1.5.7/lib/texts/MetaString.cpp vcmi/lib/texts/MetaString.cpp
--- vcmi-1.5.7/lib/texts/MetaString.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/texts/MetaString.cpp	2024-12-19 15:00:22.943149797 +0100
@@ -0,0 +1,449 @@
+/*
+ * MetaString.cpp, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#include "StdInc.h"
+#include "MetaString.h"
+
+#include "CArtHandler.h"
+#include "CCreatureHandler.h"
+#include "CCreatureSet.h"
+#include "entities/faction/CFaction.h"
+#include "texts/CGeneralTextHandler.h"
+#include "CSkillHandler.h"
+#include "GameConstants.h"
+#include "VCMI_Lib.h"
+#include "mapObjectConstructors/CObjectClassesHandler.h"
+#include "spells/CSpellHandler.h"
+#include "serializer/JsonSerializeFormat.h"
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+MetaString MetaString::createFromRawString(const std::string & value)
+{
+	MetaString result;
+	result.appendRawString(value);
+	return result;
+}
+
+MetaString MetaString::createFromTextID(const std::string & value)
+{
+	MetaString result;
+	result.appendTextID(value);
+	return result;
+}
+
+void MetaString::appendLocalString(EMetaText type, ui32 serial)
+{
+	message.push_back(EMessage::APPEND_LOCAL_STRING);
+	localStrings.emplace_back(type, serial);
+}
+
+void MetaString::appendRawString(const std::string & value)
+{
+	message.push_back(EMessage::APPEND_RAW_STRING);
+	exactStrings.push_back(value);
+}
+
+void MetaString::appendTextID(const std::string & value)
+{
+	if (!value.empty())
+	{
+		message.push_back(EMessage::APPEND_TEXTID_STRING);
+		stringsTextID.push_back(value);
+	}
+}
+
+void MetaString::appendNumber(int64_t value)
+{
+	message.push_back(EMessage::APPEND_NUMBER);
+	numbers.push_back(value);
+}
+
+void MetaString::appendEOL()
+{
+	message.push_back(EMessage::APPEND_EOL);
+}
+
+void MetaString::replaceLocalString(EMetaText type, ui32 serial)
+{
+	message.push_back(EMessage::REPLACE_LOCAL_STRING);
+	localStrings.emplace_back(type, serial);
+}
+
+void MetaString::replaceRawString(const std::string &txt)
+{
+	message.push_back(EMessage::REPLACE_RAW_STRING);
+	exactStrings.push_back(txt);
+}
+
+void MetaString::replaceTextID(const std::string & value)
+{
+	message.push_back(EMessage::REPLACE_TEXTID_STRING);
+	stringsTextID.push_back(value);
+}
+
+void MetaString::replaceNumber(int64_t txt)
+{
+	message.push_back(EMessage::REPLACE_NUMBER);
+	numbers.push_back(txt);
+}
+
+void MetaString::replacePositiveNumber(int64_t txt)
+{
+	message.push_back(EMessage::REPLACE_POSITIVE_NUMBER);
+	numbers.push_back(txt);
+}
+
+void MetaString::clear()
+{
+	exactStrings.clear();
+	localStrings.clear();
+	stringsTextID.clear();
+	message.clear();
+	numbers.clear();
+}
+
+bool MetaString::empty() const
+{
+	return message.empty() || toString().empty();
+}
+
+std::string MetaString::getLocalString(const std::pair<EMetaText, ui32> & txt) const
+{
+	EMetaText type = txt.first;
+	int ser = txt.second;
+
+	switch(type)
+	{
+		case EMetaText::GENERAL_TXT:
+			return VLC->generaltexth->translate("core.genrltxt", ser);
+		case EMetaText::ARRAY_TXT:
+			return VLC->generaltexth->translate("core.arraytxt", ser);
+		case EMetaText::ADVOB_TXT:
+			return VLC->generaltexth->translate("core.advevent", ser);
+		case EMetaText::JK_TXT:
+			return VLC->generaltexth->translate("core.jktext", ser);
+		default:
+			logGlobal->error("Failed string substitution because type is %d", static_cast<int>(type));
+			return "#@#";
+	}
+}
+
+DLL_LINKAGE std::string MetaString::toString() const
+{
+	std::string dst;
+
+	size_t exSt = 0;
+	size_t loSt = 0;
+	size_t nums = 0;
+	size_t textID = 0;
+	dst.clear();
+
+	for(const auto & elem : message)
+	{
+		switch(elem)
+		{
+			case EMessage::APPEND_RAW_STRING:
+				dst += exactStrings.at(exSt++);
+				break;
+			case EMessage::APPEND_LOCAL_STRING:
+				dst += getLocalString(localStrings.at(loSt++));
+				break;
+			case EMessage::APPEND_TEXTID_STRING:
+				dst += VLC->generaltexth->translate(stringsTextID.at(textID++));
+				break;
+			case EMessage::APPEND_NUMBER:
+				dst += std::to_string(numbers.at(nums++));
+				break;
+			case EMessage::APPEND_EOL:
+				dst += '\n';
+				break;
+			case EMessage::REPLACE_RAW_STRING:
+				boost::replace_first(dst, "%s", exactStrings.at(exSt++));
+				break;
+			case EMessage::REPLACE_LOCAL_STRING:
+				boost::replace_first(dst, "%s", getLocalString(localStrings.at(loSt++)));
+				break;
+			case EMessage::REPLACE_TEXTID_STRING:
+				boost::replace_first(dst, "%s", VLC->generaltexth->translate(stringsTextID.at(textID++)));
+				break;
+			case EMessage::REPLACE_NUMBER:
+				boost::replace_first(dst, "%d", std::to_string(numbers.at(nums++)));
+				break;
+			case EMessage::REPLACE_POSITIVE_NUMBER:
+				if (dst.find("%+d") != std::string::npos)
+				{
+					int64_t value = numbers.at(nums);
+					if (value > 0)
+						boost::replace_first(dst, "%+d", '+' + std::to_string(value));
+					else
+						boost::replace_first(dst, "%+d", std::to_string(value));
+
+					nums++;
+				}
+				else
+					boost::replace_first(dst, "%d", std::to_string(numbers.at(nums++)));
+				break;
+			default:
+				logGlobal->error("MetaString processing error! Received message of type %d", static_cast<int>(elem));
+				assert(0);
+				break;
+		}
+	}
+	return dst;
+}
+
+DLL_LINKAGE std::string MetaString::buildList() const
+{
+	size_t exSt = 0;
+	size_t loSt = 0;
+	size_t nums = 0;
+	size_t textID = 0;
+	std::string lista;
+	for(int i = 0; i < message.size(); ++i)
+	{
+		if(i > 0 && (message.at(i) == EMessage::APPEND_RAW_STRING || message.at(i) == EMessage::APPEND_LOCAL_STRING))
+		{
+			if(exSt == exactStrings.size() - 1)
+				lista += VLC->generaltexth->allTexts[141]; //" and "
+			else
+				lista += ", ";
+		}
+		switch(message.at(i))
+		{
+			case EMessage::APPEND_RAW_STRING:
+				lista += exactStrings.at(exSt++);
+				break;
+			case EMessage::APPEND_LOCAL_STRING:
+				lista += getLocalString(localStrings.at(loSt++));
+				break;
+			case EMessage::APPEND_TEXTID_STRING:
+				lista += VLC->generaltexth->translate(stringsTextID.at(textID++));
+				break;
+			case EMessage::APPEND_NUMBER:
+				lista += std::to_string(numbers.at(nums++));
+				break;
+			case EMessage::APPEND_EOL:
+				lista += '\n';
+				break;
+			case EMessage::REPLACE_RAW_STRING:
+				lista.replace(lista.find("%s"), 2, exactStrings.at(exSt++));
+				break;
+			case EMessage::REPLACE_LOCAL_STRING:
+				lista.replace(lista.find("%s"), 2, getLocalString(localStrings.at(loSt++)));
+				break;
+			case EMessage::REPLACE_TEXTID_STRING:
+				lista.replace(lista.find("%s"), 2, VLC->generaltexth->translate(stringsTextID.at(textID++)));
+				break;
+			case EMessage::REPLACE_NUMBER:
+				lista.replace(lista.find("%d"), 2, std::to_string(numbers.at(nums++)));
+				break;
+			default:
+				logGlobal->error("MetaString processing error! Received message of type %d", int(message.at(i)));
+		}
+	}
+	return lista;
+}
+
+bool MetaString::operator == (const MetaString & other) const
+{
+	return message == other.message && localStrings == other.localStrings && exactStrings == other.exactStrings && stringsTextID == other.stringsTextID && numbers == other.numbers;
+}
+
+void MetaString::jsonSerialize(JsonNode & dest) const
+{
+	JsonNode jsonMessage;
+	JsonNode jsonLocalStrings;
+	JsonNode jsonExactStrings;
+	JsonNode jsonStringsTextID;
+	JsonNode jsonNumbers;
+
+	for (const auto & entry : message )
+	{
+		JsonNode value;
+		value.Float() = static_cast<int>(entry);
+		jsonMessage.Vector().push_back(value);
+	}
+
+	for (const auto & entry : localStrings )
+	{
+		JsonNode value;
+		value.Integer() = static_cast<int>(entry.first) * 10000 + entry.second;
+		jsonLocalStrings.Vector().push_back(value);
+	}
+
+	for (const auto & entry : exactStrings )
+	{
+		JsonNode value;
+		value.String() = entry;
+		jsonExactStrings.Vector().push_back(value);
+	}
+
+	for (const auto & entry : stringsTextID )
+	{
+		JsonNode value;
+		value.String() = entry;
+		jsonStringsTextID.Vector().push_back(value);
+	}
+
+	for (const auto & entry : numbers )
+	{
+		JsonNode value;
+		value.Integer() = entry;
+		jsonNumbers.Vector().push_back(value);
+	}
+
+	dest["message"] = jsonMessage;
+	dest["localStrings"] = jsonLocalStrings;
+	dest["exactStrings"] = jsonExactStrings;
+	dest["stringsTextID"] = jsonStringsTextID;
+	dest["numbers"] = jsonNumbers;
+}
+
+void MetaString::jsonDeserialize(const JsonNode & source)
+{
+	clear();
+
+	if (source.isString())
+	{
+		// compatibility with fields that were converted from string to MetaString
+		if(boost::starts_with(source.String(), "core.") || boost::starts_with(source.String(), "vcmi."))
+			appendTextID(source.String());
+		else
+			appendRawString(source.String());
+		return;
+	}
+
+	for (const auto & entry : source["message"].Vector() )
+		message.push_back(static_cast<EMessage>(entry.Integer()));
+
+	for (const auto & entry : source["localStrings"].Vector() )
+		localStrings.push_back({ static_cast<EMetaText>(entry.Integer() / 10000), entry.Integer() % 10000 });
+
+	for (const auto & entry : source["exactStrings"].Vector() )
+		exactStrings.push_back(entry.String());
+
+	for (const auto & entry : source["stringsTextID"].Vector() )
+		stringsTextID.push_back(entry.String());
+
+	for (const auto & entry : source["numbers"].Vector() )
+		numbers.push_back(entry.Integer());
+}
+
+void MetaString::serializeJson(JsonSerializeFormat & handler)
+{
+	if(handler.saving)
+		jsonSerialize(const_cast<JsonNode&>(handler.getCurrent()));
+
+	if(!handler.saving)
+		jsonDeserialize(handler.getCurrent());
+}
+
+void MetaString::appendName(const ArtifactID & id)
+{
+	appendTextID(id.toEntity(VLC)->getNameTextID());
+}
+
+void MetaString::appendName(const SpellID & id)
+{
+	appendTextID(id.toEntity(VLC)->getNameTextID());
+}
+
+void MetaString::appendName(const PlayerColor & id)
+{
+	appendTextID(TextIdentifier("vcmi.capitalColors", id.getNum()).get());
+}
+
+void MetaString::appendName(const CreatureID & id, TQuantity count)
+{
+	if(count == 1)
+		appendNameSingular(id);
+	else
+		appendNamePlural(id);
+}
+
+void MetaString::appendName(const GameResID& id)
+{
+	appendTextID(TextIdentifier("core.restypes", id.getNum()).get());
+}
+
+void MetaString::appendNameSingular(const CreatureID & id)
+{
+	appendTextID(id.toEntity(VLC)->getNameSingularTextID());
+}
+
+void MetaString::appendNamePlural(const CreatureID & id)
+{
+	appendTextID(id.toEntity(VLC)->getNamePluralTextID());
+}
+
+void MetaString::replaceName(const ArtifactID & id)
+{
+	replaceTextID(id.toEntity(VLC)->getNameTextID());
+}
+
+void MetaString::replaceName(const FactionID & id)
+{
+	replaceTextID(id.toEntity(VLC)->getNameTextID());
+}
+
+void MetaString::replaceName(const MapObjectID & id)
+{
+	replaceTextID(VLC->objtypeh->getObjectName(id, 0));
+}
+
+void MetaString::replaceName(const MapObjectID & id, const MapObjectSubID & subId)
+{
+	replaceTextID(VLC->objtypeh->getObjectName(id, subId));
+}
+
+void MetaString::replaceName(const PlayerColor & id)
+{
+	replaceTextID(TextIdentifier("vcmi.capitalColors", id.getNum()).get());
+}
+
+void MetaString::replaceName(const SecondarySkill & id)
+{
+	replaceTextID(VLC->skillh->getById(id)->getNameTextID());
+}
+
+void MetaString::replaceName(const SpellID & id)
+{
+	replaceTextID(id.toEntity(VLC)->getNameTextID());
+}
+
+void MetaString::replaceName(const GameResID& id)
+{
+	replaceTextID(TextIdentifier("core.restypes", id.getNum()).get());
+}
+
+void MetaString::replaceNameSingular(const CreatureID & id)
+{
+	replaceTextID(id.toEntity(VLC)->getNameSingularTextID());
+}
+
+void MetaString::replaceNamePlural(const CreatureID & id)
+{
+	replaceTextID(id.toEntity(VLC)->getNamePluralTextID());
+}
+
+void MetaString::replaceName(const CreatureID & id, TQuantity count) //adds sing or plural name;
+{
+	if(count == 1)
+		replaceNameSingular(id);
+	else
+		replaceNamePlural(id);
+}
+
+void MetaString::replaceName(const CStackBasicDescriptor & stack)
+{
+	replaceName(stack.getId(), stack.count);
+}
+
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/texts/MetaString.h vcmi/lib/texts/MetaString.h
--- vcmi-1.5.7/lib/texts/MetaString.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/texts/MetaString.h	2024-12-19 15:00:22.943149797 +0100
@@ -0,0 +1,145 @@
+/*
+ * MetaString.h, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#pragma once
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+class JsonNode;
+class ArtifactID;
+class CreatureID;
+class CStackBasicDescriptor;
+class JsonSerializeFormat;
+class MapObjectID;
+class MapObjectSubID;
+class PlayerColor;
+class SecondarySkill;
+class SpellID;
+class FactionID;
+class GameResID;
+using TQuantity = si32;
+
+/// Strings classes that can be used as replacement in MetaString
+enum class EMetaText : uint8_t
+{
+	GENERAL_TXT = 1,
+	ARRAY_TXT,
+	ADVOB_TXT,
+	JK_TXT
+};
+
+/// Class for string formatting tools that also support transfer over network with localization using language of local install
+/// Can be used to compose resulting text from multiple line segments and with placeholder replacement
+class DLL_LINKAGE MetaString
+{
+private:
+	enum class EMessage : uint8_t
+	{
+		APPEND_RAW_STRING,
+		APPEND_LOCAL_STRING,
+		APPEND_TEXTID_STRING,
+		APPEND_NUMBER,
+		REPLACE_RAW_STRING,
+		REPLACE_LOCAL_STRING,
+		REPLACE_TEXTID_STRING,
+		REPLACE_NUMBER,
+		REPLACE_POSITIVE_NUMBER,
+		APPEND_EOL
+	};
+
+	std::vector<EMessage> message;
+
+	std::vector<std::pair<EMetaText,ui32> > localStrings;
+	std::vector<std::string> exactStrings;
+	std::vector<std::string> stringsTextID;
+	std::vector<int64_t> numbers;
+
+	std::string getLocalString(const std::pair<EMetaText, ui32> & txt) const;
+
+public:
+	/// Creates MetaString and appends provided raw string to it
+	static MetaString createFromRawString(const std::string & value);
+	/// Creates MetaString and appends provided text ID string to it
+	static MetaString createFromTextID(const std::string & value);
+
+	/// Appends local string to resulting string
+	void appendLocalString(EMetaText type, ui32 serial);
+	/// Appends raw string, without translation to resulting string
+	void appendRawString(const std::string & value);
+	/// Appends text ID that will be translated in output
+	void appendTextID(const std::string & value);
+	/// Appends specified number to resulting string
+	void appendNumber(int64_t value);
+
+	void appendName(const ArtifactID& id);
+	void appendName(const SpellID& id);
+	void appendName(const PlayerColor& id);
+	void appendName(const CreatureID & id, TQuantity count);
+	void appendName(const GameResID& id);
+	void appendNameSingular(const CreatureID & id);
+	void appendNamePlural(const CreatureID & id);
+	void appendEOL();
+
+	/// Replaces first '%s' placeholder in string with specified local string
+	void replaceLocalString(EMetaText type, ui32 serial);
+	/// Replaces first '%s' placeholder in string with specified fixed, untranslated string
+	void replaceRawString(const std::string & txt);
+	/// Replaces first '%s' placeholder with string ID that will be translated in output
+	void replaceTextID(const std::string & value);
+	/// Replaces first '%d' placeholder in string with specified number
+	void replaceNumber(int64_t txt);
+	/// Replaces first '%+d' placeholder in string with specified number using '+' sign as prefix
+	void replacePositiveNumber(int64_t txt);
+
+	void replaceName(const ArtifactID & id);
+	void replaceName(const FactionID& id);
+	void replaceName(const MapObjectID & id);
+	void replaceName(const MapObjectID & id, const MapObjectSubID & subId);
+	void replaceName(const PlayerColor& id);
+	void replaceName(const SecondarySkill& id);
+	void replaceName(const SpellID& id);
+	void replaceName(const GameResID& id);
+
+	/// Replaces first '%s' placeholder with singular or plural name depending on creatures count
+	void replaceName(const CreatureID & id, TQuantity count);
+	void replaceNameSingular(const CreatureID & id);
+	void replaceNamePlural(const CreatureID & id);
+	/// Replaces first '%s' placeholder with singular or plural name depending on creatures count
+	void replaceName(const CStackBasicDescriptor & stack);
+
+	/// erases any existing content in the string
+	void clear();
+
+	///used to handle loot from creature bank
+	std::string buildList() const;
+
+	/// Convert all stored values into a single, user-readable string
+	std::string toString() const;
+
+	/// Returns true if current string is empty
+	bool empty() const;
+
+	bool operator == (const MetaString & other) const;
+
+	void jsonSerialize(JsonNode & dest) const;
+	void jsonDeserialize(const JsonNode & dest);
+	
+	void serializeJson(JsonSerializeFormat & handler);
+
+	template <typename Handler> void serialize(Handler & h)
+	{
+		h & exactStrings;
+		h & localStrings;
+		h & stringsTextID;
+		h & message;
+		h & numbers;
+	}
+};
+
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/texts/TextIdentifier.h vcmi/lib/texts/TextIdentifier.h
--- vcmi-1.5.7/lib/texts/TextIdentifier.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/texts/TextIdentifier.h	2024-12-19 15:00:22.943149797 +0100
@@ -0,0 +1,42 @@
+/*
+ * TextIdentifier.h, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#pragma once
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+class TextIdentifier
+{
+	std::string identifier;
+public:
+	const std::string & get() const
+	{
+		return identifier;
+	}
+
+	TextIdentifier(const char * id):
+		identifier(id)
+	{}
+
+	TextIdentifier(const std::string & id):
+		identifier(id)
+	{}
+
+	template<typename... T>
+	TextIdentifier(const std::string & id, size_t index, T... rest):
+		TextIdentifier(id + '.' + std::to_string(index), rest...)
+	{}
+
+	template<typename... T>
+	TextIdentifier(const std::string & id, const std::string & id2, T... rest):
+		TextIdentifier(id + '.' + id2, rest...)
+	{}
+};
+
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/texts/TextLocalizationContainer.cpp vcmi/lib/texts/TextLocalizationContainer.cpp
--- vcmi-1.5.7/lib/texts/TextLocalizationContainer.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/texts/TextLocalizationContainer.cpp	2024-12-19 15:00:22.943149797 +0100
@@ -0,0 +1,213 @@
+/*
+ * TextLocalizationContainer.cpp, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#include "StdInc.h"
+#include "TextLocalizationContainer.h"
+
+#include "texts/CGeneralTextHandler.h"
+#include "Languages.h"
+#include "TextOperations.h"
+
+#include "../VCMI_Lib.h"
+#include "../json/JsonNode.h"
+#include "../modding/CModHandler.h"
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+std::recursive_mutex TextLocalizationContainer::globalTextMutex;
+
+void TextLocalizationContainer::registerStringOverride(const std::string & modContext, const TextIdentifier & UID, const std::string & localized, const std::string & language)
+{
+	std::lock_guard globalLock(globalTextMutex);
+
+	assert(!modContext.empty());
+
+	// NOTE: implicitly creates entry, intended - strings added by maps, campaigns, vcmi and potentially - UI mods are not registered anywhere at the moment
+	auto & entry = stringsLocalizations[UID.get()];
+
+	// load string override only in following cases:
+	// a) string was not modified in another mod (e.g. rebalance mod gave skill new description)
+	// b) this string override is defined in the same mod as one that provided modified version of this string
+	if (entry.identifierModContext == entry.baseStringModContext || modContext == entry.baseStringModContext)
+	{
+		entry.translatedText = localized;
+		if (entry.identifierModContext.empty())
+		{
+			entry.identifierModContext = modContext;
+			entry.baseStringModContext = modContext;
+		}
+		else
+		{
+			if (language == VLC->generaltexth->getPreferredLanguage())
+				entry.overriden = true;
+		}
+	}
+	else
+	{
+		logGlobal->debug("Skipping translation override for string %s: changed in a different mod", UID.get());
+	}
+}
+
+void TextLocalizationContainer::addSubContainer(const TextLocalizationContainer & container)
+{
+	std::lock_guard globalLock(globalTextMutex);
+
+	assert(!vstd::contains(subContainers, &container));
+	subContainers.push_back(&container);
+}
+
+void TextLocalizationContainer::removeSubContainer(const TextLocalizationContainer & container)
+{
+	std::lock_guard globalLock(globalTextMutex);
+
+	assert(vstd::contains(subContainers, &container));
+
+	subContainers.erase(std::remove(subContainers.begin(), subContainers.end(), &container), subContainers.end());
+}
+
+const std::string & TextLocalizationContainer::translateString(const TextIdentifier & identifier) const
+{
+	std::lock_guard globalLock(globalTextMutex);
+
+	if(stringsLocalizations.count(identifier.get()) == 0)
+	{
+		for(auto containerIter = subContainers.rbegin(); containerIter != subContainers.rend(); ++containerIter)
+			if((*containerIter)->identifierExists(identifier))
+				return (*containerIter)->translateString(identifier);
+
+		logGlobal->error("Unable to find localization for string '%s'", identifier.get());
+		return identifier.get();
+	}
+
+	const auto & entry = stringsLocalizations.at(identifier.get());
+	return entry.translatedText;
+}
+
+void TextLocalizationContainer::registerString(const std::string & modContext, const TextIdentifier & inputUID, const JsonNode & localized)
+{
+	assert(localized.isNull() || !localized.getModScope().empty());
+	assert(localized.isNull() || !getModLanguage(localized.getModScope()).empty());
+
+	if (localized.isNull())
+		registerString(modContext, modContext, inputUID, localized.String());
+	else
+		registerString(modContext, localized.getModScope(), inputUID, localized.String());
+}
+
+void TextLocalizationContainer::registerString(const std::string & modContext, const TextIdentifier & UID, const std::string & localized)
+{
+	registerString(modContext, modContext, UID, localized);
+}
+
+void TextLocalizationContainer::registerString(const std::string & identifierModContext, const std::string & localizedStringModContext, const TextIdentifier & UID, const std::string & localized)
+{
+	std::lock_guard globalLock(globalTextMutex);
+
+	assert(!identifierModContext.empty());
+	assert(!localizedStringModContext.empty());
+	assert(UID.get().find("..") == std::string::npos); // invalid identifier - there is section that was evaluated to empty string
+	assert(stringsLocalizations.count(UID.get()) == 0 || boost::algorithm::starts_with(UID.get(), "map") || boost::algorithm::starts_with(UID.get(), "header")); // registering already registered string? FIXME: "header" is a workaround. VMAP needs proper integration in translation system
+
+	if(stringsLocalizations.count(UID.get()) > 0)
+	{
+		auto & value = stringsLocalizations[UID.get()];
+		value.translatedText = localized;
+		value.identifierModContext = identifierModContext;
+		value.baseStringModContext = localizedStringModContext;
+	}
+	else
+	{
+		StringState value;
+		value.translatedText = localized;
+		value.identifierModContext = identifierModContext;
+		value.baseStringModContext = localizedStringModContext;
+
+		stringsLocalizations[UID.get()] = value;
+	}
+}
+
+void TextLocalizationContainer::loadTranslationOverrides(const std::string & modContext, const std::string & language, const JsonNode & config)
+{
+	for(const auto & node : config.Struct())
+		registerStringOverride(modContext, node.first, node.second.String(), language);
+}
+
+bool TextLocalizationContainer::identifierExists(const TextIdentifier & UID) const
+{
+	std::lock_guard globalLock(globalTextMutex);
+
+	return stringsLocalizations.count(UID.get());
+}
+
+void TextLocalizationContainer::exportAllTexts(std::map<std::string, std::map<std::string, std::string>> & storage, bool onlyMissing) const
+{
+	std::lock_guard globalLock(globalTextMutex);
+
+	for (auto const & subContainer : subContainers)
+		subContainer->exportAllTexts(storage, onlyMissing);
+
+	for (auto const & entry : stringsLocalizations)
+	{
+		if (onlyMissing && entry.second.overriden)
+			continue;
+
+		std::string textToWrite;
+		std::string modName = entry.second.baseStringModContext;
+
+		if (entry.second.baseStringModContext == entry.second.identifierModContext && modName.find('.') != std::string::npos)
+			modName = modName.substr(0, modName.find('.'));
+
+		boost::range::replace(modName, '.', '_');
+
+		textToWrite = entry.second.translatedText;
+
+		if (!textToWrite.empty())
+			storage[modName][entry.first] = textToWrite;
+	}
+}
+
+std::string TextLocalizationContainer::getModLanguage(const std::string & modContext)
+{
+	if (modContext == "core")
+		return CGeneralTextHandler::getInstalledLanguage();
+	return VLC->modh->getModLanguage(modContext);
+}
+
+void TextLocalizationContainer::jsonSerialize(JsonNode & dest) const
+{
+	std::lock_guard globalLock(globalTextMutex);
+
+	for(auto & s : stringsLocalizations)
+		dest.Struct()[s.first].String() = s.second.translatedText;
+}
+
+TextContainerRegistrable::TextContainerRegistrable()
+{
+	VLC->generaltexth->addSubContainer(*this);
+}
+
+TextContainerRegistrable::~TextContainerRegistrable()
+{
+	VLC->generaltexth->removeSubContainer(*this);
+}
+
+TextContainerRegistrable::TextContainerRegistrable(const TextContainerRegistrable & other)
+	: TextLocalizationContainer(other)
+{
+	VLC->generaltexth->addSubContainer(*this);
+}
+
+TextContainerRegistrable::TextContainerRegistrable(TextContainerRegistrable && other) noexcept
+	:TextLocalizationContainer(other)
+{
+	VLC->generaltexth->addSubContainer(*this);
+}
+
+
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/texts/TextLocalizationContainer.h vcmi/lib/texts/TextLocalizationContainer.h
--- vcmi-1.5.7/lib/texts/TextLocalizationContainer.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/texts/TextLocalizationContainer.h	2024-12-19 15:00:22.944149839 +0100
@@ -0,0 +1,150 @@
+/*
+ * TextLocalizationContainer.h, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#pragma once
+
+#include "TextIdentifier.h"
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+class JsonNode;
+
+class DLL_LINKAGE TextLocalizationContainer
+{
+protected:
+	static std::recursive_mutex globalTextMutex;
+
+	struct StringState
+	{
+		/// Human-readable string that was added on registration
+		std::string translatedText;
+
+		/// ID of mod that created this string
+		std::string identifierModContext;
+
+		/// ID of mod that provides original, untranslated version of this string
+		/// Different from identifierModContext if mod has modified object from another mod (e.g. rebalance mods)
+		std::string baseStringModContext;
+
+		bool overriden = false;
+
+		template <typename Handler>
+		void serialize(Handler & h)
+		{
+			h & translatedText;
+			h & identifierModContext;
+			h & baseStringModContext;
+		}
+	};
+
+	/// map identifier -> localization
+	std::unordered_map<std::string, StringState> stringsLocalizations;
+
+	std::vector<const TextLocalizationContainer *> subContainers;
+
+	/// add selected string to internal storage as high-priority strings
+	void registerStringOverride(const std::string & modContext, const TextIdentifier & UID, const std::string & localized, const std::string & language);
+
+	std::string getModLanguage(const std::string & modContext);
+
+	// returns true if identifier with such name was registered, even if not translated to current language
+	bool identifierExists(const TextIdentifier & UID) const;
+
+public:
+	/// Loads translation from provided json
+	/// Any entries loaded by this will have priority over texts registered normally
+	void loadTranslationOverrides(const std::string & modContext, const std::string & language, JsonNode const & file);
+
+	/// add selected string to internal storage
+	void registerString(const std::string & modContext, const TextIdentifier & UID, const JsonNode & localized);
+	void registerString(const std::string & modContext, const TextIdentifier & UID, const std::string & localized);
+	void registerString(const std::string & identifierModContext, const std::string & localizedStringModContext, const TextIdentifier & UID, const std::string & localized);
+
+	/// returns translated version of a string that can be displayed to user
+	template<typename  ... Args>
+	std::string translate(std::string arg1, Args ... args) const
+	{
+		TextIdentifier id(arg1, args ...);
+		return translateString(id);
+	}
+
+	/// converts identifier into user-readable string
+	const std::string & translateString(const TextIdentifier & identifier) const;
+
+	/// Debug method, returns all currently stored texts
+	/// Format: [mod ID][string ID] -> human-readable text
+	void exportAllTexts(std::map<std::string, std::map<std::string, std::string>> & storage, bool onlyMissing) const;
+
+	/// Add or override subcontainer which can store identifiers
+	void addSubContainer(const TextLocalizationContainer & container);
+
+	/// Remove subcontainer with give name
+	void removeSubContainer(const TextLocalizationContainer & container);
+
+	void jsonSerialize(JsonNode & dest) const;
+
+	template <typename Handler>
+	void serialize(Handler & h)
+	{
+		std::lock_guard globalLock(globalTextMutex);
+
+		if (h.version >= Handler::Version::SIMPLE_TEXT_CONTAINER_SERIALIZATION)
+		{
+			h & stringsLocalizations;
+		}
+		else
+		{
+			std::string key;
+			int64_t sz = stringsLocalizations.size();
+
+			if (h.version >= Handler::Version::REMOVE_TEXT_CONTAINER_SIZE_T)
+			{
+				int64_t size = sz;
+				h & size;
+				sz = size;
+			}
+			else
+			{
+				h & sz;
+			}
+
+			if(h.saving)
+			{
+				for(auto & s : stringsLocalizations)
+				{
+					key = s.first;
+					h & key;
+					h & s.second;
+				}
+			}
+			else
+			{
+				for(size_t i = 0; i < sz; ++i)
+				{
+					h & key;
+					h & stringsLocalizations[key];
+				}
+			}
+		}
+	}
+};
+
+class DLL_LINKAGE TextContainerRegistrable : public TextLocalizationContainer
+{
+public:
+	TextContainerRegistrable();
+	~TextContainerRegistrable();
+
+	TextContainerRegistrable(const TextContainerRegistrable & other);
+	TextContainerRegistrable(TextContainerRegistrable && other) noexcept;
+
+	TextContainerRegistrable& operator=(const TextContainerRegistrable & b) = default;
+};
+
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/texts/TextOperations.cpp vcmi/lib/texts/TextOperations.cpp
--- vcmi-1.5.7/lib/texts/TextOperations.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/texts/TextOperations.cpp	2024-12-19 15:00:22.944149839 +0100
@@ -0,0 +1,240 @@
+/*
+ * TextOperations.cpp, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#include "StdInc.h"
+#include "TextOperations.h"
+
+#include "texts/CGeneralTextHandler.h"
+#include "Languages.h"
+#include "CConfigHandler.h"
+
+#include <vstd/DateUtils.h>
+
+#include <boost/locale.hpp>
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+size_t TextOperations::getUnicodeCharacterSize(char firstByte)
+{
+	// length of utf-8 character can be determined from 1st byte by counting number of highest bits set to 1:
+	// 0xxxxxxx -> 1 -  ASCII chars
+	// 110xxxxx -> 2
+	// 1110xxxx -> 3
+	// 11110xxx -> 4 - last allowed in current standard
+
+	auto value = static_cast<uint8_t>(firstByte);
+
+	if ((value & 0b10000000) == 0)
+		return 1; // ASCII
+
+	if ((value & 0b11100000) == 0b11000000)
+		return 2;
+
+	if ((value & 0b11110000) == 0b11100000)
+		return 3;
+
+	if ((value & 0b11111000) == 0b11110000)
+		return 4;
+
+	assert(0);// invalid unicode sequence
+	return 4;
+}
+
+bool TextOperations::isValidUnicodeCharacter(const char * character, size_t maxSize)
+{
+	assert(maxSize > 0);
+
+	auto value = static_cast<uint8_t>(character[0]);
+
+	// ASCII
+	if ( value < 0b10000000)
+		return maxSize > 0;
+
+	// can't be first byte in UTF8
+	if (value < 0b11000000)
+		return false;
+
+	// above maximum allowed in standard (UTF codepoints are capped at 0x0010FFFF)
+	if (value > 0b11110000)
+		return false;
+
+	// first character must follow rules checked in getUnicodeCharacterSize
+	size_t size = getUnicodeCharacterSize(character[0]);
+
+	if (size > maxSize)
+		return false;
+
+	// remaining characters must have highest bit set to 1
+	for (size_t i = 1; i < size; i++)
+	{
+		auto characterValue = static_cast<uint8_t>(character[i]);
+		if (characterValue < 0b10000000)
+			return false;
+	}
+	return true;
+}
+
+bool TextOperations::isValidASCII(const std::string & text)
+{
+	for (const char & ch : text)
+		if (static_cast<uint8_t>(ch) >= 0x80 )
+			return false;
+	return true;
+}
+
+bool TextOperations::isValidASCII(const char * data, size_t size)
+{
+	for (size_t i=0; i<size; i++)
+		if (static_cast<uint8_t>(data[i]) >= 0x80 )
+			return false;
+	return true;
+}
+
+bool TextOperations::isValidUnicodeString(const std::string & text)
+{
+	for (size_t i=0; i<text.size(); i += getUnicodeCharacterSize(text[i]))
+	{
+		if (!isValidUnicodeCharacter(text.data() + i, text.size() - i))
+			return false;
+	}
+	return true;
+}
+
+bool TextOperations::isValidUnicodeString(const char * data, size_t size)
+{
+	for (size_t i=0; i<size; i += getUnicodeCharacterSize(data[i]))
+	{
+		if (!isValidUnicodeCharacter(data + i, size - i))
+			return false;
+	}
+	return true;
+}
+
+uint32_t TextOperations::getUnicodeCodepoint(const char * data, size_t maxSize)
+{
+	assert(isValidUnicodeCharacter(data, maxSize));
+	if (!isValidUnicodeCharacter(data, maxSize))
+		return 0;
+
+	// https://en.wikipedia.org/wiki/UTF-8#Encoding
+	switch (getUnicodeCharacterSize(data[0]))
+	{
+		case 1:
+			return static_cast<uint8_t>(data[0]) & 0b1111111;
+		case 2:
+			return
+				((static_cast<uint8_t>(data[0]) & 0b11111 ) << 6) +
+				((static_cast<uint8_t>(data[1]) & 0b111111) << 0) ;
+		case 3:
+			return
+				((static_cast<uint8_t>(data[0]) & 0b1111 )  << 12) +
+				((static_cast<uint8_t>(data[1]) & 0b111111) << 6) +
+				((static_cast<uint8_t>(data[2]) & 0b111111) << 0) ;
+		case 4:
+			return
+				((static_cast<uint8_t>(data[0]) & 0b111 )   << 18) +
+				((static_cast<uint8_t>(data[1]) & 0b111111) << 12) +
+				((static_cast<uint8_t>(data[2]) & 0b111111) << 6) +
+				((static_cast<uint8_t>(data[3]) & 0b111111) << 0) ;
+	}
+
+	assert(0);
+	return 0;
+}
+
+uint32_t TextOperations::getUnicodeCodepoint(char data, const std::string & encoding )
+{
+	std::string stringNative(1, data);
+	std::string stringUnicode = toUnicode(stringNative, encoding);
+
+	if (stringUnicode.empty())
+		return 0;
+
+	return getUnicodeCodepoint(stringUnicode.data(), stringUnicode.size());
+}
+
+std::string TextOperations::toUnicode(const std::string &text, const std::string &encoding)
+{
+	return boost::locale::conv::to_utf<char>(text, encoding);
+}
+
+std::string TextOperations::fromUnicode(const std::string &text, const std::string &encoding)
+{
+	return boost::locale::conv::from_utf<char>(text, encoding);
+}
+
+void TextOperations::trimRightUnicode(std::string & text, const size_t amount)
+{
+	if(text.empty())
+		return;
+	//todo: more efficient algorithm
+	for(int i = 0; i< amount; i++){
+		auto b = text.begin();
+		auto e = text.end();
+		size_t lastLen = 0;
+		size_t len = 0;
+		while (b != e) {
+			lastLen = len;
+			size_t n = getUnicodeCharacterSize(*b);
+
+			if(!isValidUnicodeCharacter(&(*b),e-b))
+			{
+				logGlobal->error("Invalid UTF8 sequence");
+				break;//invalid sequence will be trimmed
+			}
+
+			len += n;
+			b += n;
+		}
+
+		text.resize(lastLen);
+	}
+}
+
+size_t TextOperations::getUnicodeCharactersCount(const std::string & text)
+{
+	std::wstring_convert<std::codecvt_utf8<char32_t>, char32_t> conv;
+	return conv.from_bytes(text).size(); 
+}
+
+std::string TextOperations::escapeString(std::string input)
+{
+	boost::replace_all(input, "\\", "\\\\");
+	boost::replace_all(input, "\n", "\\n");
+	boost::replace_all(input, "\r", "\\r");
+	boost::replace_all(input, "\t", "\\t");
+	boost::replace_all(input, "\"", "\\\"");
+
+	return input;
+}
+
+std::string TextOperations::getFormattedDateTimeLocal(std::time_t dt)
+{
+	return vstd::getFormattedDateTime(dt, Languages::getLanguageOptions(settings["general"]["language"].String()).dateTimeFormat);
+}
+
+std::string TextOperations::getFormattedTimeLocal(std::time_t dt)
+{
+	return vstd::getFormattedDateTime(dt, "%H:%M");
+}
+
+std::string TextOperations::getCurrentFormattedTimeLocal(std::chrono::seconds timeOffset)
+{
+	auto timepoint = std::chrono::system_clock::now() + timeOffset;
+	return TextOperations::getFormattedTimeLocal(std::chrono::system_clock::to_time_t(timepoint));
+}
+
+std::string TextOperations::getCurrentFormattedDateTimeLocal(std::chrono::seconds timeOffset)
+{
+	auto timepoint = std::chrono::system_clock::now() + timeOffset;
+	return TextOperations::getFormattedDateTimeLocal(std::chrono::system_clock::to_time_t(timepoint));
+}
+
+
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/texts/TextOperations.h vcmi/lib/texts/TextOperations.h
--- vcmi-1.5.7/lib/texts/TextOperations.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/lib/texts/TextOperations.h	2024-12-19 15:00:22.944149839 +0100
@@ -0,0 +1,95 @@
+/*
+ * TextOperations.h, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#pragma once
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+/// Namespace that provides utilities for unicode support (UTF-8)
+namespace TextOperations
+{
+	/// returns 32-bit UTF codepoint for UTF-8 character symbol
+	uint32_t DLL_LINKAGE getUnicodeCodepoint(const char *data, size_t maxSize);
+
+	/// returns 32-bit UTF codepoint for character symbol in selected single-byte encoding
+	uint32_t DLL_LINKAGE getUnicodeCodepoint(char data, const std::string & encoding );
+
+	/// returns length (in bytes) of UTF-8 character starting from specified character
+	size_t DLL_LINKAGE getUnicodeCharacterSize(char firstByte);
+
+	/// test if character is a valid UTF-8 symbol
+	/// maxSize - maximum number of bytes this symbol may consist from ( = remainder of string)
+	bool DLL_LINKAGE isValidUnicodeCharacter(const char * character, size_t maxSize);
+
+	/// returns true if text contains valid ASCII-string
+	/// Note that since UTF-8 extends ASCII, any ASCII string is also UTF-8 string
+	bool DLL_LINKAGE isValidASCII(const std::string & text);
+	bool DLL_LINKAGE isValidASCII(const char * data, size_t size);
+
+	/// test if text contains valid UTF-8 sequence
+	bool DLL_LINKAGE isValidUnicodeString(const std::string & text);
+	bool DLL_LINKAGE isValidUnicodeString(const char * data, size_t size);
+
+	/// converts text to UTF-8 from specified encoding or from one specified in settings
+	std::string DLL_LINKAGE toUnicode(const std::string & text, const std::string & encoding);
+
+	/// converts text from unicode to specified encoding or to one specified in settings
+	/// NOTE: usage of these functions should be avoided if possible
+	std::string DLL_LINKAGE fromUnicode(const std::string & text, const std::string & encoding);
+
+	///delete specified amount of UTF-8 characters from right
+	DLL_LINKAGE void trimRightUnicode(std::string & text, size_t amount = 1);
+
+	/// give back amount of unicode characters
+	size_t DLL_LINKAGE getUnicodeCharactersCount(const std::string & text);
+
+	/// converts number into string using metric system prefixes, e.g. 'k' or 'M' to keep resulting strings within specified size
+	/// Note that resulting string may have more symbols than digits: minus sign and prefix symbol
+	template<typename Arithmetic>
+	inline std::string formatMetric(Arithmetic number, int maxDigits);
+
+	/// replaces all symbols that normally need escaping with appropriate escape sequences
+	std::string escapeString(std::string input);
+
+	/// get formatted DateTime depending on the language selected
+	DLL_LINKAGE std::string getFormattedDateTimeLocal(std::time_t dt);
+
+	/// get formatted current DateTime depending on the language selected
+	/// timeOffset - optional parameter to modify current time by specified time in seconds
+	DLL_LINKAGE std::string getCurrentFormattedDateTimeLocal(std::chrono::seconds timeOffset = {});
+
+	/// get formatted time (without date)
+	DLL_LINKAGE std::string getFormattedTimeLocal(std::time_t dt);
+
+	/// get formatted time (without date)
+	/// timeOffset - optional parameter to modify current time by specified time in seconds
+	DLL_LINKAGE std::string getCurrentFormattedTimeLocal(std::chrono::seconds timeOffset = {});
+};
+
+template<typename Arithmetic>
+inline std::string TextOperations::formatMetric(Arithmetic number, int maxDigits)
+{
+	Arithmetic max = std::pow(10, maxDigits);
+	if (std::abs(number) < max)
+		return std::to_string(number);
+
+	std::string symbols = " kMGTPE";
+	auto iter = symbols.begin();
+
+	while (std::abs(number) >= max)
+	{
+		number /= 1000;
+		iter++;
+
+		assert(iter != symbols.end());//should be enough even for int64
+	}
+	return std::to_string(number) + *iter;
+}
+
+VCMI_LIB_NAMESPACE_END
diff --color -urN vcmi-1.5.7/lib/TurnTimerInfo.cpp vcmi/lib/TurnTimerInfo.cpp
--- vcmi-1.5.7/lib/TurnTimerInfo.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/TurnTimerInfo.cpp	2024-12-19 15:00:22.875146987 +0100
@@ -22,9 +22,9 @@
 	return turnTimer > 0 || baseTimer > 0 || unitTimer > 0 || battleTimer > 0;
 }
 
-void TurnTimerInfo::substractTimer(int timeMs)
+void TurnTimerInfo::subtractTimer(int timeMs)
 {
-	auto const & substractTimer = [&timeMs](int & targetTimer)
+	auto const & subtractTimer = [&timeMs](int & targetTimer)
 	{
 		if (targetTimer > timeMs)
 		{
@@ -38,10 +38,10 @@
 		}
 	};
 
-	substractTimer(unitTimer);
-	substractTimer(battleTimer);
-	substractTimer(turnTimer);
-	substractTimer(baseTimer);
+	subtractTimer(unitTimer);
+	subtractTimer(battleTimer);
+	subtractTimer(turnTimer);
+	subtractTimer(baseTimer);
 }
 
 int TurnTimerInfo::valueMs() const
diff --color -urN vcmi-1.5.7/lib/TurnTimerInfo.h vcmi/lib/TurnTimerInfo.h
--- vcmi-1.5.7/lib/TurnTimerInfo.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/TurnTimerInfo.h	2024-12-19 15:00:22.875146987 +0100
@@ -28,7 +28,7 @@
 	bool isEnabled() const;
 	bool isBattleEnabled() const;
 
-	void substractTimer(int timeMs);
+	void subtractTimer(int timeMs);
 	int valueMs() const;
 
 	bool operator == (const TurnTimerInfo & other) const;
diff --color -urN vcmi-1.5.7/lib/VCMIDirs.cpp vcmi/lib/VCMIDirs.cpp
--- vcmi-1.5.7/lib/VCMIDirs.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/VCMIDirs.cpp	2024-12-19 15:00:22.877147070 +0100
@@ -104,7 +104,7 @@
 
 		":CLIENT_NOT_RUNNING"									"\n"
 		"echo %1% turned off..."								"\n"
-		"echo Attempt to move datas."							"\n"
+		"echo Attempt to move data."							"\n"
 		"echo From: %2%"										"\n"
 		"echo To: %4%"											"\n"
 		"echo Please resolve any conflicts..."					"\n"
@@ -118,7 +118,7 @@
 			"pause"												"\n" // Press any key to continue...
 			"goto REMOVE_OLD_DIR"								"\n"
 		")"														"\n"
-		"echo Game data updated succefully."					"\n"
+		"echo Game data updated successfully."					"\n"
 		"echo Please update your shortcuts."					"\n"
 		"echo Press any key to start a game . . ."				"\n"
 		"pause > nul"											"\n"
@@ -138,7 +138,7 @@
 	bathFile << (boost::format(base) % exeName % from % (from / "*.*") % to % startGameString.str()).str();
 	bathFile.close();
 
-	std::system(("start \"Updating VCMI datas\" /D \"" + to.string() + "\" \"" + bathFilename.string() + '\"').c_str());
+	std::system(("start \"Updating VCMI data\" /D \"" + to.string() + "\" \"" + bathFilename.string() + '\"').c_str());
 	// start won't block std::system
 	// /D start bat in other directory insteand of current directory.
 
@@ -239,7 +239,7 @@
 		if (bfs::current_path() == from)
 			bfs::current_path(to);
 
-		// TODO: Log fact that we moved files succefully.
+		// TODO: Log fact that we moved files successfully.
 		bfs::remove(from);
 		return true;
 	};
@@ -267,7 +267,7 @@
 	{
 		const bfs::path executablePath = getModulePath(nullptr);
 
-		// VCMI cann't determine executable path.
+		// VCMI can't determine executable path.
 		// Use standard way to move directory and exit function.
 		if (executablePath.empty())
 			return moveDirIfExists(from, to);
@@ -473,7 +473,7 @@
 			const bfs::path& srcFilePath = file->path();
 			const bfs::path  dstFilePath = to / srcFilePath.filename();
 
-			// TODO: Aplication should ask user what to do when file exists:
+			// TODO: Application should ask user what to do when file exists:
 			// replace/ignore/stop process/replace all/ignore all
 			if (!bfs::exists(dstFilePath))
 				bfs::rename(srcFilePath, dstFilePath);
diff --color -urN vcmi-1.5.7/lib/VCMI_lib.cbp vcmi/lib/VCMI_lib.cbp
--- vcmi-1.5.7/lib/VCMI_lib.cbp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/VCMI_lib.cbp	1970-01-01 01:00:00.000000000 +0100
@@ -1,529 +0,0 @@
-<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
-<CodeBlocks_project_file>
-	<FileVersion major="1" minor="6" />
-	<Project>
-		<Option title="VCMI_lib" />
-		<Option execution_dir="D:/projects/vcmi/engine/VCMI_lib/" />
-		<Option pch_mode="2" />
-		<Option compiler="gcc" />
-		<Build>
-			<Target title="Debug-win32">
-				<Option platforms="Windows;" />
-				<Option output="../VCMI_lib" prefix_auto="0" extension_auto="1" />
-				<Option object_output="../obj/Lib/Debug/x86" />
-				<Option type="3" />
-				<Option compiler="gcc" />
-				<Option host_application="D:/projects/vcmi/engine/VCMI_client.exe" />
-				<Option run_host_application_in_terminal="1" />
-				<Option createStaticLib="1" />
-				<Compiler>
-					<Add option="-Og" />
-					<Add option="-g" />
-					<Add directory="$(#zlib.include)" />
-				</Compiler>
-				<Linker>
-					<Add option="-lws2_32" />
-					<Add option="-lz" />
-					<Add option="-lminizip" />
-					<Add option="-lboost_filesystem$(#boost.libsuffix32)" />
-					<Add option="-lboost_system$(#boost.libsuffix32)" />
-					<Add option="-lboost_thread$(#boost.libsuffix32)" />
-					<Add option="-lboost_chrono$(#boost.libsuffix32)" />
-					<Add option="-lboost_locale$(#boost.libsuffix32)" />
-					<Add option="-lboost_date_time$(#boost.libsuffix32)" />
-					<Add option="-liconv" />
-					<Add option="-ldbghelp" />
-					<Add directory="$(#boost.lib32)" />
-					<Add directory="$(#sdl2.lib)" />
-					<Add directory="$(#zlib.lib)" />
-				</Linker>
-			</Target>
-			<Target title="Release-win32">
-				<Option platforms="Windows;" />
-				<Option output="../VCMI_lib" prefix_auto="0" extension_auto="1" />
-				<Option object_output="../obj/Lib/Release/x86" />
-				<Option type="3" />
-				<Option compiler="gcc" />
-				<Option createStaticLib="1" />
-				<Compiler>
-					<Add option="-fomit-frame-pointer" />
-					<Add option="-O2" />
-					<Add directory="$(#zlib.include)" />
-				</Compiler>
-				<Linker>
-					<Add option="-s" />
-					<Add option="-lws2_32" />
-					<Add option="-lz" />
-					<Add option="-lminizip" />
-					<Add option="-lboost_filesystem$(#boost.libsuffix32)" />
-					<Add option="-lboost_system$(#boost.libsuffix32)" />
-					<Add option="-lboost_thread$(#boost.libsuffix32)" />
-					<Add option="-lboost_chrono$(#boost.libsuffix32)" />
-					<Add option="-lboost_locale$(#boost.libsuffix32)" />
-					<Add option="-lboost_date_time$(#boost.libsuffix32)" />
-					<Add option="-liconv" />
-					<Add directory="$(#boost.lib32)" />
-					<Add directory="$(#sdl2.lib)" />
-					<Add directory="$(#zlib.lib)" />
-				</Linker>
-			</Target>
-			<Target title="Debug-win64">
-				<Option platforms="Windows;" />
-				<Option output="../VCMI_lib" prefix_auto="0" extension_auto="1" />
-				<Option object_output="../obj/Lib/Debug/x64" />
-				<Option type="3" />
-				<Option compiler="gnu_gcc_compiler_x64" />
-				<Option host_application="D:/projects/vcmi/engine/VCMI_client.exe" />
-				<Option run_host_application_in_terminal="1" />
-				<Option createStaticLib="1" />
-				<Compiler>
-					<Add option="-Og" />
-					<Add option="-g" />
-					<Add directory="$(#zlib64.include)" />
-				</Compiler>
-				<Linker>
-					<Add option="-lws2_32" />
-					<Add option="-lzlib" />
-					<Add option="-lminizip" />
-					<Add option="-lboost_filesystem$(#boost.libsuffix64)" />
-					<Add option="-lboost_system$(#boost.libsuffix64)" />
-					<Add option="-lboost_thread$(#boost.libsuffix64)" />
-					<Add option="-lboost_chrono$(#boost.libsuffix64)" />
-					<Add option="-lboost_locale$(#boost.libsuffix64)" />
-					<Add option="-lboost_date_time$(#boost.libsuffix64)" />
-					<Add option="-liconv" />
-					<Add option="-ldbghelp" />
-					<Add directory="$(#boost.lib64)" />
-					<Add directory="$(#sdl2.lib64)" />
-					<Add directory="$(#zlib64.lib)" />
-				</Linker>
-			</Target>
-		</Build>
-		<Compiler>
-			<Add option="-Wextra" />
-			<Add option="-Wall" />
-			<Add option="-std=gnu++11" />
-			<Add option="-fexceptions" />
-			<Add option="-Wpointer-arith" />
-			<Add option="-Wno-switch" />
-			<Add option="-Wno-sign-compare" />
-			<Add option="-Wno-unused-parameter" />
-			<Add option="-Wno-overloaded-virtual" />
-			<Add option="-Wno-unused-local-typedefs" />
-			<Add option="-isystem $(#boost.include)" />
-			<Add option="-DVCMI_DLL" />
-			<Add option="-DBOOST_ALL_DYN_LINK" />
-			<Add option="-DBOOST_SYSTEM_NO_DEPRECATED" />
-			<Add option="-DBOOST_UUID_RANDOM_PROVIDER_FORCE_WINCRYPT" />
-			<Add option="-D_WIN32_WINNT=0x0600" />
-			<Add option="-D_WIN32" />
-			<Add option="-DVCMI_NO_EXTRA_VERSION" />
-			<Add directory="." />
-			<Add directory="$(#sdl2.include)" />
-			<Add directory="../include" />
-		</Compiler>
-		<Linker>
-			<Add directory="../" />
-		</Linker>
-		<Unit filename="../CMakeLists.txt" />
-		<Unit filename="../Global.h" />
-		<Unit filename="../AUTHORS.h" />
-		<Unit filename="../Version.h" />
-		<Unit filename="../include/vcmi/Artifact.h" />
-		<Unit filename="../include/vcmi/ArtifactService.h" />
-		<Unit filename="../include/vcmi/Creature.h" />
-		<Unit filename="../include/vcmi/CreatureService.h" />
-		<Unit filename="../include/vcmi/Entity.h" />
-		<Unit filename="../include/vcmi/EntityService.h" />
-		<Unit filename="../include/vcmi/Environment.h" />
-		<Unit filename="../include/vcmi/Faction.h" />
-		<Unit filename="../include/vcmi/FactionService.h" />
-		<Unit filename="../include/vcmi/HeroClass.h" />
-		<Unit filename="../include/vcmi/HeroClassService.h" />
-		<Unit filename="../include/vcmi/HeroType.h" />
-		<Unit filename="../include/vcmi/HeroTypeService.h" />
-		<Unit filename="../include/vcmi/Metatype.h" />
-		<Unit filename="../include/vcmi/Player.h" />
-		<Unit filename="../include/vcmi/ServerCallback.h" />
-		<Unit filename="../include/vcmi/Services.h" />
-		<Unit filename="../include/vcmi/Skill.h" />
-		<Unit filename="../include/vcmi/SkillService.h" />
-		<Unit filename="../include/vcmi/Team.h" />
-		<Unit filename="../include/vcmi/events/AdventureEvents.h" />
-		<Unit filename="../include/vcmi/events/ApplyDamage.h" />
-		<Unit filename="../include/vcmi/events/BattleEvents.h" />
-		<Unit filename="../include/vcmi/events/Event.h" />
-		<Unit filename="../include/vcmi/events/EventBus.h" />
-		<Unit filename="../include/vcmi/events/GameResumed.h" />
-		<Unit filename="../include/vcmi/events/GenericEvents.h" />
-		<Unit filename="../include/vcmi/events/ObjectVisitEnded.h" />
-		<Unit filename="../include/vcmi/events/ObjectVisitStarted.h" />
-		<Unit filename="../include/vcmi/events/PlayerGotTurn.h" />
-		<Unit filename="../include/vcmi/events/SubscriptionRegistry.h" />
-		<Unit filename="../include/vcmi/events/TurnStarted.h" />
-		<Unit filename="../include/vcmi/scripting/Service.h" />
-		<Unit filename="../include/vcmi/spells/Caster.h" />
-		<Unit filename="../include/vcmi/spells/Magic.h" />
-		<Unit filename="../include/vcmi/spells/Service.h" />
-		<Unit filename="../include/vcmi/spells/Spell.h" />
-		<Unit filename="../include/vstd/CLoggerBase.h" />
-		<Unit filename="../include/vstd/ContainerUtils.h" />
-		<Unit filename="../include/vstd/RNG.h" />
-		<Unit filename="../include/vstd/StringUtils.h" />
-		<Unit filename="../scripts/lib/Metatype.lua" />
-		<Unit filename="../scripts/lib/erm.lua" />
-		<Unit filename="../scripts/lib/erm/BM.lua" />
-		<Unit filename="../scripts/lib/erm/BU.lua" />
-		<Unit filename="../scripts/lib/erm/DO.lua" />
-		<Unit filename="../scripts/lib/erm/FU.lua" />
-		<Unit filename="../scripts/lib/erm/FU_T.lua" />
-		<Unit filename="../scripts/lib/erm/GM_T.lua" />
-		<Unit filename="../scripts/lib/erm/HE.lua" />
-		<Unit filename="../scripts/lib/erm/IF.lua" />
-		<Unit filename="../scripts/lib/erm/MA.lua" />
-		<Unit filename="../scripts/lib/erm/MF.lua" />
-		<Unit filename="../scripts/lib/erm/MF_T.lua" />
-		<Unit filename="../scripts/lib/erm/OB_T.lua" />
-		<Unit filename="../scripts/lib/erm/OW.lua" />
-		<Unit filename="../scripts/lib/erm/PI_T.lua" />
-		<Unit filename="../scripts/lib/erm/ReceiverBase.lua" />
-		<Unit filename="../scripts/lib/erm/TM.lua" />
-		<Unit filename="../scripts/lib/erm/TM_T.lua" />
-		<Unit filename="../scripts/lib/erm/TriggerBase.lua" />
-		<Unit filename="../scripts/lib/erm/UN.lua" />
-		<Unit filename="../scripts/lib/erm/VR.lua" />
-		<Unit filename="../scripts/lib/verm.lua" />
-		<Unit filename="AI_Base.h" />
-		<Unit filename="CArtHandler.cpp" />
-		<Unit filename="CArtHandler.h" />
-		<Unit filename="CBonusTypeHandler.cpp" />
-		<Unit filename="CBonusTypeHandler.h" />
-		<Unit filename="CBuildingHandler.cpp" />
-		<Unit filename="CBuildingHandler.h" />
-		<Unit filename="CConfigHandler.cpp" />
-		<Unit filename="CConfigHandler.h" />
-		<Unit filename="CConsoleHandler.cpp" />
-		<Unit filename="CConsoleHandler.h" />
-		<Unit filename="CCreatureHandler.cpp" />
-		<Unit filename="CCreatureHandler.h" />
-		<Unit filename="CCreatureSet.cpp" />
-		<Unit filename="CCreatureSet.h" />
-		<Unit filename="CGameInfoCallback.cpp" />
-		<Unit filename="CGameInfoCallback.h" />
-		<Unit filename="CGameInterface.cpp" />
-		<Unit filename="CGameInterface.h" />
-		<Unit filename="CGameState.cpp" />
-		<Unit filename="CGameState.h" />
-		<Unit filename="CGameStateFwd.h" />
-		<Unit filename="CGeneralTextHandler.cpp" />
-		<Unit filename="CGeneralTextHandler.h" />
-		<Unit filename="CHeroHandler.cpp" />
-		<Unit filename="CHeroHandler.h" />
-		<Unit filename="CMakeLists.txt" />
-		<Unit filename="CModHandler.cpp" />
-		<Unit filename="CModHandler.h" />
-		<Unit filename="CPathfinder.cpp" />
-		<Unit filename="CPathfinder.h" />
-		<Unit filename="CPlayerState.cpp" />
-		<Unit filename="CPlayerState.h" />
-		<Unit filename="CRandomGenerator.cpp" />
-		<Unit filename="CRandomGenerator.h" />
-		<Unit filename="CScriptingModule.cpp" />
-		<Unit filename="CScriptingModule.h" />
-		<Unit filename="CSkillHandler.cpp" />
-		<Unit filename="CSkillHandler.h" />
-		<Unit filename="CSoundBase.h" />
-		<Unit filename="CStack.cpp" />
-		<Unit filename="CStack.h" />
-		<Unit filename="CStopWatch.h" />
-		<Unit filename="CThreadHelper.cpp" />
-		<Unit filename="CThreadHelper.h" />
-		<Unit filename="CTownHandler.cpp" />
-		<Unit filename="CTownHandler.h" />
-		<Unit filename="CondSh.h" />
-		<Unit filename="ConstTransitivePtr.h" />
-		<Unit filename="FunctionList.h" />
-		<Unit filename="GameConstants.cpp" />
-		<Unit filename="GameConstants.h" />
-		<Unit filename="HeroBonus.cpp" />
-		<Unit filename="Bonus.h" />
-		<Unit filename="IBonusTypeHandler.h" />
-		<Unit filename="IGameCallback.cpp" />
-		<Unit filename="IGameCallback.h" />
-		<Unit filename="IGameEventsReceiver.h" />
-		<Unit filename="IHandlerBase.cpp" />
-		<Unit filename="IHandlerBase.h" />
-		<Unit filename="Interprocess.h" />
-		<Unit filename="JsonDetail.cpp" />
-		<Unit filename="JsonDetail.h" />
-		<Unit filename="JsonNode.cpp" />
-		<Unit filename="JsonNode.h" />
-		<Unit filename="LogicalExpression.cpp" />
-		<Unit filename="LogicalExpression.h" />
-		<Unit filename="NetPacks.h" />
-		<Unit filename="NetPacksBase.h" />
-		<Unit filename="NetPacksLib.cpp" />
-		<Unit filename="NetPacksLobby.h" />
-		<Unit filename="PathfinderUtil.h" />
-		<Unit filename="ResourceSet.cpp" />
-		<Unit filename="ResourceSet.h" />
-		<Unit filename="ScopeGuard.h" />
-		<Unit filename="ScriptHandler.cpp" />
-		<Unit filename="ScriptHandler.h" />
-		<Unit filename="StartInfo.cpp" />
-		<Unit filename="StartInfo.h" />
-		<Unit filename="StdInc.h">
-			<Option compile="1" />
-			<Option weight="0" />
-		</Unit>
-		<Unit filename="StringConstants.h" />
-		<Unit filename="UnlockGuard.h" />
-		<Unit filename="VCMIDirs.cpp" />
-		<Unit filename="VCMIDirs.h" />
-		<Unit filename="VCMI_Lib.cpp" />
-		<Unit filename="VCMI_Lib.h" />
-		<Unit filename="battle/AccessibilityInfo.cpp" />
-		<Unit filename="battle/AccessibilityInfo.h" />
-		<Unit filename="battle/BattleAction.cpp" />
-		<Unit filename="battle/BattleAction.h" />
-		<Unit filename="battle/BattleAttackInfo.cpp" />
-		<Unit filename="battle/BattleAttackInfo.h" />
-		<Unit filename="battle/BattleHex.cpp" />
-		<Unit filename="battle/BattleHex.h" />
-		<Unit filename="battle/BattleInfo.cpp" />
-		<Unit filename="battle/BattleInfo.h" />
-		<Unit filename="battle/BattleProxy.cpp" />
-		<Unit filename="battle/BattleProxy.h" />
-		<Unit filename="battle/CBattleInfoCallback.cpp" />
-		<Unit filename="battle/CBattleInfoCallback.h" />
-		<Unit filename="battle/CBattleInfoEssentials.cpp" />
-		<Unit filename="battle/CBattleInfoEssentials.h" />
-		<Unit filename="battle/CCallbackBase.cpp" />
-		<Unit filename="battle/CCallbackBase.h" />
-		<Unit filename="battle/CObstacleInstance.cpp" />
-		<Unit filename="battle/CObstacleInstance.h" />
-		<Unit filename="battle/CPlayerBattleCallback.cpp" />
-		<Unit filename="battle/CPlayerBattleCallback.h" />
-		<Unit filename="battle/CUnitState.cpp" />
-		<Unit filename="battle/CUnitState.h" />
-		<Unit filename="battle/Destination.cpp" />
-		<Unit filename="battle/Destination.h" />
-		<Unit filename="battle/IBattleInfoCallback.h" />
-		<Unit filename="battle/IBattleState.cpp" />
-		<Unit filename="battle/IBattleState.h" />
-		<Unit filename="battle/IUnitInfo.h" />
-		<Unit filename="battle/ReachabilityInfo.cpp" />
-		<Unit filename="battle/ReachabilityInfo.h" />
-		<Unit filename="battle/SideInBattle.cpp" />
-		<Unit filename="battle/SideInBattle.h" />
-		<Unit filename="battle/SiegeInfo.cpp" />
-		<Unit filename="battle/SiegeInfo.h" />
-		<Unit filename="battle/Unit.cpp" />
-		<Unit filename="battle/Unit.h" />
-		<Unit filename="events/ApplyDamage.cpp" />
-		<Unit filename="events/ApplyDamage.h" />
-		<Unit filename="events/GameResumed.cpp" />
-		<Unit filename="events/GameResumed.h" />
-		<Unit filename="events/ObjectVisitEnded.cpp" />
-		<Unit filename="events/ObjectVisitEnded.h" />
-		<Unit filename="events/ObjectVisitStarted.cpp" />
-		<Unit filename="events/ObjectVisitStarted.h" />
-		<Unit filename="events/PlayerGotTurn.cpp" />
-		<Unit filename="events/PlayerGotTurn.h" />
-		<Unit filename="events/TurnStarted.cpp" />
-		<Unit filename="events/TurnStarted.h" />
-		<Unit filename="filesystem/AdapterLoaders.cpp" />
-		<Unit filename="filesystem/AdapterLoaders.h" />
-		<Unit filename="filesystem/CArchiveLoader.cpp" />
-		<Unit filename="filesystem/CArchiveLoader.h" />
-		<Unit filename="filesystem/CBinaryReader.cpp" />
-		<Unit filename="filesystem/CBinaryReader.h" />
-		<Unit filename="filesystem/CCompressedStream.cpp" />
-		<Unit filename="filesystem/CCompressedStream.h" />
-		<Unit filename="filesystem/CFileInputStream.cpp" />
-		<Unit filename="filesystem/CFileInputStream.h" />
-		<Unit filename="filesystem/CFilesystemLoader.cpp" />
-		<Unit filename="filesystem/CFilesystemLoader.h" />
-		<Unit filename="filesystem/CInputOutputStream.h" />
-		<Unit filename="filesystem/CInputStream.h" />
-		<Unit filename="filesystem/CMemoryBuffer.cpp" />
-		<Unit filename="filesystem/CMemoryBuffer.h" />
-		<Unit filename="filesystem/CMemoryStream.cpp" />
-		<Unit filename="filesystem/CMemoryStream.h" />
-		<Unit filename="filesystem/COutputStream.h" />
-		<Unit filename="filesystem/CStream.h" />
-		<Unit filename="filesystem/CZipLoader.cpp" />
-		<Unit filename="filesystem/CZipLoader.h" />
-		<Unit filename="filesystem/CZipSaver.cpp" />
-		<Unit filename="filesystem/CZipSaver.h" />
-		<Unit filename="filesystem/FileInfo.cpp" />
-		<Unit filename="filesystem/FileInfo.h" />
-		<Unit filename="filesystem/FileStream.cpp" />
-		<Unit filename="filesystem/FileStream.h" />
-		<Unit filename="filesystem/Filesystem.cpp" />
-		<Unit filename="filesystem/Filesystem.h" />
-		<Unit filename="filesystem/ISimpleResourceLoader.h" />
-		<Unit filename="filesystem/MinizipExtensions.cpp" />
-		<Unit filename="filesystem/MinizipExtensions.h" />
-		<Unit filename="filesystem/ResourceID.cpp" />
-		<Unit filename="filesystem/ResourceID.h" />
-		<Unit filename="int3.h" />
-		<Unit filename="logging/CBasicLogConfigurator.cpp" />
-		<Unit filename="logging/CBasicLogConfigurator.h" />
-		<Unit filename="logging/CLogger.cpp" />
-		<Unit filename="logging/CLogger.h" />
-		<Unit filename="mapObjects/CArmedInstance.cpp" />
-		<Unit filename="mapObjects/CArmedInstance.h" />
-		<Unit filename="mapObjects/CBank.cpp" />
-		<Unit filename="mapObjects/CBank.h" />
-		<Unit filename="mapObjects/CGHeroInstance.cpp" />
-		<Unit filename="mapObjects/CGHeroInstance.h" />
-		<Unit filename="mapObjects/CGMarket.cpp" />
-		<Unit filename="mapObjects/CGMarket.h" />
-		<Unit filename="mapObjects/CGPandoraBox.cpp" />
-		<Unit filename="mapObjects/CGPandoraBox.h" />
-		<Unit filename="mapObjects/CGTownInstance.cpp" />
-		<Unit filename="mapObjects/CGTownInstance.h" />
-		<Unit filename="mapObjects/CObjectClassesHandler.cpp" />
-		<Unit filename="mapObjects/CObjectClassesHandler.h" />
-		<Unit filename="mapObjects/CObjectHandler.cpp" />
-		<Unit filename="mapObjects/CObjectHandler.h" />
-		<Unit filename="mapObjects/CQuest.cpp" />
-		<Unit filename="mapObjects/CQuest.h" />
-		<Unit filename="mapObjects/CRewardableConstructor.cpp" />
-		<Unit filename="mapObjects/CRewardableConstructor.h" />
-		<Unit filename="mapObjects/CRewardableObject.cpp" />
-		<Unit filename="mapObjects/CRewardableObject.h" />
-		<Unit filename="mapObjects/CommonConstructors.cpp" />
-		<Unit filename="mapObjects/CommonConstructors.h" />
-		<Unit filename="mapObjects/JsonRandom.cpp" />
-		<Unit filename="mapObjects/JsonRandom.h" />
-		<Unit filename="mapObjects/MapObjects.h" />
-		<Unit filename="mapObjects/MiscObjects.cpp" />
-		<Unit filename="mapObjects/MiscObjects.h" />
-		<Unit filename="mapObjects/ObjectTemplate.cpp" />
-		<Unit filename="mapObjects/ObjectTemplate.h" />
-		<Unit filename="mapping/CCampaignHandler.cpp" />
-		<Unit filename="mapping/CCampaignHandler.h" />
-		<Unit filename="mapping/CDrawRoadsOperation.cpp" />
-		<Unit filename="mapping/CDrawRoadsOperation.h" />
-		<Unit filename="mapping/CMap.cpp" />
-		<Unit filename="mapping/CMap.h" />
-		<Unit filename="mapping/CMapDefines.h" />
-		<Unit filename="mapping/CMapEditManager.cpp" />
-		<Unit filename="mapping/CMapEditManager.h" />
-		<Unit filename="mapping/CMapInfo.cpp" />
-		<Unit filename="mapping/CMapInfo.h" />
-		<Unit filename="mapping/CMapService.cpp" />
-		<Unit filename="mapping/CMapService.h" />
-		<Unit filename="mapping/MapFormatH3M.cpp" />
-		<Unit filename="mapping/MapFormatH3M.h" />
-		<Unit filename="mapping/MapFormatJson.cpp" />
-		<Unit filename="mapping/MapFormatJson.h" />
-		<Unit filename="registerTypes/RegisterTypes.cpp" />
-		<Unit filename="registerTypes/RegisterTypes.h" />
-		<Unit filename="registerTypes/TypesClientPacks1.cpp" />
-		<Unit filename="registerTypes/TypesClientPacks2.cpp" />
-		<Unit filename="registerTypes/TypesLobbyPacks.cpp" />
-		<Unit filename="registerTypes/TypesMapObjects1.cpp" />
-		<Unit filename="registerTypes/TypesMapObjects2.cpp" />
-		<Unit filename="registerTypes/TypesMapObjects3.cpp" />
-		<Unit filename="registerTypes/TypesServerPacks.cpp" />
-		<Unit filename="rmg/CMapGenOptions.cpp" />
-		<Unit filename="rmg/CMapGenOptions.h" />
-		<Unit filename="rmg/CMapGenerator.cpp" />
-		<Unit filename="rmg/CMapGenerator.h" />
-		<Unit filename="rmg/CRmgTemplate.cpp" />
-		<Unit filename="rmg/CRmgTemplate.h" />
-		<Unit filename="rmg/CRmgTemplateStorage.cpp" />
-		<Unit filename="rmg/CRmgTemplateStorage.h" />
-		<Unit filename="rmg/CRmgTemplateZone.cpp" />
-		<Unit filename="rmg/CRmgTemplateZone.h" />
-		<Unit filename="rmg/CZoneGraphGenerator.cpp" />
-		<Unit filename="rmg/CZoneGraphGenerator.h" />
-		<Unit filename="rmg/CZonePlacer.cpp" />
-		<Unit filename="rmg/CZonePlacer.h" />
-		<Unit filename="serializer/BinaryDeserializer.cpp" />
-		<Unit filename="serializer/BinaryDeserializer.h" />
-		<Unit filename="serializer/BinarySerializer.cpp" />
-		<Unit filename="serializer/BinarySerializer.h" />
-		<Unit filename="serializer/CLoadIntegrityValidator.cpp" />
-		<Unit filename="serializer/CLoadIntegrityValidator.h" />
-		<Unit filename="serializer/CMemorySerializer.cpp" />
-		<Unit filename="serializer/CMemorySerializer.h" />
-		<Unit filename="serializer/CSerializer.cpp" />
-		<Unit filename="serializer/CSerializer.h" />
-		<Unit filename="serializer/CTypeList.cpp" />
-		<Unit filename="serializer/CTypeList.h" />
-		<Unit filename="serializer/Cast.h" />
-		<Unit filename="serializer/Connection.cpp" />
-		<Unit filename="serializer/Connection.h" />
-		<Unit filename="serializer/JsonDeserializer.cpp" />
-		<Unit filename="serializer/JsonDeserializer.h" />
-		<Unit filename="serializer/JsonSerializeFormat.cpp" />
-		<Unit filename="serializer/JsonSerializeFormat.h" />
-		<Unit filename="serializer/JsonSerializer.cpp" />
-		<Unit filename="serializer/JsonSerializer.h" />
-		<Unit filename="serializer/JsonTreeSerializer.h" />
-		<Unit filename="serializer/JsonUpdater.cpp" />
-		<Unit filename="serializer/JsonUpdater.h" />
-		<Unit filename="spells/AbilityCaster.cpp" />
-		<Unit filename="spells/AbilityCaster.h" />
-		<Unit filename="spells/AdventureSpellMechanics.cpp" />
-		<Unit filename="spells/AdventureSpellMechanics.h" />
-		<Unit filename="spells/BattleSpellMechanics.cpp" />
-		<Unit filename="spells/BattleSpellMechanics.h" />
-		<Unit filename="spells/BonusCaster.cpp" />
-		<Unit filename="spells/BonusCaster.h" />
-		<Unit filename="spells/CSpellHandler.cpp" />
-		<Unit filename="spells/CSpellHandler.h" />
-		<Unit filename="spells/ISpellMechanics.cpp" />
-		<Unit filename="spells/ISpellMechanics.h" />
-		<Unit filename="spells/Problem.cpp" />
-		<Unit filename="spells/Problem.h" />
-		<Unit filename="spells/ProxyCaster.cpp" />
-		<Unit filename="spells/ProxyCaster.h" />
-		<Unit filename="spells/TargetCondition.cpp" />
-		<Unit filename="spells/TargetCondition.h" />
-		<Unit filename="spells/ViewSpellInt.cpp" />
-		<Unit filename="spells/ViewSpellInt.h" />
-		<Unit filename="spells/effects/Catapult.cpp" />
-		<Unit filename="spells/effects/Catapult.h" />
-		<Unit filename="spells/effects/Clone.cpp" />
-		<Unit filename="spells/effects/Clone.h" />
-		<Unit filename="spells/effects/Damage.cpp" />
-		<Unit filename="spells/effects/Damage.h" />
-		<Unit filename="spells/effects/Dispel.cpp" />
-		<Unit filename="spells/effects/Dispel.h" />
-		<Unit filename="spells/effects/Effect.cpp" />
-		<Unit filename="spells/effects/Effect.h" />
-		<Unit filename="spells/effects/Effects.cpp" />
-		<Unit filename="spells/effects/Effects.h" />
-		<Unit filename="spells/effects/EffectsFwd.h" />
-		<Unit filename="spells/effects/Heal.cpp" />
-		<Unit filename="spells/effects/Heal.h" />
-		<Unit filename="spells/effects/LocationEffect.cpp" />
-		<Unit filename="spells/effects/LocationEffect.h" />
-		<Unit filename="spells/effects/Obstacle.cpp" />
-		<Unit filename="spells/effects/Obstacle.h" />
-		<Unit filename="spells/effects/Registry.cpp" />
-		<Unit filename="spells/effects/Registry.h" />
-		<Unit filename="spells/effects/RemoveObstacle.cpp" />
-		<Unit filename="spells/effects/RemoveObstacle.h" />
-		<Unit filename="spells/effects/Sacrifice.cpp" />
-		<Unit filename="spells/effects/Sacrifice.h" />
-		<Unit filename="spells/effects/Summon.cpp" />
-		<Unit filename="spells/effects/Summon.h" />
-		<Unit filename="spells/effects/Teleport.cpp" />
-		<Unit filename="spells/effects/Teleport.h" />
-		<Unit filename="spells/effects/Timed.cpp" />
-		<Unit filename="spells/effects/Timed.h" />
-		<Unit filename="spells/effects/UnitEffect.cpp" />
-		<Unit filename="spells/effects/UnitEffect.h" />
-		<Unit filename="vcmi_endian.h" />
-		<Unit filename="vstd/StringUtils.cpp" />
-		<Extensions>
-			<lib_finder disable_auto="1" />
-		</Extensions>
-	</Project>
-</CodeBlocks_project_file>
diff --color -urN vcmi-1.5.7/lib/VCMI_Lib.cpp vcmi/lib/VCMI_Lib.cpp
--- vcmi-1.5.7/lib/VCMI_Lib.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/VCMI_Lib.cpp	2024-12-19 15:00:22.878147111 +0100
@@ -14,19 +14,18 @@
 #include "CArtHandler.h"
 #include "CBonusTypeHandler.h"
 #include "CCreatureHandler.h"
-#include "CHeroHandler.h"
-#include "CTownHandler.h"
 #include "CConfigHandler.h"
 #include "RoadHandler.h"
 #include "RiverHandler.h"
 #include "TerrainHandler.h"
-#include "CBuildingHandler.h"
 #include "spells/CSpellHandler.h"
 #include "spells/effects/Registry.h"
 #include "CSkillHandler.h"
-#include "CGeneralTextHandler.h"
+#include "entities/faction/CTownHandler.h"
+#include "entities/hero/CHeroClassHandler.h"
+#include "entities/hero/CHeroHandler.h"
+#include "texts/CGeneralTextHandler.h"
 #include "modding/CModHandler.h"
-#include "modding/CModInfo.h"
 #include "modding/IdentifierStorage.h"
 #include "modding/CModVersion.h"
 #include "IGameEventsReceiver.h"
@@ -136,42 +135,11 @@
 	return obstacleHandler.get();
 }
 
-const IGameSettings * LibClasses::settings() const
+const IGameSettings * LibClasses::engineSettings() const
 {
 	return settingsHandler.get();
 }
 
-void LibClasses::updateEntity(Metatype metatype, int32_t index, const JsonNode & data)
-{
-	switch(metatype)
-	{
-	case Metatype::ARTIFACT:
-		arth->updateEntity(index, data);
-		break;
-	case Metatype::CREATURE:
-		creh->updateEntity(index, data);
-		break;
-	case Metatype::FACTION:
-		townh->updateEntity(index, data);
-		break;
-	case Metatype::HERO_CLASS:
-		heroclassesh->updateEntity(index, data);
-		break;
-	case Metatype::HERO_TYPE:
-		heroh->updateEntity(index, data);
-		break;
-	case Metatype::SKILL:
-		skillh->updateEntity(index, data);
-		break;
-	case Metatype::SPELL:
-		spellh->updateEntity(index, data);
-		break;
-	default:
-		logGlobal->error("Invalid Metatype id %d", static_cast<int32_t>(metatype));
-		break;
-	}
-}
-
 void LibClasses::loadFilesystem(bool extractArchives)
 {
 	CStopWatch loadTime;
@@ -188,55 +156,44 @@
 	CStopWatch loadTime;
 	modh = std::make_unique<CModHandler>();
 	identifiersHandler = std::make_unique<CIdentifierStorage>();
-	modh->loadMods();
 	logGlobal->info("\tMod handler: %d ms", loadTime.getDiff());
 
 	modh->loadModFilesystems();
 	logGlobal->info("\tMod filesystems: %d ms", loadTime.getDiff());
 }
 
-static void logHandlerLoaded(const std::string & name, CStopWatch & timer)
-{
-	logGlobal->info("\t\t %s handler: %d ms", name, timer.getDiff());
-}
-
-template <class Handler> void createHandler(std::shared_ptr<Handler> & handler, const std::string &name, CStopWatch &timer)
+template <class Handler> void createHandler(std::shared_ptr<Handler> & handler)
 {
 	handler = std::make_shared<Handler>();
-	logHandlerLoaded(name, timer);
 }
 
 void LibClasses::init(bool onlyEssential)
 {
-	CStopWatch pomtime;
-	CStopWatch totalTime;
-
-	createHandler(settingsHandler, "Game Settings", pomtime);
+	createHandler(settingsHandler);
 	modh->initializeConfig();
 
-	createHandler(generaltexth, "General text", pomtime);
-	createHandler(bth, "Bonus type", pomtime);
-	createHandler(roadTypeHandler, "Road", pomtime);
-	createHandler(riverTypeHandler, "River", pomtime);
-	createHandler(terrainTypeHandler, "Terrain", pomtime);
-	createHandler(heroh, "Hero", pomtime);
-	createHandler(heroclassesh, "Hero classes", pomtime);
-	createHandler(arth, "Artifact", pomtime);
-	createHandler(creh, "Creature", pomtime);
-	createHandler(townh, "Town", pomtime);
-	createHandler(biomeHandler, "Obstacle set", pomtime);
-	createHandler(objh, "Object", pomtime);
-	createHandler(objtypeh, "Object types information", pomtime);
-	createHandler(spellh, "Spell", pomtime);
-	createHandler(skillh, "Skill", pomtime);
-	createHandler(terviewh, "Terrain view pattern", pomtime);
-	createHandler(tplh, "Template", pomtime); //templates need already resolved identifiers (refactor?)
+	createHandler(generaltexth);
+	createHandler(bth);
+	createHandler(roadTypeHandler);
+	createHandler(riverTypeHandler);
+	createHandler(terrainTypeHandler);
+	createHandler(heroh);
+	createHandler(heroclassesh);
+	createHandler(arth);
+	createHandler(creh);
+	createHandler(townh);
+	createHandler(biomeHandler);
+	createHandler(objh);
+	createHandler(objtypeh);
+	createHandler(spellh);
+	createHandler(skillh);
+	createHandler(terviewh);
+	createHandler(tplh); //templates need already resolved identifiers (refactor?)
 #if SCRIPTING_ENABLED
-	createHandler(scriptHandler, "Script", pomtime);
+	createHandler(scriptHandler);
 #endif
-	createHandler(battlefieldsHandler, "Battlefields", pomtime);
-	createHandler(obstacleHandler, "Obstacles", pomtime);
-	logGlobal->info("\tInitializing handlers: %d ms", totalTime.getDiff());
+	createHandler(battlefieldsHandler);
+	createHandler(obstacleHandler);
 
 	modh->load();
 	modh->afterLoad(onlyEssential);
diff --color -urN vcmi-1.5.7/lib/VCMI_Lib.h vcmi/lib/VCMI_Lib.h
--- vcmi-1.5.7/lib/VCMI_Lib.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/VCMI_Lib.h	2024-12-19 15:00:22.878147111 +0100
@@ -20,7 +20,6 @@
 class CCreatureHandler;
 class CSpellHandler;
 class CSkillHandler;
-class CBuildingHandler;
 class CObjectHandler;
 class CObjectClassesHandler;
 class ObstacleSetHandler;
@@ -70,9 +69,7 @@
 	const SkillService * skills() const override;
 	const BattleFieldService * battlefields() const override;
 	const ObstacleService * obstacles() const override;
-	const IGameSettings * settings() const override;
-
-	void updateEntity(Metatype metatype, int32_t index, const JsonNode & data) override;
+	const IGameSettings * engineSettings() const override;
 
 	const spells::effects::Registry * spellEffects() const override;
 	spells::effects::Registry * spellEffects() override;
diff --color -urN vcmi-1.5.7/lib/VCMI_lib.vcxproj vcmi/lib/VCMI_lib.vcxproj
--- vcmi-1.5.7/lib/VCMI_lib.vcxproj	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/VCMI_lib.vcxproj	1970-01-01 01:00:00.000000000 +0100
@@ -1,504 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <ItemGroup Label="ProjectConfigurations">
-    <ProjectConfiguration Include="Debug|Win32">
-      <Configuration>Debug</Configuration>
-      <Platform>Win32</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Debug|x64">
-      <Configuration>Debug</Configuration>
-      <Platform>x64</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="RD|Win32">
-      <Configuration>RD</Configuration>
-      <Platform>Win32</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="RD|x64">
-      <Configuration>RD</Configuration>
-      <Platform>x64</Platform>
-    </ProjectConfiguration>
-  </ItemGroup>
-  <PropertyGroup Label="Globals">
-    <ProjectGuid>{B952FFC5-3039-4DE1-9F08-90ACDA483D8F}</ProjectGuid>
-    <RootNamespace>VCMI_lib</RootNamespace>
-    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
-  </PropertyGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='RD|Win32'" Label="Configuration">
-    <ConfigurationType>DynamicLibrary</ConfigurationType>
-    <CharacterSet>Unicode</CharacterSet>
-    <WholeProgramOptimization>true</WholeProgramOptimization>
-    <PlatformToolset>v142</PlatformToolset>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='RD|x64'" Label="Configuration">
-    <ConfigurationType>DynamicLibrary</ConfigurationType>
-    <CharacterSet>Unicode</CharacterSet>
-    <WholeProgramOptimization>true</WholeProgramOptimization>
-    <PlatformToolset>v140_xp</PlatformToolset>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
-    <ConfigurationType>DynamicLibrary</ConfigurationType>
-    <CharacterSet>Unicode</CharacterSet>
-    <PlatformToolset>v140_xp</PlatformToolset>
-    <WholeProgramOptimization>true</WholeProgramOptimization>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
-    <ConfigurationType>DynamicLibrary</ConfigurationType>
-    <CharacterSet>MultiByte</CharacterSet>
-    <PlatformToolset>v140_xp</PlatformToolset>
-  </PropertyGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
-  <ImportGroup Label="ExtensionSettings">
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='RD|Win32'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-    <Import Project="..\VCMI_global_release.props" />
-    <Import Project="..\VCMI_global.props" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='RD|x64'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-    <Import Project="..\VCMI_global_release.props" />
-    <Import Project="..\VCMI_global.props" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-    <Import Project="..\VCMI_global_debug.props" />
-    <Import Project="..\VCMI_global.props" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-    <Import Project="..\VCMI_global_debug.props" />
-    <Import Project="..\VCMI_global.props" />
-  </ImportGroup>
-  <PropertyGroup Label="UserMacros" />
-  <PropertyGroup>
-    <_ProjectFileVersion>10.0.30128.1</_ProjectFileVersion>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..</OutDir>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(VCMI_Out)</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(Configuration)\</IntDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(Configuration)\</IntDir>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='RD|Win32'">$(VCMI_Out)</OutDir>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='RD|x64'">$(VCMI_Out)</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='RD|Win32'">$(Configuration)\</IntDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='RD|x64'">$(Configuration)\</IntDir>
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='RD|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='RD|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='RD|Win32'" />
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='RD|x64'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='RD|Win32'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='RD|x64'" />
-  </PropertyGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
-    <ClCompile>
-      <AdditionalOptions>/MP4 %(AdditionalOptions) /bigobj
- /Zm150</AdditionalOptions>
-      <Optimization>Disabled</Optimization>
-      <AdditionalIncludeDirectories>$(BOOSTDIR);$(ZLIBDIR);$(SDLDIR)</AdditionalIncludeDirectories>
-      <MinimalRebuild>false</MinimalRebuild>
-      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
-      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
-      <WarningLevel>Level3</WarningLevel>
-      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>
-      <DisableSpecificWarnings>4251;%(DisableSpecificWarnings)</DisableSpecificWarnings>
-      <ExpandAttributedSource>false</ExpandAttributedSource>
-      <AssemblerOutput>NoListing</AssemblerOutput>
-      <PreprocessToFile>false</PreprocessToFile>
-      <PrecompiledHeader>Use</PrecompiledHeader>
-      <PrecompiledHeaderFile>StdInc.h</PrecompiledHeaderFile>
-      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName).pch</PrecompiledHeaderOutputFile>
-      <PreprocessorDefinitions>VCMI_DLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <WholeProgramOptimization>false</WholeProgramOptimization>
-    </ClCompile>
-    <Link>
-      <AdditionalDependencies>minizip.lib;zlib.lib;%(AdditionalDependencies)</AdditionalDependencies>
-      <AdditionalLibraryDirectories>..\..\libs</AdditionalLibraryDirectories>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
-    <ClCompile>
-      <AdditionalOptions>/MP4 %(AdditionalOptions) /bigobj
- /Zm150</AdditionalOptions>
-      <DisableSpecificWarnings>4251;%(DisableSpecificWarnings)</DisableSpecificWarnings>
-      <ExpandAttributedSource>false</ExpandAttributedSource>
-      <AssemblerOutput>NoListing</AssemblerOutput>
-      <PreprocessToFile>false</PreprocessToFile>
-      <PreprocessorDefinitions>VCMI_DLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-    </ClCompile>
-    <Link>
-      <AdditionalDependencies>minizip.lib;zlib.lib;%(AdditionalDependencies)</AdditionalDependencies>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='RD|Win32'">
-    <ClCompile>
-      <AdditionalOptions>/Oy- /bigobj</AdditionalOptions>
-      <PreprocessorDefinitions>VCMI_DLL;VCMI_NO_EXTRA_VERSION;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <PrecompiledHeaderFile>StdInc.h</PrecompiledHeaderFile>
-      <PrecompiledHeader>Use</PrecompiledHeader>
-      <AdditionalIncludeDirectories>$(BOOSTDIR);$(ZLIBDIR);$(SDLDIR)</AdditionalIncludeDirectories>
-      <MultiProcessorCompilation>true</MultiProcessorCompilation>
-    </ClCompile>
-    <Link>
-      <AdditionalDependencies>minizip.lib;zlib.lib;%(AdditionalDependencies)</AdditionalDependencies>
-      <Version>
-      </Version>
-      <LinkTimeCodeGeneration>
-      </LinkTimeCodeGeneration>
-      <AdditionalLibraryDirectories>..\..\libs</AdditionalLibraryDirectories>
-      <AdditionalOptions>/LTCG %(AdditionalOptions)</AdditionalOptions>
-      <ForceFileOutput>MultiplyDefinedSymbolOnly</ForceFileOutput>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='RD|x64'">
-    <ClCompile>
-      <AdditionalOptions>/Oy- %(AdditionalOptions) /bigobj
- /Zm150</AdditionalOptions>
-      <PreprocessorDefinitions>VCMI_DLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <PrecompiledHeader>Use</PrecompiledHeader>
-      <PrecompiledHeaderFile>StdInc.h</PrecompiledHeaderFile>
-    </ClCompile>
-    <Link>
-      <AdditionalDependencies>minizip.lib;zlib.lib;%(AdditionalDependencies)</AdditionalDependencies>
-      <Version>
-      </Version>
-      <LinkTimeCodeGeneration>
-      </LinkTimeCodeGeneration>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemGroup>
-    <ClCompile Include="battle\BattleAction.cpp" />
-    <ClCompile Include="battle\BattleHex.cpp" />
-    <ClCompile Include="battle\BattleInfo.cpp" />
-    <ClCompile Include="battle\AccessibilityInfo.cpp" />
-    <ClCompile Include="battle\BattleAttackInfo.cpp" />
-    <ClCompile Include="battle\BattleProxy.cpp" />
-    <ClCompile Include="battle\CBattleInfoCallback.cpp" />
-    <ClCompile Include="battle\CBattleInfoEssentials.cpp" />
-    <ClCompile Include="battle\CCallbackBase.cpp" />
-    <ClCompile Include="battle\CPlayerBattleCallback.cpp" />
-    <ClCompile Include="battle\CUnitState.cpp" />
-    <ClCompile Include="battle\Destination.cpp" />
-    <ClCompile Include="battle\IBattleState.cpp" />
-    <ClCompile Include="battle\ReachabilityInfo.cpp" />
-    <ClCompile Include="battle\Unit.cpp" />
-    <ClCompile Include="CArtHandler.cpp" />
-    <ClCompile Include="CBonusTypeHandler.cpp" />
-    <ClCompile Include="CBuildingHandler.cpp" />
-    <ClCompile Include="CConfigHandler.cpp" />
-    <ClCompile Include="CConsoleHandler.cpp" />
-    <ClCompile Include="CCreatureHandler.cpp" />
-    <ClCompile Include="CCreatureSet.cpp" />
-    <ClCompile Include="CGameInterface.cpp" />
-    <ClCompile Include="CGameState.cpp" />
-    <ClCompile Include="CGeneralTextHandler.cpp" />
-    <ClCompile Include="CHeroHandler.cpp" />
-    <ClCompile Include="CModHandler.cpp" />
-    <ClCompile Include="battle\CObstacleInstance.cpp" />
-    <ClCompile Include="CPathfinder.cpp" />
-    <ClCompile Include="CSkillHandler.cpp" />
-    <ClCompile Include="CStack.cpp" />
-    <ClCompile Include="CThreadHelper.cpp" />
-    <ClCompile Include="CTownHandler.cpp" />
-    <ClCompile Include="CRandomGenerator.cpp" />
-    <ClCompile Include="filesystem\CMemoryBuffer.cpp" />
-    <ClCompile Include="filesystem\CZipSaver.cpp" />
-    <ClCompile Include="filesystem\FileInfo.cpp" />
-    <ClCompile Include="filesystem\FileStream.cpp" />
-    <ClCompile Include="filesystem\MinizipExtensions.cpp" />
-    <ClCompile Include="registerTypes\TypesLobbyPacks.cpp" />
-    <ClCompile Include="serializer\BinaryDeserializer.cpp" />
-    <ClCompile Include="serializer\BinarySerializer.cpp" />
-    <ClCompile Include="serializer\CLoadIntegrityValidator.cpp" />
-    <ClCompile Include="serializer\CMemorySerializer.cpp" />
-    <ClCompile Include="serializer\CSerializer.cpp" />
-    <ClCompile Include="serializer\CTypeList.cpp" />
-    <ClCompile Include="serializer\Connection.cpp" />
-    <ClCompile Include="serializer\JsonDeserializer.cpp" />
-    <ClCompile Include="serializer\JsonSerializeFormat.cpp" />
-    <ClCompile Include="serializer\JsonSerializer.cpp" />
-    <ClCompile Include="battle\SideInBattle.cpp" />
-    <ClCompile Include="battle\SiegeInfo.cpp" />
-    <ClCompile Include="spells\AbilityCaster.cpp" />
-    <ClCompile Include="spells\BonusCaster.cpp" />
-    <ClCompile Include="spells\CSpellHandler.cpp" />
-    <ClCompile Include="spells\effects\Catapult.cpp" />
-    <ClCompile Include="spells\effects\Dispel.cpp" />
-    <ClCompile Include="spells\effects\Heal.cpp" />
-    <ClCompile Include="spells\effects\Obstacle.cpp" />
-    <ClCompile Include="spells\effects\RemoveObstacle.cpp" />
-    <ClCompile Include="spells\effects\Sacrifice.cpp" />
-    <ClCompile Include="spells\effects\Teleport.cpp" />
-    <ClCompile Include="spells\effects\UnitEffect.cpp" />
-    <ClCompile Include="spells\ISpellMechanics.cpp" />
-    <ClCompile Include="spells\AdventureSpellMechanics.cpp" />
-    <ClCompile Include="spells\BattleSpellMechanics.cpp" />
-    <ClCompile Include="spells\Problem.cpp" />
-    <ClCompile Include="spells\ProxyCaster.cpp" />
-    <ClCompile Include="spells\TargetCondition.cpp" />
-    <ClCompile Include="spells\ViewSpellInt.cpp" />
-    <ClCompile Include="spells\effects\Effect.cpp" />
-    <ClCompile Include="spells\effects\Effects.cpp" />
-    <ClCompile Include="spells\effects\Clone.cpp" />
-    <ClCompile Include="spells\effects\Damage.cpp" />
-    <ClCompile Include="spells\effects\LocationEffect.cpp" />
-    <ClCompile Include="spells\effects\Registry.cpp" />
-    <ClCompile Include="spells\effects\Summon.cpp" />
-    <ClCompile Include="spells\effects\Timed.cpp" />
-    <ClCompile Include="filesystem\AdapterLoaders.cpp" />
-    <ClCompile Include="filesystem\CArchiveLoader.cpp" />
-    <ClCompile Include="filesystem\CBinaryReader.cpp" />
-    <ClCompile Include="filesystem\CCompressedStream.cpp" />
-    <ClCompile Include="filesystem\CFileInputStream.cpp" />
-    <ClCompile Include="filesystem\CFilesystemLoader.cpp" />
-    <ClCompile Include="filesystem\CMemoryStream.cpp" />
-    <ClCompile Include="filesystem\CZipLoader.cpp" />
-    <ClCompile Include="filesystem\Filesystem.cpp" />
-    <ClCompile Include="filesystem\ResourceID.cpp" />
-    <ClCompile Include="GameConstants.cpp" />
-    <ClCompile Include="IHandlerBase.cpp" />
-    <ClCompile Include="JsonDetail.cpp" />
-    <ClCompile Include="LogicalExpression.cpp" />
-    <ClCompile Include="mapObjects\CArmedInstance.cpp" />
-    <ClCompile Include="mapObjects\CBank.cpp" />
-    <ClCompile Include="mapObjects\CGHeroInstance.cpp" />
-    <ClCompile Include="mapObjects\CGMarket.cpp" />
-    <ClCompile Include="mapObjects\CGPandoraBox.cpp" />
-    <ClCompile Include="mapObjects\CGTownInstance.cpp" />
-    <ClCompile Include="mapObjects\CObjectClassesHandler.cpp" />
-    <ClCompile Include="mapObjects\CObjectHandler.cpp" />
-    <ClCompile Include="mapObjects\CommonConstructors.cpp" />
-    <ClCompile Include="mapObjects\CQuest.cpp" />
-    <ClCompile Include="mapObjects\CRewardableConstructor.cpp" />
-    <ClCompile Include="mapObjects\CRewardableObject.cpp" />
-    <ClCompile Include="mapObjects\JsonRandom.cpp" />
-    <ClCompile Include="mapObjects\MiscObjects.cpp" />
-    <ClCompile Include="mapObjects\ObjectTemplate.cpp" />
-    <ClCompile Include="mapping\CCampaignHandler.cpp" />
-    <ClCompile Include="mapping\CMap.cpp" />
-    <ClCompile Include="mapping\CMapInfo.cpp" />
-    <ClCompile Include="mapping\CMapService.cpp" />
-    <ClCompile Include="mapping\CMapEditManager.cpp" />
-    <ClCompile Include="mapping\MapFormatH3M.cpp" />
-    <ClCompile Include="mapping\MapFormatJson.cpp" />
-    <ClCompile Include="mapping\CDrawRoadsOperation.cpp" />
-    <ClCompile Include="registerTypes\RegisterTypes.cpp" />
-    <ClCompile Include="registerTypes\TypesClientPacks1.cpp" />
-    <ClCompile Include="registerTypes\TypesClientPacks2.cpp" />
-    <ClCompile Include="registerTypes\TypesMapObjects1.cpp" />
-    <ClCompile Include="registerTypes\TypesMapObjects2.cpp" />
-    <ClCompile Include="registerTypes\TypesMapObjects3.cpp" />
-    <ClCompile Include="registerTypes\TypesServerPacks.cpp" />
-    <ClCompile Include="rmg\CMapGenerator.cpp" />
-    <ClCompile Include="logging\CLogger.cpp" />
-    <ClCompile Include="logging\CBasicLogConfigurator.cpp" />
-    <ClCompile Include="HeroBonus.cpp" />
-    <ClCompile Include="IGameCallback.cpp" />
-    <ClCompile Include="CGameInfoCallback.cpp" />
-    <ClCompile Include="JsonNode.cpp" />
-    <ClCompile Include="NetPacksLib.cpp" />
-    <ClCompile Include="ResourceSet.cpp" />
-    <ClCompile Include="rmg\CMapGenOptions.cpp" />
-    <ClCompile Include="rmg\CRmgTemplate.cpp" />
-    <ClCompile Include="rmg\CRmgTemplateStorage.cpp" />
-    <ClCompile Include="rmg\CRmgTemplateZone.cpp" />
-    <ClCompile Include="rmg\CZoneGraphGenerator.cpp" />
-    <ClCompile Include="rmg\CZonePlacer.cpp" />
-    <ClCompile Include="StartInfo.cpp" />
-    <ClCompile Include="StdInc.cpp">
-      <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">VCMI_DLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
-      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StdInc.h</PrecompiledHeaderFile>
-      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='RD|Win32'">Create</PrecompiledHeader>
-      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='RD|x64'">Create</PrecompiledHeader>
-      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
-      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">StdInc.h</PrecompiledHeaderFile>
-    </ClCompile>
-    <ClCompile Include="VCMIDirs.cpp" />
-    <ClCompile Include="VCMI_Lib.cpp" />
-    <ClCompile Include="vstd\DateUtils.cpp" />
-    <ClCompile Include="vstd\StringUtils.cpp" />
-  </ItemGroup>
-  <ItemGroup>
-    <ClInclude Include="..\Global.h" />
-    <ClInclude Include="..\AUTHORS.h" />
-    <ClInclude Include="..\Version.h" />
-    <ClInclude Include="AI_Base.h" />
-    <ClInclude Include="battle\BattleAction.h" />
-    <ClInclude Include="battle\BattleHex.h" />
-    <ClInclude Include="battle\BattleInfo.h" />
-    <ClInclude Include="battle\AccessibilityInfo.h" />
-    <ClInclude Include="battle\BattleAttackInfo.h" />
-    <ClInclude Include="battle\BattleProxy.h" />
-    <ClInclude Include="battle\CBattleInfoCallback.h" />
-    <ClInclude Include="battle\CBattleInfoEssentials.h" />
-    <ClInclude Include="battle\CCallbackBase.h" />
-    <ClInclude Include="battle\CPlayerBattleCallback.h" />
-    <ClInclude Include="battle\CUnitState.h" />
-    <ClInclude Include="battle\Destination.h" />
-    <ClInclude Include="battle\IBattleState.h" />
-    <ClInclude Include="battle\IUnitInfo.h" />
-    <ClInclude Include="battle\ReachabilityInfo.h" />
-    <ClInclude Include="battle\Unit.h" />
-    <ClInclude Include="CArtHandler.h" />
-    <ClInclude Include="CBonusTypeHandler.h" />
-    <ClInclude Include="CBuildingHandler.h" />
-    <ClInclude Include="CConfigHandler.h" />
-    <ClInclude Include="CConsoleHandler.h" />
-    <ClInclude Include="CCreatureHandler.h" />
-    <ClInclude Include="CCreatureSet.h" />
-    <ClInclude Include="CGameInterface.h" />
-    <ClInclude Include="CGameState.h" />
-    <ClInclude Include="CGameStateFwd.h" />
-    <ClInclude Include="CGeneralTextHandler.h" />
-    <ClInclude Include="CHeroHandler.h" />
-    <ClInclude Include="CModHandler.h" />
-    <ClInclude Include="battle\CObstacleInstance.h" />
-    <ClInclude Include="CondSh.h" />
-    <ClInclude Include="ConstTransitivePtr.h" />
-    <ClInclude Include="CPathfinder.h" />
-    <ClInclude Include="CPlayerState.h" />
-    <ClInclude Include="CRandomGenerator.h" />
-    <ClInclude Include="CScriptingModule.h" />
-    <ClInclude Include="CSkillHandler.h" />
-    <ClInclude Include="CSoundBase.h" />
-    <ClInclude Include="CStack.h" />
-    <ClInclude Include="CStopWatch.h" />
-    <ClInclude Include="CThreadHelper.h" />
-    <ClInclude Include="CTownHandler.h" />
-    <ClInclude Include="filesystem\AdapterLoaders.h" />
-    <ClInclude Include="filesystem\CArchiveLoader.h" />
-    <ClInclude Include="filesystem\CBinaryReader.h" />
-    <ClInclude Include="filesystem\CCompressedStream.h" />
-    <ClInclude Include="filesystem\CFileInfo.h" />
-    <ClInclude Include="filesystem\CFileInputStream.h" />
-    <ClInclude Include="filesystem\CFilesystemLoader.h" />
-    <ClInclude Include="filesystem\CInputOutputStream.h" />
-    <ClInclude Include="filesystem\CInputStream.h" />
-    <ClInclude Include="filesystem\CMemoryBuffer.h" />
-    <ClInclude Include="filesystem\CMemoryStream.h" />
-    <ClInclude Include="filesystem\COutputStream.h" />
-    <ClInclude Include="filesystem\CStream.h" />
-    <ClInclude Include="filesystem\CZipLoader.h" />
-    <ClInclude Include="filesystem\CZipSaver.h" />
-    <ClInclude Include="filesystem\FileInfo.h" />
-    <ClInclude Include="filesystem\FileStream.h" />
-    <ClInclude Include="filesystem\Filesystem.h" />
-    <ClInclude Include="filesystem\ISimpleResourceLoader.h" />
-    <ClInclude Include="filesystem\MinizipExtensions.h" />
-    <ClInclude Include="filesystem\ResourceID.h" />
-    <ClInclude Include="FunctionList.h" />
-    <ClInclude Include="IBonusTypeHandler.h" />
-    <ClInclude Include="IHandlerBase.h" />
-    <ClInclude Include="JsonDetail.h" />
-    <ClInclude Include="LogicalExpression.h" />
-    <ClInclude Include="mapObjects\CArmedInstance.h" />
-    <ClInclude Include="mapObjects\CBank.h" />
-    <ClInclude Include="mapObjects\CGHeroInstance.h" />
-    <ClInclude Include="mapObjects\CGMarket.h" />
-    <ClInclude Include="mapObjects\CGPandoraBox.h" />
-    <ClInclude Include="mapObjects\CGTownInstance.h" />
-    <ClInclude Include="mapObjects\CObjectClassesHandler.h" />
-    <ClInclude Include="mapObjects\CObjectHandler.h" />
-    <ClInclude Include="mapObjects\CommonConstructors.h" />
-    <ClInclude Include="mapObjects\CQuest.h" />
-    <ClInclude Include="mapObjects\CRewardableConstructor.h" />
-    <ClInclude Include="mapObjects\CRewardableObject.h" />
-    <ClInclude Include="mapObjects\JsonRandom.h" />
-    <ClInclude Include="mapObjects\MapObjects.h" />
-    <ClInclude Include="mapObjects\MiscObjects.h" />
-    <ClInclude Include="mapObjects\ObjectTemplate.h" />
-    <ClInclude Include="mapping\CCampaignHandler.h" />
-    <ClInclude Include="mapping\CDrawRoadsOperation.h" />
-    <ClInclude Include="mapping\CMap.h" />
-    <ClInclude Include="mapping\CMapDefines.h" />
-    <ClInclude Include="mapping\CMapInfo.h" />
-    <ClInclude Include="mapping\CMapService.h" />
-    <ClInclude Include="mapping\CMapEditManager.h" />
-    <ClInclude Include="mapping\MapFormatH3M.h" />
-    <ClInclude Include="mapping\MapFormatJson.h" />
-    <ClInclude Include="NetPacksBase.h" />
-    <ClInclude Include="NetPacksLobby.h" />
-    <ClInclude Include="registerTypes\RegisterTypes.h" />
-    <ClInclude Include="rmg\CMapGenerator.h" />
-    <ClInclude Include="logging\CLogger.h" />
-    <ClInclude Include="logging\CBasicLogConfigurator.h" />
-    <ClInclude Include="GameConstants.h" />
-    <ClInclude Include="Bonus.h" />
-    <ClInclude Include="IGameCallback.h" />
-    <ClInclude Include="CGameInfoCallback.h" />
-    <ClInclude Include="IGameEventsReceiver.h" />
-    <ClInclude Include="int3.h" />
-    <ClInclude Include="Interprocess.h" />
-    <ClInclude Include="JsonNode.h" />
-    <ClInclude Include="NetPacks.h" />
-    <ClInclude Include="ResourceSet.h" />
-    <ClInclude Include="rmg\CMapGenOptions.h" />
-    <ClInclude Include="rmg\CRmgTemplate.h" />
-    <ClInclude Include="rmg\CRmgTemplateStorage.h" />
-    <ClInclude Include="rmg\CRmgTemplateZone.h" />
-    <ClInclude Include="rmg\CZoneGraphGenerator.h" />
-    <ClInclude Include="rmg\CZonePlacer.h" />
-    <ClInclude Include="rmg\float3.h" />
-    <ClInclude Include="ScopeGuard.h" />
-    <ClInclude Include="serializer\BinaryDeserializer.h" />
-    <ClInclude Include="serializer\BinarySerializer.h" />
-    <ClInclude Include="serializer\Cast.h" />
-    <ClInclude Include="serializer\CLoadIntegrityValidator.h" />
-    <ClInclude Include="serializer\CMemorySerializer.h" />
-    <ClInclude Include="serializer\CSerializer.h" />
-    <ClInclude Include="serializer\CTypeList.h" />
-    <ClInclude Include="serializer\Connection.h" />
-    <ClInclude Include="serializer\JsonDeserializer.h" />
-    <ClInclude Include="serializer\JsonSerializeFormat.h" />
-    <ClInclude Include="serializer\JsonSerializer.h" />
-    <ClInclude Include="battle\SideInBattle.h" />
-    <ClInclude Include="battle\SiegeInfo.h" />
-    <ClInclude Include="serializer\JsonTreeSerializer.h" />
-    <ClInclude Include="spells\AbilityCaster.h" />
-    <ClInclude Include="spells\AdventureSpellMechanics.h" />
-    <ClInclude Include="spells\BattleSpellMechanics.h" />
-    <ClInclude Include="spells\BonusCaster.h" />
-    <ClInclude Include="spells\CSpellHandler.h" />
-    <ClInclude Include="spells\effects\Catapult.h" />
-    <ClInclude Include="spells\effects\Dispel.h" />
-    <ClInclude Include="spells\effects\EffectsFwd.h" />
-    <ClInclude Include="spells\effects\Heal.h" />
-    <ClInclude Include="spells\effects\Obstacle.h" />
-    <ClInclude Include="spells\effects\RemoveObstacle.h" />
-    <ClInclude Include="spells\effects\Sacrifice.h" />
-    <ClInclude Include="spells\effects\Teleport.h" />
-    <ClInclude Include="spells\effects\UnitEffect.h" />
-    <ClInclude Include="spells\ISpellMechanics.h" />
-    <ClInclude Include="spells\Magic.h" />
-    <ClInclude Include="spells\ProxyCaster.h" />
-    <ClInclude Include="spells\SpellMechanics.h" />
-    <ClInclude Include="spells\Problem.h" />
-    <ClInclude Include="spells\TargetCondition.h" />
-    <ClInclude Include="spells\ViewSpellInt.h" />
-    <ClInclude Include="spells\effects\Effect.h" />
-    <ClInclude Include="spells\effects\Effects.h" />
-    <ClInclude Include="spells\effects\Clone.h" />
-    <ClInclude Include="spells\effects\Damage.h" />
-    <ClInclude Include="spells\effects\GlobalEffect.h" />
-    <ClInclude Include="spells\effects\LocationEffect.h" />
-    <ClInclude Include="spells\effects\Registry.h" />
-    <ClInclude Include="spells\effects\StackEffect.h" />
-    <ClInclude Include="spells\effects\Summon.h" />
-    <ClInclude Include="spells\effects\Timed.h" />
-    <ClInclude Include="StartInfo.h" />
-    <ClInclude Include="StdInc.h" />
-    <ClInclude Include="StringConstants.h" />
-    <ClInclude Include="UnlockGuard.h" />
-    <ClInclude Include="vcmi_endian.h" />
-    <ClInclude Include="VCMI_Lib.h" />
-    <ClInclude Include="VCMIDirs.h" />
-  </ItemGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
-  <ImportGroup Label="ExtensionTargets">
-  </ImportGroup>
-</Project>
\ No newline at end of file
diff --color -urN vcmi-1.5.7/lib/VCMI_lib.vcxproj.filters vcmi/lib/VCMI_lib.vcxproj.filters
--- vcmi-1.5.7/lib/VCMI_lib.vcxproj.filters	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/lib/VCMI_lib.vcxproj.filters	1970-01-01 01:00:00.000000000 +0100
@@ -1,924 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <ItemGroup>
-    <Filter Include="Header Files">
-      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
-      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
-    </Filter>
-    <Filter Include="filesystem">
-      <UniqueIdentifier>{a2ca6977-50bf-4585-aa6e-779a10863922}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="logging">
-      <UniqueIdentifier>{230979a5-fbea-4d21-b2a6-cf476ebc123d}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="rmg">
-      <UniqueIdentifier>{8ba33e2e-2971-4873-9c49-128c34147a38}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="mapping">
-      <UniqueIdentifier>{401483eb-380a-4e36-b532-207491622703}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="registerTypes">
-      <UniqueIdentifier>{927d9b6e-3dc5-4370-b603-1b9887095509}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="mapObjects">
-      <UniqueIdentifier>{ee24c7f7-f4e2-4d35-b994-94a6e29ea92f}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="spells">
-      <UniqueIdentifier>{bda963b1-00e1-412a-9b44-f5cd3f8e9e33}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="serializer">
-      <UniqueIdentifier>{2f582170-d8a6-42f3-8da3-8255bac28f5a}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="battle">
-      <UniqueIdentifier>{d18aad99-ef40-484a-b317-8f7a36d975fc}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="spells\effects">
-      <UniqueIdentifier>{a3de4952-3c98-4c1a-bc4b-bd3eeaa82ba7}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="vstd">
-      <UniqueIdentifier>{91722359-2231-4596-8e73-dbdcd14bd4f3}</UniqueIdentifier>
-    </Filter>
-  </ItemGroup>
-  <ItemGroup>
-    <ClCompile Include="CArtHandler.cpp" />
-    <ClCompile Include="CBuildingHandler.cpp" />
-    <ClCompile Include="CCreatureHandler.cpp" />
-    <ClCompile Include="CGeneralTextHandler.cpp" />
-    <ClCompile Include="CHeroHandler.cpp" />
-    <ClCompile Include="CTownHandler.cpp" />
-    <ClCompile Include="CCreatureSet.cpp" />
-    <ClCompile Include="CGameState.cpp" />
-    <ClCompile Include="CRandomGenerator.cpp" />
-    <ClCompile Include="HeroBonus.cpp" />
-    <ClCompile Include="IGameCallback.cpp" />
-    <ClCompile Include="CGameInfoCallback.cpp" />
-    <ClCompile Include="NetPacksLib.cpp" />
-    <ClCompile Include="VCMI_Lib.cpp" />
-    <ClCompile Include="ResourceSet.cpp" />
-    <ClCompile Include="CGameInterface.cpp" />
-    <ClCompile Include="JsonNode.cpp" />
-    <ClCompile Include="CConsoleHandler.cpp" />
-    <ClCompile Include="CThreadHelper.cpp" />
-    <ClCompile Include="StdInc.cpp" />
-    <ClCompile Include="CModHandler.cpp" />
-    <ClCompile Include="CConfigHandler.cpp" />
-    <ClCompile Include="Mapping\CCampaignHandler.cpp" />
-    <ClCompile Include="GameConstants.cpp" />
-    <ClCompile Include="VCMIDirs.cpp" />
-    <ClCompile Include="CBonusTypeHandler.cpp" />
-    <ClCompile Include="rmg\CRmgTemplate.cpp">
-      <Filter>rmg</Filter>
-    </ClCompile>
-    <ClCompile Include="rmg\CRmgTemplateStorage.cpp">
-      <Filter>rmg</Filter>
-    </ClCompile>
-    <ClCompile Include="rmg\CRmgTemplateZone.cpp">
-      <Filter>rmg</Filter>
-    </ClCompile>
-    <ClCompile Include="rmg\CZonePlacer.cpp">
-      <Filter>rmg</Filter>
-    </ClCompile>
-    <ClCompile Include="RMG\CMapGenerator.cpp">
-      <Filter>rmg</Filter>
-    </ClCompile>
-    <ClCompile Include="rmg\CMapGenOptions.cpp">
-      <Filter>rmg</Filter>
-    </ClCompile>
-    <ClCompile Include="rmg\CZoneGraphGenerator.cpp">
-      <Filter>rmg</Filter>
-    </ClCompile>
-    <ClCompile Include="filesystem\Filesystem.cpp">
-      <Filter>filesystem</Filter>
-    </ClCompile>
-    <ClCompile Include="filesystem\CZipLoader.cpp">
-      <Filter>filesystem</Filter>
-    </ClCompile>
-    <ClCompile Include="filesystem\CMemoryStream.cpp">
-      <Filter>filesystem</Filter>
-    </ClCompile>
-    <ClCompile Include="filesystem\CFilesystemLoader.cpp">
-      <Filter>filesystem</Filter>
-    </ClCompile>
-    <ClCompile Include="filesystem\CFileInputStream.cpp">
-      <Filter>filesystem</Filter>
-    </ClCompile>
-    <ClCompile Include="filesystem\CCompressedStream.cpp">
-      <Filter>filesystem</Filter>
-    </ClCompile>
-    <ClCompile Include="filesystem\CBinaryReader.cpp">
-      <Filter>filesystem</Filter>
-    </ClCompile>
-    <ClCompile Include="filesystem\CArchiveLoader.cpp">
-      <Filter>filesystem</Filter>
-    </ClCompile>
-    <ClCompile Include="filesystem\AdapterLoaders.cpp">
-      <Filter>filesystem</Filter>
-    </ClCompile>
-    <ClCompile Include="logging\CBasicLogConfigurator.cpp">
-      <Filter>logging</Filter>
-    </ClCompile>
-    <ClCompile Include="logging\CLogger.cpp">
-      <Filter>logging</Filter>
-    </ClCompile>
-    <ClCompile Include="mapping\CMap.cpp">
-      <Filter>mapping</Filter>
-    </ClCompile>
-    <ClCompile Include="mapping\CMapEditManager.cpp">
-      <Filter>mapping</Filter>
-    </ClCompile>
-    <ClCompile Include="mapping\CMapInfo.cpp">
-      <Filter>mapping</Filter>
-    </ClCompile>
-    <ClCompile Include="mapping\CMapService.cpp">
-      <Filter>mapping</Filter>
-    </ClCompile>
-    <ClCompile Include="mapping\MapFormatH3M.cpp">
-      <Filter>mapping</Filter>
-    </ClCompile>
-    <ClCompile Include="filesystem\ResourceID.cpp">
-      <Filter>filesystem</Filter>
-    </ClCompile>
-    <ClCompile Include="JsonDetail.cpp" />
-    <ClCompile Include="mapping\MapFormatJson.cpp">
-      <Filter>mapping</Filter>
-    </ClCompile>
-    <ClCompile Include="LogicalExpression.cpp" />
-    <ClCompile Include="registerTypes\TypesClientPacks2.cpp">
-      <Filter>registerTypes</Filter>
-    </ClCompile>
-    <ClCompile Include="registerTypes\TypesServerPacks.cpp">
-      <Filter>registerTypes</Filter>
-    </ClCompile>
-    <ClCompile Include="registerTypes\RegisterTypes.cpp">
-      <Filter>registerTypes</Filter>
-    </ClCompile>
-    <ClCompile Include="registerTypes\TypesClientPacks1.cpp">
-      <Filter>registerTypes</Filter>
-    </ClCompile>
-    <ClCompile Include="mapObjects\CArmedInstance.cpp">
-      <Filter>mapObjects</Filter>
-    </ClCompile>
-    <ClCompile Include="mapObjects\CBank.cpp">
-      <Filter>mapObjects</Filter>
-    </ClCompile>
-    <ClCompile Include="mapObjects\CGHeroInstance.cpp">
-      <Filter>mapObjects</Filter>
-    </ClCompile>
-    <ClCompile Include="mapObjects\CGMarket.cpp">
-      <Filter>mapObjects</Filter>
-    </ClCompile>
-    <ClCompile Include="mapObjects\CGPandoraBox.cpp">
-      <Filter>mapObjects</Filter>
-    </ClCompile>
-    <ClCompile Include="mapObjects\CGTownInstance.cpp">
-      <Filter>mapObjects</Filter>
-    </ClCompile>
-    <ClCompile Include="mapObjects\CObjectClassesHandler.cpp">
-      <Filter>mapObjects</Filter>
-    </ClCompile>
-    <ClCompile Include="mapObjects\CObjectHandler.cpp">
-      <Filter>mapObjects</Filter>
-    </ClCompile>
-    <ClCompile Include="mapObjects\CommonConstructors.cpp">
-      <Filter>mapObjects</Filter>
-    </ClCompile>
-    <ClCompile Include="mapObjects\CQuest.cpp">
-      <Filter>mapObjects</Filter>
-    </ClCompile>
-    <ClCompile Include="mapObjects\CRewardableConstructor.cpp">
-      <Filter>mapObjects</Filter>
-    </ClCompile>
-    <ClCompile Include="mapObjects\CRewardableObject.cpp">
-      <Filter>mapObjects</Filter>
-    </ClCompile>
-    <ClCompile Include="mapObjects\JsonRandom.cpp">
-      <Filter>mapObjects</Filter>
-    </ClCompile>
-    <ClCompile Include="mapObjects\MiscObjects.cpp">
-      <Filter>mapObjects</Filter>
-    </ClCompile>
-    <ClCompile Include="mapObjects\ObjectTemplate.cpp">
-      <Filter>mapObjects</Filter>
-    </ClCompile>
-    <ClCompile Include="IHandlerBase.cpp" />
-    <ClCompile Include="spells\AdventureSpellMechanics.cpp">
-      <Filter>spells</Filter>
-    </ClCompile>
-    <ClCompile Include="spells\CSpellHandler.cpp">
-      <Filter>spells</Filter>
-    </ClCompile>
-    <ClCompile Include="spells\ViewSpellInt.cpp">
-      <Filter>spells</Filter>
-    </ClCompile>
-    <ClCompile Include="spells\ISpellMechanics.cpp">
-      <Filter>spells</Filter>
-    </ClCompile>
-    <ClCompile Include="spells\BattleSpellMechanics.cpp">
-      <Filter>spells</Filter>
-    </ClCompile>
-    <ClCompile Include="mapping\CDrawRoadsOperation.cpp" />
-    <ClCompile Include="CPathfinder.cpp" />
-    <ClCompile Include="registerTypes\TypesMapObjects1.cpp">
-      <Filter>registerTypes</Filter>
-    </ClCompile>
-    <ClCompile Include="registerTypes\TypesMapObjects2.cpp">
-      <Filter>registerTypes</Filter>
-    </ClCompile>
-    <ClCompile Include="registerTypes\TypesMapObjects3.cpp">
-      <Filter>registerTypes</Filter>
-    </ClCompile>
-    <ClCompile Include="filesystem\FileStream.cpp">
-      <Filter>filesystem</Filter>
-    </ClCompile>
-    <ClCompile Include="filesystem\FileInfo.cpp" />
-    <ClCompile Include="serializer\JsonDeserializer.cpp">
-      <Filter>serializer</Filter>
-    </ClCompile>
-    <ClCompile Include="serializer\JsonSerializeFormat.cpp">
-      <Filter>serializer</Filter>
-    </ClCompile>
-    <ClCompile Include="serializer\JsonSerializer.cpp">
-      <Filter>serializer</Filter>
-    </ClCompile>
-    <ClCompile Include="filesystem\CMemoryBuffer.cpp">
-      <Filter>filesystem</Filter>
-    </ClCompile>
-    <ClCompile Include="filesystem\CZipSaver.cpp">
-      <Filter>filesystem</Filter>
-    </ClCompile>
-    <ClCompile Include="filesystem\MinizipExtensions.cpp">
-      <Filter>filesystem</Filter>
-    </ClCompile>
-    <ClCompile Include="CStack.cpp" />
-    <ClCompile Include="battle\AccessibilityInfo.cpp">
-      <Filter>battle</Filter>
-    </ClCompile>
-    <ClCompile Include="battle\BattleAction.cpp">
-      <Filter>battle</Filter>
-    </ClCompile>
-    <ClCompile Include="battle\BattleAttackInfo.cpp">
-      <Filter>battle</Filter>
-    </ClCompile>
-    <ClCompile Include="battle\BattleHex.cpp">
-      <Filter>battle</Filter>
-    </ClCompile>
-    <ClCompile Include="battle\BattleInfo.cpp">
-      <Filter>battle</Filter>
-    </ClCompile>
-    <ClCompile Include="battle\CBattleInfoCallback.cpp">
-      <Filter>battle</Filter>
-    </ClCompile>
-    <ClCompile Include="battle\CBattleInfoEssentials.cpp">
-      <Filter>battle</Filter>
-    </ClCompile>
-    <ClCompile Include="battle\CCallbackBase.cpp">
-      <Filter>battle</Filter>
-    </ClCompile>
-    <ClCompile Include="battle\CObstacleInstance.cpp">
-      <Filter>battle</Filter>
-    </ClCompile>
-    <ClCompile Include="battle\CPlayerBattleCallback.cpp">
-      <Filter>battle</Filter>
-    </ClCompile>
-    <ClCompile Include="battle\ReachabilityInfo.cpp">
-      <Filter>battle</Filter>
-    </ClCompile>
-    <ClCompile Include="battle\SideInBattle.cpp">
-      <Filter>battle</Filter>
-    </ClCompile>
-    <ClCompile Include="battle\SiegeInfo.cpp">
-      <Filter>battle</Filter>
-    </ClCompile>
-    <ClCompile Include="serializer\CSerializer.cpp">
-      <Filter>serializer</Filter>
-    </ClCompile>
-    <ClCompile Include="serializer\BinarySerializer.cpp">
-      <Filter>serializer</Filter>
-    </ClCompile>
-    <ClCompile Include="serializer\BinaryDeserializer.cpp">
-      <Filter>serializer</Filter>
-    </ClCompile>
-    <ClCompile Include="serializer\CLoadIntegrityValidator.cpp">
-      <Filter>serializer</Filter>
-    </ClCompile>
-    <ClCompile Include="serializer\CMemorySerializer.cpp">
-      <Filter>serializer</Filter>
-    </ClCompile>
-    <ClCompile Include="serializer\Connection.cpp">
-      <Filter>serializer</Filter>
-    </ClCompile>
-    <ClCompile Include="serializer\CTypeList.cpp">
-      <Filter>serializer</Filter>
-    </ClCompile>
-    <ClCompile Include="CSkillHandler.cpp" />
-    <ClCompile Include="battle\BattleProxy.cpp">
-      <Filter>battle</Filter>
-    </ClCompile>
-    <ClCompile Include="battle\CUnitState.cpp">
-      <Filter>battle</Filter>
-    </ClCompile>
-    <ClCompile Include="battle\Destination.cpp">
-      <Filter>battle</Filter>
-    </ClCompile>
-    <ClCompile Include="battle\IBattleState.cpp">
-      <Filter>battle</Filter>
-    </ClCompile>
-    <ClCompile Include="battle\Unit.cpp">
-      <Filter>battle</Filter>
-    </ClCompile>
-    <ClCompile Include="spells\TargetCondition.cpp">
-      <Filter>spells</Filter>
-    </ClCompile>
-    <ClCompile Include="spells\effects\Catapult.cpp">
-      <Filter>spells\effects</Filter>
-    </ClCompile>
-    <ClCompile Include="spells\effects\Dispel.cpp">
-      <Filter>spells\effects</Filter>
-    </ClCompile>
-    <ClCompile Include="spells\effects\Heal.cpp">
-      <Filter>spells\effects</Filter>
-    </ClCompile>
-    <ClCompile Include="spells\effects\Obstacle.cpp">
-      <Filter>spells\effects</Filter>
-    </ClCompile>
-    <ClCompile Include="spells\effects\RemoveObstacle.cpp">
-      <Filter>spells\effects</Filter>
-    </ClCompile>
-    <ClCompile Include="spells\effects\Sacrifice.cpp">
-      <Filter>spells\effects</Filter>
-    </ClCompile>
-    <ClCompile Include="spells\effects\Teleport.cpp">
-      <Filter>spells\effects</Filter>
-    </ClCompile>
-    <ClCompile Include="spells\effects\UnitEffect.cpp">
-      <Filter>spells\effects</Filter>
-    </ClCompile>
-    <ClCompile Include="spells\effects\Clone.cpp">
-      <Filter>spells\effects</Filter>
-    </ClCompile>
-    <ClCompile Include="spells\effects\Damage.cpp">
-      <Filter>spells\effects</Filter>
-    </ClCompile>
-    <ClCompile Include="spells\effects\Effect.cpp">
-      <Filter>spells\effects</Filter>
-    </ClCompile>
-    <ClCompile Include="spells\effects\Effects.cpp">
-      <Filter>spells\effects</Filter>
-    </ClCompile>
-    <ClCompile Include="spells\effects\LocationEffect.cpp">
-      <Filter>spells\effects</Filter>
-    </ClCompile>
-    <ClCompile Include="spells\effects\Registry.cpp">
-      <Filter>spells\effects</Filter>
-    </ClCompile>
-    <ClCompile Include="spells\effects\Summon.cpp">
-      <Filter>spells\effects</Filter>
-    </ClCompile>
-    <ClCompile Include="spells\effects\Timed.cpp">
-      <Filter>spells\effects</Filter>
-    </ClCompile>
-    <ClCompile Include="spells\Problem.cpp">
-      <Filter>spells</Filter>
-    </ClCompile>
-    <ClCompile Include="spells\AbilityCaster.cpp">
-      <Filter>spells</Filter>
-    </ClCompile>
-    <ClCompile Include="spells\BonusCaster.cpp">
-      <Filter>spells</Filter>
-    </ClCompile>
-    <ClCompile Include="spells\ProxyCaster.cpp">
-      <Filter>spells</Filter>
-    </ClCompile>
-    <ClCompile Include="StartInfo.cpp" />
-    <ClCompile Include="registerTypes\TypesLobbyPacks.cpp">
-      <Filter>registerTypes</Filter>
-    </ClCompile>
-    <ClCompile Include="vstd\DateUtils.cpp">
-      <Filter>vstd</Filter>
-    </ClCompile>
-    <ClCompile Include="vstd\StringUtils.cpp">
-      <Filter>vstd</Filter>
-    </ClCompile>
-  </ItemGroup>
-  <ItemGroup>
-    <ClInclude Include="CCreatureSet.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="CGameState.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="CondSh.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="Bonus.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="IGameCallback.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="CGameInfoCallback.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="Interprocess.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="NetPacks.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="VCMI_Lib.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="VCMIDirs.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="CArtHandler.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="CBuildingHandler.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="CCreatureHandler.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="CGeneralTextHandler.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="CHeroHandler.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="ConstTransitivePtr.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="CTownHandler.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="IGameEventsReceiver.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="CScriptingModule.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="ResourceSet.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="CGameInterface.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="JsonNode.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\Global.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\AUTHORS.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="AI_Base.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="CConsoleHandler.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="CStopWatch.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="CThreadHelper.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="GameConstants.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="int3.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="StartInfo.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="StdInc.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="UnlockGuard.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="FunctionList.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="CModHandler.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="CConfigHandler.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="Mapping\CCampaignHandler.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="CBonusTypeHandler.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="IBonusTypeHandler.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="rmg\CZoneGraphGenerator.h">
-      <Filter>rmg</Filter>
-    </ClInclude>
-    <ClInclude Include="rmg\CZonePlacer.h">
-      <Filter>rmg</Filter>
-    </ClInclude>
-    <ClInclude Include="rmg\CRmgTemplateZone.h">
-      <Filter>rmg</Filter>
-    </ClInclude>
-    <ClInclude Include="rmg\CRmgTemplateStorage.h">
-      <Filter>rmg</Filter>
-    </ClInclude>
-    <ClInclude Include="rmg\CRmgTemplate.h">
-      <Filter>rmg</Filter>
-    </ClInclude>
-    <ClInclude Include="RMG\CMapGenerator.h">
-      <Filter>rmg</Filter>
-    </ClInclude>
-    <ClInclude Include="rmg\CMapGenOptions.h">
-      <Filter>rmg</Filter>
-    </ClInclude>
-    <ClInclude Include="CRandomGenerator.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="filesystem\AdapterLoaders.h">
-      <Filter>filesystem</Filter>
-    </ClInclude>
-    <ClInclude Include="filesystem\CArchiveLoader.h">
-      <Filter>filesystem</Filter>
-    </ClInclude>
-    <ClInclude Include="filesystem\CBinaryReader.h">
-      <Filter>filesystem</Filter>
-    </ClInclude>
-    <ClInclude Include="filesystem\CCompressedStream.h">
-      <Filter>filesystem</Filter>
-    </ClInclude>
-    <ClInclude Include="filesystem\CFileInfo.h">
-      <Filter>filesystem</Filter>
-    </ClInclude>
-    <ClInclude Include="filesystem\CFileInputStream.h">
-      <Filter>filesystem</Filter>
-    </ClInclude>
-    <ClInclude Include="filesystem\CFilesystemLoader.h">
-      <Filter>filesystem</Filter>
-    </ClInclude>
-    <ClInclude Include="filesystem\CInputStream.h">
-      <Filter>filesystem</Filter>
-    </ClInclude>
-    <ClInclude Include="filesystem\CMemoryStream.h">
-      <Filter>filesystem</Filter>
-    </ClInclude>
-    <ClInclude Include="filesystem\CZipLoader.h">
-      <Filter>filesystem</Filter>
-    </ClInclude>
-    <ClInclude Include="filesystem\Filesystem.h">
-      <Filter>filesystem</Filter>
-    </ClInclude>
-    <ClInclude Include="filesystem\ISimpleResourceLoader.h">
-      <Filter>filesystem</Filter>
-    </ClInclude>
-    <ClInclude Include="logging\CBasicLogConfigurator.h">
-      <Filter>logging</Filter>
-    </ClInclude>
-    <ClInclude Include="logging\CLogger.h">
-      <Filter>logging</Filter>
-    </ClInclude>
-    <ClInclude Include="mapping\CMap.h">
-      <Filter>mapping</Filter>
-    </ClInclude>
-    <ClInclude Include="mapping\CMapEditManager.h">
-      <Filter>mapping</Filter>
-    </ClInclude>
-    <ClInclude Include="mapping\CMapInfo.h">
-      <Filter>mapping</Filter>
-    </ClInclude>
-    <ClInclude Include="mapping\CMapService.h">
-      <Filter>mapping</Filter>
-    </ClInclude>
-    <ClInclude Include="mapping\MapFormatH3M.h">
-      <Filter>mapping</Filter>
-    </ClInclude>
-    <ClInclude Include="filesystem\ResourceID.h">
-      <Filter>filesystem</Filter>
-    </ClInclude>
-    <ClInclude Include="JsonDetail.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="mapping\MapFormatJson.h">
-      <Filter>mapping</Filter>
-    </ClInclude>
-    <ClInclude Include="LogicalExpression.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="rmg\float3.h">
-      <Filter>rmg</Filter>
-    </ClInclude>
-    <ClInclude Include="mapObjects\CArmedInstance.h">
-      <Filter>mapObjects</Filter>
-    </ClInclude>
-    <ClInclude Include="mapObjects\CBank.h">
-      <Filter>mapObjects</Filter>
-    </ClInclude>
-    <ClInclude Include="mapObjects\CGHeroInstance.h">
-      <Filter>mapObjects</Filter>
-    </ClInclude>
-    <ClInclude Include="mapObjects\CGMarket.h">
-      <Filter>mapObjects</Filter>
-    </ClInclude>
-    <ClInclude Include="mapObjects\CGPandoraBox.h">
-      <Filter>mapObjects</Filter>
-    </ClInclude>
-    <ClInclude Include="mapObjects\CGTownInstance.h">
-      <Filter>mapObjects</Filter>
-    </ClInclude>
-    <ClInclude Include="mapObjects\CObjectClassesHandler.h">
-      <Filter>mapObjects</Filter>
-    </ClInclude>
-    <ClInclude Include="mapObjects\CObjectHandler.h">
-      <Filter>mapObjects</Filter>
-    </ClInclude>
-    <ClInclude Include="mapObjects\CommonConstructors.h">
-      <Filter>mapObjects</Filter>
-    </ClInclude>
-    <ClInclude Include="mapObjects\CQuest.h">
-      <Filter>mapObjects</Filter>
-    </ClInclude>
-    <ClInclude Include="mapObjects\CRewardableConstructor.h">
-      <Filter>mapObjects</Filter>
-    </ClInclude>
-    <ClInclude Include="mapObjects\CRewardableObject.h">
-      <Filter>mapObjects</Filter>
-    </ClInclude>
-    <ClInclude Include="mapObjects\JsonRandom.h">
-      <Filter>mapObjects</Filter>
-    </ClInclude>
-    <ClInclude Include="mapObjects\MapObjects.h">
-      <Filter>mapObjects</Filter>
-    </ClInclude>
-    <ClInclude Include="mapObjects\MiscObjects.h">
-      <Filter>mapObjects</Filter>
-    </ClInclude>
-    <ClInclude Include="mapObjects\ObjectTemplate.h">
-      <Filter>mapObjects</Filter>
-    </ClInclude>
-    <ClInclude Include="CGameStateFwd.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="spells\AdventureSpellMechanics.h">
-      <Filter>spells</Filter>
-    </ClInclude>
-    <ClInclude Include="spells\BattleSpellMechanics.h">
-      <Filter>spells</Filter>
-    </ClInclude>
-    <ClInclude Include="spells\CSpellHandler.h">
-      <Filter>spells</Filter>
-    </ClInclude>
-    <ClInclude Include="spells\ISpellMechanics.h">
-      <Filter>spells</Filter>
-    </ClInclude>
-    <ClInclude Include="spells\ViewSpellInt.h">
-      <Filter>spells</Filter>
-    </ClInclude>
-    <ClInclude Include="spells\SpellMechanics.h">
-      <Filter>spells</Filter>
-    </ClInclude>
-    <ClInclude Include="spells\Magic.h">
-      <Filter>spells</Filter>
-    </ClInclude>
-    <ClInclude Include="CPathfinder.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="CPlayerState.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="mapping\CMapDefines.h">
-      <Filter>mapping</Filter>
-    </ClInclude>
-    <ClInclude Include="CSoundBase.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="IHandlerBase.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="NetPacksBase.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="ScopeGuard.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="StringConstants.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="vcmi_endian.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="mapping\CDrawRoadsOperation.h">
-      <Filter>mapping</Filter>
-    </ClInclude>
-    <ClInclude Include="filesystem\FileStream.h">
-      <Filter>filesystem</Filter>
-    </ClInclude>
-    <ClInclude Include="filesystem\FileInfo.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="serializer\JsonDeserializer.h">
-      <Filter>serializer</Filter>
-    </ClInclude>
-    <ClInclude Include="serializer\JsonSerializeFormat.h">
-      <Filter>serializer</Filter>
-    </ClInclude>
-    <ClInclude Include="serializer\JsonSerializer.h">
-      <Filter>serializer</Filter>
-    </ClInclude>
-    <ClInclude Include="filesystem\CInputOutputStream.h">
-      <Filter>filesystem</Filter>
-    </ClInclude>
-    <ClInclude Include="filesystem\CMemoryBuffer.h">
-      <Filter>filesystem</Filter>
-    </ClInclude>
-    <ClInclude Include="filesystem\COutputStream.h">
-      <Filter>filesystem</Filter>
-    </ClInclude>
-    <ClInclude Include="filesystem\CStream.h">
-      <Filter>filesystem</Filter>
-    </ClInclude>
-    <ClInclude Include="filesystem\CZipSaver.h">
-      <Filter>filesystem</Filter>
-    </ClInclude>
-    <ClInclude Include="filesystem\MinizipExtensions.h">
-      <Filter>filesystem</Filter>
-    </ClInclude>
-    <ClInclude Include="..\Version.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="CStack.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="battle\AccessibilityInfo.h">
-      <Filter>battle</Filter>
-    </ClInclude>
-    <ClInclude Include="battle\BattleAction.h">
-      <Filter>battle</Filter>
-    </ClInclude>
-    <ClInclude Include="battle\BattleAttackInfo.h">
-      <Filter>battle</Filter>
-    </ClInclude>
-    <ClInclude Include="battle\BattleHex.h">
-      <Filter>battle</Filter>
-    </ClInclude>
-    <ClInclude Include="battle\BattleInfo.h">
-      <Filter>battle</Filter>
-    </ClInclude>
-    <ClInclude Include="battle\CBattleInfoCallback.h">
-      <Filter>battle</Filter>
-    </ClInclude>
-    <ClInclude Include="battle\CBattleInfoEssentials.h">
-      <Filter>battle</Filter>
-    </ClInclude>
-    <ClInclude Include="battle\CCallbackBase.h">
-      <Filter>battle</Filter>
-    </ClInclude>
-    <ClInclude Include="battle\CObstacleInstance.h">
-      <Filter>battle</Filter>
-    </ClInclude>
-    <ClInclude Include="battle\CPlayerBattleCallback.h">
-      <Filter>battle</Filter>
-    </ClInclude>
-    <ClInclude Include="battle\ReachabilityInfo.h">
-      <Filter>battle</Filter>
-    </ClInclude>
-    <ClInclude Include="battle\SideInBattle.h">
-      <Filter>battle</Filter>
-    </ClInclude>
-    <ClInclude Include="battle\SiegeInfo.h">
-      <Filter>battle</Filter>
-    </ClInclude>
-    <ClInclude Include="registerTypes\RegisterTypes.h">
-      <Filter>registerTypes</Filter>
-    </ClInclude>
-    <ClInclude Include="serializer\CSerializer.h">
-      <Filter>serializer</Filter>
-    </ClInclude>
-    <ClInclude Include="serializer\BinaryDeserializer.h">
-      <Filter>serializer</Filter>
-    </ClInclude>
-    <ClInclude Include="serializer\BinarySerializer.h">
-      <Filter>serializer</Filter>
-    </ClInclude>
-    <ClInclude Include="serializer\CLoadIntegrityValidator.h">
-      <Filter>serializer</Filter>
-    </ClInclude>
-    <ClInclude Include="serializer\CMemorySerializer.h">
-      <Filter>serializer</Filter>
-    </ClInclude>
-    <ClInclude Include="serializer\Connection.h">
-      <Filter>serializer</Filter>
-    </ClInclude>
-    <ClInclude Include="serializer\CTypeList.h">
-      <Filter>serializer</Filter>
-    </ClInclude>
-    <ClInclude Include="CSkillHandler.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="spells\effects\GlobalEffect.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="spells\effects\StackEffect.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="serializer\JsonTreeSerializer.h">
-      <Filter>serializer</Filter>
-    </ClInclude>
-    <ClInclude Include="battle\BattleProxy.h">
-      <Filter>battle</Filter>
-    </ClInclude>
-    <ClInclude Include="battle\CUnitState.h">
-      <Filter>battle</Filter>
-    </ClInclude>
-    <ClInclude Include="battle\Destination.h">
-      <Filter>battle</Filter>
-    </ClInclude>
-    <ClInclude Include="battle\IBattleState.h">
-      <Filter>battle</Filter>
-    </ClInclude>
-    <ClInclude Include="battle\IUnitInfo.h">
-      <Filter>battle</Filter>
-    </ClInclude>
-    <ClInclude Include="battle\Unit.h">
-      <Filter>battle</Filter>
-    </ClInclude>
-    <ClInclude Include="spells\TargetCondition.h">
-      <Filter>spells</Filter>
-    </ClInclude>
-    <ClInclude Include="spells\effects\Catapult.h">
-      <Filter>spells\effects</Filter>
-    </ClInclude>
-    <ClInclude Include="spells\effects\Dispel.h">
-      <Filter>spells\effects</Filter>
-    </ClInclude>
-    <ClInclude Include="spells\effects\EffectsFwd.h">
-      <Filter>spells\effects</Filter>
-    </ClInclude>
-    <ClInclude Include="spells\effects\Heal.h">
-      <Filter>spells\effects</Filter>
-    </ClInclude>
-    <ClInclude Include="spells\effects\Obstacle.h">
-      <Filter>spells\effects</Filter>
-    </ClInclude>
-    <ClInclude Include="spells\effects\RemoveObstacle.h">
-      <Filter>spells\effects</Filter>
-    </ClInclude>
-    <ClInclude Include="spells\effects\Sacrifice.h">
-      <Filter>spells\effects</Filter>
-    </ClInclude>
-    <ClInclude Include="spells\effects\Teleport.h">
-      <Filter>spells\effects</Filter>
-    </ClInclude>
-    <ClInclude Include="spells\effects\UnitEffect.h">
-      <Filter>spells\effects</Filter>
-    </ClInclude>
-    <ClInclude Include="spells\effects\Clone.h">
-      <Filter>spells\effects</Filter>
-    </ClInclude>
-    <ClInclude Include="spells\effects\Damage.h">
-      <Filter>spells\effects</Filter>
-    </ClInclude>
-    <ClInclude Include="spells\effects\Effect.h">
-      <Filter>spells\effects</Filter>
-    </ClInclude>
-    <ClInclude Include="spells\effects\Effects.h">
-      <Filter>spells\effects</Filter>
-    </ClInclude>
-    <ClInclude Include="spells\effects\LocationEffect.h">
-      <Filter>spells\effects</Filter>
-    </ClInclude>
-    <ClInclude Include="spells\effects\Registry.h">
-      <Filter>spells\effects</Filter>
-    </ClInclude>
-    <ClInclude Include="spells\effects\Summon.h">
-      <Filter>spells\effects</Filter>
-    </ClInclude>
-    <ClInclude Include="spells\effects\Timed.h">
-      <Filter>spells\effects</Filter>
-    </ClInclude>
-    <ClInclude Include="spells\Problem.h">
-      <Filter>spells</Filter>
-    </ClInclude>
-    <ClInclude Include="spells\AbilityCaster.h">
-      <Filter>spells</Filter>
-    </ClInclude>
-    <ClInclude Include="spells\BonusCaster.h">
-      <Filter>spells</Filter>
-    </ClInclude>
-    <ClInclude Include="spells\ProxyCaster.h">
-      <Filter>spells</Filter>
-    </ClInclude>
-    <ClInclude Include="NetPacksLobby.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="serializer\Cast.h">
-      <Filter>serializer</Filter>
-    </ClInclude>
-  </ItemGroup>
-</Project>
\ No newline at end of file
