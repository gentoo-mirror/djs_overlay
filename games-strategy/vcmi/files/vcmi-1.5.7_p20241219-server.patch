diff --color -urN vcmi-1.5.7/server/battles/BattleActionProcessor.cpp vcmi/server/battles/BattleActionProcessor.cpp
--- vcmi-1.5.7/server/battles/BattleActionProcessor.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/server/battles/BattleActionProcessor.cpp	2024-12-19 15:00:22.991151781 +0100
@@ -14,13 +14,14 @@
 
 #include "../CGameHandler.h"
 
-#include "../../lib/CGeneralTextHandler.h"
+#include "../../lib/texts/CGeneralTextHandler.h"
 #include "../../lib/CStack.h"
-#include "../../lib/GameSettings.h"
+#include "../../lib/IGameSettings.h"
 #include "../../lib/battle/CBattleInfoCallback.h"
 #include "../../lib/battle/CObstacleInstance.h"
 #include "../../lib/battle/IBattleState.h"
 #include "../../lib/battle/BattleAction.h"
+#include "../../lib/entities/building/TownFortifications.h"
 #include "../../lib/gameState/CGameState.h"
 #include "../../lib/networkPacks/PacksForClientBattle.h"
 #include "../../lib/networkPacks/SetStackEffect.h"
@@ -29,6 +30,8 @@
 #include "../../lib/spells/ISpellMechanics.h"
 #include "../../lib/spells/Problem.h"
 
+#include <vstd/RNG.h>
+
 BattleActionProcessor::BattleActionProcessor(BattleProcessor * owner, CGameHandler * newGameHandler)
 	: owner(owner)
 	, gameHandler(newGameHandler)
@@ -63,7 +66,7 @@
 		return false;
 	}
 
-	owner->setBattleResult(battle, EBattleResult::ESCAPE, !ba.side);
+	owner->setBattleResult(battle, EBattleResult::ESCAPE, battle.otherSide(ba.side));
 	return true;
 }
 
@@ -84,7 +87,7 @@
 	}
 
 	gameHandler->giveResource(player, EGameResID::GOLD, -cost);
-	owner->setBattleResult(battle, EBattleResult::SURRENDER, !ba.side);
+	owner->setBattleResult(battle, EBattleResult::SURRENDER, battle.otherSide(ba.side));
 	return true;
 }
 
@@ -184,7 +187,7 @@
 	buffer.push_back(bonus2);
 
 	sse.toUpdate.push_back(std::make_pair(ba.stackNumber, buffer));
-	gameHandler->sendAndApply(&sse);
+	gameHandler->sendAndApply(sse);
 
 	BattleLogMessage message;
 	message.battleID = battle.getBattle()->getBattleID();
@@ -196,7 +199,7 @@
 
 	message.lines.push_back(text);
 
-	gameHandler->sendAndApply(&message);
+	gameHandler->sendAndApply(message);
 	return true;
 }
 
@@ -273,7 +276,7 @@
 	for (int i = 0; i < totalAttacks; ++i)
 	{
 		//first strike
-		if(i == 0 && firstStrike && retaliation && !stack->hasBonusOfType(BonusType::BLOCKS_RETALIATION))
+		if(i == 0 && firstStrike && retaliation && !stack->hasBonusOfType(BonusType::BLOCKS_RETALIATION) && !stack->hasBonusOfType(BonusType::INVINCIBLE))
 		{
 			makeAttack(battle, destinationStack, stack, 0, stack->getPosition(), true, false, true);
 		}
@@ -300,6 +303,7 @@
 		//we check retaliation twice, so if it unblocked during attack it will work only on next attack
 		if(stack->alive()
 			&& !stack->hasBonusOfType(BonusType::BLOCKS_RETALIATION)
+			&& !stack->hasBonusOfType(BonusType::INVINCIBLE)
 			&& (i == 0 && !firstStrike)
 			&& retaliation && destinationStack->ableToRetaliate())
 		{
@@ -344,20 +348,27 @@
 		return false;
 	}
 
-	if (!destinationStack)
+	const bool emptyTileAreaAttack = battle.battleCanTargetEmptyHex(stack);
+
+	if (!destinationStack && !emptyTileAreaAttack)
 	{
 		gameHandler->complain("No target to shoot!");
 		return false;
 	}
 
-	static const auto firstStrikeSelector = Selector::typeSubtype(BonusType::FIRST_STRIKE, BonusCustomSubtype::damageTypeAll).Or(Selector::typeSubtype(BonusType::FIRST_STRIKE, BonusCustomSubtype::damageTypeRanged));
-	const bool firstStrike = destinationStack->hasBonus(firstStrikeSelector);
+	bool firstStrike = false;
+	if(!emptyTileAreaAttack)
+	{
+		static const auto firstStrikeSelector = Selector::typeSubtype(BonusType::FIRST_STRIKE, BonusCustomSubtype::damageTypeAll).Or(Selector::typeSubtype(BonusType::FIRST_STRIKE, BonusCustomSubtype::damageTypeRanged));
+		firstStrike = destinationStack->hasBonus(firstStrikeSelector);
+	}
 
 	if (!firstStrike)
 		makeAttack(battle, stack, destinationStack, 0, destination, true, true, false);
 
 	//ranged counterattack
-	if (destinationStack->hasBonusOfType(BonusType::RANGED_RETALIATION)
+	if (!emptyTileAreaAttack
+		&& destinationStack->hasBonusOfType(BonusType::RANGED_RETALIATION)
 		&& !stack->hasBonusOfType(BonusType::BLOCKS_RANGED_RETALIATION)
 		&& destinationStack->ableToRetaliate()
 		&& battle.battleCanShoot(destinationStack, stack->getPosition())
@@ -378,11 +389,9 @@
 
 	for(int i = firstStrike ? 0:1; i < totalRangedAttacks; ++i)
 	{
-		if(
-			stack->alive()
-			&& destinationStack->alive()
-			&& stack->shots.canUse()
-			)
+		if(stack->alive()
+			&& (emptyTileAreaAttack || destinationStack->alive())
+			&& stack->shots.canUse())
 		{
 			makeAttack(battle, stack, destinationStack, 0, destination, false, true, false);
 		}
@@ -587,7 +596,7 @@
 	{
 		StartAction startAction(ba);
 		startAction.battleID = battle.getBattle()->getBattleID();
-		gameHandler->sendAndApply(&startAction);
+		gameHandler->sendAndApply(startAction);
 	}
 
 	bool result = dispatchBattleAction(battle, ba);
@@ -596,7 +605,7 @@
 	{
 		EndAction endAction;
 		endAction.battleID = battle.getBattle()->getBattleID();
-		gameHandler->sendAndApply(&endAction);
+		gameHandler->sendAndApply(endAction);
 	}
 
 	if(ba.actionType == EActionType::WAIT || ba.actionType == EActionType::DEFEND || ba.actionType == EActionType::SHOOT || ba.actionType == EActionType::MONSTER_SPELL)
@@ -625,7 +634,7 @@
 		return 0;
 
 	//initing necessary tables
-	auto accessibility = battle.getAccesibility(curStack);
+	auto accessibility = battle.getAccessibility(curStack);
 	std::set<BattleHex> passed;
 	//Ignore obstacles on starting position
 	passed.insert(curStack->getPosition());
@@ -649,7 +658,7 @@
 
 	bool canUseGate = false;
 	auto dbState = battle.battleGetGateState();
-	if(battle.battleGetSiegeLevel() > 0 && curStack->unitSide() == BattleSide::DEFENDER &&
+	if(battle.battleGetFortifications().wallsHealth > 0 && curStack->unitSide() == BattleSide::DEFENDER &&
 		dbState != EGateState::DESTROYED &&
 		dbState != EGateState::BLOCKED)
 	{
@@ -707,7 +716,7 @@
 				BattleUpdateGateState db;
 				db.battleID = battle.getBattle()->getBattleID();
 				db.state = EGateState::OPENED;
-				gameHandler->sendAndApply(&db);
+				gameHandler->sendAndApply(db);
 			}
 
 			//inform clients about move
@@ -719,7 +728,7 @@
 			sm.tilesToMove = tiles;
 			sm.distance = path.second;
 			sm.teleporting = false;
-			gameHandler->sendAndApply(&sm);
+			gameHandler->sendAndApply(sm);
 		}
 	}
 	else //for non-flying creatures
@@ -847,7 +856,7 @@
 				sm.distance = path.second;
 				sm.teleporting = false;
 				sm.tilesToMove = tiles;
-				gameHandler->sendAndApply(&sm);
+				gameHandler->sendAndApply(sm);
 				tiles.clear();
 			}
 
@@ -872,7 +881,7 @@
 							BattleUpdateGateState db;
 							db.battleID = battle.getBattle()->getBattleID();
 							db.state = EGateState::OPENED;
-							gameHandler->sendAndApply(&db);
+							gameHandler->sendAndApply(db);
 						}
 					}
 					else if (curStack->getPosition() == gateMayCloseAtHex)
@@ -888,7 +897,7 @@
 		}
 	}
 	//handle last hex separately for deviation
-	if (VLC->settings()->getBoolean(EGameSettings::COMBAT_ONE_HEX_TRIGGERS_OBSTACLES))
+	if (gameHandler->getSettings().getBoolean(EGameSettings::COMBAT_ONE_HEX_TRIGGERS_OBSTACLES))
 	{
 		if (dest == battle::Unit::occupiedHex(start, curStack->doubleWide(), curStack->unitSide())
 			|| start == battle::Unit::occupiedHex(dest, curStack->doubleWide(), curStack->unitSide()))
@@ -904,9 +913,13 @@
 
 void BattleActionProcessor::makeAttack(const CBattleInfoCallback & battle, const CStack * attacker, const CStack * defender, int distance, BattleHex targetHex, bool first, bool ranged, bool counter)
 {
-	if(first && !counter)
+	if(defender && first && !counter)
 		handleAttackBeforeCasting(battle, ranged, attacker, defender);
 
+	// If the attacker or defender is not alive before the attack action, the action should be skipped.
+	if((!attacker->alive()) || (defender && !defender->alive()))
+		return;
+
 	FireShieldInfo fireShield;
 	BattleAttack bat;
 	BattleLogMessage blm;
@@ -927,7 +940,7 @@
 
 	if(attackerLuck > 0)
 	{
-		auto diceSize = VLC->settings()->getVector(EGameSettings::COMBAT_GOOD_LUCK_DICE);
+		auto diceSize = gameHandler->getSettings().getVector(EGameSettings::COMBAT_GOOD_LUCK_DICE);
 		size_t diceIndex = std::min<size_t>(diceSize.size(), attackerLuck) - 1; // array index, so 0-indexed
 
 		if(diceSize.size() > 0 && gameHandler->getRandomGenerator().nextInt(1, diceSize[diceIndex]) == 1)
@@ -936,7 +949,7 @@
 
 	if(attackerLuck < 0)
 	{
-		auto diceSize = VLC->settings()->getVector(EGameSettings::COMBAT_BAD_LUCK_DICE);
+		auto diceSize = gameHandler->getSettings().getVector(EGameSettings::COMBAT_BAD_LUCK_DICE);
 		size_t diceIndex = std::min<size_t>(diceSize.size(), -attackerLuck) - 1; // array index, so 0-indexed
 
 		if(diceSize.size() > 0 && gameHandler->getRandomGenerator().nextInt(1, diceSize[diceIndex]) == 1)
@@ -956,18 +969,18 @@
 			bat.flags |= BattleAttack::BALLISTA_DOUBLE_DMG;
 	}
 
-	int64_t drainedLife = 0;
+	battle::HealInfo healInfo;
 
 	// only primary target
-	if(defender->alive())
-		drainedLife += applyBattleEffects(battle, bat, attackerState, fireShield, defender, distance, false);
+	if(defender && defender->alive())
+		applyBattleEffects(battle, bat, attackerState, fireShield, defender, healInfo, distance, false);
 
 	//multiple-hex normal attack
 	std::set<const CStack*> attackedCreatures = battle.getAttackedCreatures(attacker, targetHex, bat.shot()); //creatures other than primary target
 	for(const CStack * stack : attackedCreatures)
 	{
 		if(stack != defender && stack->alive()) //do not hit same stack twice
-			drainedLife += applyBattleEffects(battle, bat, attackerState, fireShield, stack, distance, true);
+			applyBattleEffects(battle, bat, attackerState, fireShield, stack, healInfo, distance, true);
 	}
 
 	std::shared_ptr<const Bonus> bonus = attacker->getFirstBonus(Selector::type()(BonusType::SPELL_LIKE_ATTACK));
@@ -995,7 +1008,7 @@
 		{
 			if(stack != defender && stack->alive()) //do not hit same stack twice
 			{
-				drainedLife += applyBattleEffects(battle, bat, attackerState, fireShield, stack, distance, true);
+				applyBattleEffects(battle, bat, attackerState, fireShield, stack, healInfo, distance, true);
 			}
 		}
 
@@ -1019,13 +1032,13 @@
 		bat.attackerChanges.changedStacks.push_back(info);
 	}
 
-	if (drainedLife > 0)
+	if (healInfo.healedHealthPoints > 0)
 		bat.flags |= BattleAttack::LIFE_DRAIN;
 
 	for (BattleStackAttacked & bsa : bat.bsa)
 		bsa.battleID = battle.getBattle()->getBattleID();
 
-	gameHandler->sendAndApply(&bat);
+	gameHandler->sendAndApply(bat);
 
 	{
 		const bool multipleTargets = bat.bsa.size() > 1;
@@ -1039,26 +1052,17 @@
 			totalKills += bsa.killedAmount;
 		}
 
-		{
-			MetaString text;
-			attacker->addText(text, EMetaText::GENERAL_TXT, 376);
-			attacker->addNameReplacement(text);
-			text.replaceNumber(totalDamage);
-			blm.lines.push_back(text);
-		}
+		addGenericDamageLog(blm, attackerState, totalDamage);
 
-		addGenericKilledLog(blm, defender, totalKills, multipleTargets);
+		if(defender)
+			addGenericKilledLog(blm, defender, totalKills, multipleTargets);
 	}
 
 	// drain life effect (as well as log entry) must be applied after the attack
-	if(drainedLife > 0)
+	if(healInfo.healedHealthPoints > 0)
 	{
-		MetaString text;
-		attackerState->addText(text, EMetaText::GENERAL_TXT, 361);
-		attackerState->addNameReplacement(text, false);
-		text.replaceNumber(drainedLife);
-		defender->addNameReplacement(text, true);
-		blm.lines.push_back(std::move(text));
+		addGenericDrainedLifeLog(blm, attackerState, defender, healInfo.healedHealthPoints);
+		addGenericResurrectedLog(blm, attackerState, defender, healInfo.resurrectedCount);
 	}
 
 	if(!fireShield.empty())
@@ -1101,7 +1105,7 @@
 			StacksInjured pack;
 			pack.battleID = battle.getBattle()->getBattleID();
 			pack.stacks.push_back(bsa);
-			gameHandler->sendAndApply(&pack);
+			gameHandler->sendAndApply(pack);
 
 			// TODO: this is already implemented in Damage::describeEffect()
 			{
@@ -1115,9 +1119,10 @@
 		}
 	}
 
-	gameHandler->sendAndApply(&blm);
+	gameHandler->sendAndApply(blm);
 
-	handleAfterAttackCasting(battle, ranged, attacker, defender);
+	if(defender)
+		handleAfterAttackCasting(battle, ranged, attacker, defender);
 }
 
 void BattleActionProcessor::attackCasting(const CBattleInfoCallback & battle, bool ranged, BonusType attackMode, const battle::Unit * attacker, const CStack * defender)
@@ -1273,10 +1278,9 @@
 	int singleCreatureKillChancePercent = attacker->valOfBonuses(BonusType::DEATH_STARE, subtype);
 	double chanceToKill = singleCreatureKillChancePercent / 100.0;
 	vstd::amin(chanceToKill, 1); //cap at 100%
-	std::binomial_distribution<> distribution(attacker->getCount(), chanceToKill);
-	int killedCreatures = distribution(gameHandler->getRandomGenerator().getStdGenerator());
+	int killedCreatures = gameHandler->getRandomGenerator().nextBinomialInt(attacker->getCount(), chanceToKill);
 
-	int maxToKill = (attacker->getCount() * singleCreatureKillChancePercent + 99) / 100;
+	int maxToKill = vstd::divideAndCeil(attacker->getCount() * singleCreatureKillChancePercent, 100);
 	vstd::amin(killedCreatures, maxToKill);
 
 	killedCreatures += (attacker->level() * attacker->valOfBonuses(BonusType::DEATH_STARE, BonusCustomSubtype::deathStareCommander)) / defender->level();
@@ -1351,7 +1355,7 @@
 		double chanceToTrigger = attacker->valOfBonuses(BonusType::TRANSMUTATION) / 100.0f;
 		vstd::amin(chanceToTrigger, 1); //cap at 100%
 
-		if(gameHandler->getRandomGenerator().getDoubleRange(0, 1)() > chanceToTrigger)
+		if(gameHandler->getRandomGenerator().nextDouble(0, 1) > chanceToTrigger)
 			return;
 
 		int bonusAdditionalInfo = attacker->getBonus(Selector::type()(BonusType::TRANSMUTATION))->additionalInfo[0];
@@ -1386,14 +1390,14 @@
 		BattleUnitsChanged removeUnits;
 		removeUnits.battleID = battle.getBattle()->getBattleID();
 		removeUnits.changedStacks.emplace_back(defender->unitId(), UnitChanges::EOperation::REMOVE);
-		gameHandler->sendAndApply(&removeUnits);
-		gameHandler->sendAndApply(&addUnits);
+		gameHandler->sendAndApply(removeUnits);
+		gameHandler->sendAndApply(addUnits);
 
 		// send empty event to client
 		// temporary(?) workaround to force animations to trigger
 		StacksInjured fakeEvent;
 		fakeEvent.battleID = battle.getBattle()->getBattleID();
-		gameHandler->sendAndApply(&fakeEvent);
+		gameHandler->sendAndApply(fakeEvent);
 	}
 
 	if(attacker->hasBonusOfType(BonusType::DESTRUCTION, BonusCustomSubtype::destructionKillPercentage) || attacker->hasBonusOfType(BonusType::DESTRUCTION, BonusCustomSubtype::destructionKillAmount))
@@ -1415,7 +1419,7 @@
 
 		vstd::amin(chanceToTrigger, 1); //cap trigger chance at 100%
 
-		if(gameHandler->getRandomGenerator().getDoubleRange(0, 1)() > chanceToTrigger)
+		if(gameHandler->getRandomGenerator().nextDouble(0, 1) > chanceToTrigger)
 			return;
 
 		BattleStackAttacked bsa;
@@ -1430,12 +1434,12 @@
 		si.battleID = battle.getBattle()->getBattleID();
 		si.stacks.push_back(bsa);
 
-		gameHandler->sendAndApply(&si);
+		gameHandler->sendAndApply(si);
 		sendGenericKilledLog(battle, defender, bsa.killedAmount, false);
 	}
 }
 
-int64_t BattleActionProcessor::applyBattleEffects(const CBattleInfoCallback & battle, BattleAttack & bat, std::shared_ptr<battle::CUnitState> attackerState, FireShieldInfo & fireShield, const CStack * def, int distance, bool secondary)
+void BattleActionProcessor::applyBattleEffects(const CBattleInfoCallback & battle, BattleAttack & bat, std::shared_ptr<battle::CUnitState> attackerState, FireShieldInfo & fireShield, const CStack * def, battle::HealInfo & healInfo, int distance, bool secondary) const
 {
 	BattleStackAttacked bsa;
 	if(secondary)
@@ -1456,14 +1460,11 @@
 		CStack::prepareAttacked(bsa, gameHandler->getRandomGenerator(), bai.defender->acquireState()); //calculate casualties
 	}
 
-	int64_t drainedLife = 0;
-
 	//life drain handling
 	if(attackerState->hasBonusOfType(BonusType::LIFE_DRAIN) && def->isLiving())
 	{
 		int64_t toHeal = bsa.damageAmount * attackerState->valOfBonuses(BonusType::LIFE_DRAIN) / 100;
-		attackerState->heal(toHeal, EHealLevel::RESURRECT, EHealPower::PERMANENT);
-		drainedLife += toHeal;
+		healInfo += attackerState->heal(toHeal, EHealLevel::RESURRECT, EHealPower::PERMANENT);
 	}
 
 	//soul steal handling
@@ -1477,8 +1478,7 @@
 			{
 				int64_t toHeal = bsa.killedAmount * attackerState->valOfBonuses(BonusType::SOUL_STEAL, subtype) * attackerState->getMaxHealth();
 				bool permanent = subtype == BonusCustomSubtype::soulStealPermanent;
-				attackerState->heal(toHeal, EHealLevel::OVERHEAL, (permanent ? EHealPower::PERMANENT : EHealPower::ONE_BATTLE));
-				drainedLife += toHeal;
+				healInfo += attackerState->heal(toHeal, EHealLevel::OVERHEAL, (permanent ? EHealPower::PERMANENT : EHealPower::ONE_BATTLE));
 				break;
 			}
 		}
@@ -1499,8 +1499,6 @@
 		auto fireShieldDamage = (std::min<int64_t>(def->getAvailableHealth(), bsa.damageAmount) * def->valOfBonuses(BonusType::FIRE_SHIELD)) / 100;
 		fireShield.push_back(std::make_pair(def, fireShieldDamage));
 	}
-
-	return drainedLife;
 }
 
 void BattleActionProcessor::sendGenericKilledLog(const CBattleInfoCallback & battle, const CStack * defender, int32_t killed, bool multiple)
@@ -1510,11 +1508,11 @@
 		BattleLogMessage blm;
 		blm.battleID = battle.getBattle()->getBattleID();
 		addGenericKilledLog(blm, defender, killed, multiple);
-		gameHandler->sendAndApply(&blm);
+		gameHandler->sendAndApply(blm);
 	}
 }
 
-void BattleActionProcessor::addGenericKilledLog(BattleLogMessage & blm, const CStack * defender, int32_t killed, bool multiple)
+void BattleActionProcessor::addGenericKilledLog(BattleLogMessage & blm, const CStack * defender, int32_t killed, bool multiple) const
 {
 	if(killed > 0)
 	{
@@ -1542,6 +1540,46 @@
 	}
 }
 
+void BattleActionProcessor::addGenericDamageLog(BattleLogMessage& blm, const std::shared_ptr<battle::CUnitState> &attackerState, int64_t damageDealt) const
+{
+	MetaString text;
+	attackerState->addText(text, EMetaText::GENERAL_TXT, 376);
+	attackerState->addNameReplacement(text);
+	text.replaceNumber(damageDealt);
+	blm.lines.push_back(std::move(text));
+}
+
+void BattleActionProcessor::addGenericDrainedLifeLog(BattleLogMessage& blm, const std::shared_ptr<battle::CUnitState>& attackerState, const CStack* defender, int64_t drainedLife) const
+{
+	MetaString text;
+	attackerState->addText(text, EMetaText::GENERAL_TXT, 361);
+	attackerState->addNameReplacement(text);
+	text.replaceNumber(drainedLife);
+	defender->addNameReplacement(text);
+	blm.lines.push_back(std::move(text));
+}
+
+void BattleActionProcessor::addGenericResurrectedLog(BattleLogMessage& blm, const std::shared_ptr<battle::CUnitState>& attackerState, const CStack* defender, int64_t resurrected) const
+{
+	if (resurrected > 0)
+	{
+		auto text = blm.lines.back().toString();
+		text.pop_back();	// erase '.' at the end of line with life drain info
+		MetaString ms = MetaString::createFromRawString(text);
+		if (resurrected == 1)
+		{
+			ms.appendLocalString(EMetaText::GENERAL_TXT, 363);		// "\n and one rises from the dead."
+		}
+		else
+		{
+			ms.appendLocalString(EMetaText::GENERAL_TXT, 364);		// "\n and %d rise from the dead."
+			ms.replaceNumber(resurrected);
+		}
+		blm.lines[blm.lines.size() - 1] = std::move(ms);
+	}	
+
+}
+
 bool BattleActionProcessor::makeAutomaticBattleAction(const CBattleInfoCallback & battle, const BattleAction & ba)
 {
 	return makeBattleActionImpl(battle, ba);
@@ -1549,7 +1587,7 @@
 
 bool BattleActionProcessor::makePlayerBattleAction(const CBattleInfoCallback & battle, PlayerColor player, const BattleAction &ba)
 {
-	if (ba.side != 0 && ba.side != 1 && gameHandler->complain("Can not make action - invalid battle side!"))
+	if (ba.side != BattleSide::ATTACKER && ba.side != BattleSide::DEFENDER && gameHandler->complain("Can not make action - invalid battle side!"))
 		return false;
 
 	if(battle.battleGetTacticDist() != 0)
diff --color -urN vcmi-1.5.7/server/battles/BattleActionProcessor.h vcmi/server/battles/BattleActionProcessor.h
--- vcmi-1.5.7/server/battles/BattleActionProcessor.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/server/battles/BattleActionProcessor.h	2024-12-19 15:00:22.991151781 +0100
@@ -19,11 +19,12 @@
 struct BattleHex;
 class CStack;
 class PlayerColor;
-enum class BonusType;
+enum class BonusType : uint8_t;
 
 namespace battle
 {
 class Unit;
+struct HealInfo;
 class CUnitState;
 }
 
@@ -53,10 +54,13 @@
 	std::set<SpellID> getSpellsForAttackCasting(TConstBonusListPtr spells, const CStack *defender);
 
 	// damage, drain life & fire shield; returns amount of drained life
-	int64_t applyBattleEffects(const CBattleInfoCallback & battle, BattleAttack & bat, std::shared_ptr<battle::CUnitState> attackerState, FireShieldInfo & fireShield, const CStack * def, int distance, bool secondary);
+	void applyBattleEffects(const CBattleInfoCallback & battle, BattleAttack & bat, std::shared_ptr<battle::CUnitState> attackerState, FireShieldInfo & fireShield, const CStack * def, battle::HealInfo & healInfo, int distance, bool secondary) const;
 
 	void sendGenericKilledLog(const CBattleInfoCallback & battle, const CStack * defender, int32_t killed, bool multiple);
-	void addGenericKilledLog(BattleLogMessage & blm, const CStack * defender, int32_t killed, bool multiple);
+	void addGenericKilledLog(BattleLogMessage & blm, const CStack * defender, int32_t killed, bool multiple) const;
+	void addGenericDamageLog(BattleLogMessage& blm, const std::shared_ptr<battle::CUnitState> &attackerState, int64_t damageDealt) const;
+	void addGenericDrainedLifeLog(BattleLogMessage& blm, const std::shared_ptr<battle::CUnitState> &attackerState, const CStack* defender, int64_t drainedLife) const;
+	void addGenericResurrectedLog(BattleLogMessage& blm, const std::shared_ptr<battle::CUnitState> &attackerState, const CStack* defender, int64_t resurrected) const;
 
 	bool canStackAct(const CBattleInfoCallback & battle, const CStack * stack);
 
diff --color -urN vcmi-1.5.7/server/battles/BattleFlowProcessor.cpp vcmi/server/battles/BattleFlowProcessor.cpp
--- vcmi-1.5.7/server/battles/BattleFlowProcessor.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/server/battles/BattleFlowProcessor.cpp	2024-12-19 15:00:22.992151822 +0100
@@ -16,23 +16,27 @@
 #include "../TurnTimerHandler.h"
 
 #include "../../lib/CStack.h"
-#include "../../lib/GameSettings.h"
+#include "../../lib/IGameSettings.h"
 #include "../../lib/battle/CBattleInfoCallback.h"
 #include "../../lib/battle/IBattleState.h"
+#include "../../lib/entities/building/TownFortifications.h"
 #include "../../lib/gameState/CGameState.h"
 #include "../../lib/mapObjects/CGTownInstance.h"
 #include "../../lib/networkPacks/PacksForClientBattle.h"
 #include "../../lib/spells/BonusCaster.h"
+#include "../../lib/spells/CSpellHandler.h"
 #include "../../lib/spells/ISpellMechanics.h"
 #include "../../lib/spells/ObstacleCasterProxy.h"
 
+#include <vstd/RNG.h>
+
 BattleFlowProcessor::BattleFlowProcessor(BattleProcessor * owner, CGameHandler * newGameHandler)
 	: owner(owner)
 	, gameHandler(newGameHandler)
 {
 }
 
-void BattleFlowProcessor::summonGuardiansHelper(const CBattleInfoCallback & battle, std::vector<BattleHex> & output, const BattleHex & targetPosition, ui8 side, bool targetIsTwoHex) //return hexes for summoning two hex monsters in output, target = unit to guard
+void BattleFlowProcessor::summonGuardiansHelper(const CBattleInfoCallback & battle, std::vector<BattleHex> & output, const BattleHex & targetPosition, BattleSide side, bool targetIsTwoHex) //return hexes for summoning two hex monsters in output, target = unit to guard
 {
 	int x = targetPosition.getX();
 	int y = targetPosition.getY();
@@ -111,13 +115,18 @@
 {
 	const auto * town = battle.battleGetDefendedTown();
 
+	if (!town)
+		return;
+
+	const auto & fortifications = town->fortificationsLevel();
+
 	//Moat should be initialized here, because only here we can use spellcasting
-	if (town && town->fortLevel() >= CGTownInstance::CITADEL)
+	if (fortifications.hasMoat)
 	{
 		const auto * h = battle.battleGetFightingHero(BattleSide::DEFENDER);
 		const auto * actualCaster = h ? static_cast<const spells::Caster*>(h) : nullptr;
 		auto moatCaster = spells::SilentCaster(battle.sideToPlayer(BattleSide::DEFENDER), actualCaster);
-		auto cast = spells::BattleCast(&battle, &moatCaster, spells::Mode::PASSIVE, town->town->moatAbility.toSpell());
+		auto cast = spells::BattleCast(&battle, &moatCaster, spells::Mode::PASSIVE, fortifications.moatSpell.toSpell());
 		auto target = spells::Target();
 		cast.cast(gameHandler->spellEnv, target);
 	}
@@ -126,7 +135,7 @@
 void BattleFlowProcessor::onBattleStarted(const CBattleInfoCallback & battle)
 {
 	tryPlaceMoats(battle);
-	
+
 	gameHandler->turnTimerHandler->onBattleStart(battle.getBattle()->getBattleID());
 
 	if (battle.battleGetTacticDist() == 0)
@@ -139,7 +148,7 @@
 		return;
 
 	std::shared_ptr<const Bonus> summonInfo = stack->getBonus(Selector::type()(BonusType::SUMMON_GUARDIANS));
-	auto accessibility = battle.getAccesibility();
+	auto accessibility = battle.getAccessibility();
 	CreatureID creatureData = summonInfo->subtype.as<CreatureID>();
 	std::vector<BattleHex> targetHexes;
 	const bool targetIsBig = stack->unitType()->isDoubleWide(); //target = creature to guard
@@ -170,7 +179,7 @@
 			pack.battleID = battle.getBattle()->getBattleID();
 			pack.changedStacks.emplace_back(info.id, UnitChanges::EOperation::ADD);
 			info.save(pack.changedStacks.back().data);
-			gameHandler->sendAndApply(&pack);
+			gameHandler->sendAndApply(pack);
 		}
 	}
 
@@ -178,12 +187,12 @@
 	// temporary(?) workaround to force animations to trigger
 	StacksInjured fakeEvent;
 	fakeEvent.battleID = battle.getBattle()->getBattleID();
-	gameHandler->sendAndApply(&fakeEvent);
+	gameHandler->sendAndApply(fakeEvent);
 }
 
 void BattleFlowProcessor::castOpeningSpells(const CBattleInfoCallback & battle)
 {
-	for (int i = 0; i < 2; ++i)
+	for(auto i : {BattleSide::ATTACKER, BattleSide::DEFENDER})
 	{
 		auto h = battle.battleGetFightingHero(i);
 		if (!h)
@@ -232,7 +241,7 @@
 	BattleNextRound bnr;
 	bnr.battleID = battle.getBattle()->getBattleID();
 	logGlobal->debug("Next round starts");
-	gameHandler->sendAndApply(&bnr);
+	gameHandler->sendAndApply(bnr);
 
 	// operate on copy - removing obstacles will invalidate iterator on 'battle' container
 	auto obstacles = battle.battleGetAllObstacles();
@@ -278,7 +287,7 @@
 			bte.val = std::min(lostHealth, stack->valOfBonuses(BonusType::HP_REGENERATION));
 
 		if(bte.val) // anything to heal
-			gameHandler->sendAndApply(&bte);
+			gameHandler->sendAndApply(bte);
 	}
 
 	if(!next || !next->willMove())
@@ -318,14 +327,16 @@
 			removeGhosts.changedStacks.emplace_back(stack->unitId(), UnitChanges::EOperation::REMOVE);
 
 		if(!removeGhosts.changedStacks.empty())
-			gameHandler->sendAndApply(&removeGhosts);
-		
+			gameHandler->sendAndApply(removeGhosts);
+
 		gameHandler->turnTimerHandler->onBattleNextStack(battle.getBattle()->getBattleID(), *next);
 
 		if (!tryMakeAutomaticAction(battle, next))
 		{
-			setActiveStack(battle, next);
-			break;
+			if(next->alive()) {
+				setActiveStack(battle, next);
+				break;
+			}
 		}
 	}
 }
@@ -336,7 +347,7 @@
 	int nextStackMorale = next->moraleVal();
 	if(!next->hadMorale && !next->waited() && nextStackMorale < 0)
 	{
-		auto diceSize = VLC->settings()->getVector(EGameSettings::COMBAT_BAD_MORALE_DICE);
+		auto diceSize = gameHandler->getSettings().getVector(EGameSettings::COMBAT_BAD_MORALE_DICE);
 		size_t diceIndex = std::min<size_t>(diceSize.size(), -nextStackMorale) - 1; // array index, so 0-indexed
 
 		if(diceSize.size() > 0 && gameHandler->getRandomGenerator().nextInt(1, diceSize[diceIndex]) == 1)
@@ -387,20 +398,47 @@
 		attack.side = next->unitSide();
 		attack.stackNumber = next->unitId();
 
-		//TODO: select target by priority
+		// TODO: unify logic with AI?
+		// Find best target using logic similar to H3 AI
+
+		const auto & isBetterTarget = [&battle](const battle::Unit * candidate, const battle::Unit * current)
+		{
+			bool candidateInsideWalls = battle.battleIsInsideWalls(candidate->getPosition());
+			bool currentInsideWalls = battle.battleIsInsideWalls(current->getPosition());
+
+			if (candidateInsideWalls != currentInsideWalls)
+				return candidateInsideWalls > currentInsideWalls;
+
+			// also check for war machines - shooters are more dangerous than war machines, ballista or catapult
+			bool candidateCanShoot = candidate->canShoot() && candidate->unitType()->warMachine == ArtifactID::NONE;
+			bool currentCanShoot = current->canShoot() && current->unitType()->warMachine == ArtifactID::NONE;
+
+			if (candidateCanShoot != currentCanShoot)
+				return candidateCanShoot > currentCanShoot;
+
+			int64_t candidateTargetValue = static_cast<int64_t>(candidate->unitType()->getAIValue() * candidate->getCount());
+			int64_t currentTargetValue = static_cast<int64_t>(current->unitType()->getAIValue() * current->getCount());
+
+			return candidateTargetValue > currentTargetValue;
+		};
 
 		const battle::Unit * target = nullptr;
 
 		for(auto & elem : battle.battleGetAllStacks(true))
 		{
-			if(elem->unitType()->getId() != CreatureID::CATAPULT
-			   && elem->unitOwner() != next->unitOwner()
-			   && elem->isValidTarget()
-			   && battle.battleCanShoot(next, elem->getPosition()))
-			{
-				target = elem;
-				break;
-			}
+			if (elem->unitOwner() == next->unitOwner())
+				continue;
+
+			if (!elem->isValidTarget())
+				continue;
+
+			if (!battle.battleCanShoot(next, elem->getPosition()))
+				continue;
+
+			if (target && !isBetterTarget(elem, target))
+				continue;
+
+			target = elem;
 		}
 
 		if(target == nullptr)
@@ -488,7 +526,7 @@
 		&& next->canMove()
 		&& nextStackMorale > 0)
 	{
-		auto diceSize = VLC->settings()->getVector(EGameSettings::COMBAT_GOOD_MORALE_DICE);
+		auto diceSize = gameHandler->getSettings().getVector(EGameSettings::COMBAT_GOOD_MORALE_DICE);
 		size_t diceIndex = std::min<size_t>(diceSize.size(), nextStackMorale) - 1; // array index, so 0-indexed
 
 		if(diceSize.size() > 0 && gameHandler->getRandomGenerator().nextInt(1, diceSize[diceIndex]) == 1)
@@ -499,7 +537,7 @@
 			bte.effect = vstd::to_underlying(BonusType::MORALE);
 			bte.val = 1;
 			bte.additionalInfo = 0;
-			gameHandler->sendAndApply(&bte); //play animation
+			gameHandler->sendAndApply(bte); //play animation
 			return true;
 		}
 	}
@@ -527,6 +565,20 @@
 	if(battle.battleGetTacticDist() != 0)
 		return;
 
+	// creature will not skip the turn after casting a spell if spell uses canCastWithoutSkip
+	if(ba.actionType == EActionType::MONSTER_SPELL)
+	{
+		assert(activeStack != nullptr);
+		assert(actedStack != nullptr);
+
+		// NOTE: in case of random spellcaster, (e.g. Master Genie) spell has been selected by server and was not present in action received from player
+		if(actedStack->castSpellThisTurn && ba.spell.hasValue() && ba.spell.toSpell()->canCastWithoutSkip())
+		{
+			setActiveStack(battle, actedStack);
+			return;
+		}
+	}
+
 	if (ba.isUnitAction())
 	{
 		assert(activeStack != nullptr);
@@ -569,7 +621,7 @@
 	bsa.battleID = battle.getBattle()->getBattleID();
 	bsa.stack = stack->unitId();
 	bsa.askPlayerInterface = false;
-	gameHandler->sendAndApply(&bsa);
+	gameHandler->sendAndApply(bsa);
 
 	bool ret = owner->makeAutomaticBattleAction(battle, ba);
 	return ret;
@@ -612,7 +664,7 @@
 	BattleObstaclesChanged obsRem;
 	obsRem.battleID = battle.getBattle()->getBattleID();
 	obsRem.changes.emplace_back(obstacle.uniqueID, ObstacleChanges::EOperation::REMOVE);
-	gameHandler->sendAndApply(&obsRem);
+	gameHandler->sendAndApply(obsRem);
 }
 
 void BattleFlowProcessor::stackTurnTrigger(const CBattleInfoCallback & battle, const CStack *st)
@@ -654,7 +706,7 @@
 				ssp.battleID = battle.getBattle()->getBattleID();
 				ssp.which = BattleSetStackProperty::UNBIND;
 				ssp.stackID = st->unitId();
-				gameHandler->sendAndApply(&ssp);
+				gameHandler->sendAndApply(ssp);
 			}
 		}
 
@@ -667,7 +719,7 @@
 				if (bte.val < b->val) //(negative) poison effect increases - update it
 				{
 					bte.effect = vstd::to_underlying(BonusType::POISON);
-					gameHandler->sendAndApply(&bte);
+					gameHandler->sendAndApply(bte);
 				}
 			}
 		}
@@ -683,7 +735,7 @@
 					bte.effect = vstd::to_underlying(BonusType::MANA_DRAIN);
 					bte.val = manaDrained;
 					bte.additionalInfo = opponentHero->id.getNum(); //for sanity
-					gameHandler->sendAndApply(&bte);
+					gameHandler->sendAndApply(bte);
 				}
 			}
 		}
@@ -703,7 +755,7 @@
 				if (gameHandler->getRandomGenerator().nextInt(99) < 10) //fixed 10%
 				{
 					bte.effect = vstd::to_underlying(BonusType::FEAR);
-					gameHandler->sendAndApply(&bte);
+					gameHandler->sendAndApply(bte);
 				}
 			}
 		}
@@ -713,7 +765,7 @@
 			return b->subtype.as<SpellID>() == SpellID::NONE;
 		});
 
-		int side = *battle.playerToSide(st->unitOwner());
+		BattleSide side = battle.playerToSide(st->unitOwner());
 		if(st->canCast() && battle.battleGetEnchanterCounter(side) == 0)
 		{
 			bool cast = false;
@@ -728,8 +780,14 @@
 				});
 				spells::BattleCast parameters(&battle, st, spells::Mode::ENCHANTER, spell);
 				parameters.setSpellLevel(bonus->val);
-				parameters.massive = true;
-				parameters.smart = true;
+
+				auto &levelInfo = spell->getLevelInfo(bonus->val);
+				bool isDamageSpell = spell->isDamage() || spell->isOffensive();
+				if (!isDamageSpell || levelInfo.smartTarget || !levelInfo.range.empty())
+				{
+					parameters.massive = true;
+					parameters.smart = true;
+				}
 				//todo: recheck effect level
 				if(parameters.castIfPossible(gameHandler->spellEnv, spells::Target(1, spells::Destination())))
 				{
@@ -742,7 +800,7 @@
 					ssp.absolute = false;
 					ssp.val = cooldown;
 					ssp.stackID = st->unitId();
-					gameHandler->sendAndApply(&ssp);
+					gameHandler->sendAndApply(ssp);
 				}
 			}
 		}
@@ -756,5 +814,5 @@
 	BattleSetActiveStack sas;
 	sas.battleID = battle.getBattle()->getBattleID();
 	sas.stack = stack->unitId();
-	gameHandler->sendAndApply(&sas);
+	gameHandler->sendAndApply(sas);
 }
diff --color -urN vcmi-1.5.7/server/battles/BattleFlowProcessor.h vcmi/server/battles/BattleFlowProcessor.h
--- vcmi-1.5.7/server/battles/BattleFlowProcessor.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/server/battles/BattleFlowProcessor.h	2024-12-19 15:00:22.992151822 +0100
@@ -9,6 +9,8 @@
  */
 #pragma once
 
+#include "../lib/battle/BattleSide.h"
+
 VCMI_LIB_NAMESPACE_BEGIN
 class CStack;
 struct BattleHex;
@@ -35,7 +37,7 @@
 	bool rollGoodMorale(const CBattleInfoCallback & battle, const CStack * stack);
 	bool tryMakeAutomaticAction(const CBattleInfoCallback & battle, const CStack * stack);
 
-	void summonGuardiansHelper(const CBattleInfoCallback & battle, std::vector<BattleHex> & output, const BattleHex & targetPosition, ui8 side, bool targetIsTwoHex);
+	void summonGuardiansHelper(const CBattleInfoCallback & battle, std::vector<BattleHex> & output, const BattleHex & targetPosition, BattleSide side, bool targetIsTwoHex);
 	void trySummonGuardians(const CBattleInfoCallback & battle, const CStack * stack);
 	void tryPlaceMoats(const CBattleInfoCallback & battle);
 	void castOpeningSpells(const CBattleInfoCallback & battle);
diff --color -urN vcmi-1.5.7/server/battles/BattleProcessor.cpp vcmi/server/battles/BattleProcessor.cpp
--- vcmi-1.5.7/server/battles/BattleProcessor.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/server/battles/BattleProcessor.cpp	2024-12-19 15:00:22.992151822 +0100
@@ -23,13 +23,17 @@
 #include "../../lib/battle/CBattleInfoCallback.h"
 #include "../../lib/battle/CObstacleInstance.h"
 #include "../../lib/battle/BattleInfo.h"
+#include "../../lib/battle/BattleLayout.h"
+#include "../../lib/entities/building/TownFortifications.h"
 #include "../../lib/gameState/CGameState.h"
 #include "../../lib/mapping/CMap.h"
 #include "../../lib/mapObjects/CGHeroInstance.h"
+#include "../../lib/mapObjects/CGTownInstance.h"
 #include "../../lib/modding/IdentifierStorage.h"
 #include "../../lib/networkPacks/PacksForClient.h"
 #include "../../lib/networkPacks/PacksForClientBattle.h"
 #include "../../lib/CPlayerState.h"
+#include <vstd/RNG.h>
 
 BattleProcessor::BattleProcessor(CGameHandler * gameHandler)
 	: gameHandler(gameHandler)
@@ -48,67 +52,59 @@
 	pb.player = player;
 	pb.reason = PlayerBlocked::UPCOMING_BATTLE;
 	pb.startOrEnd = PlayerBlocked::BLOCKADE_STARTED;
-	gameHandler->sendAndApply(&pb);
+	gameHandler->sendAndApply(pb);
 }
 
-void BattleProcessor::restartBattlePrimary(const BattleID & battleID, const CArmedInstance *army1, const CArmedInstance *army2, int3 tile,
-								const CGHeroInstance *hero1, const CGHeroInstance *hero2, bool creatureBank,
-								const CGTownInstance *town)
+void BattleProcessor::restartBattle(const BattleID & battleID, const CArmedInstance *army1, const CArmedInstance *army2, int3 tile,
+								const CGHeroInstance *hero1, const CGHeroInstance *hero2, const BattleLayout & layout, const CGTownInstance *town)
 {
 	auto battle = gameHandler->gameState()->getBattle(battleID);
 
-	auto lastBattleQuery = std::dynamic_pointer_cast<CBattleQuery>(gameHandler->queries->topQuery(battle->sides[0].color));
+	auto lastBattleQuery = std::dynamic_pointer_cast<CBattleQuery>(gameHandler->queries->topQuery(battle->getSide(BattleSide::ATTACKER).color));
 	if(!lastBattleQuery)
-		lastBattleQuery = std::dynamic_pointer_cast<CBattleQuery>(gameHandler->queries->topQuery(battle->sides[1].color));
+		lastBattleQuery = std::dynamic_pointer_cast<CBattleQuery>(gameHandler->queries->topQuery(battle->getSide(BattleSide::DEFENDER).color));
 
 	assert(lastBattleQuery);
 
 	//existing battle query for retying auto-combat
 	if(lastBattleQuery)
 	{
-		const CGHeroInstance*heroes[2];
-		heroes[0] = hero1;
-		heroes[1] = hero2;
+		BattleSideArray<const CGHeroInstance*> heroes{hero1, hero2};
 
-		for(int i : {0, 1})
+		for(auto i : {BattleSide::ATTACKER, BattleSide::DEFENDER})
 		{
 			if(heroes[i])
 			{
 				SetMana restoreInitialMana;
 				restoreInitialMana.val = lastBattleQuery->initialHeroMana[i];
 				restoreInitialMana.hid = heroes[i]->id;
-				gameHandler->sendAndApply(&restoreInitialMana);
+				gameHandler->sendAndApply(restoreInitialMana);
 			}
 		}
 
 		lastBattleQuery->result = std::nullopt;
 
-		assert(lastBattleQuery->belligerents[0] == battle->sides[0].armyObject);
-		assert(lastBattleQuery->belligerents[1] == battle->sides[1].armyObject);
+		assert(lastBattleQuery->belligerents[BattleSide::ATTACKER] == battle->getSide(BattleSide::ATTACKER).armyObject);
+		assert(lastBattleQuery->belligerents[BattleSide::DEFENDER] == battle->getSide(BattleSide::DEFENDER).armyObject);
 	}
 
 	BattleCancelled bc;
 	bc.battleID = battleID;
-	gameHandler->sendAndApply(&bc);
+	gameHandler->sendAndApply(bc);
 
-	startBattlePrimary(army1, army2, tile, hero1, hero2, creatureBank, town);
+	startBattle(army1, army2, tile, hero1, hero2, layout, town);
 }
 
-void BattleProcessor::startBattlePrimary(const CArmedInstance *army1, const CArmedInstance *army2, int3 tile,
-								const CGHeroInstance *hero1, const CGHeroInstance *hero2, bool creatureBank,
-								const CGTownInstance *town)
+void BattleProcessor::startBattle(const CArmedInstance *army1, const CArmedInstance *army2, int3 tile,
+								const CGHeroInstance *hero1, const CGHeroInstance *hero2, const BattleLayout & layout, const CGTownInstance *town)
 {
 	assert(gameHandler->gameState()->getBattle(army1->getOwner()) == nullptr);
 	assert(gameHandler->gameState()->getBattle(army2->getOwner()) == nullptr);
 
-	const CArmedInstance *armies[2];
-	armies[0] = army1;
-	armies[1] = army2;
-	const CGHeroInstance*heroes[2];
-	heroes[0] = hero1;
-	heroes[1] = hero2;
+	BattleSideArray<const CArmedInstance *> armies{army1, army2};
+	BattleSideArray<const CGHeroInstance*>heroes{hero1, hero2};
 
-	auto battleID = setupBattle(tile, armies, heroes, creatureBank, town); //initializes stacks, places creatures on battlefield, blocks and informs player interfaces
+	auto battleID = setupBattle(tile, armies, heroes, layout, town); //initializes stacks, places creatures on battlefield, blocks and informs player interfaces
 
 	const auto * battle = gameHandler->gameState()->getBattle(battleID);
 	assert(battle);
@@ -122,13 +118,13 @@
 			GiveBonus giveBonus(GiveBonus::ETarget::OBJECT);
 			giveBonus.id = hero1->id;
 			giveBonus.bonus = bonus;
-			gameHandler->sendAndApply(&giveBonus);
+			gameHandler->sendAndApply(giveBonus);
 		}
 	}
 
-	auto lastBattleQuery = std::dynamic_pointer_cast<CBattleQuery>(gameHandler->queries->topQuery(battle->sides[0].color));
+	auto lastBattleQuery = std::dynamic_pointer_cast<CBattleQuery>(gameHandler->queries->topQuery(battle->getSide(BattleSide::ATTACKER).color));
 	if(!lastBattleQuery)
-		lastBattleQuery = std::dynamic_pointer_cast<CBattleQuery>(gameHandler->queries->topQuery(battle->sides[1].color));
+		lastBattleQuery = std::dynamic_pointer_cast<CBattleQuery>(gameHandler->queries->topQuery(battle->getSide(BattleSide::DEFENDER).color));
 
 	if (lastBattleQuery)
 	{
@@ -139,7 +135,7 @@
 		auto newBattleQuery = std::make_shared<CBattleQuery>(gameHandler, battle);
 
 		// store initial mana to reset if battle has been restarted
-		for(int i : {0, 1})
+		for(auto i : {BattleSide::ATTACKER, BattleSide::DEFENDER})
 			if(heroes[i])
 				newBattleQuery->initialHeroMana[i] = heroes[i]->mana;
 
@@ -149,48 +145,52 @@
 	flowProcessor->onBattleStarted(*battle);
 }
 
-void BattleProcessor::startBattleI(const CArmedInstance *army1, const CArmedInstance *army2, int3 tile, bool creatureBank)
+void BattleProcessor::startBattle(const CArmedInstance *army1, const CArmedInstance *army2)
 {
-	startBattlePrimary(army1, army2, tile,
-		army1->ID == Obj::HERO ? static_cast<const CGHeroInstance*>(army1) : nullptr,
-		army2->ID == Obj::HERO ? static_cast<const CGHeroInstance*>(army2) : nullptr,
-		creatureBank);
+	startBattle(army1, army2, army2->visitablePos(),
+		army1->ID == Obj::HERO ? dynamic_cast<const CGHeroInstance*>(army1) : nullptr,
+		army2->ID == Obj::HERO ? dynamic_cast<const CGHeroInstance*>(army2) : nullptr,
+		BattleLayout::createDefaultLayout(gameHandler, army1, army2),
+		nullptr);
 }
 
-void BattleProcessor::startBattleI(const CArmedInstance *army1, const CArmedInstance *army2, bool creatureBank)
-{
-	startBattleI(army1, army2, army2->visitablePos(), creatureBank);
-}
-
-BattleID BattleProcessor::setupBattle(int3 tile, const CArmedInstance *armies[2], const CGHeroInstance *heroes[2], bool creatureBank, const CGTownInstance *town)
+BattleID BattleProcessor::setupBattle(int3 tile, BattleSideArray<const CArmedInstance *> armies, BattleSideArray<const CGHeroInstance *> heroes, const BattleLayout & layout, const CGTownInstance *town)
 {
 	const auto & t = *gameHandler->getTile(tile);
-	TerrainId terrain = t.terType->getId();
-	if (gameHandler->gameState()->map->isCoastalTile(tile)) //coastal tile is always ground
+	TerrainId terrain = t.getTerrainID();
+	if (town)
+		terrain = town->getNativeTerrain();
+	else if (gameHandler->gameState()->map->isCoastalTile(tile)) //coastal tile is always ground
 		terrain = ETerrainId::SAND;
 
-	BattleField terType = gameHandler->gameState()->battleGetBattlefieldType(tile, gameHandler->getRandomGenerator());
-	if (heroes[0] && heroes[0]->boat && heroes[1] && heroes[1]->boat)
-		terType = BattleField(*VLC->identifiers()->getIdentifier("core", "battlefield.ship_to_ship"));
+	BattleField battlefieldType = gameHandler->gameState()->battleGetBattlefieldType(tile, gameHandler->getRandomGenerator());
+
+	if (town)
+	{
+		const TerrainType* terrainData = VLC->terrainTypeHandler->getById(terrain);
+		battlefieldType = BattleField(*RandomGeneratorUtil::nextItem(terrainData->battleFields, gameHandler->getRandomGenerator()));
+	}
+	else if (heroes[BattleSide::ATTACKER] && heroes[BattleSide::ATTACKER]->boat && heroes[BattleSide::DEFENDER] && heroes[BattleSide::DEFENDER]->boat)
+		battlefieldType = BattleField(*VLC->identifiers()->getIdentifier("core", "battlefield.ship_to_ship"));
 
 	//send info about battles
 	BattleStart bs;
-	bs.info = BattleInfo::setupBattle(tile, terrain, terType, armies, heroes, creatureBank, town);
+	bs.info = BattleInfo::setupBattle(tile, terrain, battlefieldType, armies, heroes, layout, town);
 	bs.battleID = gameHandler->gameState()->nextBattleID;
 
-	engageIntoBattle(bs.info->sides[0].color);
-	engageIntoBattle(bs.info->sides[1].color);
+	engageIntoBattle(bs.info->getSide(BattleSide::ATTACKER).color);
+	engageIntoBattle(bs.info->getSide(BattleSide::DEFENDER).color);
 
-	auto lastBattleQuery = std::dynamic_pointer_cast<CBattleQuery>(gameHandler->queries->topQuery(bs.info->sides[0].color));
+	auto lastBattleQuery = std::dynamic_pointer_cast<CBattleQuery>(gameHandler->queries->topQuery(bs.info->getSide(BattleSide::ATTACKER).color));
 	if(!lastBattleQuery)
-		lastBattleQuery = std::dynamic_pointer_cast<CBattleQuery>(gameHandler->queries->topQuery(bs.info->sides[1].color));
-	bool isDefenderHuman = bs.info->sides[1].color.isValidPlayer() && gameHandler->getPlayerState(bs.info->sides[1].color)->isHuman();
-	bool isAttackerHuman = gameHandler->getPlayerState(bs.info->sides[0].color)->isHuman();
+		lastBattleQuery = std::dynamic_pointer_cast<CBattleQuery>(gameHandler->queries->topQuery(bs.info->getSide(BattleSide::DEFENDER).color));
+	bool isDefenderHuman = bs.info->getSide(BattleSide::DEFENDER).color.isValidPlayer() && gameHandler->getPlayerState(bs.info->getSide(BattleSide::DEFENDER).color)->isHuman();
+	bool isAttackerHuman = gameHandler->getPlayerState(bs.info->getSide(BattleSide::ATTACKER).color)->isHuman();
 
 	bool onlyOnePlayerHuman = isDefenderHuman != isAttackerHuman;
 	bs.info->replayAllowed = lastBattleQuery == nullptr && onlyOnePlayerHuman;
 
-	gameHandler->sendAndApply(&bs);
+	gameHandler->sendAndApply(bs);
 
 	return bs.battleID;
 }
@@ -198,7 +198,7 @@
 bool BattleProcessor::checkBattleStateChanges(const CBattleInfoCallback & battle)
 {
 	//check if drawbridge state need to be changes
-	if (battle.battleGetSiegeLevel() > 0)
+	if (battle.battleGetFortifications().wallsHealth > 0)
 		updateGateState(battle);
 
 	if (resultProcessor->battleIsEnding(battle))
@@ -268,7 +268,7 @@
 	}
 
 	if (db.state != battle.battleGetGateState())
-		gameHandler->sendAndApply(&db);
+		gameHandler->sendAndApply(db);
 }
 
 bool BattleProcessor::makePlayerBattleAction(const BattleID & battleID, PlayerColor player, const BattleAction &ba)
@@ -284,7 +284,7 @@
 	return result;
 }
 
-void BattleProcessor::setBattleResult(const CBattleInfoCallback & battle, EBattleResult resultType, int victoriusSide)
+void BattleProcessor::setBattleResult(const CBattleInfoCallback & battle, EBattleResult resultType, BattleSide victoriusSide)
 {
 	resultProcessor->setBattleResult(battle, resultType, victoriusSide);
 	resultProcessor->endBattle(battle);
diff --color -urN vcmi-1.5.7/server/battles/BattleProcessor.h vcmi/server/battles/BattleProcessor.h
--- vcmi-1.5.7/server/battles/BattleProcessor.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/server/battles/BattleProcessor.h	2024-12-19 15:00:22.992151822 +0100
@@ -10,6 +10,7 @@
 #pragma once
 
 #include "../../lib/GameConstants.h"
+#include "../../lib/battle/BattleSide.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 class CGHeroInstance;
@@ -19,6 +20,7 @@
 class int3;
 class CBattleInfoCallback;
 struct BattleResult;
+struct BattleLayout;
 class BattleID;
 VCMI_LIB_NAMESPACE_END
 
@@ -44,24 +46,22 @@
 	void engageIntoBattle(PlayerColor player);
 
 	bool checkBattleStateChanges(const CBattleInfoCallback & battle);
-	BattleID setupBattle(int3 tile, const CArmedInstance *armies[2], const CGHeroInstance *heroes[2], bool creatureBank, const CGTownInstance *town);
+	BattleID setupBattle(int3 tile, BattleSideArray<const CArmedInstance *> armies, BattleSideArray<const CGHeroInstance *> heroes, const BattleLayout & layout, const CGTownInstance *town);
 
 	bool makeAutomaticBattleAction(const CBattleInfoCallback & battle, const BattleAction & ba);
 
-	void setBattleResult(const CBattleInfoCallback & battle, EBattleResult resultType, int victoriusSide);
+	void setBattleResult(const CBattleInfoCallback & battle, EBattleResult resultType, BattleSide victoriusSide);
 
 public:
 	explicit BattleProcessor(CGameHandler * gameHandler);
 	~BattleProcessor();
 
 	/// Starts battle with specified parameters
-	void startBattlePrimary(const CArmedInstance *army1, const CArmedInstance *army2, int3 tile, const CGHeroInstance *hero1, const CGHeroInstance *hero2, bool creatureBank = false, const CGTownInstance *town = nullptr);
-	/// Starts battle between two armies (which can also be heroes) at specified tile
-	void startBattleI(const CArmedInstance *army1, const CArmedInstance *army2, int3 tile, bool creatureBank = false);
+	void startBattle(const CArmedInstance *army1, const CArmedInstance *army2, int3 tile, const CGHeroInstance *hero1, const CGHeroInstance *hero2, const BattleLayout & layout, const CGTownInstance *town);
 	/// Starts battle between two armies (which can also be heroes) at position of 2nd object
-	void startBattleI(const CArmedInstance *army1, const CArmedInstance *army2, bool creatureBank = false);
+	void startBattle(const CArmedInstance *army1, const CArmedInstance *army2);
 	/// Restart ongoing battle and end previous battle
-	void restartBattlePrimary(const BattleID & battleID, const CArmedInstance *army1, const CArmedInstance *army2, int3 tile, const CGHeroInstance *hero1, const CGHeroInstance *hero2, bool creatureBank = false, const CGTownInstance *town = nullptr);
+	void restartBattle(const BattleID & battleID, const CArmedInstance *army1, const CArmedInstance *army2, int3 tile, const CGHeroInstance *hero1, const CGHeroInstance *hero2, const BattleLayout & layout, const CGTownInstance *town);
 
 	/// Processing of incoming battle action netpack
 	bool makePlayerBattleAction(const BattleID & battleID, PlayerColor player, const BattleAction & ba);
diff --color -urN vcmi-1.5.7/server/battles/BattleResultProcessor.cpp vcmi/server/battles/BattleResultProcessor.cpp
--- vcmi-1.5.7/server/battles/BattleResultProcessor.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/server/battles/BattleResultProcessor.cpp	2024-12-19 15:00:22.993151863 +0100
@@ -19,7 +19,7 @@
 #include "../../lib/ArtifactUtils.h"
 #include "../../lib/CStack.h"
 #include "../../lib/CPlayerState.h"
-#include "../../lib/GameSettings.h"
+#include "../../lib/IGameSettings.h"
 #include "../../lib/battle/CBattleInfoCallback.h"
 #include "../../lib/battle/IBattleState.h"
 #include "../../lib/battle/SideInBattle.h"
@@ -27,16 +27,17 @@
 #include "../../lib/mapObjects/CGTownInstance.h"
 #include "../../lib/networkPacks/PacksForClientBattle.h"
 #include "../../lib/networkPacks/PacksForClient.h"
-#include "../../lib/serializer/Cast.h"
 #include "../../lib/spells/CSpellHandler.h"
 
+#include <vstd/RNG.h>
+
 BattleResultProcessor::BattleResultProcessor(BattleProcessor * owner, CGameHandler * newGameHandler)
 //	: owner(owner)
 	: gameHandler(newGameHandler)
 {
 }
 
-CasualtiesAfterBattle::CasualtiesAfterBattle(const CBattleInfoCallback & battle, uint8_t sideInBattle):
+CasualtiesAfterBattle::CasualtiesAfterBattle(const CBattleInfoCallback & battle, BattleSide sideInBattle):
 	army(battle.battleGetArmyObject(sideInBattle))
 {
 	heroWithDeadCommander = ObjectInstanceID();
@@ -79,7 +80,7 @@
 			else if(warMachine != ArtifactID::CATAPULT && st->getCount() <= 0)
 			{
 				logGlobal->debug("War machine has been destroyed");
-				auto hero = dynamic_ptr_cast<CGHeroInstance> (army);
+				auto hero = dynamic_cast<const CGHeroInstance*> (army);
 				if (hero)
 					removedWarMachines.push_back (ArtifactLocation(hero->id, hero->getArtPos(warMachine, true)));
 				else
@@ -177,7 +178,7 @@
 		scp.heroid = heroWithDeadCommander;
 		scp.which = SetCommanderProperty::ALIVE;
 		scp.amount = 0;
-		gh->sendAndApply(&scp);
+		gh->sendAndApply(scp);
 	}
 }
 
@@ -203,25 +204,18 @@
 	this->remainingBattleQueriesCount = remainingBattleQueriesCount;
 }
 
-//FinishingBattleHelper::FinishingBattleHelper()
-//{
-//	winnerHero = loserHero = nullptr;
-//	winnerSide = 0;
-//	remainingBattleQueriesCount = 0;
-//}
-
 void BattleResultProcessor::endBattle(const CBattleInfoCallback & battle)
 {
-	auto const & giveExp = [](BattleResult &r)
+	auto const & giveExp = [&battle](BattleResult &r)
 	{
-		if (r.winner > 1)
+		if (r.winner == BattleSide::NONE)
 		{
 			// draw
 			return;
 		}
-		r.exp[0] = 0;
-		r.exp[1] = 0;
-		for (auto i = r.casualties[!r.winner].begin(); i!=r.casualties[!r.winner].end(); i++)
+		r.exp[BattleSide::ATTACKER] = 0;
+		r.exp[BattleSide::DEFENDER] = 0;
+		for (auto i = r.casualties[battle.otherSide(r.winner)].begin(); i!=r.casualties[battle.otherSide(r.winner)].end(); i++)
 		{
 			r.exp[r.winner] += VLC->creh->objects.at(i->first)->valOfBonuses(BonusType::STACK_HEALTH) * i->second;
 		}
@@ -239,9 +233,9 @@
 	if (battleResult->result == EBattleResult::NORMAL) // give 500 exp for defeating hero, unless he escaped
 	{
 		if(heroAttacker)
-			battleResult->exp[1] += 500;
+			battleResult->exp[BattleSide::DEFENDER] += 500;
 		if(heroDefender)
-			battleResult->exp[0] += 500;
+			battleResult->exp[BattleSide::ATTACKER] += 500;
 	}
 
 	// Give 500 exp to winner if a town was conquered during the battle
@@ -250,17 +244,17 @@
 		battleResult->exp[BattleSide::ATTACKER] += 500;
 
 	if(heroAttacker)
-		battleResult->exp[0] = heroAttacker->calculateXp(battleResult->exp[0]);//scholar skill
+		battleResult->exp[BattleSide::ATTACKER] = heroAttacker->calculateXp(battleResult->exp[BattleSide::ATTACKER]);//scholar skill
 	if(heroDefender)
-		battleResult->exp[1] = heroDefender->calculateXp(battleResult->exp[1]);
+		battleResult->exp[BattleSide::DEFENDER] = heroDefender->calculateXp(battleResult->exp[BattleSide::DEFENDER]);
 
-	auto battleQuery = std::dynamic_pointer_cast<CBattleQuery>(gameHandler->queries->topQuery(battle.sideToPlayer(0)));
+	auto battleQuery = std::dynamic_pointer_cast<CBattleQuery>(gameHandler->queries->topQuery(battle.sideToPlayer(BattleSide::ATTACKER)));
 	if(!battleQuery)
-		battleQuery = std::dynamic_pointer_cast<CBattleQuery>(gameHandler->queries->topQuery(battle.sideToPlayer(1)));
+		battleQuery = std::dynamic_pointer_cast<CBattleQuery>(gameHandler->queries->topQuery(battle.sideToPlayer(BattleSide::DEFENDER)));
 	if (!battleQuery)
 	{
 		logGlobal->error("Cannot find battle query!");
-		gameHandler->complain("Player " + boost::lexical_cast<std::string>(battle.sideToPlayer(0)) + " has no battle query at the top!");
+		gameHandler->complain("Player " + boost::lexical_cast<std::string>(battle.sideToPlayer(BattleSide::ATTACKER)) + " has no battle query at the top!");
 		return;
 	}
 
@@ -297,7 +291,7 @@
 	}
 
 	gameHandler->turnTimerHandler->onBattleEnd(battle.getBattle()->getBattleID());
-	gameHandler->sendAndApply(battleResult);
+	gameHandler->sendAndApply(*battleResult);
 
 	if (battleResult->queryID == QueryID::NONE)
 		endBattleConfirm(battle);
@@ -305,9 +299,9 @@
 
 void BattleResultProcessor::endBattleConfirm(const CBattleInfoCallback & battle)
 {
-	auto battleQuery = std::dynamic_pointer_cast<CBattleQuery>(gameHandler->queries->topQuery(battle.sideToPlayer(0)));
+	auto battleQuery = std::dynamic_pointer_cast<CBattleQuery>(gameHandler->queries->topQuery(battle.sideToPlayer(BattleSide::ATTACKER)));
 	if(!battleQuery)
-		battleQuery = std::dynamic_pointer_cast<CBattleQuery>(gameHandler->queries->topQuery(battle.sideToPlayer(1)));
+		battleQuery = std::dynamic_pointer_cast<CBattleQuery>(gameHandler->queries->topQuery(battle.sideToPlayer(BattleSide::DEFENDER)));
 	if(!battleQuery)
 	{
 		logGlobal->trace("No battle query, battle end was confirmed by another player");
@@ -323,198 +317,215 @@
 	CasualtiesAfterBattle cab1(battle, BattleSide::ATTACKER);
 	CasualtiesAfterBattle cab2(battle, BattleSide::DEFENDER);
 
-	ChangeSpells cs; //for Eagle Eye
+	cab1.updateArmy(gameHandler);
+	cab2.updateArmy(gameHandler); //take casualties after battle is deleted
 
+	if(battleResult->winner == BattleSide::DEFENDER
+	   && finishingBattle->winnerHero
+	   && finishingBattle->winnerHero->visitedTown
+	   && !finishingBattle->winnerHero->inTownGarrison
+	   && finishingBattle->winnerHero->visitedTown->garrisonHero == finishingBattle->winnerHero)
+	{
+		gameHandler->swapGarrisonOnSiege(finishingBattle->winnerHero->visitedTown->id); //return defending visitor from garrison to its rightful place
+	}
+	//give exp
+	if(!finishingBattle->isDraw() && battleResult->exp[finishingBattle->winnerSide] && finishingBattle->winnerHero)
+		gameHandler->giveExperience(finishingBattle->winnerHero, battleResult->exp[finishingBattle->winnerSide]);
+
+	// Eagle Eye handling
 	if(!finishingBattle->isDraw() && finishingBattle->winnerHero)
 	{
-		if (int eagleEyeLevel = finishingBattle->winnerHero->valOfBonuses(BonusType::LEARN_BATTLE_SPELL_LEVEL_LIMIT))
+		ChangeSpells spells;
+
+		if(auto eagleEyeLevel = finishingBattle->winnerHero->valOfBonuses(BonusType::LEARN_BATTLE_SPELL_LEVEL_LIMIT))
 		{
-			double eagleEyeChance = finishingBattle->winnerHero->valOfBonuses(BonusType::LEARN_BATTLE_SPELL_CHANCE);
+			auto eagleEyeChance = finishingBattle->winnerHero->valOfBonuses(BonusType::LEARN_BATTLE_SPELL_CHANCE);
 			for(auto & spellId : battle.getBattle()->getUsedSpells(battle.otherSide(battleResult->winner)))
 			{
 				auto spell = spellId.toEntity(VLC->spells());
-				if(spell && spell->getLevel() <= eagleEyeLevel && !finishingBattle->winnerHero->spellbookContainsSpell(spell->getId()) && gameHandler->getRandomGenerator().nextInt(99) < eagleEyeChance)
-					cs.spells.insert(spell->getId());
+				if(spell
+					&& spell->getLevel() <= eagleEyeLevel
+					&& !finishingBattle->winnerHero->spellbookContainsSpell(spell->getId())
+					&& gameHandler->getRandomGenerator().nextInt(99) < eagleEyeChance)
+				{
+					spells.spells.insert(spell->getId());
+				}
 			}
 		}
-	}
-	std::vector<const CArtifactInstance *> arts; //display them in window
 
+		if(!spells.spells.empty())
+		{
+			spells.learn = 1;
+			spells.hid = finishingBattle->winnerHero->id;
+
+			InfoWindow iw;
+			iw.player = finishingBattle->winnerHero->tempOwner;
+			iw.text.appendLocalString(EMetaText::GENERAL_TXT, 221); //Through eagle-eyed observation, %s is able to learn %s
+			iw.text.replaceRawString(finishingBattle->winnerHero->getNameTranslated());
+
+			std::ostringstream names;
+			for(int i = 0; i < spells.spells.size(); i++)
+			{
+				names << "%s";
+				if(i < spells.spells.size() - 2)
+					names << ", ";
+				else if(i < spells.spells.size() - 1)
+					names << "%s";
+			}
+			names << ".";
+
+			iw.text.replaceRawString(names.str());
+
+			auto it = spells.spells.begin();
+			for(int i = 0; i < spells.spells.size(); i++, it++)
+			{
+				iw.text.replaceName(*it);
+				if(i == spells.spells.size() - 2) //we just added pre-last name
+					iw.text.replaceLocalString(EMetaText::GENERAL_TXT, 141); // " and "
+				iw.components.emplace_back(ComponentType::SPELL, *it);
+			}
+			gameHandler->sendAndApply(iw);
+			gameHandler->sendAndApply(spells);
+		}
+	}
+	// Artifacts handling
 	if(result == EBattleResult::NORMAL && !finishingBattle->isDraw() && finishingBattle->winnerHero)
 	{
-		auto sendMoveArtifact = [&](const CArtifactInstance *art, MoveArtifact *ma)
+		std::vector<const CArtifactInstance*> arts; // display them in window
+		CArtifactFittingSet artFittingSet(*finishingBattle->winnerHero);
+
+		const auto addArtifactToTransfer = [&artFittingSet, &arts](BulkMoveArtifacts & pack, const ArtifactPosition & srcSlot, const CArtifactInstance * art)
 		{
-			const auto slot = ArtifactUtils::getArtAnyPosition(finishingBattle->winnerHero, art->getTypeId());
-			if(slot != ArtifactPosition::PRE_FIRST)
-			{
-				arts.push_back(art);
-				ma->dst = ArtifactLocation(finishingBattle->winnerHero->id, slot);
-				if(ArtifactUtils::isSlotBackpack(slot))
-					ma->askAssemble = false;
-				gameHandler->sendAndApply(ma);
+			assert(art);
+			const auto dstSlot = ArtifactUtils::getArtAnyPosition(&artFittingSet, art->getTypeId());
+			if(dstSlot != ArtifactPosition::PRE_FIRST)
+			{
+				pack.artsPack0.emplace_back(BulkMoveArtifacts::LinkedSlots(srcSlot, dstSlot));
+				if(ArtifactUtils::isSlotEquipment(dstSlot))
+					pack.artsPack0.back().askAssemble = true;
+				arts.emplace_back(art);
+				artFittingSet.putArtifact(dstSlot, const_cast<CArtifactInstance*>(art));
 			}
 		};
+		const auto sendArtifacts = [this](BulkMoveArtifacts & bma)
+		{
+			if(!bma.artsPack0.empty())
+				gameHandler->sendAndApply(bma);
+		};
 
-		if (finishingBattle->loserHero)
+		BulkMoveArtifacts packHero(finishingBattle->winnerHero->getOwner(), ObjectInstanceID::NONE, finishingBattle->winnerHero->id, false);
+		if(finishingBattle->loserHero)
 		{
-			//TODO: wrap it into a function, somehow (std::variant -_-)
-			auto artifactsWorn = finishingBattle->loserHero->artifactsWorn;
-			for (auto artSlot : artifactsWorn)
-			{
-				MoveArtifact ma;
-				ma.src = ArtifactLocation(finishingBattle->loserHero->id, artSlot.first);
-				const CArtifactInstance * art = finishingBattle->loserHero->getArt(artSlot.first);
-				if (art && !art->artType->isBig() &&
-					art->artType->getId() != ArtifactID::SPELLBOOK)
-						// don't move war machines or locked arts (spellbook)
-				{
-					sendMoveArtifact(art, &ma);
-				}
-			}
-			for(int slotNumber = finishingBattle->loserHero->artifactsInBackpack.size() - 1; slotNumber >= 0; slotNumber--)
+			packHero.srcArtHolder = finishingBattle->loserHero->id;
+			for(const auto & slot : ArtifactUtils::commonWornSlots())
 			{
-				//we assume that no big artifacts can be found
-				MoveArtifact ma;
-				ma.src = ArtifactLocation(finishingBattle->loserHero->id,
-					ArtifactPosition(ArtifactPosition::BACKPACK_START + slotNumber)); //backpack automatically shifts arts to beginning
-				const CArtifactInstance * art = finishingBattle->loserHero->getArt(ArtifactPosition::BACKPACK_START + slotNumber);
-				if (art->artType->getId() != ArtifactID::GRAIL) //grail may not be won
+				if(const auto artSlot = finishingBattle->loserHero->artifactsWorn.find(slot);
+					artSlot != finishingBattle->loserHero->artifactsWorn.end() && ArtifactUtils::isArtRemovable(*artSlot))
 				{
-					sendMoveArtifact(art, &ma);
+					addArtifactToTransfer(packHero, artSlot->first, artSlot->second.getArt());
 				}
 			}
-			if (finishingBattle->loserHero->commander) //TODO: what if commanders belong to no hero?
+			for(const auto & artSlot : finishingBattle->loserHero->artifactsInBackpack)
 			{
-				artifactsWorn = finishingBattle->loserHero->commander->artifactsWorn;
-				for (auto artSlot : artifactsWorn)
-				{
-					MoveArtifact ma;
-					ma.src = ArtifactLocation(finishingBattle->loserHero->id, artSlot.first);
-					ma.src.creature = finishingBattle->loserHero->findStack(finishingBattle->loserHero->commander);
-					const auto art = finishingBattle->loserHero->commander->getArt(artSlot.first);
-					if (art && !art->artType->isBig())
-					{
-						sendMoveArtifact(art, &ma);
-					}
-				}
+				if(const auto art = artSlot.getArt(); art->getTypeId() != ArtifactID::GRAIL)
+					addArtifactToTransfer(packHero, finishingBattle->loserHero->getArtPos(art), art);
 			}
-		}
-
-		auto loser = battle.otherSide(battleResult->winner);
 
-		for (auto armySlot : battle.battleGetArmyObject(loser)->stacks)
-		{
-			auto artifactsWorn = armySlot.second->artifactsWorn;
-			for(const auto & artSlot : artifactsWorn)
+			if(finishingBattle->loserHero->commander)
 			{
-				MoveArtifact ma;
-				ma.src = ArtifactLocation(finishingBattle->loserHero->id, artSlot.first);
-				ma.src.creature = finishingBattle->loserHero->findStack(finishingBattle->loserHero->commander);
-				const auto art = finishingBattle->loserHero->commander->getArt(artSlot.first);
-				if (art && !art->artType->isBig())
-				{
-					sendMoveArtifact(art, &ma);
-				}
+				BulkMoveArtifacts packCommander(finishingBattle->winnerHero->getOwner(), finishingBattle->loserHero->id, finishingBattle->winnerHero->id, false);
+				packCommander.srcCreature = finishingBattle->loserHero->findStack(finishingBattle->loserHero->commander);
+				for(const auto & artSlot : finishingBattle->loserHero->commander->artifactsWorn)
+					addArtifactToTransfer(packCommander, artSlot.first, artSlot.second.getArt());
+				sendArtifacts(packCommander);
 			}
-		}
-	}
-
-	if (arts.size()) //display loot
-	{
-		InfoWindow iw;
-		iw.player = finishingBattle->winnerHero->tempOwner;
-
-		iw.text.appendLocalString (EMetaText::GENERAL_TXT, 30); //You have captured enemy artifact
-
-		for (auto art : arts) //TODO; separate function to display loot for various ojects?
-		{
-			if (art->artType->getId() == ArtifactID::SPELL_SCROLL)
-				iw.components.emplace_back(ComponentType::SPELL_SCROLL, art->getScrollSpellID());
-			else
-				iw.components.emplace_back(ComponentType::ARTIFACT, art->artType->getId());
-
-			if (iw.components.size() >= 14)
+			auto armyObj = battle.battleGetArmyObject(battle.otherSide(battleResult->winner));
+			for(const auto & armySlot : armyObj->stacks)
 			{
-				gameHandler->sendAndApply(&iw);
-				iw.components.clear();
+				BulkMoveArtifacts packsArmy(finishingBattle->winnerHero->getOwner(), finishingBattle->loserHero->id, finishingBattle->winnerHero->id, false);
+				packsArmy.srcArtHolder = armyObj->id;
+				packsArmy.srcCreature = armySlot.first;
+				for(const auto & artSlot : armySlot.second->artifactsWorn)
+					addArtifactToTransfer(packsArmy, artSlot.first, armySlot.second->getArt(artSlot.first));
+				sendArtifacts(packsArmy);
 			}
 		}
-		if (iw.components.size())
+		// Display loot
+		if(!arts.empty())
 		{
-			gameHandler->sendAndApply(&iw);
-		}
-	}
-	//Eagle Eye secondary skill handling
-	if (!cs.spells.empty())
-	{
-		cs.learn = 1;
-		cs.hid = finishingBattle->winnerHero->id;
+			InfoWindow iw;
+			iw.player = finishingBattle->winnerHero->tempOwner;
+			iw.text.appendLocalString(EMetaText::GENERAL_TXT, 30); //You have captured enemy artifact
 
-		InfoWindow iw;
-		iw.player = finishingBattle->winnerHero->tempOwner;
-		iw.text.appendLocalString(EMetaText::GENERAL_TXT, 221); //Through eagle-eyed observation, %s is able to learn %s
-		iw.text.replaceRawString(finishingBattle->winnerHero->getNameTranslated());
+			for(const auto art : arts) //TODO; separate function to display loot for various objects?
+			{
+				if(art->isScroll())
+					iw.components.emplace_back(ComponentType::SPELL_SCROLL, art->getScrollSpellID());
+				else
+					iw.components.emplace_back(ComponentType::ARTIFACT, art->getTypeId());
 
-		std::ostringstream names;
-		for (int i = 0; i < cs.spells.size(); i++)
-		{
-			names << "%s";
-			if (i < cs.spells.size() - 2)
-				names << ", ";
-			else if (i < cs.spells.size() - 1)
-				names << "%s";
+				if(iw.components.size() >= GameConstants::INFO_WINDOW_ARTIFACTS_MAX_ITEMS)
+				{
+					gameHandler->sendAndApply(iw);
+					iw.components.clear();
+				}
+			}
+			gameHandler->sendAndApply(iw);
 		}
-		names << ".";
-
-		iw.text.replaceRawString(names.str());
+		if(!packHero.artsPack0.empty())
+			sendArtifacts(packHero);
+	}
 
-		auto it = cs.spells.begin();
-		for (int i = 0; i < cs.spells.size(); i++, it++)
+	// Remove beaten hero
+	if(finishingBattle->loserHero)
+	{
+		//add statistics
+		if(!finishingBattle->isDraw())
 		{
-			iw.text.replaceName(*it);
-			if (i == cs.spells.size() - 2) //we just added pre-last name
-				iw.text.replaceLocalString(EMetaText::GENERAL_TXT, 141); // " and "
-			iw.components.emplace_back(ComponentType::SPELL, *it);
+			ConstTransitivePtr<CGHeroInstance> strongestHero = nullptr;
+			for(auto & hero : gameHandler->gameState()->getPlayerState(finishingBattle->loser)->getHeroes())
+				if(!strongestHero || hero->exp > strongestHero->exp)
+					strongestHero = hero;
+			if(strongestHero->id == finishingBattle->loserHero->id && strongestHero->level > 5)
+				gameHandler->gameState()->statistic.accumulatedValues[finishingBattle->victor].lastDefeatedStrongestHeroDay = gameHandler->gameState()->getDate(Date::DAY);
 		}
-		gameHandler->sendAndApply(&iw);
-		gameHandler->sendAndApply(&cs);
-	}
-	cab1.updateArmy(gameHandler);
-	cab2.updateArmy(gameHandler); //take casualties after battle is deleted
 
-	if(finishingBattle->loserHero) //remove beaten hero
-	{
 		RemoveObject ro(finishingBattle->loserHero->id, finishingBattle->victor);
-		gameHandler->sendAndApply(&ro);
+		gameHandler->sendAndApply(ro);
 	}
-	if(finishingBattle->isDraw() && finishingBattle->winnerHero) //for draw case both heroes should be removed
+	// For draw case both heroes should be removed
+	if(finishingBattle->isDraw() && finishingBattle->winnerHero)
 	{
 		RemoveObject ro(finishingBattle->winnerHero->id, finishingBattle->loser);
-		gameHandler->sendAndApply(&ro);
+		gameHandler->sendAndApply(ro);
 	}
 
-	if(battleResult->winner == BattleSide::DEFENDER
-	   && finishingBattle->winnerHero
-	   && finishingBattle->winnerHero->visitedTown
-	   && !finishingBattle->winnerHero->inTownGarrison
-	   && finishingBattle->winnerHero->visitedTown->garrisonHero == finishingBattle->winnerHero)
+	// add statistic
+	if(battle.sideToPlayer(BattleSide::ATTACKER) == PlayerColor::NEUTRAL || battle.sideToPlayer(BattleSide::DEFENDER) == PlayerColor::NEUTRAL)
 	{
-		gameHandler->swapGarrisonOnSiege(finishingBattle->winnerHero->visitedTown->id); //return defending visitor from garrison to its rightful place
+		gameHandler->gameState()->statistic.accumulatedValues[battle.sideToPlayer(BattleSide::ATTACKER)].numBattlesNeutral++;
+		gameHandler->gameState()->statistic.accumulatedValues[battle.sideToPlayer(BattleSide::DEFENDER)].numBattlesNeutral++;
+		if(!finishingBattle->isDraw())
+			gameHandler->gameState()->statistic.accumulatedValues[battle.sideToPlayer(finishingBattle->winnerSide)].numWinBattlesNeutral++;
+	}
+	else
+	{
+		gameHandler->gameState()->statistic.accumulatedValues[battle.sideToPlayer(BattleSide::ATTACKER)].numBattlesPlayer++;
+		gameHandler->gameState()->statistic.accumulatedValues[battle.sideToPlayer(BattleSide::DEFENDER)].numBattlesPlayer++;
+		if(!finishingBattle->isDraw())
+			gameHandler->gameState()->statistic.accumulatedValues[battle.sideToPlayer(finishingBattle->winnerSide)].numWinBattlesPlayer++;
 	}
-	//give exp
-	if(!finishingBattle->isDraw() && battleResult->exp[finishingBattle->winnerSide] && finishingBattle->winnerHero)
-		gameHandler->giveExperience(finishingBattle->winnerHero, battleResult->exp[finishingBattle->winnerSide]);
 
 	BattleResultAccepted raccepted;
 	raccepted.battleID = battle.getBattle()->getBattleID();
-	raccepted.heroResult[0].army = const_cast<CArmedInstance*>(battle.battleGetArmyObject(BattleSide::ATTACKER));
-	raccepted.heroResult[1].army = const_cast<CArmedInstance*>(battle.battleGetArmyObject(BattleSide::DEFENDER));
-	raccepted.heroResult[0].hero = const_cast<CGHeroInstance*>(battle.battleGetFightingHero(BattleSide::ATTACKER));
-	raccepted.heroResult[1].hero = const_cast<CGHeroInstance*>(battle.battleGetFightingHero(BattleSide::DEFENDER));
-	raccepted.heroResult[0].exp = battleResult->exp[0];
-	raccepted.heroResult[1].exp = battleResult->exp[1];
-	raccepted.winnerSide = finishingBattle->winnerSide; 
-	gameHandler->sendAndApply(&raccepted);
+	raccepted.heroResult[BattleSide::ATTACKER].army = const_cast<CArmedInstance*>(battle.battleGetArmyObject(BattleSide::ATTACKER));
+	raccepted.heroResult[BattleSide::DEFENDER].army = const_cast<CArmedInstance*>(battle.battleGetArmyObject(BattleSide::DEFENDER));
+	raccepted.heroResult[BattleSide::ATTACKER].hero = const_cast<CGHeroInstance*>(battle.battleGetFightingHero(BattleSide::ATTACKER));
+	raccepted.heroResult[BattleSide::DEFENDER].hero = const_cast<CGHeroInstance*>(battle.battleGetFightingHero(BattleSide::DEFENDER));
+	raccepted.heroResult[BattleSide::ATTACKER].exp = battleResult->exp[BattleSide::ATTACKER];
+	raccepted.heroResult[BattleSide::DEFENDER].exp = battleResult->exp[BattleSide::DEFENDER];
+	raccepted.winnerSide = finishingBattle->winnerSide;
+	gameHandler->sendAndApply(raccepted);
 
 	gameHandler->queries->popIfTop(battleQuery);
 	//--> continuation (battleAfterLevelUp) occurs after level-up gameHandler->queries are handled or on removing query
@@ -545,37 +556,43 @@
 	const CStackBasicDescriptor raisedStack = finishingBattle->winnerHero ? finishingBattle->winnerHero->calculateNecromancy(result) : CStackBasicDescriptor();
 	// Give raised units to winner and show dialog, if any were raised,
 	// units will be given after casualties are taken
-	const SlotID necroSlot = raisedStack.type ? finishingBattle->winnerHero->getSlotFor(raisedStack.type) : SlotID();
+	const SlotID necroSlot = raisedStack.getCreature() ? finishingBattle->winnerHero->getSlotFor(raisedStack.getCreature()) : SlotID();
 
 	if (necroSlot != SlotID() && !finishingBattle->isDraw())
 	{
 		finishingBattle->winnerHero->showNecromancyDialog(raisedStack, gameHandler->getRandomGenerator());
-		gameHandler->addToSlot(StackLocation(finishingBattle->winnerHero, necroSlot), raisedStack.type, raisedStack.count);
+		gameHandler->addToSlot(StackLocation(finishingBattle->winnerHero, necroSlot), raisedStack.getCreature(), raisedStack.count);
 	}
 
 	BattleResultsApplied resultsApplied;
 	resultsApplied.battleID = battleID;
 	resultsApplied.player1 = finishingBattle->victor;
 	resultsApplied.player2 = finishingBattle->loser;
-	gameHandler->sendAndApply(&resultsApplied);
+	gameHandler->sendAndApply(resultsApplied);
 
 	//handle victory/loss of engaged players
 	std::set<PlayerColor> playerColors = {finishingBattle->loser, finishingBattle->victor};
 	gameHandler->checkVictoryLossConditions(playerColors);
 
 	if (result.result == EBattleResult::SURRENDER)
+	{
+		gameHandler->gameState()->statistic.accumulatedValues[finishingBattle->loser].numHeroSurrendered++;
 		gameHandler->heroPool->onHeroSurrendered(finishingBattle->loser, finishingBattle->loserHero);
+	}
 
 	if (result.result == EBattleResult::ESCAPE)
+	{
+		gameHandler->gameState()->statistic.accumulatedValues[finishingBattle->loser].numHeroEscaped++;
 		gameHandler->heroPool->onHeroEscaped(finishingBattle->loser, finishingBattle->loserHero);
+	}
 
-	if (result.winner != 2 && finishingBattle->winnerHero && finishingBattle->winnerHero->stacks.empty()
+	if (result.winner != BattleSide::NONE && finishingBattle->winnerHero && finishingBattle->winnerHero->stacks.empty()
 		&& (!finishingBattle->winnerHero->commander || !finishingBattle->winnerHero->commander->alive))
 	{
 		RemoveObject ro(finishingBattle->winnerHero->id, finishingBattle->winnerHero->getOwner());
-		gameHandler->sendAndApply(&ro);
+		gameHandler->sendAndApply(ro);
 
-		if (VLC->settings()->getBoolean(EGameSettings::HEROES_RETREAT_ON_WIN_WITHOUT_TROOPS))
+		if (gameHandler->getSettings().getBoolean(EGameSettings::HEROES_RETREAT_ON_WIN_WITHOUT_TROOPS))
 			gameHandler->heroPool->onHeroEscaped(finishingBattle->victor, finishingBattle->winnerHero);
 	}
 
@@ -583,7 +600,7 @@
 	battleResults.erase(battleID);
 }
 
-void BattleResultProcessor::setBattleResult(const CBattleInfoCallback & battle, EBattleResult resultType, int victoriusSide)
+void BattleResultProcessor::setBattleResult(const CBattleInfoCallback & battle, EBattleResult resultType, BattleSide victoriusSide)
 {
 	assert(battleResults.count(battle.getBattle()->getBattleID()) == 0);
 
diff --color -urN vcmi-1.5.7/server/battles/BattleResultProcessor.h vcmi/server/battles/BattleResultProcessor.h
--- vcmi-1.5.7/server/battles/BattleResultProcessor.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/server/battles/BattleResultProcessor.h	2024-12-19 15:00:22.993151863 +0100
@@ -12,6 +12,7 @@
 #include "../../lib/GameConstants.h"
 #include "../../lib/networkPacks/StackLocation.h"
 #include "../../lib/networkPacks/ArtifactLocation.h"
+#include "../../lib/battle/BattleSide.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 struct SideInBattle;
@@ -34,7 +35,7 @@
 	TSummoned summoned;
 	ObjectInstanceID heroWithDeadCommander; //TODO: unify stack locations
 
-	CasualtiesAfterBattle(const CBattleInfoCallback & battle, uint8_t sideInBattle);
+	CasualtiesAfterBattle(const CBattleInfoCallback & battle, BattleSide sideInBattle);
 	void updateArmy(CGameHandler * gh);
 };
 
@@ -42,11 +43,11 @@
 {
 	FinishingBattleHelper(const CBattleInfoCallback & battle, const BattleResult & result, int RemainingBattleQueriesCount);
 
-	inline bool isDraw() const {return winnerSide == 2;}
+	inline bool isDraw() const {return winnerSide == BattleSide::NONE;}
 
 	const CGHeroInstance *winnerHero, *loserHero;
 	PlayerColor victor, loser;
-	ui8 winnerSide;
+	BattleSide winnerSide;
 
 	int remainingBattleQueriesCount;
 
@@ -74,7 +75,7 @@
 
 	bool battleIsEnding(const CBattleInfoCallback & battle) const;
 
-	void setBattleResult(const CBattleInfoCallback & battle, EBattleResult resultType, int victoriusSide);
+	void setBattleResult(const CBattleInfoCallback & battle, EBattleResult resultType, BattleSide victoriusSide);
 	void endBattle(const CBattleInfoCallback & battle); //ends battle
 	void endBattleConfirm(const CBattleInfoCallback & battle);
 	void battleAfterLevelUp(const BattleID & battleID, const BattleResult & result);
diff --color -urN vcmi-1.5.7/server/CGameHandler.cpp vcmi/server/CGameHandler.cpp
--- vcmi-1.5.7/server/CGameHandler.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/server/CGameHandler.cpp	2024-12-19 15:00:22.989151698 +0100
@@ -16,25 +16,26 @@
 #include "ServerSpellCastEnvironment.h"
 #include "battles/BattleProcessor.h"
 #include "processors/HeroPoolProcessor.h"
+#include "processors/NewTurnProcessor.h"
 #include "processors/PlayerMessageProcessor.h"
 #include "processors/TurnOrderProcessor.h"
 #include "queries/QueriesProcessor.h"
 #include "queries/MapQueries.h"
+#include "queries/VisitQueries.h"
 
 #include "../lib/ArtifactUtils.h"
 #include "../lib/CArtHandler.h"
-#include "../lib/CBuildingHandler.h"
+#include "../lib/CConfigHandler.h"
 #include "../lib/CCreatureHandler.h"
 #include "../lib/CCreatureSet.h"
-#include "../lib/CGeneralTextHandler.h"
-#include "../lib/CHeroHandler.h"
+#include "../lib/texts/CGeneralTextHandler.h"
 #include "../lib/CPlayerState.h"
+#include "../lib/CRandomGenerator.h"
 #include "../lib/CSoundBase.h"
 #include "../lib/CThreadHelper.h"
-#include "../lib/CTownHandler.h"
 #include "../lib/GameConstants.h"
 #include "../lib/UnlockGuard.h"
-#include "../lib/GameSettings.h"
+#include "../lib/IGameSettings.h"
 #include "../lib/ScriptHandler.h"
 #include "../lib/StartInfo.h"
 #include "../lib/TerrainHandler.h"
@@ -43,23 +44,35 @@
 #include "../lib/int3.h"
 
 #include "../lib/battle/BattleInfo.h"
+
+#include "../lib/entities/building/CBuilding.h"
+#include "../lib/entities/faction/CTownHandler.h"
+#include "../lib/entities/hero/CHeroHandler.h"
+
 #include "../lib/filesystem/FileInfo.h"
 #include "../lib/filesystem/Filesystem.h"
+
 #include "../lib/gameState/CGameState.h"
 
 #include "../lib/mapping/CMap.h"
 #include "../lib/mapping/CMapService.h"
+
+#include "../lib/mapObjects/CGCreature.h"
 #include "../lib/mapObjects/CGMarket.h"
+#include "../lib/mapObjects/TownBuildingInstance.h"
 #include "../lib/mapObjects/CGTownInstance.h"
 #include "../lib/mapObjects/MiscObjects.h"
+#include "../lib/mapObjectConstructors/AObjectTypeHandler.h"
+#include "../lib/mapObjectConstructors/CObjectClassesHandler.h"
+
 #include "../lib/modding/ModIncompatibility.h"
+
 #include "../lib/networkPacks/StackLocation.h"
+
 #include "../lib/pathfinder/CPathfinder.h"
 #include "../lib/pathfinder/PathfinderOptions.h"
 #include "../lib/pathfinder/TurnInfo.h"
 
-#include "../lib/registerTypes/RegisterTypesServerPacks.h"
-
 #include "../lib/rmg/CMapGenOptions.h"
 
 #include "../lib/serializer/CSaveFile.h"
@@ -68,7 +81,8 @@
 
 #include "../lib/spells/CSpellHandler.h"
 
-#include "vstd/CLoggerBase.h"
+#include <vstd/RNG.h>
+#include <vstd/CLoggerBase.h>
 #include <vcmi/events/EventBus.h>
 #include <vcmi/events/GenericEvents.h>
 #include <vcmi/events/AdventureEvents.h>
@@ -78,53 +92,6 @@
 #define COMPLAIN_RET(txt) {complain(txt); return false;}
 #define COMPLAIN_RETF(txt, FORMAT) {complain(boost::str(boost::format(txt) % FORMAT)); return false;}
 
-template <typename T> class CApplyOnGH;
-
-class CBaseForGHApply
-{
-public:
-	virtual bool applyOnGH(CGameHandler * gh, CGameState * gs, CPack * pack) const =0;
-	virtual ~CBaseForGHApply(){}
-	template<typename U> static CBaseForGHApply *getApplier(const U * t=nullptr)
-	{
-		return new CApplyOnGH<U>();
-	}
-};
-
-template <typename T> class CApplyOnGH : public CBaseForGHApply
-{
-public:
-	bool applyOnGH(CGameHandler * gh, CGameState * gs, CPack * pack) const override
-	{
-		T *ptr = static_cast<T*>(pack);
-		try
-		{
-			ApplyGhNetPackVisitor applier(*gh);
-
-			ptr->visit(applier);
-
-			return applier.getResult();
-		}
-		catch(ExceptionNotAllowedAction & e)
-		{
-            (void)e;
-			return false;
-		}
-	}
-};
-
-template <>
-class CApplyOnGH<CPack> : public CBaseForGHApply
-{
-public:
-	bool applyOnGH(CGameHandler * gh, CGameState * gs, CPack * pack) const override
-	{
-		logGlobal->error("Cannot apply on GH plain CPack!");
-		assert(0);
-		return false;
-	}
-};
-
 static inline double distance(int3 a, int3 b)
 {
 	return std::sqrt((double)(a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y));
@@ -189,22 +156,22 @@
 	sps.which = primarySkill;
 	sps.abs = false;
 	sps.val = 1;
-	sendAndApply(&sps);
+	sendAndApply(sps);
 
 	HeroLevelUp hlu;
 	hlu.player = hero->tempOwner;
 	hlu.heroId = hero->id;
 	hlu.primskill = primarySkill;
-	hlu.skills = hero->getLevelUpProposedSecondarySkills(heroPool->getHeroSkillsRandomGenerator(hero->getHeroType()));
+	hlu.skills = hero->getLevelUpProposedSecondarySkills(heroPool->getHeroSkillsRandomGenerator(hero->getHeroTypeID()));
 
 	if (hlu.skills.size() == 0)
 	{
-		sendAndApply(&hlu);
+		sendAndApply(hlu);
 		levelUpHero(hero);
 	}
 	else if (hlu.skills.size() == 1 || !hero->getOwner().isValidPlayer())
 	{
-		sendAndApply(&hlu);
+		sendAndApply(hlu);
 		levelUpHero(hero, hlu.skills.front());
 	}
 	else if (hlu.skills.size() > 1)
@@ -212,7 +179,7 @@
 		auto levelUpQuery = std::make_shared<CHeroLevelUpDialogQuery>(this, hlu, hero);
 		hlu.queryID = levelUpQuery->queryID;
 		queries->addQuery(levelUpQuery);
-		sendAndApply(&hlu);
+		sendAndApply(hlu);
 		//level up will be called on query reply
 	}
 }
@@ -268,33 +235,34 @@
 				scp.accumulatedBonus.type = BonusType::STACKS_SPEED;
 				break;
 			case ECommander::SPELL_POWER:
-				scp.accumulatedBonus.type = BonusType::MAGIC_RESISTANCE;
+				scp.accumulatedBonus.type = BonusType::SPELL_DAMAGE_REDUCTION;
+				scp.accumulatedBonus.subtype = BonusSubtypeID(SpellSchool::ANY);
 				scp.accumulatedBonus.val = difference (VLC->creh->skillLevels, c->secondarySkills, ECommander::RESISTANCE);
-				sendAndApply (&scp); //additional pack
+				sendAndApply(scp); //additional pack
 				scp.accumulatedBonus.type = BonusType::CREATURE_SPELL_POWER;
 				scp.accumulatedBonus.val = difference (VLC->creh->skillLevels, c->secondarySkills, ECommander::SPELL_POWER) * 100; //like hero with spellpower = ability level
-				sendAndApply (&scp); //additional pack
+				sendAndApply(scp); //additional pack
 				scp.accumulatedBonus.type = BonusType::CASTS;
 				scp.accumulatedBonus.val = difference (VLC->creh->skillLevels, c->secondarySkills, ECommander::CASTS);
-				sendAndApply (&scp); //additional pack
+				sendAndApply(scp); //additional pack
 				scp.accumulatedBonus.type = BonusType::CREATURE_ENCHANT_POWER; //send normally
 				break;
 		}
 
 		scp.accumulatedBonus.val = difference (VLC->creh->skillLevels, c->secondarySkills, skill);
-		sendAndApply (&scp);
+		sendAndApply(scp);
 
 		scp.which = SetCommanderProperty::SECONDARY_SKILL;
 		scp.additionalInfo = skill;
 		scp.amount = c->secondarySkills.at(skill) + 1;
-		sendAndApply (&scp);
+		sendAndApply(scp);
 	}
 	else if (skill >= 100)
 	{
 		scp.which = SetCommanderProperty::SPECIAL_SKILL;
 		scp.accumulatedBonus = *VLC->creh->skillRequirements.at(skill-100).first;
 		scp.additionalInfo = skill; //unnormalized
-		sendAndApply (&scp);
+		sendAndApply(scp);
 	}
 	expGiven(hero);
 }
@@ -339,12 +307,12 @@
 
 	if (!skillAmount)
 	{
-		sendAndApply(&clu);
+		sendAndApply(clu);
 		levelUpCommander(c);
 	}
 	else if (skillAmount == 1  ||  hero->tempOwner == PlayerColor::NEUTRAL) //choose skill automatically
 	{
-		sendAndApply(&clu);
+		sendAndApply(clu);
 		levelUpCommander(c, *RandomGeneratorUtil::nextItem(clu.skills, getRandomGenerator()));
 	}
 	else if (skillAmount > 1) //apply and ask for secondary skill
@@ -352,7 +320,7 @@
 		auto commanderLevelUp = std::make_shared<CCommanderLevelUpDialogQuery>(this, clu, hero);
 		clu.queryID = commanderLevelUp->queryID;
 		queries->addQuery(commanderLevelUp);
-		sendAndApply(&clu);
+		sendAndApply(clu);
 	}
 }
 
@@ -390,7 +358,7 @@
 		iw.player = hero->tempOwner;
 		iw.text.appendLocalString(EMetaText::GENERAL_TXT, 1); //can gain no more XP
 		iw.text.replaceTextID(hero->getNameTextID());
-		sendAndApply(&iw);
+		sendAndApply(iw);
 	}
 
 	SetPrimSkill sps;
@@ -398,7 +366,7 @@
 	sps.which = PrimarySkill::EXPERIENCE;
 	sps.abs = false;
 	sps.val = amountToGain;
-	sendAndApply(&sps);
+	sendAndApply(sps);
 
 	//hero may level up
 	if (hero->commander && hero->commander->alive)
@@ -408,7 +376,7 @@
 		scp.heroid = hero->id;
 		scp.which = SetCommanderProperty::EXPERIENCE;
 		scp.amount = amountToGain;
-		sendAndApply (&scp);
+		sendAndApply(scp);
 		CBonusSystemNode::treeHasChanged();
 	}
 
@@ -422,7 +390,7 @@
 	sps.which = which;
 	sps.abs = abs;
 	sps.val = val;
-	sendAndApply(&sps);
+	sendAndApply(sps);
 }
 
 void CGameHandler::changeSecSkill(const CGHeroInstance * hero, SecondarySkill which, int val, bool abs)
@@ -437,7 +405,7 @@
 	sss.which = which;
 	sss.val = val;
 	sss.abs = abs;
-	sendAndApply(&sss);
+	sendAndApply(sss);
 
 	if (hero->visitedTown)
 		giveSpells(hero->visitedTown, hero);
@@ -464,50 +432,71 @@
 			continue;
 		
 		auto playerConnection = vstd::find(playerConnections.second, c);
-		if(playerConnection != playerConnections.second.end())
+		if(playerConnection == playerConnections.second.end())
+			continue;
+
+		logGlobal->trace("Player %s disconnected. Notifying remaining players", playerId.toString());
+
+		// this player have left the game - broadcast infowindow to all in-game players
+		for (auto i = gs->players.cbegin(); i!=gs->players.cend(); i++)
 		{
-			std::string messageText = boost::str(boost::format("%s (cid %d) was disconnected") % playerSettings->name % c->connectionID);
-			playerMessages->broadcastMessage(playerId, messageText);
+			if (i->first == playerId)
+				continue;
+
+			if (getPlayerState(i->first)->status != EPlayerStatus::INGAME)
+				continue;
+
+			logGlobal->trace("Notifying player %s", i->first);
+
+			InfoWindow out;
+			out.player = i->first;
+			out.text.appendTextID("vcmi.server.errors.playerLeft");
+			out.text.replaceName(playerId);
+			out.components.emplace_back(ComponentType::FLAG, playerId);
+			sendAndApply(out);
 		}
 	}
 }
 
-void CGameHandler::handleReceivedPack(CPackForServer * pack)
+void CGameHandler::handleReceivedPack(CPackForServer & pack)
 {
 	//prepare struct informing that action was applied
-	auto sendPackageResponse = [&](bool succesfullyApplied)
+	auto sendPackageResponse = [&](bool successfullyApplied)
 	{
 		PackageApplied applied;
-		applied.player = pack->player;
-		applied.result = succesfullyApplied;
-		applied.packType = CTypeList::getInstance().getTypeID(pack);
-		applied.requestID = pack->requestID;
-		pack->c->sendPack(&applied);
+		applied.player = pack.player;
+		applied.result = successfullyApplied;
+		applied.packType = CTypeList::getInstance().getTypeID(&pack);
+		applied.requestID = pack.requestID;
+		pack.c->sendPack(applied);
 	};
 
-	CBaseForGHApply * apply = applier->getApplier(CTypeList::getInstance().getTypeID(pack)); //and appropriate applier object
-	if(isBlockedByQueries(pack, pack->player))
+	if(isBlockedByQueries(&pack, pack.player))
 	{
 		sendPackageResponse(false);
 	}
-	else if(apply)
+	else
 	{
-		const bool result = apply->applyOnGH(this, this->gs, pack);
+		bool result;
+		try
+		{
+			ApplyGhNetPackVisitor applier(*this);
+			pack.visit(applier);
+			result = applier.getResult();
+		}
+		catch(ExceptionNotAllowedAction &)
+		{
+			result = false;
+		}
+
 		if(result)
-			logGlobal->trace("Message %s successfully applied!", typeid(*pack).name());
+			logGlobal->trace("Message %s successfully applied!", typeid(pack).name());
 		else
 			complain((boost::format("Got false in applying %s... that request must have been fishy!")
-				% typeid(*pack).name()).str());
+				% typeid(pack).name()).str());
 
 		sendPackageResponse(true);
 	}
-	else
-	{
-		logGlobal->error("Message cannot be applied, cannot find applier (unregistered type)!");
-		sendPackageResponse(false);
-	}
-
-	vstd::clear_pointer(pack);
 }
 
 CGameHandler::CGameHandler(CVCMIServer * lobby)
@@ -517,14 +506,14 @@
 	, turnOrder(std::make_unique<TurnOrderProcessor>(this))
 	, queries(std::make_unique<QueriesProcessor>())
 	, playerMessages(std::make_unique<PlayerMessageProcessor>(this))
+	, randomNumberGenerator(std::make_unique<CRandomGenerator>())
 	, complainNoCreatures("No creatures to split")
 	, complainNotEnoughCreatures("Cannot split that stack, not enough creatures!")
 	, complainInvalidSlot("Invalid slot accessed!")
 	, turnTimerHandler(std::make_unique<TurnTimerHandler>(*this))
+	, newTurnProcessor(std::make_unique<NewTurnProcessor>(this))
 {
 	QID = 1;
-	applier = std::make_shared<CApplier<CBaseForGHApply>>();
-	registerTypesServerPacks(*applier);
 
 	spellEnv = new ServerSpellCastEnvironment(this);
 }
@@ -546,10 +535,11 @@
 
 void CGameHandler::init(StartInfo *si, Load::ProgressAccumulator & progressTracking)
 {
-	if (si->seedToBeUsed == 0)
-	{
-		si->seedToBeUsed = CRandomGenerator::getDefault().nextInt();
-	}
+	int requestedSeed = settings["server"]["seed"].Integer();
+	if (requestedSeed != 0)
+		randomNumberGenerator->setSeed(requestedSeed);
+	logGlobal->info("Using random seed: %d", randomNumberGenerator->nextInt());
+
 	CMapService mapService;
 	gs = new CGameState();
 	gs->preInit(VLC, this);
@@ -557,26 +547,18 @@
 	gs->init(&mapService, si, progressTracking);
 	logGlobal->info("Gamestate initialized!");
 
-	// reset seed, so that clients can't predict any following random values
-	getRandomGenerator().resetSeed();
-
 	for (auto & elem : gs->players)
 		turnOrder->addPlayer(elem.first);
 
 	for (auto & elem : gs->map->allHeroes)
 	{
 		if(elem)
-			heroPool->getHeroSkillsRandomGenerator(elem->getHeroType()); // init RMG seed
+			heroPool->getHeroSkillsRandomGenerator(elem->getHeroTypeID()); // init RMG seed
 	}
 
 	reinitScripting();
 }
 
-static bool evntCmp(const CMapEvent &a, const CMapEvent &b)
-{
-	return a.earlierThan(b);
-}
-
 void CGameHandler::setPortalDwelling(const CGTownInstance * town, bool forced=false, bool clear = false)
 {// bool forced = true - if creature should be replaced, if false - only if no creature was set
 
@@ -587,35 +569,35 @@
 		return;
 	}
 
-	if (forced || town->creatures.at(GameConstants::CREATURES_PER_TOWN).second.empty())//we need to change creature
+	if (forced || town->creatures.at(town->getTown()->creatures.size()).second.empty())//we need to change creature
 		{
 			SetAvailableCreatures ssi;
 			ssi.tid = town->id;
 			ssi.creatures = town->creatures;
-			ssi.creatures[GameConstants::CREATURES_PER_TOWN].second.clear();//remove old one
+			ssi.creatures[town->getTown()->creatures.size()].second.clear();//remove old one
 
-			const std::vector<ConstTransitivePtr<CGDwelling> > &dwellings = p->dwellings;
-			if (dwellings.empty())//no dwellings - just remove
+			std::set<CreatureID> availableCreatures;
+			for (const auto & dwelling : p->getOwnedObjects())
 			{
-				sendAndApply(&ssi);
-				return;
+				const auto & dwellingCreatures = dwelling->asOwnable()->providedCreatures();
+				availableCreatures.insert(dwellingCreatures.begin(), dwellingCreatures.end());
 			}
 
-			auto dwelling = *RandomGeneratorUtil::nextItem(dwellings, getRandomGenerator());
+			if (availableCreatures.empty())
+				return;
 
-			// for multi-creature dwellings like Golem Factory
-			auto creatureId = RandomGeneratorUtil::nextItem(dwelling->creatures, getRandomGenerator())->second[0];
+			CreatureID creatureId = *RandomGeneratorUtil::nextItem(availableCreatures, getRandomGenerator());
 
 			if (clear)
 			{
-				ssi.creatures[GameConstants::CREATURES_PER_TOWN].first = std::max(1, (VLC->creh->objects.at(creatureId)->getGrowth())/2);
+				ssi.creatures[town->getTown()->creatures.size()].first = std::max(1, (creatureId.toEntity(VLC)->getGrowth())/2);
 			}
 			else
 			{
-				ssi.creatures[GameConstants::CREATURES_PER_TOWN].first = VLC->creh->objects.at(creatureId)->getGrowth();
+				ssi.creatures[town->getTown()->creatures.size()].first = creatureId.toEntity(VLC)->getGrowth();
 			}
-			ssi.creatures[GameConstants::CREATURES_PER_TOWN].second.push_back(creatureId);
-			sendAndApply(&ssi);
+			ssi.creatures[town->getTown()->creatures.size()].second.push_back(creatureId);
+			sendAndApply(ssi);
 		}
 }
 
@@ -623,54 +605,34 @@
 {
 	events::PlayerGotTurn::defaultExecute(serverEventBus.get(), which);
 	turnTimerHandler->onPlayerGetTurn(which);
+	newTurnProcessor->onPlayerTurnStarted(which);
 }
 
 void CGameHandler::onPlayerTurnEnded(PlayerColor which)
 {
-	const auto * playerState = gs->getPlayerState(which);
-	assert(playerState->status == EPlayerStatus::INGAME);
+	newTurnProcessor->onPlayerTurnEnded(which);
+}
 
-	if (playerState->towns.empty())
-	{
-		DaysWithoutTown pack;
-		pack.player = which;
-		pack.daysWithoutCastle = playerState->daysWithoutCastle.value_or(0) + 1;
-		sendAndApply(&pack);
-	}
-	else
+void CGameHandler::addStatistics(StatisticDataSet &stat) const
+{
+	for (const auto & elem : gs->players)
 	{
-		if (playerState->daysWithoutCastle.has_value())
-		{
-			DaysWithoutTown pack;
-			pack.player = which;
-			pack.daysWithoutCastle = std::nullopt;
-			sendAndApply(&pack);
-		}
-	}
-
-	// check for 7 days without castle
-	checkVictoryLossConditionsForPlayer(which);
+		if (elem.first == PlayerColor::NEUTRAL || !elem.first.isValidPlayer())
+			continue;
 
-	bool newWeek = getDate(Date::DAY_OF_WEEK) == 7; // end of 7th day
+		auto data = StatisticDataSet::createEntry(&elem.second, gs);
 
-	if (newWeek) //new heroes in tavern
-		heroPool->onNewWeek(which);
+		stat.add(data);
+	}
 }
 
 void CGameHandler::onNewTurn()
 {
 	logGlobal->trace("Turn %d", gs->day+1);
-	NewTurn n;
-	n.specialWeek = NewTurn::NO_ACTION;
-	n.creatureid = CreatureID::NONE;
-	n.day = gs->day + 1;
 
 	bool firstTurn = !getDate(Date::DAY);
-	bool newWeek = getDate(Date::DAY_OF_WEEK) == 7; //day numbers are confusing, as day was not yet switched
 	bool newMonth = getDate(Date::DAY_OF_MONTH) == 28;
 
-	std::map<PlayerColor, si32> hadGold;//starting gold - for buildings like dwarven treasury
-
 	if (firstTurn)
 	{
 		for (auto obj : gs->map->objects)
@@ -680,241 +642,39 @@
 				giveExperience(getHero(obj->id), 0);
 			}
 		}
-	}
 
-	for (auto & player : gs->players)
-	{
-		if (player.second.status != EPlayerStatus::INGAME)
-			continue;
+		for (auto & elem : gs->players)
+			heroPool->onNewWeek(elem.first);
 
-		if (player.second.heroes.empty() && player.second.towns.empty())
-			throw std::runtime_error("Invalid player in player state! Player " + std::to_string(player.first.getNum()) + ", map name: " + gs->map->name.toString() + ", map description: " + gs->map->description.toString());
 	}
-
-	if (newWeek && !firstTurn)
+	else
 	{
-		n.specialWeek = NewTurn::NORMAL;
-		bool deityOfFireBuilt = false;
-		for (const CGTownInstance *t : gs->map->towns)
-		{
-			if (t->hasBuilt(BuildingID::GRAIL, ETownType::INFERNO))
-			{
-				deityOfFireBuilt = true;
-				break;
-			}
-		}
-
-		if (deityOfFireBuilt)
-		{
-			n.specialWeek = NewTurn::DEITYOFFIRE;
-			n.creatureid = CreatureID::IMP;
-		}
-		else if(VLC->settings()->getBoolean(EGameSettings::CREATURES_ALLOW_RANDOM_SPECIAL_WEEKS))
-		{
-			int monthType = getRandomGenerator().nextInt(99);
-			if (newMonth) //new month
-			{
-				if (monthType < 40) //double growth
-				{
-					n.specialWeek = NewTurn::DOUBLE_GROWTH;
-					if (VLC->settings()->getBoolean(EGameSettings::CREATURES_ALLOW_ALL_FOR_DOUBLE_MONTH))
-					{
-						n.creatureid = VLC->creh->pickRandomMonster(getRandomGenerator());
-					}
-					else if (VLC->creh->doubledCreatures.size())
-					{
-						n.creatureid = *RandomGeneratorUtil::nextItem(VLC->creh->doubledCreatures, getRandomGenerator());
-					}
-					else
-					{
-						complain("Cannot find creature that can be spawned!");
-						n.specialWeek = NewTurn::NORMAL;
-					}
-				}
-				else if (monthType < 50)
-					n.specialWeek = NewTurn::PLAGUE;
-			}
-			else //it's a week, but not full month
-			{
-				if (monthType < 25)
-				{
-					n.specialWeek = NewTurn::BONUS_GROWTH; //+5
-					std::pair<int, CreatureID> newMonster(54, CreatureID());
-					do
-					{
-						newMonster.second = VLC->creh->pickRandomMonster(getRandomGenerator());
-					} while (VLC->creh->objects[newMonster.second] &&
-						(*VLC->townh)[VLC->creatures()->getById(newMonster.second)->getFaction()]->town == nullptr); // find first non neutral creature
-					n.creatureid = newMonster.second;
-				}
-			}
-		}
+		addStatistics(gameState()->statistic); // write at end of turn
 	}
 
-	for (auto & elem : gs->players)
-	{
-		if (elem.first == PlayerColor::NEUTRAL)
-			continue;
-
-		assert(elem.first.isValidPlayer());//illegal player number!
-
-		std::pair<PlayerColor, si32> playerGold(elem.first, elem.second.resources[EGameResID::GOLD]);
-		hadGold.insert(playerGold);
-
-		if (firstTurn)
-			heroPool->onNewWeek(elem.first);
-
-		n.res[elem.first] = elem.second.resources;
-
-		if(!firstTurn)
-		{
-			for (GameResID k = GameResID::WOOD; k < GameResID::COUNT; k++)
-			{
-				n.res[elem.first][k] += elem.second.valOfBonuses(BonusType::RESOURCES_CONSTANT_BOOST, BonusSubtypeID(k));
-				n.res[elem.first][k] += elem.second.valOfBonuses(BonusType::RESOURCES_TOWN_MULTIPLYING_BOOST, BonusSubtypeID(k)) * elem.second.towns.size();
-			}
-
-			if(newWeek) //weekly crystal generation if 1 or more crystal dragons in any hero army or town garrison
-			{
-				bool hasCrystalGenCreature = false;
-				for(CGHeroInstance * hero : elem.second.heroes)
-				{
-					for(auto stack : hero->stacks)
-					{
-						if(stack.second->hasBonusOfType(BonusType::SPECIAL_CRYSTAL_GENERATION))
-						{
-							hasCrystalGenCreature = true;
-							break;
-						}
-					}
-				}
-				if(!hasCrystalGenCreature) //not found in armies, check towns
-				{
-					for(CGTownInstance * town : elem.second.towns)
-					{
-						for(auto stack : town->stacks)
-						{
-							if(stack.second->hasBonusOfType(BonusType::SPECIAL_CRYSTAL_GENERATION))
-							{
-								hasCrystalGenCreature = true;
-								break;
-							}
-						}
-					}
-				}
-				if(hasCrystalGenCreature)
-					n.res[elem.first][EGameResID::CRYSTAL] += 3;
-			}
-		}
-
-		for (CGHeroInstance *h : (elem).second.heroes)
-		{
-			if (h->visitedTown)
-				giveSpells(h->visitedTown, h);
-
-			NewTurn::Hero hth;
-			hth.id = h->id;
-			auto ti = std::make_unique<TurnInfo>(h, 1);
-			// TODO: this code executed when bonuses of previous day not yet updated (this happen in NewTurn::applyGs). See issue 2356
-			hth.move = h->movementPointsLimitCached(gs->map->getTile(h->visitablePos()).terType->isLand(), ti.get());
-			hth.mana = h->getManaNewTurn();
-
-			n.heroes.insert(hth);
-
-			if (!firstTurn) //not first day
-			{
-				for (GameResID k = GameResID::WOOD; k < GameResID::COUNT; k++)
-				{
-					n.res[elem.first][k] += h->valOfBonuses(BonusType::GENERATE_RESOURCE, BonusSubtypeID(k));
-				}
-			}
-		}
-	}
 	for (CGTownInstance *t : gs->map->towns)
 	{
 		PlayerColor player = t->tempOwner;
-		handleTownEvents(t, n);
-		if (newWeek) //first day of week
-		{
-			if (t->hasBuilt(BuildingSubID::PORTAL_OF_SUMMONING))
-				setPortalDwelling(t, true, (n.specialWeek == NewTurn::PLAGUE ? true : false)); //set creatures for Portal of Summoning
-
-			if (!firstTurn)
-				if (t->hasBuilt(BuildingSubID::TREASURY) && player.isValidPlayer())
-						n.res[player][EGameResID::GOLD] += hadGold.at(player)/10; //give 10% of starting gold
-
-			if (!vstd::contains(n.cres, t->id))
-			{
-				n.cres[t->id].tid = t->id;
-				n.cres[t->id].creatures = t->creatures;
-			}
-			auto & sac = n.cres.at(t->id);
 
-			for (int k=0; k < GameConstants::CREATURES_PER_TOWN; k++) //creature growths
-			{
-				if (!t->creatures.at(k).second.empty()) // there are creatures at this level
-				{
-					ui32 &availableCount = sac.creatures.at(k).first;
-					const CCreature *cre = t->creatures.at(k).second.back().toCreature();
-
-					if (n.specialWeek == NewTurn::PLAGUE)
-						availableCount = t->creatures.at(k).first / 2; //halve their number, no growth
-					else
-					{
-						if (firstTurn) //first day of game: use only basic growths
-							availableCount = cre->getGrowth();
-						else
-							availableCount += t->creatureGrowth(k);
-
-						//Deity of fire week - upgrade both imps and upgrades
-						if (n.specialWeek == NewTurn::DEITYOFFIRE && vstd::contains(t->creatures.at(k).second, n.creatureid))
-							availableCount += 15;
-
-						if (cre->getId() == n.creatureid) //bonus week, effect applies only to identical creatures
-						{
-							if (n.specialWeek == NewTurn::DOUBLE_GROWTH)
-								availableCount *= 2;
-							else if (n.specialWeek == NewTurn::BONUS_GROWTH)
-								availableCount += 5;
-						}
-					}
-				}
-			}
-		}
-		if (!firstTurn  &&  player.isValidPlayer())//not the first day and town not neutral
-		{
-			n.res[player] = n.res[player] + t->dailyIncome();
-		}
 		if(t->hasBuilt(BuildingID::GRAIL)
-			&& t->town->buildings.at(BuildingID::GRAIL)->height == CBuilding::HEIGHT_SKYSHIP)
+			&& t->getTown()->buildings.at(BuildingID::GRAIL)->height == CBuilding::HEIGHT_SKYSHIP)
 		{
 			// Skyship, probably easier to handle same as Veil of darkness
-			//do it every new day after veils apply
-			if (player != PlayerColor::NEUTRAL) //do not reveal fow for neutral player
-			{
-				FoWChange fw;
-				fw.mode = ETileVisibility::REVEALED;
-				fw.player = player;
-				// find all hidden tiles
-				const auto & fow = getPlayerTeam(player)->fogOfWarMap;
-
-				auto shape = fow->shape();
-				for(size_t z = 0; z < shape[0]; z++)
-					for(size_t x = 0; x < shape[1]; x++)
-						for(size_t y = 0; y < shape[2]; y++)
-							if (!(*fow)[z][x][y])
-								fw.tiles.insert(int3(x, y, z));
-
-				sendAndApply (&fw);
-			}
+			// do it every new day before veils
+			if (player.isValidPlayer())
+				changeFogOfWar(t->getSightCenter(), t->getSightRadius(), player, ETileVisibility::REVEALED);
 		}
+	}
+
+	for (CGTownInstance *t : gs->map->towns)
+	{
 		if (t->hasBonusOfType (BonusType::DARKNESS))
 		{
 			for (auto & player : gs->players)
 			{
 				if (getPlayerStatus(player.first) == EPlayerStatus::INGAME &&
 					getPlayerRelations(player.first, t->tempOwner) == PlayerRelations::ENEMIES)
-					changeFogOfWar(t->getSightCenter(), t->getFirstBonus(Selector::type()(BonusType::DARKNESS))->val, player.first, ETileVisibility::HIDDEN);
+					changeFogOfWar(t->getSightCenter(), t->valOfBonuses(BonusType::DARKNESS), player.first, ETileVisibility::HIDDEN);
 			}
 		}
 	}
@@ -924,70 +684,14 @@
 		SetAvailableArtifacts saa;
 		saa.id = ObjectInstanceID::NONE;
 		pickAllowedArtsSet(saa.arts, getRandomGenerator());
-		sendAndApply(&saa);
+		sendAndApply(saa);
 	}
-	sendAndApply(&n);
-
-	if (newWeek)
-	{
-		//spawn wandering monsters
-		if (newMonth && (n.specialWeek == NewTurn::DOUBLE_GROWTH || n.specialWeek == NewTurn::DEITYOFFIRE))
-		{
-			spawnWanderingMonsters(n.creatureid);
-		}
 
-		//new week info popup
-		if (!firstTurn)
-		{
-			InfoWindow iw;
-			switch (n.specialWeek)
-			{
-				case NewTurn::DOUBLE_GROWTH:
-					iw.text.appendLocalString(EMetaText::ARRAY_TXT, 131);
-					iw.text.replaceNameSingular(n.creatureid);
-					iw.text.replaceNameSingular(n.creatureid);
-					break;
-				case NewTurn::PLAGUE:
-					iw.text.appendLocalString(EMetaText::ARRAY_TXT, 132);
-					break;
-				case NewTurn::BONUS_GROWTH:
-					iw.text.appendLocalString(EMetaText::ARRAY_TXT, 134);
-					iw.text.replaceNameSingular(n.creatureid);
-					iw.text.replaceNameSingular(n.creatureid);
-					break;
-				case NewTurn::DEITYOFFIRE:
-					iw.text.appendLocalString(EMetaText::ARRAY_TXT, 135);
-					iw.text.replaceNameSingular(CreatureID::IMP); //%s imp
-					iw.text.replaceNameSingular(CreatureID::IMP); //%s imp
-					iw.text.replacePositiveNumber(15);//%+d 15
-					iw.text.replaceNameSingular(CreatureID::FAMILIAR); //%s familiar
-					iw.text.replacePositiveNumber(15);//%+d 15
-					break;
-				default:
-					if (newMonth)
-					{
-						iw.text.appendLocalString(EMetaText::ARRAY_TXT, (130));
-						iw.text.replaceLocalString(EMetaText::ARRAY_TXT, getRandomGenerator().nextInt(32, 41));
-					}
-					else
-					{
-						iw.text.appendLocalString(EMetaText::ARRAY_TXT, (133));
-						iw.text.replaceLocalString(EMetaText::ARRAY_TXT, getRandomGenerator().nextInt(43, 57));
-					}
-			}
-			for (auto & elem : gs->players)
-			{
-				iw.player = elem.first;
-				sendAndApply(&iw);
-			}
-		}
-	}
+	newTurnProcessor->onNewTurn();
 
 	if (!firstTurn)
 		checkVictoryLossConditionsForAll(); // check for map turn limit
 
-	logGlobal->trace("Info about turn %d has been sent!", n.day);
-	handleTimeEvents();
 	//call objects
 	for (auto & elem : gs->map->objects)
 	{
@@ -1067,7 +771,7 @@
 		}
 	}
 	if (!cs.spells.empty())
-		sendAndApply(&cs);
+		sendAndApply(cs);
 }
 
 bool CGameHandler::removeObject(const CGObjectInstance * obj, const PlayerColor & initiator)
@@ -1081,9 +785,9 @@
 	RemoveObject ro;
 	ro.objectID = obj->id;
 	ro.initiator = initiator;
-	sendAndApply(&ro);
+	sendAndApply(ro);
 
-	checkVictoryLossConditionsForAll(); //eg if monster escaped (removing objs after battle is done dircetly by endBattle, not this function)
+	checkVictoryLossConditionsForAll(); //e.g. if monster escaped (removing objs after battle is done directly by endBattle, not this function)
 	return true;
 }
 
@@ -1100,7 +804,7 @@
 		return false;
 	}
 
-	logGlobal->trace("Player %d (%s) wants to move hero %d from %s to %s", asker, asker.toString(), hid.getNum(), h->pos.toString(), dst.toString());
+	logGlobal->trace("Player %d (%s) wants to move hero %d from %s to %s", asker, asker.toString(), hid.getNum(), h->anchorPos().toString(), dst.toString());
 	const int3 hmpos = h->convertToVisitablePos(dst);
 
 	if (!gs->map->isInTheMap(hmpos))
@@ -1126,9 +830,8 @@
 
 	const bool embarking = !h->boat && objectToVisit && objectToVisit->ID == Obj::BOAT;
 	const bool disembarking = h->boat
-		&& t.terType->isLand()
-		&& (dst == h->pos
-			|| (h->boat->layer == EPathfindingLayer::SAIL && !t.blocked));
+		&& t.isLand()
+		&& (dst == h->pos || (h->boat->layer == EPathfindingLayer::SAIL && !t.blocked()));
 
 	//result structure for start - movement failed, no move points used
 	TryMoveHero tmh;
@@ -1139,22 +842,22 @@
 	tmh.movePoints = h->movementPointsRemaining();
 
 	//check if destination tile is available
-	auto pathfinderHelper = std::make_unique<CPathfinderHelper>(gs, h, PathfinderOptions());
+	auto pathfinderHelper = std::make_unique<CPathfinderHelper>(gs, h, PathfinderOptions(this));
 	auto ti = pathfinderHelper->getTurnInfo();
 
 	const bool canFly = pathfinderHelper->hasBonusOfType(BonusType::FLYING_MOVEMENT) || (h->boat && h->boat->layer == EPathfindingLayer::AIR);
 	const bool canWalkOnSea = pathfinderHelper->hasBonusOfType(BonusType::WATER_WALKING) || (h->boat && h->boat->layer == EPathfindingLayer::WATER);
 	const int cost = pathfinderHelper->getMovementCost(h->visitablePos(), hmpos, nullptr, nullptr, h->movementPointsRemaining());
 
-	const bool movingOntoObstacle = t.blocked && !t.visitable;
+	const bool movingOntoObstacle = t.blocked() && !t.visitable();
 	const bool objectCoastVisitable = objectToVisit && objectToVisit->isCoastVisitable();
-	const bool movingOntoWater = !h->boat && t.terType->isWater() && !objectCoastVisitable;
+	const bool movingOntoWater = !h->boat && t.isWater() && !objectCoastVisitable;
 
 	const auto complainRet = [&](const std::string & message)
 	{
 		//send info about movement failure
 		complain(message);
-		sendAndApply(&tmh);
+		sendAndApply(tmh);
 		return false;
 	};
 
@@ -1172,18 +875,18 @@
 
 	//it's a rock or blocked and not visitable tile
 	//OR hero is on land and dest is water and (there is not present only one object - boat)
-	if (!t.terType->isPassable() || (movingOntoObstacle && !canFly))
+	if (!t.getTerrain()->isPassable() || (movingOntoObstacle && !canFly))
 		return complainRet("Cannot move hero, destination tile is blocked!");
 
 	//hero is not on boat/water walking and dst water tile doesn't contain boat/hero (objs visitable from land) -> we test back cause boat may be on top of another object (#276)
 	if(movingOntoWater && !canFly && !canWalkOnSea)
 		return complainRet("Cannot move hero, destination tile is on water!");
 
-	if(h->boat && h->boat->layer == EPathfindingLayer::SAIL && t.terType->isLand() && t.blocked)
+	if(h->boat && h->boat->layer == EPathfindingLayer::SAIL && t.isLand() && t.blocked())
 		return complainRet("Cannot disembark hero, tile is blocked!");
 
 	if(distance(h->pos, dst) >= 1.5 && movementMode == EMovementMode::STANDARD)
-		return complainRet("Tiles are not neighboring!");
+		return complainRet("Tiles " + h->pos.toString()+ " and "+ dst.toString() +" are not neighboring!");
 
 	if(h->inTownGarrison)
 		return complainRet("Can not move garrisoned hero!");
@@ -1191,7 +894,7 @@
 	if(h->movementPointsRemaining() < cost && dst != h->pos && movementMode == EMovementMode::STANDARD)
 		return complainRet("Hero doesn't have any movement points left!");
 
-	if (transit && !canFly && !(canWalkOnSea && t.terType->isWater()) && !CGTeleport::isTeleport(objectToVisit))
+	if (transit && !canFly && !(canWalkOnSea && t.isWater()) && !CGTeleport::isTeleport(objectToVisit))
 		return complainRet("Hero cannot transit over this tile!");
 
 	//several generic blocks of code
@@ -1199,7 +902,7 @@
 	// should be called if hero changes tile but before applying TryMoveHero package
 	auto leaveTile = [&]()
 	{
-		for (CGObjectInstance *obj : gs->map->getTile(int3(h->pos.x-1, h->pos.y, h->pos.z)).visitableObjects)
+		for (CGObjectInstance *obj : gs->map->getTile(h->visitablePos()).visitableObjects)
 		{
 			obj->onHeroLeave(h);
 		}
@@ -1221,7 +924,7 @@
 			tmh.attackedFrom = std::make_optional(guardPos);
 
 		tmh.result = result;
-		sendAndApply(&tmh);
+		sendAndApply(tmh);
 
 		if (visitDest == VISIT_DEST && objectToVisit && objectToVisit->id == h->id)
 		{ // Hero should be always able to visit any object he is staying on even if there are guards around
@@ -1282,19 +985,18 @@
 		if (blockingVisit()) // e.g. hero on the other side of teleporter
 			return true;
 
-		EGuardLook guardsCheck = (VLC->settings()->getBoolean(EGameSettings::DIMENSION_DOOR_TRIGGERS_GUARDS) && movementMode == EMovementMode::DIMENSION_DOOR)
+		EGuardLook guardsCheck = (getSettings().getBoolean(EGameSettings::DIMENSION_DOOR_TRIGGERS_GUARDS) && movementMode == EMovementMode::DIMENSION_DOOR)
 			? CHECK_FOR_GUARDS
 			: IGNORE_GUARDS;
 
 		doMove(TryMoveHero::TELEPORTATION, guardsCheck, DONT_VISIT_DEST, LEAVING_TILE);
 
 		// visit town for town portal \ castle gates
-		// do not use generic visitObjectOnTile to avoid double-teleporting
-		// if this moveHero call was triggered by teleporter
+		// do not visit any other objects, e.g. monoliths to avoid double-teleporting
 		if (objectToVisit)
 		{
 			if (CGTownInstance * town = dynamic_cast<CGTownInstance *>(objectToVisit))
-				town->onHeroVisit(h);
+				objectVisited(town, h);
 		}
 
 		return true;
@@ -1314,7 +1016,7 @@
 			if (CGTeleport::isTeleport(objectToVisit))
 				visitDest = DONT_VISIT_DEST;
 
-			if (canFly || (canWalkOnSea && t.terType->isWater()))
+			if (canFly || (canWalkOnSea && t.isWater()))
 			{
 				lookForGuards = IGNORE_GUARDS;
 				visitDest = DONT_VISIT_DEST;
@@ -1328,6 +1030,7 @@
 
 		turnTimerHandler->setEndTurnAllowed(h->getOwner(), !movingOntoWater && !movingOntoObstacle);
 		doMove(TryMoveHero::SUCCESS, lookForGuards, visitDest, LEAVING_TILE);
+		gs->statistic.accumulatedValues[asker].movementPointsUsed += tmh.movePoints;
 		return true;
 	}
 }
@@ -1344,7 +1047,7 @@
 	if (((h->getOwner() != t->getOwner())
 		&& complain("Cannot teleport hero to another player"))
 
-	|| (from->town->faction->getId() != t->town->faction->getId()
+	|| (from->getFactionID() != t->getFactionID()
 		&& complain("Source town and destination town should belong to the same faction"))
 
 	|| ((!from || !from->hasBuilt(BuildingSubID::CASTLE_GATE))
@@ -1371,43 +1074,34 @@
 	const CGTownInstance * town = dynamic_cast<const CGTownInstance *>(obj);
 	if (town) //town captured
 	{
+		gs->statistic.accumulatedValues[owner].lastCapturedTownDay = gs->getDate(Date::DAY);
+
 		if (owner.isValidPlayer()) //new owner is real player
 		{
 			if (town->hasBuilt(BuildingSubID::PORTAL_OF_SUMMONING))
 				setPortalDwelling(town, true, false);
 		}
-
-		if (oldOwner.isValidPlayer()) //old owner is real player
-		{
-			if (getPlayerState(oldOwner)->towns.empty() && getPlayerState(oldOwner)->status != EPlayerStatus::LOSER) //previous player lost last town
-			{
-				InfoWindow iw;
-				iw.player = oldOwner;
-				iw.text.appendLocalString(EMetaText::GENERAL_TXT, 6); //%s, you have lost your last town. If you do not conquer another town in the next week, you will be eliminated.
-				iw.text.replaceName(oldOwner);
-				sendAndApply(&iw);
-			}
-		}
 	}
 
-	const PlayerState * p = getPlayerState(owner);
-
-	if ((obj->ID == Obj::CREATURE_GENERATOR1 || obj->ID == Obj::CREATURE_GENERATOR4) && p && p->dwellings.size()==1)//first dwelling captured
+	if ((obj->ID == Obj::CREATURE_GENERATOR1 || obj->ID == Obj::CREATURE_GENERATOR4))
 	{
-		for (const CGTownInstance * t : getPlayerState(owner)->towns)
+		if (owner.isValidPlayer())
 		{
-			if (t->hasBuilt(BuildingSubID::PORTAL_OF_SUMMONING))
-				setPortalDwelling(t);//set initial creatures for all portals of summoning
+			for (const CGTownInstance * t : getPlayerState(owner)->getTowns())
+			{
+				if (t->hasBuilt(BuildingSubID::PORTAL_OF_SUMMONING))
+					setPortalDwelling(t);//set initial creatures for all portals of summoning
+			}
 		}
 	}
 }
 
-void CGameHandler::showBlockingDialog(BlockingDialog *iw)
+void CGameHandler::showBlockingDialog(const IObjectInterface * caller, BlockingDialog *iw)
 {
-	auto dialogQuery = std::make_shared<CBlockingDialogQuery>(this, *iw);
+	auto dialogQuery = std::make_shared<CBlockingDialogQuery>(this, caller, *iw);
 	queries->addQuery(dialogQuery);
 	iw->queryID = dialogQuery->queryID;
-	sendToAllClients(iw);
+	sendToAllClients(*iw);
 }
 
 void CGameHandler::showTeleportDialog(TeleportDialog *iw)
@@ -1415,7 +1109,7 @@
 	auto dialogQuery = std::make_shared<CTeleportDialogQuery>(this, *iw);
 	queries->addQuery(dialogQuery);
 	iw->queryID = dialogQuery->queryID;
-	sendToAllClients(iw);
+	sendToAllClients(*iw);
 }
 
 void CGameHandler::giveResource(PlayerColor player, GameResID which, int val) //TODO: cap according to Bersy's suggestion
@@ -1433,7 +1127,7 @@
 	sr.abs = false;
 	sr.player = player;
 	sr.res = resources;
-	sendAndApply(&sr);
+	sendAndApply(sr);
 }
 
 void CGameHandler::giveCreatures(const CArmedInstance *obj, const CGHeroInstance * h, const CCreatureSet &creatures, bool remove)
@@ -1445,7 +1139,7 @@
 	//first we move creatures to give to make them army of object-source
 	for (auto & elem : creatures.Slots())
 	{
-		addToSlot(StackLocation(obj, obj->getSlotFor(elem.second->type)), elem.second->type, elem.second->count);
+		addToSlot(StackLocation(obj, obj->getSlotFor(elem.second->getCreature())), elem.second->getCreature(), elem.second->count);
 	}
 
 	tryJoiningArmy(obj, h, remove, true);
@@ -1466,7 +1160,7 @@
 			bool foundSth = false;
 			for (auto i = obj->Slots().begin(); i != obj->Slots().end(); i++)
 			{
-				if (i->second->type == sbd.type)
+				if (i->second->getType() == sbd.getType())
 				{
 					TQuantity take = std::min(sbd.count - collected, i->second->count); //collect as much cres as we can
 					changeStackCount(StackLocation(obj, i->first), -take, false);
@@ -1487,13 +1181,15 @@
 
 void CGameHandler::heroVisitCastle(const CGTownInstance * obj, const CGHeroInstance * hero)
 {
-	HeroVisitCastle vc;
-	vc.hid = hero->id;
-	vc.tid = obj->id;
-	vc.flags |= 1;
-	sendAndApply(&vc);
+	if (obj->visitingHero != hero && obj->garrisonHero != hero)
+	{
+		HeroVisitCastle vc;
+		vc.hid = hero->id;
+		vc.tid = obj->id;
+		vc.flags |= 1;
+		sendAndApply(vc);
+	}
 	visitCastleObjects(obj, hero);
-	giveSpells (obj, hero);
 
 	if (obj->visitingHero && obj->garrisonHero)
 		useScholarSkill(obj->visitingHero->id, obj->garrisonHero->id);
@@ -1502,8 +1198,28 @@
 
 void CGameHandler::visitCastleObjects(const CGTownInstance * t, const CGHeroInstance * h)
 {
-	for (auto building : t->bonusingBuildings)
-		building->onHeroVisit(h);
+	std::vector<const CGHeroInstance * > visitors;
+	visitors.push_back(h);
+	visitCastleObjects(t, visitors);
+}
+
+void CGameHandler::visitCastleObjects(const CGTownInstance * t, std::vector<const CGHeroInstance * > visitors)
+{
+	std::vector<BuildingID> buildingsToVisit;
+	for (auto const & hero : visitors)
+		giveSpells (t, hero);
+
+	for (auto & building : t->rewardableBuildings)
+	{
+		if (!t->getTown()->buildings.at(building.first)->manualHeroVisit && t->hasBuilt(building.first))
+			buildingsToVisit.push_back(building.first);
+	}
+
+	if (!buildingsToVisit.empty())
+	{
+		auto visitQuery = std::make_shared<TownBuildingVisitQuery>(this, t, visitors, buildingsToVisit);
+		queries->addQuery(visitQuery);
+	}
 }
 
 void CGameHandler::stopHeroVisitCastle(const CGTownInstance * obj, const CGHeroInstance * hero)
@@ -1511,14 +1227,20 @@
 	HeroVisitCastle vc;
 	vc.hid = hero->id;
 	vc.tid = obj->id;
-	sendAndApply(&vc);
+	sendAndApply(vc);
 }
 
-void CGameHandler::removeArtifact(const ArtifactLocation &al)
+void CGameHandler::removeArtifact(const ArtifactLocation & al)
 {
-	EraseArtifact ea;
-	ea.al = al;
-	sendAndApply(&ea);
+	removeArtifact(al.artHolder, {al.slot});
+}
+
+void CGameHandler::removeArtifact(const ObjectInstanceID & srcId, const std::vector<ArtifactPosition> & slotsPack)
+{
+	BulkEraseArtifacts ea;
+	ea.artHolder = srcId;
+	ea.posPack.insert(ea.posPack.end(), slotsPack.begin(), slotsPack.end());
+	sendAndApply(ea);
 }
 
 void CGameHandler::changeSpells(const CGHeroInstance * hero, bool give, const std::set<SpellID> &spells)
@@ -1527,17 +1249,27 @@
 	cs.hid = hero->id;
 	cs.spells = spells;
 	cs.learn = give;
-	sendAndApply(&cs);
+	sendAndApply(cs);
+}
+
+void CGameHandler::setResearchedSpells(const CGTownInstance * town, int level, const std::vector<SpellID> & spells, bool accepted)
+{
+	SetResearchedSpells cs;
+	cs.tid = town->id;
+	cs.spells = spells;
+	cs.level = level;
+	cs.accepted = accepted;
+	sendAndApply(cs);
 }
 
 void CGameHandler::giveHeroBonus(GiveBonus * bonus)
 {
-	sendAndApply(bonus);
+	sendAndApply(*bonus);
 }
 
 void CGameHandler::setMovePoints(SetMovePoints * smp)
 {
-	sendAndApply(smp);
+	sendAndApply(*smp);
 }
 
 void CGameHandler::setMovePoints(ObjectInstanceID hid, int val, bool absolute)
@@ -1546,7 +1278,7 @@
 	smp.hid = hid;
 	smp.val = val;
 	smp.absolute = absolute;
-	sendAndApply(&smp);
+	sendAndApply(smp);
 }
 
 void CGameHandler::setManaPoints(ObjectInstanceID hid, int val)
@@ -1555,7 +1287,7 @@
 	sm.hid = hid;
 	sm.val = val;
 	sm.absolute = true;
-	sendAndApply(&sm);
+	sendAndApply(sm);
 }
 
 void CGameHandler::giveHero(ObjectInstanceID id, PlayerColor player, ObjectInstanceID boatId)
@@ -1564,7 +1296,7 @@
 	gh.id = id;
 	gh.player = player;
 	gh.boatId = boatId;
-	sendAndApply(&gh);
+	sendAndApply(gh);
 
 	//Reveal fow around new hero, especially released from Prison
 	auto h = getHero(id);
@@ -1577,7 +1309,7 @@
 	cop.objid = objid;
 	cop.nPos = newPos;
 	cop.initiator = initiator;
-	sendAndApply(&cop);
+	sendAndApply(cop);
 }
 
 void CGameHandler::useScholarSkill(ObjectInstanceID fromHero, ObjectInstanceID toHero)
@@ -1647,7 +1379,7 @@
 			}
 			iw.text.appendLocalString(EMetaText::GENERAL_TXT, 142);//from %s
 			iw.text.replaceTextID(h2->getNameTextID());
-			sendAndApply(&cs2);
+			sendAndApply(cs2);
 		}
 
 		if (!cs1.spells.empty() && !cs2.spells.empty())
@@ -1675,9 +1407,9 @@
 			}
 			iw.text.appendLocalString(EMetaText::GENERAL_TXT, 148);//from %s
 			iw.text.replaceTextID(h2->getNameTextID());
-			sendAndApply(&cs1);
+			sendAndApply(cs1);
 		}
-		sendAndApply(&iw);
+		sendAndApply(iw);
 	}
 }
 
@@ -1694,43 +1426,43 @@
 		hex.player = h1->getOwner();
 		hex.hero1 = hero1;
 		hex.hero2 = hero2;
-		sendAndApply(&hex);
+		sendAndApply(hex);
 
 		useScholarSkill(hero1,hero2);
 		queries->addQuery(exchange);
 	}
 }
 
-void CGameHandler::sendToAllClients(CPackForClient * pack)
+void CGameHandler::sendToAllClients(CPackForClient & pack)
 {
-	logNetwork->trace("\tSending to all clients: %s", typeid(*pack).name());
+	logNetwork->trace("\tSending to all clients: %s", typeid(pack).name());
 	for (auto c : lobby->activeConnections)
 		c->sendPack(pack);
 }
 
-void CGameHandler::sendAndApply(CPackForClient * pack)
+void CGameHandler::sendAndApply(CPackForClient & pack)
 {
 	sendToAllClients(pack);
 	gs->apply(pack);
-	logNetwork->trace("\tApplied on gs: %s", typeid(*pack).name());
+	logNetwork->trace("\tApplied on gs: %s", typeid(pack).name());
 }
 
-void CGameHandler::sendAndApply(CGarrisonOperationPack * pack)
+void CGameHandler::sendAndApply(CGarrisonOperationPack & pack)
 {
-	sendAndApply(static_cast<CPackForClient *>(pack));
+	sendAndApply(static_cast<CPackForClient &>(pack));
 	checkVictoryLossConditionsForAll();
 }
 
-void CGameHandler::sendAndApply(SetResources * pack)
+void CGameHandler::sendAndApply(SetResources & pack)
 {
-	sendAndApply(static_cast<CPackForClient *>(pack));
-	checkVictoryLossConditionsForPlayer(pack->player);
+	sendAndApply(static_cast<CPackForClient &>(pack));
+	checkVictoryLossConditionsForPlayer(pack.player);
 }
 
-void CGameHandler::sendAndApply(NewStructures * pack)
+void CGameHandler::sendAndApply(NewStructures & pack)
 {
-	sendAndApply(static_cast<CPackForClient *>(pack));
-	checkVictoryLossConditionsForPlayer(getTown(pack->tid)->tempOwner);
+	sendAndApply(static_cast<CPackForClient &>(pack));
+	checkVictoryLossConditionsForPlayer(getTown(pack.tid)->tempOwner);
 }
 
 bool CGameHandler::isPlayerOwns(CPackForServer * pack, ObjectInstanceID id)
@@ -1741,7 +1473,7 @@
 void CGameHandler::throwNotAllowedAction(CPackForServer * pack)
 {
 	if(pack->c)
-		playerMessages->sendSystemMessage(pack->c, "You are not allowed to perform this action!");
+		playerMessages->sendSystemMessage(pack->c, MetaString::createFromTextID("vcmi.server.errors.notAllowed"));
 
 	logNetwork->error("Player is not allowed to perform this action!");
 	throw ExceptionNotAllowedAction();
@@ -1749,12 +1481,13 @@
 
 void CGameHandler::wrongPlayerMessage(CPackForServer * pack, PlayerColor expectedplayer)
 {
-	std::ostringstream oss;
-	oss << "You were identified as player " << pack->player << " while expecting " << expectedplayer;
-	logNetwork->error(oss.str());
+	auto str = MetaString::createFromTextID("vcmi.server.errors.wrongIdentified");
+	str.appendName(pack->player);
+	str.appendName(expectedplayer);
+	logNetwork->error(str.toString());
 
 	if(pack->c)
-		playerMessages->sendSystemMessage(pack->c, oss.str());
+		playerMessages->sendSystemMessage(pack->c, str);
 }
 
 void CGameHandler::throwIfWrongOwner(CPackForServer * pack, ObjectInstanceID id)
@@ -1837,16 +1570,18 @@
 	catch(const ModIncompatibility & e)
 	{
 		logGlobal->error("Failed to load game: %s", e.what());
-		std::string errorMsg;
+		MetaString errorMsg;
 		if(!e.whatMissing().empty())
 		{
-			errorMsg += VLC->generaltexth->translate("vcmi.server.errors.modsToEnable") + '\n';
-			errorMsg += e.whatMissing();
+			errorMsg.appendTextID("vcmi.server.errors.modsToEnable");
+			errorMsg.appendRawString("\n");
+			errorMsg.appendRawString(e.whatMissing());
 		}
 		if(!e.whatExcessive().empty())
 		{
-			errorMsg += VLC->generaltexth->translate("vcmi.server.errors.modsToDisable") + '\n';
-			errorMsg += e.whatExcessive();
+			errorMsg.appendTextID("vcmi.server.errors.modsToDisable");
+			errorMsg.appendRawString("\n");
+			errorMsg.appendRawString(e.whatExcessive());
 		}
 		lobby->announceMessage(errorMsg);
 		return false;
@@ -1857,14 +1592,17 @@
 		MetaString errorMsg;
 		errorMsg.appendTextID("vcmi.server.errors.unknownEntity");
 		errorMsg.replaceRawString(e.identifierName);
-		lobby->announceMessage(errorMsg.toString());//FIXME: should be localized on client side
+		lobby->announceMessage(errorMsg);
 		return false;
 	}
 
 	catch(const std::exception & e)
 	{
 		logGlobal->error("Failed to load game: %s", e.what());
-		lobby->announceMessage(std::string("Failed to load game: ") + e.what());
+		auto str = MetaString::createFromTextID("vcmi.broadcast.failedLoadGame");
+		str.appendRawString(": ");
+		str.appendRawString(e.what());
+		lobby->announceMessage(str);
 		return false;
 	}
 	gs->preInit(VLC, this);
@@ -1912,7 +1650,7 @@
 		if(actualAmount <= howMany)
 			break;
 	}
-	sendAndApply(&bulkRS);
+	sendAndApply(bulkRS);
 	return true;
 }
 
@@ -1954,7 +1692,7 @@
 		rs.count = creatureSet.getStackCount(slot);
 		bulkRS.moves.push_back(rs);
 	}
-	sendAndApply(&bulkRS);
+	sendAndApply(bulkRS);
 	return true;
 }
 
@@ -2041,7 +1779,7 @@
 		rs.count = move.second.second;
 		bulkRS.moves.push_back(rs);
 	}
-	sendAndApply(&bulkRS);
+	sendAndApply(bulkRS);
 	return true;
 }
 
@@ -2123,18 +1861,14 @@
 		complain((boost::format("Failure: totalCreatures=%d but check=%d") % totalCreatures % check).str());
 		return false;
 	}
-	sendAndApply(&bulkSRS);
+	sendAndApply(bulkSRS);
 	return true;
 }
 
 bool CGameHandler::arrangeStacks(ObjectInstanceID id1, ObjectInstanceID id2, ui8 what, SlotID p1, SlotID p2, si32 val, PlayerColor player)
 {
-	const CArmedInstance * s1 = static_cast<const CArmedInstance *>(getObjInstance(id1));
-	const CArmedInstance * s2 = static_cast<const CArmedInstance *>(getObjInstance(id2));
-	const CCreatureSet & S1 = *s1;
-	const CCreatureSet & S2 = *s2;
-	StackLocation sl1(s1, p1);
-	StackLocation sl2(s2, p2);
+	const CArmedInstance * s1 = static_cast<const CArmedInstance *>(getObj(id1));
+	const CArmedInstance * s2 = static_cast<const CArmedInstance *>(getObj(id2));
 
 	if (s1 == nullptr || s2 == nullptr)
 	{
@@ -2142,6 +1876,11 @@
 		return false;
 	}
 
+	const CCreatureSet & S1 = *s1;
+	const CCreatureSet & S2 = *s2;
+	StackLocation sl1(s1, p1);
+	StackLocation sl2(s2, p2);
+
 	if (!sl1.slot.validSlot()  ||  !sl2.slot.validSlot())
 	{
 		complain(complainInvalidSlot);
@@ -2303,12 +2042,12 @@
 	const CGTownInstance * t = getTown(tid);
 	if(!t)
 		COMPLAIN_RETF("No such town (ID=%s)!", tid);
-	if(!t->town->buildings.count(requestedID))
-		COMPLAIN_RETF("Town of faction %s does not have info about building ID=%s!", t->town->faction->getNameTranslated() % requestedID);
+	if(!t->getTown()->buildings.count(requestedID))
+		COMPLAIN_RETF("Town of faction %s does not have info about building ID=%s!", t->getFaction()->getNameTranslated() % requestedID);
 	if(t->hasBuilt(requestedID))
-		COMPLAIN_RETF("Building %s is already built in %s", t->town->buildings.at(requestedID)->getNameTranslated() % t->getNameTranslated());
+		COMPLAIN_RETF("Building %s is already built in %s", t->getTown()->buildings.at(requestedID)->getNameTranslated() % t->getNameTranslated());
 
-	const CBuilding * requestedBuilding = t->town->buildings.at(requestedID);
+	const CBuilding * requestedBuilding = t->getTown()->buildings.at(requestedID);
 
 	//Vector with future list of built building and buildings in auto-mode that are not yet built.
 	std::vector<const CBuilding*> remainingAutoBuildings;
@@ -2345,18 +2084,18 @@
 	{
 		if(buildingID >= BuildingID::DWELL_FIRST) //dwelling
 		{
-			int level = (buildingID - BuildingID::DWELL_FIRST) % GameConstants::CREATURES_PER_TOWN;
-			int upgradeNumber = (buildingID - BuildingID::DWELL_FIRST) / GameConstants::CREATURES_PER_TOWN;
+			int level = BuildingID::getLevelFromDwelling(buildingID);
+			int upgradeNumber = BuildingID::getUpgradedFromDwelling(buildingID);
 
-			if(upgradeNumber >= t->town->creatures.at(level).size())
+			if(upgradeNumber >= t->getTown()->creatures.at(level).size())
 			{
-				complain(boost::str(boost::format("Error ecountered when building dwelling (bid=%s):"
+				complain(boost::str(boost::format("Error encountered when building dwelling (bid=%s):"
 													"no creature found (upgrade number %d, level %d!")
 												% buildingID % upgradeNumber % level));
 				return;
 			}
 
-			const CCreature * crea = t->town->creatures.at(level).at(upgradeNumber).toCreature();
+			const CCreature * crea = t->getTown()->creatures.at(level).at(upgradeNumber).toCreature();
 
 			SetAvailableCreatures ssi;
 			ssi.tid = t->id;
@@ -2364,9 +2103,9 @@
 			if (ssi.creatures[level].second.empty()) // first creature in a dwelling
 				ssi.creatures[level].first = crea->getGrowth();
 			ssi.creatures[level].second.push_back(crea->getId());
-			sendAndApply(&ssi);
+			sendAndApply(ssi);
 		}
-		if(t->town->buildings.at(buildingID)->subId == BuildingSubID::PORTAL_OF_SUMMONING)
+		if(t->getTown()->buildings.at(buildingID)->subId == BuildingSubID::PORTAL_OF_SUMMONING)
 		{
 			setPortalDwelling(t);
 		}
@@ -2377,9 +2116,9 @@
 	{
 		auto isMageGuild = (buildingID <= BuildingID::MAGES_GUILD_5 && buildingID >= BuildingID::MAGES_GUILD_1);
 		auto isLibrary = isMageGuild ? false
-			: t->town->buildings.at(buildingID)->subId == BuildingSubID::EBuildingSubID::LIBRARY;
+			: t->getTown()->buildings.at(buildingID)->subId == BuildingSubID::EBuildingSubID::LIBRARY;
 
-		if(isMageGuild || isLibrary || (t->getFaction() == ETownType::CONFLUX && buildingID == BuildingID::GRAIL))
+		if(isMageGuild || isLibrary || (t->getFactionID() == ETownType::CONFLUX && buildingID == BuildingID::GRAIL))
 		{
 			if(t->visitingHero)
 				giveSpells(t,t->visitingHero);
@@ -2389,13 +2128,13 @@
 	};
 
 	//Checks if all requirements will be met with expected building list "buildingsThatWillBe"
-	auto areRequirementsFullfilled = [&](const BuildingID & buildID)
+	auto areRequirementsFulfilled = [&](const BuildingID & buildID)
 	{
 		return buildingsThatWillBe.count(buildID);
 	};
 
 	//Init the vectors
-	for(auto & build : t->town->buildings)
+	for(auto & build : t->getTown()->buildings)
 	{
 		if(t->hasBuilt(build.first))
 		{
@@ -2411,7 +2150,7 @@
 	//Prepare structure (list of building ids will be filled later)
 	NewStructures ns;
 	ns.tid = tid;
-	ns.builded = force ? t->builded : (t->builded+1);
+	ns.built = force ? t->built : (t->built+1);
 
 	std::queue<const CBuilding*> buildingsToAdd;
 	buildingsToAdd.push(requestedBuilding);
@@ -2429,7 +2168,7 @@
 		{
 			auto actualRequirements = t->genBuildingRequirements(autoBuilding->bid);
 
-			if(actualRequirements.test(areRequirementsFullfilled))
+			if(actualRequirements.test(areRequirementsFulfilled))
 				buildingsToAdd.push(autoBuilding);
 		}
 	}
@@ -2440,10 +2179,13 @@
 
 	//Take cost
 	if(!force)
+	{
 		giveResources(t->tempOwner, -requestedBuilding->resources);
+		gs->statistic.accumulatedValues[t->tempOwner].spentResourcesForBuildings += requestedBuilding->resources;
+	}
 
 	//We know what has been built, apply changes. Do this as final step to properly update town window
-	sendAndApply(&ns);
+	sendAndApply(ns);
 
 	//Other post-built events. To some logic like giving spells to work gamestate changes for new building must be already in place!
 	for(auto builtID : ns.bid)
@@ -2452,26 +2194,67 @@
 	// now when everything is built - reveal tiles for lookout tower
 	changeFogOfWar(t->getSightCenter(), t->getSightRadius(), t->getOwner(), ETileVisibility::REVEALED);
 
-	if(t->garrisonHero) //garrison hero first - consistent with original H3 Mana Vortex and Battle Scholar Academy levelup windows order
-		visitCastleObjects(t, t->garrisonHero);
-	if(t->visitingHero)
-		visitCastleObjects(t, t->visitingHero);
+	if (!force)
+	{
+		//garrison hero first - consistent with original H3 Mana Vortex and Battle Scholar Academy levelup windows order
+		std::vector<const CGHeroInstance *> visitors;
+		if (t->garrisonHero)
+			visitors.push_back(t->garrisonHero);
+		if (t->visitingHero)
+			visitors.push_back(t->visitingHero);
+
+		if (!visitors.empty())
+			visitCastleObjects(t, visitors);
+	}
 
 	checkVictoryLossConditionsForPlayer(t->tempOwner);
 	return true;
 }
 
+bool CGameHandler::visitTownBuilding(ObjectInstanceID tid, BuildingID bid)
+{
+	const CGTownInstance * t = getTown(tid);
+
+	if(!t->hasBuilt(bid))
+		return false;
+
+	auto subID = t->getTown()->buildings.at(bid)->subId;
+
+	if(subID == BuildingSubID::EBuildingSubID::BANK)
+	{
+		TResources res;
+		res[EGameResID::GOLD] = 2500;
+		giveResources(t->getOwner(), res);
+
+		setObjPropertyValue(t->id, ObjProperty::BONUS_VALUE_SECOND, 2500);
+		return true;
+	}
+
+	if (t->rewardableBuildings.count(bid) && t->visitingHero && t->getTown()->buildings.at(bid)->manualHeroVisit)
+	{
+		std::vector<BuildingID> buildingsToVisit;
+		std::vector<const CGHeroInstance*> visitors;
+		buildingsToVisit.push_back(bid);
+		visitors.push_back(t->visitingHero);
+		auto visitQuery = std::make_shared<TownBuildingVisitQuery>(this, t, visitors, buildingsToVisit);
+		queries->addQuery(visitQuery);
+		return true;
+	}
+
+	return true;
+}
+
 bool CGameHandler::razeStructure (ObjectInstanceID tid, BuildingID bid)
 {
 ///incomplete, simply erases target building
 	const CGTownInstance * t = getTown(tid);
-	if (!vstd::contains(t->builtBuildings, bid))
+	if(!t->hasBuilt(bid))
 		return false;
 	RazeStructures rs;
 	rs.tid = tid;
 	rs.bid.insert(bid);
 	rs.destroyed = t->destroyed + 1;
-	sendAndApply(&rs);
+	sendAndApply(rs);
 //TODO: Remove dwellers
 // 	if (t->subID == 4 && bid == 17) //Veil of Darkness
 // 	{
@@ -2479,11 +2262,65 @@
 // 		rb.whoID = t->id;
 // 		rb.source = BonusSource::TOWN_STRUCTURE;
 // 		rb.id = 17;
-// 		sendAndApply(&rb);
+// 		sendAndApply(rb);
 // 	}
 	return true;
 }
 
+bool CGameHandler::spellResearch(ObjectInstanceID tid, SpellID spellAtSlot, bool accepted)
+{
+	CGTownInstance *t = gs->getTown(tid);
+
+	if(!getSettings().getBoolean(EGameSettings::TOWNS_SPELL_RESEARCH) && complain("Spell research not allowed!"))
+		return false;
+	if (!t->spellResearchAllowed && complain("Spell research not allowed in this town!"))
+		return false;
+
+	int level = -1;
+	for(int i = 0; i < t->spells.size(); i++)
+		if(vstd::find_pos(t->spells[i], spellAtSlot) != -1)
+			level = i;
+	
+	if(level == -1 && complain("Spell for replacement not found!"))
+		return false;
+
+	auto spells = t->spells.at(level);
+	
+	bool researchLimitExceeded = t->spellResearchCounterDay >= getSettings().getValue(EGameSettings::TOWNS_SPELL_RESEARCH_PER_DAY).Vector()[level].Float();
+	if(researchLimitExceeded && complain("Already researched today!"))
+		return false;
+
+	if(!accepted)
+	{
+		auto it = spells.begin() + t->spellsAtLevel(level, false);
+		std::rotate(it, it + 1, spells.end()); // move to end
+		setResearchedSpells(t, level, spells, accepted);
+		return true;
+	}
+
+	auto costBase = TResources(getSettings().getValue(EGameSettings::TOWNS_SPELL_RESEARCH_COST).Vector()[level]);
+	auto costExponent = getSettings().getValue(EGameSettings::TOWNS_SPELL_RESEARCH_COST_EXPONENT_PER_RESEARCH).Vector()[level].Float();
+	auto cost = costBase * std::pow(t->spellResearchAcceptedCounter + 1, costExponent);
+
+	if(!getPlayerState(t->getOwner())->resources.canAfford(cost) && complain("Spell replacement cannot be afforded!"))
+		return false;
+
+	giveResources(t->getOwner(), -cost);
+
+	std::swap(spells.at(t->spellsAtLevel(level, false)), spells.at(vstd::find_pos(spells, spellAtSlot)));
+	auto it = spells.begin() + t->spellsAtLevel(level, false);
+	std::rotate(it, it + 1, spells.end()); // move to end
+
+	setResearchedSpells(t, level, spells, accepted);
+
+	if(t->visitingHero)
+		giveSpells(t, t->visitingHero);
+	if(t->garrisonHero)
+		giveSpells(t, t->garrisonHero);
+
+	return true;
+}
+
 bool CGameHandler::recruitCreatures(ObjectInstanceID objid, ObjectInstanceID dstid, CreatureID crid, ui32 cram, si32 fromLvl, PlayerColor player)
 {
 	const CGDwelling * dwelling = dynamic_cast<const CGDwelling *>(getObj(objid));
@@ -2542,13 +2379,15 @@
 	}
 
 	//recruit
-	giveResources(army->tempOwner, -(c->getFullRecruitCost() * cram));
+	TResources cost = (c->getFullRecruitCost() * cram);
+	giveResources(army->tempOwner, -cost);
+	gs->statistic.accumulatedValues[army->tempOwner].spentResourcesForArmy += cost;
 
 	SetAvailableCreatures sac;
 	sac.tid = objid;
 	sac.creatures = dwelling->creatures;
 	sac.creatures[level].first -= cram;
-	sendAndApply(&sac);
+	sendAndApply(sac);
 
 	if (warMachine)
 	{
@@ -2559,7 +2398,7 @@
 		COMPLAIN_RET_FALSE_IF(artId == ArtifactID::CATAPULT, "Catapult cannot be recruited!");
 		COMPLAIN_RET_FALSE_IF(nullptr == art, "Invalid war machine artifact");
 
-		return giveHeroNewArtifact(hero, art);
+		return giveHeroNewArtifact(hero, artId, ArtifactPosition::FIRST_AVAILABLE);
 	}
 	else
 	{
@@ -2595,6 +2434,7 @@
 
 	//take resources
 	giveResources(player, -totalCost);
+	gs->statistic.accumulatedValues[player].spentResourcesForArmy += totalCost;
 
 	//upgrade creature
 	changeStackType(StackLocation(obj, pos), upgID.toCreature());
@@ -2610,7 +2450,7 @@
 	sst.army = sl.army->id;
 	sst.slot = sl.slot;
 	sst.type = c->getId();
-	sendAndApply(&sst);
+	sendAndApply(sst);
 	return true;
 }
 
@@ -2622,12 +2462,12 @@
 		auto i = src->Slots().begin(); //iterator to stack to move
 		StackLocation sl(src, i->first); //location of stack to move
 
-		SlotID pos = dst->getSlotFor(i->second->type);
+		SlotID pos = dst->getSlotFor(i->second->getCreature());
 		if (!pos.validSlot())
 		{
 			//try to merge two other stacks to make place
 			std::pair<SlotID, SlotID> toMerge;
-			if (dst->mergableStacks(toMerge, i->first) && allowMerging)
+			if (dst->mergeableStacks(toMerge, i->first) && allowMerging)
 			{
 				moveStack(StackLocation(dst, toMerge.first), StackLocation(dst, toMerge.second)); //merge toMerge.first into toMerge.second
 				assert(!dst->hasStackAtSlot(toMerge.first)); //we have now a new free slot
@@ -2669,7 +2509,7 @@
 		intown.visiting = ObjectInstanceID();
 		intown.garrison = town->visitingHero->id;
 	}
-	sendAndApply(&intown);
+	sendAndApply(intown);
 	return true;
 }
 
@@ -2691,12 +2531,12 @@
 		intown.tid = tid;
 		intown.visiting = ObjectInstanceID();
 		intown.garrison = town->visitingHero->id;
-		sendAndApply(&intown);
+		sendAndApply(intown);
 		return true;
 	}
 	else if (town->garrisonHero && !town->visitingHero) //move hero out of the garrison
 	{
-		int mapCap = VLC->settings()->getInteger(EGameSettings::HEROES_PER_PLAYER_ON_MAP_CAP);
+		int mapCap = getSettings().getInteger(EGameSettings::HEROES_PER_PLAYER_ON_MAP_CAP);
 		//check if moving hero out of town will break wandering heroes limit
 		if (getHeroCount(town->garrisonHero->tempOwner,false) >= mapCap)
 		{
@@ -2708,7 +2548,7 @@
 		intown.tid = tid;
 		intown.garrison = ObjectInstanceID();
 		intown.visiting =  town->garrisonHero->id;
-		sendAndApply(&intown);
+		sendAndApply(intown);
 		return true;
 	}
 	else if (!!town->garrisonHero && town->visitingHero) //swap visiting and garrison hero
@@ -2717,7 +2557,7 @@
 		intown.tid = tid;
 		intown.garrison = town->visitingHero->id;
 		intown.visiting =  town->garrisonHero->id;
-		sendAndApply(&intown);
+		sendAndApply(intown);
 		return true;
 	}
 	else
@@ -2740,10 +2580,16 @@
 	if(!isAllowedExchange(src.artHolder, dst.artHolder))
 		COMPLAIN_RET("That heroes cannot make any exchange!");
 
+	COMPLAIN_RET_FALSE_IF(!ArtifactUtils::checkIfSlotValid(*srcArtSet, src.slot), "moveArtifact: wrong artifact source slot");
 	const auto srcArtifact = srcArtSet->getArt(src.slot);
-	const auto dstArtifact = dstArtSet->getArt(dst.slot);
+	auto dstSlot = dst.slot;
+	if(dstSlot == ArtifactPosition::FIRST_AVAILABLE)
+		dstSlot = ArtifactUtils::getArtAnyPosition(dstArtSet, srcArtifact->getTypeId());
+	if(!ArtifactUtils::checkIfSlotValid(*dstArtSet, dstSlot))
+		return true;
+	const auto dstArtifact = dstArtSet->getArt(dstSlot);
 	const bool isDstSlotOccupied = dstArtSet->bearerType() == ArtBearer::ALTAR ? false : dstArtifact != nullptr;
-	const bool isDstSlotBackpack = dstArtSet->bearerType() == ArtBearer::HERO ? ArtifactUtils::isSlotBackpack(dst.slot) : false;
+	const bool isDstSlotBackpack = dstArtSet->bearerType() == ArtBearer::HERO ? ArtifactUtils::isSlotBackpack(dstSlot) : false;
 
 	if(srcArtifact == nullptr)
 		COMPLAIN_RET("No artifact to move!");
@@ -2752,23 +2598,23 @@
 
 	// Check if src/dest slots are appropriate for the artifacts exchanged.
 	// Moving to the backpack is always allowed.
-	if((!srcArtifact || !isDstSlotBackpack) && !srcArtifact->canBePutAt(dstArtSet, dst.slot, true))
+	if((!srcArtifact || !isDstSlotBackpack) && !srcArtifact->canBePutAt(dstArtSet, dstSlot, true))
 		COMPLAIN_RET("Cannot move artifact!");
 
 	auto srcSlotInfo = srcArtSet->getSlot(src.slot);
-	auto dstSlotInfo = dstArtSet->getSlot(dst.slot);
+	auto dstSlotInfo = dstArtSet->getSlot(dstSlot);
 
 	if((srcSlotInfo && srcSlotInfo->locked) || (dstSlotInfo && dstSlotInfo->locked))
 		COMPLAIN_RET("Cannot move artifact locks.");
 
-	if(isDstSlotBackpack && srcArtifact->artType->isBig())
+	if(isDstSlotBackpack && srcArtifact->getType()->isBig())
 		COMPLAIN_RET("Cannot put big artifacts in backpack!");
-	if(src.slot == ArtifactPosition::MACH4 || dst.slot == ArtifactPosition::MACH4)
+	if(src.slot == ArtifactPosition::MACH4 || dstSlot == ArtifactPosition::MACH4)
 		COMPLAIN_RET("Cannot move catapult!");
 	if(isDstSlotBackpack && !ArtifactUtils::isBackpackFreeSlots(dstArtSet))
 		COMPLAIN_RET("Backpack is full!");
 
-	auto dstSlot = std::min(dst.slot, ArtifactPosition(ArtifactPosition::BACKPACK_START + dstArtSet->artifactsInBackpack.size()));
+	dstSlot = std::min(dstSlot, ArtifactPosition(ArtifactPosition::BACKPACK_START + dstArtSet->artifactsInBackpack.size()));
 
 	if(src.slot == dstSlot && src.artHolder == dst.artHolder)
 		COMPLAIN_RET("Won't move artifact: Dest same as source!");
@@ -2783,17 +2629,16 @@
 		// Previous artifact must be swapped
 		COMPLAIN_RET_FALSE_IF(!dstArtifact->canBePutAt(srcArtSet, src.slot, true), "Cannot swap artifacts!");
 		ma.artsPack1.push_back(BulkMoveArtifacts::LinkedSlots(dstSlot, src.slot));
-		ma.swap = true;
 	}
 
 	auto hero = getHero(dst.artHolder);
-	if(ArtifactUtils::checkSpellbookIsNeeded(hero, srcArtifact->artType->getId(), dstSlot))
-		giveHeroNewArtifact(hero, ArtifactID(ArtifactID::SPELLBOOK).toArtifact(), ArtifactPosition::SPELLBOOK);
+	if(ArtifactUtils::checkSpellbookIsNeeded(hero, srcArtifact->getTypeId(), dstSlot))
+		giveHeroNewArtifact(hero, ArtifactID::SPELLBOOK, ArtifactPosition::SPELLBOOK);
 
 	ma.artsPack0.push_back(BulkMoveArtifacts::LinkedSlots(src.slot, dstSlot));
-	if(src.artHolder != dst.artHolder)
-		ma.askAssemble = true;
-	sendAndApply(&ma);
+	if(src.artHolder != dst.artHolder && !isDstSlotBackpack)
+		ma.artsPack0.back().askAssemble = true;
+	sendAndApply(ma);
 	return true;
 }
 
@@ -2829,7 +2674,7 @@
 			if(auto dstHero = getHero(dstId))
 			{
 				if(ArtifactUtils::checkSpellbookIsNeeded(dstHero, artifact->getTypeId(), dstSlot))
-					giveHeroNewArtifact(dstHero, ArtifactID(ArtifactID::SPELLBOOK).toArtifact(), ArtifactPosition::SPELLBOOK);
+					giveHeroNewArtifact(dstHero, ArtifactID::SPELLBOOK, ArtifactPosition::SPELLBOOK);
 			}
 		}
 	};
@@ -2894,26 +2739,91 @@
 			}
 		}
 	}
-	sendAndApply(&ma);
+	sendAndApply(ma);
 	return true;
 }
 
-bool CGameHandler::scrollBackpackArtifacts(const PlayerColor & player, const ObjectInstanceID heroID, bool left)
+bool CGameHandler::manageBackpackArtifacts(const PlayerColor & player, const ObjectInstanceID heroID, const ManageBackpackArtifacts::ManageCmd & sortType)
 {
-	auto artSet = getArtSet(heroID);
-	COMPLAIN_RET_FALSE_IF(artSet == nullptr, "scrollBackpackArtifacts: wrong hero's ID");
+	const auto artSet = getArtSet(heroID);
+	COMPLAIN_RET_FALSE_IF(artSet == nullptr, "manageBackpackArtifacts: wrong hero's ID");
 
 	BulkMoveArtifacts bma(player, heroID, heroID, false);
+	const auto makeSortBackpackRequest = [artSet, &bma](const std::function<int32_t(const ArtSlotInfo&)> & getSortId)
+	{
+		std::map<int32_t, std::vector<BulkMoveArtifacts::LinkedSlots>> packsSorted;
+		ArtifactPosition backpackSlot = ArtifactPosition::BACKPACK_START;
+		for(const auto & backpackSlotInfo : artSet->artifactsInBackpack)
+			packsSorted.try_emplace(getSortId(backpackSlotInfo)).first->second.emplace_back(backpackSlot++, ArtifactPosition::PRE_FIRST);
 
-	const auto backpackEnd = ArtifactPosition(ArtifactPosition::BACKPACK_START + artSet->artifactsInBackpack.size() - 1);
-	if(backpackEnd > ArtifactPosition::BACKPACK_START)
+		for(auto & [sortId, pack] : packsSorted)
+		{
+			// Each pack of artifacts is also sorted by ArtifactID. Scrolls by SpellID
+			std::sort(pack.begin(), pack.end(), [artSet](const auto & slots0, const auto & slots1) -> bool
+				{
+					const auto art0 = artSet->getArt(slots0.srcPos);
+					const auto art1 = artSet->getArt(slots1.srcPos);
+					if(art0->isScroll() && art1->isScroll())
+						return art0->getScrollSpellID() > art1->getScrollSpellID();
+					return art0->getTypeId().num > art1->getTypeId().num;
+				});
+			bma.artsPack0.insert(bma.artsPack0.end(), pack.begin(), pack.end());
+		}
+		backpackSlot = ArtifactPosition::BACKPACK_START;
+		for(auto & slots : bma.artsPack0)
+			slots.dstPos = backpackSlot++;
+	};
+	
+	if(sortType == ManageBackpackArtifacts::ManageCmd::SORT_BY_SLOT)
 	{
-		if(left)
-			bma.artsPack0.push_back(BulkMoveArtifacts::LinkedSlots(backpackEnd, ArtifactPosition::BACKPACK_START));
-		else
-			bma.artsPack0.push_back(BulkMoveArtifacts::LinkedSlots(ArtifactPosition::BACKPACK_START, backpackEnd));
-		sendAndApply(&bma);
+		makeSortBackpackRequest([](const ArtSlotInfo & inf) -> int32_t
+			{
+				auto possibleSlots = inf.getArt()->getType()->getPossibleSlots();
+				if (possibleSlots.find(ArtBearer::CREATURE) != possibleSlots.end() && !possibleSlots.at(ArtBearer::CREATURE).empty()) 
+				{
+					return -2;
+				}
+				else if (possibleSlots.find(ArtBearer::COMMANDER) != possibleSlots.end() && !possibleSlots.at(ArtBearer::COMMANDER).empty()) 
+				{
+					return -1;
+				}
+				else if (possibleSlots.find(ArtBearer::HERO) != possibleSlots.end() && !possibleSlots.at(ArtBearer::HERO).empty()) 
+				{
+					return inf.getArt()->getType()->getPossibleSlots().at(ArtBearer::HERO).front().num;
+				}
+				else 
+				{
+					// for grail
+					return -3;
+				}
+			});
+	}
+	else if(sortType == ManageBackpackArtifacts::ManageCmd::SORT_BY_COST)
+	{
+		makeSortBackpackRequest([](const ArtSlotInfo & inf) -> int32_t
+			{
+				return inf.getArt()->getType()->getPrice();
+			});
+	}
+	else if(sortType == ManageBackpackArtifacts::ManageCmd::SORT_BY_CLASS)
+	{
+		makeSortBackpackRequest([](const ArtSlotInfo & inf) -> int32_t
+			{
+				return inf.getArt()->getType()->aClass;
+			});
+	}
+	else
+	{
+		const auto backpackEnd = ArtifactPosition(ArtifactPosition::BACKPACK_START + artSet->artifactsInBackpack.size() - 1);
+		if(backpackEnd > ArtifactPosition::BACKPACK_START)
+		{
+			if(sortType == ManageBackpackArtifacts::ManageCmd::SCROLL_LEFT)
+				bma.artsPack0.emplace_back(backpackEnd, ArtifactPosition::BACKPACK_START);
+			else
+				bma.artsPack0.emplace_back(ArtifactPosition::BACKPACK_START, backpackEnd);
+		}
 	}
+	sendAndApply(bma);
 	return true;
 }
 
@@ -2929,7 +2839,7 @@
 			costume.costumeSet.emplace(slot, slotInfo->getArt()->getTypeId());
 	}
 
-	sendAndApply(&costume);
+	sendAndApply(costume);
 	return true;
 }
 
@@ -2961,15 +2871,15 @@
 		// Second, find the necessary artifacts for the costume
 		for(const auto & artPos : costumeArtMap)
 		{
-			if(const auto availableArts = artFittingSet.getAllArtPositions(artPos.second, false, false, false); !availableArts.empty())
+			if(const auto slot = artFittingSet.getArtPos(artPos.second, false, false); slot != ArtifactPosition::PRE_FIRST)
 			{
 				bma.artsPack0.emplace_back(BulkMoveArtifacts::LinkedSlots
 					{
-						artSet->getSlotByInstance(artFittingSet.getArt(availableArts.front())),
+						artSet->getArtPos(artFittingSet.getArt(slot)),
 						artPos.first
 					});
-				artFittingSet.removeArtifact(availableArts.front());
-				if(ArtifactUtils::isSlotBackpack(availableArts.front()))
+				artFittingSet.removeArtifact(slot);
+				if(ArtifactUtils::isSlotBackpack(slot))
 					estimateBackpackSize--;
 			}
 		}
@@ -2982,9 +2892,9 @@
 				estimateBackpackSize++;
 			}
 		
-		const auto backpackCap = VLC->settings()->getInteger(EGameSettings::HEROES_BACKPACK_CAP);
+		const auto backpackCap = getSettings().getInteger(EGameSettings::HEROES_BACKPACK_CAP);
 		if((backpackCap < 0 || estimateBackpackSize <= backpackCap) && !bma.artsPack0.empty())
-			sendAndApply(&bma);
+			sendAndApply(bma);
 	}
 	return true;
 }
@@ -3022,25 +2932,28 @@
 		}
 		
 		if(ArtifactUtils::checkSpellbookIsNeeded(hero, assembleTo, artifactSlot))
-			giveHeroNewArtifact(hero, ArtifactID(ArtifactID::SPELLBOOK).toArtifact(), ArtifactPosition::SPELLBOOK);
+			giveHeroNewArtifact(hero, ArtifactID::SPELLBOOK, ArtifactPosition::SPELLBOOK);
 
 		AssembledArtifact aa;
 		aa.al = dstLoc;
-		aa.builtArt = combinedArt;
-		sendAndApply(&aa);
+		aa.artId = assembleTo;
+		sendAndApply(aa);
 	}
 	else
 	{
 		if(!destArtifact->isCombined())
 			COMPLAIN_RET("assembleArtifacts: Artifact being attempted to disassemble is not a combined artifact!");
 
+		if(!destArtifact->hasParts())
+			COMPLAIN_RET("assembleArtifacts: Artifact being attempted to disassemble is fused combined artifact!");
+
 		if(ArtifactUtils::isSlotBackpack(artifactSlot)
-			&& !ArtifactUtils::isBackpackFreeSlots(hero, destArtifact->artType->getConstituents().size() - 1))
+			&& !ArtifactUtils::isBackpackFreeSlots(hero, destArtifact->getType()->getConstituents().size() - 1))
 			COMPLAIN_RET("assembleArtifacts: Artifact being attempted to disassemble but backpack is full!");
 
 		DisassembledArtifact da;
 		da.al = dstLoc;
-		sendAndApply(&da);
+		sendAndApply(da);
 	}
 
 	return true;
@@ -3079,7 +2992,7 @@
 			return false;
 
 		giveResource(hero->getOwner(),EGameResID::GOLD,-GameConstants::SPELLBOOK_GOLD_COST);
-		giveHeroNewArtifact(hero, ArtifactID(ArtifactID::SPELLBOOK).toArtifact(), ArtifactPosition::SPELLBOOK);
+		giveHeroNewArtifact(hero, ArtifactID::SPELLBOOK, ArtifactPosition::SPELLBOOK);
 		assert(hero->getArt(ArtifactPosition::SPELLBOOK));
 		giveSpells(town,hero);
 		return true;
@@ -3093,11 +3006,21 @@
 		const int price = art->getPrice();
 		COMPLAIN_RET_FALSE_IF(getPlayerState(hero->getOwner())->resources[EGameResID::GOLD] < price, "Not enough gold!");
 
-		if ((town->hasBuilt(BuildingID::BLACKSMITH) && town->town->warMachine == aid)
-		 || (town->hasBuilt(BuildingSubID::BALLISTA_YARD) && aid == ArtifactID::BALLISTA))
+		if(town->isWarMachineAvailable(aid))
 		{
+			bool hasFreeSlot = false;
+			for(auto slot : art->getPossibleSlots().at(ArtBearer::HERO))
+				if (hero->getArt(slot) == nullptr)
+					hasFreeSlot = true;
+
+			if (!hasFreeSlot)
+			{
+				auto slot = art->getPossibleSlots().at(ArtBearer::HERO).front();
+				removeArtifact(ArtifactLocation(hero->id, slot));
+			}
+
 			giveResource(hero->getOwner(),EGameResID::GOLD,-price);
-			return giveHeroNewArtifact(hero, art);
+			return giveHeroNewArtifact(hero, aid, ArtifactPosition::FIRST_AVAILABLE);
 		}
 		else
 			COMPLAIN_RET("This machine is unavailable here!");
@@ -3136,11 +3059,11 @@
 		COMPLAIN_RET("Wrong marktet...");
 
 	bool found = false;
-	for (const CArtifact *&art : saa.arts)
+	for (ArtifactID & art : saa.arts)
 	{
-		if (art && art->getId() == aid)
+		if (art == aid)
 		{
-			art = nullptr;
+			art = ArtifactID();
 			found = true;
 			break;
 		}
@@ -3149,8 +3072,8 @@
 	if (!found)
 		COMPLAIN_RET("Cannot find selected artifact on the list");
 
-	sendAndApply(&saa);
-	giveHeroNewArtifact(h, aid.toArtifact(), ArtifactPosition::FIRST_AVAILABLE);
+	sendAndApply(saa);
+	giveHeroNewArtifact(h, aid, ArtifactPosition::FIRST_AVAILABLE);
 	return true;
 }
 
@@ -3159,11 +3082,11 @@
 	COMPLAIN_RET_FALSE_IF((!h), "Only hero can sell artifacts!");
 	const CArtifactInstance *art = h->getArtByInstanceId(aid);
 	COMPLAIN_RET_FALSE_IF((!art), "There is no artifact to sell!");
-	COMPLAIN_RET_FALSE_IF((!art->artType->isTradable()), "Cannot sell a war machine or spellbook!");
+	COMPLAIN_RET_FALSE_IF((!art->getType()->isTradable()), "Cannot sell a war machine or spellbook!");
 
 	int resVal = 0;
 	int dump = 1;
-	m->getOffer(art->artType->getId(), rid, dump, resVal, EMarketMode::ARTIFACT_RESOURCE);
+	m->getOffer(art->getType()->getId(), rid, dump, resVal, EMarketMode::ARTIFACT_RESOURCE);
 
 	removeArtifact(ArtifactLocation(h->id, h->getArtPos(art)));
 	giveResource(h->tempOwner, rid, resVal);
@@ -3215,6 +3138,9 @@
 	giveResource(player, toSell, -b1 * amountToBoy);
 	giveResource(player, toBuy, b2 * amountToBoy);
 
+	gs->statistic.accumulatedValues[player].tradeVolume[toSell] += -b1 * amountToBoy;
+	gs->statistic.accumulatedValues[player].tradeVolume[toBuy] += b2 * amountToBoy;
+
 	return true;
 }
 
@@ -3235,7 +3161,7 @@
 
 	int b1; //base quantities for trade
 	int b2;
-	market->getOffer(s.type->getId(), resourceID, b1, b2, EMarketMode::CREATURE_RESOURCE);
+	market->getOffer(s.getId(), resourceID, b1, b2, EMarketMode::CREATURE_RESOURCE);
 	int units = count / b1; //how many base quantities we trade
 
 	if (count%b1) //all offered units of resource should be used, if not -> somewhere in calculations must be an error
@@ -3310,7 +3236,7 @@
 	ChangeFormation cf;
 	cf.hid = hid;
 	cf.formation = formation;
-	sendAndApply(&cf);
+	sendAndApply(cf);
 
 	return true;
 }
@@ -3341,154 +3267,14 @@
 	return true;
 }
 
-void CGameHandler::handleTimeEvents()
-{
-	gs->map->events.sort(evntCmp);
-	while(gs->map->events.size() && gs->map->events.front().firstOccurence+1 == gs->day)
-	{
-		CMapEvent ev = gs->map->events.front();
-
-		for (int player = 0; player < PlayerColor::PLAYER_LIMIT_I; player++)
-		{
-			auto color = PlayerColor(player);
-
-			const PlayerState * pinfo = getPlayerState(color, false); //do not output error if player does not exist
-
-			if (pinfo  //player exists
-				&& (ev.players & 1<<player) //event is enabled to this player
-				&& ((ev.computerAffected && !pinfo->human)
-					|| (ev.humanAffected && pinfo->human)
-				)
-			)
-			{
-				//give resources
-				giveResources(color, ev.resources);
-
-				//prepare dialog
-				InfoWindow iw;
-				iw.player = color;
-				iw.text = ev.message;
-
-				for (GameResID i : GameResID::ALL_RESOURCES())
-				{
-					if (ev.resources[i]) //if resource is changed, we add it to the dialog
-						iw.components.emplace_back(ComponentType::RESOURCE, i, ev.resources[i]);
-				}
-
-				sendAndApply(&iw); //show dialog
-			}
-		} //PLAYERS LOOP
-
-		if (ev.nextOccurence)
-		{
-			gs->map->events.pop_front();
-
-			ev.firstOccurence += ev.nextOccurence;
-			auto it = gs->map->events.begin();
-			while(it != gs->map->events.end() && it->earlierThanOrEqual(ev))
-				it++;
-			gs->map->events.insert(it, ev);
-		}
-		else
-		{
-			gs->map->events.pop_front();
-		}
-	}
-
-	//TODO send only if changed
-	UpdateMapEvents ume;
-	ume.events = gs->map->events;
-	sendAndApply(&ume);
-}
-
-void CGameHandler::handleTownEvents(CGTownInstance * town, NewTurn &n)
-{
-	town->events.sort(evntCmp);
-	while(town->events.size() && town->events.front().firstOccurence == gs->day)
-	{
-		PlayerColor player = town->tempOwner;
-		CCastleEvent ev = town->events.front();
-		const PlayerState * pinfo = getPlayerState(player, false);
-
-		if (pinfo  //player exists
-			&& (ev.players & 1<<player.getNum()) //event is enabled to this player
-			&& ((ev.computerAffected && !pinfo->human)
-				|| (ev.humanAffected && pinfo->human)))
-		{
-			// dialog
-			InfoWindow iw;
-			iw.player = player;
-			iw.text = ev.message;
-
-			if (ev.resources.nonZero())
-			{
-				TResources was = n.res[player];
-				n.res[player] += ev.resources;
-				n.res[player].amax(0);
-
-				for (GameResID i : GameResID::ALL_RESOURCES())
-					if (ev.resources[i] && pinfo->resources[i] != n.res.at(player)[i]) //if resource had changed, we add it to the dialog
-						iw.components.emplace_back(ComponentType::RESOURCE, i, n.res.at(player)[i] - was[i]);
-			}
-
-			for (auto & i : ev.buildings)
-			{
-				// Only perform action if:
-				// 1. Building exists in town (don't attempt to build Lvl 5 guild in Fortress
-				// 2. Building was not built yet
-				// othervice, silently ignore / skip it
-				if (town->town->buildings.count(i) && !town->hasBuilt(i))
-				{
-					buildStructure(town->id, i, true);
-					iw.components.emplace_back(ComponentType::BUILDING, BuildingTypeUniqueID(town->getFaction(), i));
-				}
-			}
-
-			if (!ev.creatures.empty() && !vstd::contains(n.cres, town->id))
-			{
-				n.cres[town->id].tid = town->id;
-				n.cres[town->id].creatures = town->creatures;
-			}
-			auto & sac = n.cres[town->id];
-
-			for (si32 i=0;i<ev.creatures.size();i++) //creature growths
-			{
-				if (!town->creatures.at(i).second.empty() && ev.creatures.at(i) > 0)//there is dwelling
-				{
-					sac.creatures[i].first += ev.creatures.at(i);
-					iw.components.emplace_back(ComponentType::CREATURE, town->creatures.at(i).second.back(), ev.creatures.at(i));
-				}
-			}
-			sendAndApply(&iw); //show dialog
-		}
-
-		if (ev.nextOccurence)
-		{
-			town->events.pop_front();
-
-			ev.firstOccurence += ev.nextOccurence;
-			auto it = town->events.begin();
-			while(it != town->events.end() && it->earlierThanOrEqual(ev))
-				it++;
-			town->events.insert(it, ev);
-		}
-		else
-		{
-			town->events.pop_front();
-		}
-	}
-
-	//TODO send only if changed
-	UpdateCastleEvents uce;
-	uce.town = town->id;
-	uce.events = town->events;
-	sendAndApply(&uce);
-}
-
 bool CGameHandler::complain(const std::string &problem)
 {
 #ifndef ENABLE_GOLDMASTER
-	playerMessages->broadcastSystemMessage("Server encountered a problem: " + problem);
+	MetaString str;
+	str.appendTextID("vcmi.broadcast.serverProblem");
+	str.appendRawString(": ");
+	str.appendRawString(problem);
+	playerMessages->broadcastSystemMessage(str);
 #endif
 	logGlobal->error(problem);
 	return true;
@@ -3511,7 +3297,7 @@
 	gd.objid = upobj;
 	gd.removableUnits = removableUnits;
 	gd.queryID = garrisonQuery->queryID;
-	sendAndApply(&gd);
+	sendAndApply(gd);
 }
 
 void CGameHandler::showObjectWindow(const CGObjectInstance * object, EOpenWindowMode window, const CGHeroInstance * visitor, bool addQuery)
@@ -3527,7 +3313,7 @@
 		pack.queryID = windowQuery->queryID;
 		queries->addQuery(windowQuery);
 	}
-	sendAndApply(&pack);
+	sendAndApply(pack);
 }
 
 bool CGameHandler::isAllowedExchange(ObjectInstanceID id1, ObjectInstanceID id2)
@@ -3555,9 +3341,9 @@
 				return true;
 		}
 
-		auto market = dynamic_cast<const IMarket*>(o1);
+		auto market = getMarket(id1);
 		if(market == nullptr)
-			market = dynamic_cast<const IMarket*>(o2);
+			market = getMarket(id2);
 		if(market)
 			return market->allowsTrade(EMarketMode::ARTIFACT_EXP);
 
@@ -3602,7 +3388,7 @@
 		throw std::runtime_error("Can not visit object that is being visited");
 	}
 
-	std::shared_ptr<CObjectVisitQuery> visitQuery;
+	std::shared_ptr<MapObjectVisitQuery> visitQuery;
 
 	auto startVisit = [&](ObjectVisitStarted & event)
 	{
@@ -3621,7 +3407,7 @@
 					visitedObject = visitedTown;
 			}
 		}
-		visitQuery = std::make_shared<CObjectVisitQuery>(this, visitedObject, h, visitedObject->visitablePos());
+		visitQuery = std::make_shared<MapObjectVisitQuery>(this, visitedObject, h);
 		queries->addQuery(visitQuery); //TODO real visit pos
 
 		HeroVisit hv;
@@ -3629,7 +3415,7 @@
 		hv.heroId = h->id;
 		hv.player = h->tempOwner;
 		hv.starting = true;
-		sendAndApply(&hv);
+		sendAndApply(hv);
 
 		obj->onHeroVisit(h);
 	};
@@ -3640,11 +3426,11 @@
 		queries->popIfTop(visitQuery); //visit ends here if no queries were created
 }
 
-void CGameHandler::objectVisitEnded(const CObjectVisitQuery & query)
+void CGameHandler::objectVisitEnded(const CGHeroInstance *h, PlayerColor player)
 {
 	using events::ObjectVisitEnded;
 
-	logGlobal->debug("%s visit ends.\n", query.visitingHero->nodeName());
+	logGlobal->debug("%s visit ends.\n", h->nodeName());
 
 	auto endVisit = [&](ObjectVisitEnded & event)
 	{
@@ -3652,12 +3438,12 @@
 		hv.player = event.getPlayer();
 		hv.heroId = event.getHero();
 		hv.starting = false;
-		sendAndApply(&hv);
+		sendAndApply(hv);
 	};
 
 	//TODO: ObjectVisitEnded should also have id of visited object,
 	//but this requires object being deleted only by `removeAfterVisit()` but not `removeObject()`
-	ObjectVisitEnded::defaultExecute(serverEventBus.get(), endVisit, query.players.front(), query.visitingHero->id);
+	ObjectVisitEnded::defaultExecute(serverEventBus.get(), endVisit, player, h->id);
 }
 
 bool CGameHandler::buildBoat(ObjectInstanceID objid, PlayerColor playerID)
@@ -3672,9 +3458,9 @@
 
 	TResources boatCost;
 	obj->getBoatCost(boatCost);
-	TResources aviable = getPlayerState(playerID)->resources;
+	TResources available = getPlayerState(playerID)->resources;
 
-	if (!aviable.canAfford(boatCost))
+	if (!available.canAfford(boatCost))
 	{
 		complain("Not enough resources to build a boat!");
 		return false;
@@ -3688,7 +3474,7 @@
 	}
 
 	giveResources(playerID, -boatCost);
-	createObject(tile, playerID, Obj::BOAT, obj->getBoatType().getNum());
+	createBoat(tile, obj->getBoatType(), playerID);
 	return true;
 }
 
@@ -3723,12 +3509,14 @@
 	{
 		InfoWindow iw;
 		getVictoryLossMessage(player, victoryLossCheckResult, iw);
-		sendAndApply(&iw);
+		sendAndApply(iw);
 
 		PlayerEndsGame peg;
 		peg.player = player;
 		peg.victoryLossCheckResult = victoryLossCheckResult;
-		sendAndApply(&peg);
+		peg.statistic = StatisticDataSet(gameState()->statistic);
+		addStatistics(peg.statistic); // add last turn befor win / loss
+		sendAndApply(peg);
 
 		turnOrder->onPlayerEndsGame(player);
 
@@ -3747,8 +3535,8 @@
 					getVictoryLossMessage(player, peg.victoryLossCheckResult, iw);
 					iw.player = i->first;
 
-					sendAndApply(&iw);
-					sendAndApply(&peg);
+					sendAndApply(iw);
+					sendAndApply(peg);
 				}
 			}
 
@@ -3760,10 +3548,10 @@
 		else
 		{
 			//copy heroes vector to avoid iterator invalidation as removal change PlayerState
-			auto hlp = p->heroes;
+			auto hlp = p->getHeroes();
 			for (auto h : hlp) //eliminate heroes
 			{
-				if (h.get())
+				if (h)
 					removeObject(h, player);
 			}
 
@@ -3792,7 +3580,7 @@
 					InfoWindow iw;
 					getVictoryLossMessage(player, victoryLossCheckResult.invert(), iw);
 					iw.player = pc;
-					sendAndApply(&iw);
+					sendAndApply(iw);
 				}
 			}
 			checkVictoryLossConditions(playerColors);
@@ -3813,13 +3601,13 @@
 	if (h->diggingStatus() != EDiggingStatus::CAN_DIG) //checks for terrain and movement
 		COMPLAIN_RETF("Hero cannot dig (error code %d)!", static_cast<int>(h->diggingStatus()));
 
-	createObject(h->visitablePos(), h->getOwner(), Obj::HOLE, 0 );
+	createHole(h->visitablePos(), h->getOwner());
 
 	//take MPs
 	SetMovePoints smp;
 	smp.hid = h->id;
 	smp.val = 0;
-	sendAndApply(&smp);
+	sendAndApply(smp);
 
 	InfoWindow iw;
 	iw.type = EInfoWindowMode::AUTO;
@@ -3831,20 +3619,20 @@
 		iw.text.appendLocalString(EMetaText::GENERAL_TXT, 58); //"Congratulations! After spending many hours digging here, your hero has uncovered the " ...
 		iw.text.appendName(grail); // ... " The Grail"
 		iw.soundID = soundBase::ULTIMATEARTIFACT;
-		giveHeroNewArtifact(h, grail.toArtifact(), ArtifactPosition::FIRST_AVAILABLE); //give grail
-		sendAndApply(&iw);
+		giveHeroNewArtifact(h, grail, ArtifactPosition::FIRST_AVAILABLE); //give grail
+		sendAndApply(iw);
 
 		iw.soundID = soundBase::invalid;
 		iw.components.emplace_back(ComponentType::ARTIFACT, grail);
 		iw.text.clear();
 		iw.text.appendTextID(grail.toArtifact()->getDescriptionTextID());
-		sendAndApply(&iw);
+		sendAndApply(iw);
 	}
 	else
 	{
 		iw.text.appendLocalString(EMetaText::GENERAL_TXT, 59); //"Nothing here. \n Where could it be?"
 		iw.soundID = soundBase::Dig;
-		sendAndApply(&iw);
+		sendAndApply(iw);
 	}
 
 	return true;
@@ -3888,7 +3676,7 @@
 			COMPLAIN_RET("Cannot sacrifice last creature!");
 		}
 
-		int crid = hero->getStack(slot[i]).type->getId();
+		int crid = hero->getStack(slot[i]).getId();
 
 		changeStackCount(StackLocation(hero, slot[i]), -(TQuantity)count[i]);
 
@@ -3904,33 +3692,35 @@
 	return true;
 }
 
-bool CGameHandler::sacrificeArtifact(const IMarket * m, const CGHeroInstance * hero, const std::vector<ArtifactInstanceID> & arts)
+bool CGameHandler::sacrificeArtifact(const IMarket * market, const CGHeroInstance * hero, const std::vector<ArtifactInstanceID> & arts)
 {
 	if (!hero)
 		COMPLAIN_RET("You need hero to sacrifice artifact!");
 	if(hero->getAlignment() == EAlignment::EVIL)
 		COMPLAIN_RET("Evil hero can't sacrifice artifact!");
 
-	assert(m);
-	auto altarObj = dynamic_cast<const CGArtifactsAltar*>(m);
+	assert(market);
+	const auto artSet = market->getArtifactsStorage();
 
 	int expSum = 0;
-	auto finish = [this, &hero, &expSum]()
+	std::vector<ArtifactPosition> artPack;
+	auto finish = [this, &hero, &expSum, &artPack, market]()
 	{
+		removeArtifact(market->getObjInstanceID(), artPack);
 		giveExperience(hero, hero->calculateXp(expSum));
 	};
 
 	for(const auto & artInstId : arts)
 	{
-		if(auto art = altarObj->getArtByInstanceId(artInstId))
+		if(auto art = artSet->getArtByInstanceId(artInstId))
 		{
-			if(art->artType->isTradable())
+			if(art->getType()->isTradable())
 			{
 				int dmp;
 				int expToGive;
-				m->getOffer(art->getTypeId(), 0, dmp, expToGive, EMarketMode::ARTIFACT_EXP);
+				market->getOffer(art->getTypeId(), 0, dmp, expToGive, EMarketMode::ARTIFACT_EXP);
 				expSum += expToGive;
-				removeArtifact(ArtifactLocation(altarObj->id, altarObj->getSlotByInstance(art)));
+				artPack.push_back(artSet->getArtPos(art));
 			}
 			else
 			{
@@ -3962,7 +3752,7 @@
 	ins.slot = sl.slot;
 	ins.type = c->getId();
 	ins.count = count;
-	sendAndApply(&ins);
+	sendAndApply(ins);
 	return true;
 }
 
@@ -3981,7 +3771,7 @@
 	EraseStack es;
 	es.army = sl.army->id;
 	es.slot = sl.slot;
-	sendAndApply(&es);
+	sendAndApply(es);
 	return true;
 }
 
@@ -4006,7 +3796,7 @@
 		csc.slot = sl.slot;
 		csc.count = count;
 		csc.absoluteValue = absoluteValue;
-		sendAndApply(&csc);
+		sendAndApply(csc);
 	}
 	return true;
 }
@@ -4039,7 +3829,7 @@
 			{
 				for (auto i = src->stacks.begin(); i != src->stacks.end(); i++)//while there are unmoved creatures
 				{
-					SlotID pos = dst->getSlotFor(i->second->type);
+					SlotID pos = dst->getSlotFor(i->second->getCreature());
 					if (pos.validSlot())
 					{
 						moveStack(StackLocation(src, i->first), StackLocation(dst, pos));
@@ -4088,7 +3878,7 @@
 	rs.srcSlot = src.slot;
 	rs.dstSlot = dst.slot;
 	rs.count = count;
-	sendAndApply(&rs);
+	sendAndApply(rs);
 	return true;
 }
 
@@ -4122,14 +3912,15 @@
 		ss.dstArmy = sl2.army->id;
 		ss.srcSlot = sl1.slot;
 		ss.dstSlot = sl2.slot;
-		sendAndApply(&ss);
+		sendAndApply(ss);
 		return true;
 	}
 }
 
-bool CGameHandler::putArtifact(const ArtifactLocation & al, const CArtifactInstance * art, std::optional<bool> askAssemble)
+bool CGameHandler::putArtifact(const ArtifactLocation & al, const ArtifactInstanceID & id, std::optional<bool> askAssemble)
 {
-	assert(art && art->artType);
+	const auto artInst = getArtInstance(id);
+	assert(artInst && artInst->getType());
 	ArtifactLocation dst(al.artHolder, ArtifactPosition::PRE_FIRST);
 	dst.creature = al.creature;
 	auto putTo = getArtSet(al);
@@ -4137,11 +3928,11 @@
 
 	if(al.slot == ArtifactPosition::FIRST_AVAILABLE)
 	{
-		dst.slot = ArtifactUtils::getArtAnyPosition(putTo, art->getTypeId());
+		dst.slot = ArtifactUtils::getArtAnyPosition(putTo, artInst->getTypeId());
 	}
 	else if(ArtifactUtils::isSlotBackpack(al.slot) && !al.creature.has_value())
 	{
-		dst.slot = ArtifactUtils::getArtBackpackPosition(putTo, art->getTypeId());
+		dst.slot = ArtifactUtils::getArtBackpackPosition(putTo, artInst->getTypeId());
 	}
 	else
 	{
@@ -4156,11 +3947,10 @@
 			askAssemble = false;
 	}
 
-	if(art->canBePutAt(putTo, dst.slot))
+	if(artInst->canBePutAt(putTo, dst.slot))
 	{
-		PutArtifact pa(dst, askAssemble.value());
-		pa.art = art;
-		sendAndApply(&pa);
+		PutArtifact pa(id, dst, askAssemble.value());
+		sendAndApply(pa);
 		return true;
 	}
 	else
@@ -4169,13 +3959,21 @@
 	}
 }
 
-bool CGameHandler::giveHeroNewArtifact(const CGHeroInstance * h, const CArtifact * artType, ArtifactPosition pos)
+bool CGameHandler::giveHeroNewArtifact(
+	const CGHeroInstance * h, const CArtifact * artType, const SpellID & spellId, const ArtifactPosition & pos)
 {
 	assert(artType);
 
+	NewArtifact na;
+	na.artHolder = h->id;
+	na.artId = artType->getId();
+	na.spellId = spellId;
+	na.pos = pos;
+
 	if(pos == ArtifactPosition::FIRST_AVAILABLE)
 	{
-		if(!artType->canBePutAt(h, ArtifactUtils::getArtAnyPosition(h, artType->getId())))
+		na.pos = ArtifactUtils::getArtAnyPosition(h, artType->getId());
+		if(!artType->canBePutAt(h, na.pos))
 			COMPLAIN_RET("Cannot put artifact in that slot!");
 	}
 	else if(ArtifactUtils::isSlotBackpack(pos))
@@ -4187,18 +3985,18 @@
 	{
 		COMPLAIN_RET_FALSE_IF(!artType->canBePutAt(h, pos, false), "Cannot put artifact in that slot!");
 	}
+	sendAndApply(na);
+	return true;
+}
 
-	auto * newArtInst = new CArtifactInstance();
-	newArtInst->artType = artType; // *NOT* via settype -> all bonus-related stuff must be done by NewArtifact apply
-
-	NewArtifact na;
-	na.art = newArtInst;
-	sendAndApply(&na); // -> updates newArtInst!!!
+bool CGameHandler::giveHeroNewArtifact(const CGHeroInstance * h, const ArtifactID & artId, const ArtifactPosition & pos)
+{
+	return giveHeroNewArtifact(h, artId.toArtifact(), SpellID::NONE, pos);
+}
 
-	if(putArtifact(ArtifactLocation(h->id, pos), newArtInst, false))
-		return true;
-	else
-		return false;
+bool CGameHandler::giveHeroNewScroll(const CGHeroInstance * h, const SpellID & spellId, const ArtifactPosition & pos)
+{
+	return giveHeroNewArtifact(h, ArtifactID(ArtifactID::SPELL_SCROLL).toArtifact(), spellId, pos);
 }
 
 void CGameHandler::spawnWanderingMonsters(CreatureID creatureID)
@@ -4218,7 +4016,7 @@
 		{
 			auto count = cre->getRandomAmount(std::rand);
 
-			createObject(*tile, PlayerColor::NEUTRAL, Obj::MONSTER, creatureID);
+			createWanderingMonster(*tile, creatureID);
 			auto monsterId = getTopObj(*tile)->id;
 
 			setObjPropertyValue(monsterId, ObjProperty::MONSTER_COUNT, count);
@@ -4232,7 +4030,7 @@
 {
 	UpdateArtHandlerLists uahl;
 	uahl.allocatedArtifacts = gs->allocatedArtifacts;
-	sendAndApply(&uahl);
+	sendAndApply(uahl);
 }
 
 bool CGameHandler::isValidObject(const CGObjectInstance *obj) const
@@ -4240,9 +4038,12 @@
 	return vstd::contains(gs->map->objects, obj);
 }
 
-bool CGameHandler::isBlockedByQueries(const CPack *pack, PlayerColor player)
+bool CGameHandler::isBlockedByQueries(const CPackForServer *pack, PlayerColor player)
 {
-	if (!strcmp(typeid(*pack).name(), typeid(PlayerMessage).name()))
+	if (dynamic_cast<const PlayerMessage *>(pack) != nullptr)
+		return false;
+
+	if (dynamic_cast<const SaveLocalState *>(pack) != nullptr)
 		return false;
 
 	auto query = queries->topQuery(player);
@@ -4264,7 +4065,7 @@
 	//If the object is being visited, there must be a matching query
 	for (const auto &query : queries->allQueries())
 	{
-		if (auto someVistQuery = std::dynamic_pointer_cast<CObjectVisitQuery>(query))
+		if (auto someVistQuery = std::dynamic_pointer_cast<MapObjectVisitQuery>(query))
 		{
 			if (someVistQuery->visitedObject == object)
 			{
@@ -4285,19 +4086,6 @@
 	if (mode == ETileVisibility::HIDDEN)
 	{
 		getTilesInRange(tiles, center, radius, ETileVisibility::REVEALED, player);
-
-		std::unordered_set<int3> observedTiles; //do not hide tiles observed by heroes. May lead to disastrous AI problems
-		auto p = getPlayerState(player);
-		for (auto h : p->heroes)
-		{
-			getTilesInRange(observedTiles, h->getSightCenter(), h->getSightRadius(), ETileVisibility::REVEALED, h->tempOwner);
-		}
-		for (auto t : p->towns)
-		{
-			getTilesInRange(observedTiles, t->getSightCenter(), t->getSightRadius(), ETileVisibility::REVEALED, t->tempOwner);
-		}
-		for (auto tile : observedTiles)
-			vstd::erase_if_present (tiles, tile);
 	}
 	else
 	{
@@ -4306,7 +4094,7 @@
 	changeFogOfWar(tiles, player, mode);
 }
 
-void CGameHandler::changeFogOfWar(std::unordered_set<int3> &tiles, PlayerColor player, ETileVisibility mode)
+void CGameHandler::changeFogOfWar(const std::unordered_set<int3> &tiles, PlayerColor player, ETileVisibility mode)
 {
 	if (tiles.empty())
 		return;
@@ -4315,7 +4103,24 @@
 	fow.tiles = tiles;
 	fow.player = player;
 	fow.mode = mode;
-	sendAndApply(&fow);
+
+	if (mode == ETileVisibility::HIDDEN)
+	{
+		// do not hide tiles observed by owned objects. May lead to disastrous AI problems
+		// FIXME: this leads to a bug - shroud of darkness from Necropolis does can not override Skyship from Tower
+		std::unordered_set<int3> observedTiles;
+		auto p = getPlayerState(player);
+		for (auto obj : p->getOwnedObjects())
+			getTilesInRange(observedTiles, obj->getSightCenter(), obj->getSightRadius(), ETileVisibility::REVEALED, obj->getOwner());
+
+		for (auto tile : observedTiles)
+			vstd::erase_if_present (fow.tiles, tile);
+
+		if (fow.tiles.empty())
+			return;
+	}
+
+	sendAndApply(fow);
 }
 
 const CGHeroInstance * CGameHandler::getVisitingHero(const CGObjectInstance *obj)
@@ -4324,7 +4129,7 @@
 
 	for(const auto & query : queries->allQueries())
 	{
-		auto visit = std::dynamic_pointer_cast<const CObjectVisitQuery>(query);
+		auto visit = std::dynamic_pointer_cast<const VisitQuery>(query);
 		if (visit && visit->visitedObject == obj)
 			return visit->visitingHero;
 	}
@@ -4337,7 +4142,7 @@
 
 	for(const auto & query : queries->allQueries())
 	{
-		auto visit = std::dynamic_pointer_cast<const CObjectVisitQuery>(query);
+		auto visit = std::dynamic_pointer_cast<const VisitQuery>(query);
 		if (visit && visit->visitingHero == hero)
 			return visit->visitedObject;
 	}
@@ -4354,7 +4159,7 @@
 	// visitation query is covered by other query that must be answered first
 
 	if (auto topQuery = queries->topQuery(hero->getOwner()))
-		if (auto visit = std::dynamic_pointer_cast<const CObjectVisitQuery>(topQuery))
+		if (auto visit = std::dynamic_pointer_cast<const VisitQuery>(topQuery))
 			return !(visit->visitedObject == obj && visit->visitingHero == hero);
 
 	return true;
@@ -4366,7 +4171,7 @@
 	sob.id = objid;
 	sob.what = prop;
 	sob.identifier = NumericID(value);
-	sendAndApply(&sob);
+	sendAndApply(sob);
 }
 
 void CGameHandler::setObjPropertyID(ObjectInstanceID objid, ObjProperty prop, ObjPropertyID identifier)
@@ -4375,17 +4180,42 @@
 	sob.id = objid;
 	sob.what = prop;
 	sob.identifier = identifier;
-	sendAndApply(&sob);
+	sendAndApply(sob);
+}
+
+void CGameHandler::setBankObjectConfiguration(ObjectInstanceID objid, const BankConfig & configuration)
+{
+	SetBankConfiguration srb;
+	srb.objectID = objid;
+	srb.configuration = configuration;
+	sendAndApply(srb);
+}
+
+void CGameHandler::setRewardableObjectConfiguration(ObjectInstanceID objid, const Rewardable::Configuration & configuration)
+{
+	SetRewardableConfiguration srb;
+	srb.objectID = objid;
+	srb.configuration = configuration;
+	sendAndApply(srb);
+}
+
+void CGameHandler::setRewardableObjectConfiguration(ObjectInstanceID townInstanceID, BuildingID buildingID, const Rewardable::Configuration & configuration)
+{
+	SetRewardableConfiguration srb;
+	srb.objectID = townInstanceID;
+	srb.buildingID = buildingID;
+	srb.configuration = configuration;
+	sendAndApply(srb);
 }
 
 void CGameHandler::showInfoDialog(InfoWindow * iw)
 {
-	sendAndApply(iw);
+	sendAndApply(*iw);
 }
 
-CRandomGenerator & CGameHandler::getRandomGenerator()
+vstd::RNG & CGameHandler::getRandomGenerator()
 {
-	return CRandomGenerator::getDefault();
+	return *randomNumberGenerator;
 }
 
 #if SCRIPTING_ENABLED
@@ -4400,27 +4230,83 @@
 //}
 #endif
 
-void CGameHandler::createObject(const int3 & visitablePosition, const PlayerColor & initiator, MapObjectID type, MapObjectSubID subtype)
+
+CGObjectInstance * CGameHandler::createNewObject(const int3 & visitablePosition, MapObjectID objectID, MapObjectSubID subID)
 {
-	NewObject no;
-	no.ID = type;
-	no.subID = subtype;
-	no.initiator = initiator;
-	no.targetPos = visitablePosition;
-	sendAndApply(&no);
+	TerrainId terrainType = ETerrainId::NONE;
+
+	if (!gs->isInTheMap(visitablePosition))
+		throw std::runtime_error("Attempt to create object outside map at " + visitablePosition.toString());
+
+	const TerrainTile & t = gs->map->getTile(visitablePosition);
+	terrainType = t.getTerrainID();
+
+	auto handler = VLC->objtypeh->getHandlerFor(objectID, subID);
+
+	CGObjectInstance * o = handler->create(gs->callback, nullptr);
+	handler->configureObject(o, getRandomGenerator());
+	assert(o->ID == objectID);
+
+	assert(!handler->getTemplates(terrainType).empty());
+	if (handler->getTemplates().empty())
+		throw std::runtime_error("Attempt to create object (" + std::to_string(objectID) + ", " + std::to_string(subID.getNum()) + ") with no templates!");
+
+	if (!handler->getTemplates(terrainType).empty())
+		o->appearance = handler->getTemplates(terrainType).front();
+	else
+		o->appearance = handler->getTemplates().front();
+
+	if (o->isVisitable())
+		o->setAnchorPos(visitablePosition + o->getVisitableOffset());
+	else
+		o->setAnchorPos(visitablePosition);
+
+	return o;
 }
 
-void CGameHandler::startBattlePrimary(const CArmedInstance *army1, const CArmedInstance *army2, int3 tile, const CGHeroInstance *hero1, const CGHeroInstance *hero2, bool creatureBank, const CGTownInstance *town)
+void CGameHandler::createWanderingMonster(const int3 & visitablePosition, CreatureID creature)
 {
-	battles->startBattlePrimary(army1, army2, tile, hero1, hero2, creatureBank, town);
+	auto createdObject = createNewObject(visitablePosition, Obj::MONSTER, creature);
+
+	auto * cre = dynamic_cast<CGCreature *>(createdObject);
+	assert(cre);
+	cre->notGrowingTeam = cre->neverFlees = false;
+	cre->character = 2;
+	cre->gainedArtifact = ArtifactID::NONE;
+	cre->identifier = -1;
+	cre->addToSlot(SlotID(0), new CStackInstance(creature, -1)); //add placeholder stack
+
+	newObject(createdObject, PlayerColor::NEUTRAL);
+}
+
+void CGameHandler::createBoat(const int3 & visitablePosition, BoatId type, PlayerColor initiator)
+{
+	auto createdObject = createNewObject(visitablePosition, Obj::BOAT, type);
+	newObject(createdObject, initiator);
+}
+
+void CGameHandler::createHole(const int3 & visitablePosition, PlayerColor initiator)
+{
+	auto createdObject = createNewObject(visitablePosition, Obj::HOLE, 0);
+	newObject(createdObject, initiator);
+}
+
+void CGameHandler::newObject(CGObjectInstance * object, PlayerColor initiator)
+{
+	object->initObj(gs->getRandomGenerator());
+
+	NewObject no;
+	no.newObject = object;
+	no.initiator = initiator;
+	sendAndApply(no);
 }
 
-void CGameHandler::startBattleI(const CArmedInstance *army1, const CArmedInstance *army2, int3 tile, bool creatureBank )
+void CGameHandler::startBattle(const CArmedInstance *army1, const CArmedInstance *army2, int3 tile, const CGHeroInstance *hero1, const CGHeroInstance *hero2, const BattleLayout & layout, const CGTownInstance *town)
 {
-	battles->startBattleI(army1, army2, tile, creatureBank);
+	battles->startBattle(army1, army2, tile, hero1, hero2, layout, town);
 }
 
-void CGameHandler::startBattleI(const CArmedInstance *army1, const CArmedInstance *army2, bool creatureBank )
+void CGameHandler::startBattle(const CArmedInstance *army1, const CArmedInstance *army2 )
 {
-	battles->startBattleI(army1, army2, creatureBank);
+	battles->startBattle(army1, army2);
 }
diff --color -urN vcmi-1.5.7/server/CGameHandler.h vcmi/server/CGameHandler.h
--- vcmi-1.5.7/server/CGameHandler.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/server/CGameHandler.h	2024-12-19 15:00:22.989151698 +0100
@@ -14,6 +14,8 @@
 #include "../lib/IGameCallback.h"
 #include "../lib/LoadProgress.h"
 #include "../lib/ScriptHandler.h"
+#include "../lib/gameState/GameStatistics.h"
+#include "../lib/networkPacks/PacksForServer.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
@@ -23,8 +25,8 @@
 class CConnection;
 class CCommanderInstance;
 class EVictoryLossCheckResult;
+class CRandomGenerator;
 
-struct CPack;
 struct CPackForServer;
 struct NewTurn;
 struct CGarrisonOperationPack;
@@ -38,8 +40,6 @@
 }
 #endif
 
-template<typename T> class CApplier;
-
 VCMI_LIB_NAMESPACE_END
 
 class HeroPoolProcessor;
@@ -51,11 +51,11 @@
 class TurnTimerHandler;
 class QueriesProcessor;
 class CObjectVisitQuery;
+class NewTurnProcessor;
 
 class CGameHandler : public IGameCallback, public Environment
 {
 	CVCMIServer * lobby;
-	std::shared_ptr<CApplier<CBaseForGHApply>> applier;
 
 public:
 	std::unique_ptr<HeroPoolProcessor> heroPool;
@@ -63,6 +63,8 @@
 	std::unique_ptr<QueriesProcessor> queries;
 	std::unique_ptr<TurnOrderProcessor> turnOrder;
 	std::unique_ptr<TurnTimerHandler> turnTimerHandler;
+	std::unique_ptr<NewTurnProcessor> newTurnProcessor;
+	std::unique_ptr<CRandomGenerator> randomNumberGenerator;
 
 	//use enums as parameters, because doMove(sth, true, false, true) is not readable
 	enum EGuardLook {CHECK_FOR_GUARDS, IGNORE_GUARDS};
@@ -86,10 +88,18 @@
 	CVCMIServer * gameLobby() const;
 
 	bool isValidObject(const CGObjectInstance *obj) const;
-	bool isBlockedByQueries(const CPack *pack, PlayerColor player);
+	bool isBlockedByQueries(const CPackForServer *pack, PlayerColor player);
 	bool isAllowedExchange(ObjectInstanceID id1, ObjectInstanceID id2);
 	void giveSpells(const CGTownInstance *t, const CGHeroInstance *h);
 
+	// Helpers to create new object of specified type
+
+	CGObjectInstance * createNewObject(const int3 & visitablePosition, MapObjectID objectID, MapObjectSubID subID);
+	void createWanderingMonster(const int3 & visitablePosition, CreatureID creature);
+	void createBoat(const int3 & visitablePosition, BoatId type, PlayerColor initiator) override;
+	void createHole(const int3 & visitablePosition, PlayerColor initiator);
+	void newObject(CGObjectInstance * object, PlayerColor initiator);
+
 	explicit CGameHandler(CVCMIServer * lobby);
 	~CGameHandler();
 
@@ -97,14 +107,14 @@
 	//from IGameCallback
 	//do sth
 	void changeSpells(const CGHeroInstance * hero, bool give, const std::set<SpellID> &spells) override;
+	void setResearchedSpells(const CGTownInstance * town, int level, const std::vector<SpellID> & spells, bool accepted) override;
 	bool removeObject(const CGObjectInstance * obj, const PlayerColor & initiator) override;
-	void createObject(const int3 & visitablePosition, const PlayerColor & initiator, MapObjectID type, MapObjectSubID subtype) override;
 	void setOwner(const CGObjectInstance * obj, PlayerColor owner) override;
 	void giveExperience(const CGHeroInstance * hero, TExpType val) override;
 	void changePrimSkill(const CGHeroInstance * hero, PrimarySkill which, si64 val, bool abs=false) override;
 	void changeSecSkill(const CGHeroInstance * hero, SecondarySkill which, int val, bool abs=false) override;
 
-	void showBlockingDialog(BlockingDialog *iw) override;
+	void showBlockingDialog(const IObjectInterface * caller, BlockingDialog *iw) override;
 	void showTeleportDialog(TeleportDialog *iw) override;
 	void showGarrisonDialog(ObjectInstanceID upobj, ObjectInstanceID hid, bool removableUnits) override;
 	void showObjectWindow(const CGObjectInstance * object, EOpenWindowMode window, const CGHeroInstance * visitor, bool addQuery) override;
@@ -124,12 +134,15 @@
 
 	void removeAfterVisit(const CGObjectInstance *object) override;
 
-	bool giveHeroNewArtifact(const CGHeroInstance * h, const CArtifact * artType, ArtifactPosition pos = ArtifactPosition::FIRST_AVAILABLE) override;
-	bool putArtifact(const ArtifactLocation & al, const CArtifactInstance * art, std::optional<bool> askAssemble) override;
+	bool giveHeroNewArtifact(const CGHeroInstance * h, const CArtifact * artType, const SpellID & spellId, const ArtifactPosition & pos);
+	bool giveHeroNewArtifact(const CGHeroInstance * h, const ArtifactID & artId, const ArtifactPosition & pos) override;
+	bool giveHeroNewScroll(const CGHeroInstance * h, const SpellID & spellId, const ArtifactPosition & pos) override;
+	bool putArtifact(const ArtifactLocation & al, const ArtifactInstanceID & id, std::optional<bool> askAssemble) override;
 	void removeArtifact(const ArtifactLocation &al) override;
+	void removeArtifact(const ObjectInstanceID & srcId, const std::vector<ArtifactPosition> & slotsPack);
 	bool moveArtifact(const PlayerColor & player, const ArtifactLocation & src, const ArtifactLocation & dst) override;
 	bool bulkMoveArtifacts(const PlayerColor & player, ObjectInstanceID srcId, ObjectInstanceID dstId, bool swap, bool equipped, bool backpack);
-	bool scrollBackpackArtifacts(const PlayerColor & player, const ObjectInstanceID heroID, bool left);
+	bool manageBackpackArtifacts(const PlayerColor & player, const ObjectInstanceID heroID, const ManageBackpackArtifacts::ManageCmd & sortType);
 	bool saveArtifactsCostume(const PlayerColor & player, const ObjectInstanceID heroID, uint32_t costumeIdx);
 	bool switchArtifactsCostume(const PlayerColor & player, const ObjectInstanceID heroID, uint32_t costumeIdx);
 	bool eraseArtifactByClient(const ArtifactLocation & al);
@@ -137,9 +150,8 @@
 
 	void heroVisitCastle(const CGTownInstance * obj, const CGHeroInstance * hero) override;
 	void stopHeroVisitCastle(const CGTownInstance * obj, const CGHeroInstance * hero) override;
-	void startBattlePrimary(const CArmedInstance *army1, const CArmedInstance *army2, int3 tile, const CGHeroInstance *hero1, const CGHeroInstance *hero2, bool creatureBank = false, const CGTownInstance *town = nullptr) override; //use hero=nullptr for no hero
-	void startBattleI(const CArmedInstance *army1, const CArmedInstance *army2, int3 tile, bool creatureBank = false) override; //if any of armies is hero, hero will be used
-	void startBattleI(const CArmedInstance *army1, const CArmedInstance *army2, bool creatureBank = false) override; //if any of armies is hero, hero will be used, visitable tile of second obj is place of battle
+	void startBattle(const CArmedInstance *army1, const CArmedInstance *army2, int3 tile, const CGHeroInstance *hero1, const CGHeroInstance *hero2, const BattleLayout & layout, const CGTownInstance *town) override; //use hero=nullptr for no hero
+	void startBattle(const CArmedInstance *army1, const CArmedInstance *army2) override; //if any of armies is hero, hero will be used, visitable tile of second obj is place of battle
 	bool moveHero(ObjectInstanceID hid, int3 dst, EMovementMode movementMode, bool transit = false, PlayerColor asker = PlayerColor::NEUTRAL) override;
 	void giveHeroBonus(GiveBonus * bonus) override;
 	void setMovePoints(SetMovePoints * smp) override;
@@ -150,7 +162,7 @@
 	void heroExchange(ObjectInstanceID hero1, ObjectInstanceID hero2) override;
 
 	void changeFogOfWar(int3 center, ui32 radius, PlayerColor player, ETileVisibility mode) override;
-	void changeFogOfWar(std::unordered_set<int3> &tiles, PlayerColor player,ETileVisibility mode) override;
+	void changeFogOfWar(const std::unordered_set<int3> &tiles, PlayerColor player,ETileVisibility mode) override;
 	
 	void castSpell(const spells::Caster * caster, SpellID spellID, const int3 &pos) override;
 
@@ -160,6 +172,9 @@
 	bool isVisitCoveredByAnotherQuery(const CGObjectInstance *obj, const CGHeroInstance *hero) override;
 	void setObjPropertyValue(ObjectInstanceID objid, ObjProperty prop, int32_t value) override;
 	void setObjPropertyID(ObjectInstanceID objid, ObjProperty prop, ObjPropertyID identifier) override;
+	void setBankObjectConfiguration(ObjectInstanceID objid, const BankConfig & configuration) override;
+	void setRewardableObjectConfiguration(ObjectInstanceID objid, const Rewardable::Configuration & configuration) override;
+	void setRewardableObjectConfiguration(ObjectInstanceID townInstanceID, BuildingID buildingID, const Rewardable::Configuration & configuration) override;
 	void showInfoDialog(InfoWindow * iw) override;
 
 	//////////////////////////////////////////////////////////////////////////
@@ -168,6 +183,7 @@
 	void visitObjectOnTile(const TerrainTile &t, const CGHeroInstance * h);
 	bool teleportHero(ObjectInstanceID hid, ObjectInstanceID dstid, ui8 source, PlayerColor asker = PlayerColor::NEUTRAL);
 	void visitCastleObjects(const CGTownInstance * obj, const CGHeroInstance * hero) override;
+	void visitCastleObjects(const CGTownInstance * obj, std::vector<const CGHeroInstance * > visitors);
 	void levelUpHero(const CGHeroInstance * hero, SecondarySkill skill);//handle client respond and send one more request if needed
 	void levelUpHero(const CGHeroInstance * hero);//initial call - check if hero have remaining levelups & handle them
 	void levelUpCommander (const CCommanderInstance * c, int skill); //secondary skill 1 to 6, special skill : skill - 100
@@ -178,7 +194,7 @@
 
 	void init(StartInfo *si, Load::ProgressAccumulator & progressTracking);
 	void handleClientDisconnection(std::shared_ptr<CConnection> c);
-	void handleReceivedPack(CPackForServer * pack);
+	void handleReceivedPack(CPackForServer & pack);
 	bool hasPlayerAt(PlayerColor player, std::shared_ptr<CConnection> c) const;
 	bool hasBothPlayersAtSameConnection(PlayerColor left, PlayerColor right) const;
 
@@ -201,7 +217,9 @@
 	bool upgradeCreature( ObjectInstanceID objid, SlotID pos, CreatureID upgID );
 	bool recruitCreatures(ObjectInstanceID objid, ObjectInstanceID dst, CreatureID crid, ui32 cram, si32 level, PlayerColor player);
 	bool buildStructure(ObjectInstanceID tid, BuildingID bid, bool force=false);//force - for events: no cost, no checkings
+	bool visitTownBuilding(ObjectInstanceID tid, BuildingID bid);
 	bool razeStructure(ObjectInstanceID tid, BuildingID bid);
+	bool spellResearch(ObjectInstanceID tid, SpellID spellAtSlot, bool accepted);
 	bool disbandCreature( ObjectInstanceID id, SlotID pos );
 	bool arrangeStacks( ObjectInstanceID id1, ObjectInstanceID id2, ui8 what, SlotID p1, SlotID p2, si32 val, PlayerColor player);
 	bool bulkMoveArmy(ObjectInstanceID srcArmy, ObjectInstanceID destArmy, SlotID srcSlot);
@@ -214,26 +232,23 @@
 	void onPlayerTurnStarted(PlayerColor which);
 	void onPlayerTurnEnded(PlayerColor which);
 	void onNewTurn();
+	void addStatistics(StatisticDataSet &stat) const;
 
-	void handleTimeEvents();
-	void handleTownEvents(CGTownInstance *town, NewTurn &n);
 	bool complain(const std::string &problem); //sends message to all clients, prints on the logs and return true
 	void objectVisited( const CGObjectInstance * obj, const CGHeroInstance * h );
-	void objectVisitEnded(const CObjectVisitQuery &query);
+	void objectVisitEnded(const CGHeroInstance *h, PlayerColor player);
 	bool dig(const CGHeroInstance *h);
 	void moveArmy(const CArmedInstance *src, const CArmedInstance *dst, bool allowMerging);
 
 	template <typename Handler> void serialize(Handler &h)
 	{
 		h & QID;
-		h & getRandomGenerator();
+		h & *randomNumberGenerator;
 		h & *battles;
 		h & *heroPool;
 		h & *playerMessages;
 		h & *turnOrder;
-
-		if (h.version >= Handler::Version::TURN_TIMERS_STATE)
-			h & *turnTimerHandler;
+		h & *turnTimerHandler;
 
 #if SCRIPTING_ENABLED
 		JsonNode scriptsState;
@@ -245,11 +260,11 @@
 #endif
 	}
 
-	void sendToAllClients(CPackForClient * pack);
-	void sendAndApply(CPackForClient * pack) override;
-	void sendAndApply(CGarrisonOperationPack * pack);
-	void sendAndApply(SetResources * pack);
-	void sendAndApply(NewStructures * pack);
+	void sendToAllClients(CPackForClient & pack);
+	void sendAndApply(CPackForClient & pack) override;
+	void sendAndApply(CGarrisonOperationPack & pack);
+	void sendAndApply(SetResources & pack);
+	void sendAndApply(NewStructures & pack);
 
 	void wrongPlayerMessage(CPackForServer * pack, PlayerColor expectedplayer);
 	/// Unconditionally throws with "Action not allowed" message
@@ -267,7 +282,7 @@
 
 	void start(bool resume);
 	void tick(int millisecondsPassed);
-	bool sacrificeArtifact(const IMarket * m, const CGHeroInstance * hero, const std::vector<ArtifactInstanceID> & arts);
+	bool sacrificeArtifact(const IMarket * market, const CGHeroInstance * hero, const std::vector<ArtifactInstanceID> & arts);
 	void spawnWanderingMonsters(CreatureID creatureID);
 
 	// Check for victory and loss conditions
@@ -275,7 +290,7 @@
 	void checkVictoryLossConditions(const std::set<PlayerColor> & playerColors);
 	void checkVictoryLossConditionsForAll();
 
-	CRandomGenerator & getRandomGenerator();
+	vstd::RNG & getRandomGenerator() override;
 
 #if SCRIPTING_ENABLED
 	scripting::Pool * getGlobalContextPool() const override;
diff --color -urN vcmi-1.5.7/server/CMakeLists.txt vcmi/server/CMakeLists.txt
--- vcmi-1.5.7/server/CMakeLists.txt	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/server/CMakeLists.txt	2024-12-19 15:00:22.989151698 +0100
@@ -9,9 +9,11 @@
 		queries/BattleQueries.cpp
 		queries/CQuery.cpp
 		queries/MapQueries.cpp
+		queries/VisitQueries.cpp
 		queries/QueriesProcessor.cpp
 
 		processors/HeroPoolProcessor.cpp
+		processors/NewTurnProcessor.cpp
 		processors/PlayerMessageProcessor.cpp
 		processors/TurnOrderProcessor.cpp
 
@@ -35,9 +37,11 @@
 		queries/BattleQueries.h
 		queries/CQuery.h
 		queries/MapQueries.h
+		queries/VisitQueries.h
 		queries/QueriesProcessor.h
 
 		processors/HeroPoolProcessor.h
+		processors/NewTurnProcessor.h
 		processors/PlayerMessageProcessor.h
 		processors/TurnOrderProcessor.h
 
diff --color -urN vcmi-1.5.7/server/CVCMIServer.cpp vcmi/server/CVCMIServer.cpp
--- vcmi-1.5.7/server/CVCMIServer.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/server/CVCMIServer.cpp	2024-12-19 15:00:22.990151740 +0100
@@ -15,12 +15,18 @@
 #include "LobbyNetPackVisitors.h"
 #include "processors/PlayerMessageProcessor.h"
 
-#include "../lib/CHeroHandler.h"
 #include "../lib/CPlayerState.h"
-#include "../lib/MetaString.h"
-#include "../lib/registerTypes/RegisterTypesLobbyPacks.h"
+#include "../lib/campaign/CampaignState.h"
+#include "../lib/entities/hero/CHeroHandler.h"
+#include "../lib/entities/hero/CHeroClass.h"
+#include "../lib/gameState/CGameState.h"
+#include "../lib/mapping/CMapDefines.h"
+#include "../lib/mapping/CMapInfo.h"
+#include "../lib/mapping/CMapHeader.h"
+#include "../lib/rmg/CMapGenOptions.h"
 #include "../lib/serializer/CMemorySerializer.h"
 #include "../lib/serializer/Connection.h"
+#include "../lib/texts/CGeneralTextHandler.h"
 
 // UUID generation
 #include <boost/uuid/uuid.hpp>
@@ -28,64 +34,6 @@
 #include <boost/uuid/uuid_generators.hpp>
 #include <boost/program_options.hpp>
 
-template<typename T> class CApplyOnServer;
-
-class CBaseForServerApply
-{
-public:
-	virtual bool applyOnServerBefore(CVCMIServer * srv, CPack * pack) const =0;
-	virtual void applyOnServerAfter(CVCMIServer * srv, CPack * pack) const =0;
-	virtual ~CBaseForServerApply() {}
-	template<typename U> static CBaseForServerApply * getApplier(const U * t = nullptr)
-	{
-		return new CApplyOnServer<U>();
-	}
-};
-
-template <typename T> class CApplyOnServer : public CBaseForServerApply
-{
-public:
-	bool applyOnServerBefore(CVCMIServer * srv, CPack * pack) const override
-	{
-		T * ptr = static_cast<T *>(pack);
-		ClientPermissionsCheckerNetPackVisitor checker(*srv);
-		ptr->visit(checker);
-
-		if(checker.getResult())
-		{
-			ApplyOnServerNetPackVisitor applier(*srv);
-			ptr->visit(applier);
-			return applier.getResult();
-		}
-		else
-			return false;
-	}
-
-	void applyOnServerAfter(CVCMIServer * srv, CPack * pack) const override
-	{
-		T * ptr = static_cast<T *>(pack);
-		ApplyOnServerAfterAnnounceNetPackVisitor applier(*srv);
-		ptr->visit(applier);
-	}
-};
-
-template <>
-class CApplyOnServer<CPack> : public CBaseForServerApply
-{
-public:
-	bool applyOnServerBefore(CVCMIServer * srv, CPack * pack) const override
-	{
-		logGlobal->error("Cannot apply plain CPack!");
-		assert(0);
-		return false;
-	}
-	void applyOnServerAfter(CVCMIServer * srv, CPack * pack) const override
-	{
-		logGlobal->error("Cannot apply plain CPack!");
-		assert(0);
-	}
-};
-
 class CVCMIServerPackVisitor : public VCMI_LIB_WRAP_NAMESPACE(ICPackVisitor)
 {
 private:
@@ -102,13 +50,13 @@
 
 	void visitForLobby(CPackForLobby & packForLobby) override
 	{
-		handler.handleReceivedPack(std::unique_ptr<CPackForLobby>(&packForLobby));
+		handler.handleReceivedPack(packForLobby);
 	}
 
 	void visitForServer(CPackForServer & serverPack) override
 	{
 		if (gh)
-			gh->handleReceivedPack(&serverPack);
+			gh->handleReceivedPack(serverPack);
 		else
 			logNetwork->error("Received pack for game server while in lobby!");
 	}
@@ -118,7 +66,7 @@
 	}
 };
 
-CVCMIServer::CVCMIServer(uint16_t port, bool connectToLobby, bool runByClient)
+CVCMIServer::CVCMIServer(uint16_t port, bool runByClient)
 	: currentClientId(1)
 	, currentPlayerId(1)
 	, port(port)
@@ -126,26 +74,32 @@
 {
 	uuid = boost::uuids::to_string(boost::uuids::random_generator()());
 	logNetwork->trace("CVCMIServer created! UUID: %s", uuid);
-	applier = std::make_shared<CApplier<CBaseForServerApply>>();
-	registerTypesLobbyPacks(*applier);
 
 	networkHandler = INetworkHandler::createHandler();
-
-	if(connectToLobby)
-		lobbyProcessor = std::make_unique<GlobalLobbyProcessor>(*this);
-	else
-		startAcceptingIncomingConnections();
 }
 
 CVCMIServer::~CVCMIServer() = default;
 
-void CVCMIServer::startAcceptingIncomingConnections()
+uint16_t CVCMIServer::prepare(bool connectToLobby) {
+	if(connectToLobby) {
+		lobbyProcessor = std::make_unique<GlobalLobbyProcessor>(*this);
+		return 0;
+	} else {
+		return startAcceptingIncomingConnections();
+	}
+}
+
+uint16_t CVCMIServer::startAcceptingIncomingConnections()
 {
-	logNetwork->info("Port %d will be used", port);
+	port
+		? logNetwork->info("Port %d will be used", port)
+		: logNetwork->info("Randomly assigned port will be used");
 
+	// config port may be 0 => srvport will contain the OS-assigned port value
 	networkServer = networkHandler->createServerTCP(*this);
-	networkServer->start(port);
-	logNetwork->info("Listening for connections at port %d", port);
+	auto srvport = networkServer->start(port);
+	logNetwork->info("Listening for connections at port %d", srvport);
+	return srvport;
 }
 
 void CVCMIServer::onNewConnection(const std::shared_ptr<INetworkConnection> & connection)
@@ -245,7 +199,6 @@
 	}
 
 	* si = * gh->gs->initialOpts;
-	si->seedToBeUsed = si->seedPostInit = 0;
 	setState(EServerState::LOBBY);
 	if (si->campState)
 	{
@@ -279,9 +232,9 @@
 			{
 				//FIXME: UNGUARDED MULTITHREADED ACCESS!!!
 				currentProgress = progressTracking.get();
-				std::unique_ptr<LobbyLoadProgress> loadProgress(new LobbyLoadProgress);
-				loadProgress->progress = currentProgress;
-				announcePack(std::move(loadProgress));
+				LobbyLoadProgress loadProgress;
+				loadProgress.progress = currentProgress;
+				announcePack(loadProgress);
 			}
 			boost::this_thread::sleep(boost::posix_time::milliseconds(50));
 		}
@@ -292,7 +245,7 @@
 	{
 	case EStartMode::CAMPAIGN:
 		logNetwork->info("Preparing to start new campaign");
-		si->startTimeIso8601 = vstd::getDateTimeISO8601Basic(std::time(nullptr));
+		si->startTime = std::time(nullptr);
 		si->fileURI = mi->fileURI;
 		si->campState->setCurrentMap(campaignMap);
 		si->campState->setCurrentMapBonus(campaignBonus);
@@ -301,7 +254,7 @@
 
 	case EStartMode::NEW_GAME:
 		logNetwork->info("Preparing to start new game");
-		si->startTimeIso8601 = vstd::getDateTimeISO8601Basic(std::time(nullptr));
+		si->startTime = std::time(nullptr);
 		si->fileURI = mi->fileURI;
 		gh->init(si.get(), progressTracking);
 		break;
@@ -345,36 +298,32 @@
 	logNetwork->error("Network error receiving a pack. Connection has been closed");
 
 	std::shared_ptr<CConnection> c = findConnection(connection);
-	if (!c)
-		return; // player have already disconnected via clientDisconnected call
 
-	vstd::erase(activeConnections, c);
-
-	if(activeConnections.empty() || hostClientId == c->connectionID)
+	// player may have already disconnected via clientDisconnected call
+	if (c)
 	{
-		setState(EServerState::SHUTDOWN);
-		return;
-	}
-
-	if(gh && getState() == EServerState::GAMEPLAY)
-	{
-		gh->handleClientDisconnection(c);
-
-		auto lcd = std::make_unique<LobbyClientDisconnected>();
-		lcd->c = c;
-		lcd->clientId = c->connectionID;
-		handleReceivedPack(std::move(lcd));
+		LobbyClientDisconnected lcd;
+		lcd.c = c;
+		lcd.clientId = c->connectionID;
+		handleReceivedPack(lcd);
 	}
 }
 
-void CVCMIServer::handleReceivedPack(std::unique_ptr<CPackForLobby> pack)
+void CVCMIServer::handleReceivedPack(CPackForLobby & pack)
 {
-	CBaseForServerApply * apply = applier->getApplier(CTypeList::getInstance().getTypeID(pack.get()));
-	if(apply->applyOnServerBefore(this, pack.get()))
-		announcePack(std::move(pack));
+	ClientPermissionsCheckerNetPackVisitor checker(*this);
+	pack.visit(checker);
+
+	if(checker.getResult())
+	{
+		ApplyOnServerNetPackVisitor applier(*this);
+		pack.visit(applier);
+		if (applier.getResult())
+			announcePack(pack);
+	}
 }
 
-void CVCMIServer::announcePack(std::unique_ptr<CPackForLobby> pack)
+void CVCMIServer::announcePack(CPackForLobby & pack)
 {
 	for(auto activeConnection : activeConnections)
 	{
@@ -382,18 +331,19 @@
 		// Until UUID set we only pass LobbyClientConnected to this client
 		//if(c->uuid == uuid && !dynamic_cast<LobbyClientConnected *>(pack.get()))
 		//	continue;
-		activeConnection->sendPack(pack.get());
+		activeConnection->sendPack(pack);
 	}
 
-	applier->getApplier(CTypeList::getInstance().getTypeID(pack.get()))->applyOnServerAfter(this, pack.get());
+	ApplyOnServerAfterAnnounceNetPackVisitor applier(*this);
+	pack.visit(applier);
 }
 
-void CVCMIServer::announceMessage(MetaString txt)
+void CVCMIServer::announceMessage(const MetaString & txt)
 {
 	logNetwork->info("Show message: %s", txt.toString());
-	auto cm = std::make_unique<LobbyShowMessage>();
-	cm->message = txt;
-	announcePack(std::move(cm));
+	LobbyShowMessage cm;
+	cm.message = txt;
+	announcePack(cm);
 }
 
 void CVCMIServer::announceMessage(const std::string & txt)
@@ -403,13 +353,13 @@
 	announceMessage(str);
 }
 
-void CVCMIServer::announceTxt(MetaString txt, const std::string & playerName)
+void CVCMIServer::announceTxt(const MetaString & txt, const std::string & playerName)
 {
 	logNetwork->info("%s says: %s", playerName, txt.toString());
-	auto cm = std::make_unique<LobbyChatMessage>();
-	cm->playerName = playerName;
-	cm->message = txt;
-	announcePack(std::move(cm));
+	LobbyChatMessage cm;
+	cm.playerName = playerName;
+	cm.message = txt;
+	announcePack(cm);
 }
 
 void CVCMIServer::announceTxt(const std::string & txt, const std::string & playerName)
@@ -474,9 +424,21 @@
 
 void CVCMIServer::clientDisconnected(std::shared_ptr<CConnection> connection)
 {
-	connection->getConnection()->close();
+	assert(vstd::contains(activeConnections, connection));
+	logGlobal->trace("Received disconnection request");
 	vstd::erase(activeConnections, connection);
 
+	if(activeConnections.empty() || hostClientId == connection->connectionID)
+	{
+		setState(EServerState::SHUTDOWN);
+		return;
+	}
+
+	if(gh && getState() == EServerState::GAMEPLAY)
+	{
+		gh->handleClientDisconnection(connection);
+	}
+
 //	PlayerReinitInterface startAiPack;
 //	startAiPack.playerConnectionId = PlayerSettings::PLAYER_AI;
 //
@@ -510,7 +472,7 @@
 //	}
 //
 //	if(!startAiPack.players.empty())
-//		gh->sendAndApply(&startAiPack);
+//		gh->sendAndApply(startAiPack);
 }
 
 void CVCMIServer::reconnectPlayer(int connId)
@@ -537,7 +499,7 @@
 		}
 
 		if(!startAiPack.players.empty())
-			gh->sendAndApply(&startAiPack);
+			gh->sendAndApply(startAiPack);
 	}
 }
 
@@ -617,8 +579,6 @@
 				pset.heroNameTextId = pinfo.mainCustomHeroNameTextId;
 				pset.heroPortrait = pinfo.mainCustomHeroPortrait;
 			}
-
-			pset.handicap = PlayerSettings::NO_HANDICAP;
 		}
 
 		if(mi->isRandomMap && mapGenOpts)
@@ -669,9 +629,9 @@
 		}
 	}
 
-	auto lus = std::make_unique<LobbyUpdateState>();
-	lus->state = *this;
-	announcePack(std::move(lus));
+	LobbyUpdateState lus;
+	lus.state = *this;
+	announcePack(lus);
 }
 
 void CVCMIServer::setPlayer(PlayerColor clickedColor)
@@ -690,7 +650,7 @@
 	//identify clicked player
 	int clickedNameID = 0; //number of player - zero means AI, assume it initially
 	if(clicked.isControlledByHuman())
-		clickedNameID = *(clicked.connectedPlayerIDs.begin()); //if not AI - set appropiate ID
+		clickedNameID = *(clicked.connectedPlayerIDs.begin()); //if not AI - set appropriate ID
 
 	if(clickedNameID > 0 && playerToRestore.id == clickedNameID) //player to restore is about to being replaced -> put him back to the old place
 	{
@@ -752,12 +712,66 @@
 	if(player.connectedPlayerIDs.empty())
 		return;
 
-	int nameID = *(player.connectedPlayerIDs.begin()); //if not AI - set appropiate ID
+	int nameID = *(player.connectedPlayerIDs.begin()); //if not AI - set appropriate ID
 
 	playerNames[nameID].name = name;
 	setPlayerConnectedId(player, nameID);
 }
 
+void CVCMIServer::setPlayerHandicap(PlayerColor color, Handicap handicap)
+{
+	if(color == PlayerColor::CANNOT_DETERMINE)
+		return;
+
+	si->playerInfos[color].handicap = handicap;
+
+	int humanPlayer = 0;
+	for (const auto & pi : si->playerInfos)
+		if(pi.second.isControlledByHuman())
+			humanPlayer++;
+
+	if(humanPlayer < 2) // Singleplayer
+		return;
+
+	MetaString str;
+	str.appendTextID("vcmi.lobby.handicap");
+	str.appendRawString(" ");
+	str.appendName(color);
+	str.appendRawString(":");
+
+	if(handicap.startBonus.empty() && handicap.percentIncome == 100 && handicap.percentGrowth == 100)
+	{
+		str.appendRawString(" ");
+		str.appendTextID("core.genrltxt.523");
+		announceTxt(str);
+		return;
+	}
+
+	for(auto & res : EGameResID::ALL_RESOURCES())
+		if(handicap.startBonus[res] != 0)
+		{
+			str.appendRawString(" ");
+			str.appendName(res);
+			str.appendRawString(":");
+			str.appendRawString(std::to_string(handicap.startBonus[res]));
+		}
+	if(handicap.percentIncome != 100)
+	{
+		str.appendRawString(" ");
+		str.appendTextID("core.jktext.32");
+		str.appendRawString(":");
+		str.appendRawString(std::to_string(handicap.percentIncome) + "%");
+	}
+	if(handicap.percentGrowth != 100)
+	{
+		str.appendRawString(" ");
+		str.appendTextID("core.genrltxt.194");
+		str.appendRawString(":");
+		str.appendRawString(std::to_string(handicap.percentGrowth) + "%");
+	}
+	announceTxt(str);
+}
+
 void CVCMIServer::optionNextCastle(PlayerColor player, int dir)
 {
 	PlayerSettings & s = si->playerInfos[player];
@@ -995,20 +1009,53 @@
 void CVCMIServer::multiplayerWelcomeMessage()
 {
 	int humanPlayer = 0;
-	for (auto & pi : si->playerInfos)
+	for (const auto & pi : si->playerInfos)
 		if(pi.second.isControlledByHuman())
 			humanPlayer++;
 
 	if(humanPlayer < 2) // Singleplayer
 		return;
 
-	gh->playerMessages->broadcastSystemMessage("Use '!help' to list available commands");
+	gh->playerMessages->broadcastSystemMessage(MetaString::createFromTextID("vcmi.broadcast.command"));
+
+	for (const auto & pi : si->playerInfos)
+		if(!pi.second.handicap.startBonus.empty() || pi.second.handicap.percentIncome != 100 || pi.second.handicap.percentGrowth != 100)
+		{
+			MetaString str;
+			str.appendTextID("vcmi.lobby.handicap");
+			str.appendRawString(" ");
+			str.appendName(pi.first);
+			str.appendRawString(":");
+			for(auto & res : EGameResID::ALL_RESOURCES())
+				if(pi.second.handicap.startBonus[res] != 0)
+				{
+					str.appendRawString(" ");
+					str.appendName(res);
+					str.appendRawString(":");
+					str.appendRawString(std::to_string(pi.second.handicap.startBonus[res]));
+				}
+			if(pi.second.handicap.percentIncome != 100)
+			{
+				str.appendRawString(" ");
+				str.appendTextID("core.jktext.32");
+				str.appendRawString(":");
+				str.appendRawString(std::to_string(pi.second.handicap.percentIncome) + "%");
+			}
+			if(pi.second.handicap.percentGrowth != 100)
+			{
+				str.appendRawString(" ");
+				str.appendTextID("core.genrltxt.194");
+				str.appendRawString(":");
+				str.appendRawString(std::to_string(pi.second.handicap.percentGrowth) + "%");
+			}
+			gh->playerMessages->broadcastSystemMessage(str);
+		}
 
 	std::vector<std::string> optionIds;
 	if(si->extraOptionsInfo.cheatsAllowed)
-		optionIds.push_back("vcmi.optionsTab.cheatAllowed.hover");
+		optionIds.emplace_back("vcmi.optionsTab.cheatAllowed.hover");
 	if(si->extraOptionsInfo.unlimitedReplay)
-		optionIds.push_back("vcmi.optionsTab.unlimitedReplay.hover");
+		optionIds.emplace_back("vcmi.optionsTab.unlimitedReplay.hover");
 
 	if(!optionIds.size()) // No settings to publish
 		return;
diff --color -urN vcmi-1.5.7/server/CVCMIServer.h vcmi/server/CVCMIServer.h
--- vcmi-1.5.7/server/CVCMIServer.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/server/CVCMIServer.h	2024-12-19 15:00:22.990151740 +0100
@@ -25,8 +25,6 @@
 class PlayerColor;
 class MetaString;
 
-template<typename T> class CApplier;
-
 VCMI_LIB_NAMESPACE_END
 
 class CGameHandler;
@@ -52,7 +50,6 @@
 
 	std::unique_ptr<INetworkHandler> networkHandler;
 
-	std::shared_ptr<CApplier<CBaseForServerApply>> applier;
 	EServerState state = EServerState::LOBBY;
 
 	std::shared_ptr<CConnection> findConnection(const std::shared_ptr<INetworkConnection> &);
@@ -66,6 +63,8 @@
 	/// List of all active connections
 	std::vector<std::shared_ptr<CConnection>> activeConnections;
 
+	uint16_t prepare(bool connectToLobby);
+
 	// INetworkListener impl
 	void onDisconnected(const std::shared_ptr<INetworkConnection> & connection, const std::string & errorMessage) override;
 	void onPacketReceived(const std::shared_ptr<INetworkConnection> & connection, const std::vector<std::byte> & message) override;
@@ -74,7 +73,7 @@
 
 	std::shared_ptr<CGameHandler> gh;
 
-	CVCMIServer(uint16_t port, bool connectToLobby, bool runByClient);
+	CVCMIServer(uint16_t port, bool runByClient);
 	~CVCMIServer();
 
 	void run();
@@ -83,14 +82,14 @@
 	bool prepareToStartGame();
 	void prepareToRestart();
 	void startGameImmediately();
-	void startAcceptingIncomingConnections();
+	uint16_t startAcceptingIncomingConnections();
 
 	void threadHandleClient(std::shared_ptr<CConnection> c);
 
-	void announcePack(std::unique_ptr<CPackForLobby> pack);
+	void announcePack(CPackForLobby & pack);
 	bool passHost(int toConnectionId);
 
-	void announceTxt(MetaString txt, const std::string & playerName = "system");
+	void announceTxt(const MetaString & txt, const std::string & playerName = "system");
 	void announceTxt(const std::string & txt, const std::string & playerName = "system");
 
 	void setPlayerConnectedId(PlayerSettings & pset, ui8 player) const;
@@ -100,10 +99,10 @@
 	void clientDisconnected(std::shared_ptr<CConnection> c);
 	void reconnectPlayer(int connId);
 
-	void announceMessage(MetaString txt);
+	void announceMessage(const MetaString & txt);
 	void announceMessage(const std::string & txt);
 
-	void handleReceivedPack(std::unique_ptr<CPackForLobby> pack);
+	void handleReceivedPack(CPackForLobby & pack);
 
 	void updateAndPropagateLobbyState();
 
@@ -115,6 +114,7 @@
 	// Work with LobbyInfo
 	void setPlayer(PlayerColor clickedColor);
 	void setPlayerName(PlayerColor player, std::string name);
+	void setPlayerHandicap(PlayerColor player, Handicap handicap);
 	void optionNextHero(PlayerColor player, int dir); //dir == -1 or +1
 	void optionSetHero(PlayerColor player, HeroTypeID id);
 	HeroTypeID nextAllowedHero(PlayerColor player, HeroTypeID id, int direction);
diff --color -urN vcmi-1.5.7/server/GlobalLobbyProcessor.cpp vcmi/server/GlobalLobbyProcessor.cpp
--- vcmi-1.5.7/server/GlobalLobbyProcessor.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/server/GlobalLobbyProcessor.cpp	2024-12-19 15:00:22.990151740 +0100
@@ -15,7 +15,8 @@
 #include "../lib/json/JsonUtils.h"
 #include "../lib/VCMI_Lib.h"
 #include "../lib/modding/CModHandler.h"
-#include "../lib/modding/CModInfo.h"
+#include "../lib/modding/ModDescription.h"
+#include "../lib/modding/ModVerificationInfo.h"
 
 GlobalLobbyProcessor::GlobalLobbyProcessor(CVCMIServer & owner)
 	: owner(owner)
@@ -67,7 +68,7 @@
 {
 	if (connection == controlConnection)
 	{
-		JsonNode json(message.data(), message.size());
+		JsonNode json(message.data(), message.size(), "<lobby network packet>");
 
 		if(json["type"].String() == "operationFailed")
 			return receiveOperationFailed(json);
@@ -97,7 +98,7 @@
 void GlobalLobbyProcessor::receiveServerLoginSuccess(const JsonNode & json)
 {
 	// no-op, wait just for any new commands from lobby
-	logGlobal->info("Lobby: Succesfully connected to lobby server");
+	logGlobal->info("Lobby: Successfully connected to lobby server");
 	owner.startAcceptingIncomingConnections();
 }
 
@@ -161,7 +162,7 @@
 
 	for (auto const & modName : VLC->modh->getActiveMods())
 	{
-		if(VLC->modh->getModInfo(modName).checkModGameplayAffecting())
+		if(VLC->modh->getModInfo(modName).affectsGameplay())
 			info[modName] = VLC->modh->getModInfo(modName).getVerificationInfo();
 	}
 
diff --color -urN vcmi-1.5.7/server/LobbyNetPackVisitors.h vcmi/server/LobbyNetPackVisitors.h
--- vcmi-1.5.7/server/LobbyNetPackVisitors.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/server/LobbyNetPackVisitors.h	2024-12-19 15:00:22.990151740 +0100
@@ -39,6 +39,7 @@
 	void visitLobbyChatMessage(LobbyChatMessage & pack) override;
 	void visitLobbyGuiAction(LobbyGuiAction & pack) override;
 	void visitLobbyPvPAction(LobbyPvPAction & pack) override;
+	void visitLobbyDelete(LobbyDelete & pack) override;
 };
 
 class ApplyOnServerAfterAnnounceNetPackVisitor : public VCMI_LIB_WRAP_NAMESPACE(ICPackVisitor)
@@ -89,10 +90,12 @@
 	void visitLobbyChangePlayerOption(LobbyChangePlayerOption & pack) override;
 	void visitLobbySetPlayer(LobbySetPlayer & pack) override;
 	void visitLobbySetPlayerName(LobbySetPlayerName & pack) override;
+	void visitLobbySetPlayerHandicap(LobbySetPlayerHandicap & pack) override;
 	void visitLobbySetTurnTime(LobbySetTurnTime & pack) override;
 	void visitLobbySetExtraOptions(LobbySetExtraOptions & pack) override;
 	void visitLobbySetSimturns(LobbySetSimturns & pack) override;
 	void visitLobbySetDifficulty(LobbySetDifficulty & pack) override;
 	void visitLobbyForceSetPlayer(LobbyForceSetPlayer & pack) override;
 	void visitLobbyPvPAction(LobbyPvPAction & pack) override;
+	void visitLobbyDelete(LobbyDelete & pack) override;
 };
diff --color -urN vcmi-1.5.7/server/NetPacksLobbyServer.cpp vcmi/server/NetPacksLobbyServer.cpp
--- vcmi-1.5.7/server/NetPacksLobbyServer.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/server/NetPacksLobbyServer.cpp	2024-12-19 15:00:22.990151740 +0100
@@ -17,10 +17,12 @@
 #include "../lib/CRandomGenerator.h"
 
 #include "../lib/campaign/CampaignState.h"
+#include "../lib/entities/faction/CTownHandler.h"
+#include "../lib/entities/faction/CFaction.h"
 #include "../lib/serializer/Connection.h"
 #include "../lib/mapping/CMapInfo.h"
 #include "../lib/mapping/CMapHeader.h"
-#include "../lib/CTownHandler.h"
+#include "../lib/filesystem/Filesystem.h"
 
 void ClientPermissionsCheckerNetPackVisitor::visitForLobby(CPackForLobby & pack)
 {
@@ -32,7 +34,7 @@
 
 void ApplyOnServerAfterAnnounceNetPackVisitor::visitForLobby(CPackForLobby & pack)
 {
-	// Propogate options after every CLobbyPackToServer
+	// Propagate options after every CLobbyPackToServer
 	if(pack.isForServer())
 	{
 		srv.updateAndPropagateLobbyState();
@@ -107,6 +109,7 @@
 
 void ApplyOnServerNetPackVisitor::visitLobbyClientDisconnected(LobbyClientDisconnected & pack)
 {
+	pack.c->getConnection()->close();
 	srv.clientDisconnected(pack.c);
 	result = true;
 }
@@ -126,10 +129,10 @@
 	}
 	else if(pack.c->connectionID == srv.hostClientId)
 	{
-		auto ph = std::make_unique<LobbyChangeHost>();
+		LobbyChangeHost ph;
 		auto newHost = srv.activeConnections.front();
-		ph->newHostConnectionId = newHost->connectionID;
-		srv.announcePack(std::move(ph));
+		ph.newHostConnectionId = newHost->connectionID;
+		srv.announcePack(ph);
 	}
 	srv.updateAndPropagateLobbyState();
 	
@@ -345,6 +348,12 @@
 	result = true;
 }
 
+void ApplyOnServerNetPackVisitor::visitLobbySetPlayerHandicap(LobbySetPlayerHandicap & pack)
+{
+	srv.setPlayerHandicap(pack.color, pack.handicap);
+	result = true;
+}
+
 void ApplyOnServerNetPackVisitor::visitLobbySetSimturns(LobbySetSimturns & pack)
 {
 	srv.si->simturnsInfo = pack.simturnsInfo;
@@ -375,7 +384,6 @@
 	result = true;
 }
 
-
 void ClientPermissionsCheckerNetPackVisitor::visitLobbyPvPAction(LobbyPvPAction & pack)
 {
 	result = true;
@@ -425,3 +433,32 @@
 	}
 	result = true;
 }
+
+
+void ClientPermissionsCheckerNetPackVisitor::visitLobbyDelete(LobbyDelete & pack)
+{
+	result = srv.isClientHost(pack.c->connectionID);
+}
+
+void ApplyOnServerNetPackVisitor::visitLobbyDelete(LobbyDelete & pack)
+{
+	if(pack.type == LobbyDelete::EType::SAVEGAME || pack.type == LobbyDelete::EType::RANDOMMAP)
+	{
+		auto res = ResourcePath(pack.name, pack.type == LobbyDelete::EType::SAVEGAME ? EResType::SAVEGAME : EResType::MAP);
+		auto file = boost::filesystem::canonical(*CResourceHandler::get()->getResourceName(res));
+		boost::filesystem::remove(file);
+		if(boost::filesystem::is_empty(file.parent_path()))
+			boost::filesystem::remove(file.parent_path());
+	}
+	else if(pack.type == LobbyDelete::EType::SAVEGAME_FOLDER)
+	{
+		auto res = ResourcePath("Saves/" + pack.name, EResType::DIRECTORY);
+		auto folder = boost::filesystem::canonical(*CResourceHandler::get()->getResourceName(res));
+		boost::filesystem::remove_all(folder);
+	}
+
+	LobbyUpdateState lus;
+	lus.state = srv;
+	lus.refreshList = true;
+	srv.announcePack(lus);
+}
diff --color -urN vcmi-1.5.7/server/NetPacksServer.cpp vcmi/server/NetPacksServer.cpp
--- vcmi-1.5.7/server/NetPacksServer.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/server/NetPacksServer.cpp	2024-12-19 15:00:22.990151740 +0100
@@ -19,6 +19,7 @@
 #include "queries/MapQueries.h"
 
 #include "../lib/IGameCallback.h"
+#include "../lib/CPlayerState.h"
 #include "../lib/mapObjects/CGTownInstance.h"
 #include "../lib/mapObjects/CGHeroInstance.h"
 #include "../lib/gameState/CGameState.h"
@@ -27,7 +28,6 @@
 #include "../lib/battle/Unit.h"
 #include "../lib/spells/CSpellHandler.h"
 #include "../lib/spells/ISpellMechanics.h"
-#include "../lib/serializer/Cast.h"
 
 void ApplyGhNetPackVisitor::visitSaveGame(SaveGame & pack)
 {
@@ -139,6 +139,22 @@
 	result = gh.buildStructure(pack.tid, pack.bid);
 }
 
+void ApplyGhNetPackVisitor::visitSpellResearch(SpellResearch & pack)
+{
+	gh.throwIfWrongOwner(&pack, pack.tid);
+	gh.throwIfPlayerNotActive(&pack);
+	
+	result = gh.spellResearch(pack.tid, pack.spellAtSlot, pack.accepted);
+}
+
+void ApplyGhNetPackVisitor::visitVisitTownBuilding(VisitTownBuilding & pack)
+{
+	gh.throwIfWrongOwner(&pack, pack.tid);
+	gh.throwIfPlayerNotActive(&pack);
+
+	result = gh.visitTownBuilding(pack.tid, pack.bid);
+}
+
 void ApplyGhNetPackVisitor::visitRecruitCreatures(RecruitCreatures & pack)
 {
 	gh.throwIfWrongPlayer(&pack);
@@ -176,7 +192,7 @@
 
 void ApplyGhNetPackVisitor::visitBulkExchangeArtifacts(BulkExchangeArtifacts & pack)
 {
-	if(dynamic_cast<const IMarket*>(gh.getObj(pack.srcHero)) == nullptr)
+	if(gh.getMarket(pack.srcHero) == nullptr)
 		gh.throwIfWrongOwner(&pack, pack.srcHero);
 	if(pack.swap)
 		gh.throwIfWrongOwner(&pack, pack.dstHero);
@@ -190,22 +206,7 @@
 	gh.throwIfPlayerNotActive(&pack);
 
 	if(gh.getPlayerRelations(pack.player, gh.getOwner(pack.artHolder)) != PlayerRelations::ENEMIES)
-	{
-		if(pack.cmd == ManageBackpackArtifacts::ManageCmd::SCROLL_LEFT)
-			result = gh.scrollBackpackArtifacts(pack.player, pack.artHolder, true);
-		else if(pack.cmd == ManageBackpackArtifacts::ManageCmd::SCROLL_RIGHT)
-			result = gh.scrollBackpackArtifacts(pack.player, pack.artHolder, false);
-		else
-		{
-			gh.throwIfWrongOwner(&pack, pack.artHolder);
-			if(pack.cmd == ManageBackpackArtifacts::ManageCmd::SORT_BY_CLASS)
-				result = true;
-			else if(pack.cmd == ManageBackpackArtifacts::ManageCmd::SORT_BY_COST)
-				result = true;
-			else if(pack.cmd == ManageBackpackArtifacts::ManageCmd::SORT_BY_SLOT)
-				result = true;
-		}
-	}
+		result = gh.manageBackpackArtifacts(pack.player, pack.artHolder, pack.cmd);
 }
 
 void ApplyGhNetPackVisitor::visitManageEquippedArtifacts(ManageEquippedArtifacts & pack)
@@ -242,7 +243,7 @@
 {
 	const CGObjectInstance * object = gh.getObj(pack.marketId);
 	const CGHeroInstance * hero = gh.getHero(pack.heroId);
-	const auto * market = dynamic_cast<const IMarket*>(object);
+	const auto * market = gh.getMarket(pack.marketId);
 
 	gh.throwIfWrongPlayer(&pack);
 	gh.throwIfPlayerNotActive(&pack);
@@ -283,7 +284,7 @@
 			gh.throwAndComplain(&pack, "Can not trade - no hero!");
 
 		// TODO: check that object is actually being visited (e.g. Query exists)
-		if (!object->visitableAt(hero->visitablePos().x, hero->visitablePos().y))
+		if (!object->visitableAt(hero->visitablePos()))
 			gh.throwAndComplain(&pack, "Can not trade - object not visited!");
 
 		if (object->getOwner().isValidPlayer() && gh.getPlayerRelations(object->getOwner(), hero->getOwner()) == PlayerRelations::ENEMIES)
@@ -389,6 +390,13 @@
 	result = gh.queryReply(pack.qid, pack.reply, pack.player);
 }
 
+void ApplyGhNetPackVisitor::visitSaveLocalState(SaveLocalState & pack)
+{
+	gh.throwIfWrongPlayer(&pack);
+	*gh.gameState()->getPlayerState(pack.player)->playerLocalSettings = pack.data;
+	result = true;
+}
+
 void ApplyGhNetPackVisitor::visitMakeAction(MakeAction & pack)
 {
 	gh.throwIfWrongPlayer(&pack);
diff --color -urN vcmi-1.5.7/server/processors/HeroPoolProcessor.cpp vcmi/server/processors/HeroPoolProcessor.cpp
--- vcmi-1.5.7/server/processors/HeroPoolProcessor.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/server/processors/HeroPoolProcessor.cpp	2024-12-19 15:00:22.993151863 +0100
@@ -13,17 +13,19 @@
 #include "TurnOrderProcessor.h"
 #include "../CGameHandler.h"
 
-#include "../../lib/CHeroHandler.h"
+#include "../../lib/CRandomGenerator.h"
 #include "../../lib/CPlayerState.h"
-#include "../../lib/GameSettings.h"
+#include "../../lib/IGameSettings.h"
 #include "../../lib/StartInfo.h"
+#include "../../lib/entities/hero/CHeroClass.h"
+#include "../../lib/entities/hero/CHero.h"
 #include "../../lib/mapObjects/CGTownInstance.h"
 #include "../../lib/mapObjects/CGHeroInstance.h"
 #include "../../lib/networkPacks/PacksForClient.h"
 #include "../../lib/gameState/CGameState.h"
 #include "../../lib/gameState/TavernHeroesPool.h"
 #include "../../lib/gameState/TavernSlot.h"
-#include "../../lib/GameSettings.h"
+#include "../../lib/IGameSettings.h"
 
 HeroPoolProcessor::HeroPoolProcessor(CGameHandler * gameHandler)
 	: gameHandler(gameHandler)
@@ -46,8 +48,8 @@
 	// try to find "better" slot to overwrite
 	// we want to avoid overwriting retreated heroes when tavern still has slot with random hero
 	// as well as avoid overwriting surrendered heroes if we can overwrite retreated hero
-	auto roleLeft = heroesPool->getSlotRole(heroes[0]->getHeroType());
-	auto roleRight = heroesPool->getSlotRole(heroes[1]->getHeroType());
+	auto roleLeft = heroesPool->getSlotRole(heroes[0]->getHeroTypeID());
+	auto roleRight = heroesPool->getSlotRole(heroes[1]->getHeroTypeID());
 
 	if (roleLeft > roleRight)
 		return TavernHeroSlot::RANDOM;
@@ -69,9 +71,9 @@
 
 	sah.slotID = selectSlotForRole(color, sah.roleID);
 	sah.player = color;
-	sah.hid = hero->getHeroType();
+	sah.hid = hero->getHeroTypeID();
 	sah.replenishPoints = false;
-	gameHandler->sendAndApply(&sah);
+	gameHandler->sendAndApply(sah);
 }
 
 void HeroPoolProcessor::onHeroEscaped(const PlayerColor & color, const CGHeroInstance * hero)
@@ -81,12 +83,12 @@
 
 	sah.slotID = selectSlotForRole(color, sah.roleID);
 	sah.player = color;
-	sah.hid = hero->getHeroType();
+	sah.hid = hero->getHeroTypeID();
 	sah.army.clearSlots();
-	sah.army.setCreature(SlotID(0), hero->type->initialArmy.at(0).creature, 1);
+	sah.army.setCreature(SlotID(0), hero->getHeroType()->initialArmy.at(0).creature, 1);
 	sah.replenishPoints = false;
 
-	gameHandler->sendAndApply(&sah);
+	gameHandler->sendAndApply(sah);
 }
 
 void HeroPoolProcessor::clearHeroFromSlot(const PlayerColor & color, TavernHeroSlot slot)
@@ -97,7 +99,7 @@
 	sah.slotID = slot;
 	sah.hid = HeroTypeID::NONE;
 	sah.replenishPoints = false;
-	gameHandler->sendAndApply(&sah);
+	gameHandler->sendAndApply(sah);
 }
 
 void HeroPoolProcessor::selectNewHeroForSlot(const PlayerColor & color, TavernHeroSlot slot, bool needNativeHero, bool giveArmy, const HeroTypeID & nextHero)
@@ -111,7 +113,7 @@
 
 	if (newHero)
 	{
-		sah.hid = newHero->getHeroType();
+		sah.hid = newHero->getHeroTypeID();
 
 		if (giveArmy)
 		{
@@ -122,7 +124,7 @@
 		{
 			sah.roleID = TavernSlotRole::SINGLE_UNIT;
 			sah.army.clearSlots();
-			sah.army.setCreature(SlotID(0), newHero->type->initialArmy[0].creature, 1);
+			sah.army.setCreature(SlotID(0), newHero->getHeroType()->initialArmy[0].creature, 1);
 		}
 	}
 	else
@@ -130,7 +132,7 @@
 		sah.hid = HeroTypeID::NONE;
 	}
 
-	gameHandler->sendAndApply(&sah);
+	gameHandler->sendAndApply(sah);
 }
 
 void HeroPoolProcessor::onNewWeek(const PlayerColor & color)
@@ -157,15 +159,15 @@
 	if (playerState->resources[EGameResID::GOLD] < GameConstants::HERO_GOLD_COST && gameHandler->complain("Not enough gold for buying hero!"))
 		return false;
 
-	if (gameHandler->getHeroCount(player, false) >= VLC->settings()->getInteger(EGameSettings::HEROES_PER_PLAYER_ON_MAP_CAP) && gameHandler->complain("Cannot hire hero, too many wandering heroes already!"))
+	if (gameHandler->getHeroCount(player, false) >= gameHandler->getSettings().getInteger(EGameSettings::HEROES_PER_PLAYER_ON_MAP_CAP) && gameHandler->complain("Cannot hire hero, too many wandering heroes already!"))
 		return false;
 
-	if (gameHandler->getHeroCount(player, true) >= VLC->settings()->getInteger(EGameSettings::HEROES_PER_PLAYER_TOTAL_CAP) && gameHandler->complain("Cannot hire hero, too many heroes garrizoned and wandering already!"))
+	if (gameHandler->getHeroCount(player, true) >= gameHandler->getSettings().getInteger(EGameSettings::HEROES_PER_PLAYER_TOTAL_CAP) && gameHandler->complain("Cannot hire hero, too many heroes garrizoned and wandering already!"))
 		return false;
 
 	if (nextHero != HeroTypeID::NONE) // player attempts to invite next hero
 	{
-		if(!VLC->settings()->getBoolean(EGameSettings::HEROES_TAVERN_INVITE) && gameHandler->complain("Inviting heroes not allowed!"))
+		if(!gameHandler->getSettings().getBoolean(EGameSettings::HEROES_TAVERN_INVITE) && gameHandler->complain("Inviting heroes not allowed!"))
 			return false;
 
 		if(!heroesPool->unusedHeroesFromPool().count(nextHero) && gameHandler->complain("Cannot invite specified hero!"))
@@ -207,7 +209,7 @@
 
 	for(const auto & hero : recruitableHeroes)
 	{
-		if(hero->getHeroType() == heroToRecruit)
+		if(hero->getHeroTypeID() == heroToRecruit)
 			recruitedHero = hero;
 	}
 
@@ -220,19 +222,18 @@
 
 	HeroRecruited hr;
 	hr.tid = mapObject->id;
-	hr.hid = recruitedHero->getHeroType();
+	hr.hid = recruitedHero->getHeroTypeID();
 	hr.player = player;
 	hr.tile = recruitedHero->convertFromVisitablePos(targetPos );
 	if(gameHandler->getTile(targetPos)->isWater() && !recruitedHero->boat)
 	{
 		//Create a new boat for hero
-		gameHandler->createObject(targetPos, player, Obj::BOAT, recruitedHero->getBoatType().getNum());
-
+		gameHandler->createBoat(targetPos, recruitedHero->getBoatType(), player);
 		hr.boatId = gameHandler->getTopObj(targetPos)->id;
 	}
 
 	// apply netpack -> this will remove hired hero from pool
-	gameHandler->sendAndApply(&hr);
+	gameHandler->sendAndApply(hr);
 
 	if(recruitableHeroes[0] == recruitedHero)
 		selectNewHeroForSlot(player, TavernHeroSlot::NATIVE, false, false, nextHero);
@@ -242,10 +243,7 @@
 	gameHandler->giveResource(player, EGameResID::GOLD, -GameConstants::HERO_GOLD_COST);
 
 	if(town)
-	{
-		gameHandler->visitCastleObjects(town, recruitedHero);
-		gameHandler->giveSpells(town, recruitedHero);
-	}
+		gameHandler->objectVisited(town, recruitedHero);
 
 	// If new hero has scouting he might reveal more terrain than we saw before
 	gameHandler->changeFogOfWar(recruitedHero->getSightCenter(), recruitedHero->getSightRadius(), player, ETileVisibility::REVEALED);
@@ -261,14 +259,14 @@
 
 	for(const auto & elem : heroesPool->unusedHeroesFromPool())
 	{
-		if (vstd::contains(result, elem.second->type->heroClass))
+		if (vstd::contains(result, elem.second->getHeroClass()))
 			continue;
 
 		bool heroAvailable = heroesPool->isHeroAvailableFor(elem.first, player);
-		bool heroClassBanned = elem.second->type->heroClass->tavernProbability(factionID) == 0;
+		bool heroClassBanned = elem.second->getHeroClass()->tavernProbability(factionID) == 0;
 
 		if(heroAvailable && !heroClassBanned)
-			result.push_back(elem.second->type->heroClass);
+			result.push_back(elem.second->getHeroClass());
 	}
 
 	return result;
@@ -285,7 +283,7 @@
 		assert(!vstd::contains(result, elem.second));
 
 		bool heroAvailable = heroesPool->isHeroAvailableFor(elem.first, player);
-		bool heroClassMatches = elem.second->type->heroClass == heroClass;
+		bool heroClassMatches = elem.second->getHeroClass() == heroClass;
 
 		if(heroAvailable && heroClassMatches)
 			result.push_back(elem.second);
@@ -321,7 +319,7 @@
 			continue;
 
 		bool hasSameClass = vstd::contains_if(currentTavern, [&](const CGHeroInstance * hero){
-			return hero->type->heroClass == heroClass;
+			return hero->getHeroClass() == heroClass;
 		});
 
 		if (hasSameClass)
@@ -368,7 +366,7 @@
 	return *RandomGeneratorUtil::nextItem(possibleHeroes, getRandomGenerator(player));
 }
 
-CRandomGenerator & HeroPoolProcessor::getHeroSkillsRandomGenerator(const HeroTypeID & hero)
+vstd::RNG & HeroPoolProcessor::getHeroSkillsRandomGenerator(const HeroTypeID & hero)
 {
 	if (heroSeed.count(hero) == 0)
 	{
@@ -379,7 +377,7 @@
 	return *heroSeed.at(hero);
 }
 
-CRandomGenerator & HeroPoolProcessor::getRandomGenerator(const PlayerColor & player)
+vstd::RNG & HeroPoolProcessor::getRandomGenerator(const PlayerColor & player)
 {
 	if (playerSeed.count(player) == 0)
 	{
diff --color -urN vcmi-1.5.7/server/processors/HeroPoolProcessor.h vcmi/server/processors/HeroPoolProcessor.h
--- vcmi-1.5.7/server/processors/HeroPoolProcessor.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/server/processors/HeroPoolProcessor.h	2024-12-19 15:00:22.993151863 +0100
@@ -19,8 +19,13 @@
 class CGHeroInstance;
 class HeroTypeID;
 class ObjectInstanceID;
-class CRandomGenerator;
 class CHeroClass;
+class CRandomGenerator;
+
+namespace vstd
+{
+class RNG;
+}
 
 VCMI_LIB_NAMESPACE_END
 
@@ -46,7 +51,7 @@
 
 	CGHeroInstance * pickHeroFor(bool isNative, const PlayerColor & player);
 
-	CRandomGenerator & getRandomGenerator(const PlayerColor & player);
+	vstd::RNG & getRandomGenerator(const PlayerColor & player);
 
 	TavernHeroSlot selectSlotForRole(const PlayerColor & player, TavernSlotRole roleID);
 
@@ -58,7 +63,7 @@
 
 	void onNewWeek(const PlayerColor & color);
 
-	CRandomGenerator & getHeroSkillsRandomGenerator(const HeroTypeID & hero);
+	vstd::RNG & getHeroSkillsRandomGenerator(const HeroTypeID & hero);
 
 	/// Incoming net pack handling
 	bool hireHero(const ObjectInstanceID & objectID, const HeroTypeID & hid, const PlayerColor & player, const HeroTypeID & nextHero);
diff --color -urN vcmi-1.5.7/server/processors/NewTurnProcessor.cpp vcmi/server/processors/NewTurnProcessor.cpp
--- vcmi-1.5.7/server/processors/NewTurnProcessor.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/server/processors/NewTurnProcessor.cpp	2024-12-19 15:00:22.993151863 +0100
@@ -0,0 +1,718 @@
+/*
+ * NewTurnProcessor.cpp, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#include "StdInc.h"
+#include "NewTurnProcessor.h"
+
+#include "HeroPoolProcessor.h"
+
+#include "../CGameHandler.h"
+
+#include "../../lib/CPlayerState.h"
+#include "../../lib/IGameSettings.h"
+#include "../../lib/StartInfo.h"
+#include "../../lib/TerrainHandler.h"
+#include "../../lib/constants/StringConstants.h"
+#include "../../lib/entities/building/CBuilding.h"
+#include "../../lib/entities/faction/CTownHandler.h"
+#include "../../lib/gameState/CGameState.h"
+#include "../../lib/gameState/SThievesGuildInfo.h"
+#include "../../lib/mapObjects/CGHeroInstance.h"
+#include "../../lib/mapObjects/CGTownInstance.h"
+#include "../../lib/mapObjects/IOwnableObject.h"
+#include "../../lib/mapping/CMap.h"
+#include "../../lib/networkPacks/PacksForClient.h"
+#include "../../lib/networkPacks/StackLocation.h"
+#include "../../lib/pathfinder/TurnInfo.h"
+#include "../../lib/texts/CGeneralTextHandler.h"
+
+#include <vstd/RNG.h>
+
+NewTurnProcessor::NewTurnProcessor(CGameHandler * gameHandler)
+	:gameHandler(gameHandler)
+{
+}
+
+void NewTurnProcessor::handleTimeEvents(PlayerColor color)
+{
+	for (auto const & event : gameHandler->gameState()->map->events)
+	{
+		if (!event.occursToday(gameHandler->gameState()->day))
+			continue;
+
+		if (!event.affectsPlayer(color, gameHandler->getPlayerState(color)->isHuman()))
+			continue;
+
+		InfoWindow iw;
+		iw.player = color;
+		iw.text = event.message;
+
+		//give resources
+		if (!event.resources.empty())
+		{
+			gameHandler->giveResources(color, event.resources);
+			for (GameResID i : GameResID::ALL_RESOURCES())
+				if (event.resources[i])
+					iw.components.emplace_back(ComponentType::RESOURCE, i, event.resources[i]);
+		}
+
+		//remove objects specified by event
+		for(const ObjectInstanceID objectIdToRemove : event.deletedObjectsInstances)
+		{
+			auto objectInstance = gameHandler->getObj(objectIdToRemove, false);
+			if(objectInstance != nullptr)
+				gameHandler->removeObject(objectInstance, PlayerColor::NEUTRAL);
+		}
+		gameHandler->sendAndApply(iw); //show dialog
+	}
+}
+
+void NewTurnProcessor::handleTownEvents(const CGTownInstance * town)
+{
+	for (auto const & event : town->events)
+	{
+		if (!event.occursToday(gameHandler->gameState()->day))
+			continue;
+
+		PlayerColor player = town->getOwner();
+		if (!event.affectsPlayer(player, gameHandler->getPlayerState(player)->isHuman()))
+			continue;
+
+		// dialog
+		InfoWindow iw;
+		iw.player = player;
+		iw.text = event.message;
+
+		if (event.resources.nonZero())
+		{
+			gameHandler->giveResources(player, event.resources);
+
+			for (GameResID i : GameResID::ALL_RESOURCES())
+				if (event.resources[i])
+					iw.components.emplace_back(ComponentType::RESOURCE, i, event.resources[i]);
+		}
+
+		for (auto & i : event.buildings)
+		{
+			// Only perform action if:
+			// 1. Building exists in town (don't attempt to build Lvl 5 guild in Fortress
+			// 2. Building was not built yet
+			// othervice, silently ignore / skip it
+			if (town->getTown()->buildings.count(i) && !town->hasBuilt(i))
+			{
+				gameHandler->buildStructure(town->id, i, true);
+				iw.components.emplace_back(ComponentType::BUILDING, BuildingTypeUniqueID(town->getFactionID(), i));
+			}
+		}
+
+		if (!event.creatures.empty())
+		{
+			SetAvailableCreatures sac;
+			sac.tid = town->id;
+			sac.creatures = town->creatures;
+
+			for (si32 i=0;i<event.creatures.size();i++) //creature growths
+			{
+				if (i < town->creatures.size() && !town->creatures.at(i).second.empty() && event.creatures.at(i) > 0)//there is dwelling
+				{
+					sac.creatures[i].first += event.creatures.at(i);
+					iw.components.emplace_back(ComponentType::CREATURE, town->creatures.at(i).second.back(), event.creatures.at(i));
+				}
+			}
+
+			gameHandler->sendAndApply(sac); //show dialog
+		}
+		gameHandler->sendAndApply(iw); //show dialog
+	}
+}
+
+void NewTurnProcessor::onPlayerTurnStarted(PlayerColor which)
+{
+	const auto * playerState = gameHandler->gameState()->getPlayerState(which);
+
+	handleTimeEvents(which);
+	for (const auto * t : playerState->getTowns())
+		handleTownEvents(t);
+
+	for (const auto * t : playerState->getTowns())
+	{
+		//garrison hero first - consistent with original H3 Mana Vortex and Battle Scholar Academy levelup windows order
+		if (t->garrisonHero != nullptr)
+			gameHandler->objectVisited(t, t->garrisonHero);
+
+		if (t->visitingHero != nullptr)
+			gameHandler->objectVisited(t, t->visitingHero);
+	}
+}
+
+void NewTurnProcessor::onPlayerTurnEnded(PlayerColor which)
+{
+	const auto * playerState = gameHandler->gameState()->getPlayerState(which);
+	assert(playerState->status == EPlayerStatus::INGAME);
+
+	if (playerState->getTowns().empty())
+	{
+		DaysWithoutTown pack;
+		pack.player = which;
+		pack.daysWithoutCastle = playerState->daysWithoutCastle.value_or(0) + 1;
+		gameHandler->sendAndApply(pack);
+	}
+	else
+	{
+		if (playerState->daysWithoutCastle.has_value())
+		{
+			DaysWithoutTown pack;
+			pack.player = which;
+			pack.daysWithoutCastle = std::nullopt;
+			gameHandler->sendAndApply(pack);
+		}
+	}
+
+	// check for 7 days without castle
+	gameHandler->checkVictoryLossConditionsForPlayer(which);
+
+	bool newWeek = gameHandler->getDate(Date::DAY_OF_WEEK) == 7; // end of 7th day
+
+	if (newWeek) //new heroes in tavern
+		gameHandler->heroPool->onNewWeek(which);
+}
+
+ResourceSet NewTurnProcessor::generatePlayerIncome(PlayerColor playerID, bool newWeek)
+{
+	const auto & playerSettings = gameHandler->getPlayerSettings(playerID);
+	const PlayerState & state = gameHandler->gameState()->players.at(playerID);
+	ResourceSet income;
+
+	for (const auto & town : state.getTowns())
+	{
+		if (newWeek && town->hasBuilt(BuildingSubID::TREASURY))
+		{
+			//give 10% of starting gold
+			income[EGameResID::GOLD] += state.resources[EGameResID::GOLD] / 10;
+		}
+
+		//give resources if there's a Mystic Pond
+		if (newWeek && town->hasBuilt(BuildingSubID::MYSTIC_POND))
+		{
+			static constexpr std::array rareResources = {
+				GameResID::MERCURY,
+				GameResID::SULFUR,
+				GameResID::CRYSTAL,
+				GameResID::GEMS
+			};
+
+			auto resID = *RandomGeneratorUtil::nextItem(rareResources, gameHandler->getRandomGenerator());
+			int resVal = gameHandler->getRandomGenerator().nextInt(1, 4);
+
+			income[resID] += resVal;
+
+			gameHandler->setObjPropertyValue(town->id, ObjProperty::BONUS_VALUE_FIRST, resID);
+			gameHandler->setObjPropertyValue(town->id, ObjProperty::BONUS_VALUE_SECOND, resVal);
+		}
+	}
+
+	for (GameResID k = GameResID::WOOD; k < GameResID::COUNT; k++)
+	{
+		income += state.valOfBonuses(BonusType::RESOURCES_CONSTANT_BOOST, BonusSubtypeID(k));
+		income += state.valOfBonuses(BonusType::RESOURCES_TOWN_MULTIPLYING_BOOST, BonusSubtypeID(k)) * state.getTowns().size();
+	}
+
+	if(newWeek) //weekly crystal generation if 1 or more crystal dragons in any hero army or town garrison
+	{
+		bool hasCrystalGenCreature = false;
+		for (const auto & hero : state.getHeroes())
+			for(auto stack : hero->stacks)
+				if(stack.second->hasBonusOfType(BonusType::SPECIAL_CRYSTAL_GENERATION))
+					hasCrystalGenCreature = true;
+
+		for(const auto & town : state.getTowns())
+			for(auto stack : town->stacks)
+				if(stack.second->hasBonusOfType(BonusType::SPECIAL_CRYSTAL_GENERATION))
+					hasCrystalGenCreature = true;
+
+		if(hasCrystalGenCreature)
+			income[EGameResID::CRYSTAL] += 3;
+	}
+
+	TResources incomeHandicapped = income;
+	incomeHandicapped.applyHandicap(playerSettings->handicap.percentIncome);
+
+	for (auto obj :	state.getOwnedObjects())
+		incomeHandicapped += obj->asOwnable()->dailyIncome();
+
+	if (!state.isHuman())
+	{
+		// Initialize bonuses for different resources
+		int difficultyIndex = gameHandler->gameState()->getStartInfo()->difficulty;
+		const std::string & difficultyName = GameConstants::DIFFICULTY_NAMES[difficultyIndex];
+		const JsonNode & weeklyBonusesConfig = gameHandler->gameState()->getSettings().getValue(EGameSettings::RESOURCES_WEEKLY_BONUSES_AI);
+		const JsonNode & difficultyConfig = weeklyBonusesConfig[difficultyName];
+
+		// Distribute weekly bonuses over 7 days, depending on the current day of the week
+		for (GameResID i : GameResID::ALL_RESOURCES())
+		{
+			const std::string & name = GameConstants::RESOURCE_NAMES[i];
+			int weeklyBonus = difficultyConfig[name].Integer();
+			int dayOfWeek = gameHandler->gameState()->getDate(Date::DAY_OF_WEEK);
+			int dailyIncome = incomeHandicapped[i];
+			int amountTillToday = dailyIncome * weeklyBonus * (dayOfWeek-1) / 7 / 100;
+			int amountAfterToday = dailyIncome * weeklyBonus * dayOfWeek / 7 / 100;
+			int dailyBonusToday = amountAfterToday - amountTillToday;
+			incomeHandicapped[static_cast<GameResID>(i)] += dailyBonusToday;
+		}
+	}
+
+	return incomeHandicapped;
+}
+
+SetAvailableCreatures NewTurnProcessor::generateTownGrowth(const CGTownInstance * t, EWeekType weekType, CreatureID creatureWeek, bool firstDay)
+{
+	SetAvailableCreatures sac;
+	PlayerColor player = t->tempOwner;
+
+	sac.tid = t->id;
+	sac.creatures = t->creatures;
+
+	for (int k=0; k < t->getTown()->creatures.size(); k++)
+	{
+		if (t->creatures.at(k).second.empty())
+			continue;
+
+		uint32_t creaturesBefore = t->creatures.at(k).first;
+		uint32_t creatureGrowth = 0;
+		const CCreature *cre = t->creatures.at(k).second.back().toCreature();
+
+		if (firstDay)
+		{
+			creatureGrowth = cre->getGrowth();
+		}
+		else
+		{
+			creatureGrowth = t->creatureGrowth(k);
+
+			//Deity of fire week - upgrade both imps and upgrades
+			if (weekType == EWeekType::DEITYOFFIRE && vstd::contains(t->creatures.at(k).second, creatureWeek))
+				creatureGrowth += 15;
+
+			//bonus week, effect applies only to identical creatures
+			if (weekType == EWeekType::BONUS_GROWTH && cre->getId() == creatureWeek)
+				creatureGrowth += 5;
+		}
+
+		// Neutral towns have halved creature growth
+		if (!player.isValidPlayer())
+			creatureGrowth /= 2;
+
+		uint32_t resultingCreatures = 0;
+
+		if (weekType == EWeekType::PLAGUE)
+			resultingCreatures = creaturesBefore / 2;
+		else if (weekType == EWeekType::DOUBLE_GROWTH && vstd::contains(t->creatures.at(k).second, creatureWeek))
+			resultingCreatures = (creaturesBefore + creatureGrowth) * 2;
+		else
+			resultingCreatures = creaturesBefore + creatureGrowth;
+
+		sac.creatures.at(k).first = resultingCreatures;
+	}
+
+	return sac;
+}
+
+void NewTurnProcessor::updateNeutralTownGarrison(const CGTownInstance * t, int currentWeek) const
+{
+	assert(t);
+	assert(!t->getOwner().isValidPlayer());
+
+	constexpr int randomRollsCounts = 3; // H3 makes around 3 random rolls to make simple bell curve distribution
+	constexpr int upgradeChance = 5; // Chance for a unit to get an upgrade
+	constexpr int growthChanceFort = 80; // Chance for growth to occur in towns with fort built
+	constexpr int growthChanceVillage = 40; // Chance for growth to occur in towns without fort
+
+	const auto & takeFromAvailable = [this, t](CreatureID creatureID)
+	{
+		int tierToSubstract = -1;
+		for (int i = 0; i < t->getTown()->creatures.size(); ++i)
+			if (vstd::contains(t->getTown()->creatures[i], creatureID))
+				tierToSubstract = i;
+
+		if (tierToSubstract == -1)
+			return; // impossible?
+
+		int creaturesAvailable = t->creatures[tierToSubstract].first;
+		int creaturesRecruited = creatureID.toCreature()->getGrowth();
+		int creaturesLeft = std::max(0, creaturesAvailable - creaturesRecruited);
+
+		if (creaturesLeft != creaturesAvailable)
+		{
+			SetAvailableCreatures sac;
+			sac.tid = t->id;
+			sac.creatures = t->creatures;
+			sac.creatures[tierToSubstract].first = creaturesLeft;
+			gameHandler->sendAndApply(sac);
+		}
+	};
+
+	int growthChance = t->hasFort()	? growthChanceFort : growthChanceVillage;
+	int growthRoll = gameHandler->getRandomGenerator().nextInt(0, 99);
+
+	if (growthRoll >= growthChance)
+		return;
+
+	int tierRoll = 0;
+	for(int i = 0; i < randomRollsCounts; ++i)
+		tierRoll += gameHandler->getRandomGenerator().nextInt(0, currentWeek);
+
+	// NOTE: determined by observing H3 games, might not match H3 100%
+	int tierToGrow = std::clamp(tierRoll / randomRollsCounts, 0, 6) + 1;
+
+	bool upgradeUnit = gameHandler->getRandomGenerator().nextInt(0, 99) < upgradeChance;
+
+	// Check if town garrison already has unit of specified tier
+	for(const auto & slot : t->Slots())
+	{
+		const auto * creature = slot.second->getCreature();
+
+		if (creature->getFactionID() != t->getFactionID())
+			continue;
+
+		if (creature->getLevel() != tierToGrow)
+			continue;
+
+		StackLocation stackLocation(t, slot.first);
+		gameHandler->changeStackCount(stackLocation, creature->getGrowth(), false);
+		takeFromAvailable(creature->getGrowth());
+
+		if (upgradeUnit && !creature->upgrades.empty())
+		{
+			CreatureID upgraded = *RandomGeneratorUtil::nextItem(creature->upgrades, gameHandler->getRandomGenerator());
+			gameHandler->changeStackType(stackLocation, upgraded.toCreature());
+		}
+		else
+			gameHandler->changeStackType(stackLocation, creature);
+		return;
+	}
+
+	// No existing creatures in garrison, but we have a free slot we can use
+	SlotID freeSlotID = t->getFreeSlot();
+	if (freeSlotID.validSlot())
+	{
+		for (auto const & tierVector : t->getTown()->creatures)
+		{
+			CreatureID baseCreature	= tierVector.at(0);
+
+			if (baseCreature.toEntity(VLC)->getLevel() != tierToGrow)
+				continue;
+
+			StackLocation stackLocation(t, freeSlotID);
+
+			if (upgradeUnit && !baseCreature.toCreature()->upgrades.empty())
+			{
+				CreatureID upgraded = *RandomGeneratorUtil::nextItem(baseCreature.toCreature()->upgrades, gameHandler->getRandomGenerator());
+				gameHandler->insertNewStack(stackLocation, upgraded.toCreature(), upgraded.toCreature()->getGrowth());
+				takeFromAvailable(upgraded.toCreature()->getGrowth());
+			}
+			else
+			{
+				gameHandler->insertNewStack(stackLocation, baseCreature.toCreature(), baseCreature.toCreature()->getGrowth());
+				takeFromAvailable(baseCreature.toCreature()->getGrowth());
+			}
+
+			return;
+		}
+	}
+}
+
+RumorState NewTurnProcessor::pickNewRumor()
+{
+	RumorState newRumor;
+
+	static const std::vector<RumorState::ERumorType> rumorTypes = {RumorState::TYPE_MAP, RumorState::TYPE_SPECIAL, RumorState::TYPE_RAND, RumorState::TYPE_RAND};
+	std::vector<RumorState::ERumorTypeSpecial> sRumorTypes = {
+															  RumorState::RUMOR_OBELISKS, RumorState::RUMOR_ARTIFACTS, RumorState::RUMOR_ARMY, RumorState::RUMOR_INCOME};
+	if(gameHandler->gameState()->map->grailPos.valid()) // Grail should always be on map, but I had related crash I didn't manage to reproduce
+		sRumorTypes.push_back(RumorState::RUMOR_GRAIL);
+
+	int rumorId = -1;
+	int rumorExtra = -1;
+	auto & rand = gameHandler->getRandomGenerator();
+	newRumor.type = *RandomGeneratorUtil::nextItem(rumorTypes, rand);
+
+	do
+	{
+		switch(newRumor.type)
+		{
+			case RumorState::TYPE_SPECIAL:
+			{
+				SThievesGuildInfo tgi;
+				gameHandler->gameState()->obtainPlayersStats(tgi, 20);
+				rumorId = *RandomGeneratorUtil::nextItem(sRumorTypes, rand);
+				if(rumorId == RumorState::RUMOR_GRAIL)
+				{
+					rumorExtra = gameHandler->gameState()->getTile(gameHandler->gameState()->map->grailPos)->getTerrainID().getNum();
+					break;
+				}
+
+				std::vector<PlayerColor> players = {};
+				switch(rumorId)
+				{
+					case RumorState::RUMOR_OBELISKS:
+						players = tgi.obelisks[0];
+						break;
+
+					case RumorState::RUMOR_ARTIFACTS:
+						players = tgi.artifacts[0];
+						break;
+
+					case RumorState::RUMOR_ARMY:
+						players = tgi.army[0];
+						break;
+
+					case RumorState::RUMOR_INCOME:
+						players = tgi.income[0];
+						break;
+				}
+				rumorExtra = RandomGeneratorUtil::nextItem(players, rand)->getNum();
+
+				break;
+			}
+			case RumorState::TYPE_MAP:
+				// Makes sure that map rumors only used if there enough rumors too choose from
+				if(!gameHandler->gameState()->map->rumors.empty() && (gameHandler->gameState()->map->rumors.size() > 1 || !gameHandler->gameState()->currentRumor.last.count(RumorState::TYPE_MAP)))
+				{
+					rumorId = rand.nextInt(gameHandler->gameState()->map->rumors.size() - 1);
+					break;
+				}
+				else
+					newRumor.type = RumorState::TYPE_RAND;
+				[[fallthrough]];
+
+			case RumorState::TYPE_RAND:
+				auto vector = VLC->generaltexth->findStringsWithPrefix("core.randtvrn");
+				rumorId = rand.nextInt((int)vector.size() - 1);
+
+				break;
+		}
+	}
+	while(!newRumor.update(rumorId, rumorExtra));
+
+	return newRumor;
+}
+
+std::tuple<EWeekType, CreatureID> NewTurnProcessor::pickWeekType(bool newMonth)
+{
+	for (const CGTownInstance *t : gameHandler->gameState()->map->towns)
+	{
+		if (t->hasBuilt(BuildingID::GRAIL, ETownType::INFERNO))
+			return { EWeekType::DEITYOFFIRE, CreatureID::IMP };
+	}
+
+	if(!gameHandler->getSettings().getBoolean(EGameSettings::CREATURES_ALLOW_RANDOM_SPECIAL_WEEKS))
+		return { EWeekType::NORMAL, CreatureID::NONE};
+
+	int monthType = gameHandler->getRandomGenerator().nextInt(99);
+	if (newMonth) //new month
+	{
+		if (monthType < 40) //double growth
+		{
+			if (gameHandler->getSettings().getBoolean(EGameSettings::CREATURES_ALLOW_ALL_FOR_DOUBLE_MONTH))
+			{
+				CreatureID creatureID = VLC->creh->pickRandomMonster(gameHandler->getRandomGenerator());
+				return { EWeekType::DOUBLE_GROWTH, creatureID};
+			}
+			else if (VLC->creh->doubledCreatures.size())
+			{
+				CreatureID creatureID = *RandomGeneratorUtil::nextItem(VLC->creh->doubledCreatures, gameHandler->getRandomGenerator());
+				return { EWeekType::DOUBLE_GROWTH, creatureID};
+			}
+			else
+			{
+				gameHandler->complain("Cannot find creature that can be spawned!");
+				return { EWeekType::NORMAL, CreatureID::NONE};
+			}
+		}
+
+		if (monthType < 50)
+			return { EWeekType::PLAGUE, CreatureID::NONE};
+
+		return { EWeekType::NORMAL, CreatureID::NONE};
+	}
+	else //it's a week, but not full month
+	{
+		if (monthType < 25)
+		{
+			std::pair<int, CreatureID> newMonster(54, CreatureID());
+			do
+			{
+				newMonster.second = VLC->creh->pickRandomMonster(gameHandler->getRandomGenerator());
+			} while (VLC->creh->objects[newMonster.second] &&
+					(*VLC->townh)[VLC->creatures()->getById(newMonster.second)->getFactionID()]->town == nullptr); // find first non neutral creature
+
+			return { EWeekType::BONUS_GROWTH, newMonster.second};
+		}
+		return { EWeekType::NORMAL, CreatureID::NONE};
+	}
+}
+
+std::vector<SetMana> NewTurnProcessor::updateHeroesManaPoints()
+{
+	std::vector<SetMana> result;
+
+	for (auto & elem : gameHandler->gameState()->players)
+	{
+		for (CGHeroInstance *h : elem.second.getHeroes())
+		{
+			int32_t newMana = h->getManaNewTurn();
+
+			if (newMana != h->mana)
+				result.emplace_back(h->id, newMana, true);
+		}
+	}
+	return result;
+}
+
+std::vector<SetMovePoints> NewTurnProcessor::updateHeroesMovementPoints()
+{
+	std::vector<SetMovePoints> result;
+
+	for (auto & elem : gameHandler->gameState()->players)
+	{
+		for (CGHeroInstance *h : elem.second.getHeroes())
+		{
+			auto ti = std::make_unique<TurnInfo>(h, 1);
+			// NOTE: this code executed when bonuses of previous day not yet updated (this happen in NewTurn::applyGs). See issue 2356
+			int32_t newMovementPoints = h->movementPointsLimitCached(gameHandler->gameState()->map->getTile(h->visitablePos()).isLand(), ti.get());
+
+			if (newMovementPoints != h->movementPointsRemaining())
+				result.emplace_back(h->id, newMovementPoints, true);
+		}
+	}
+	return result;
+}
+
+InfoWindow NewTurnProcessor::createInfoWindow(EWeekType weekType, CreatureID creatureWeek, bool newMonth)
+{
+	InfoWindow iw;
+	switch (weekType)
+	{
+		case EWeekType::DOUBLE_GROWTH:
+			iw.text.appendLocalString(EMetaText::ARRAY_TXT, 131);
+			iw.text.replaceNameSingular(creatureWeek);
+			iw.text.replaceNameSingular(creatureWeek);
+			break;
+		case EWeekType::PLAGUE:
+			iw.text.appendLocalString(EMetaText::ARRAY_TXT, 132);
+			break;
+		case EWeekType::BONUS_GROWTH:
+			iw.text.appendLocalString(EMetaText::ARRAY_TXT, 134);
+			iw.text.replaceNameSingular(creatureWeek);
+			iw.text.replaceNameSingular(creatureWeek);
+			break;
+		case EWeekType::DEITYOFFIRE:
+			iw.text.appendLocalString(EMetaText::ARRAY_TXT, 135);
+			iw.text.replaceNameSingular(CreatureID::IMP); //%s imp
+			iw.text.replaceNameSingular(CreatureID::IMP); //%s imp
+			iw.text.replacePositiveNumber(15);//%+d 15
+			iw.text.replaceNameSingular(CreatureID::FAMILIAR); //%s familiar
+			iw.text.replacePositiveNumber(15);//%+d 15
+			break;
+		default:
+			if (newMonth)
+			{
+				iw.text.appendLocalString(EMetaText::ARRAY_TXT, (130));
+				iw.text.replaceLocalString(EMetaText::ARRAY_TXT, gameHandler->getRandomGenerator().nextInt(32, 41));
+			}
+			else
+			{
+				iw.text.appendLocalString(EMetaText::ARRAY_TXT, (133));
+				iw.text.replaceLocalString(EMetaText::ARRAY_TXT, gameHandler->getRandomGenerator().nextInt(43, 57));
+			}
+	}
+	return iw;
+}
+
+NewTurn NewTurnProcessor::generateNewTurnPack()
+{
+	NewTurn n;
+	n.specialWeek = EWeekType::FIRST_WEEK;
+	n.creatureid = CreatureID::NONE;
+	n.day = gameHandler->gameState()->day + 1;
+
+	bool firstTurn = !gameHandler->getDate(Date::DAY);
+	bool newWeek = gameHandler->getDate(Date::DAY_OF_WEEK) == 7; //day numbers are confusing, as day was not yet switched
+	bool newMonth = gameHandler->getDate(Date::DAY_OF_MONTH) == 28;
+
+	if (!firstTurn)
+	{
+		for (const auto & player : gameHandler->gameState()->players)
+			n.playerIncome[player.first] = generatePlayerIncome(player.first, newWeek);
+	}
+
+	if (newWeek && !firstTurn)
+	{
+		auto [specialWeek, creatureID] = pickWeekType(newMonth);
+		n.specialWeek = specialWeek;
+		n.creatureid = creatureID;
+	}
+
+	n.heroesMana = updateHeroesManaPoints();
+	n.heroesMovement = updateHeroesMovementPoints();
+
+	if (newWeek)
+	{
+		for (CGTownInstance *t : gameHandler->gameState()->map->towns)
+			n.availableCreatures.push_back(generateTownGrowth(t, n.specialWeek, n.creatureid, firstTurn));
+	}
+
+	if (newWeek)
+		n.newRumor = pickNewRumor();
+
+	if (newWeek)
+	{
+		//new week info popup
+		if (n.specialWeek != EWeekType::FIRST_WEEK)
+			n.newWeekNotification = createInfoWindow(n.specialWeek, n.creatureid, newMonth);
+	}
+
+	return n;
+}
+
+void NewTurnProcessor::onNewTurn()
+{
+	NewTurn n = generateNewTurnPack();
+
+	bool firstTurn = !gameHandler->getDate(Date::DAY);
+	bool newWeek = gameHandler->getDate(Date::DAY_OF_WEEK) == 7; //day numbers are confusing, as day was not yet switched
+	bool newMonth = gameHandler->getDate(Date::DAY_OF_MONTH) == 28;
+
+	gameHandler->sendAndApply(n);
+
+	if (newWeek)
+	{
+		for (CGTownInstance *t : gameHandler->gameState()->map->towns)
+			if (t->hasBuilt(BuildingSubID::PORTAL_OF_SUMMONING))
+				gameHandler->setPortalDwelling(t, true, (n.specialWeek == EWeekType::PLAGUE ? true : false)); //set creatures for Portal of Summoning
+	}
+
+	if (newWeek && !firstTurn)
+	{
+		for (CGTownInstance *t : gameHandler->gameState()->map->towns)
+		{
+			if (!t->getOwner().isValidPlayer())
+				updateNeutralTownGarrison(t, 1 + gameHandler->getDate(Date::DAY) / 7);
+		}
+	}
+
+	//spawn wandering monsters
+	if (newMonth && (n.specialWeek == EWeekType::DOUBLE_GROWTH || n.specialWeek == EWeekType::DEITYOFFIRE))
+	{
+		gameHandler->spawnWanderingMonsters(n.creatureid);
+	}
+
+	logGlobal->trace("Info about turn %d has been sent!", n.day);
+}
diff --color -urN vcmi-1.5.7/server/processors/NewTurnProcessor.h vcmi/server/processors/NewTurnProcessor.h
--- vcmi-1.5.7/server/processors/NewTurnProcessor.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/server/processors/NewTurnProcessor.h	2024-12-19 15:00:22.993151863 +0100
@@ -0,0 +1,53 @@
+/*
+ * NewTurnProcessor.h, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#pragma once
+
+#include "../../lib/constants/EntityIdentifiers.h"
+#include "../../lib/constants/Enumerations.h"
+#include "../../lib/gameState/RumorState.h"
+
+VCMI_LIB_NAMESPACE_BEGIN
+class CGTownInstance;
+class ResourceSet;
+struct SetAvailableCreatures;
+struct SetMovePoints;
+struct SetMana;
+struct InfoWindow;
+struct NewTurn;
+VCMI_LIB_NAMESPACE_END
+
+class CGameHandler;
+
+class NewTurnProcessor : boost::noncopyable
+{
+	CGameHandler * gameHandler;
+
+	std::vector<SetMana> updateHeroesManaPoints();
+	std::vector<SetMovePoints> updateHeroesMovementPoints();
+
+	ResourceSet generatePlayerIncome(PlayerColor playerID, bool newWeek);
+	SetAvailableCreatures generateTownGrowth(const CGTownInstance * town, EWeekType weekType, CreatureID creatureWeek, bool firstDay);
+	RumorState pickNewRumor();
+	InfoWindow createInfoWindow(EWeekType weekType, CreatureID creatureWeek, bool newMonth);
+	std::tuple<EWeekType, CreatureID> pickWeekType(bool newMonth);
+
+	NewTurn generateNewTurnPack();
+	void handleTimeEvents(PlayerColor player);
+	void handleTownEvents(const CGTownInstance *town);
+
+	void updateNeutralTownGarrison(const CGTownInstance * t, int currentWeek) const;
+
+public:
+	NewTurnProcessor(CGameHandler * gameHandler);
+
+	void onNewTurn();
+	void onPlayerTurnStarted(PlayerColor color);
+	void onPlayerTurnEnded(PlayerColor color);
+};
diff --color -urN vcmi-1.5.7/server/processors/PlayerMessageProcessor.cpp vcmi/server/processors/PlayerMessageProcessor.cpp
--- vcmi-1.5.7/server/processors/PlayerMessageProcessor.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/server/processors/PlayerMessageProcessor.cpp	2024-12-19 15:00:22.993151863 +0100
@@ -16,9 +16,10 @@
 #include "../CVCMIServer.h"
 #include "../TurnTimerHandler.h"
 
-#include "../../lib/CHeroHandler.h"
 #include "../../lib/CPlayerState.h"
 #include "../../lib/StartInfo.h"
+#include "../../lib/entities/building/CBuilding.h"
+#include "../../lib/entities/hero/CHeroHandler.h"
 #include "../../lib/gameState/CGameState.h"
 #include "../../lib/mapObjects/CGTownInstance.h"
 #include "../../lib/mapObjects/CGHeroInstance.h"
@@ -28,6 +29,8 @@
 #include "../../lib/networkPacks/PacksForClient.h"
 #include "../../lib/networkPacks/StackLocation.h"
 #include "../../lib/serializer/Connection.h"
+#include "../../lib/spells/CSpellHandler.h"
+#include "../lib/VCMIDirs.h"
 
 PlayerMessageProcessor::PlayerMessageProcessor(CGameHandler * gameHandler)
 	:gameHandler(gameHandler)
@@ -67,7 +70,7 @@
 	if(!isHost)
 		return;
 
-	broadcastSystemMessage("game was terminated");
+	broadcastSystemMessage(MetaString::createFromTextID("vcmi.broadcast.gameTerminated"));
 	gameHandler->gameLobby()->setState(EServerState::SHUTDOWN);
 }
 
@@ -97,7 +100,7 @@
 			PlayerCheated pc;
 			pc.player = playerToKick;
 			pc.losingCheatCode = true;
-			gameHandler->sendAndApply(&pc);
+			gameHandler->sendAndApply(pc);
 			gameHandler->checkVictoryLossConditionsForPlayer(playerToKick);
 		}
 	}
@@ -112,7 +115,11 @@
 	if(words.size() == 2)
 	{
 		gameHandler->save("Saves/" + words[1]);
-		broadcastSystemMessage("game saved as " + words[1]);
+		MetaString str;
+		str.appendTextID("vcmi.broadcast.gameSavedAs");
+		str.appendRawString(" ");
+		str.appendRawString(words[1]);
+		broadcastSystemMessage(str);
 	}
 }
 
@@ -123,54 +130,70 @@
 	{
 		if(player.second.cheated)
 		{
-			broadcastSystemMessage("Player " + player.first.toString() + " is cheater!");
+			auto str = MetaString::createFromTextID("vcmi.broadcast.playerCheater");
+			str.replaceName(player.first);
+			broadcastSystemMessage(str);
 			playersCheated++;
 		}
 	}
 
 	if(!playersCheated)
-		broadcastSystemMessage("No cheaters registered!");
+		broadcastSystemMessage(MetaString::createFromTextID("vcmi.broadcast.noCheater"));
+}
+
+void PlayerMessageProcessor::commandStatistic(PlayerColor player, const std::vector<std::string> & words)
+{
+	bool isHost = gameHandler->gameLobby()->isPlayerHost(player);
+	if(!isHost)
+		return;
+
+	std::string path = gameHandler->gameState()->statistic.writeCsv();
+
+	auto str = MetaString::createFromTextID("vcmi.broadcast.statisticFile");
+	str.replaceRawString(path);
+	broadcastSystemMessage(str);
 }
 
 void PlayerMessageProcessor::commandHelp(PlayerColor player, const std::vector<std::string> & words)
 {
-	broadcastSystemMessage("Available commands to host:");
-	broadcastSystemMessage("'!exit' - immediately ends current game");
-	broadcastSystemMessage("'!kick <player>' - kick specified player from the game");
-	broadcastSystemMessage("'!save <filename>' - save game under specified filename");
-	broadcastSystemMessage("Available commands to all players:");
-	broadcastSystemMessage("'!help' - display this help");
-	broadcastSystemMessage("'!cheaters' - list players that entered cheat command during game");
-	broadcastSystemMessage("'!vote' - allows to change some game settings if all players vote for it");
+	broadcastSystemMessage(MetaString::createFromTextID("vcmi.broadcast.help.commands"));
+	broadcastSystemMessage(MetaString::createFromTextID("vcmi.broadcast.help.exit"));
+	broadcastSystemMessage(MetaString::createFromTextID("vcmi.broadcast.help.kick"));
+	broadcastSystemMessage(MetaString::createFromTextID("vcmi.broadcast.help.save"));
+	broadcastSystemMessage(MetaString::createFromTextID("vcmi.broadcast.help.statistic"));
+	broadcastSystemMessage(MetaString::createFromTextID("vcmi.broadcast.help.commandsAll"));
+	broadcastSystemMessage(MetaString::createFromTextID("vcmi.broadcast.help.help"));
+	broadcastSystemMessage(MetaString::createFromTextID("vcmi.broadcast.help.cheaters"));
+	broadcastSystemMessage(MetaString::createFromTextID("vcmi.broadcast.help.vote"));
 }
 
 void PlayerMessageProcessor::commandVote(PlayerColor player, const std::vector<std::string> & words)
 {
 	if(words.size() < 2)
 	{
-		broadcastSystemMessage("'!vote simturns allow X' - allow simultaneous turns for specified number of days, or until contact");
-		broadcastSystemMessage("'!vote simturns force X' - force simultaneous turns for specified number of days, blocking player contacts");
-		broadcastSystemMessage("'!vote simturns abort' - abort simultaneous turns once this turn ends");
-		broadcastSystemMessage("'!vote timer prolong X' - prolong base timer for all players by specified number of seconds");
+		broadcastSystemMessage(MetaString::createFromTextID("vcmi.broadcast.vote.allow"));
+		broadcastSystemMessage(MetaString::createFromTextID("vcmi.broadcast.vote.force"));
+		broadcastSystemMessage(MetaString::createFromTextID("vcmi.broadcast.vote.abort"));
+		broadcastSystemMessage(MetaString::createFromTextID("vcmi.broadcast.vote.timer"));
 		return;
 	}
 
-	if(words[1] == "yes" || words[1] == "no")
+	if(words[1] == "yes" || words[1] == "no" || words[1] == MetaString::createFromTextID("vcmi.broadcast.vote.yes").toString() || words[1] == MetaString::createFromTextID("vcmi.broadcast.vote.no").toString())
 	{
 		if(currentVote == ECurrentChatVote::NONE)
 		{
-			broadcastSystemMessage("No active voting!");
+			broadcastSystemMessage(MetaString::createFromTextID("vcmi.broadcast.vote.noActive"));
 			return;
 		}
 
-		if(words[1] == "yes")
+		if(words[1] == "yes" || words[1] == MetaString::createFromTextID("vcmi.broadcast.vote.yes").toString())
 		{
 			awaitingPlayers.erase(player);
 			if(awaitingPlayers.empty())
 				finishVoting();
 			return;
 		}
-		if(words[1] == "no")
+		if(words[1] == "no" || words[1] == MetaString::createFromTextID("vcmi.broadcast.vote.no").toString())
 		{
 			abortVoting();
 			return;
@@ -225,28 +248,36 @@
 		}
 	}
 
-	broadcastSystemMessage("Voting command not recognized!");
+	broadcastSystemMessage(MetaString::createFromTextID("vcmi.broadcast.vote.notRecognized"));
 }
 
 void PlayerMessageProcessor::finishVoting()
 {
+	MetaString msg;
 	switch(currentVote)
 	{
 		case ECurrentChatVote::SIMTURNS_ALLOW:
-			broadcastSystemMessage("Voting successful. Simultaneous turns will run for " + std::to_string(currentVoteParameter) + " more days, or until contact");
+			msg.appendTextID("vcmi.broadcast.vote.success.untilContacts");
+			msg.replaceRawString(std::to_string(currentVoteParameter));
+			broadcastSystemMessage(msg);
 			gameHandler->turnOrder->setMaxSimturnsDuration(currentVoteParameter);
 			break;
 		case ECurrentChatVote::SIMTURNS_FORCE:
-			broadcastSystemMessage("Voting successful. Simultaneous turns will run for " + std::to_string(currentVoteParameter) + " more days. Contacts are blocked");
+			msg.appendTextID("vcmi.broadcast.vote.success.contactsBlocked");
+			msg.replaceRawString(std::to_string(currentVoteParameter));
+			broadcastSystemMessage(msg);
 			gameHandler->turnOrder->setMinSimturnsDuration(currentVoteParameter);
 			break;
 		case ECurrentChatVote::SIMTURNS_ABORT:
-			broadcastSystemMessage("Voting successful. Simultaneous turns will end on next day");
+			msg.appendTextID("vcmi.broadcast.vote.success.nextDay");
+			broadcastSystemMessage(msg);
 			gameHandler->turnOrder->setMinSimturnsDuration(0);
 			gameHandler->turnOrder->setMaxSimturnsDuration(0);
 			break;
 		case ECurrentChatVote::TIMER_PROLONG:
-			broadcastSystemMessage("Voting successful. Timer for all players has been prolonger for " + std::to_string(currentVoteParameter) + " seconds");
+			msg.appendTextID("vcmi.broadcast.vote.success.timer");
+			msg.replaceRawString(std::to_string(currentVoteParameter));
+			broadcastSystemMessage(msg);
 			gameHandler->turnTimerHandler->prolongTimers(currentVoteParameter * 1000);
 			break;
 	}
@@ -257,7 +288,7 @@
 
 void PlayerMessageProcessor::abortVoting()
 {
-	broadcastSystemMessage("Player voted against change. Voting aborted");
+	broadcastSystemMessage(MetaString::createFromTextID("vcmi.broadcast.vote.aborted"));
 	currentVote = ECurrentChatVote::NONE;
 }
 
@@ -266,25 +297,33 @@
 	currentVote = what;
 	currentVoteParameter = parameter;
 
+	MetaString msg;
 	switch(currentVote)
 	{
 		case ECurrentChatVote::SIMTURNS_ALLOW:
-			broadcastSystemMessage("Started voting to allow simultaneous turns for " + std::to_string(parameter) + " more days");
+			msg.appendTextID("vcmi.broadcast.vote.start.untilContacts");
+			msg.replaceRawString(std::to_string(parameter));
+			broadcastSystemMessage(msg);
 			break;
 		case ECurrentChatVote::SIMTURNS_FORCE:
-			broadcastSystemMessage("Started voting to force simultaneous turns for " + std::to_string(parameter) + " more days");
+			msg.appendTextID("vcmi.broadcast.vote.start.contactsBlocked");
+			msg.replaceRawString(std::to_string(parameter));
+			broadcastSystemMessage(msg);
 			break;
 		case ECurrentChatVote::SIMTURNS_ABORT:
-			broadcastSystemMessage("Started voting to end simultaneous turns starting from next day");
+			msg.appendTextID("vcmi.broadcast.vote.start.nextDay");
+			broadcastSystemMessage(msg);
 			break;
 		case ECurrentChatVote::TIMER_PROLONG:
-			broadcastSystemMessage("Started voting to prolong timer for all players by " + std::to_string(parameter) + " seconds");
+			msg.appendTextID("vcmi.broadcast.vote.start.timer");
+			msg.replaceRawString(std::to_string(parameter));
+			broadcastSystemMessage(msg);
 			break;
 		default:
 			return;
 	}
 
-	broadcastSystemMessage("Type '!vote yes' to agree to this change or '!vote no' to vote against it");
+	broadcastSystemMessage(MetaString::createFromTextID("vcmi.broadcast.vote.hint"));
 	awaitingPlayers.clear();
 
 	for(PlayerColor player(0); player < PlayerColor::PLAYER_LIMIT; ++player)
@@ -318,6 +357,8 @@
 		commandSave(player, words);
 	if(words[0] == "!cheaters")
 		commandCheaters(player, words);
+	if(words[0] == "!statistic")
+		commandStatistic(player, words);
 }
 
 void PlayerMessageProcessor::cheatGiveSpells(PlayerColor player, const CGHeroInstance * hero)
@@ -327,7 +368,7 @@
 
 	///Give hero spellbook
 	if (!hero->hasSpellbook())
-		gameHandler->giveHeroNewArtifact(hero, ArtifactID(ArtifactID::SPELLBOOK).toArtifact(), ArtifactPosition::SPELLBOOK);
+		gameHandler->giveHeroNewArtifact(hero, ArtifactID::SPELLBOOK, ArtifactPosition::SPELLBOOK);
 
 	///Give all spells with bonus (to allow banned spells)
 	GiveBonus giveBonus(GiveBonus::ETarget::OBJECT);
@@ -337,7 +378,7 @@
 	for (int level = 1; level <= GameConstants::SPELL_LEVELS; level++)
 	{
 		giveBonus.bonus.subtype = BonusCustomSubtype::spellLevel(level);
-		gameHandler->sendAndApply(&giveBonus);
+		gameHandler->sendAndApply(giveBonus);
 	}
 
 	///Give mana
@@ -345,7 +386,7 @@
 	sm.hid = hero->id;
 	sm.val = 999;
 	sm.absolute = true;
-	gameHandler->sendAndApply(&sm);
+	gameHandler->sendAndApply(sm);
 }
 
 void PlayerMessageProcessor::cheatBuildTown(PlayerColor player, const CGTownInstance * town)
@@ -353,7 +394,7 @@
 	if (!town)
 		return;
 
-	for (auto & build : town->town->buildings)
+	for (auto & build : town->getTown()->buildings)
 	{
 		if (!town->hasBuilt(build.first)
 			&& !build.second->getNameTranslated().empty()
@@ -405,11 +446,11 @@
 		return;
 
 	if (!hero->getArt(ArtifactPosition::MACH1))
-		gameHandler->giveHeroNewArtifact(hero, ArtifactID(ArtifactID::BALLISTA).toArtifact(), ArtifactPosition::MACH1);
+		gameHandler->giveHeroNewArtifact(hero, ArtifactID::BALLISTA, ArtifactPosition::MACH1);
 	if (!hero->getArt(ArtifactPosition::MACH2))
-		gameHandler->giveHeroNewArtifact(hero, ArtifactID(ArtifactID::AMMO_CART).toArtifact(), ArtifactPosition::MACH2);
+		gameHandler->giveHeroNewArtifact(hero, ArtifactID::AMMO_CART, ArtifactPosition::MACH2);
 	if (!hero->getArt(ArtifactPosition::MACH3))
-		gameHandler->giveHeroNewArtifact(hero, ArtifactID(ArtifactID::FIRST_AID_TENT).toArtifact(), ArtifactPosition::MACH3);
+		gameHandler->giveHeroNewArtifact(hero, ArtifactID::FIRST_AID_TENT, ArtifactPosition::MACH3);
 }
 
 void PlayerMessageProcessor::cheatGiveArtifacts(PlayerColor player, const CGHeroInstance * hero, std::vector<std::string> words)
@@ -423,7 +464,7 @@
 		{
 			auto artID = VLC->identifiers()->getIdentifier(ModScope::scopeGame(), "artifact", word, false);
 			if(artID &&  VLC->arth->objects[*artID])
-				gameHandler->giveHeroNewArtifact(hero, ArtifactID(*artID).toArtifact(), ArtifactPosition::FIRST_AVAILABLE);
+				gameHandler->giveHeroNewArtifact(hero, ArtifactID(*artID), ArtifactPosition::FIRST_AVAILABLE);
 		}
 	}
 	else
@@ -431,11 +472,23 @@
 		for(int g = 7; g < VLC->arth->objects.size(); ++g) //including artifacts from mods
 		{
 			if(VLC->arth->objects[g]->canBePutAt(hero))
-				gameHandler->giveHeroNewArtifact(hero, ArtifactID(g).toArtifact(), ArtifactPosition::FIRST_AVAILABLE);
+				gameHandler->giveHeroNewArtifact(hero, ArtifactID(g), ArtifactPosition::FIRST_AVAILABLE);
 		}
 	}
 }
 
+void PlayerMessageProcessor::cheatGiveScrolls(PlayerColor player, const CGHeroInstance * hero)
+{
+	if(!hero)
+		return;
+
+	for(const auto & spell : VLC->spellh->objects)
+		if(gameHandler->gameState()->isAllowed(spell->getId()) && !spell->isSpecial())
+		{
+			gameHandler->giveHeroNewScroll(hero, spell->getId(), ArtifactPosition::FIRST_AVAILABLE);
+		}
+}
+
 void PlayerMessageProcessor::cheatLevelup(PlayerColor player, const CGHeroInstance * hero, std::vector<std::string> words)
 {
 	if (!hero)
@@ -491,7 +544,7 @@
 		unlimited = true;
 	}
 
-	gameHandler->sendAndApply(&smp);
+	gameHandler->sendAndApply(smp);
 
 	GiveBonus gb(GiveBonus::ETarget::OBJECT);
 	gb.bonus.type = BonusType::FREE_SHIP_BOARDING;
@@ -536,7 +589,7 @@
 	PlayerCheated pc;
 	pc.player = player;
 	pc.winningCheatCode = true;
-	gameHandler->sendAndApply(&pc);
+	gameHandler->sendAndApply(pc);
 }
 
 void PlayerMessageProcessor::cheatDefeat(PlayerColor player)
@@ -544,7 +597,7 @@
 	PlayerCheated pc;
 	pc.player = player;
 	pc.losingCheatCode = true;
-	gameHandler->sendAndApply(&pc);
+	gameHandler->sendAndApply(pc);
 }
 
 void PlayerMessageProcessor::cheatMapReveal(PlayerColor player, bool reveal)
@@ -560,12 +613,12 @@
 	for(int z = 0; z < mapSize.z; z++)
 		for(int x = 0; x < mapSize.x; x++)
 			for(int y = 0; y < mapSize.y; y++)
-				if(!(*fowMap)[z][x][y] || fc.mode == ETileVisibility::HIDDEN)
+				if(!fowMap[z][x][y] || fc.mode == ETileVisibility::HIDDEN)
 					hlp_tab[lastUnc++] = int3(x, y, z);
 
 	fc.tiles.insert(hlp_tab, hlp_tab + lastUnc);
 	delete [] hlp_tab;
-	gameHandler->sendAndApply(&fc);
+	gameHandler->sendAndApply(fc);
 }
 
 void PlayerMessageProcessor::cheatPuzzleReveal(PlayerColor player)
@@ -583,7 +636,7 @@
 
 				PlayerCheated pc;
 				pc.player = color;
-				gameHandler->sendAndApply(&pc);
+				gameHandler->sendAndApply(pc);
 			}
 		}
 	}
@@ -659,7 +712,8 @@
 		"vcmiolorin",              "vcmiexp",
 		"vcmiluck",                                   "nwcfollowthewhiterabbit", 
 		"vcmimorale",                                 "nwcmorpheus",
-		"vcmigod",                                    "nwctheone"
+		"vcmigod",                                    "nwctheone",
+		"vcmiscrolls"
 	};
 
 	if (!vstd::contains(townTargetedCheats, cheatName) && !vstd::contains(playerTargetedCheats, cheatName) && !vstd::contains(heroTargetedCheats, cheatName))
@@ -685,7 +739,7 @@
 
 		PlayerCheated pc;
 		pc.player = i.first;
-		gameHandler->sendAndApply(&pc);
+		gameHandler->sendAndApply(pc);
 
 		playerTargetedCheat = true;
 		parameters.erase(parameters.begin());
@@ -694,17 +748,17 @@
 			executeCheatCode(cheatName, i.first, ObjectInstanceID::NONE, parameters);
 
 		if (vstd::contains(townTargetedCheats, cheatName))
-			for (const auto & t : i.second.towns)
+			for (const auto & t : i.second.getTowns())
 				executeCheatCode(cheatName, i.first, t->id, parameters);
 
 		if (vstd::contains(heroTargetedCheats, cheatName))
-			for (const auto & h : i.second.heroes)
+			for (const auto & h : i.second.getHeroes())
 				executeCheatCode(cheatName, i.first, h->id, parameters);
 	}
 
 	PlayerCheated pc;
 	pc.player = player;
-	gameHandler->sendAndApply(&pc);
+	gameHandler->sendAndApply(pc);
 	
 	if (!playerTargetedCheat)
 		executeCheatCode(cheatName, player, currObj, words);
@@ -736,6 +790,7 @@
 	const auto & doCheatRevealPuzzle = [&]() { cheatPuzzleReveal(player); };
 	const auto & doCheatMaxLuck = [&]() { cheatMaxLuck(player, hero); };
 	const auto & doCheatMaxMorale = [&]() { cheatMaxMorale(player, hero); };
+	const auto & doCheatGiveScrolls = [&]() { cheatGiveScrolls(player, hero); };
 	const auto & doCheatTheOne = [&]()
 	{
 		if(!hero)
@@ -804,6 +859,7 @@
 		{"nwcmorpheus",             doCheatMaxMorale      },
 		{"vcmigod",                 doCheatTheOne         },
 		{"nwctheone",               doCheatTheOne         },
+		{"vcmiscrolls",             doCheatGiveScrolls    },
 	};
 
 	assert(callbacks.count(cheatName));
@@ -811,11 +867,11 @@
 		callbacks.at(cheatName)();
 }
 
-void PlayerMessageProcessor::sendSystemMessage(std::shared_ptr<CConnection> connection, MetaString message)
+void PlayerMessageProcessor::sendSystemMessage(std::shared_ptr<CConnection> connection, const MetaString & message)
 {
 	SystemMessage sm;
 	sm.text = message;
-	connection->sendPack(&sm);
+	connection->sendPack(sm);
 }
 
 void PlayerMessageProcessor::sendSystemMessage(std::shared_ptr<CConnection> connection, const std::string & message)
@@ -829,7 +885,7 @@
 {
 	SystemMessage sm;
 	sm.text = message;
-	gameHandler->sendToAllClients(&sm);
+	gameHandler->sendToAllClients(sm);
 }
 
 void PlayerMessageProcessor::broadcastSystemMessage(const std::string & message)
@@ -842,5 +898,5 @@
 void PlayerMessageProcessor::broadcastMessage(PlayerColor playerSender, const std::string & message)
 {
 	PlayerMessageClient temp_message(playerSender, message);
-	gameHandler->sendAndApply(&temp_message);
+	gameHandler->sendAndApply(temp_message);
 }
diff --color -urN vcmi-1.5.7/server/processors/PlayerMessageProcessor.h vcmi/server/processors/PlayerMessageProcessor.h
--- vcmi-1.5.7/server/processors/PlayerMessageProcessor.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/server/processors/PlayerMessageProcessor.h	2024-12-19 15:00:22.994151905 +0100
@@ -46,6 +46,7 @@
 	void cheatGiveArmy(PlayerColor player, const CGHeroInstance * hero, std::vector<std::string> words);
 	void cheatGiveMachines(PlayerColor player, const CGHeroInstance * hero);
 	void cheatGiveArtifacts(PlayerColor player, const CGHeroInstance * hero, std::vector<std::string> words);
+	void cheatGiveScrolls(PlayerColor player, const CGHeroInstance * hero);
 	void cheatLevelup(PlayerColor player, const CGHeroInstance * hero, std::vector<std::string> words);
 	void cheatExperience(PlayerColor player, const CGHeroInstance * hero, std::vector<std::string> words);
 	void cheatMovement(PlayerColor player, const CGHeroInstance * hero, std::vector<std::string> words);
@@ -62,6 +63,7 @@
 	void commandKick(PlayerColor player, const std::vector<std::string> & words);
 	void commandSave(PlayerColor player, const std::vector<std::string> & words);
 	void commandCheaters(PlayerColor player, const std::vector<std::string> & words);
+	void commandStatistic(PlayerColor player, const std::vector<std::string> & words);
 	void commandHelp(PlayerColor player, const std::vector<std::string> & words);
 	void commandVote(PlayerColor player, const std::vector<std::string> & words);
 
@@ -76,7 +78,7 @@
 	void playerMessage(PlayerColor player, const std::string & message, ObjectInstanceID currObj);
 
 	/// Send message to specific client with "System" as sender
-	void sendSystemMessage(std::shared_ptr<CConnection> connection, MetaString message);
+	void sendSystemMessage(std::shared_ptr<CConnection> connection, const MetaString & message);
 	void sendSystemMessage(std::shared_ptr<CConnection> connection, const std::string & message);
 
 	/// Send message to all players with "System" as sender
diff --color -urN vcmi-1.5.7/server/processors/TurnOrderProcessor.cpp vcmi/server/processors/TurnOrderProcessor.cpp
--- vcmi-1.5.7/server/processors/TurnOrderProcessor.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/server/processors/TurnOrderProcessor.cpp	2024-12-19 15:00:22.994151905 +0100
@@ -72,7 +72,7 @@
 	{
 		// Simturns between all players have ended - send single global notification
 		if (!blockedContacts.empty())
-			gameHandler->playerMessages->broadcastSystemMessage("Simultaneous turns have ended");
+			gameHandler->playerMessages->broadcastSystemMessage(MetaString::createFromTextID("vcmi.broadcast.simturn.end"));
 	}
 	else
 	{
@@ -83,11 +83,11 @@
 				continue;
 
 			MetaString message;
-			message.appendRawString("Simultaneous turns between players %s and %s have ended"); // FIXME: we should send MetaString itself and localize it on client side
+			message.appendTextID("vcmi.broadcast.simturn.endBetween");
 			message.replaceName(contact.a);
 			message.replaceName(contact.b);
 
-			gameHandler->playerMessages->broadcastSystemMessage(message.toString());
+			gameHandler->playerMessages->broadcastSystemMessage(message);
 		}
 	}
 
@@ -121,7 +121,7 @@
 		}
 	}
 
-	for(const auto & hero : leftInfo->heroes)
+	for(const auto & hero : leftInfo->getHeroes())
 	{
 		CPathsInfo out(mapSize, hero);
 		auto config = std::make_shared<SingleHeroPathfinderConfig>(out, gameHandler->gameState(), hero);
@@ -137,7 +137,7 @@
 						leftReachability[z][x][y] = true;
 	}
 
-	for(const auto & hero : rightInfo->heroes)
+	for(const auto & hero : rightInfo->getHeroes())
 	{
 		CPathsInfo out(mapSize, hero);
 		auto config = std::make_shared<SingleHeroPathfinderConfig>(out, gameHandler->gameState(), hero);
@@ -179,7 +179,7 @@
 
 	if (activeInfo->human != waitingInfo->human)
 	{
-		// only one AI and one human can play simultaneoulsy from single connection
+		// only one AI and one human can play simultaneously from single connection
 		if (!gameHandler->getStartInfo()->simturnsInfo.allowHumanWithAI)
 			return false;
 	}
@@ -287,7 +287,7 @@
 	PlayerStartsTurn pst;
 	pst.player = which;
 	pst.queryID = turnQuery->queryID;
-	gameHandler->sendAndApply(&pst);
+	gameHandler->sendAndApply(pst);
 
 	assert(!actingPlayers.empty());
 }
@@ -302,7 +302,7 @@
 
 	PlayerEndsTurn pet;
 	pet.player = which;
-	gameHandler->sendAndApply(&pet);
+	gameHandler->sendAndApply(pet);
 
 	if (!awaitingPlayers.empty())
 		tryStartTurnsForPlayers();
diff --color -urN vcmi-1.5.7/server/queries/BattleQueries.cpp vcmi/server/queries/BattleQueries.cpp
--- vcmi-1.5.7/server/queries/BattleQueries.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/server/queries/BattleQueries.cpp	2024-12-19 15:00:22.994151905 +0100
@@ -17,43 +17,44 @@
 
 #include "../../lib/battle/IBattleState.h"
 #include "../../lib/battle/SideInBattle.h"
+#include "../../lib/battle/BattleLayout.h"
 #include "../../lib/CPlayerState.h"
 #include "../../lib/mapObjects/CGObjectInstance.h"
 #include "../../lib/mapObjects/CGTownInstance.h"
 #include "../../lib/networkPacks/PacksForServer.h"
-#include "../../lib/serializer/Cast.h"
 
-void CBattleQuery::notifyObjectAboutRemoval(const CObjectVisitQuery & objectVisit) const
+void CBattleQuery::notifyObjectAboutRemoval(const CGObjectInstance * visitedObject, const CGHeroInstance * visitingHero) const
 {
 	assert(result);
 
 	if(result)
-		objectVisit.visitedObject->battleFinished(objectVisit.visitingHero, *result);
+		visitedObject->battleFinished(visitingHero, *result);
 }
 
 CBattleQuery::CBattleQuery(CGameHandler * owner, const IBattleInfo * bi):
 	CQuery(owner),
 	battleID(bi->getBattleID())
 {
-	belligerents[0] = bi->getSideArmy(0);
-	belligerents[1] = bi->getSideArmy(1);
+	belligerents[BattleSide::ATTACKER] = bi->getSideArmy(BattleSide::ATTACKER);
+	belligerents[BattleSide::DEFENDER] = bi->getSideArmy(BattleSide::DEFENDER);
 
-	addPlayer(bi->getSidePlayer(0));
-	addPlayer(bi->getSidePlayer(1));
+	addPlayer(bi->getSidePlayer(BattleSide::ATTACKER));
+	addPlayer(bi->getSidePlayer(BattleSide::DEFENDER));
 }
 
 CBattleQuery::CBattleQuery(CGameHandler * owner):
 	CQuery(owner)
 {
-	belligerents[0] = belligerents[1] = nullptr;
+	belligerents[BattleSide::ATTACKER] = nullptr;
+	belligerents[BattleSide::DEFENDER] = nullptr;
 }
 
-bool CBattleQuery::blocksPack(const CPack * pack) const
+bool CBattleQuery::blocksPack(const CPackForServer * pack) const
 {
-	if(dynamic_ptr_cast<MakeAction>(pack) != nullptr)
+	if(dynamic_cast<const MakeAction*>(pack) != nullptr)
 		return false;
 
-	if(dynamic_ptr_cast<GamePause>(pack) != nullptr)
+	if(dynamic_cast<const GamePause*>(pack) != nullptr)
 		return false;
 
 	return true;
@@ -81,8 +82,8 @@
 	bi(bi),
 	result(Br)
 {
-	addPlayer(bi->getSidePlayer(0));
-	addPlayer(bi->getSidePlayer(1));
+	addPlayer(bi->getSidePlayer(BattleSide::ATTACKER));
+	addPlayer(bi->getSidePlayer(BattleSide::DEFENDER));
 }
 
 void CBattleDialogQuery::onRemoval(PlayerColor color)
@@ -95,14 +96,14 @@
 	assert(answer);
 	if(*answer == 1)
 	{
-		gh->battles->restartBattlePrimary(
+		gh->battles->restartBattle(
 			bi->getBattleID(),
-			bi->getSideArmy(0),
-			bi->getSideArmy(1),
+			bi->getSideArmy(BattleSide::ATTACKER),
+			bi->getSideArmy(BattleSide::DEFENDER),
 			bi->getLocation(),
-			bi->getSideHero(0),
-			bi->getSideHero(1),
-			bi->isCreatureBank(),
+			bi->getSideHero(BattleSide::ATTACKER),
+			bi->getSideHero(BattleSide::DEFENDER),
+			bi->getLayout(),
 			bi->getDefendedTown()
 		);
 	}
diff --color -urN vcmi-1.5.7/server/queries/BattleQueries.h vcmi/server/queries/BattleQueries.h
--- vcmi-1.5.7/server/queries/BattleQueries.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/server/queries/BattleQueries.h	2024-12-19 15:00:22.994151905 +0100
@@ -11,6 +11,7 @@
 
 #include "CQuery.h"
 #include "../../lib/networkPacks/PacksForClientBattle.h"
+#include "../../lib/battle/BattleSide.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 class IBattleInfo;
@@ -20,16 +21,16 @@
 class CBattleQuery : public CQuery
 {
 public:
-	std::array<const CArmedInstance *,2> belligerents;
-	std::array<int, 2> initialHeroMana;
+	BattleSideArray<const CArmedInstance *> belligerents;
+	BattleSideArray<int> initialHeroMana;
 
 	BattleID battleID;
 	std::optional<BattleResult> result;
 
 	CBattleQuery(CGameHandler * owner);
 	CBattleQuery(CGameHandler * owner, const IBattleInfo * Bi); //TODO
-	void notifyObjectAboutRemoval(const CObjectVisitQuery &objectVisit) const override;
-	bool blocksPack(const CPack *pack) const override;
+	void notifyObjectAboutRemoval(const CGObjectInstance * visitedObject, const CGHeroInstance * visitingHero) const override;
+	bool blocksPack(const CPackForServer *pack) const override;
 	void onRemoval(PlayerColor color) override;
 	void onExposure(QueryPtr topQuery) override;
 };
@@ -37,10 +38,10 @@
 class CBattleDialogQuery : public CDialogQuery
 {
 	bool resultProcessed = false;
-public:
-	CBattleDialogQuery(CGameHandler * owner, const IBattleInfo * Bi, std::optional<BattleResult> Br);
-
 	const IBattleInfo * bi;
 	std::optional<BattleResult> result;
+
+public:
+	CBattleDialogQuery(CGameHandler * owner, const IBattleInfo * Bi, std::optional<BattleResult> Br);
 	void onRemoval(PlayerColor color) override;
 };
diff --color -urN vcmi-1.5.7/server/queries/CQuery.cpp vcmi/server/queries/CQuery.cpp
--- vcmi-1.5.7/server/queries/CQuery.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/server/queries/CQuery.cpp	2024-12-19 15:00:22.994151905 +0100
@@ -14,27 +14,8 @@
 
 #include "../CGameHandler.h"
 
-#include "../../lib/serializer/Cast.h"
 #include "../../lib/networkPacks/PacksForServer.h"
 
-template <typename Container>
-std::string formatContainer(const Container & c, std::string delimeter = ", ", std::string opener = "(", std::string closer=")")
-{
-	std::string ret = opener;
-	auto itr = std::begin(c);
-	if(itr != std::end(c))
-	{
-		ret += std::to_string(*itr);
-		while(++itr != std::end(c))
-		{
-			ret += delimeter;
-			ret += std::to_string(*itr);
-		}
-	}
-	ret += closer;
-	return ret;
-}
-
 std::ostream & operator<<(std::ostream & out, const CQuery & query)
 {
 	return out << query.toString();
@@ -100,12 +81,12 @@
 
 }
 
-bool CQuery::blocksPack(const CPack * pack) const
+bool CQuery::blocksPack(const CPackForServer * pack) const
 {
 	return false;
 }
 
-void CQuery::notifyObjectAboutRemoval(const CObjectVisitQuery & objectVisit) const
+void CQuery::notifyObjectAboutRemoval(const CGObjectInstance * visitedObject, const CGHeroInstance * visitingHero) const
 {
 
 }
@@ -131,10 +112,10 @@
 
 }
 
-bool CQuery::blockAllButReply(const CPack * pack) const
+bool CQuery::blockAllButReply(const CPackForServer * pack) const
 {
 	//We accept only query replies from correct player
-	if(auto reply = dynamic_ptr_cast<QueryReply>(pack))
+	if(auto reply = dynamic_cast<const QueryReply*>(pack))
 		return !vstd::contains(players, reply->player);
 
 	return true;
@@ -151,7 +132,7 @@
 	return true;
 }
 
-bool CDialogQuery::blocksPack(const CPack * pack) const
+bool CDialogQuery::blocksPack(const CPackForServer * pack) const
 {
 	return blockAllButReply(pack);
 }
@@ -168,7 +149,7 @@
 	addPlayer(color);
 }
 
-bool CGenericQuery::blocksPack(const CPack * pack) const
+bool CGenericQuery::blocksPack(const CPackForServer * pack) const
 {
 	return blockAllButReply(pack);
 }
diff --color -urN vcmi-1.5.7/server/queries/CQuery.h vcmi/server/queries/CQuery.h
--- vcmi-1.5.7/server/queries/CQuery.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/server/queries/CQuery.h	2024-12-19 15:00:22.994151905 +0100
@@ -13,7 +13,9 @@
 
 VCMI_LIB_NAMESPACE_BEGIN
 
-struct CPack;
+struct CPackForServer;
+class CGObjectInstance;
+class CGHeroInstance;
 
 VCMI_LIB_NAMESPACE_END
 
@@ -40,25 +42,36 @@
 
 	CQuery(CGameHandler * gh);
 
-	virtual bool blocksPack(const CPack *pack) const; //query can block attempting actions by player. Eg. he can't move hero during the battle.
+	/// query can block attempting actions by player. Eg. he can't move hero during the battle.
+	virtual bool blocksPack(const CPackForServer *pack) const;
 
-	virtual bool endsByPlayerAnswer() const; //query is removed after player gives answer (like dialogs)
-	virtual void onAdding(PlayerColor color); //called just before query is pushed on stack
-	virtual void onAdded(PlayerColor color); //called right after query is pushed on stack
-	virtual void onRemoval(PlayerColor color); //called after query is removed from stack
-	virtual void onExposure(QueryPtr topQuery);//called when query immediately above is removed and this is exposed (becomes top)
-	virtual std::string toString() const;
+	/// query is removed after player gives answer (like dialogs)
+	virtual bool endsByPlayerAnswer() const;
+
+	/// called just before query is pushed on stack
+	virtual void onAdding(PlayerColor color);
+
+	/// called right after query is pushed on stack
+	virtual void onAdded(PlayerColor color);
 
-	virtual void notifyObjectAboutRemoval(const CObjectVisitQuery &objectVisit) const;
+	/// called after query is removed from stack
+	virtual void onRemoval(PlayerColor color);
+
+	/// called when query immediately above is removed and this is exposed (becomes top)
+	virtual void onExposure(QueryPtr topQuery);
+
+	/// called when this query is being removed and must report its result to currently visited object
+	virtual void notifyObjectAboutRemoval(const CGObjectInstance * visitedObject, const CGHeroInstance * visitingHero) const;
 
 	virtual void setReply(std::optional<int32_t> reply);
+	virtual std::string toString() const;
 
 	virtual ~CQuery();
 protected:
 	QueriesProcessor * owner;
 	CGameHandler * gh;
 	void addPlayer(PlayerColor color);
-	bool blockAllButReply(const CPack * pack) const;
+	bool blockAllButReply(const CPackForServer * pack) const;
 };
 
 std::ostream &operator<<(std::ostream &out, const CQuery &query);
@@ -69,7 +82,7 @@
 public:
 	CDialogQuery(CGameHandler * owner);
 	bool endsByPlayerAnswer() const override;
-	bool blocksPack(const CPack *pack) const override;
+	bool blocksPack(const CPackForServer *pack) const override;
 	void setReply(std::optional<int32_t> reply) override;
 protected:
 	std::optional<ui32> answer;
@@ -80,7 +93,7 @@
 public:
 	CGenericQuery(CGameHandler * gh, PlayerColor color, std::function<void(std::optional<int32_t>)> Callback);
 
-	bool blocksPack(const CPack * pack) const override;
+	bool blocksPack(const CPackForServer * pack) const override;
 	bool endsByPlayerAnswer() const override;
 	void onExposure(QueryPtr topQuery) override;
 	void setReply(std::optional<int32_t> reply) override;
diff --color -urN vcmi-1.5.7/server/queries/MapQueries.cpp vcmi/server/queries/MapQueries.cpp
--- vcmi-1.5.7/server/queries/MapQueries.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/server/queries/MapQueries.cpp	2024-12-19 15:00:22.994151905 +0100
@@ -13,10 +13,9 @@
 #include "QueriesProcessor.h"
 #include "../CGameHandler.h"
 #include "../TurnTimerHandler.h"
-#include "../../lib/mapObjects/MiscObjects.h"
 #include "../../lib/mapObjects/CGHeroInstance.h"
+#include "../../lib/mapObjects/MiscObjects.h"
 #include "../../lib/networkPacks/PacksForServer.h"
-#include "../../lib/serializer/Cast.h"
 
 TimerPauseQuery::TimerPauseQuery(CGameHandler * owner, PlayerColor player):
 	CQuery(owner)
@@ -24,7 +23,7 @@
 	addPlayer(player);
 }
 
-bool TimerPauseQuery::blocksPack(const CPack *pack) const
+bool TimerPauseQuery::blocksPack(const CPackForServer *pack) const
 {
 	return blockAllButReply(pack);
 }
@@ -44,41 +43,9 @@
 	return true;
 }
 
-CObjectVisitQuery::CObjectVisitQuery(CGameHandler * owner, const CGObjectInstance * Obj, const CGHeroInstance * Hero, int3 Tile):
-	CQuery(owner), visitedObject(Obj), visitingHero(Hero), tile(Tile), removeObjectAfterVisit(false)
-{
-	addPlayer(Hero->tempOwner);
-}
-
-bool CObjectVisitQuery::blocksPack(const CPack *pack) const
-{
-	//During the visit itself ALL actions are blocked.
-	//(However, the visit may trigger a query above that'll pass some.)
-	return true;
-}
-
-void CObjectVisitQuery::onRemoval(PlayerColor color)
-{
-	gh->objectVisitEnded(*this);
-
-	//TODO or should it be destructor?
-	//Can object visit affect 2 players and what would be desired behavior?
-	if(removeObjectAfterVisit)
-		gh->removeObject(visitedObject, color);
-}
-
-void CObjectVisitQuery::onExposure(QueryPtr topQuery)
-{
-	//Object may have been removed and deleted.
-	if(gh->isValidObject(visitedObject))
-		topQuery->notifyObjectAboutRemoval(*this);
-
-	owner->popIfTop(*this);
-}
-
-void CGarrisonDialogQuery::notifyObjectAboutRemoval(const CObjectVisitQuery & objectVisit) const
+void CGarrisonDialogQuery::notifyObjectAboutRemoval(const CGObjectInstance * visitedObject, const CGHeroInstance * visitingHero) const
 {
-	objectVisit.visitedObject->garrisonDialogClosed(objectVisit.visitingHero);
+	visitedObject->garrisonDialogClosed(visitingHero);
 }
 
 CGarrisonDialogQuery::CGarrisonDialogQuery(CGameHandler * owner, const CArmedInstance * up, const CArmedInstance * down):
@@ -91,28 +58,28 @@
 	addPlayer(down->tempOwner);
 }
 
-bool CGarrisonDialogQuery::blocksPack(const CPack * pack) const
+bool CGarrisonDialogQuery::blocksPack(const CPackForServer * pack) const
 {
 	std::set<ObjectInstanceID> ourIds;
 	ourIds.insert(this->exchangingArmies[0]->id);
 	ourIds.insert(this->exchangingArmies[1]->id);
 
-	if(auto stacks = dynamic_ptr_cast<ArrangeStacks>(pack))
+	if(auto stacks = dynamic_cast<const ArrangeStacks*>(pack))
 		return !vstd::contains(ourIds, stacks->id1) || !vstd::contains(ourIds, stacks->id2);
 
-	if(auto stacks = dynamic_ptr_cast<BulkSplitStack>(pack))
+	if(auto stacks = dynamic_cast<const BulkSplitStack*>(pack))
 		return !vstd::contains(ourIds, stacks->srcOwner);
 
-	if(auto stacks = dynamic_ptr_cast<BulkMergeStacks>(pack))
+	if(auto stacks = dynamic_cast<const BulkMergeStacks*>(pack))
 		return !vstd::contains(ourIds, stacks->srcOwner);
 
-	if(auto stacks = dynamic_ptr_cast<BulkSmartSplitStack>(pack))
+	if(auto stacks = dynamic_cast<const BulkSmartSplitStack*>(pack))
 		return !vstd::contains(ourIds, stacks->srcOwner);
 
-	if(auto stacks = dynamic_ptr_cast<BulkMoveArmy>(pack))
+	if(auto stacks = dynamic_cast<const BulkMoveArmy*>(pack))
 		return !vstd::contains(ourIds, stacks->srcArmy) || !vstd::contains(ourIds, stacks->destArmy);
 
-	if(auto arts = dynamic_ptr_cast<ExchangeArtifacts>(pack))
+	if(auto arts = dynamic_cast<const ExchangeArtifacts*>(pack))
 	{
 		if(auto id1 = arts->src.artHolder)
 			if(!vstd::contains(ourIds, id1))
@@ -123,41 +90,42 @@
 				return true;
 		return false;
 	}
-	if(auto dismiss = dynamic_ptr_cast<DisbandCreature>(pack))
+	if(auto dismiss = dynamic_cast<const DisbandCreature*>(pack))
 		return !vstd::contains(ourIds, dismiss->id);
 
-	if(auto arts = dynamic_ptr_cast<BulkExchangeArtifacts>(pack))
+	if(auto arts = dynamic_cast<const BulkExchangeArtifacts*>(pack))
 		return !vstd::contains(ourIds, arts->srcHero) || !vstd::contains(ourIds, arts->dstHero);
 
-	if(auto arts = dynamic_ptr_cast<ManageBackpackArtifacts>(pack))
+	if(auto arts = dynamic_cast<const ManageBackpackArtifacts*>(pack))
 		return !vstd::contains(ourIds, arts->artHolder);
 
-	if(auto art = dynamic_ptr_cast<EraseArtifactByClient>(pack))
+	if(auto art = dynamic_cast<const EraseArtifactByClient*>(pack))
 	{
 		if(auto id = art->al.artHolder)
 			return !vstd::contains(ourIds, id);
 	}
 
-	if(auto dismiss = dynamic_ptr_cast<AssembleArtifacts>(pack))
+	if(auto dismiss = dynamic_cast<const AssembleArtifacts*>(pack))
 		return !vstd::contains(ourIds, dismiss->heroID);
 
-	if(auto upgrade = dynamic_ptr_cast<UpgradeCreature>(pack))
+	if(auto upgrade = dynamic_cast<const UpgradeCreature*>(pack))
 		return !vstd::contains(ourIds, upgrade->id);
 
-	if(auto formation = dynamic_ptr_cast<SetFormation>(pack))
+	if(auto formation = dynamic_cast<const SetFormation*>(pack))
 		return !vstd::contains(ourIds, formation->hid);
 
 	return CDialogQuery::blocksPack(pack);
 }
 
-void CBlockingDialogQuery::notifyObjectAboutRemoval(const CObjectVisitQuery & objectVisit) const
+void CBlockingDialogQuery::notifyObjectAboutRemoval(const CGObjectInstance * visitedObject, const CGHeroInstance * visitingHero) const
 {
 	assert(answer);
-	objectVisit.visitedObject->blockingDialogAnswered(objectVisit.visitingHero, *answer);
+	caller->blockingDialogAnswered(visitingHero, *answer);
 }
 
-CBlockingDialogQuery::CBlockingDialogQuery(CGameHandler * owner, const BlockingDialog & bd):
-	CDialogQuery(owner)
+CBlockingDialogQuery::CBlockingDialogQuery(CGameHandler * owner, const IObjectInterface * caller, const BlockingDialog & bd):
+	CDialogQuery(owner),
+	caller(caller)
 {
 	this->bd = bd;
 	addPlayer(bd.player);
@@ -175,60 +143,59 @@
 	//do nothing - wait for reply
 }
 
-bool OpenWindowQuery::blocksPack(const CPack *pack) const
+bool OpenWindowQuery::blocksPack(const CPackForServer *pack) const
 {
 	if (mode == EOpenWindowMode::RECRUITMENT_FIRST || mode == EOpenWindowMode::RECRUITMENT_ALL)
 	{
-		if(dynamic_ptr_cast<RecruitCreatures>(pack) != nullptr)
+		if(dynamic_cast<const RecruitCreatures*>(pack) != nullptr)
 			return false;
 
 		// If hero has no free slots, he might get some stacks merged automatically
-		if(dynamic_ptr_cast<ArrangeStacks>(pack) != nullptr)
+		if(dynamic_cast<const ArrangeStacks*>(pack) != nullptr)
 			return false;
 	}
 
 	if (mode == EOpenWindowMode::TAVERN_WINDOW)
 	{
-		if(dynamic_ptr_cast<HireHero>(pack) != nullptr)
+		if(dynamic_cast<const HireHero*>(pack) != nullptr)
 			return false;
 	}
 
 	if (mode == EOpenWindowMode::UNIVERSITY_WINDOW)
 	{
-		if(dynamic_ptr_cast<TradeOnMarketplace>(pack) != nullptr)
+		if(dynamic_cast<const TradeOnMarketplace*>(pack) != nullptr)
 			return false;
 	}
 
 	if (mode == EOpenWindowMode::MARKET_WINDOW)
 	{
-		if(dynamic_ptr_cast<ExchangeArtifacts>(pack) != nullptr)
+		if(dynamic_cast<const ExchangeArtifacts*>(pack) != nullptr)
 			return false;
 
-		if(dynamic_ptr_cast<BulkExchangeArtifacts>(pack) != nullptr)
+		if(dynamic_cast<const BulkExchangeArtifacts*>(pack) != nullptr)
 			return false;
 
-		if(dynamic_ptr_cast<ManageBackpackArtifacts>(pack) != nullptr)
+		if(dynamic_cast<const ManageBackpackArtifacts*>(pack) != nullptr)
 			return false;
 
-		if(dynamic_ptr_cast<AssembleArtifacts>(pack))
+		if(dynamic_cast<const AssembleArtifacts*>(pack))
 			return false;
 
-		if(dynamic_ptr_cast<EraseArtifactByClient>(pack))
+		if(dynamic_cast<const EraseArtifactByClient*>(pack))
 			return false;
 
-		if(dynamic_ptr_cast<TradeOnMarketplace>(pack) != nullptr)
+		if(dynamic_cast<const TradeOnMarketplace*>(pack) != nullptr)
 			return false;
 	}
 
 	return CDialogQuery::blocksPack(pack);
 }
 
-void CTeleportDialogQuery::notifyObjectAboutRemoval(const CObjectVisitQuery & objectVisit) const
+void CTeleportDialogQuery::notifyObjectAboutRemoval(const CGObjectInstance * visitedObject, const CGHeroInstance * visitingHero) const
 {
-	// do not change to dynamic_ptr_cast - SIGSEGV!
-	auto obj = dynamic_cast<const CGTeleport*>(objectVisit.visitedObject);
+	auto obj = dynamic_cast<const CGTeleport*>(visitedObject);
 	if(obj)
-		obj->teleportDialogAnswered(objectVisit.visitingHero, *answer, td.exits);
+		obj->teleportDialogAnswered(visitingHero, *answer, td.exits);
 	else
 		logGlobal->error("Invalid instance in teleport query");
 }
@@ -254,9 +221,9 @@
 	gh->levelUpHero(hero, hlu.skills[*answer]);
 }
 
-void CHeroLevelUpDialogQuery::notifyObjectAboutRemoval(const CObjectVisitQuery & objectVisit) const
+void CHeroLevelUpDialogQuery::notifyObjectAboutRemoval(const CGObjectInstance * visitedObject, const CGHeroInstance * visitingHero) const
 {
-	objectVisit.visitedObject->heroLevelUpDone(objectVisit.visitingHero);
+	visitedObject->heroLevelUpDone(visitingHero);
 }
 
 CCommanderLevelUpDialogQuery::CCommanderLevelUpDialogQuery(CGameHandler * owner, const CommanderLevelUp & Clu, const CGHeroInstance * Hero):
@@ -273,9 +240,9 @@
 	gh->levelUpCommander(hero->commander, clu.skills[*answer]);
 }
 
-void CCommanderLevelUpDialogQuery::notifyObjectAboutRemoval(const CObjectVisitQuery & objectVisit) const
+void CCommanderLevelUpDialogQuery::notifyObjectAboutRemoval(const CGObjectInstance * visitedObject, const CGHeroInstance * visitingHero) const
 {
-	objectVisit.visitedObject->heroLevelUpDone(objectVisit.visitingHero);
+	visitedObject->heroLevelUpDone(visitingHero);
 }
 
 CHeroMovementQuery::CHeroMovementQuery(CGameHandler * owner, const TryMoveHero & Tmh, const CGHeroInstance * Hero, bool VisitDestAfterVictory):
@@ -306,7 +273,7 @@
 	pb.player = color;
 	pb.reason = PlayerBlocked::ONGOING_MOVEMENT;
 	pb.startOrEnd = PlayerBlocked::BLOCKADE_ENDED;
-	gh->sendAndApply(&pb);
+	gh->sendAndApply(pb);
 }
 
 void CHeroMovementQuery::onAdding(PlayerColor color)
@@ -315,5 +282,5 @@
 	pb.player = color;
 	pb.reason = PlayerBlocked::ONGOING_MOVEMENT;
 	pb.startOrEnd = PlayerBlocked::BLOCKADE_STARTED;
-	gh->sendAndApply(&pb);
+	gh->sendAndApply(pb);
 }
diff --color -urN vcmi-1.5.7/server/queries/MapQueries.h vcmi/server/queries/MapQueries.h
--- vcmi-1.5.7/server/queries/MapQueries.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/server/queries/MapQueries.h	2024-12-19 15:00:22.994151905 +0100
@@ -15,12 +15,9 @@
 VCMI_LIB_NAMESPACE_BEGIN
 class CGHeroInstance;
 class CGObjectInstance;
-class int3;
+class IObjectInterface;
 VCMI_LIB_NAMESPACE_END
 
-
-class TurnTimerHandler;
-
 //Created when player starts turn or when player puts game on [ause
 //Removed when player accepts a turn or continur play
 class TimerPauseQuery : public CQuery
@@ -28,29 +25,12 @@
 public:	
 	TimerPauseQuery(CGameHandler * owner, PlayerColor player);
 	
-	bool blocksPack(const CPack *pack) const override;
+	bool blocksPack(const CPackForServer *pack) const override;
 	void onAdding(PlayerColor color) override;
 	void onRemoval(PlayerColor color) override;
 	bool endsByPlayerAnswer() const override;
 };
 
-//Created when hero visits object.
-//Removed when query above is resolved (or immediately after visit if no queries were created)
-class CObjectVisitQuery : public CQuery
-{
-public:
-	const CGObjectInstance *visitedObject;
-	const CGHeroInstance *visitingHero;
-	int3 tile; //may be different than hero pos -> eg. visit via teleport
-	bool removeObjectAfterVisit;
-
-	CObjectVisitQuery(CGameHandler * owner, const CGObjectInstance *Obj, const CGHeroInstance *Hero, int3 Tile);
-
-	bool blocksPack(const CPack *pack) const override;
-	void onRemoval(PlayerColor color) override;
-	void onExposure(QueryPtr topQuery) override;
-};
-
 //Created when hero attempts move and something happens
 //(not necessarily position change, could be just an object interaction).
 class CHeroMovementQuery : public CQuery
@@ -73,19 +53,20 @@
 	std::array<const CArmedInstance *,2> exchangingArmies;
 
 	CGarrisonDialogQuery(CGameHandler * owner, const CArmedInstance *up, const CArmedInstance *down);
-	void notifyObjectAboutRemoval(const CObjectVisitQuery &objectVisit) const override;
-	bool blocksPack(const CPack *pack) const override;
+	void notifyObjectAboutRemoval(const CGObjectInstance * visitedObject, const CGHeroInstance * visitingHero) const override;
+	bool blocksPack(const CPackForServer *pack) const override;
 };
 
 //yes/no and component selection dialogs
 class CBlockingDialogQuery : public CDialogQuery
 {
 public:
+	const IObjectInterface * caller;
 	BlockingDialog bd; //copy of pack... debug purposes
 
-	CBlockingDialogQuery(CGameHandler * owner, const BlockingDialog &bd);
+	CBlockingDialogQuery(CGameHandler * owner, const IObjectInterface * caller, const BlockingDialog &bd);
 
-	void notifyObjectAboutRemoval(const CObjectVisitQuery &objectVisit) const override;
+	void notifyObjectAboutRemoval(const CGObjectInstance * visitedObject, const CGHeroInstance * visitingHero) const override;
 };
 
 class OpenWindowQuery : public CDialogQuery
@@ -94,7 +75,7 @@
 public:
 	OpenWindowQuery(CGameHandler * owner, const CGHeroInstance *hero, EOpenWindowMode mode);
 
-	bool blocksPack(const CPack *pack) const override;
+	bool blocksPack(const CPackForServer *pack) const override;
 	void onExposure(QueryPtr topQuery) override;
 };
 
@@ -105,7 +86,7 @@
 
 	CTeleportDialogQuery(CGameHandler * owner, const TeleportDialog &td);
 
-	void notifyObjectAboutRemoval(const CObjectVisitQuery &objectVisit) const override;
+	void notifyObjectAboutRemoval(const CGObjectInstance * visitedObject, const CGHeroInstance * visitingHero) const override;
 };
 
 class CHeroLevelUpDialogQuery : public CDialogQuery
@@ -114,7 +95,7 @@
 	CHeroLevelUpDialogQuery(CGameHandler * owner, const HeroLevelUp &Hlu, const CGHeroInstance * Hero);
 
 	void onRemoval(PlayerColor color) override;
-	void notifyObjectAboutRemoval(const CObjectVisitQuery &objectVisit) const override;
+	void notifyObjectAboutRemoval(const CGObjectInstance * visitedObject, const CGHeroInstance * visitingHero) const override;
 
 	HeroLevelUp hlu;
 	const CGHeroInstance * hero;
@@ -126,7 +107,7 @@
 	CCommanderLevelUpDialogQuery(CGameHandler * owner, const CommanderLevelUp &Clu, const CGHeroInstance * Hero);
 
 	void onRemoval(PlayerColor color) override;
-	void notifyObjectAboutRemoval(const CObjectVisitQuery &objectVisit) const override;
+	void notifyObjectAboutRemoval(const CGObjectInstance * visitedObject, const CGHeroInstance * visitingHero) const override;
 
 	CommanderLevelUp clu;
 	const CGHeroInstance * hero;
diff --color -urN vcmi-1.5.7/server/queries/VisitQueries.cpp vcmi/server/queries/VisitQueries.cpp
--- vcmi-1.5.7/server/queries/VisitQueries.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/server/queries/VisitQueries.cpp	2024-12-19 15:00:22.994151905 +0100
@@ -0,0 +1,87 @@
+/*
+ * VisitQueries.cpp, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#include "StdInc.h"
+#include "VisitQueries.h"
+
+#include "../../lib/mapObjects/CGHeroInstance.h"
+#include "../../lib/mapObjects/CGTownInstance.h"
+#include "../../lib/mapObjects/TownBuildingInstance.h"
+#include "../CGameHandler.h"
+#include "QueriesProcessor.h"
+
+VisitQuery::VisitQuery(CGameHandler * owner, const CGObjectInstance * Obj, const CGHeroInstance * Hero)
+	: CQuery(owner)
+	, visitedObject(Obj)
+	, visitingHero(Hero)
+{
+	addPlayer(Hero->tempOwner);
+}
+
+bool VisitQuery::blocksPack(const CPackForServer * pack) const
+{
+	//During the visit itself ALL actions are blocked.
+	//(However, the visit may trigger a query above that'll pass some.)
+	return true;
+}
+
+void MapObjectVisitQuery::onExposure(QueryPtr topQuery)
+{
+	//Object may have been removed and deleted.
+	if(gh->isValidObject(visitedObject))
+		topQuery->notifyObjectAboutRemoval(visitedObject, visitingHero);
+
+	owner->popIfTop(*this);
+}
+
+MapObjectVisitQuery::MapObjectVisitQuery(CGameHandler * owner, const CGObjectInstance * Obj, const CGHeroInstance * Hero)
+	: VisitQuery(owner, Obj, Hero)
+	, removeObjectAfterVisit(false)
+{
+}
+
+void MapObjectVisitQuery::onRemoval(PlayerColor color)
+{
+	gh->objectVisitEnded(visitingHero, players.front());
+
+	//Can object visit affect 2 players and what would be desired behavior?
+	if(removeObjectAfterVisit)
+		gh->removeObject(visitedObject, color);
+}
+
+TownBuildingVisitQuery::TownBuildingVisitQuery(CGameHandler * owner, const CGTownInstance * Obj, std::vector<const CGHeroInstance *> heroes, std::vector<BuildingID> buildingToVisit)
+	: VisitQuery(owner, Obj, heroes.front())
+	, visitedTown(Obj)
+{
+	// generate in reverse order - first building-hero pair to handle must be in the end of vector
+	for (auto const * hero : boost::adaptors::reverse(heroes))
+		for (auto const & building : boost::adaptors::reverse(buildingToVisit))
+			visitedBuilding.push_back({ hero, building});
+}
+
+void TownBuildingVisitQuery::onExposure(QueryPtr topQuery)
+{
+	topQuery->notifyObjectAboutRemoval(visitedObject, visitingHero);
+
+	onAdded(players.front());
+}
+
+void TownBuildingVisitQuery::onAdded(PlayerColor color)
+{
+	while (!visitedBuilding.empty() && owner->topQuery(color).get() == this)
+	{
+		visitingHero = visitedBuilding.back().hero;
+		const auto * building = visitedTown->rewardableBuildings.at(visitedBuilding.back().building);
+		building->onHeroVisit(visitingHero);
+		visitedBuilding.pop_back();
+	}
+
+	if (visitedBuilding.empty() && owner->topQuery(color).get() == this)
+		owner->popIfTop(*this);
+}
diff --color -urN vcmi-1.5.7/server/queries/VisitQueries.h vcmi/server/queries/VisitQueries.h
--- vcmi-1.5.7/server/queries/VisitQueries.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/server/queries/VisitQueries.h	2024-12-19 15:00:22.994151905 +0100
@@ -0,0 +1,59 @@
+/*
+ * VisitQueries.h, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#pragma once
+
+#include "CQuery.h"
+
+VCMI_LIB_NAMESPACE_BEGIN
+class CGTownInstance;
+VCMI_LIB_NAMESPACE_END
+
+//Created when hero visits object.
+//Removed when query above is resolved (or immediately after visit if no queries were created)
+class VisitQuery : public CQuery
+{
+protected:
+	VisitQuery(CGameHandler * owner, const CGObjectInstance * Obj, const CGHeroInstance * Hero);
+
+public:
+	const CGObjectInstance * visitedObject;
+	const CGHeroInstance * visitingHero;
+
+	bool blocksPack(const CPackForServer * pack) const final;
+};
+
+class MapObjectVisitQuery final : public VisitQuery
+{
+public:
+	bool removeObjectAfterVisit;
+
+	MapObjectVisitQuery(CGameHandler * owner, const CGObjectInstance * Obj, const CGHeroInstance * Hero);
+
+	void onRemoval(PlayerColor color) final;
+	void onExposure(QueryPtr topQuery) final;
+};
+
+class TownBuildingVisitQuery final : public VisitQuery
+{
+	struct BuildingVisit
+	{
+		const CGHeroInstance * hero;
+		BuildingID building;
+	};
+
+	const CGTownInstance * visitedTown;
+	std::vector<BuildingVisit> visitedBuilding;
+
+public:
+	TownBuildingVisitQuery(CGameHandler * owner, const CGTownInstance * Obj, std::vector<const CGHeroInstance *> heroes, std::vector<BuildingID> buildingToVisit);
+
+	void onAdded(PlayerColor color) final;
+	void onExposure(QueryPtr topQuery) final;
+};
diff --color -urN vcmi-1.5.7/server/ServerNetPackVisitors.h vcmi/server/ServerNetPackVisitors.h
--- vcmi-1.5.7/server/ServerNetPackVisitors.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/server/ServerNetPackVisitors.h	2024-12-19 15:00:22.990151740 +0100
@@ -41,6 +41,8 @@
 	void visitBulkSmartSplitStack(BulkSmartSplitStack & pack) override;
 	void visitDisbandCreature(DisbandCreature & pack) override;
 	void visitBuildStructure(BuildStructure & pack) override;
+	void visitSpellResearch(SpellResearch & pack) override;
+	void visitVisitTownBuilding(VisitTownBuilding & pack) override;
 	void visitRecruitCreatures(RecruitCreatures & pack) override;
 	void visitUpgradeCreature(UpgradeCreature & pack) override;
 	void visitGarrisonHeroSwap(GarrisonHeroSwap & pack) override;
@@ -60,4 +62,5 @@
 	void visitDigWithHero(DigWithHero & pack) override;
 	void visitCastAdvSpell(CastAdvSpell & pack) override;
 	void visitPlayerMessage(PlayerMessage & pack) override;
+	void visitSaveLocalState(SaveLocalState & pack) override;
 };
diff --color -urN vcmi-1.5.7/server/ServerSpellCastEnvironment.cpp vcmi/server/ServerSpellCastEnvironment.cpp
--- vcmi-1.5.7/server/ServerSpellCastEnvironment.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/server/ServerSpellCastEnvironment.cpp	2024-12-19 15:00:22.991151781 +0100
@@ -39,42 +39,42 @@
 	return &gh->getRandomGenerator();
 }
 
-void ServerSpellCastEnvironment::apply(CPackForClient * pack)
+void ServerSpellCastEnvironment::apply(CPackForClient & pack)
 {
 	gh->sendAndApply(pack);
 }
 
-void ServerSpellCastEnvironment::apply(BattleLogMessage * pack)
+void ServerSpellCastEnvironment::apply(BattleLogMessage & pack)
 {
 	gh->sendAndApply(pack);
 }
 
-void ServerSpellCastEnvironment::apply(BattleStackMoved * pack)
+void ServerSpellCastEnvironment::apply(BattleStackMoved & pack)
 {
 	gh->sendAndApply(pack);
 }
 
-void ServerSpellCastEnvironment::apply(BattleUnitsChanged * pack)
+void ServerSpellCastEnvironment::apply(BattleUnitsChanged & pack)
 {
 	gh->sendAndApply(pack);
 }
 
-void ServerSpellCastEnvironment::apply(SetStackEffect * pack)
+void ServerSpellCastEnvironment::apply(SetStackEffect & pack)
 {
 	gh->sendAndApply(pack);
 }
 
-void ServerSpellCastEnvironment::apply(StacksInjured * pack)
+void ServerSpellCastEnvironment::apply(StacksInjured & pack)
 {
 	gh->sendAndApply(pack);
 }
 
-void ServerSpellCastEnvironment::apply(BattleObstaclesChanged * pack)
+void ServerSpellCastEnvironment::apply(BattleObstaclesChanged & pack)
 {
 	gh->sendAndApply(pack);
 }
 
-void ServerSpellCastEnvironment::apply(CatapultAttack * pack)
+void ServerSpellCastEnvironment::apply(CatapultAttack & pack)
 {
 	gh->sendAndApply(pack);
 }
@@ -94,10 +94,15 @@
 	return gh->moveHero(hid, dst, mode, false);
 }
 
+void ServerSpellCastEnvironment::createBoat(const int3 & visitablePosition, BoatId type, PlayerColor initiator)
+{
+	return gh->createBoat(visitablePosition, type, initiator);
+}
+
 void ServerSpellCastEnvironment::genericQuery(Query * request, PlayerColor color, std::function<void(std::optional<int32_t>)> callback)
 {
 	auto query = std::make_shared<CGenericQuery>(gh, color, callback);
 	request->queryID = query->queryID;
 	gh->queries->addQuery(query);
-	gh->sendAndApply(request);
+	gh->sendAndApply(*request);
 }
diff --color -urN vcmi-1.5.7/server/ServerSpellCastEnvironment.h vcmi/server/ServerSpellCastEnvironment.h
--- vcmi-1.5.7/server/ServerSpellCastEnvironment.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/server/ServerSpellCastEnvironment.h	2024-12-19 15:00:22.991151781 +0100
@@ -24,19 +24,20 @@
 
 	vstd::RNG * getRNG() override;
 
-	void apply(CPackForClient * pack) override;
+	void apply(CPackForClient & pack) override;
 
-	void apply(BattleLogMessage * pack) override;
-	void apply(BattleStackMoved * pack) override;
-	void apply(BattleUnitsChanged * pack) override;
-	void apply(SetStackEffect * pack) override;
-	void apply(StacksInjured * pack) override;
-	void apply(BattleObstaclesChanged * pack) override;
-	void apply(CatapultAttack * pack) override;
+	void apply(BattleLogMessage & pack) override;
+	void apply(BattleStackMoved & pack) override;
+	void apply(BattleUnitsChanged & pack) override;
+	void apply(SetStackEffect & pack) override;
+	void apply(StacksInjured & pack) override;
+	void apply(BattleObstaclesChanged & pack) override;
+	void apply(CatapultAttack & pack) override;
 
 	const CMap * getMap() const override;
 	const CGameInfoCallback * getCb() const override;
 	bool moveHero(ObjectInstanceID hid, int3 dst, EMovementMode mode) override;
+	void createBoat(const int3 & visitablePosition, BoatId type, PlayerColor initiator) override;
 	void genericQuery(Query * request, PlayerColor color, std::function<void(std::optional<int32_t>)> callback) override;
 private:
 	CGameHandler * gh;
diff --color -urN vcmi-1.5.7/server/TurnTimerHandler.cpp vcmi/server/TurnTimerHandler.cpp
--- vcmi-1.5.7/server/TurnTimerHandler.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/server/TurnTimerHandler.cpp	2024-12-19 15:00:22.991151781 +0100
@@ -60,7 +60,7 @@
 	TurnTimeUpdate ttu;
 	ttu.player = player;
 	ttu.turnTimer = timers[player];
-	gameHandler.sendAndApply(&ttu);
+	gameHandler.sendAndApply(ttu);
 	lastUpdate[player] = 0;
 }
 
@@ -256,7 +256,7 @@
 	if (!si->turnTimerInfo.isBattleEnabled())
 		return;
 
-	ui8 side = 0;
+	BattleSide side = BattleSide::NONE;
 	const CStack * stack = nullptr;
 	bool isTactisPhase = gs->getBattle(battleID)->battleTacticDist() > 0;
 	
diff --color -urN vcmi-1.5.7/server/VCMI_server.cbp vcmi/server/VCMI_server.cbp
--- vcmi-1.5.7/server/VCMI_server.cbp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/server/VCMI_server.cbp	1970-01-01 01:00:00.000000000 +0100
@@ -1,131 +0,0 @@
-<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
-<CodeBlocks_project_file>
-	<FileVersion major="1" minor="6" />
-	<Project>
-		<Option title="VCMI_server" />
-		<Option pch_mode="2" />
-		<Option compiler="gcc" />
-		<Build>
-			<Target title="Debug-win32">
-				<Option platforms="Windows;" />
-				<Option output="../VCMI_server" prefix_auto="1" extension_auto="1" />
-				<Option working_dir="../" />
-				<Option object_output="../obj/Server/Debug/x86" />
-				<Option type="1" />
-				<Option compiler="gcc" />
-				<Option use_console_runner="0" />
-				<Compiler>
-					<Add option="-Og" />
-					<Add option="-g" />
-				</Compiler>
-				<Linker>
-					<Add option="-lboost_program_options$(#boost.libsuffix32)" />
-					<Add option="-lboost_filesystem$(#boost.libsuffix32)" />
-					<Add option="-lboost_system$(#boost.libsuffix32)" />
-					<Add option="-lboost_thread$(#boost.libsuffix32)" />
-					<Add option="-lboost_chrono$(#boost.libsuffix32)" />
-					<Add option="-lVCMI_lib" />
-					<Add directory="$(#boost.lib32)" />
-				</Linker>
-			</Target>
-			<Target title="Release-win32">
-				<Option platforms="Windows;" />
-				<Option output="../VCMI_server" prefix_auto="1" extension_auto="1" />
-				<Option working_dir="../" />
-				<Option object_output="../obj/Server/Release/x86" />
-				<Option type="1" />
-				<Option compiler="gcc" />
-				<Option use_console_runner="0" />
-				<Compiler>
-					<Add option="-fomit-frame-pointer" />
-					<Add option="-O2" />
-				</Compiler>
-				<Linker>
-					<Add option="-s" />
-					<Add option="-lboost_program_options$(#boost.libsuffix32)" />
-					<Add option="-lboost_filesystem$(#boost.libsuffix32)" />
-					<Add option="-lboost_system$(#boost.libsuffix32)" />
-					<Add option="-lboost_thread$(#boost.libsuffix32)" />
-					<Add option="-lboost_chrono$(#boost.libsuffix32)" />
-					<Add option="-lVCMI_lib" />
-					<Add directory="$(#boost.lib32)" />
-				</Linker>
-			</Target>
-			<Target title="Debug-win64">
-				<Option platforms="Windows;" />
-				<Option output="../VCMI_server" prefix_auto="1" extension_auto="1" />
-				<Option working_dir="../" />
-				<Option object_output="../obj/Server/Debug/x86" />
-				<Option type="1" />
-				<Option compiler="gnu_gcc_compiler_x64" />
-				<Option use_console_runner="0" />
-				<Compiler>
-					<Add option="-Og" />
-					<Add option="-ggdb" />
-					<Add directory="$(#zlib64.include)" />
-				</Compiler>
-				<Linker>
-					<Add option="-lboost_program_options$(#boost.libsuffix64)" />
-					<Add option="-lboost_filesystem$(#boost.libsuffix64)" />
-					<Add option="-lboost_system$(#boost.libsuffix64)" />
-					<Add option="-lboost_thread$(#boost.libsuffix64)" />
-					<Add option="-lboost_chrono$(#boost.libsuffix64)" />
-					<Add option="-lVCMI_lib" />
-					<Add directory="$(#boost.lib64)" />
-				</Linker>
-			</Target>
-		</Build>
-		<Compiler>
-			<Add option="-Wextra" />
-			<Add option="-Wall" />
-			<Add option="-std=gnu++11" />
-			<Add option="-fexceptions" />
-			<Add option="-Wpointer-arith" />
-			<Add option="-Wno-switch" />
-			<Add option="-Wno-sign-compare" />
-			<Add option="-Wno-unused-parameter" />
-			<Add option="-Wno-overloaded-virtual" />
-			<Add option="-isystem $(#boost.include)" />
-			<Add option="-D_WIN32_WINNT=0x0600" />
-			<Add option="-DBOOST_ALL_DYN_LINK" />
-			<Add option="-DBOOST_SYSTEM_NO_DEPRECATED" />
-			<Add option="-D_WIN32" />
-			<Add option="-DBOOST_UUID_RANDOM_PROVIDER_FORCE_WINCRYPT" />
-			<Add directory="$(#sdl2.include)" />
-			<Add directory="$(#zlib.include)" />
-			<Add directory="../include" />
-		</Compiler>
-		<Linker>
-			<Add option="-lole32" />
-			<Add option="-loleaut32" />
-			<Add option="-lws2_32" />
-			<Add option="-ladvapi32" />
-			<Add option="-lmswsock" />
-			<Add directory="../" />
-		</Linker>
-		<Unit filename="CGameHandler.cpp" />
-		<Unit filename="CGameHandler.h" />
-		<Unit filename="CQuery.cpp" />
-		<Unit filename="CQuery.h" />
-		<Unit filename="CVCMIServer.cpp" />
-		<Unit filename="CVCMIServer.h" />
-		<Unit filename="NetPacksLobbyServer.cpp" />
-		<Unit filename="NetPacksServer.cpp" />
-		<Unit filename="StdInc.h">
-			<Option compile="1" />
-			<Option weight="0" />
-		</Unit>
-		<Extensions>
-			<DoxyBlocks>
-				<comment_style block="0" line="0" />
-				<doxyfile_project />
-				<doxyfile_build />
-				<doxyfile_warnings />
-				<doxyfile_output />
-				<doxyfile_dot />
-				<general />
-			</DoxyBlocks>
-			<lib_finder disable_auto="1" />
-		</Extensions>
-	</Project>
-</CodeBlocks_project_file>
diff --color -urN vcmi-1.5.7/server/VCMI_server.vcxproj vcmi/server/VCMI_server.vcxproj
--- vcmi-1.5.7/server/VCMI_server.vcxproj	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/server/VCMI_server.vcxproj	1970-01-01 01:00:00.000000000 +0100
@@ -1,180 +0,0 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
-<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <ItemGroup Label="ProjectConfigurations">
-    <ProjectConfiguration Include="Debug|Win32">
-      <Configuration>Debug</Configuration>
-      <Platform>Win32</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Debug|x64">
-      <Configuration>Debug</Configuration>
-      <Platform>x64</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="RD|Win32">
-      <Configuration>RD</Configuration>
-      <Platform>Win32</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="RD|x64">
-      <Configuration>RD</Configuration>
-      <Platform>x64</Platform>
-    </ProjectConfiguration>
-  </ItemGroup>
-  <PropertyGroup Label="Globals">
-    <ProjectGuid>{8AF697C3-465E-4910-B31B-576A9ECDB309}</ProjectGuid>
-    <RootNamespace>VCMI_server</RootNamespace>
-    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
-  </PropertyGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='RD|Win32'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <CharacterSet>MultiByte</CharacterSet>
-    <WholeProgramOptimization>true</WholeProgramOptimization>
-    <PlatformToolset>v142</PlatformToolset>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='RD|x64'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <CharacterSet>MultiByte</CharacterSet>
-    <WholeProgramOptimization>true</WholeProgramOptimization>
-    <PlatformToolset>v140_xp</PlatformToolset>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <CharacterSet>Unicode</CharacterSet>
-    <PlatformToolset>v140_xp</PlatformToolset>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <CharacterSet>Unicode</CharacterSet>
-    <PlatformToolset>v140_xp</PlatformToolset>
-  </PropertyGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
-  <ImportGroup Label="ExtensionSettings">
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='RD|Win32'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-    <Import Project="..\VCMI_global_release.props" />
-    <Import Project="..\VCMI_global.props" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='RD|x64'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-    <Import Project="..\VCMI_global_release.props" />
-    <Import Project="..\VCMI_global.props" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-    <Import Project="..\VCMI_global_debug.props" />
-    <Import Project="..\VCMI_global.props" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-    <Import Project="..\VCMI_global_debug.props" />
-    <Import Project="..\VCMI_global.props" />
-  </ImportGroup>
-  <PropertyGroup Label="UserMacros" />
-  <PropertyGroup>
-    <_ProjectFileVersion>10.0.30128.1</_ProjectFileVersion>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..</OutDir>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(VCMI_Out)</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(Configuration)\</IntDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(Configuration)\</IntDir>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='RD|Win32'">$(VCMI_Out)</OutDir>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='RD|x64'">$(VCMI_Out)</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='RD|Win32'">$(Configuration)\</IntDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='RD|x64'">$(Configuration)\</IntDir>
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='RD|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='RD|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='RD|Win32'" />
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='RD|x64'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='RD|Win32'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='RD|x64'" />
-  </PropertyGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
-    <ClCompile>
-      <AdditionalOptions>/MP4 %(AdditionalOptions)/Zm200</AdditionalOptions>
-      <Optimization>Disabled</Optimization>
-      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <MinimalRebuild>false</MinimalRebuild>
-      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
-      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
-      <WarningLevel>Level3</WarningLevel>
-      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>
-      <DisableSpecificWarnings>4251;%(DisableSpecificWarnings)</DisableSpecificWarnings>
-      <PrecompiledHeader>Use</PrecompiledHeader>
-      <PrecompiledHeaderFile>StdInc.h</PrecompiledHeaderFile>
-    </ClCompile>
-    <Link>
-      <AdditionalDependencies>VCMI_lib.lib;zlib.lib;%(AdditionalDependencies)</AdditionalDependencies>
-      <AdditionalLibraryDirectories>..\..\libs;</AdditionalLibraryDirectories>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
-    <ClCompile>
-      <AdditionalOptions>/MP4 %(AdditionalOptions)/Zm200</AdditionalOptions>
-      <DisableSpecificWarnings>4251;%(DisableSpecificWarnings)</DisableSpecificWarnings>
-      <PrecompiledHeader>Use</PrecompiledHeader>
-      <PrecompiledHeaderFile>StdInc.h</PrecompiledHeaderFile>
-    </ClCompile>
-    <Link>
-      <AdditionalDependencies>VCMI_lib.lib;zlib.lib;%(AdditionalDependencies)</AdditionalDependencies>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='RD|Win32'">
-    <ClCompile>
-      <AdditionalOptions>/Oy- %(AdditionalOptions)</AdditionalOptions>
-      <DisableSpecificWarnings>4251;%(DisableSpecificWarnings)</DisableSpecificWarnings>
-      <PrecompiledHeader>Use</PrecompiledHeader>
-      <PrecompiledHeaderFile>StdInc.h</PrecompiledHeaderFile>
-      <MultiProcessorCompilation>true</MultiProcessorCompilation>
-    </ClCompile>
-    <Link>
-      <AdditionalDependencies>VCMI_lib.lib;zlib.lib;%(AdditionalDependencies)</AdditionalDependencies>
-      <AdditionalLibraryDirectories>$(VCMI_Out)</AdditionalLibraryDirectories>
-      <AdditionalOptions>/d2:-notypeopt %(AdditionalOptions)</AdditionalOptions>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='RD|x64'">
-    <ClCompile>
-      <AdditionalOptions>/Oy- %(AdditionalOptions)/Zm200</AdditionalOptions>
-      <DisableSpecificWarnings>4251;%(DisableSpecificWarnings)</DisableSpecificWarnings>
-      <PrecompiledHeader>Use</PrecompiledHeader>
-      <PrecompiledHeaderFile>StdInc.h</PrecompiledHeaderFile>
-    </ClCompile>
-    <Link>
-      <AdditionalDependencies>VCMI_lib.lib;zlib.lib;%(AdditionalDependencies)</AdditionalDependencies>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemGroup>
-    <ClCompile Include="CGameHandler.cpp" />
-    <ClCompile Include="CQuery.cpp" />
-    <ClCompile Include="CVCMIServer.cpp" />
-    <ClCompile Include="NetPacksLobbyServer.cpp" />
-    <ClCompile Include="NetPacksServer.cpp" />
-    <ClCompile Include="StdInc.cpp">
-      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
-      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StdInc.h</PrecompiledHeaderFile>
-      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='RD|Win32'">Create</PrecompiledHeader>
-      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
-      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='RD|x64'">Create</PrecompiledHeader>
-    </ClCompile>
-  </ItemGroup>
-  <ItemGroup>
-    <ClInclude Include="..\Global.h" />
-    <ClInclude Include="CGameHandler.h" />
-    <ClInclude Include="CQuery.h" />
-    <ClInclude Include="CVCMIServer.h" />
-    <ClInclude Include="StdInc.h" />
-  </ItemGroup>
-  <ItemGroup>
-    <ProjectReference Include="..\lib\VCMI_lib.vcxproj">
-      <Project>{b952ffc5-3039-4de1-9f08-90acda483d8f}</Project>
-    </ProjectReference>
-  </ItemGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
-  <ImportGroup Label="ExtensionTargets">
-  </ImportGroup>
-</Project>
\ No newline at end of file
