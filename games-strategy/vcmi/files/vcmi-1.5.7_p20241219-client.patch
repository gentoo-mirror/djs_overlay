diff --color -urN vcmi-1.5.7/client/adventureMap/AdventureMapInterface.cpp vcmi/client/adventureMap/AdventureMapInterface.cpp
--- vcmi-1.5.7/client/adventureMap/AdventureMapInterface.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/adventureMap/AdventureMapInterface.cpp	2024-12-19 15:00:22.241120786 +0100
@@ -31,15 +31,18 @@
 #include "../gui/Shortcut.h"
 #include "../gui/WindowHandler.h"
 #include "../render/Canvas.h"
+#include "../render/IImage.h"
 #include "../render/IRenderHandler.h"
+#include "../render/IScreenHandler.h"
+#include "../render/AssetGenerator.h"
 #include "../CMT.h"
 #include "../PlayerLocalState.h"
 #include "../CPlayerInterface.h"
 
 #include "../../CCallback.h"
-#include "../../lib/GameSettings.h"
+#include "../../lib/IGameSettings.h"
 #include "../../lib/StartInfo.h"
-#include "../../lib/CGeneralTextHandler.h"
+#include "../../lib/texts/CGeneralTextHandler.h"
 #include "../../lib/spells/CSpellHandler.h"
 #include "../../lib/mapObjects/CGHeroInstance.h"
 #include "../../lib/mapObjects/CGTownInstance.h"
@@ -57,11 +60,13 @@
 	scrollingWasBlocked(false),
 	backgroundDimLevel(settings["adventure"]["backgroundDimLevel"].Integer())
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 	pos.x = pos.y = 0;
 	pos.w = GH.screenDimensions().x;
 	pos.h = GH.screenDimensions().y;
 
+	AssetGenerator::createPaletteShiftedSprites();
+
 	shortcuts = std::make_shared<AdventureMapShortcuts>(*this);
 
 	widget = std::make_shared<AdventureMapWidget>(shortcuts);
@@ -178,7 +183,7 @@
 		{
 			if(!std::dynamic_pointer_cast<AdventureMapInterface>(window) && std::dynamic_pointer_cast<CIntObject>(window) && isBigWindow(window))
 			{
-				to.fillTexture(GH.renderHandler().loadImage(ImagePath::builtin("DiBoxBck")));
+				to.fillTexture(GH.renderHandler().loadImage(ImagePath::builtin("DiBoxBck"), EImageBlitMode::OPAQUE));
 				return;
 			}
 		}
@@ -231,7 +236,7 @@
 
 	bool cursorInScrollArea = scrollDelta != Point(0,0);
 	bool scrollingActive = cursorInScrollArea && shortcuts->optionMapScrollingActive() && !scrollingWasBlocked;
-	bool scrollingBlocked = GH.isKeyboardCtrlDown() || !settings["adventure"]["borderScroll"].Bool();
+	bool scrollingBlocked = GH.isKeyboardCtrlDown() || !settings["adventure"]["borderScroll"].Bool() || !GH.screenHandler().hasFocus();
 
 	if (!scrollingWasActive && scrollingBlocked)
 	{
@@ -399,7 +404,7 @@
 		return;
 
 	currentPlayerID = playerID;
-	widget->setPlayer(playerID);
+	widget->setPlayerColor(playerID);
 }
 
 void AdventureMapInterface::onPlayerTurnStarted(PlayerColor playerID)
@@ -451,7 +456,7 @@
 		widget->getInfoBar()->showDate();
 
 	onHeroChanged(nullptr);
-	Canvas canvas = Canvas::createFromSurface(screen);
+	Canvas canvas = Canvas::createFromSurface(screen, CanvasScalingPolicy::AUTO);
 	showAll(canvas);
 	mapAudio->onPlayerTurnStarted();
 
@@ -555,7 +560,8 @@
 		else //still here? we need to move hero if we clicked end of already selected path or calculate a new path otherwise
 		{
 			if(LOCPLINT->localState->hasPath(currentHero) &&
-			   LOCPLINT->localState->getPath(currentHero).endPos() == targetPosition)//we'll be moving
+			   LOCPLINT->localState->getPath(currentHero).endPos() == targetPosition &&
+			   !GH.isKeyboardShiftDown())//we'll be moving
 			{
 				assert(!CGI->mh->hasOngoingAnimations());
 				if(!CGI->mh->hasOngoingAnimations() && LOCPLINT->localState->getPath(currentHero).nextNode().turns == 0)
@@ -615,7 +621,7 @@
 		case SpellID::DIMENSION_DOOR:
 			if(isValidAdventureSpellTarget(targetPosition))
 			{
-				if(VLC->settings()->getBoolean(EGameSettings::DIMENSION_DOOR_TRIGGERS_GUARDS) && LOCPLINT->cb->isTileGuardedUnchecked(targetPosition))
+				if(LOCPLINT->cb->getSettings().getBoolean(EGameSettings::DIMENSION_DOOR_TRIGGERS_GUARDS) && LOCPLINT->cb->isTileGuardedUnchecked(targetPosition))
 					CCS->curh->set(Cursor::Map::T1_ATTACK);
 				else
 					CCS->curh->set(Cursor::Map::TELEPORT);
@@ -897,7 +903,7 @@
 
 void AdventureMapInterface::onScreenResize()
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 
 	// remember our activation state and reactive after reconstruction
 	// since othervice activate() calls for created elements will bypass virtual dispatch
@@ -914,7 +920,7 @@
 
 	widget = std::make_shared<AdventureMapWidget>(shortcuts);
 	widget->getMapView()->onViewMapActivated();
-	widget->setPlayer(currentPlayerID);
+	widget->setPlayerColor(currentPlayerID);
 	widget->updateActiveState();
 	widget->getMinimap()->update();
 	widget->getInfoBar()->showSelection();
diff --color -urN vcmi-1.5.7/client/adventureMap/AdventureMapInterface.h vcmi/client/adventureMap/AdventureMapInterface.h
--- vcmi-1.5.7/client/adventureMap/AdventureMapInterface.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/adventureMap/AdventureMapInterface.h	2024-12-19 15:00:22.241120786 +0100
@@ -31,7 +31,6 @@
 class CGStatusBar;
 class AdventureMapWidget;
 class AdventureMapShortcuts;
-class CAnimation;
 class MapView;
 class CResDataBar;
 class CHeroList;
diff --color -urN vcmi-1.5.7/client/adventureMap/AdventureMapShortcuts.cpp vcmi/client/adventureMap/AdventureMapShortcuts.cpp
--- vcmi-1.5.7/client/adventureMap/AdventureMapShortcuts.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/adventureMap/AdventureMapShortcuts.cpp	2024-12-19 15:00:22.241120786 +0100
@@ -24,6 +24,7 @@
 #include "../windows/CKingdomInterface.h"
 #include "../windows/CSpellWindow.h"
 #include "../windows/CMarketWindow.h"
+#include "../windows/GUIClasses.h"
 #include "../windows/settings/SettingsMainWindow.h"
 #include "AdventureMapInterface.h"
 #include "AdventureOptions.h"
@@ -31,16 +32,19 @@
 
 #include "../../CCallback.h"
 #include "../../lib/CConfigHandler.h"
-#include "../../lib/CGeneralTextHandler.h"
+#include "../../lib/texts/CGeneralTextHandler.h"
 #include "../../lib/mapObjects/CGHeroInstance.h"
 #include "../../lib/mapObjects/CGTownInstance.h"
 #include "../../lib/mapping/CMap.h"
 #include "../../lib/pathfinder/CGPathNode.h"
+#include "../../lib/mapObjectConstructors/CObjectClassesHandler.h"
 
 AdventureMapShortcuts::AdventureMapShortcuts(AdventureMapInterface & owner)
 	: owner(owner)
 	, state(EAdventureState::NOT_INITIALIZED)
 	, mapLevel(0)
+	, searchLast("")
+	, searchPos(0)
 {}
 
 void AdventureMapShortcuts::setState(EAdventureState newState)
@@ -48,7 +52,7 @@
 	state = newState;
 }
 
-EAdventureState AdventureMapShortcuts::getState()
+EAdventureState AdventureMapShortcuts::getState() const
 {
 	return state;
 }
@@ -71,6 +75,8 @@
 		{ EShortcut::ADVENTURE_QUEST_LOG,        optionCanViewQuests(),  [this]() { this->showQuestlog(); } },
 		{ EShortcut::ADVENTURE_TOGGLE_SLEEP,     optionHeroSelected(),   [this]() { this->toggleSleepWake(); } },
 		{ EShortcut::ADVENTURE_TOGGLE_GRID,      optionInMapView(),      [this]() { this->toggleGrid(); } },
+		{ EShortcut::ADVENTURE_TOGGLE_VISITABLE, optionInMapView(),      [this]() { this->toggleVisitable(); } },
+		{ EShortcut::ADVENTURE_TOGGLE_BLOCKED,   optionInMapView(),      [this]() { this->toggleBlocked(); } },
 		{ EShortcut::ADVENTURE_TRACK_HERO,       optionInMapView(),      [this]() { this->toggleTrackHero(); } },
 		{ EShortcut::ADVENTURE_SET_HERO_ASLEEP,  optionHeroAwake(),      [this]() { this->setHeroSleeping(); } },
 		{ EShortcut::ADVENTURE_SET_HERO_AWAKE,   optionHeroSleeping(),   [this]() { this->setHeroAwake(); } },
@@ -107,7 +113,9 @@
 		{ EShortcut::ADVENTURE_MOVE_HERO_EE,     optionHeroSelected(),   [this]() { this->moveHeroDirectional({+1,  0}); } },
 		{ EShortcut::ADVENTURE_MOVE_HERO_NW,     optionHeroSelected(),   [this]() { this->moveHeroDirectional({-1, -1}); } },
 		{ EShortcut::ADVENTURE_MOVE_HERO_NN,     optionHeroSelected(),   [this]() { this->moveHeroDirectional({ 0, -1}); } },
-		{ EShortcut::ADVENTURE_MOVE_HERO_NE,     optionHeroSelected(),   [this]() { this->moveHeroDirectional({+1, -1}); } }
+		{ EShortcut::ADVENTURE_MOVE_HERO_NE,     optionHeroSelected(),   [this]() { this->moveHeroDirectional({+1, -1}); } },
+		{ EShortcut::ADVENTURE_SEARCH,           optionSidePanelActive(),[this]() { this->search(false); } },
+		{ EShortcut::ADVENTURE_SEARCH_CONTINUE,  optionSidePanelActive(),[this]() { this->search(true); } }
 	};
 	return result;
 }
@@ -168,6 +176,18 @@
 	s["showGrid"].Bool() = !settings["gameTweaks"]["showGrid"].Bool();
 }
 
+void AdventureMapShortcuts::toggleVisitable()
+{
+	Settings s = settings.write["session"];
+	s["showVisitable"].Bool() = !settings["session"]["showVisitable"].Bool();
+}
+
+void AdventureMapShortcuts::toggleBlocked()
+{
+	Settings s = settings.write["session"];
+	s["showBlocked"].Bool() = !settings["session"]["showBlocked"].Bool();
+}
+
 void AdventureMapShortcuts::toggleSleepWake()
 {
 	if (!optionHeroSelected())
@@ -311,7 +331,6 @@
 		[]()
 		{
 			CSH->endGameplay();
-			GH.defActionsDef = 63;
 			CMM->menu->switchToTab("main");
 		},
 		0
@@ -325,7 +344,6 @@
 		[]()
 		{
 			CSH->endGameplay();
-			GH.defActionsDef = 63;
 			CMM->menu->switchToTab("new");
 		},
 		nullptr
@@ -445,6 +463,62 @@
 	owner.hotkeyZoom(distance, false);
 }
 
+void AdventureMapShortcuts::search(bool next)
+{
+	// get all relevant objects
+	std::vector<ObjectInstanceID> visitableObjInstances;
+	for(auto & obj : LOCPLINT->cb->getAllVisitableObjs())
+		if(obj->ID != MapObjectID::MONSTER && obj->ID != MapObjectID::HERO && obj->ID != MapObjectID::TOWN)
+			visitableObjInstances.push_back(obj->id);
+
+	// count of elements for each group (map is already sorted)
+	std::map<std::string, int> mapObjCount;
+	for(auto & obj : visitableObjInstances)
+		mapObjCount[{ LOCPLINT->cb->getObjInstance(obj)->getObjectName() }]++;
+
+	// convert to vector for indexed access
+	std::vector<std::pair<std::string, int>> textCountList;
+	for (auto itr = mapObjCount.begin(); itr != mapObjCount.end(); ++itr)
+		textCountList.push_back(*itr);
+
+	// get pos of last selection
+	int lastSel = 0;
+	for(int i = 0; i < textCountList.size(); i++)
+		if(textCountList[i].first == searchLast)
+			lastSel = i;
+
+	// create texts
+	std::vector<std::string> texts;
+	for(auto & obj : textCountList)
+		texts.push_back(obj.first + " (" + std::to_string(obj.second) + ")");
+
+	// function to center element from list on map
+	auto selectObjOnMap = [this, textCountList, visitableObjInstances](int index)
+		{
+			auto selObj = textCountList[index].first;
+
+			// filter for matching objects
+			std::vector<ObjectInstanceID> selVisitableObjInstances;
+			for(auto & obj : visitableObjInstances)
+				if(selObj == LOCPLINT->cb->getObjInstance(obj)->getObjectName())
+					selVisitableObjInstances.push_back(obj);
+			
+			if(searchPos + 1 < selVisitableObjInstances.size() && searchLast == selObj)
+				searchPos++;
+			else
+				searchPos = 0;
+
+			auto objInst = LOCPLINT->cb->getObjInstance(selVisitableObjInstances[searchPos]);
+			owner.centerOnObject(objInst);
+			searchLast = objInst->getObjectName();
+		};
+
+	if(next)
+		selectObjOnMap(lastSel);
+	else
+		GH.windows().createAndPushWindow<CObjectListWindow>(texts, nullptr, CGI->generaltexth->translate("vcmi.adventureMap.search.hover"), CGI->generaltexth->translate("vcmi.adventureMap.search.help"), [selectObjOnMap](int index){ selectObjOnMap(index); }, lastSel, std::vector<std::shared_ptr<IImage>>(), true);
+}
+
 void AdventureMapShortcuts::nextObject()
 {
 	const CGHeroInstance *h = LOCPLINT->localState->getCurrentHero();
@@ -518,7 +592,6 @@
 	auto * hero = LOCPLINT->localState->getCurrentHero();
 	auto objects = LOCPLINT->cb->getVisitableObjs(hero->visitablePos());
 
-	//assert(vstd::contains(objects,hero));
 	return objects.size() > 1; // there is object other than our hero
 }
 
diff --color -urN vcmi-1.5.7/client/adventureMap/AdventureMapShortcuts.h vcmi/client/adventureMap/AdventureMapShortcuts.h
--- vcmi-1.5.7/client/adventureMap/AdventureMapShortcuts.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/adventureMap/AdventureMapShortcuts.h	2024-12-19 15:00:22.241120786 +0100
@@ -33,6 +33,9 @@
 	EAdventureState state;
 	int mapLevel;
 
+	std::string searchLast;
+	int searchPos;
+	
 	void showOverview();
 	void worldViewBack();
 	void worldViewScale1x();
@@ -42,6 +45,8 @@
 	void showQuestlog();
 	void toggleTrackHero();
 	void toggleGrid();
+	void toggleVisitable();
+	void toggleBlocked();
 	void toggleSleepWake();
 	void setHeroSleeping();
 	void setHeroAwake();
@@ -69,6 +74,7 @@
 	void nextTown();
 	void nextObject();
 	void zoom( int distance);
+	void search(bool next);
 	void moveHeroDirectional(const Point & direction);
 
 public:
@@ -94,6 +100,6 @@
 	bool optionMapViewActive();
 
 	void setState(EAdventureState newState);
-	EAdventureState getState();
+	EAdventureState getState() const;
 	void onMapViewMoved(const Rect & visibleArea, int mapLevel);
 };
diff --color -urN vcmi-1.5.7/client/adventureMap/AdventureMapWidget.cpp vcmi/client/adventureMap/AdventureMapWidget.cpp
--- vcmi-1.5.7/client/adventureMap/AdventureMapWidget.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/adventureMap/AdventureMapWidget.cpp	2024-12-19 15:00:22.242120828 +0100
@@ -20,7 +20,6 @@
 #include "../gui/CGuiHandler.h"
 #include "../gui/Shortcut.h"
 #include "../mapView/MapView.h"
-#include "../render/CAnimation.h"
 #include "../render/IImage.h"
 #include "../render/IRenderHandler.h"
 #include "../widgets/Buttons.h"
@@ -60,7 +59,7 @@
 	const JsonNode config(JsonPath::builtin("config/widgets/adventureMap.json"));
 
 	for(const auto & entry : config["options"]["imagesPlayerColored"].Vector())
-		playerColorerImages.push_back(ImagePath::fromJson(entry));
+		playerColoredImages.push_back(ImagePath::fromJson(entry));
 
 	build(config);
 	addUsedEvents(KEYBOARD);
@@ -125,26 +124,6 @@
 	return Rect(topLeft + boundingBox.topLeft(), dimensions);
 }
 
-std::shared_ptr<IImage> AdventureMapWidget::loadImage(const JsonNode & name)
-{
-	ImagePath resource = ImagePath::fromJson(name);
-
-	if(images.count(resource) == 0)
-		images[resource] = GH.renderHandler().loadImage(resource);
-
-	return images[resource];
-}
-
-std::shared_ptr<CAnimation> AdventureMapWidget::loadAnimation(const JsonNode & name)
-{
-	AnimationPath resource = AnimationPath::fromJson(name);
-
-	if(animations.count(resource) == 0)
-		animations[resource] = GH.renderHandler().loadAnimation(resource);
-
-	return animations[resource];
-}
-
 std::shared_ptr<CIntObject> AdventureMapWidget::buildInfobox(const JsonNode & input)
 {
 	Rect area = readTargetArea(input["area"]);
@@ -156,8 +135,12 @@
 {
 	Rect targetArea = readTargetArea(input["area"]);
 	Rect sourceArea = readSourceArea(input["sourceArea"], input["area"]);
+	ImagePath path = ImagePath::fromJson(input["image"]);
 
-	return std::make_shared<CFilledTexture>(loadImage(input["image"]), targetArea, sourceArea);
+	if (vstd::contains(playerColoredImages, path))
+		return std::make_shared<FilledTexturePlayerIndexed>(path, targetArea, sourceArea);
+	else
+		return std::make_shared<CFilledTexture>(path, targetArea, sourceArea);
 }
 
 std::shared_ptr<CIntObject> AdventureMapWidget::buildMapButton(const JsonNode & input)
@@ -257,7 +240,7 @@
 	size_t index = input["index"].Integer();
 	size_t perPlayer = input["perPlayer"].Integer();
 
-	return std::make_shared<CAdventureMapIcon>(area.topLeft(), loadAnimation(input["image"]), index, perPlayer);
+	return std::make_shared<CAdventureMapIcon>(area.topLeft(), AnimationPath::fromJson(input["image"]), index, perPlayer);
 }
 
 std::shared_ptr<CIntObject> AdventureMapWidget::buildMapTownList(const JsonNode & input)
@@ -326,9 +309,8 @@
 std::shared_ptr<CIntObject> AdventureMapWidget::buildTexturePlayerColored(const JsonNode & input)
 {
 	logGlobal->debug("Building widget CFilledTexture");
-	auto image = ImagePath::fromJson(input["image"]);
 	Rect area = readTargetArea(input["area"]);
-	return std::make_shared<FilledTexturePlayerColored>(image, area);
+	return std::make_shared<FilledTexturePlayerColored>(area);
 }
 
 std::shared_ptr<CHeroList> AdventureMapWidget::getHeroList()
@@ -356,7 +338,7 @@
 	return infoBar;
 }
 
-void AdventureMapWidget::setPlayer(const PlayerColor & player)
+void AdventureMapWidget::setPlayerColor(const PlayerColor & player)
 {
 	setPlayerChildren(this, player);
 }
@@ -369,43 +351,41 @@
 		auto icon = dynamic_cast<CAdventureMapIcon *>(entry);
 		auto button = dynamic_cast<CButton *>(entry);
 		auto resDataBar = dynamic_cast<CResDataBar *>(entry);
-		auto texture = dynamic_cast<FilledTexturePlayerColored *>(entry);
+		auto textureColored = dynamic_cast<FilledTexturePlayerColored *>(entry);
+		auto textureIndexed = dynamic_cast<FilledTexturePlayerIndexed *>(entry);
 
 		if(button)
 			button->setPlayerColor(player);
 
 		if(resDataBar)
-			resDataBar->colorize(player);
+			resDataBar->setPlayerColor(player);
 
 		if(icon)
-			icon->setPlayer(player);
+			icon->setPlayerColor(player);
 
 		if(container)
 			setPlayerChildren(container, player);
 
-		if (texture)
-			texture->playerColored(player);
-	}
+		if (textureColored)
+			textureColored->setPlayerColor(player);
 
-	for(const auto & entry : playerColorerImages)
-	{
-		if(images.count(entry))
-			images[entry]->playerColored(player);
+		if (textureIndexed)
+			textureIndexed->setPlayerColor(player);
 	}
 
 	redraw();
 }
 
-CAdventureMapIcon::CAdventureMapIcon(const Point & position, std::shared_ptr<CAnimation> animation, size_t index, size_t iconsPerPlayer)
+CAdventureMapIcon::CAdventureMapIcon(const Point & position, const AnimationPath & animation, size_t index, size_t iconsPerPlayer)
 	: index(index)
 	, iconsPerPlayer(iconsPerPlayer)
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 	pos += position;
 	image = std::make_shared<CAnimImage>(animation, index);
 }
 
-void CAdventureMapIcon::setPlayer(const PlayerColor & player)
+void CAdventureMapIcon::setPlayerColor(const PlayerColor & player)
 {
 	image->setFrame(index + player.getNum() * iconsPerPlayer);
 }
diff --color -urN vcmi-1.5.7/client/adventureMap/AdventureMapWidget.h vcmi/client/adventureMap/AdventureMapWidget.h
--- vcmi-1.5.7/client/adventureMap/AdventureMapWidget.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/adventureMap/AdventureMapWidget.h	2024-12-19 15:00:22.242120828 +0100
@@ -11,7 +11,6 @@
 
 #include "../gui/InterfaceObjectConfigurable.h"
 
-class CAnimation;
 class CHeroList;
 class CTownList;
 class CMinimap;
@@ -29,11 +28,7 @@
 	std::vector<Rect> subwidgetSizes;
 
 	/// list of images on which player-colored palette will be applied
-	std::vector<ImagePath> playerColorerImages;
-
-	/// list of named images shared between widgets
-	std::map<ImagePath, std::shared_ptr<IImage>> images;
-	std::map<AnimationPath, std::shared_ptr<CAnimation>> animations;
+	std::vector<ImagePath> playerColoredImages;
 
 	/// Widgets that require access from adventure map
 	std::shared_ptr<CHeroList> heroList;
@@ -48,9 +43,6 @@
 	Rect readSourceArea(const JsonNode & source, const JsonNode & sourceCommon);
 	Rect readArea(const JsonNode & source, const Rect & boundingBox);
 
-	std::shared_ptr<IImage> loadImage(const JsonNode & name);
-	std::shared_ptr<CAnimation> loadAnimation(const JsonNode & name);
-
 	std::shared_ptr<CIntObject> buildInfobox(const JsonNode & input);
 	std::shared_ptr<CIntObject> buildMapImage(const JsonNode & input);
 	std::shared_ptr<CIntObject> buildMapButton(const JsonNode & input);
@@ -64,7 +56,6 @@
 	std::shared_ptr<CIntObject> buildStatusBar(const JsonNode & input);
 	std::shared_ptr<CIntObject> buildTexturePlayerColored(const JsonNode &);
 
-
 	void setPlayerChildren(CIntObject * widget, const PlayerColor & player);
 	void updateActiveStateChildden(CIntObject * widget);
 public:
@@ -76,7 +67,7 @@
 	std::shared_ptr<MapView> getMapView();
 	std::shared_ptr<CInfoBar> getInfoBar();
 
-	void setPlayer(const PlayerColor & player);
+	void setPlayerColor(const PlayerColor & player);
 
 	void onMapViewMoved(const Rect & visibleArea, int mapLevel);
 	void updateActiveState();
@@ -104,7 +95,7 @@
 	size_t index;
 	size_t iconsPerPlayer;
 public:
-	CAdventureMapIcon(const Point & position, std::shared_ptr<CAnimation> image, size_t index, size_t iconsPerPlayer);
+	CAdventureMapIcon(const Point & position, const AnimationPath & image, size_t index, size_t iconsPerPlayer);
 
-	void setPlayer(const PlayerColor & player);
+	void setPlayerColor(const PlayerColor & player);
 };
diff --color -urN vcmi-1.5.7/client/adventureMap/AdventureOptions.cpp vcmi/client/adventureMap/AdventureOptions.cpp
--- vcmi-1.5.7/client/adventureMap/AdventureOptions.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/adventureMap/AdventureOptions.cpp	2024-12-19 15:00:22.242120828 +0100
@@ -23,12 +23,12 @@
 
 #include "../../CCallback.h"
 #include "../../lib/StartInfo.h"
-#include "../../lib/CGeneralTextHandler.h"
+#include "../../lib/texts/CGeneralTextHandler.h"
 
 AdventureOptions::AdventureOptions()
 	: CWindowObject(PLAYER_COLORED, ImagePath::builtin("ADVOPTS"))
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	viewWorld = std::make_shared<CButton>(Point(24, 23), AnimationPath::builtin("ADVVIEW.DEF"), CButton::tooltip(), [&](){ close(); }, EShortcut::ADVENTURE_VIEW_WORLD);
 	viewWorld->addCallback([] { LOCPLINT->viewWorldMap(); });
diff --color -urN vcmi-1.5.7/client/adventureMap/CInfoBar.cpp vcmi/client/adventureMap/CInfoBar.cpp
--- vcmi-1.5.7/client/adventureMap/CInfoBar.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/adventureMap/CInfoBar.cpp	2024-12-19 15:00:22.242120828 +0100
@@ -20,16 +20,16 @@
 #include "../widgets/MiscWidgets.h"
 #include "../windows/InfoWindows.h"
 #include "../CGameInfo.h"
-#include "../CMusicHandler.h"
 #include "../CPlayerInterface.h"
 #include "../PlayerLocalState.h"
 #include "../gui/CGuiHandler.h"
 #include "../gui/WindowHandler.h"
+#include "../media/ISoundPlayer.h"
 #include "../render/IScreenHandler.h"
 
 #include "../../CCallback.h"
 #include "../../lib/CConfigHandler.h"
-#include "../../lib/CGeneralTextHandler.h"
+#include "../../lib/texts/CGeneralTextHandler.h"
 #include "../../lib/mapObjects/CGHeroInstance.h"
 #include "../../lib/mapObjects/CGTownInstance.h"
 
@@ -51,7 +51,7 @@
 
 CInfoBar::VisibleHeroInfo::VisibleHeroInfo(const CGHeroInstance * hero)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	background = std::make_shared<CPicture>(ImagePath::builtin("ADSTATHR"));
 
 	if(settings["gameTweaks"]["infoBarCreatureManagement"].Bool())
@@ -62,7 +62,7 @@
 
 CInfoBar::VisibleTownInfo::VisibleTownInfo(const CGTownInstance * town)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	background = std::make_shared<CPicture>(ImagePath::builtin("ADSTATCS"));
 
 	if(settings["gameTweaks"]["infoBarCreatureManagement"].Bool())
@@ -73,7 +73,7 @@
 
 CInfoBar::VisibleDateInfo::VisibleDateInfo()
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	animation = std::make_shared<CShowableAnim>(1, 0, getNewDayName(), CShowableAnim::PLAY_ONCE, 180);// H3 uses around 175-180 ms per frame
 	animation->setDuration(1500);
@@ -114,7 +114,7 @@
 
 CInfoBar::VisibleEnemyTurnInfo::VisibleEnemyTurnInfo(PlayerColor player)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	background = std::make_shared<CPicture>(ImagePath::builtin("ADSTATNX"));
 	banner = std::make_shared<CAnimImage>(AnimationPath::builtin("CREST58"), player.getNum(), 0, 20, 51);
 	sand = std::make_shared<CShowableAnim>(99, 51, AnimationPath::builtin("HOURSAND"), 0, 100); // H3 uses around 100 ms per frame
@@ -123,7 +123,7 @@
 
 CInfoBar::VisibleGameStatusInfo::VisibleGameStatusInfo()
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	//get amount of halls of each level
 	std::vector<int> halls(4, 0);
 	for(auto town : LOCPLINT->localState->getOwnedTowns())
@@ -180,7 +180,7 @@
 
 CInfoBar::VisibleComponentInfo::VisibleComponentInfo(const std::vector<Component> & compsToDisplay, std::string message, int textH, bool tiny)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	background = std::make_shared<CPicture>(ImagePath::builtin("ADSTATOT"), 1, 0);
 	auto fullRect = Rect(CInfoBar::offset, CInfoBar::offset, data_width - 2 * CInfoBar::offset, data_height - 2 * CInfoBar::offset);
@@ -250,14 +250,14 @@
 
 void CInfoBar::reset()
 {
-	OBJECT_CONSTRUCTION_CUSTOM_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	state = EMPTY;
 	visibleInfo = std::make_shared<EmptyVisibleInfo>();
 }
 
 void CInfoBar::showSelection()
 {
-	OBJECT_CONSTRUCTION_CUSTOM_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	if(LOCPLINT->localState->getCurrentHero())
 	{
 		showHeroSelection(LOCPLINT->localState->getCurrentHero());
@@ -325,7 +325,7 @@
 	state(EMPTY),
 	listener(settings.listen["gameTweaks"]["infoBarCreatureManagement"])
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	pos.w = position.w;
 	pos.h = position.h;
 	listener(std::bind(&CInfoBar::OnInfoBarCreatureManagementChanged, this));
@@ -349,7 +349,7 @@
 
 void CInfoBar::showDate()
 {
-	OBJECT_CONSTRUCTION_CUSTOM_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	playNewDaySound();
 	state = DATE;
 	visibleInfo = std::make_shared<VisibleDateInfo>();
@@ -475,7 +475,7 @@
 
 void CInfoBar::popComponents(bool remove)
 {
-	OBJECT_CONSTRUCTION_CUSTOM_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	if(remove && !componentsQueue.empty())
 		componentsQueue.pop();
 	if(!componentsQueue.empty())
@@ -492,7 +492,7 @@
 
 void CInfoBar::pushComponents(const std::vector<Component> & comps, std::string message, int textH, bool tiny, int timer)
 {
-	OBJECT_CONSTRUCTION_CUSTOM_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	componentsQueue.emplace(VisibleComponentInfo::Cache(comps, message, textH, tiny), timer);
 }
 
@@ -503,7 +503,7 @@
 
 void CInfoBar::startEnemyTurn(PlayerColor color)
 {
-	OBJECT_CONSTRUCTION_CUSTOM_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	state = AITURN;
 	visibleInfo = std::make_shared<VisibleEnemyTurnInfo>(color);
 	redraw();
@@ -511,7 +511,7 @@
 
 void CInfoBar::showHeroSelection(const CGHeroInstance * hero)
 {
-	OBJECT_CONSTRUCTION_CUSTOM_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	if(!hero)
 	{
 		reset();
@@ -526,7 +526,7 @@
 
 void CInfoBar::showTownSelection(const CGTownInstance * town)
 {
-	OBJECT_CONSTRUCTION_CUSTOM_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	if(!town)
 	{
 		reset();
@@ -541,7 +541,7 @@
 
 void CInfoBar::showGameStatus()
 {
-	OBJECT_CONSTRUCTION_CUSTOM_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	state = GAME;
 	visibleInfo = std::make_shared<VisibleGameStatusInfo>();
 	setTimer(3000);
diff --color -urN vcmi-1.5.7/client/adventureMap/CInGameConsole.cpp vcmi/client/adventureMap/CInGameConsole.cpp
--- vcmi-1.5.7/client/adventureMap/CInGameConsole.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/adventureMap/CInGameConsole.cpp	2024-12-19 15:00:22.242120828 +0100
@@ -12,7 +12,6 @@
 #include "CInGameConsole.h"
 
 #include "../CGameInfo.h"
-#include "../CMusicHandler.h"
 #include "../CPlayerInterface.h"
 #include "../CServerHandler.h"
 #include "../GameChatHandler.h"
@@ -21,6 +20,7 @@
 #include "../gui/WindowHandler.h"
 #include "../gui/Shortcut.h"
 #include "../gui/TextAlignment.h"
+#include "../media/ISoundPlayer.h"
 #include "../render/Colors.h"
 #include "../render/Canvas.h"
 #include "../render/IScreenHandler.h"
@@ -30,9 +30,8 @@
 #include "../../CCallback.h"
 #include "../../lib/CConfigHandler.h"
 #include "../../lib/CThreadHelper.h"
-#include "../../lib/TextOperations.h"
 #include "../../lib/mapObjects/CArmedInstance.h"
-#include "../../lib/MetaString.h"
+#include "../../lib/texts/TextOperations.h"
 
 CInGameConsole::CInGameConsole()
 	: CIntObject(KEYBOARD | TIME | TEXTINPUT)
@@ -221,7 +220,7 @@
 	}
 }
 
-void CInGameConsole::textInputed(const std::string & inputtedText)
+void CInGameConsole::textInputted(const std::string & inputtedText)
 {
 	if (LOCPLINT->cingconsole != this)
 		return;
diff --color -urN vcmi-1.5.7/client/adventureMap/CInGameConsole.h vcmi/client/adventureMap/CInGameConsole.h
--- vcmi-1.5.7/client/adventureMap/CInGameConsole.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/adventureMap/CInGameConsole.h	2024-12-19 15:00:22.242120828 +0100
@@ -50,7 +50,7 @@
 	void show(Canvas & to) override;
 	void showAll(Canvas & to) override;
 	void keyPressed(EShortcut key) override;
-	void textInputed(const std::string & enteredText) override;
+	void textInputted(const std::string & enteredText) override;
 	void textEdited(const std::string & enteredText) override;
 	bool captureThisKey(EShortcut key) override;
 
diff --color -urN vcmi-1.5.7/client/adventureMap/CList.cpp vcmi/client/adventureMap/CList.cpp
--- vcmi-1.5.7/client/adventureMap/CList.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/adventureMap/CList.cpp	2024-12-19 15:00:22.243120869 +0100
@@ -18,26 +18,28 @@
 #include "../widgets/ObjectLists.h"
 #include "../widgets/RadialMenu.h"
 #include "../windows/InfoWindows.h"
+#include "../windows/CCastleInterface.h"
 #include "../CGameInfo.h"
 #include "../CPlayerInterface.h"
 #include "../PlayerLocalState.h"
 #include "../gui/CGuiHandler.h"
+#include "../gui/Shortcut.h"
 #include "../gui/WindowHandler.h"
 #include "../render/Canvas.h"
 #include "../render/Colors.h"
 
-#include "../../lib/CGeneralTextHandler.h"
-#include "../../lib/CHeroHandler.h"
-#include "../../lib/GameSettings.h"
+#include "../../lib/texts/CGeneralTextHandler.h"
+#include "../../lib/IGameSettings.h"
 #include "../../lib/mapObjects/CGHeroInstance.h"
 #include "../../lib/mapObjects/CGTownInstance.h"
 
+#include "../../CCallback.h"
+
 CList::CListItem::CListItem(CList * Parent)
 	: CIntObject(LCLICK | SHOW_POPUP | HOVER),
 	parent(Parent),
 	selection()
 {
-	defActions = 255-DISPOSE;
 }
 
 CList::CListItem::~CListItem() = default;
@@ -71,7 +73,7 @@
 
 void CList::CListItem::onSelect(bool on)
 {
-	OBJECT_CONSTRUCTION_CUSTOM_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	selection.reset();
 	if(on)
 		selection = genSelection();
@@ -96,7 +98,7 @@
 
 void CList::createList(Point firstItemPosition, Point itemPositionDelta, size_t listAmount)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	listBox = std::make_shared<CListBox>(std::bind(&CList::createItem, this, _1), firstItemPosition, itemPositionDelta, size, listAmount);
 }
 
@@ -207,7 +209,7 @@
 
 CHeroList::CEmptyHeroItem::CEmptyHeroItem()
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	movement = std::make_shared<CAnimImage>(AnimationPath::builtin("IMOBIL"), 0, 0, 0, 1);
 	portrait = std::make_shared<CPicture>(ImagePath::builtin("HPSXXX"), movement->pos.w + 1, 0);
 	mana = std::make_shared<CAnimImage>(AnimationPath::builtin("IMANA"), 0, 0, movement->pos.w + portrait->pos.w + 2, 1 );
@@ -220,7 +222,7 @@
 	: CListItem(parent),
 	hero(Hero)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	movement = std::make_shared<CAnimImage>(AnimationPath::builtin("IMOBIL"), 0, 0, 0, 1);
 	portrait = std::make_shared<CAnimImage>(AnimationPath::builtin("PortraitsSmall"), hero->getIconIndex(), 0, movement->pos.w + 1);
 	mana = std::make_shared<CAnimImage>(AnimationPath::builtin("IMANA"), 0, 0, movement->pos.w + portrait->pos.w + 2, 1);
@@ -230,7 +232,7 @@
 
 	update();
 
-	addUsedEvents(GESTURE);
+	addUsedEvents(GESTURE | KEYBOARD);
 }
 
 void CHeroList::CHeroItem::update()
@@ -263,7 +265,7 @@
 
 std::string CHeroList::CHeroItem::getHoverText()
 {
-	return boost::str(boost::format(CGI->generaltexth->allTexts[15]) % hero->getNameTranslated() % hero->getClassNameTranslated());
+	return boost::str(boost::format(CGI->generaltexth->allTexts[15]) % hero->getNameTranslated() % hero->getClassNameTranslated()) + hero->getMovementPointsTextIfOwner(hero->getOwner());
 }
 
 void CHeroList::CHeroItem::gesture(bool on, const Point & initialPosition, const Point & finalPosition)
@@ -301,6 +303,55 @@
 	GH.windows().createAndPushWindow<RadialMenu>(pos.center(), menuElements, true);
 }
 
+void CHeroList::CHeroItem::keyPressed(EShortcut key)
+{
+	if(!hero)
+		return;
+
+	if(parent->selected != this->shared_from_this())
+		return;
+
+	auto & heroes = LOCPLINT->localState->getWanderingHeroes();
+
+	if(key == EShortcut::LIST_HERO_DISMISS)
+	{
+		LOCPLINT->showYesNoDialog(CGI->generaltexth->allTexts[22], [=](){ LOCPLINT->cb->dismissHero(hero); }, nullptr);
+		return;
+	}
+
+	if(heroes.size() < 2)
+		return;
+
+	size_t heroPos = vstd::find_pos(heroes, hero);
+	const CGHeroInstance * heroUpper = (heroPos < 1) ? nullptr : heroes.at(heroPos - 1);
+	const CGHeroInstance * heroLower = (heroPos > heroes.size() - 2) ? nullptr : heroes.at(heroPos + 1);
+
+	switch(key)
+	{
+	case EShortcut::LIST_HERO_UP:
+		if(heroUpper)
+			LOCPLINT->localState->swapWanderingHero(heroPos, heroPos - 1);
+		break;
+
+	case EShortcut::LIST_HERO_DOWN:
+		if(heroLower)
+			LOCPLINT->localState->swapWanderingHero(heroPos, heroPos + 1);
+		break;
+
+	case EShortcut::LIST_HERO_TOP:
+		if(heroUpper)
+			for (size_t i = heroPos; i > 0; i--)
+				LOCPLINT->localState->swapWanderingHero(i, i - 1);
+		break;
+
+	case EShortcut::LIST_HERO_BOTTOM:
+		if(heroLower)
+			for (int i = heroPos; i < heroes.size() - 1; i++)
+				LOCPLINT->localState->swapWanderingHero(i, i + 1);
+		break;
+	}
+}
+
 std::shared_ptr<CIntObject> CHeroList::createItem(size_t index)
 {
 	if (LOCPLINT->localState->getWanderingHeroes().size() > index)
@@ -365,12 +416,12 @@
 	CListItem(parent),
 	town(Town)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	picture = std::make_shared<CAnimImage>(AnimationPath::builtin("ITPA"), 0);
 	pos = picture->pos;
 	update();
 
-	addUsedEvents(GESTURE);
+	addUsedEvents(GESTURE | KEYBOARD);
 }
 
 std::shared_ptr<CIntObject> CTownList::CTownItem::genSelection()
@@ -380,7 +431,7 @@
 
 void CTownList::CTownItem::update()
 {
-	size_t iconIndex = town->town->clientInfo.icons[town->hasFort()][town->builded >= CGI->settings()->getInteger(EGameSettings::TOWNS_BUILDINGS_PER_TURN_CAP)];
+	size_t iconIndex = town->getTown()->clientInfo.icons[town->hasFort()][town->built >= LOCPLINT->cb->getSettings().getInteger(EGameSettings::TOWNS_BUILDINGS_PER_TURN_CAP)];
 
 	picture->setFrame(iconIndex + 2);
 	redraw();
@@ -399,7 +450,7 @@
 
 void CTownList::CTownItem::showTooltip()
 {
-	CRClickPopup::createAndPush(town, GH.getCursorPosition());
+	CRClickPopup::createAndPush(town, pos.center());
 }
 
 void CTownList::CTownItem::gesture(bool on, const Point & initialPosition, const Point & finalPosition)
@@ -419,24 +470,77 @@
 	int townUpperPos = (townIndex < 1) ? -1 : townIndex - 1;
 	int townLowerPos = (townIndex > towns.size() - 2) ? -1 : townIndex + 1;
 
+	auto updateList = [](){
+		for (auto ki : GH.windows().findWindows<CCastleInterface>())
+			ki->townChange(); //update list
+	};
+
 	std::vector<RadialMenuConfig> menuElements = {
-		{ RadialMenuConfig::ITEM_ALT_NN, townUpperPos > -1, "altUpTop", "vcmi.radialWheel.moveTop", [townIndex]()
+		{ RadialMenuConfig::ITEM_ALT_NN, townUpperPos > -1, "altUpTop", "vcmi.radialWheel.moveTop", [updateList, townIndex]()
 		{
 			for (int i = townIndex; i > 0; i--)
 				LOCPLINT->localState->swapOwnedTowns(i, i - 1);
+			updateList();
 		} },
-		{ RadialMenuConfig::ITEM_ALT_NW, townUpperPos > -1, "altUp", "vcmi.radialWheel.moveUp", [townIndex, townUpperPos](){LOCPLINT->localState->swapOwnedTowns(townIndex, townUpperPos); } },
-		{ RadialMenuConfig::ITEM_ALT_SW, townLowerPos > -1, "altDown", "vcmi.radialWheel.moveDown", [townIndex, townLowerPos](){ LOCPLINT->localState->swapOwnedTowns(townIndex, townLowerPos); } },
-		{ RadialMenuConfig::ITEM_ALT_SS, townLowerPos > -1, "altDownBottom", "vcmi.radialWheel.moveBottom", [townIndex, towns]()
+		{ RadialMenuConfig::ITEM_ALT_NW, townUpperPos > -1, "altUp", "vcmi.radialWheel.moveUp", [updateList, townIndex, townUpperPos](){LOCPLINT->localState->swapOwnedTowns(townIndex, townUpperPos); updateList(); } },
+		{ RadialMenuConfig::ITEM_ALT_SW, townLowerPos > -1, "altDown", "vcmi.radialWheel.moveDown", [updateList, townIndex, townLowerPos](){ LOCPLINT->localState->swapOwnedTowns(townIndex, townLowerPos); updateList(); } },
+		{ RadialMenuConfig::ITEM_ALT_SS, townLowerPos > -1, "altDownBottom", "vcmi.radialWheel.moveBottom", [updateList, townIndex, towns]()
 		{
 			for (int i = townIndex; i < towns.size() - 1; i++)
 				LOCPLINT->localState->swapOwnedTowns(i, i + 1);
+			updateList();
 		} },
 	};
 
 	GH.windows().createAndPushWindow<RadialMenu>(pos.center(), menuElements, true);
 }
 
+void CTownList::CTownItem::keyPressed(EShortcut key)
+{
+	if(parent->selected != this->shared_from_this())
+		return;
+
+	const std::vector<const CGTownInstance *> towns = LOCPLINT->localState->getOwnedTowns();
+	size_t townIndex = vstd::find_pos(towns, town);
+
+	if(townIndex + 1 > towns.size() || !towns.at(townIndex))
+		return;
+
+	if(towns.size() < 2)
+		return;
+
+	int townUpperPos = (townIndex < 1) ? -1 : townIndex - 1;
+	int townLowerPos = (townIndex > towns.size() - 2) ? -1 : townIndex + 1;
+
+	switch(key)
+	{
+	case EShortcut::LIST_TOWN_UP:
+		if(townUpperPos > -1)
+			LOCPLINT->localState->swapOwnedTowns(townIndex, townUpperPos);
+		break;
+
+	case EShortcut::LIST_TOWN_DOWN:
+		if(townLowerPos > -1)
+			LOCPLINT->localState->swapOwnedTowns(townIndex, townLowerPos);
+		break;
+
+	case EShortcut::LIST_TOWN_TOP:
+		if(townUpperPos > -1)
+			for (int i = townIndex; i > 0; i--)
+				LOCPLINT->localState->swapOwnedTowns(i, i - 1);
+		break;
+
+	case EShortcut::LIST_TOWN_BOTTOM:
+		if(townLowerPos > -1)
+			for (int i = townIndex; i < towns.size() - 1; i++)
+				LOCPLINT->localState->swapOwnedTowns(i, i + 1);
+		break;
+	}
+
+	for (auto ki : GH.windows().findWindows<CCastleInterface>())
+		ki->townChange(); //update list
+}
+
 std::string CTownList::CTownItem::getHoverText()
 {
 	return town->getObjectName();
diff --color -urN vcmi-1.5.7/client/adventureMap/CList.h vcmi/client/adventureMap/CList.h
--- vcmi-1.5.7/client/adventureMap/CList.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/adventureMap/CList.h	2024-12-19 15:00:22.243120869 +0100
@@ -29,9 +29,10 @@
 protected:
 	class CListItem : public CIntObject, public std::enable_shared_from_this<CListItem>
 	{
-		CList * parent;
 		std::shared_ptr<CIntObject> selection;
 	public:
+		CList * parent;
+
 		CListItem(CList * parent);
 		~CListItem();
 
@@ -55,9 +56,6 @@
 
 private:
 	const size_t size;
-
-	//for selection\deselection
-	std::shared_ptr<CListItem> selected;
 	void select(std::shared_ptr<CListItem> which);
 	friend class CListItem;
 
@@ -81,6 +79,9 @@
 	void update();
 
 public:
+	//for selection\deselection
+	std::shared_ptr<CListItem> selected;
+
 	/// functions that will be called when selection changes
 	CFunctionList<void()> onSelect;
 
@@ -128,6 +129,7 @@
 		void open() override;
 		void showTooltip() override;
 		void gesture(bool on, const Point & initialPosition, const Point & finalPosition) override;
+		void keyPressed(EShortcut key) override;
 		std::string getHoverText() override;
 	};
 
@@ -162,6 +164,7 @@
 		void open() override;
 		void showTooltip() override;
 		void gesture(bool on, const Point & initialPosition, const Point & finalPosition) override;
+		void keyPressed(EShortcut key) override;
 		std::string getHoverText() override;
 	};
 
diff --color -urN vcmi-1.5.7/client/adventureMap/CMinimap.cpp vcmi/client/adventureMap/CMinimap.cpp
--- vcmi-1.5.7/client/adventureMap/CMinimap.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/adventureMap/CMinimap.cpp	2024-12-19 15:00:22.243120869 +0100
@@ -26,7 +26,7 @@
 #include "../windows/InfoWindows.h"
 
 #include "../../CCallback.h"
-#include "../../lib/CGeneralTextHandler.h"
+#include "../../lib/texts/CGeneralTextHandler.h"
 #include "../../lib/TerrainHandler.h"
 #include "../../lib/mapObjects/CGHeroInstance.h"
 #include "../../lib/mapping/CMapDefines.h"
@@ -50,10 +50,10 @@
 			return graphics->playerColors[player.getNum()];
 	}
 
-	if (tile->blocked && (!tile->visitable))
-		return tile->terType->minimapBlocked;
+	if (tile->blocked() && !tile->visitable())
+		return tile->getTerrain()->minimapBlocked;
 	else
-		return tile->terType->minimapUnblocked;
+		return tile->getTerrain()->minimapUnblocked;
 }
 
 void CMinimapInstance::refreshTile(const int3 &tile)
@@ -73,7 +73,7 @@
 
 CMinimapInstance::CMinimapInstance(CMinimap *Parent, int Level):
 	parent(Parent),
-	minimap(new Canvas(Point(LOCPLINT->cb->getMapSize().x, LOCPLINT->cb->getMapSize().y))),
+	minimap(new Canvas(Point(LOCPLINT->cb->getMapSize().x, LOCPLINT->cb->getMapSize().y), CanvasScalingPolicy::IGNORE)),
 	level(Level)
 {
 	pos.w = parent->pos.w;
@@ -90,11 +90,11 @@
 	: CIntObject(LCLICK | SHOW_POPUP | DRAG | MOVE | GESTURE, position.topLeft()),
 	level(0)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 
-	double maxSideLenghtSrc = std::max(LOCPLINT->cb->getMapSize().x, LOCPLINT->cb->getMapSize().y);
-	double maxSideLenghtDst = std::max(position.w, position.h);
-	double resize = maxSideLenghtSrc / maxSideLenghtDst;
+	double maxSideLengthSrc = std::max(LOCPLINT->cb->getMapSize().x, LOCPLINT->cb->getMapSize().y);
+	double maxSideLengthDst = std::max(position.w, position.h);
+	double resize = maxSideLengthSrc / maxSideLengthDst;
 	Point newMinimapSize = Point(LOCPLINT->cb->getMapSize().x/ resize, LOCPLINT->cb->getMapSize().y / resize);
 	Point offset = Point((std::max(newMinimapSize.x, newMinimapSize.y) - newMinimapSize.x) / 2, (std::max(newMinimapSize.x, newMinimapSize.y) - newMinimapSize.y) / 2);
 
@@ -202,7 +202,7 @@
 	if(aiShield->recActions & UPDATE) //AI turn is going on. There is no need to update minimap
 		return;
 
-	OBJECT_CONSTRUCTION_CUSTOM_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	minimap = std::make_shared<CMinimapInstance>(this, level);
 	redraw();
 }
diff --color -urN vcmi-1.5.7/client/adventureMap/CResDataBar.cpp vcmi/client/adventureMap/CResDataBar.cpp
--- vcmi-1.5.7/client/adventureMap/CResDataBar.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/adventureMap/CResDataBar.cpp	2024-12-19 15:00:22.243120869 +0100
@@ -21,7 +21,7 @@
 
 #include "../../CCallback.h"
 #include "../../lib/CConfigHandler.h"
-#include "../../lib/CGeneralTextHandler.h"
+#include "../../lib/texts/CGeneralTextHandler.h"
 #include "../../lib/ResourceSet.h"
 
 CResDataBar::CResDataBar(const ImagePath & imageName, const Point & position)
@@ -29,9 +29,9 @@
 	pos.x += position.x;
 	pos.y += position.y;
 
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	background = std::make_shared<CPicture>(imageName, 0, 0);
-	background->colorize(LOCPLINT->playerID);
+	background->setPlayerColor(LOCPLINT->playerID);
 
 	pos.w = background->pos.w;
 	pos.h = background->pos.h;
@@ -84,7 +84,7 @@
 		to.drawText(pos.topLeft() + *datePosition, FONT_SMALL, Colors::WHITE, ETextAlignment::TOPLEFT, buildDateString());
 }
 
-void CResDataBar::colorize(PlayerColor player)
+void CResDataBar::setPlayerColor(PlayerColor player)
 {
-	background->colorize(player);
+	background->setPlayerColor(player);
 }
diff --color -urN vcmi-1.5.7/client/adventureMap/CResDataBar.h vcmi/client/adventureMap/CResDataBar.h
--- vcmi-1.5.7/client/adventureMap/CResDataBar.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/adventureMap/CResDataBar.h	2024-12-19 15:00:22.244120911 +0100
@@ -34,7 +34,7 @@
 	void setDatePosition(const Point & position);
 	void setResourcePosition(const GameResID & resource, const Point & position);
 
-	void colorize(PlayerColor player);
+	void setPlayerColor(PlayerColor player);
 	void showAll(Canvas & to) override;
 };
 
diff --color -urN vcmi-1.5.7/client/adventureMap/MapAudioPlayer.cpp vcmi/client/adventureMap/MapAudioPlayer.cpp
--- vcmi-1.5.7/client/adventureMap/MapAudioPlayer.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/adventureMap/MapAudioPlayer.cpp	2024-12-19 15:00:22.244120911 +0100
@@ -12,10 +12,12 @@
 
 #include "../CCallback.h"
 #include "../CGameInfo.h"
-#include "../CMusicHandler.h"
 #include "../CPlayerInterface.h"
 #include "../mapView/mapHandler.h"
+#include "../media/IMusicPlayer.h"
+#include "../media/ISoundPlayer.h"
 
+#include "../../lib/CRandomGenerator.h"
 #include "../../lib/TerrainHandler.h"
 #include "../../lib/mapObjects/CArmedInstance.h"
 #include "../../lib/mapObjects/CGHeroInstance.h"
@@ -79,9 +81,9 @@
 		{
 			for(int fy = 0; fy < obj->getHeight(); ++fy)
 			{
-				int3 currTile(obj->pos.x - fx, obj->pos.y - fy, obj->pos.z);
+				int3 currTile(obj->anchorPos().x - fx, obj->anchorPos().y - fy, obj->anchorPos().z);
 
-				if(LOCPLINT->cb->isInTheMap(currTile) && obj->coveringAt(currTile.x, currTile.y))
+				if(LOCPLINT->cb->isInTheMap(currTile) && obj->coveringAt(currTile))
 					objects[currTile.z][currTile.x][currTile.y].push_back(obj->id);
 			}
 		}
@@ -106,7 +108,7 @@
 
 		for(const auto & tile : tiles)
 		{
-			int3 currTile = obj->pos + tile;
+			int3 currTile = obj->anchorPos() + tile;
 
 			if(LOCPLINT->cb->isInTheMap(currTile))
 				objects[currTile.z][currTile.x][currTile.y].push_back(obj->id);
@@ -135,8 +137,12 @@
 		if (!object)
 			logGlobal->warn("Already removed object %d found on tile! (%d %d %d)", objectID.getNum(), tile.x, tile.y, tile.z);
 
-		if(object && object->getAmbientSound())
-			result.push_back(object->getAmbientSound().value());
+		if(object)
+		{
+			auto ambientSound = object->getAmbientSound(CRandomGenerator::getDefault());
+			if (ambientSound)
+				result.push_back(ambientSound.value());
+		}
 	}
 
 	if(CGI->mh->getMap()->isCoastalTile(tile))
@@ -176,7 +182,7 @@
 		const auto * tile = LOCPLINT->cb->getTile(currentSelection->visitablePos());
 
 		if (tile)
-			CCS->musich->playMusicFromSet("terrain", tile->terType->getJsonKey(), true, false);
+			CCS->musich->playMusicFromSet("terrain", tile->getTerrain()->getJsonKey(), true, false);
 	}
 
 	if(audioPlaying && enemyMakingTurn)
diff --color -urN vcmi-1.5.7/client/adventureMap/TurnTimerWidget.cpp vcmi/client/adventureMap/TurnTimerWidget.cpp
--- vcmi-1.5.7/client/adventureMap/TurnTimerWidget.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/adventureMap/TurnTimerWidget.cpp	2024-12-19 15:00:22.244120911 +0100
@@ -11,11 +11,11 @@
 #include "TurnTimerWidget.h"
 
 #include "../CGameInfo.h"
-#include "../CMusicHandler.h"
 #include "../CPlayerInterface.h"
 #include "../battle/BattleInterface.h"
 #include "../battle/BattleStacksController.h"
 #include "../gui/CGuiHandler.h"
+#include "../media/ISoundPlayer.h"
 #include "../render/Graphics.h"
 #include "../widgets/Images.h"
 #include "../widgets/GraphicalPrimitiveCanvas.h"
@@ -35,7 +35,7 @@
 	, lastSoundCheckSeconds(0)
 	, isBattleMode(player.isValidPlayer())
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 
 	pos += position;
 	pos.w = 0;
diff --color -urN vcmi-1.5.7/client/ArtifactsUIController.cpp vcmi/client/ArtifactsUIController.cpp
--- vcmi-1.5.7/client/ArtifactsUIController.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/client/ArtifactsUIController.cpp	2024-12-19 15:00:22.238120662 +0100
@@ -0,0 +1,170 @@
+/*
+ * ArtifactsUIController.cpp, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+ 
+#include "StdInc.h"
+#include "ArtifactsUIController.h"
+#include "CGameInfo.h"
+#include "CPlayerInterface.h"
+
+#include "../CCallback.h"
+#include "../lib/ArtifactUtils.h"
+#include "../lib/texts/CGeneralTextHandler.h"
+#include "../lib/mapObjects/CGHeroInstance.h"
+
+#include "gui/CGuiHandler.h"
+#include "gui/WindowHandler.h"
+#include "widgets/CComponent.h"
+#include "windows/CWindowWithArtifacts.h"
+
+ArtifactsUIController::ArtifactsUIController()
+{
+	numOfMovedArts = 0;
+	numOfArtsAskAssembleSession = 0;
+}
+
+bool ArtifactsUIController::askToAssemble(const ArtifactLocation & al, const bool onlyEquipped, const bool checkIgnored)
+{
+	if(auto hero = LOCPLINT->cb->getHero(al.artHolder))
+	{
+		if(hero->getArt(al.slot) == nullptr)
+		{
+			logGlobal->error("artifact location %d points to nothing", al.slot.num);
+			return false;
+		}
+		return askToAssemble(hero, al.slot, onlyEquipped, checkIgnored);
+	}
+	return false;
+}
+
+bool ArtifactsUIController::askToAssemble(const CGHeroInstance * hero, const ArtifactPosition & slot,
+	const bool onlyEquipped, const bool checkIgnored)
+{
+	assert(hero);
+	const auto art = hero->getArt(slot);
+	assert(art);
+
+	if(hero->tempOwner != LOCPLINT->playerID)
+		return false;
+
+	if(numOfArtsAskAssembleSession != 0)
+		numOfArtsAskAssembleSession--;
+	auto assemblyPossibilities = ArtifactUtils::assemblyPossibilities(hero, art->getTypeId(), onlyEquipped);
+	if(!assemblyPossibilities.empty())
+	{
+		auto askThread = new boost::thread([this, hero, art, slot, assemblyPossibilities, checkIgnored]() -> void
+			{
+				boost::mutex::scoped_lock askLock(askAssembleArtifactMutex);
+				for(const auto combinedArt : assemblyPossibilities)
+				{
+					boost::mutex::scoped_lock interfaceLock(GH.interfaceMutex);
+					if(checkIgnored)
+					{
+						if(vstd::contains(ignoredArtifacts, combinedArt->getId()))
+							continue;
+						ignoredArtifacts.emplace(combinedArt->getId());
+					}
+
+					bool assembleConfirmed = false;
+					MetaString message = MetaString::createFromTextID(art->getType()->getDescriptionTextID());
+					message.appendEOL();
+					message.appendEOL();
+					if(combinedArt->isFused())
+						message.appendRawString(CGI->generaltexth->translate("vcmi.heroWindow.fusingArtifact.fusing"));
+					else
+						message.appendRawString(CGI->generaltexth->allTexts[732]); // You possess all of the components needed to assemble the
+					message.replaceName(ArtifactID(combinedArt->getId()));
+					LOCPLINT->showYesNoDialog(message.toString(), [&assembleConfirmed, hero, slot, combinedArt]()
+						{
+							assembleConfirmed = true;
+							LOCPLINT->cb.get()->assembleArtifacts(hero->id, slot, true, combinedArt->getId());
+						}, nullptr, {std::make_shared<CComponent>(ComponentType::ARTIFACT, combinedArt->getId())});
+
+					LOCPLINT->waitWhileDialog();
+					if(assembleConfirmed)
+						break;
+				}
+			});
+		askThread->detach();
+		return true;
+	}
+	return false;
+}
+
+bool ArtifactsUIController::askToDisassemble(const CGHeroInstance * hero, const ArtifactPosition & slot)
+{
+	assert(hero);
+	const auto art = hero->getArt(slot);
+	assert(art);
+
+	if(hero->tempOwner != LOCPLINT->playerID)
+		return false;
+
+	if(art->hasParts())
+	{
+		if(ArtifactUtils::isSlotBackpack(slot) && !ArtifactUtils::isBackpackFreeSlots(hero, art->getType()->getConstituents().size() - 1))
+			return false;
+
+		MetaString message = MetaString::createFromTextID(art->getType()->getDescriptionTextID());
+		message.appendEOL();
+		message.appendEOL();
+		message.appendRawString(CGI->generaltexth->allTexts[733]); // Do you wish to disassemble this artifact?
+		LOCPLINT->showYesNoDialog(message.toString(), [hero, slot]()
+			{
+				LOCPLINT->cb->assembleArtifacts(hero->id, slot, false, ArtifactID());
+			}, nullptr);
+		return true;
+	}
+	return false;
+}
+
+void ArtifactsUIController::artifactRemoved()
+{
+	for(const auto & artWin : GH.windows().findWindows<CWindowWithArtifacts>())
+		artWin->update();
+	LOCPLINT->waitWhileDialog();
+}
+
+void ArtifactsUIController::artifactMoved()
+{
+	// If a bulk transfer has arrived, then redrawing only the last art movement.
+	if(numOfMovedArts != 0)
+		numOfMovedArts--;
+
+	if(numOfMovedArts == 0)
+		for(const auto & artWin : GH.windows().findWindows<CWindowWithArtifacts>())
+		{
+			artWin->update();
+		}
+	LOCPLINT->waitWhileDialog();
+}
+
+void ArtifactsUIController::bulkArtMovementStart(size_t totalNumOfArts, size_t possibleAssemblyNumOfArts)
+{
+	assert(totalNumOfArts >= possibleAssemblyNumOfArts);
+	numOfMovedArts = totalNumOfArts;
+	if(numOfArtsAskAssembleSession == 0)
+	{
+		// Do not start the next session until the previous one is finished
+		numOfArtsAskAssembleSession = possibleAssemblyNumOfArts;
+		ignoredArtifacts.clear();
+	}
+}
+
+void ArtifactsUIController::artifactAssembled()
+{
+	for(const auto & artWin : GH.windows().findWindows<CWindowWithArtifacts>())
+		artWin->update();
+}
+
+void ArtifactsUIController::artifactDisassembled()
+{
+	for(const auto & artWin : GH.windows().findWindows<CWindowWithArtifacts>())
+		artWin->update();
+}
diff --color -urN vcmi-1.5.7/client/ArtifactsUIController.h vcmi/client/ArtifactsUIController.h
--- vcmi-1.5.7/client/ArtifactsUIController.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/client/ArtifactsUIController.h	2024-12-19 15:00:22.238120662 +0100
@@ -0,0 +1,42 @@
+/*
+ * ArtifactsUIController.h, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+ #pragma once
+
+#include "../lib/constants/EntityIdentifiers.h"
+#include "../lib/networkPacks/ArtifactLocation.h"
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+class CGHeroInstance;
+
+VCMI_LIB_NAMESPACE_END
+
+class ArtifactsUIController
+{
+	size_t numOfMovedArts;
+	size_t numOfArtsAskAssembleSession;
+	std::set<ArtifactID> ignoredArtifacts;
+
+	boost::mutex askAssembleArtifactMutex;
+
+public:
+	ArtifactsUIController();
+	bool askToAssemble(const ArtifactLocation & al, const bool onlyEquipped = false, const bool checkIgnored = false);
+	bool askToAssemble(const CGHeroInstance * hero, const ArtifactPosition & slot, const bool onlyEquipped = false,
+		const bool checkIgnored = false);
+	bool askToDisassemble(const CGHeroInstance * hero, const ArtifactPosition & slot);
+
+	void artifactRemoved();
+	void artifactMoved();
+	void bulkArtMovementStart(size_t totalNumOfArts, size_t possibleAssemblyNumOfArts);
+	void artifactAssembled();
+	void artifactDisassembled();
+};
+ 
\ No newline at end of file
diff --color -urN vcmi-1.5.7/client/battle/BattleActionsController.cpp vcmi/client/battle/BattleActionsController.cpp
--- vcmi-1.5.7/client/battle/BattleActionsController.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/battle/BattleActionsController.cpp	2024-12-19 15:00:22.244120911 +0100
@@ -28,7 +28,7 @@
 
 #include "../../CCallback.h"
 #include "../../lib/CConfigHandler.h"
-#include "../../lib/CGeneralTextHandler.h"
+#include "../../lib/texts/CGeneralTextHandler.h"
 #include "../../lib/CRandomGenerator.h"
 #include "../../lib/CStack.h"
 #include "../../lib/battle/BattleAction.h"
@@ -175,6 +175,18 @@
 	if (!owner.stacksController->getActiveStack())
 		return;
 
+	if(owner.getBattle()->battleCanTargetEmptyHex(owner.stacksController->getActiveStack()))
+	{
+		auto actionFilterPredicate = [](const PossiblePlayerBattleAction x)
+		{
+			return x.get() != PossiblePlayerBattleAction::SHOOT;
+		};
+
+		vstd::erase_if(possibleActions, actionFilterPredicate);
+		GH.fakeMouseMove();
+		return;
+	}
+
 	if (!isActiveStackSpellcaster())
 		return;
 
@@ -263,6 +275,9 @@
 				return 2;
 				break;
 			case PossiblePlayerBattleAction::SHOOT:
+				if(targetStack == nullptr || targetStack->unitSide() == stack->unitSide() || !targetStack->alive())
+					return 100; //bottom priority
+
 				return 4;
 				break;
 			case PossiblePlayerBattleAction::ATTACK_AND_RETURN:
@@ -312,8 +327,8 @@
 	heroSpellToCast = std::make_shared<BattleAction>();
 	heroSpellToCast->actionType = EActionType::HERO_SPELL;
 	heroSpellToCast->spell = spellID;
-	heroSpellToCast->stackNumber = (owner.attackingHeroInstance->tempOwner == owner.curInt->playerID) ? -1 : -2;
-	heroSpellToCast->side = owner.defendingHeroInstance ? (owner.curInt->playerID == owner.defendingHeroInstance->tempOwner) : false;
+	heroSpellToCast->stackNumber = -1;
+	heroSpellToCast->side = owner.curInt->cb->getBattle(owner.getBattleID())->battleGetMySide();
 
 	//choosing possible targets
 	const CGHeroInstance *castingHero = (owner.attackingHeroInstance->tempOwner == owner.curInt->playerID) ? owner.attackingHeroInstance : owner.defendingHeroInstance;
@@ -356,6 +371,12 @@
 
 	auto action = selectAction(hoveredHex);
 
+	if(owner.stacksController->getActiveStack()->hasBonusOfType(BonusType::SPELL_LIKE_ATTACK))
+	{
+		auto bonus = owner.stacksController->getActiveStack()->getBonus(Selector::type()(BonusType::SPELL_LIKE_ATTACK));
+		return bonus->subtype.as<SpellID>().toSpell();
+	}
+
 	if (action.spell() == SpellID::NONE)
 		return nullptr;
 
@@ -514,6 +535,13 @@
 
 		case PossiblePlayerBattleAction::SHOOT:
 		{
+			if(targetStack == nullptr) //should be true only for spell-like attack
+			{
+				auto spellLikeAttackBonus = owner.stacksController->getActiveStack()->getBonus(Selector::type()(BonusType::SPELL_LIKE_ATTACK));
+				assert(spellLikeAttackBonus != nullptr);
+				return boost::str(boost::format(CGI->generaltexth->allTexts[26]) % spellLikeAttackBonus->subtype.as<SpellID>().toSpell()->getNameTranslated());
+			}
+
 			const auto * shooter = owner.stacksController->getActiveStack();
 
 			DamageEstimation retaliation;
@@ -625,7 +653,20 @@
 			return false;
 
 		case PossiblePlayerBattleAction::SHOOT:
-			return owner.getBattle()->battleCanShoot(owner.stacksController->getActiveStack(), targetHex);
+			{
+				auto currentStack = owner.stacksController->getActiveStack();
+				if(!owner.getBattle()->battleCanShoot(currentStack, targetHex))
+					return false;
+
+				if(targetStack == nullptr && owner.getBattle()->battleCanTargetEmptyHex(currentStack))
+				{
+					auto spellLikeAttackBonus = currentStack->getBonus(Selector::type()(BonusType::SPELL_LIKE_ATTACK));
+					const CSpell * spellDataToCheck = spellLikeAttackBonus->subtype.as<SpellID>().toSpell();
+					return isCastingPossibleHere(spellDataToCheck, nullptr, targetHex);
+				}
+
+				return true;
+			}
 
 		case PossiblePlayerBattleAction::NO_LOCATION:
 			return false;
@@ -771,7 +812,7 @@
 				}
 			}
 
-			if (!spellcastingModeActive())
+			if (!heroSpellcastingModeActive())
 			{
 				if (action.spell().hasValue())
 				{
@@ -1018,14 +1059,9 @@
 
 void BattleActionsController::onHexRightClicked(BattleHex clickedHex)
 {
-	auto spellcastActionPredicate = [](PossiblePlayerBattleAction & action)
-	{
-		return action.spellcast();
-	};
+	bool isCurrentStackInSpellcastMode = creatureSpellcastingModeActive();
 
-	bool isCurrentStackInSpellcastMode = !possibleActions.empty() && std::all_of(possibleActions.begin(), possibleActions.end(), spellcastActionPredicate);
-
-	if (spellcastingModeActive() || isCurrentStackInSpellcastMode)
+	if (heroSpellcastingModeActive() || isCurrentStackInSpellcastMode)
 	{
 		endCastingSpell();
 		CRClickPopup::createAndPush(CGI->generaltexth->translate("core.genrltxt.731")); // spell cancelled
@@ -1044,11 +1080,21 @@
 		owner.defendingHero->heroRightClicked();
 }
 
-bool BattleActionsController::spellcastingModeActive() const
+bool BattleActionsController::heroSpellcastingModeActive() const
 {
 	return heroSpellToCast != nullptr;
 }
 
+bool BattleActionsController::creatureSpellcastingModeActive() const
+{
+	auto spellcastModePredicate = [](const PossiblePlayerBattleAction & action)
+	{
+		return action.spellcast() || action.get() == PossiblePlayerBattleAction::SHOOT; //for hotkey-eligible SPELL_LIKE_ATTACK creature should have only SHOOT action
+	};
+
+	return !possibleActions.empty() && std::all_of(possibleActions.begin(), possibleActions.end(), spellcastModePredicate);
+}
+
 bool BattleActionsController::currentActionSpellcasting(BattleHex hoveredHex)
 {
 	if (heroSpellToCast)
diff --color -urN vcmi-1.5.7/client/battle/BattleActionsController.h vcmi/client/battle/BattleActionsController.h
--- vcmi-1.5.7/client/battle/BattleActionsController.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/battle/BattleActionsController.h	2024-12-19 15:00:22.244120911 +0100
@@ -82,8 +82,10 @@
 	/// initialize list of potential actions for new active stack
 	void activateStack();
 
-	/// returns true if UI is currently in target selection mode
-	bool spellcastingModeActive() const;
+	/// returns true if UI is currently in hero spell target selection mode
+	bool heroSpellcastingModeActive() const;
+	/// returns true if UI is currently in "F" hotkey creature spell target selection mode
+	bool creatureSpellcastingModeActive() const;
 
 	/// returns true if one of the following is true:
 	/// - we are casting spell by hero
@@ -120,7 +122,7 @@
 	const std::vector<PossiblePlayerBattleAction> & getPossibleActions() const;
 	void removePossibleAction(PossiblePlayerBattleAction);
 	
-	/// inserts possible action in the beggining in order to prioritize it
+	/// inserts possible action in the beginning in order to prioritize it
 	void pushFrontPossibleAction(PossiblePlayerBattleAction);
 
 	/// resets possible actions to original state
diff --color -urN vcmi-1.5.7/client/battle/BattleAnimationClasses.cpp vcmi/client/battle/BattleAnimationClasses.cpp
--- vcmi-1.5.7/client/battle/BattleAnimationClasses.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/battle/BattleAnimationClasses.cpp	2024-12-19 15:00:22.245120952 +0100
@@ -20,10 +20,11 @@
 #include "CreatureAnimation.h"
 
 #include "../CGameInfo.h"
-#include "../CMusicHandler.h"
 #include "../CPlayerInterface.h"
 #include "../gui/CursorHandler.h"
 #include "../gui/CGuiHandler.h"
+#include "../media/ISoundPlayer.h"
+#include "../render/CAnimation.h"
 #include "../render/IRenderHandler.h"
 
 #include "../../CCallback.h"
@@ -160,7 +161,7 @@
 const CCreature * AttackAnimation::getCreature() const
 {
 	if (attackingStack->unitType()->getId() == CreatureID::ARROW_TOWERS)
-		return owner.siegeController->getTurretCreature();
+		return owner.siegeController->getTurretCreature(attackingStack->initialPosition);
 	else
 		return attackingStack->unitType();
 }
@@ -355,9 +356,9 @@
 		myAnim->setType(ECreatureAnimType::MOVING);
 	}
 
-	if (moveSoundHander == -1)
+	if (moveSoundHandler == -1)
 	{
-		moveSoundHander = CCS->soundh->playSound(stack->unitType()->sounds.move, -1);
+		moveSoundHandler = CCS->soundh->playSound(stack->unitType()->sounds.move, -1);
 	}
 
 	Point begPosition = owner.stacksController->getStackPositionAtHex(prevHex, stack);
@@ -398,12 +399,12 @@
 		myAnim->pos.moveTo(coords);
 
 		// true if creature haven't reached the final destination hex
-		if ((curentMoveIndex + 1) < destTiles.size())
+		if ((currentMoveIndex + 1) < destTiles.size())
 		{
 			// update the next hex field which has to be reached by the stack
-			curentMoveIndex++;
+			currentMoveIndex++;
 			prevHex = nextHex;
-			nextHex = destTiles[curentMoveIndex];
+			nextHex = destTiles[currentMoveIndex];
 
 			// request re-initialization
 			initialized = false;
@@ -417,18 +418,18 @@
 {
 	assert(stack);
 
-	if(moveSoundHander != -1)
-		CCS->soundh->stopSound(moveSoundHander);
+	if(moveSoundHandler != -1)
+		CCS->soundh->stopSound(moveSoundHandler);
 }
 
 MovementAnimation::MovementAnimation(BattleInterface & owner, const CStack *stack, std::vector<BattleHex> _destTiles, int _distance)
 	: StackMoveAnimation(owner, stack, stack->getPosition(), _destTiles.front()),
 	  destTiles(_destTiles),
-	  curentMoveIndex(0),
+	  currentMoveIndex(0),
 	  begX(0), begY(0),
 	  distanceX(0), distanceY(0),
 	  progressPerSecond(0.0),
-	  moveSoundHander(-1),
+	  moveSoundHandler(-1),
 	  progress(0.0)
 {
 	logAnim->debug("Created MovementAnimation for %s", stack->getName());
@@ -649,7 +650,7 @@
 	Point shooterPos = stackAnimation(attackingStack)->pos.topLeft();
 	Point shotTarget = owner.stacksController->getStackPositionAtHex(dest, defendingStack);
 
-	//maximal angle in radians between straight horizontal line and shooting line for which shot is considered to be straight (absoulte value)
+	//maximal angle in radians between straight horizontal line and shooting line for which shot is considered to be straight (absolute value)
 	static const double straightAngle = 0.2;
 
 	double projectileAngle = -atan2(shotTarget.y - shooterPos.y, std::abs(shotTarget.x - shooterPos.x));
@@ -672,18 +673,18 @@
 
 	if (getGroup() == getUpwardsGroup())
 	{
-		shotOrigin.x += ( -25 + shooterInfo->animation.upperRightMissleOffsetX ) * multiplier;
-		shotOrigin.y += shooterInfo->animation.upperRightMissleOffsetY;
+		shotOrigin.x += ( -25 + shooterInfo->animation.upperRightMissileOffsetX ) * multiplier;
+		shotOrigin.y += shooterInfo->animation.upperRightMissileOffsetY;
 	}
 	else if (getGroup() == getDownwardsGroup())
 	{
-		shotOrigin.x += ( -25 + shooterInfo->animation.lowerRightMissleOffsetX ) * multiplier;
-		shotOrigin.y += shooterInfo->animation.lowerRightMissleOffsetY;
+		shotOrigin.x += ( -25 + shooterInfo->animation.lowerRightMissileOffsetX ) * multiplier;
+		shotOrigin.y += shooterInfo->animation.lowerRightMissileOffsetY;
 	}
 	else if (getGroup() == getForwardGroup())
 	{
-		shotOrigin.x += ( -25 + shooterInfo->animation.rightMissleOffsetX ) * multiplier;
-		shotOrigin.y += shooterInfo->animation.rightMissleOffsetY;
+		shotOrigin.x += ( -25 + shooterInfo->animation.rightMissileOffsetX ) * multiplier;
+		shotOrigin.y += shooterInfo->animation.rightMissileOffsetY;
 	}
 	else
 	{
@@ -880,9 +881,10 @@
 	return maxFrames / 2;
 }
 
-EffectAnimation::EffectAnimation(BattleInterface & owner, const AnimationPath & animationName, int effects, bool reversed):
+EffectAnimation::EffectAnimation(BattleInterface & owner, const AnimationPath & animationName, int effects, float transparencyFactor, bool reversed):
 	BattleAnimation(owner),
-	animation(GH.renderHandler().loadAnimation(animationName)),
+	animation(GH.renderHandler().loadAnimation(animationName, EImageBlitMode::SIMPLE)),
+	transparencyFactor(transparencyFactor),
 	effectFlags(effects),
 	effectFinished(false),
 	reversed(reversed)
@@ -891,32 +893,32 @@
 }
 
 EffectAnimation::EffectAnimation(BattleInterface & owner, const AnimationPath & animationName, std::vector<BattleHex> hex, int effects, bool reversed):
-	EffectAnimation(owner, animationName, effects, reversed)
+	EffectAnimation(owner, animationName, effects, 1.0f, reversed)
 {
 	battlehexes = hex;
 }
 
-EffectAnimation::EffectAnimation(BattleInterface & owner, const AnimationPath & animationName, BattleHex hex, int effects, bool reversed):
-	EffectAnimation(owner, animationName, effects, reversed)
+EffectAnimation::EffectAnimation(BattleInterface & owner, const AnimationPath & animationName, BattleHex hex, int effects, float transparencyFactor, bool reversed):
+	EffectAnimation(owner, animationName, effects, transparencyFactor, reversed)
 {
 	assert(hex.isValid());
 	battlehexes.push_back(hex);
 }
 
 EffectAnimation::EffectAnimation(BattleInterface & owner, const AnimationPath & animationName, std::vector<Point> pos, int effects, bool reversed):
-	EffectAnimation(owner, animationName, effects, reversed)
+	EffectAnimation(owner, animationName, effects, 1.0f, reversed)
 {
 	positions = pos;
 }
 
 EffectAnimation::EffectAnimation(BattleInterface & owner, const AnimationPath & animationName, Point pos, int effects, bool reversed):
-	EffectAnimation(owner, animationName, effects, reversed)
+	EffectAnimation(owner, animationName, effects, 1.0f, reversed)
 {
 	positions.push_back(pos);
 }
 
 EffectAnimation::EffectAnimation(BattleInterface & owner, const AnimationPath & animationName, Point pos, BattleHex hex, int effects, bool reversed):
-	EffectAnimation(owner, animationName, effects, reversed)
+	EffectAnimation(owner, animationName, effects, 1.0f, reversed)
 {
 	assert(hex.isValid());
 	battlehexes.push_back(hex);
@@ -925,8 +927,6 @@
 
 bool EffectAnimation::init()
 {
-	animation->preload();
-
 	auto first = animation->getImage(0, 0, true);
 	if(!first)
 	{
@@ -952,6 +952,7 @@
 	be.effectID = ID;
 	be.animation = animation;
 	be.currentFrame = 0;
+	be.transparencyFactor = transparencyFactor;
 	be.type = reversed ? BattleEffect::AnimType::REVERSE : BattleEffect::AnimType::DEFAULT;
 
 	for (size_t i = 0; i < std::max(battlehexes.size(), positions.size()); ++i)
diff --color -urN vcmi-1.5.7/client/battle/BattleAnimationClasses.h vcmi/client/battle/BattleAnimationClasses.h
--- vcmi-1.5.7/client/battle/BattleAnimationClasses.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/battle/BattleAnimationClasses.h	2024-12-19 15:00:22.245120952 +0100
@@ -141,10 +141,10 @@
 class MovementAnimation : public StackMoveAnimation
 {
 private:
-	int moveSoundHander; // sound handler used when moving a unit
+	int moveSoundHandler; // sound handler used when moving a unit
 
 	std::vector<BattleHex> destTiles; //full path, includes already passed hexes
-	ui32 curentMoveIndex; // index of nextHex in destTiles
+	ui32 currentMoveIndex; // index of nextHex in destTiles
 
 	double begX, begY; // starting position
 	double distanceX, distanceY; // full movement distance, may be negative if creture moves topleft
@@ -309,9 +309,10 @@
 class EffectAnimation : public BattleAnimation
 {
 	std::string soundName;
+	int effectFlags;
+	float transparencyFactor;
 	bool effectFinished;
 	bool reversed;
-	int effectFlags;
 
 	std::shared_ptr<CAnimation>	animation;
 	std::vector<Point> positions;
@@ -335,14 +336,14 @@
 	};
 
 	/// Create animation with screen-wide effect
-	EffectAnimation(BattleInterface & owner, const AnimationPath & animationName, int effects = 0, bool reversed = false);
+	EffectAnimation(BattleInterface & owner, const AnimationPath & animationName, int effects = 0, float transparencyFactor = 1.f, bool reversed = false);
 
 	/// Create animation positioned at point(s). Note that positions must be are absolute, including battleint position offset
 	EffectAnimation(BattleInterface & owner, const AnimationPath & animationName, Point pos                 , int effects = 0, bool reversed = false);
 	EffectAnimation(BattleInterface & owner, const AnimationPath & animationName, std::vector<Point> pos    , int effects = 0, bool reversed = false);
 
 	/// Create animation positioned at certain hex(es)
-	EffectAnimation(BattleInterface & owner, const AnimationPath & animationName, BattleHex hex             , int effects = 0, bool reversed = false);
+	EffectAnimation(BattleInterface & owner, const AnimationPath & animationName, BattleHex hex             , int effects = 0, float transparencyFactor = 1.0f, bool reversed = false);
 	EffectAnimation(BattleInterface & owner, const AnimationPath & animationName, std::vector<BattleHex> hex, int effects = 0, bool reversed = false);
 
 	EffectAnimation(BattleInterface & owner, const AnimationPath & animationName, Point pos, BattleHex hex,   int effects = 0, bool reversed = false);
diff --color -urN vcmi-1.5.7/client/battle/BattleEffectsController.cpp vcmi/client/battle/BattleEffectsController.cpp
--- vcmi-1.5.7/client/battle/BattleEffectsController.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/battle/BattleEffectsController.cpp	2024-12-19 15:00:22.245120952 +0100
@@ -18,9 +18,9 @@
 #include "BattleStacksController.h"
 #include "BattleRenderer.h"
 
-#include "../CMusicHandler.h"
 #include "../CGameInfo.h"
 #include "../CPlayerInterface.h"
+#include "../media/ISoundPlayer.h"
 #include "../render/Canvas.h"
 #include "../render/CAnimation.h"
 #include "../render/Graphics.h"
@@ -31,7 +31,7 @@
 #include "../../lib/networkPacks/PacksForClientBattle.h"
 #include "../../lib/CStack.h"
 #include "../../lib/IGameEventsReceiver.h"
-#include "../../lib/CGeneralTextHandler.h"
+#include "../../lib/texts/CGeneralTextHandler.h"
 
 BattleEffectsController::BattleEffectsController(BattleInterface & owner):
 	owner(owner)
@@ -44,7 +44,7 @@
 	displayEffect(effect, AudioPath(), destTile);
 }
 
-void BattleEffectsController::displayEffect(EBattleEffect effect, const AudioPath & soundFile, const BattleHex & destTile)
+void BattleEffectsController::displayEffect(EBattleEffect effect, const AudioPath & soundFile, const BattleHex & destTile, float transparencyFactor)
 {
 	size_t effectID = static_cast<size_t>(effect);
 
@@ -52,7 +52,7 @@
 
 	CCS->soundh->playSound( soundFile );
 
-	owner.stacksController->addNewAnim(new EffectAnimation(owner, customAnim, destTile));
+	owner.stacksController->addNewAnim(new EffectAnimation(owner, customAnim, destTile, 0, transparencyFactor));
 }
 
 void BattleEffectsController::battleTriggerEffect(const BattleTriggerEffect & bte)
@@ -69,7 +69,7 @@
 	switch(static_cast<BonusType>(bte.effect))
 	{
 		case BonusType::HP_REGENERATION:
-			displayEffect(EBattleEffect::REGENERATION, AudioPath::builtin("REGENER"), stack->getPosition());
+			displayEffect(EBattleEffect::REGENERATION, AudioPath::builtin("REGENER"), stack->getPosition(), 0.5);
 			break;
 		case BonusType::MANA_DRAIN:
 			displayEffect(EBattleEffect::MANA_DRAIN, AudioPath::builtin("MANADRAI"), stack->getPosition());
@@ -78,7 +78,7 @@
 			displayEffect(EBattleEffect::POISON, AudioPath::builtin("POISON"), stack->getPosition());
 			break;
 		case BonusType::FEAR:
-			displayEffect(EBattleEffect::FEAR, AudioPath::builtin("FEAR"), stack->getPosition());
+			displayEffect(EBattleEffect::FEAR, AudioPath::builtin("FEAR"), stack->getPosition(), 0.5);
 			break;
 		case BonusType::MORALE:
 		{
@@ -124,6 +124,7 @@
 			currentFrame %= elem.animation->size();
 
 			auto img = elem.animation->getImage(currentFrame, static_cast<size_t>(elem.type));
+			img->setAlpha(255 * elem.transparencyFactor);
 
 			canvas.draw(img, elem.pos);
 		});
diff --color -urN vcmi-1.5.7/client/battle/BattleEffectsController.h vcmi/client/battle/BattleEffectsController.h
--- vcmi-1.5.7/client/battle/BattleEffectsController.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/battle/BattleEffectsController.h	2024-12-19 15:00:22.245120952 +0100
@@ -39,7 +39,8 @@
 
 	AnimType type;
 	Point pos; //position on the screen
-	float currentFrame;
+	float currentFrame = 0.0;
+	float transparencyFactor = 1.0;
 	std::shared_ptr<CAnimation> animation;
 	int effectID; //uniqueID equal ot ID of appropriate CSpellEffectAnim
 	BattleHex tile; //Indicates if effect which hex the effect is drawn on
@@ -65,7 +66,7 @@
 
 	//displays custom effect on the battlefield
 	void displayEffect(EBattleEffect effect, const BattleHex & destTile);
-	void displayEffect(EBattleEffect effect, const AudioPath & soundFile, const BattleHex & destTile);
+	void displayEffect(EBattleEffect effect, const AudioPath & soundFile, const BattleHex & destTile, float transparencyFactor = 1.f);
 
 	void battleTriggerEffect(const BattleTriggerEffect & bte);
 
diff --color -urN vcmi-1.5.7/client/battle/BattleFieldController.cpp vcmi/client/battle/BattleFieldController.cpp
--- vcmi-1.5.7/client/battle/BattleFieldController.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/battle/BattleFieldController.cpp	2024-12-19 15:00:22.246120993 +0100
@@ -82,67 +82,47 @@
 	};
 }
 
-std::map<int, int> hexEdgeMaskToFrameIndex;
-
-// Maps HexEdgesMask to "Frame" indexes for range highligt images
-void initializeHexEdgeMaskToFrameIndex()
+static const std::map<int, int> hexEdgeMaskToFrameIndex =
 {
-	hexEdgeMaskToFrameIndex[HexMasks::empty] = 0;
-
-    hexEdgeMaskToFrameIndex[HexMasks::topLeft] = 1;
-    hexEdgeMaskToFrameIndex[HexMasks::topRight] = 2;
-    hexEdgeMaskToFrameIndex[HexMasks::right] = 3;
-    hexEdgeMaskToFrameIndex[HexMasks::bottomRight] = 4;
-    hexEdgeMaskToFrameIndex[HexMasks::bottomLeft] = 5;
-    hexEdgeMaskToFrameIndex[HexMasks::left] = 6;
-
-    hexEdgeMaskToFrameIndex[HexMasks::top] = 7;
-    hexEdgeMaskToFrameIndex[HexMasks::bottom] = 8;
-
-    hexEdgeMaskToFrameIndex[HexMasks::topRightHalfCorner] = 9;
-    hexEdgeMaskToFrameIndex[HexMasks::bottomRightHalfCorner] = 10;
-    hexEdgeMaskToFrameIndex[HexMasks::bottomLeftHalfCorner] = 11;
-    hexEdgeMaskToFrameIndex[HexMasks::topLeftHalfCorner] = 12;
-
-    hexEdgeMaskToFrameIndex[HexMasks::rightTopAndBottom] = 13;
-    hexEdgeMaskToFrameIndex[HexMasks::leftTopAndBottom] = 14;
-	
-    hexEdgeMaskToFrameIndex[HexMasks::rightHalf] = 13;
-    hexEdgeMaskToFrameIndex[HexMasks::leftHalf] = 14;
-
-    hexEdgeMaskToFrameIndex[HexMasks::topRightCorner] = 15;
-    hexEdgeMaskToFrameIndex[HexMasks::bottomRightCorner] = 16;
-    hexEdgeMaskToFrameIndex[HexMasks::bottomLeftCorner] = 17;
-    hexEdgeMaskToFrameIndex[HexMasks::topLeftCorner] = 18;
-}
+    { HexMasks::empty, 0 },
+    { HexMasks::topLeft, 1 },
+    { HexMasks::topRight, 2 },
+    { HexMasks::right, 3 },
+    { HexMasks::bottomRight, 4 },
+    { HexMasks::bottomLeft, 5 },
+    { HexMasks::left, 6 },
+    { HexMasks::top, 7 },
+    { HexMasks::bottom, 8 },
+    { HexMasks::topRightHalfCorner, 9 },
+    { HexMasks::bottomRightHalfCorner, 10 },
+    { HexMasks::bottomLeftHalfCorner, 11 },
+    { HexMasks::topLeftHalfCorner, 12 },
+    { HexMasks::rightTopAndBottom, 13 },
+    { HexMasks::leftTopAndBottom, 14 },
+    { HexMasks::rightHalf, 13 },
+    { HexMasks::leftHalf, 14 },
+    { HexMasks::topRightCorner, 15 },
+    { HexMasks::bottomRightCorner, 16 },
+    { HexMasks::bottomLeftCorner, 17 },
+    { HexMasks::topLeftCorner, 18 }
+};
 
 BattleFieldController::BattleFieldController(BattleInterface & owner):
 	owner(owner)
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 
 	//preparing cells and hexes
 	cellBorder = GH.renderHandler().loadImage(ImagePath::builtin("CCELLGRD.BMP"), EImageBlitMode::COLORKEY);
-	cellShade = GH.renderHandler().loadImage(ImagePath::builtin("CCELLSHD.BMP"));
+	cellShade = GH.renderHandler().loadImage(ImagePath::builtin("CCELLSHD.BMP"), EImageBlitMode::SIMPLE);
 	cellUnitMovementHighlight = GH.renderHandler().loadImage(ImagePath::builtin("UnitMovementHighlight.PNG"), EImageBlitMode::COLORKEY);
 	cellUnitMaxMovementHighlight = GH.renderHandler().loadImage(ImagePath::builtin("UnitMaxMovementHighlight.PNG"), EImageBlitMode::COLORKEY);
 
-	attackCursors = GH.renderHandler().loadAnimation(AnimationPath::builtin("CRCOMBAT"));
-	attackCursors->preload();
-
-	spellCursors = GH.renderHandler().loadAnimation(AnimationPath::builtin("CRSPELL"));
-	spellCursors->preload();
-
-	initializeHexEdgeMaskToFrameIndex();
+	attackCursors = GH.renderHandler().loadAnimation(AnimationPath::builtin("CRCOMBAT"), EImageBlitMode::COLORKEY);
+	spellCursors = GH.renderHandler().loadAnimation(AnimationPath::builtin("CRSPELL"), EImageBlitMode::COLORKEY);
 
-	rangedFullDamageLimitImages = GH.renderHandler().loadAnimation(AnimationPath::builtin("battle/rangeHighlights/rangeHighlightsGreen.json"));
-	rangedFullDamageLimitImages->preload();
-
-	shootingRangeLimitImages = GH.renderHandler().loadAnimation(AnimationPath::builtin("battle/rangeHighlights/rangeHighlightsRed.json"));
-	shootingRangeLimitImages->preload();
-
-	flipRangeLimitImagesIntoPositions(rangedFullDamageLimitImages);
-	flipRangeLimitImagesIntoPositions(shootingRangeLimitImages);
+	rangedFullDamageLimitImages = GH.renderHandler().loadAnimation(AnimationPath::builtin("battle/rangeHighlights/rangeHighlightsGreen.json"), EImageBlitMode::COLORKEY);
+	shootingRangeLimitImages = GH.renderHandler().loadAnimation(AnimationPath::builtin("battle/rangeHighlights/rangeHighlightsRed.json"), EImageBlitMode::COLORKEY);
 
 	if(!owner.siegeController)
 	{
@@ -162,7 +142,7 @@
 	pos.w = background->width();
 	pos.h = background->height();
 
-	backgroundWithHexes = std::make_unique<Canvas>(Point(background->width(), background->height()));
+	backgroundWithHexes = std::make_unique<Canvas>(Point(background->width(), background->height()), CanvasScalingPolicy::AUTO);
 
 	updateAccessibleHexes();
 	addUsedEvents(LCLICK | SHOW_POPUP | MOVE | TIME | GESTURE);
@@ -176,7 +156,7 @@
 
 void BattleFieldController::createHeroes()
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 
 	// create heroes as part of our constructor for correct positioning inside battlefield
 	if(owner.attackingHeroInstance)
@@ -376,9 +356,6 @@
 	std::set<BattleHex> result;
 	auto hoveredHex = getHoveredHex();
 
-	if(!settings["battle"]["mouseShadow"].Bool())
-		return result;
-
 	const spells::Caster *caster = nullptr;
 	const CSpell *spell = nullptr;
 
@@ -542,38 +519,18 @@
 			mask.set(direction);
 
 		uint8_t imageKey = static_cast<uint8_t>(mask.to_ulong());
-		output.push_back(limitImages->getImage(hexEdgeMaskToFrameIndex[imageKey]));
+		output.push_back(limitImages->getImage(hexEdgeMaskToFrameIndex.at(imageKey)));
 	}
 
 	return output;
 }
 
-void BattleFieldController::calculateRangeLimitAndHighlightImages(uint8_t distance, std::shared_ptr<CAnimation> rangeLimitImages, std::vector<BattleHex> & rangeLimitHexes, std::vector<std::shared_ptr<IImage>> & rangeLimitHexesHighligts)
+void BattleFieldController::calculateRangeLimitAndHighlightImages(uint8_t distance, std::shared_ptr<CAnimation> rangeLimitImages, std::vector<BattleHex> & rangeLimitHexes, std::vector<std::shared_ptr<IImage>> & rangeLimitHexesHighlights)
 {
 		std::vector<BattleHex> rangeHexes = getRangeHexes(hoveredHex, distance);
 		rangeLimitHexes = getRangeLimitHexes(hoveredHex, rangeHexes, distance);
 		std::vector<std::vector<BattleHex::EDir>> rangeLimitNeighbourDirections = getOutsideNeighbourDirectionsForLimitHexes(rangeHexes, rangeLimitHexes);
-		rangeLimitHexesHighligts = calculateRangeLimitHighlightImages(rangeLimitNeighbourDirections, rangeLimitImages);
-}
-
-void BattleFieldController::flipRangeLimitImagesIntoPositions(std::shared_ptr<CAnimation> images)
-{
-	images->getImage(hexEdgeMaskToFrameIndex[HexMasks::topRight])->verticalFlip();
-	images->getImage(hexEdgeMaskToFrameIndex[HexMasks::right])->verticalFlip();
-	images->getImage(hexEdgeMaskToFrameIndex[HexMasks::bottomRight])->doubleFlip();
-	images->getImage(hexEdgeMaskToFrameIndex[HexMasks::bottomLeft])->horizontalFlip();
-
-	images->getImage(hexEdgeMaskToFrameIndex[HexMasks::bottom])->horizontalFlip();
-
-	images->getImage(hexEdgeMaskToFrameIndex[HexMasks::topRightHalfCorner])->verticalFlip();
-	images->getImage(hexEdgeMaskToFrameIndex[HexMasks::bottomRightHalfCorner])->doubleFlip();
-	images->getImage(hexEdgeMaskToFrameIndex[HexMasks::bottomLeftHalfCorner])->horizontalFlip();
-
-	images->getImage(hexEdgeMaskToFrameIndex[HexMasks::rightHalf])->verticalFlip();
-
-	images->getImage(hexEdgeMaskToFrameIndex[HexMasks::topRightCorner])->verticalFlip();
-	images->getImage(hexEdgeMaskToFrameIndex[HexMasks::bottomRightCorner])->doubleFlip();
-	images->getImage(hexEdgeMaskToFrameIndex[HexMasks::bottomLeftCorner])->horizontalFlip();
+		rangeLimitHexesHighlights = calculateRangeLimitHighlightImages(rangeLimitNeighbourDirections, rangeLimitImages);
 }
 
 void BattleFieldController::showHighlightedHexes(Canvas & canvas)
@@ -581,14 +538,16 @@
 	std::vector<BattleHex> rangedFullDamageLimitHexes;
 	std::vector<BattleHex> shootingRangeLimitHexes;
 
-	std::vector<std::shared_ptr<IImage>> rangedFullDamageLimitHexesHighligts;
-	std::vector<std::shared_ptr<IImage>> shootingRangeLimitHexesHighligts;
+	std::vector<std::shared_ptr<IImage>> rangedFullDamageLimitHexesHighlights;
+	std::vector<std::shared_ptr<IImage>> shootingRangeLimitHexesHighlights;
 
 	std::set<BattleHex> hoveredStackMovementRangeHexes = getMovementRangeForHoveredStack();
 	std::set<BattleHex> hoveredSpellHexes = getHighlightedHexesForSpellRange();
 	std::set<BattleHex> hoveredMoveHexes  = getHighlightedHexesForMovementTarget();
 
 	BattleHex hoveredHex = getHoveredHex();
+	std::set<BattleHex> hoveredMouseHex = hoveredHex.isValid() ? std::set<BattleHex>({ hoveredHex }) : std::set<BattleHex>();
+
 	const CStack * hoveredStack = getHoveredStack();
 	if(!hoveredStack && hoveredHex == BattleHex::INVALID)
 		return;
@@ -598,14 +557,19 @@
 	{
 		// calculate array with highlight images for ranged full damage limit
 		auto rangedFullDamageDistance = hoveredStack->getRangedFullDamageDistance();
-		calculateRangeLimitAndHighlightImages(rangedFullDamageDistance, rangedFullDamageLimitImages, rangedFullDamageLimitHexes, rangedFullDamageLimitHexesHighligts);
+		calculateRangeLimitAndHighlightImages(rangedFullDamageDistance, rangedFullDamageLimitImages, rangedFullDamageLimitHexes, rangedFullDamageLimitHexesHighlights);
 
 		// calculate array with highlight images for shooting range limit
 		auto shootingRangeDistance = hoveredStack->getShootingRangeDistance();
-		calculateRangeLimitAndHighlightImages(shootingRangeDistance, shootingRangeLimitImages, shootingRangeLimitHexes, shootingRangeLimitHexesHighligts);
+		calculateRangeLimitAndHighlightImages(shootingRangeDistance, shootingRangeLimitImages, shootingRangeLimitHexes, shootingRangeLimitHexesHighlights);
 	}
 
-	auto const & hoveredMouseHexes = hoveredHex != BattleHex::INVALID && owner.actionsController->currentActionSpellcasting(getHoveredHex()) ? hoveredSpellHexes : hoveredMoveHexes;
+	bool useSpellRangeForMouse = hoveredHex != BattleHex::INVALID
+		&& (owner.actionsController->currentActionSpellcasting(getHoveredHex())
+			|| owner.actionsController->creatureSpellcastingModeActive()); //at least shooting with SPELL_LIKE_ATTACK can operate in spellcasting mode without being actual spellcast
+	bool useMoveRangeForMouse = !hoveredMoveHexes.empty() || !settings["battle"]["mouseShadow"].Bool();
+
+	const auto & hoveredMouseHexes = useSpellRangeForMouse ? hoveredSpellHexes : ( useMoveRangeForMouse ? hoveredMoveHexes : hoveredMouseHex);
 
 	for(int hex = 0; hex < GameConstants::BFIELD_SIZE; ++hex)
 	{
@@ -635,11 +599,11 @@
 		}
 		if(hexInRangedFullDamageLimit)
 		{
-			showHighlightedHex(canvas, rangedFullDamageLimitHexesHighligts[hexIndexInRangedFullDamageLimit], hex, false);
+			showHighlightedHex(canvas, rangedFullDamageLimitHexesHighlights[hexIndexInRangedFullDamageLimit], hex, false);
 		}
 		if(hexInShootingRangeLimit)
 		{
-			showHighlightedHex(canvas, shootingRangeLimitHexesHighligts[hexIndexInShootingRangeLimit], hex, false);
+			showHighlightedHex(canvas, shootingRangeLimitHexesHighlights[hexIndexInShootingRangeLimit], hex, false);
 		}
 	}
 }
@@ -865,7 +829,7 @@
 
 void BattleFieldController::updateAccessibleHexes()
 {
-	auto accessibility = owner.getBattle()->getAccesibility();
+	auto accessibility = owner.getBattle()->getAccessibility();
 
 	for(int i = 0; i < accessibility.size(); i++)
 		stackCountOutsideHexes[i] = (accessibility[i] == EAccessibility::ACCESSIBLE || (accessibility[i] == EAccessibility::SIDE_COLUMN));
diff --color -urN vcmi-1.5.7/client/battle/BattleFieldController.h vcmi/client/battle/BattleFieldController.h
--- vcmi-1.5.7/client/battle/BattleFieldController.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/battle/BattleFieldController.h	2024-12-19 15:00:22.246120993 +0100
@@ -73,7 +73,7 @@
 	/// calculate if a hex is in range limit and return its index in range
 	bool IsHexInRangeLimit(BattleHex hex, std::vector<BattleHex> & rangeLimitHexes, int * hexIndexInRangeLimit);
 
-	/// get an array that has for each hex in range, an aray with all directions where an ouside neighbour hex exists
+	/// get an array that has for each hex in range, an array with all directions where an outside neighbour hex exists
 	std::vector<std::vector<BattleHex::EDir>> getOutsideNeighbourDirectionsForLimitHexes(std::vector<BattleHex> rangeHexes, std::vector<BattleHex> rangeLimitHexes);
 
 	/// calculates what image to use as range limit, depending on the direction of neighbors
@@ -82,10 +82,7 @@
 	std::vector<std::shared_ptr<IImage>> calculateRangeLimitHighlightImages(std::vector<std::vector<BattleHex::EDir>> hexesNeighbourDirections, std::shared_ptr<CAnimation> limitImages);
 
 	/// calculates all hexes for a range limit and what images to be shown as highlight for each of the hexes
-	void calculateRangeLimitAndHighlightImages(uint8_t distance, std::shared_ptr<CAnimation> rangeLimitImages, std::vector<BattleHex> & rangeLimitHexes, std::vector<std::shared_ptr<IImage>> & rangeLimitHexesHighligts);
-
-	/// to reduce the number of source images used, some images will be used as flipped versions of preloaded ones
-	void flipRangeLimitImagesIntoPositions(std::shared_ptr<CAnimation> images);
+	void calculateRangeLimitAndHighlightImages(uint8_t distance, std::shared_ptr<CAnimation> rangeLimitImages, std::vector<BattleHex> & rangeLimitHexes, std::vector<std::shared_ptr<IImage>> & rangeLimitHexesHighlights);
 
 	void showBackground(Canvas & canvas);
 	void showBackgroundImage(Canvas & canvas);
diff --color -urN vcmi-1.5.7/client/battle/BattleInterfaceClasses.cpp vcmi/client/battle/BattleInterfaceClasses.cpp
--- vcmi-1.5.7/client/battle/BattleInterfaceClasses.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/battle/BattleInterfaceClasses.cpp	2024-12-19 15:00:22.247121034 +0100
@@ -19,42 +19,47 @@
 #include "BattleWindow.h"
 
 #include "../CGameInfo.h"
-#include "../CMusicHandler.h"
 #include "../CPlayerInterface.h"
-#include "../CVideoHandler.h"
 #include "../gui/CursorHandler.h"
 #include "../gui/CGuiHandler.h"
 #include "../gui/Shortcut.h"
 #include "../gui/MouseButton.h"
 #include "../gui/WindowHandler.h"
+#include "../media/IMusicPlayer.h"
 #include "../render/Canvas.h"
 #include "../render/IImage.h"
 #include "../render/IFont.h"
 #include "../render/Graphics.h"
 #include "../widgets/Buttons.h"
+#include "../widgets/CComponent.h"
 #include "../widgets/Images.h"
 #include "../widgets/Slider.h"
 #include "../widgets/TextControls.h"
+#include "../widgets/VideoWidget.h"
 #include "../widgets/GraphicalPrimitiveCanvas.h"
 #include "../windows/CMessage.h"
 #include "../windows/CCreatureWindow.h"
 #include "../windows/CSpellWindow.h"
+#include "../windows/InfoWindows.h"
 #include "../render/CAnimation.h"
 #include "../render/IRenderHandler.h"
 #include "../adventureMap/CInGameConsole.h"
+#include "../eventsSDL/InputHandler.h"
 
 #include "../../CCallback.h"
 #include "../../lib/CStack.h"
 #include "../../lib/CConfigHandler.h"
 #include "../../lib/CCreatureHandler.h"
+#include "../../lib/entities/hero/CHeroClass.h"
+#include "../../lib/entities/hero/CHero.h"
 #include "../../lib/gameState/InfoAboutArmy.h"
-#include "../../lib/CGeneralTextHandler.h"
-#include "../../lib/CTownHandler.h"
-#include "../../lib/CHeroHandler.h"
+#include "../../lib/texts/CGeneralTextHandler.h"
+#include "../../lib/texts/TextOperations.h"
 #include "../../lib/StartInfo.h"
 #include "../../lib/mapObjects/CGTownInstance.h"
 #include "../../lib/networkPacks/PacksForClientBattle.h"
-#include "../../lib/TextOperations.h"
+#include "../../lib/json/JsonUtils.h"
+
 
 void BattleConsole::showAll(Canvas & to)
 {
@@ -72,7 +77,7 @@
 		to.drawText(line2, FONT_SMALL, Colors::WHITE, ETextAlignment::CENTER, visibleText[1]);
 }
 
-std::vector<std::string> BattleConsole::getVisibleText()
+std::vector<std::string> BattleConsole::getVisibleText() const
 {
 	// high priority texts that hide battle log entries
 	for(const auto & text : {consoleText, hoverText})
@@ -108,9 +113,10 @@
 
 	boost::split(lines, text, boost::is_any_of("\n"));
 
+	const auto & font = GH.renderHandler().loadFont(FONT_SMALL);
 	for(const auto & line : lines)
 	{
-		if (graphics->fonts[FONT_SMALL]->getStringWidth(text) < pos.w)
+		if (font->getStringWidth(text) < pos.w)
 		{
 			output.push_back(line);
 		}
@@ -154,7 +160,7 @@
 	, scrollPosition(-1)
 	, enteringText(false)
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 	pos += objectPos;
 	pos.w = size.x;
 	pos.h = size.y;
@@ -223,7 +229,7 @@
 BattleConsoleWindow::BattleConsoleWindow(const std::string & text)
 	: CWindowObject(BORDERED)
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 
 	pos.w = 429;
 	pos.h = 434;
@@ -323,7 +329,7 @@
 
 void BattleHero::heroLeftClicked()
 {
-	if(owner.actionsController->spellcastingModeActive()) //we are casting a spell
+	if(owner.actionsController->heroSpellcastingModeActive()) //we are casting a spell
 		return;
 
 	if(!hero || !owner.makingTurn())
@@ -384,16 +390,15 @@
 {
 	AnimationPath animationPath;
 
-	if(!hero->type->battleImage.empty())
-		animationPath = hero->type->battleImage;
+	if(!hero->getHeroType()->battleImage.empty())
+		animationPath = hero->getHeroType()->battleImage;
 	else
 	if(hero->gender == EHeroGender::FEMALE)
-		animationPath = hero->type->heroClass->imageBattleFemale;
+		animationPath = hero->getHeroClass()->imageBattleFemale;
 	else
-		animationPath = hero->type->heroClass->imageBattleMale;
+		animationPath = hero->getHeroClass()->imageBattleMale;
 
-	animation = GH.renderHandler().loadAnimation(animationPath);
-	animation->preload();
+	animation = GH.renderHandler().loadAnimation(animationPath, EImageBlitMode::WITH_SHADOW);
 
 	pos.w = 64;
 	pos.h = 136;
@@ -404,11 +409,10 @@
 		animation->verticalFlip();
 
 	if(defender)
-		flagAnimation = GH.renderHandler().loadAnimation(AnimationPath::builtin("CMFLAGR"));
+		flagAnimation = GH.renderHandler().loadAnimation(AnimationPath::builtin("CMFLAGR"), EImageBlitMode::COLORKEY);
 	else
-		flagAnimation = GH.renderHandler().loadAnimation(AnimationPath::builtin("CMFLAGL"));
+		flagAnimation = GH.renderHandler().loadAnimation(AnimationPath::builtin("CMFLAGL"), EImageBlitMode::COLORKEY);
 
-	flagAnimation->preload();
 	flagAnimation->playerColored(hero->tempOwner);
 
 	switchToNextPhase();
@@ -417,18 +421,137 @@
 	addUsedEvents(TIME);
 }
 
+QuickSpellPanel::QuickSpellPanel(BattleInterface & owner)
+	: CIntObject(0), owner(owner)
+{
+	OBJECT_CONSTRUCTION;
+
+	addUsedEvents(LCLICK | SHOW_POPUP | MOVE | INPUT_MODE_CHANGE);
+
+	pos = Rect(0, 0, 52, 600);
+	background = std::make_shared<CFilledTexture>(ImagePath::builtin("DIBOXBCK"), pos);
+	rect = std::make_shared<TransparentFilledRectangle>(Rect(0, 0, pos.w + 1, pos.h + 1), ColorRGBA(0, 0, 0, 0), ColorRGBA(241, 216, 120, 255));
+
+	create();
+}
+
+std::vector<std::tuple<SpellID, bool>> QuickSpellPanel::getSpells() const
+{
+	std::vector<SpellID> spellIds;
+	std::vector<bool> spellIdsFromSetting;
+	for(int i = 0; i < QUICKSPELL_SLOTS; i++)
+	{
+		std::string spellIdentifier = persistentStorage["quickSpell"][std::to_string(i)].String();
+		SpellID id;
+		try
+		{
+			id = SpellID::decode(spellIdentifier);
+		}
+		catch(const IdentifierResolutionException& e)
+		{
+			id = SpellID::NONE;
+		}	
+		spellIds.push_back(id);	
+		spellIdsFromSetting.push_back(id != SpellID::NONE);	
+	}
+
+	// autofill empty slots with spells if possible
+	auto hero = owner.getBattle()->battleGetMyHero();
+	for(int i = 0; i < QUICKSPELL_SLOTS; i++)
+	{
+		if(spellIds[i] != SpellID::NONE)
+			continue;
+
+		for(const auto & availableSpellID : CGI->spellh->getDefaultAllowed())
+		{
+			const auto * availableSpell = availableSpellID.toSpell();
+			if(!availableSpell->isAdventure() && !availableSpell->isCreatureAbility() && hero->canCastThisSpell(availableSpell) && !vstd::contains(spellIds, availableSpell->getId()))
+			{
+				spellIds[i] = availableSpell->getId();
+				break;
+			}	
+		}
+	}
+
+	std::vector<std::tuple<SpellID, bool>> ret;
+	for(int i = 0; i < QUICKSPELL_SLOTS; i++)
+		ret.push_back(std::make_tuple(spellIds[i], spellIdsFromSetting[i]));
+	return ret;
+}
+
+void QuickSpellPanel::create()
+{
+	OBJECT_CONSTRUCTION;
+
+	const JsonNode config = JsonUtils::assembleFromFiles("config/shortcutsConfig");
+
+	labels.clear();
+	buttons.clear();
+	buttonsDisabled.clear();
+
+	auto hero = owner.getBattle()->battleGetMyHero();
+	if(!hero)
+		return;
+
+	auto spells = getSpells();
+	for(int i = 0; i < QUICKSPELL_SLOTS; i++) {
+		SpellID id;
+		bool fromSettings;
+		std::tie(id, fromSettings) = spells[i];
+
+		auto button = std::make_shared<CButton>(Point(2, 7 + 50 * i), AnimationPath::builtin("spellint"), CButton::tooltip(), [this, id, hero](){
+			if(id.hasValue() && id.toSpell()->canBeCast(owner.getBattle().get(), spells::Mode::HERO, hero))
+			{
+				owner.castThisSpell(id);
+			}
+		});
+		button->setOverlay(std::make_shared<CAnimImage>(AnimationPath::builtin("spellint"), id != SpellID::NONE ? id.num + 1 : 0));
+		button->addPopupCallback([this, i, hero](){
+			GH.input().hapticFeedback();
+			GH.windows().createAndPushWindow<CSpellWindow>(hero, owner.curInt.get(), true, [this, i](SpellID spell){
+				Settings configID = persistentStorage.write["quickSpell"][std::to_string(i)];
+				configID->String() = spell == SpellID::NONE ? "" : spell.toSpell()->identifier;
+				create();
+			});
+		});
+
+		if(fromSettings)
+			buttonsIsAutoGenerated.push_back(std::make_shared<TransparentFilledRectangle>(Rect(45, 37 + 50 * i, 5, 5), Colors::ORANGE));
+
+		if(!id.hasValue() || !id.toSpell()->canBeCast(owner.getBattle().get(), spells::Mode::HERO, hero))
+		{
+			buttonsDisabled.push_back(std::make_shared<TransparentFilledRectangle>(Rect(2, 7 + 50 * i, 48, 36), ColorRGBA(0, 0, 0, 172)));
+		}
+		if(GH.input().getCurrentInputMode() == InputMode::KEYBOARD_AND_MOUSE)
+			labels.push_back(std::make_shared<CLabel>(7, 10 + 50 * i, EFonts::FONT_TINY, ETextAlignment::TOPLEFT, Colors::WHITE, config["keyboard"]["battleSpellShortcut" + std::to_string(i)].String()));
+
+		buttons.push_back(button);
+	}
+}
+
+void QuickSpellPanel::show(Canvas & to)
+{
+	showAll(to);
+	CIntObject::show(to);
+}
+
+void QuickSpellPanel::inputModeChanged(InputMode modi)
+{
+	create();
+	redraw();
+}
+
 HeroInfoBasicPanel::HeroInfoBasicPanel(const InfoAboutHero & hero, Point * position, bool initializeBackground)
 	: CIntObject(0)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	if (position != nullptr)
 		moveTo(*position);
 
 	if(initializeBackground)
 	{
 		background = std::make_shared<CPicture>(ImagePath::builtin("CHRPOP"));
-		background->getSurface()->setBlitMode(EImageBlitMode::OPAQUE);
-		background->colorize(hero.owner);
+		background->setPlayerColor(hero.owner);
 	}
 
 	initializeData(hero);
@@ -436,7 +559,7 @@
 
 void HeroInfoBasicPanel::initializeData(const InfoAboutHero & hero)
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 	auto attack = hero.details->primskills[0];
 	auto defense = hero.details->primskills[1];
 	auto power = hero.details->primskills[2];
@@ -489,17 +612,15 @@
 StackInfoBasicPanel::StackInfoBasicPanel(const CStack * stack, bool initializeBackground)
 	: CIntObject(0)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	if(initializeBackground)
 	{
 		background = std::make_shared<CPicture>(ImagePath::builtin("CCRPOP"));
 		background->pos.y += 37;
-		background->getSurface()->setBlitMode(EImageBlitMode::OPAQUE);
-		background->colorize(stack->getOwner());
+		background->setPlayerColor(stack->getOwner());
 		background2 = std::make_shared<CPicture>(ImagePath::builtin("CHRPOP"));
-		background2->getSurface()->setBlitMode(EImageBlitMode::OPAQUE);
-		background2->colorize(stack->getOwner());
+		background2->setPlayerColor(stack->getOwner());
 	}
 
 	initializeData(stack);
@@ -507,7 +628,7 @@
 
 void StackInfoBasicPanel::initializeData(const CStack * stack)
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 
 	icons.push_back(std::make_shared<CAnimImage>(AnimationPath::builtin("TWCRPORT"), stack->creatureId() + 2, 0, 10, 6));
 	labels.push_back(std::make_shared<CLabel>(10 + 58, 6 + 64, FONT_MEDIUM, ETextAlignment::BOTTOMRIGHT, Colors::WHITE, TextOperations::formatMetric(stack->getCount(), 4)));
@@ -599,22 +720,22 @@
 HeroInfoWindow::HeroInfoWindow(const InfoAboutHero & hero, Point * position)
 	: CWindowObject(RCLICK_POPUP | SHADOW_DISABLED, ImagePath::builtin("CHRPOP"))
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	if (position != nullptr)
 		moveTo(*position);
 
-	background->colorize(hero.owner); //maybe add this functionality to base class?
+	background->setPlayerColor(hero.owner); //maybe add this functionality to base class?
 
 	content = std::make_shared<HeroInfoBasicPanel>(hero, nullptr, false);
 }
 
 BattleResultWindow::BattleResultWindow(const BattleResult & br, CPlayerInterface & _owner, bool allowReplay)
-	: owner(_owner), currentVideo(BattleResultVideo::NONE)
+	: owner(_owner)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	background = std::make_shared<CPicture>(ImagePath::builtin("CPRESULT"));
-	background->colorize(owner.playerID);
+	background->setPlayerColor(owner.playerID);
 	pos = center(background->pos);
 
 	exit = std::make_shared<CButton>(Point(384, 505), AnimationPath::builtin("iok6432.def"), std::make_pair("", ""), [&](){ bExitf();}, EShortcut::GLOBAL_ACCEPT);
@@ -627,7 +748,7 @@
 		labels.push_back(std::make_shared<CLabel>(232, 520, FONT_MEDIUM, ETextAlignment::CENTER, Colors::WHITE, CGI->generaltexth->translate("vcmi.battleResultsWindow.applyResultsLabel")));
 	}
 
-	if(br.winner == 0) //attacker won
+	if(br.winner == BattleSide::ATTACKER)
 	{
 		labels.push_back(std::make_shared<CLabel>(59, 124, FONT_SMALL, ETextAlignment::CENTER, Colors::WHITE, CGI->generaltexth->allTexts[410]));
 	}
@@ -635,8 +756,8 @@
 	{
 		labels.push_back(std::make_shared<CLabel>(59, 124, FONT_SMALL, ETextAlignment::CENTER, Colors::WHITE, CGI->generaltexth->allTexts[411]));
 	}
-
-	if(br.winner == 1)
+	
+	if(br.winner == BattleSide::DEFENDER)
 	{
 		labels.push_back(std::make_shared<CLabel>(412, 124, FONT_SMALL, ETextAlignment::CENTER, Colors::WHITE, CGI->generaltexth->allTexts[410]));
 	}
@@ -651,15 +772,15 @@
 
 	std::string sideNames[2] = {"N/A", "N/A"};
 
-	for(int i = 0; i < 2; i++)
+	for(auto i : {BattleSide::ATTACKER, BattleSide::DEFENDER})
 	{
 		auto heroInfo = owner.cb->getBattle(br.battleID)->battleGetHeroInfo(i);
 		const int xs[] = {21, 392};
 
 		if(heroInfo.portraitSource.isValid()) //attacking hero
 		{
-			icons.push_back(std::make_shared<CAnimImage>(AnimationPath::builtin("PortraitsLarge"), heroInfo.getIconIndex(), 0, xs[i], 38));
-			sideNames[i] = heroInfo.name;
+			icons.push_back(std::make_shared<CAnimImage>(AnimationPath::builtin("PortraitsLarge"), heroInfo.getIconIndex(), 0, xs[static_cast<int>(i)], 38));
+			sideNames[static_cast<int>(i)] = heroInfo.name;
 		}
 		else
 		{
@@ -676,8 +797,8 @@
 
 			if(best != stacks.end()) //should be always but to be safe...
 			{
-				icons.push_back(std::make_shared<CAnimImage>(AnimationPath::builtin("TWCRPORT"), (*best)->unitType()->getIconIndex(), 0, xs[i], 38));
-				sideNames[i] = (*best)->unitType()->getNamePluralTranslated();
+				icons.push_back(std::make_shared<CAnimImage>(AnimationPath::builtin("TWCRPORT"), (*best)->unitType()->getIconIndex(), 0, xs[static_cast<int>(i)], 38));
+				sideNames[static_cast<int>(i)] = (*best)->unitType()->getNamePluralTranslated();
 			}
 		}
 	}
@@ -687,16 +808,16 @@
 	labels.push_back(std::make_shared<CLabel>(381, 53, FONT_SMALL, ETextAlignment::BOTTOMRIGHT, Colors::WHITE, sideNames[1]));
 
 	//printing casualties
-	for(int step = 0; step < 2; ++step)
+	for(auto step : {BattleSide::ATTACKER, BattleSide::DEFENDER})
 	{
 		if(br.casualties[step].size()==0)
 		{
-			labels.push_back(std::make_shared<CLabel>(235, 360 + 97 * step, FONT_SMALL, ETextAlignment::CENTER, Colors::WHITE, CGI->generaltexth->allTexts[523]));
+			labels.push_back(std::make_shared<CLabel>(235, 360 + 97 * static_cast<int>(step), FONT_SMALL, ETextAlignment::CENTER, Colors::WHITE, CGI->generaltexth->allTexts[523]));
 		}
 		else
 		{
 			int xPos = 235 - ((int)br.casualties[step].size()*32 + ((int)br.casualties[step].size() - 1)*10)/2; //increment by 42 with each picture
-			int yPos = 344 + step * 97;
+			int yPos = 344 + static_cast<int>(step) * 97;
 			for(auto & elem : br.casualties[step])
 			{
 				auto creature = CGI->creatures()->getByIndex(elem.first);
@@ -711,68 +832,98 @@
 			}
 		}
 	}
+
+	auto resources = getResources(br);
+
+	description = std::make_shared<CTextBox>(resources.resultText.toString(), Rect(69, 203, 330, 68), 0, FONT_SMALL, ETextAlignment::CENTER, Colors::WHITE);
+	videoPlayer = std::make_shared<VideoWidget>(Point(107, 70), resources.prologueVideo, resources.loopedVideo, false);
+
+	CCS->musich->playMusic(resources.musicName, false, true);
+}
+
+BattleResultResources BattleResultWindow::getResources(const BattleResult & br)
+{
 	//printing result description
-	bool weAreAttacker = !(owner.cb->getBattle(br.battleID)->battleGetMySide());
-	if((br.winner == 0 && weAreAttacker) || (br.winner == 1 && !weAreAttacker)) //we've won
+	bool weAreAttacker = owner.cb->getBattle(br.battleID)->battleGetMySide() == BattleSide::ATTACKER;
+	bool weAreDefender = !weAreAttacker;
+	bool weWon = (br.winner == BattleSide::ATTACKER && weAreAttacker) || (br.winner == BattleSide::DEFENDER && !weAreAttacker);
+	bool isSiege = owner.cb->getBattle(br.battleID)->battleGetDefendedTown() != nullptr;
+
+	BattleResultResources resources;
+
+	if(weWon)
 	{
-		int text = 304;
-		currentVideo = BattleResultVideo::WIN;
+		if(isSiege && weAreDefender)
+		{
+			resources.musicName = AudioPath::builtin("Music/Defend Castle");
+			resources.prologueVideo = VideoPath::builtin("DEFENDALL.BIK");
+			resources.loopedVideo = VideoPath::builtin("defendloop.bik");
+		}
+		else
+		{
+			resources.musicName = AudioPath::builtin("Music/Win Battle");
+			resources.prologueVideo = VideoPath::builtin("WIN3.BIK");
+			resources.loopedVideo = VideoPath::builtin("WIN3.BIK");
+		}
+
 		switch(br.result)
 		{
 		case EBattleResult::NORMAL:
-			if(owner.cb->getBattle(br.battleID)->battleGetDefendedTown() && !weAreAttacker)
-				currentVideo = BattleResultVideo::WIN_SIEGE;
+			resources.resultText.appendTextID("core.genrltxt.304");
 			break;
 		case EBattleResult::ESCAPE:
-			text = 303;
+			resources.resultText.appendTextID("core.genrltxt.303");
 			break;
 		case EBattleResult::SURRENDER:
-			text = 302;
+			resources.resultText.appendTextID("core.genrltxt.302");
 			break;
 		default:
-			logGlobal->error("Invalid battle result code %d. Assumed normal.", static_cast<int>(br.result));
-			break;
+			throw std::runtime_error("Invalid battle result!");
 		}
-		playVideo();
-
-		std::string str = CGI->generaltexth->allTexts[text];
 
 		const CGHeroInstance * ourHero = owner.cb->getBattle(br.battleID)->battleGetMyHero();
 		if (ourHero)
 		{
-			str += CGI->generaltexth->allTexts[305];
-			boost::algorithm::replace_first(str, "%s", ourHero->getNameTranslated());
-			boost::algorithm::replace_first(str, "%d", std::to_string(br.exp[weAreAttacker ? 0 : 1]));
+			resources.resultText.appendTextID("core.genrltxt.305");
+			resources.resultText.replaceTextID(ourHero->getNameTranslated());
+			resources.resultText.replaceNumber(br.exp[weAreAttacker ? BattleSide::ATTACKER : BattleSide::DEFENDER]);
 		}
-
-		description = std::make_shared<CTextBox>(str, Rect(69, 203, 330, 68), 0, FONT_SMALL, ETextAlignment::CENTER, Colors::WHITE);
 	}
 	else // we lose
 	{
-		int text = 311;
-		currentVideo = BattleResultVideo::DEFEAT;
 		switch(br.result)
 		{
 		case EBattleResult::NORMAL:
-			if(owner.cb->getBattle(br.battleID)->battleGetDefendedTown() && !weAreAttacker)
-				currentVideo = BattleResultVideo::DEFEAT_SIEGE;
+			resources.resultText.appendTextID("core.genrltxt.311");
+			resources.musicName = AudioPath::builtin("Music/LoseCombat");
+			resources.prologueVideo = VideoPath::builtin("LBSTART.BIK");
+			resources.loopedVideo = VideoPath::builtin("LBLOOP.BIK");
 			break;
 		case EBattleResult::ESCAPE:
-			currentVideo = BattleResultVideo::RETREAT;
-			text = 310;
+			resources.resultText.appendTextID("core.genrltxt.310");
+			resources.musicName = AudioPath::builtin("Music/Retreat Battle");
+			resources.prologueVideo = VideoPath::builtin("RTSTART.BIK");
+			resources.loopedVideo = VideoPath::builtin("RTLOOP.BIK");
 			break;
 		case EBattleResult::SURRENDER:
-			currentVideo = BattleResultVideo::SURRENDER;
-			text = 309;
+			resources.resultText.appendTextID("core.genrltxt.309");
+			resources.musicName = AudioPath::builtin("Music/Surrender Battle");
+			resources.prologueVideo = VideoPath();
+			resources.loopedVideo = VideoPath::builtin("SURRENDER.BIK");
 			break;
 		default:
-			logGlobal->error("Invalid battle result code %d. Assumed normal.", static_cast<int>(br.result));
-			break;
+				throw std::runtime_error("Invalid battle result!");
 		}
-		playVideo();
 
-		labels.push_back(std::make_shared<CLabel>(235, 235, FONT_SMALL, ETextAlignment::CENTER, Colors::WHITE, CGI->generaltexth->allTexts[text]));
+		if(isSiege && weAreDefender)
+		{
+			resources.musicName = AudioPath::builtin("Music/LoseCastle");
+			resources.prologueVideo = VideoPath::builtin("LOSECSTL.BIK");
+			resources.loopedVideo = VideoPath::builtin("LOSECSLP.BIK");
+		}
 	}
+
+	return resources;
 }
 
 void BattleResultWindow::activate()
@@ -781,81 +932,6 @@
 	CIntObject::activate();
 }
 
-void BattleResultWindow::show(Canvas & to)
-{
-	CIntObject::show(to);
-	CCS->videoh->update(pos.x + 107, pos.y + 70, to.getInternalSurface(), true, false,
-	[&]()
-	{
-		playVideo(true);
-	});
-}
-
-void BattleResultWindow::playVideo(bool startLoop)
-{
-	AudioPath musicName = AudioPath();
-	VideoPath videoName = VideoPath();
-
-	if(!startLoop)
-	{
-		switch(currentVideo)
-		{
-			case BattleResultVideo::WIN:
-				musicName = AudioPath::builtin("Music/Win Battle");
-				videoName = VideoPath::builtin("WIN3.BIK");
-				break;
-			case BattleResultVideo::SURRENDER:
-				musicName = AudioPath::builtin("Music/Surrender Battle");
-				videoName = VideoPath::builtin("SURRENDER.BIK");
-				break;
-			case BattleResultVideo::RETREAT:
-				musicName = AudioPath::builtin("Music/Retreat Battle");
-				videoName = VideoPath::builtin("RTSTART.BIK");
-				break;
-			case BattleResultVideo::DEFEAT:
-				musicName = AudioPath::builtin("Music/LoseCombat");
-				videoName = VideoPath::builtin("LBSTART.BIK");
-				break;
-			case BattleResultVideo::DEFEAT_SIEGE:
-				musicName = AudioPath::builtin("Music/LoseCastle");
-				videoName = VideoPath::builtin("LOSECSTL.BIK");	
-				break;
-			case BattleResultVideo::WIN_SIEGE:
-				musicName = AudioPath::builtin("Music/Defend Castle");
-				videoName = VideoPath::builtin("DEFENDALL.BIK");	
-				break;
-		}
-	}
-	else
-	{
-		switch(currentVideo)
-		{
-			case BattleResultVideo::RETREAT:
-				currentVideo = BattleResultVideo::RETREAT_LOOP;
-				videoName = VideoPath::builtin("RTLOOP.BIK");
-				break;
-			case BattleResultVideo::DEFEAT:
-				currentVideo = BattleResultVideo::DEFEAT_LOOP;
-				videoName = VideoPath::builtin("LBLOOP.BIK");
-				break;
-			case BattleResultVideo::DEFEAT_SIEGE:
-				currentVideo = BattleResultVideo::DEFEAT_SIEGE_LOOP;
-				videoName = VideoPath::builtin("LOSECSLP.BIK");	
-				break;
-			case BattleResultVideo::WIN_SIEGE:
-				currentVideo = BattleResultVideo::WIN_SIEGE_LOOP;
-				videoName = VideoPath::builtin("DEFENDLOOP.BIK");	
-				break;
-		}	
-	}
-
-	if(musicName != AudioPath())
-		CCS->musich->playMusic(musicName, false, true);
-	
-	if(videoName != VideoPath())
-		CCS->videoh->open(videoName);
-}
-
 void BattleResultWindow::buttonPressed(int button)
 {
 	if (resultCallback)
@@ -871,7 +947,6 @@
 	//Result window and battle interface are gone. We requested all dialogs to be closed before opening the battle,
 	//so we can be sure that there is no dialogs left on GUI stack.
 	intTmp.showingDialog->setFree();
-	CCS->videoh->close();
 }
 
 void BattleResultWindow::bExitf()
@@ -888,7 +963,7 @@
 	: embedded(Embedded),
 	owner(owner)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	uint32_t queueSize = QUEUE_SIZE_BIG;
 
@@ -902,9 +977,6 @@
 		pos.h = 49;
 		pos.x += parent->pos.w/2 - pos.w/2;
 		pos.y += queueSmallOutside ? -queueSmallOutsideYOffset : 10;
-
-		icons = GH.renderHandler().loadAnimation(AnimationPath::builtin("CPRSMALL"));
-		stateIcons = GH.renderHandler().loadAnimation(AnimationPath::builtin("VCMI/BATTLEQUEUE/STATESSMALL"));
 	}
 	else
 	{
@@ -914,13 +986,7 @@
 		pos.y -= pos.h;
 
 		background = std::make_shared<CFilledTexture>(ImagePath::builtin("DIBOXBCK"), Rect(0, 0, pos.w, pos.h));
-
-		icons = GH.renderHandler().loadAnimation(AnimationPath::builtin("TWCRPORT"));
-		stateIcons = GH.renderHandler().loadAnimation(AnimationPath::builtin("VCMI/BATTLEQUEUE/STATESSMALL"));
-		//TODO: where use big icons?
-		//stateIcons = GH.renderHandler().loadAnimation("VCMI/BATTLEQUEUE/STATESBIG");
 	}
-	stateIcons->preload();
 
 	stackBoxes.resize(queueSize);
 	for (int i = 0; i < stackBoxes.size(); i++)
@@ -962,7 +1028,7 @@
 
 int32_t StackQueue::getSiegeShooterIconID()
 {
-	return owner.siegeController->getSiegedTown()->town->faction->getIndex();
+	return owner.siegeController->getSiegedTown()->getFactionID().getNum();
 }
 
 std::optional<uint32_t> StackQueue::getHoveredUnitIdIfAny() const
@@ -981,7 +1047,7 @@
 StackQueue::StackBox::StackBox(StackQueue * owner):
 	CIntObject(SHOW_POPUP | HOVER), owner(owner)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	background = std::make_shared<CPicture>(ImagePath::builtin(owner->embedded ? "StackQueueSmall" : "StackQueueLarge"));
 
 	pos.w = background->pos.w;
@@ -989,22 +1055,24 @@
 
 	if(owner->embedded)
 	{
-		icon = std::make_shared<CAnimImage>(owner->icons, 0, 0, 5, 2);
+		icon = std::make_shared<CAnimImage>(AnimationPath::builtin("CPRSMALL"), 0, 0, 5, 2);
 		amount = std::make_shared<CLabel>(pos.w/2, pos.h - 7, FONT_SMALL, ETextAlignment::CENTER, Colors::WHITE);
 		roundRect = std::make_shared<TransparentFilledRectangle>(Rect(0, 0, 2, 48), ColorRGBA(0, 0, 0, 255), ColorRGBA(0, 255, 0, 255));
 	}
 	else
 	{
-		icon = std::make_shared<CAnimImage>(owner->icons, 0, 0, 9, 1);
+		icon = std::make_shared<CAnimImage>(AnimationPath::builtin("TWCRPORT"), 0, 0, 9, 1);
 		amount = std::make_shared<CLabel>(pos.w/2, pos.h - 8, FONT_MEDIUM, ETextAlignment::CENTER, Colors::WHITE);
 		roundRect = std::make_shared<TransparentFilledRectangle>(Rect(0, 0, 15, 18), ColorRGBA(0, 0, 0, 255), ColorRGBA(241, 216, 120, 255));
 		round = std::make_shared<CLabel>(4, 2, FONT_SMALL, ETextAlignment::TOPLEFT, Colors::WHITE);
 
-		int icon_x = pos.w - 17;
-		int icon_y = pos.h - 18;
+		Point iconPos(pos.w - 16, pos.h - 16);
 
-		stateIcon = std::make_shared<CAnimImage>(owner->stateIcons, 0, 0, icon_x, icon_y);
-		stateIcon->visible = false;
+		defendIcon = std::make_shared<CPicture>(ImagePath::builtin("battle/QueueDefend"), iconPos);
+		waitIcon = std::make_shared<CPicture>(ImagePath::builtin("battle/QueueWait"), iconPos);
+
+		defendIcon->setEnabled(false);
+		waitIcon->setEnabled(false);
 	}
 	roundRect->disable();
 }
@@ -1014,7 +1082,7 @@
 	if(unit)
 	{
 		boundUnitID = unit->unitId();
-		background->colorize(unit->unitOwner());
+		background->setPlayerColor(unit->unitOwner());
 		icon->visible = true;
 
 		// temporary code for mod compatibility:
@@ -1034,39 +1102,33 @@
 		if(currentTurn && !owner->embedded)
 		{
 			std::string tmp = std::to_string(*currentTurn);
-			int len = graphics->fonts[FONT_SMALL]->getStringWidth(tmp);
+			const auto & font = GH.renderHandler().loadFont(FONT_SMALL);
+			int len = font->getStringWidth(tmp);
 			roundRect->pos.w = len + 6;
 			round->setText(tmp);
 		}
 
-		if(stateIcon)
+		if(!owner->embedded)
 		{
-			if(unit->defended((int)turn) || (turn > 0 && unit->defended((int)turn - 1)))
-			{
-				stateIcon->setFrame(0, 0);
-				stateIcon->visible = true;
-			}
-			else if(unit->waited((int)turn))
-			{
-				stateIcon->setFrame(1, 0);
-				stateIcon->visible = true;
-			}
-			else
-			{
-				stateIcon->visible = false;
-			}
+			bool defended = unit->defended(turn) || (turn > 0 && unit->defended(turn - 1));
+			bool waited = unit->waited(turn) && !defended;
+
+			defendIcon->setEnabled(defended);
+			waitIcon->setEnabled(waited);
 		}
 	}
 	else
 	{
 		boundUnitID = std::nullopt;
-		background->colorize(PlayerColor::NEUTRAL);
+		background->setPlayerColor(PlayerColor::NEUTRAL);
 		icon->visible = false;
 		icon->setFrame(0);
 		amount->setText("");
-
-		if(stateIcon)
-			stateIcon->visible = false;
+		if(!owner->embedded)
+		{
+			defendIcon->setEnabled(false);
+			waitIcon->setEnabled(false);
+		}
 	}
 }
 
diff --color -urN vcmi-1.5.7/client/battle/BattleInterfaceClasses.h vcmi/client/battle/BattleInterfaceClasses.h
--- vcmi-1.5.7/client/battle/BattleInterfaceClasses.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/battle/BattleInterfaceClasses.h	2024-12-19 15:00:22.247121034 +0100
@@ -13,6 +13,7 @@
 #include "../gui/CIntObject.h"
 #include "../../lib/FunctionList.h"
 #include "../../lib/battle/BattleHex.h"
+#include "../../lib/texts/MetaString.h"
 #include "../windows/CWindowObject.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
@@ -21,6 +22,7 @@
 struct BattleResult;
 struct InfoAboutHero;
 class CStack;
+class CPlayerBattleCallback;
 
 namespace battle
 {
@@ -42,6 +44,8 @@
 class TransparentFilledRectangle;
 class CPlayerInterface;
 class BattleRenderer;
+class VideoWidget;
+class QuickSpellPanel;
 
 /// Class which shows the console at the bottom of the battle screen and manages the text of the console
 class BattleConsole : public CIntObject, public IStatusBar
@@ -70,7 +74,7 @@
 	std::vector<std::string> splitText(const std::string &text);
 
 	/// select line(s) that will be visible in UI
-	std::vector<std::string> getVisibleText();
+	std::vector<std::string> getVisibleText() const;
 public:
 	BattleConsole(const BattleInterface & owner, std::shared_ptr<CPicture> backgroundSource, const Point & objectPos, const Point & imagePos, const Point &size);
 
@@ -145,6 +149,32 @@
 	BattleHero(const BattleInterface & owner, const CGHeroInstance * hero, bool defender);
 };
 
+class QuickSpellPanel : public CIntObject
+{
+private:
+	std::shared_ptr<CFilledTexture> background;
+	std::shared_ptr<TransparentFilledRectangle> rect;
+	std::vector<std::shared_ptr<CButton>> buttons;
+	std::vector<std::shared_ptr<TransparentFilledRectangle>> buttonsIsAutoGenerated;
+	std::vector<std::shared_ptr<TransparentFilledRectangle>> buttonsDisabled;
+	std::vector<std::shared_ptr<CLabel>> labels;
+
+	BattleInterface & owner;
+public:
+	int QUICKSPELL_SLOTS = 12;
+
+	bool isEnabled; // isActive() is not working on multiple conditions, because of this we need a seperate flag
+
+	QuickSpellPanel(BattleInterface & owner);
+
+	void create();
+
+	std::vector<std::tuple<SpellID, bool>> getSpells() const;
+
+	void show(Canvas & to) override;
+	void inputModeChanged(InputMode modi) override;
+};
+
 class HeroInfoBasicPanel : public CIntObject //extracted from InfoWindow to fit better as non-popup embed element
 {
 private:
@@ -185,6 +215,14 @@
 	HeroInfoWindow(const InfoAboutHero & hero, Point * position);
 };
 
+struct BattleResultResources
+{
+	VideoPath prologueVideo;
+	VideoPath loopedVideo;
+	AudioPath musicName;
+	MetaString resultText;
+};
+
 /// Class which is responsible for showing the battle result window
 class BattleResultWindow : public WindowBase
 {
@@ -195,25 +233,10 @@
 	std::shared_ptr<CButton> repeat;
 	std::vector<std::shared_ptr<CAnimImage>> icons;
 	std::shared_ptr<CTextBox> description;
+	std::shared_ptr<VideoWidget> videoPlayer;
 	CPlayerInterface & owner;
 
-	enum BattleResultVideo
-	{
-		NONE,
-		WIN,
-		SURRENDER,
-		RETREAT,
-		RETREAT_LOOP,
-		DEFEAT,
-		DEFEAT_LOOP,
-		DEFEAT_SIEGE,
-		DEFEAT_SIEGE_LOOP,
-		WIN_SIEGE,
-		WIN_SIEGE_LOOP,
-	};
-	BattleResultVideo currentVideo;
-
-	void playVideo(bool startLoop = false);
+	BattleResultResources getResources(const BattleResult & br);
 	
 	void buttonPressed(int button); //internal function for button callbacks
 public:
@@ -224,7 +247,6 @@
 	std::function<void(int result)> resultCallback; //callback receiving which button was pressed
 
 	void activate() override;
-	void show(Canvas & to) override;
 };
 
 /// Shows the stack queue
@@ -238,7 +260,8 @@
 		std::shared_ptr<CPicture> background;
 		std::shared_ptr<CAnimImage> icon;
 		std::shared_ptr<CLabel> amount;
-		std::shared_ptr<CAnimImage> stateIcon;
+		std::shared_ptr<CPicture> waitIcon;
+		std::shared_ptr<CPicture> defendIcon;
 		std::shared_ptr<CLabel> round;
 		std::shared_ptr<TransparentFilledRectangle> roundRect;
 
@@ -258,9 +281,6 @@
 	std::vector<std::shared_ptr<StackBox>> stackBoxes;
 	BattleInterface & owner;
 
-	std::shared_ptr<CAnimation> icons;
-	std::shared_ptr<CAnimation> stateIcons;
-
 	int32_t getSiegeShooterIconID();
 public:
 	const bool embedded;
diff --color -urN vcmi-1.5.7/client/battle/BattleInterface.cpp vcmi/client/battle/BattleInterface.cpp
--- vcmi-1.5.7/client/battle/BattleInterface.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/battle/BattleInterface.cpp	2024-12-19 15:00:22.246120993 +0100
@@ -24,20 +24,21 @@
 #include "BattleRenderer.h"
 
 #include "../CGameInfo.h"
-#include "../CMusicHandler.h"
 #include "../CPlayerInterface.h"
 #include "../gui/CursorHandler.h"
 #include "../gui/CGuiHandler.h"
 #include "../gui/WindowHandler.h"
+#include "../media/IMusicPlayer.h"
+#include "../media/ISoundPlayer.h"
 #include "../windows/CTutorialWindow.h"
 #include "../render/Canvas.h"
 #include "../adventureMap/AdventureMapInterface.h"
 
 #include "../../CCallback.h"
+#include "../../lib/BattleFieldHandler.h"
 #include "../../lib/CStack.h"
 #include "../../lib/CConfigHandler.h"
-#include "../../lib/CGeneralTextHandler.h"
-#include "../../lib/CHeroHandler.h"
+#include "../../lib/texts/CGeneralTextHandler.h"
 #include "../../lib/gameState/InfoAboutArmy.h"
 #include "../../lib/mapObjects/CGTownInstance.h"
 #include "../../lib/networkPacks/PacksForClientBattle.h"
@@ -83,7 +84,7 @@
 	this->army2 = army2;
 
 	const CGTownInstance *town = getBattle()->battleGetDefendedTown();
-	if(town && town->hasFort())
+	if(town && town->fortificationsLevel().wallsHealth > 0)
 		siegeController.reset(new BattleSiegeController(*this, town));
 
 	windowObject = std::make_shared<BattleWindow>(*this);
@@ -112,7 +113,23 @@
 			onIntroSoundPlayed();
 	};
 
-	int battleIntroSoundChannel = CCS->soundh->playSoundFromSet(CCS->soundh->battleIntroSounds);
+	auto bfieldType = getBattle()->battleGetBattlefieldType();
+	const auto & battlefieldSound = bfieldType.getInfo()->musicFilename;
+
+	std::vector<soundBase::soundID> battleIntroSounds =
+	{
+		soundBase::battle00, soundBase::battle01,
+		soundBase::battle02, soundBase::battle03, soundBase::battle04,
+		soundBase::battle05, soundBase::battle06, soundBase::battle07
+	};
+
+	int battleIntroSoundChannel = -1;
+
+	if (!battlefieldSound.empty())
+		battleIntroSoundChannel = CCS->soundh->playSound(battlefieldSound);
+	else
+		battleIntroSoundChannel = CCS->soundh->playSoundFromSet(battleIntroSounds);
+
 	if (battleIntroSoundChannel != -1)
 	{
 		CCS->soundh->setCallback(battleIntroSoundChannel, onIntroPlayed);
@@ -136,7 +153,13 @@
 	if (openingPlaying())
 		openingEnd();
 
-	CCS->musich->playMusicFromSet("battle", true, true);
+	auto bfieldType = getBattle()->battleGetBattlefieldType();
+	const auto & battlefieldMusic = bfieldType.getInfo()->musicFilename;
+
+	if (!battlefieldMusic.empty())
+		CCS->musich->playMusic(battlefieldMusic, true, true);
+	else
+		CCS->musich->playMusicFromSet("battle", true, true);
 }
 
 void BattleInterface::openingEnd()
@@ -205,19 +228,19 @@
 {
 	stacksController->stacksAreAttacked(attackedInfos);
 
-	std::array<int, 2> killedBySide = {0, 0};
+	BattleSideArray<int> killedBySide;
 
 	for(const StackAttackedInfo & attackedInfo : attackedInfos)
 	{
-		ui8 side = attackedInfo.defender->unitSide();
+		BattleSide side = attackedInfo.defender->unitSide();
 		killedBySide.at(side) += attackedInfo.amountKilled;
 	}
 
-	for(ui8 side = 0; side < 2; side++)
+	for(BattleSide side : { BattleSide::ATTACKER, BattleSide::DEFENDER })
 	{
-		if(killedBySide.at(side) > killedBySide.at(1-side))
+		if(killedBySide.at(side) > killedBySide.at(getBattle()->otherSide(side)))
 			setHeroAnimation(side, EHeroAnimType::DEFEAT);
-		else if(killedBySide.at(side) < killedBySide.at(1-side))
+		else if(killedBySide.at(side) < killedBySide.at(getBattle()->otherSide(side)))
 			setHeroAnimation(side, EHeroAnimType::VICTORY);
 	}
 }
@@ -247,14 +270,14 @@
 	}
 
 	auto side = getBattle()->playerToSide(curInt->playerID);
-	if(!side)
+	if(side == BattleSide::NONE)
 	{
 		logGlobal->error("Player %s is not in battle", curInt->playerID.toString());
 		return;
 	}
 
 	BattleAction ba;
-	ba.side = side.value();
+	ba.side = side;
 	ba.actionType = action;
 	ba.aimToHex(tile);
 	ba.spell = spell;
@@ -385,7 +408,7 @@
 		}
 		else
 		{
-			auto hero = sc->side ? defendingHero : attackingHero;
+			auto hero = sc->side == BattleSide::DEFENDER ? defendingHero : attackingHero;
 			assert(hero);
 
 			addToAnimationStage(EAnimationEvents::BEFORE_HIT, [=]()
@@ -442,11 +465,11 @@
 	{
 		Point leftHero = Point(15, 30);
 		Point rightHero = Point(755, 30);
-		bool side = sc->side;
+		BattleSide side = sc->side;
 
 		addToAnimationStage(EAnimationEvents::AFTER_HIT, [=](){
-			stacksController->addNewAnim(new EffectAnimation(*this, AnimationPath::builtin(side ? "SP07_A.DEF" : "SP07_B.DEF"), leftHero));
-			stacksController->addNewAnim(new EffectAnimation(*this, AnimationPath::builtin(side ? "SP07_B.DEF" : "SP07_A.DEF"), rightHero));
+			stacksController->addNewAnim(new EffectAnimation(*this, AnimationPath::builtin(side == BattleSide::DEFENDER ? "SP07_A.DEF" : "SP07_B.DEF"), leftHero));
+			stacksController->addNewAnim(new EffectAnimation(*this, AnimationPath::builtin(side == BattleSide::DEFENDER ? "SP07_B.DEF" : "SP07_A.DEF"), rightHero));
 		});
 	}
 
@@ -459,7 +482,7 @@
 		fieldController->redrawBackgroundWithHexes();
 }
 
-void BattleInterface::setHeroAnimation(ui8 side, EHeroAnimType phase)
+void BattleInterface::setHeroAnimation(BattleSide side, EHeroAnimType phase)
 {
 	if(side == BattleSide::ATTACKER)
 	{
@@ -512,9 +535,9 @@
 				flags |= EffectAnimation::SCREEN_FILL;
 
 			if (!destinationTile.isValid())
-				stacksController->addNewAnim(new EffectAnimation(*this, animation.resourceName, flags));
+				stacksController->addNewAnim(new EffectAnimation(*this, animation.resourceName, flags, animation.transparency));
 			else
-				stacksController->addNewAnim(new EffectAnimation(*this, animation.resourceName, destinationTile, flags));
+				stacksController->addNewAnim(new EffectAnimation(*this, animation.resourceName, destinationTile, flags, animation.transparency));
 		}
 	}
 }
@@ -632,7 +655,7 @@
 	tacticsMode = false;
 
 	auto side = tacticianInterface->cb->getBattle(battleID)->playerToSide(tacticianInterface->playerID);
-	auto action = BattleAction::makeEndOFTacticPhase(*side);
+	auto action = BattleAction::makeEndOFTacticPhase(side);
 
 	tacticianInterface->cb->battleMakeTacticAction(battleID, action);
 }
@@ -728,10 +751,10 @@
 			// FIXME: unsafe
 			// Run task in separate thread to avoid UI lock while AI is making turn (which might take some time)
 			// HOWEVER this thread won't atttempt to lock game state, potentially leading to races
-			boost::thread aiThread([battleID = this->battleID, curInt = this->curInt, activeStack]()
+			boost::thread aiThread([localBattleID = battleID, localCurInt = curInt, activeStack]()
 			{
 				setThreadName("autofightingAI");
-				curInt->autofightingAI->activeStack(battleID, activeStack);
+				localCurInt->autofightingAI->activeStack(localBattleID, activeStack);
 			});
 			aiThread.detach();
 		}
@@ -836,3 +859,10 @@
 	if(visible)
 		windowObject->showStickyHeroWindows();
 }
+
+void BattleInterface::setStickyQuickSpellWindowVisibility(bool visible)
+{
+	windowObject->hideStickyQuickSpellWindow();
+	if(visible)
+		windowObject->showStickyQuickSpellWindow();
+}
diff --color -urN vcmi-1.5.7/client/battle/BattleInterface.h vcmi/client/battle/BattleInterface.h
--- vcmi-1.5.7/client/battle/BattleInterface.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/battle/BattleInterface.h	2024-12-19 15:00:22.246120993 +0100
@@ -39,7 +39,6 @@
 class BattleResultWindow;
 class StackQueue;
 class CPlayerInterface;
-class CAnimation;
 struct BattleEffect;
 class IImage;
 class StackQueue;
@@ -171,7 +170,7 @@
 
 	void showInterface(Canvas & to);
 
-	void setHeroAnimation(ui8 side, EHeroAnimType phase);
+	void setHeroAnimation(BattleSide side, EHeroAnimType phase);
 
 	void executeSpellCast(); //called when a hero casts a spell
 
@@ -185,6 +184,7 @@
 
 	void setBattleQueueVisibility(bool visible);
 	void setStickyHeroWindowsVisibility(bool visible);
+	void setStickyQuickSpellWindowVisibility(bool visible);
 
 	void endNetwork();
 	void executeStagedAnimations();
@@ -206,7 +206,7 @@
 	void stacksAreAttacked(std::vector<StackAttackedInfo> attackedInfos); //called when a certain amount of stacks has been attacked
 	void stackAttacking(const StackAttackInfo & attackInfo); //called when stack with id ID is attacking something on hex dest
 	void newRoundFirst();
-	void newRound(); //caled when round is ended;
+	void newRound(); //called when round is ended;
 	void stackIsCatapulting(const CatapultAttack & ca); //called when a stack is attacking walls
 	void battleFinished(const BattleResult& br, QueryID queryID); //called when battle is finished - battleresult window should be printed
 	void spellCast(const BattleSpellCast *sc); //called when a hero casts a spell
diff --color -urN vcmi-1.5.7/client/battle/BattleObstacleController.cpp vcmi/client/battle/BattleObstacleController.cpp
--- vcmi-1.5.7/client/battle/BattleObstacleController.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/battle/BattleObstacleController.cpp	2024-12-19 15:00:22.247121034 +0100
@@ -17,10 +17,11 @@
 #include "BattleRenderer.h"
 #include "CreatureAnimation.h"
 
-#include "../CMusicHandler.h"
 #include "../CGameInfo.h"
 #include "../CPlayerInterface.h"
 #include "../gui/CGuiHandler.h"
+#include "../media/ISoundPlayer.h"
+#include "../render/CAnimation.h"
 #include "../render/Canvas.h"
 #include "../render/IRenderHandler.h"
 
@@ -46,24 +47,16 @@
 {
 	AnimationPath animationName = oi.getAnimation();
 
-	if (animationsCache.count(animationName) == 0)
+	if (oi.obstacleType == CObstacleInstance::ABSOLUTE_OBSTACLE)
 	{
-		if (oi.obstacleType == CObstacleInstance::ABSOLUTE_OBSTACLE)
-		{
-			// obstacle uses single bitmap image for animations
-			auto animation = GH.renderHandler().createAnimation();
-			animation->setCustom(animationName.getName(), 0, 0);
-			animationsCache[animationName] = animation;
-			animation->preload();
-		}
-		else
-		{
-			auto animation = GH.renderHandler().loadAnimation(animationName);
-			animationsCache[animationName] = animation;
-			animation->preload();
-		}
+		// obstacle uses single bitmap image for animations
+		obstacleImages[oi.uniqueID] = GH.renderHandler().loadImage(animationName.toType<EResType::IMAGE>(), EImageBlitMode::SIMPLE);
+	}
+	else
+	{
+		obstacleAnimations[oi.uniqueID] = GH.renderHandler().loadAnimation(animationName, EImageBlitMode::SIMPLE);
+		obstacleImages[oi.uniqueID] = obstacleAnimations[oi.uniqueID]->getImage(0);
 	}
-	obstacleAnimations[oi.uniqueID] = animationsCache[animationName];
 }
 
 void BattleObstacleController::obstacleRemoved(const std::vector<ObstacleChanges> & obstacles)
@@ -85,9 +78,7 @@
 		if(animationPath.empty())
 			continue;
 
-		auto animation = GH.renderHandler().loadAnimation(animationPath);
-		animation->preload();
-
+		auto animation = GH.renderHandler().loadAnimation(animationPath, EImageBlitMode::SIMPLE);
 		auto first = animation->getImage(0, 0);
 		if(!first)
 			continue;
@@ -99,6 +90,7 @@
 		owner.stacksController->addNewAnim(new EffectAnimation(owner, animationPath, whereTo, obstacle["position"].Integer(), 0, true));
 
 		obstacleAnimations.erase(oi.id);
+		obstacleImages.erase(oi.id);
 		//so when multiple obstacles are removed, they show up one after another
 		owner.waitForAnimations();
 	}
@@ -110,12 +102,10 @@
 	{
 		auto side = owner.getBattle()->playerToSide(owner.curInt->playerID);
 
-		if(!oi->visibleForSide(side.value(), owner.getBattle()->battleHasNativeStack(side.value())))
+		if(!oi->visibleForSide(side, owner.getBattle()->battleHasNativeStack(side)))
 			continue;
 
-		auto animation = GH.renderHandler().loadAnimation(oi->getAppearAnimation());
-		animation->preload();
-
+		auto animation = GH.renderHandler().loadAnimation(oi->getAppearAnimation(), EImageBlitMode::SIMPLE);
 		auto first = animation->getImage(0, 0);
 		if(!first)
 			continue;
@@ -187,26 +177,22 @@
 void BattleObstacleController::tick(uint32_t msPassed)
 {
 	timePassed += msPassed / 1000.f;
+	int framesCount = timePassed * AnimationControls::getObstaclesSpeed();
+
+	for(auto & animation : obstacleAnimations)
+	{
+		int frameIndex = framesCount % animation.second->size(0);
+		obstacleImages[animation.first] = animation.second->getImage(frameIndex, 0);
+	}
 }
 
 std::shared_ptr<IImage> BattleObstacleController::getObstacleImage(const CObstacleInstance & oi)
 {
-	int framesCount = timePassed * AnimationControls::getObstaclesSpeed();
-	std::shared_ptr<CAnimation> animation;
-
 	// obstacle is not loaded yet, don't show anything
-	if (obstacleAnimations.count(oi.uniqueID) == 0)
+	if (obstacleImages.count(oi.uniqueID) == 0)
 		return nullptr;
 
-	animation = obstacleAnimations[oi.uniqueID];
-	assert(animation);
-
-	if(animation)
-	{
-		int frameIndex = framesCount % animation->size(0);
-		return animation->getImage(frameIndex, 0);
-	}
-	return nullptr;
+	return obstacleImages[oi.uniqueID];
 }
 
 Point BattleObstacleController::getObstaclePosition(std::shared_ptr<IImage> image, const CObstacleInstance & obstacle)
diff --color -urN vcmi-1.5.7/client/battle/BattleObstacleController.h vcmi/client/battle/BattleObstacleController.h
--- vcmi-1.5.7/client/battle/BattleObstacleController.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/battle/BattleObstacleController.h	2024-12-19 15:00:22.247121034 +0100
@@ -36,12 +36,12 @@
 	/// total time, in seconds, since start of battle. Used for animating obstacles
 	float timePassed;
 
-	/// cached animations of all obstacles in current battle
-	std::map<AnimationPath, std::shared_ptr<CAnimation>> animationsCache;
-
 	/// list of all obstacles that are currently being rendered
 	std::map<si32, std::shared_ptr<CAnimation>> obstacleAnimations;
 
+	/// Current images for all present obstacles
+	std::map<si32, std::shared_ptr<IImage>> obstacleImages;
+
 	void loadObstacleImage(const CObstacleInstance & oi);
 
 	std::shared_ptr<IImage> getObstacleImage(const CObstacleInstance & oi);
diff --color -urN vcmi-1.5.7/client/battle/BattleOverlayLogVisualizer.cpp vcmi/client/battle/BattleOverlayLogVisualizer.cpp
--- vcmi-1.5.7/client/battle/BattleOverlayLogVisualizer.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/client/battle/BattleOverlayLogVisualizer.cpp	2024-12-19 15:00:22.247121034 +0100
@@ -0,0 +1,41 @@
+/*
+ * BattleOverlayLogVisualizer.cpp, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+
+#include "StdInc.h"
+#include "BattleOverlayLogVisualizer.h"
+#include "BattleInterface.h"
+#include "BattleFieldController.h"
+
+#include "../render/Canvas.h"
+#include "../render/Colors.h"
+#include "../render/EFont.h"
+#include "../render/IFont.h"
+#include "../render/IRenderHandler.h"
+#include "../gui/TextAlignment.h"
+#include "../gui/CGuiHandler.h"
+#include "../render/Graphics.h"
+
+BattleOverlayLogVisualizer::BattleOverlayLogVisualizer(
+	BattleRenderer::RendererRef & target,
+	BattleInterface & owner)
+	: target(target), owner(owner)
+{
+}
+
+void BattleOverlayLogVisualizer::drawText(BattleHex hex, int lineNumber, const std::string & text)
+{
+	Point offset = owner.fieldController->hexPositionLocal(hex).topLeft() + Point(20, 20);
+	const auto & font = GH.renderHandler().loadFont(FONT_TINY);
+	int h = font->getLineHeight();
+
+	offset.y += h * lineNumber;
+
+	target.drawText(offset, EFonts::FONT_TINY, Colors::YELLOW, ETextAlignment::TOPCENTER, text);
+}
diff --color -urN vcmi-1.5.7/client/battle/BattleOverlayLogVisualizer.h vcmi/client/battle/BattleOverlayLogVisualizer.h
--- vcmi-1.5.7/client/battle/BattleOverlayLogVisualizer.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/client/battle/BattleOverlayLogVisualizer.h	2024-12-19 15:00:22.247121034 +0100
@@ -0,0 +1,28 @@
+/*
+ * BattleOverlayLogVisualizer.h, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#pragma once
+
+#include "../../lib/logging/VisualLogger.h"
+#include "BattleRenderer.h"
+
+class Canvas;
+class BattleInterface;
+
+class BattleOverlayLogVisualizer : public IBattleOverlayLogVisualizer
+{
+private:
+	BattleRenderer::RendererRef & target;
+	BattleInterface & owner;
+
+public:
+	BattleOverlayLogVisualizer(BattleRenderer::RendererRef & target, BattleInterface & owner);
+
+	void drawText(BattleHex hex, int lineNumber, const std::string & text) override;
+};
diff --color -urN vcmi-1.5.7/client/battle/BattleProjectileController.cpp vcmi/client/battle/BattleProjectileController.cpp
--- vcmi-1.5.7/client/battle/BattleProjectileController.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/battle/BattleProjectileController.cpp	2024-12-19 15:00:22.247121034 +0100
@@ -15,6 +15,7 @@
 #include "BattleStacksController.h"
 #include "CreatureAnimation.h"
 
+#include "../render/CAnimation.h"
 #include "../render/Canvas.h"
 #include "../render/IRenderHandler.h"
 #include "../gui/CGuiHandler.h"
@@ -159,12 +160,12 @@
 	const CCreature * creature = stack->unitType();
 
 	if(creature->getId() == CreatureID::ARROW_TOWERS)
-		creature = owner.siegeController->getTurretCreature();
+		creature = owner.siegeController->getTurretCreature(stack->initialPosition);
 
-	if(creature->animation.missleFrameAngles.empty())
+	if(creature->animation.missileFrameAngles.empty())
 	{
 		logAnim->error("Mod error: Creature '%s' on the Archer's tower is not a shooter. Mod should be fixed. Trying to use archer's data instead...", creature->getNameSingularTranslated());
-		creature = CGI->creh->objects[CreatureID::ARCHER];
+		creature = CreatureID(CreatureID::ARCHER).toCreature();
 	}
 
 	return *creature;
@@ -191,8 +192,7 @@
 
 std::shared_ptr<CAnimation> BattleProjectileController::createProjectileImage(const AnimationPath & path )
 {
-	std::shared_ptr<CAnimation> projectile = GH.renderHandler().loadAnimation(path);
-	projectile->preload();
+	std::shared_ptr<CAnimation> projectile = GH.renderHandler().loadAnimation(path, EImageBlitMode::COLORKEY);
 
 	if(projectile->size(1) != 0)
 		logAnim->error("Expected empty group 1 in stack projectile");
@@ -277,7 +277,7 @@
 {
 	const CCreature & creature = getShooter(stack);
 
-	auto & angles = creature.animation.missleFrameAngles;
+	auto & angles = creature.animation.missileFrameAngles;
 	auto animation = getProjectileImage(stack);
 
 	// only frames below maxFrame are usable: anything  higher is either no present or we don't know when it should be used
diff --color -urN vcmi-1.5.7/client/battle/BattleRenderer.cpp vcmi/client/battle/BattleRenderer.cpp
--- vcmi-1.5.7/client/battle/BattleRenderer.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/battle/BattleRenderer.cpp	2024-12-19 15:00:22.247121034 +0100
@@ -17,6 +17,7 @@
 #include "BattleSiegeController.h"
 #include "BattleStacksController.h"
 #include "BattleObstacleController.h"
+#include "BattleOverlayLogVisualizer.h"
 
 void BattleRenderer::collectObjects()
 {
@@ -73,4 +74,7 @@
 	collectObjects();
 	sortObjects();
 	renderObjects(targetCanvas);
+
+	BattleOverlayLogVisualizer r(targetCanvas, owner);
+	logVisual->visualize(r);
 }
diff --color -urN vcmi-1.5.7/client/battle/BattleSiegeController.cpp vcmi/client/battle/BattleSiegeController.cpp
--- vcmi-1.5.7/client/battle/BattleSiegeController.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/battle/BattleSiegeController.cpp	2024-12-19 15:00:22.248121076 +0100
@@ -17,16 +17,17 @@
 #include "BattleFieldController.h"
 #include "BattleRenderer.h"
 
-#include "../CMusicHandler.h"
 #include "../CGameInfo.h"
 #include "../CPlayerInterface.h"
 #include "../gui/CGuiHandler.h"
+#include "../media/ISoundPlayer.h"
 #include "../render/Canvas.h"
 #include "../render/IImage.h"
 #include "../render/IRenderHandler.h"
 
 #include "../../CCallback.h"
 #include "../../lib/CStack.h"
+#include "../../lib/entities/building/TownFortifications.h"
 #include "../../lib/mapObjects/CGTownInstance.h"
 #include "../../lib/networkPacks/PacksForClientBattle.h"
 
@@ -34,40 +35,37 @@
 {
 	auto getImageIndex = [&]() -> int
 	{
-		bool isTower = (what == EWallVisual::KEEP || what == EWallVisual::BOTTOM_TOWER || what == EWallVisual::UPPER_TOWER);
+		int health = static_cast<int>(state);
 
-		switch (state)
+		switch (what)
 		{
-		case EWallState::REINFORCED :
-			return 1;
-		case EWallState::INTACT :
-			if (town->hasBuilt(BuildingID::CASTLE))
-				return 2; // reinforced walls were damaged
-			else
-				return 1;
-		case EWallState::DAMAGED :
-			// towers don't have separate image here - INTACT and DAMAGED is 1, DESTROYED is 2
-			if (isTower)
-				return 1;
-			else
-				return 2;
-		case EWallState::DESTROYED :
-			if (isTower)
-				return 2;
-			else
+			case EWallVisual::KEEP:
+			case EWallVisual::BOTTOM_TOWER:
+			case EWallVisual::UPPER_TOWER:
+				if (health > 0)
+					return 1;
+				else
+					return 2;
+			default:
+			{
+				int healthTotal = town->fortificationsLevel().wallsHealth;
+				if (healthTotal == health)
+					return 1;
+				if (health > 0)
+					return 2;
 				return 3;
-		}
-		return 1;
+			}
+		};
 	};
 
-	const std::string & prefix = town->town->clientInfo.siegePrefix;
+	const std::string & prefix = town->getTown()->clientInfo.siegePrefix;
 	std::string addit = std::to_string(getImageIndex());
 
 	switch(what)
 	{
 	case EWallVisual::BACKGROUND_WALL:
 		{
-			auto faction = town->town->faction->getIndex();
+			auto faction = town->getFactionID();
 
 			if (faction == ETownType::RAMPART || faction == ETownType::NECROPOLIS || faction == ETownType::DUNGEON || faction == ETownType::STRONGHOLD)
 				return ImagePath::builtinTODO(prefix + "TPW1.BMP");
@@ -113,7 +111,7 @@
 
 void BattleSiegeController::showWallPiece(Canvas & canvas, EWallVisual::EWallVisual what)
 {
-	auto & ci = town->town->clientInfo;
+	auto & ci = town->getTown()->clientInfo;
 	auto const & pos = ci.siegePositions[what];
 
 	if ( wallPieceImages[what] && pos.isValid())
@@ -122,22 +120,21 @@
 
 ImagePath BattleSiegeController::getBattleBackgroundName() const
 {
-	const std::string & prefix = town->town->clientInfo.siegePrefix;
+	const std::string & prefix = town->getTown()->clientInfo.siegePrefix;
 	return ImagePath::builtinTODO(prefix + "BACK.BMP");
 }
 
-bool BattleSiegeController::getWallPieceExistance(EWallVisual::EWallVisual what) const
+bool BattleSiegeController::getWallPieceExistence(EWallVisual::EWallVisual what) const
 {
-	//FIXME: use this instead of buildings test?
-	//ui8 siegeLevel = owner.curInt->cb->battleGetSiegeLevel();
+	const auto & fortifications = town->fortificationsLevel();
 
 	switch (what)
 	{
-	case EWallVisual::MOAT:              return town->hasBuilt(BuildingID::CITADEL) && town->town->clientInfo.siegePositions.at(EWallVisual::MOAT).isValid();
-	case EWallVisual::MOAT_BANK:         return town->hasBuilt(BuildingID::CITADEL) && town->town->clientInfo.siegePositions.at(EWallVisual::MOAT_BANK).isValid();
-	case EWallVisual::KEEP_BATTLEMENT:   return town->hasBuilt(BuildingID::CITADEL) && owner.getBattle()->battleGetWallState(EWallPart::KEEP) != EWallState::DESTROYED;
-	case EWallVisual::UPPER_BATTLEMENT:  return town->hasBuilt(BuildingID::CASTLE) && owner.getBattle()->battleGetWallState(EWallPart::UPPER_TOWER) != EWallState::DESTROYED;
-	case EWallVisual::BOTTOM_BATTLEMENT: return town->hasBuilt(BuildingID::CASTLE) && owner.getBattle()->battleGetWallState(EWallPart::BOTTOM_TOWER) != EWallState::DESTROYED;
+	case EWallVisual::MOAT:              return fortifications.hasMoat && town->getTown()->clientInfo.siegePositions.at(EWallVisual::MOAT).isValid();
+	case EWallVisual::MOAT_BANK:         return fortifications.hasMoat && town->getTown()->clientInfo.siegePositions.at(EWallVisual::MOAT_BANK).isValid();
+	case EWallVisual::KEEP_BATTLEMENT:   return fortifications.citadelHealth > 0 && owner.getBattle()->battleGetWallState(EWallPart::KEEP) != EWallState::DESTROYED;
+	case EWallVisual::UPPER_BATTLEMENT:  return fortifications.upperTowerHealth > 0 && owner.getBattle()->battleGetWallState(EWallPart::UPPER_TOWER) != EWallState::DESTROYED;
+	case EWallVisual::BOTTOM_BATTLEMENT: return fortifications.lowerTowerHealth > 0 && owner.getBattle()->battleGetWallState(EWallPart::BOTTOM_TOWER) != EWallState::DESTROYED;
 	default:                             return true;
 	}
 }
@@ -179,16 +176,26 @@
 		if ( g == EWallVisual::GATE ) // gate is initially closed and has no image to display in this state
 			continue;
 
-		if ( !getWallPieceExistance(EWallVisual::EWallVisual(g)) )
+		if ( !getWallPieceExistence(EWallVisual::EWallVisual(g)) )
 			continue;
 
-		wallPieceImages[g] = GH.renderHandler().loadImage(getWallPieceImageName(EWallVisual::EWallVisual(g), EWallState::REINFORCED));
+		wallPieceImages[g] = GH.renderHandler().loadImage(getWallPieceImageName(EWallVisual::EWallVisual(g), EWallState::REINFORCED), EImageBlitMode::COLORKEY);
 	}
 }
 
-const CCreature *BattleSiegeController::getTurretCreature() const
+const CCreature *BattleSiegeController::getTurretCreature(BattleHex position) const
 {
-	return CGI->creh->objects[town->town->clientInfo.siegeShooter];
+	switch (position)
+	{
+		case BattleHex::CASTLE_CENTRAL_TOWER:
+			return town->fortificationsLevel().citadelShooter.toCreature();
+		case BattleHex::CASTLE_UPPER_TOWER:
+			return town->fortificationsLevel().upperTowerShooter.toCreature();
+		case BattleHex::CASTLE_BOTTOM_TOWER:
+			return town->fortificationsLevel().lowerTowerShooter.toCreature();
+	}
+
+	throw std::runtime_error("Unable to select shooter for tower at " + std::to_string(position.hex));
 }
 
 Point BattleSiegeController::getTurretCreaturePosition( BattleHex position ) const
@@ -211,8 +218,8 @@
 	if (posID != 0)
 	{
 		return {
-			town->town->clientInfo.siegePositions[posID].x,
-			town->town->clientInfo.siegePositions[posID].y
+			town->getTown()->clientInfo.siegePositions[posID].x,
+			town->getTown()->clientInfo.siegePositions[posID].y
 		};
 	}
 
@@ -248,7 +255,7 @@
 		wallPieceImages[EWallVisual::GATE] = nullptr;
 
 	if (stateId != EWallState::NONE)
-		wallPieceImages[EWallVisual::GATE] = GH.renderHandler().loadImage(getWallPieceImageName(EWallVisual::GATE,  stateId));
+		wallPieceImages[EWallVisual::GATE] = GH.renderHandler().loadImage(getWallPieceImageName(EWallVisual::GATE,  stateId), EImageBlitMode::COLORKEY);
 
 	if (playSound)
 		CCS->soundh->playSound(soundBase::DRAWBRG);
@@ -256,10 +263,10 @@
 
 void BattleSiegeController::showAbsoluteObstacles(Canvas & canvas)
 {
-	if (getWallPieceExistance(EWallVisual::MOAT))
+	if (getWallPieceExistence(EWallVisual::MOAT))
 		showWallPiece(canvas, EWallVisual::MOAT);
 
-	if (getWallPieceExistance(EWallVisual::MOAT_BANK))
+	if (getWallPieceExistence(EWallVisual::MOAT_BANK))
 		showWallPiece(canvas, EWallVisual::MOAT_BANK);
 }
 
@@ -292,7 +299,7 @@
 	{
 		auto wallPiece = EWallVisual::EWallVisual(i);
 
-		if ( !getWallPieceExistance(wallPiece))
+		if ( !getWallPieceExistence(wallPiece))
 			continue;
 
 		if ( getWallPiecePosition(wallPiece) == BattleHex::INVALID)
@@ -357,7 +364,7 @@
 
 		auto wallState = EWallState(owner.getBattle()->battleGetWallState(attackInfo.attackedPart));
 
-		wallPieceImages[wallId] = GH.renderHandler().loadImage(getWallPieceImageName(EWallVisual::EWallVisual(wallId), wallState));
+		wallPieceImages[wallId] = GH.renderHandler().loadImage(getWallPieceImageName(EWallVisual::EWallVisual(wallId), wallState), EImageBlitMode::COLORKEY);
 	}
 }
 
diff --color -urN vcmi-1.5.7/client/battle/BattleSiegeController.h vcmi/client/battle/BattleSiegeController.h
--- vcmi-1.5.7/client/battle/BattleSiegeController.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/battle/BattleSiegeController.h	2024-12-19 15:00:22.248121076 +0100
@@ -83,7 +83,7 @@
 	BattleHex getWallPiecePosition(EWallVisual::EWallVisual what) const;
 
 	/// returns true if chosen wall piece should be present in current battle
-	bool getWallPieceExistance(EWallVisual::EWallVisual what) const;
+	bool getWallPieceExistence(EWallVisual::EWallVisual what) const;
 
 	void showWallPiece(Canvas & canvas, EWallVisual::EWallVisual what);
 
@@ -104,7 +104,7 @@
 	/// queries from other battle controllers
 	bool isAttackableByCatapult(BattleHex hex) const;
 	ImagePath getBattleBackgroundName() const;
-	const CCreature *getTurretCreature() const;
+	const CCreature *getTurretCreature(BattleHex turretPosition) const;
 	Point getTurretCreaturePosition( BattleHex position ) const;
 
 	const CGTownInstance *getSiegedTown() const;
diff --color -urN vcmi-1.5.7/client/battle/BattleStacksController.cpp vcmi/client/battle/BattleStacksController.cpp
--- vcmi-1.5.7/client/battle/BattleStacksController.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/battle/BattleStacksController.cpp	2024-12-19 15:00:22.248121076 +0100
@@ -23,10 +23,11 @@
 #include "CreatureAnimation.h"
 
 #include "../CPlayerInterface.h"
-#include "../CMusicHandler.h"
 #include "../CGameInfo.h"
 #include "../gui/CGuiHandler.h"
 #include "../gui/WindowHandler.h"
+#include "../media/ISoundPlayer.h"
+#include "../render/AssetGenerator.h"
 #include "../render/Colors.h"
 #include "../render/Canvas.h"
 #include "../render/IRenderHandler.h"
@@ -37,9 +38,9 @@
 #include "../../lib/spells/ISpellMechanics.h"
 #include "../../lib/battle/BattleAction.h"
 #include "../../lib/battle/BattleHex.h"
+#include "../../lib/texts/TextOperations.h"
 #include "../../lib/CRandomGenerator.h"
 #include "../../lib/CStack.h"
-#include "../../lib/TextOperations.h"
 
 static void onAnimationFinished(const CStack *stack, std::weak_ptr<CreatureAnimation> anim)
 {
@@ -79,24 +80,12 @@
 	stackToActivate(nullptr),
 	animIDhelper(0)
 {
+	AssetGenerator::createCombatUnitNumberWindow();
 	//preparing graphics for displaying amounts of creatures
-	amountNormal     = GH.renderHandler().loadImage(ImagePath::builtin("CMNUMWIN.BMP"), EImageBlitMode::COLORKEY);
-	amountPositive   = GH.renderHandler().loadImage(ImagePath::builtin("CMNUMWIN.BMP"), EImageBlitMode::COLORKEY);
-	amountNegative   = GH.renderHandler().loadImage(ImagePath::builtin("CMNUMWIN.BMP"), EImageBlitMode::COLORKEY);
-	amountEffNeutral = GH.renderHandler().loadImage(ImagePath::builtin("CMNUMWIN.BMP"), EImageBlitMode::COLORKEY);
-
-	static const auto shifterNormal   = ColorFilter::genRangeShifter( 0.f, 0.f, 0.f, 0.6f, 0.2f, 1.0f );
-	static const auto shifterPositive = ColorFilter::genRangeShifter( 0.f, 0.f, 0.f, 0.2f, 1.0f, 0.2f );
-	static const auto shifterNegative = ColorFilter::genRangeShifter( 0.f, 0.f, 0.f, 1.0f, 0.2f, 0.2f );
-	static const auto shifterNeutral  = ColorFilter::genRangeShifter( 0.f, 0.f, 0.f, 1.0f, 1.0f, 0.2f );
-
-	// do not change border color
-	static const int32_t ignoredMask = 1 << 26;
-
-	amountNormal->adjustPalette(shifterNormal, ignoredMask);
-	amountPositive->adjustPalette(shifterPositive, ignoredMask);
-	amountNegative->adjustPalette(shifterNegative, ignoredMask);
-	amountEffNeutral->adjustPalette(shifterNeutral, ignoredMask);
+	amountNormal     = GH.renderHandler().loadImage(ImagePath::builtin("combatUnitNumberWindowDefault"), EImageBlitMode::COLORKEY);
+	amountPositive   = GH.renderHandler().loadImage(ImagePath::builtin("combatUnitNumberWindowPositive"), EImageBlitMode::COLORKEY);
+	amountNegative   = GH.renderHandler().loadImage(ImagePath::builtin("combatUnitNumberWindowNegative"), EImageBlitMode::COLORKEY);
+	amountEffNeutral = GH.renderHandler().loadImage(ImagePath::builtin("combatUnitNumberWindowNeutral"), EImageBlitMode::COLORKEY);
 
 	std::vector<const CStack*> stacks = owner.getBattle()->battleGetAllStacks(true);
 	for(const CStack * s : stacks)
@@ -191,7 +180,7 @@
 	{
 		assert(owner.siegeController);
 
-		const CCreature *turretCreature = owner.siegeController->getTurretCreature();
+		const CCreature *turretCreature = owner.siegeController->getTurretCreature(stack->initialPosition);
 
 		stackAnimation[stack->unitId()] = AnimationControls::getAnimation(turretCreature);
 		stackAnimation[stack->unitId()]->pos.h = turretCreatureAnimationHeight;
@@ -329,10 +318,10 @@
 			boxPosition = owner.fieldController->hexPositionLocal(frontPos).center() + Point(-8, -14);
 	}
 
-	Point textPosition = Point(amountBG->dimensions().x/2 + boxPosition.x, boxPosition.y + graphics->fonts[EFonts::FONT_TINY]->getLineHeight() - 6);
+	Point textPosition = Point(amountBG->dimensions().x/2 + boxPosition.x, boxPosition.y + amountBG->dimensions().y/2);
 
 	canvas.draw(amountBG, boxPosition);
-	canvas.drawText(textPosition, EFonts::FONT_TINY, Colors::WHITE, ETextAlignment::TOPCENTER, TextOperations::formatMetric(stack->getCount(), 4));
+	canvas.drawText(textPosition, EFonts::FONT_TINY, Colors::WHITE, ETextAlignment::CENTER, TextOperations::formatMetric(stack->getCount(), 4));
 }
 
 void BattleStacksController::showStack(Canvas & canvas, const CStack * stack)
@@ -438,7 +427,7 @@
 		// defender need to face in direction opposited to out attacker
 		bool needsReverse = shouldAttackFacingRight(attackedInfo.attacker, attackedInfo.defender) == facingRight(attackedInfo.defender);
 
-		// FIXME: this check is better, however not usable since stacksAreAttacked is called after net pack is applyed - petrification is already removed
+		// FIXME: this check is better, however not usable since stacksAreAttacked is called after net pack is applied - petrification is already removed
 		// if (needsReverse && !attackedInfo.defender->isFrozen())
 		if (needsReverse && stackAnimation[attackedInfo.defender->unitId()]->getType() != ECreatureAnimType::FROZEN)
 		{
@@ -647,7 +636,7 @@
 	{
 		owner.addToAnimationStage(EAnimationEvents::AFTER_HIT, [=]()
 		{
-			owner.effectsController->displayEffect(EBattleEffect::DRAIN_LIFE, AudioPath::builtin("DRAINLIF"), attacker->getPosition());
+			owner.effectsController->displayEffect(EBattleEffect::DRAIN_LIFE, AudioPath::builtin("DRAINLIF"), attacker->getPosition(), 0.5);
 		});
 	}
 
@@ -873,7 +862,8 @@
 	spell = owner.actionsController->getCurrentSpell(hoveredHex);
 	caster = owner.actionsController->getCurrentSpellcaster();
 
-	if(caster && spell && owner.actionsController->currentActionSpellcasting(hoveredHex) ) //when casting spell
+	//casting spell or in explicit spellcasting mode that also handles SPELL_LIKE_ATTACK
+	if(caster && spell && (owner.actionsController->currentActionSpellcasting(hoveredHex) || owner.actionsController->creatureSpellcastingModeActive()))
 	{
 		spells::Target target;
 		target.emplace_back(hoveredHex);
diff --color -urN vcmi-1.5.7/client/battle/BattleWindow.cpp vcmi/client/battle/BattleWindow.cpp
--- vcmi-1.5.7/client/battle/BattleWindow.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/battle/BattleWindow.cpp	2024-12-19 15:00:22.249121117 +0100
@@ -18,7 +18,6 @@
 
 #include "../CGameInfo.h"
 #include "../CPlayerInterface.h"
-#include "../CMusicHandler.h"
 #include "../gui/CursorHandler.h"
 #include "../gui/CGuiHandler.h"
 #include "../gui/Shortcut.h"
@@ -35,7 +34,7 @@
 #include "../adventureMap/TurnTimerWidget.h"
 
 #include "../../CCallback.h"
-#include "../../lib/CGeneralTextHandler.h"
+#include "../../lib/texts/CGeneralTextHandler.h"
 #include "../../lib/gameState/InfoAboutArmy.h"
 #include "../../lib/mapObjects/CGHeroInstance.h"
 #include "../../lib/CStack.h"
@@ -46,11 +45,11 @@
 #include "../../lib/CPlayerState.h"
 #include "../windows/settings/SettingsMainWindow.h"
 
-BattleWindow::BattleWindow(BattleInterface & owner):
-	owner(owner),
+BattleWindow::BattleWindow(BattleInterface & Owner):
+	owner(Owner),
 	lastAlternativeAction(PossiblePlayerBattleAction::INVALID)
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 	pos.w = 800;
 	pos.h = 600;
 	pos = center();
@@ -65,6 +64,20 @@
 	
 	const JsonNode config(JsonPath::builtin("config/widgets/BattleWindow2.json"));
 	
+	addShortcut(EShortcut::BATTLE_TOGGLE_QUICKSPELL, [this](){ this->toggleStickyQuickSpellVisibility();});
+	addShortcut(EShortcut::BATTLE_SPELL_SHORTCUT_0,  [this](){ useSpellIfPossible(0);  });
+	addShortcut(EShortcut::BATTLE_SPELL_SHORTCUT_1,  [this](){ useSpellIfPossible(1);  });
+	addShortcut(EShortcut::BATTLE_SPELL_SHORTCUT_2,  [this](){ useSpellIfPossible(2);  });
+	addShortcut(EShortcut::BATTLE_SPELL_SHORTCUT_3,  [this](){ useSpellIfPossible(3);  });
+	addShortcut(EShortcut::BATTLE_SPELL_SHORTCUT_4,  [this](){ useSpellIfPossible(4);  });
+	addShortcut(EShortcut::BATTLE_SPELL_SHORTCUT_5,  [this](){ useSpellIfPossible(5);  });
+	addShortcut(EShortcut::BATTLE_SPELL_SHORTCUT_6,  [this](){ useSpellIfPossible(6);  });
+	addShortcut(EShortcut::BATTLE_SPELL_SHORTCUT_7,  [this](){ useSpellIfPossible(7);  });
+	addShortcut(EShortcut::BATTLE_SPELL_SHORTCUT_8,  [this](){ useSpellIfPossible(8);  });
+	addShortcut(EShortcut::BATTLE_SPELL_SHORTCUT_9,  [this](){ useSpellIfPossible(9);  });
+	addShortcut(EShortcut::BATTLE_SPELL_SHORTCUT_10, [this](){ useSpellIfPossible(10); });
+	addShortcut(EShortcut::BATTLE_SPELL_SHORTCUT_11, [this](){ useSpellIfPossible(11); });
+
 	addShortcut(EShortcut::GLOBAL_OPTIONS, std::bind(&BattleWindow::bOptionsf, this));
 	addShortcut(EShortcut::BATTLE_SURRENDER, std::bind(&BattleWindow::bSurrenderf, this));
 	addShortcut(EShortcut::BATTLE_RETREAT, std::bind(&BattleWindow::bFleef, this));
@@ -96,6 +109,7 @@
 	owner.fieldController->createHeroes();
 
 	createQueue();
+	createQuickSpellWindow();
 	createStickyHeroInfoWindows();
 	createTimerInfoWindows();
 
@@ -109,7 +123,7 @@
 
 void BattleWindow::createQueue()
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 
 	//create stack queue and adjust our own position
 	bool embedQueue;
@@ -136,7 +150,7 @@
 
 void BattleWindow::createStickyHeroInfoWindows()
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 
 	if(owner.defendingHeroInstance)
 	{
@@ -165,9 +179,68 @@
 	setPositionInfoWindow();
 }
 
+void BattleWindow::createQuickSpellWindow()
+{
+	OBJECT_CONSTRUCTION;
+
+	quickSpellWindow = std::make_shared<QuickSpellPanel>(owner);
+	quickSpellWindow->moveTo(Point(pos.x - 67, pos.y));
+
+	if(settings["battle"]["enableQuickSpellPanel"].Bool())
+		showStickyQuickSpellWindow();
+	else
+		hideStickyQuickSpellWindow();
+}
+
+void BattleWindow::toggleStickyQuickSpellVisibility()
+{
+	if(settings["battle"]["enableQuickSpellPanel"].Bool())
+		hideStickyQuickSpellWindow();
+	else
+		showStickyQuickSpellWindow();
+}
+
+void BattleWindow::hideStickyQuickSpellWindow()
+{
+	Settings showStickyQuickSpellWindow = settings.write["battle"]["enableQuickSpellPanel"];
+	showStickyQuickSpellWindow->Bool() = false;
+
+	quickSpellWindow->disable();
+	quickSpellWindow->isEnabled = false;
+
+	setPositionInfoWindow();
+	createTimerInfoWindows();
+	GH.windows().totalRedraw();
+}
+
+void BattleWindow::showStickyQuickSpellWindow()
+{
+	Settings showStickyQuickSpellWindow = settings.write["battle"]["enableQuickSpellPanel"];
+	showStickyQuickSpellWindow->Bool() = true;
+
+	auto hero = owner.getBattle()->battleGetMyHero();
+
+	if(GH.screenDimensions().x >= 1050 && hero != nullptr && hero->hasSpellbook())
+	{
+		quickSpellWindow->enable();
+		quickSpellWindow->isEnabled = true;
+	}
+	else
+	{
+		quickSpellWindow->disable();
+		quickSpellWindow->isEnabled = false;
+	}
+
+	setPositionInfoWindow();
+	createTimerInfoWindows();
+	GH.windows().totalRedraw();
+}
+
 void BattleWindow::createTimerInfoWindows()
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
+
+	int xOffsetAttacker = quickSpellWindow->isEnabled ? -53 : 0;
 
 	if(LOCPLINT->cb->getStartInfo()->turnTimerInfo.battleTimer != 0 || LOCPLINT->cb->getStartInfo()->turnTimerInfo.unitTimer != 0)
 	{
@@ -177,7 +250,7 @@
 		if (attacker.isValidPlayer())
 		{
 			if (GH.screenDimensions().x >= 1000)
-				attackerTimerWidget = std::make_shared<TurnTimerWidget>(Point(-92, 1), attacker);
+				attackerTimerWidget = std::make_shared<TurnTimerWidget>(Point(-92 + xOffsetAttacker, 1), attacker);
 			else
 				attackerTimerWidget = std::make_shared<TurnTimerWidget>(Point(1, 135), attacker);
 		}
@@ -200,6 +273,21 @@
 	return std::make_shared<BattleConsole>(owner, background, rect.topLeft(), offset, rect.dimensions() );
 }
 
+void BattleWindow::useSpellIfPossible(int slot)
+{
+	SpellID id;
+	bool fromSettings;
+	std::tie(id, fromSettings) = quickSpellWindow->getSpells()[slot];
+
+	if(id == SpellID::NONE)
+		return;
+
+	if(id.hasValue() && owner.getBattle()->battleGetMyHero() && id.toSpell()->canBeCast(owner.getBattle().get(), spells::Mode::HERO, owner.getBattle()->battleGetMyHero()))
+	{
+		owner.castThisSpell(id);
+	}
+};
+
 void BattleWindow::toggleQueueVisibility()
 {
 	if(settings["battle"]["showQueue"].Bool())
@@ -284,10 +372,12 @@
 void BattleWindow::updateQueue()
 {
 	queue->update();
+	createQuickSpellWindow();
 }
 
 void BattleWindow::setPositionInfoWindow()
 {
+	int xOffsetAttacker = quickSpellWindow->isEnabled ? -53 : 0;
 	if(defenderHeroWindow)
 	{
 		Point position = (GH.screenDimensions().x >= 1000)
@@ -298,7 +388,7 @@
 	if(attackerHeroWindow)
 	{
 		Point position = (GH.screenDimensions().x >= 1000)
-				? Point(pos.x - 93, pos.y + 60)
+				? Point(pos.x - 93 + xOffsetAttacker, pos.y + 60)
 				: Point(pos.x + 1, pos.y + 195);
 		attackerHeroWindow->moveTo(position);
 	}
@@ -312,7 +402,7 @@
 	if(attackerStackWindow)
 	{
 		Point position = (GH.screenDimensions().x >= 1000)
-				? Point(pos.x - 93, attackerHeroWindow ? attackerHeroWindow->pos.y + 210 : pos.y + 60)
+				? Point(pos.x - 93 + xOffsetAttacker, attackerHeroWindow ? attackerHeroWindow->pos.y + 210 : pos.y + 60)
 				: Point(pos.x + 1, attackerHeroWindow ? attackerHeroWindow->pos.y : pos.y + 195);
 		attackerStackWindow->moveTo(position);
 	}
@@ -326,7 +416,7 @@
 
 void BattleWindow::updateStackInfoWindow(const CStack * stack)
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 
 	bool showInfoWindows = settings["battle"]["stickyHeroInfoWindows"].Bool();
 
@@ -347,6 +437,7 @@
 		attackerStackWindow = nullptr;
 	
 	setPositionInfoWindow();
+	createTimerInfoWindows();
 }
 
 void BattleWindow::heroManaPointsChanged(const CGHeroInstance * hero)
@@ -447,7 +538,7 @@
 
 void BattleWindow::bOptionsf()
 {
-	if (owner.actionsController->spellcastingModeActive())
+	if (owner.actionsController->heroSpellcastingModeActive())
 		return;
 
 	CCS->curh->set(Cursor::Map::POINTER);
@@ -457,7 +548,7 @@
 
 void BattleWindow::bSurrenderf()
 {
-	if (owner.actionsController->spellcastingModeActive())
+	if (owner.actionsController->heroSpellcastingModeActive())
 		return;
 
 	int cost = owner.getBattle()->battleGetSurrenderCost();
@@ -477,7 +568,7 @@
 
 void BattleWindow::bFleef()
 {
-	if (owner.actionsController->spellcastingModeActive())
+	if (owner.actionsController->heroSpellcastingModeActive())
 		return;
 
 	if ( owner.getBattle()->battleCanFlee() )
@@ -584,7 +675,7 @@
 
 void BattleWindow::bAutofightf()
 {
-	if (owner.actionsController->spellcastingModeActive())
+	if (owner.actionsController->heroSpellcastingModeActive())
 		return;
 
 	if(settings["battle"]["endWithAutocombat"].Bool() && onlyOnePlayerHuman)
@@ -621,7 +712,7 @@
 
 void BattleWindow::bSpellf()
 {
-	if (owner.actionsController->spellcastingModeActive())
+	if (owner.actionsController->heroSpellcastingModeActive())
 		return;
 
 	if (!owner.makingTurn())
@@ -652,7 +743,7 @@
 			const auto artID = blockingBonus->sid.as<ArtifactID>();
 			//If we have artifact, put name of our hero. Otherwise assume it's the enemy.
 			//TODO check who *really* is source of bonus
-			std::string heroName = myHero->hasArt(artID) ? myHero->getNameTranslated() : owner.enemyHero().name;
+			std::string heroName = myHero->hasArt(artID, true) ? myHero->getNameTranslated() : owner.enemyHero().name;
 
 			//%s wields the %s, an ancient artifact which creates a p dead to all magic.
 			LOCPLINT->showInfoDialog(boost::str(boost::format(CGI->generaltexth->allTexts[683])
@@ -694,7 +785,7 @@
 
 void BattleWindow::bWaitf()
 {
-	if (owner.actionsController->spellcastingModeActive())
+	if (owner.actionsController->heroSpellcastingModeActive())
 		return;
 
 	if (owner.stacksController->getActiveStack() != nullptr)
@@ -703,7 +794,7 @@
 
 void BattleWindow::bDefencef()
 {
-	if (owner.actionsController->spellcastingModeActive())
+	if (owner.actionsController->heroSpellcastingModeActive())
 		return;
 
 	if (owner.stacksController->getActiveStack() != nullptr)
@@ -712,7 +803,7 @@
 
 void BattleWindow::bConsoleUpf()
 {
-	if (owner.actionsController->spellcastingModeActive())
+	if (owner.actionsController->heroSpellcastingModeActive())
 		return;
 
 	console->scrollUp();
@@ -720,7 +811,7 @@
 
 void BattleWindow::bConsoleDownf()
 {
-	if (owner.actionsController->spellcastingModeActive())
+	if (owner.actionsController->heroSpellcastingModeActive())
 		return;
 
 	console->scrollDown();
@@ -760,12 +851,14 @@
 	setShortcutBlocked(EShortcut::BATTLE_WAIT, on || owner.tacticsMode || !canWait);
 	setShortcutBlocked(EShortcut::BATTLE_DEFEND, on || owner.tacticsMode);
 	setShortcutBlocked(EShortcut::BATTLE_SELECT_ACTION, on || owner.tacticsMode);
-	setShortcutBlocked(EShortcut::BATTLE_AUTOCOMBAT, (settings["battle"]["endWithAutocombat"].Bool() && onlyOnePlayerHuman) ? on || owner.tacticsMode || owner.actionsController->spellcastingModeActive() : owner.actionsController->spellcastingModeActive());
-	setShortcutBlocked(EShortcut::BATTLE_END_WITH_AUTOCOMBAT, on || owner.tacticsMode || !onlyOnePlayerHuman || owner.actionsController->spellcastingModeActive());
+	setShortcutBlocked(EShortcut::BATTLE_AUTOCOMBAT, (settings["battle"]["endWithAutocombat"].Bool() && onlyOnePlayerHuman) ? on || owner.tacticsMode || owner.actionsController->heroSpellcastingModeActive() : owner.actionsController->heroSpellcastingModeActive());
+	setShortcutBlocked(EShortcut::BATTLE_END_WITH_AUTOCOMBAT, on || owner.tacticsMode || !onlyOnePlayerHuman || owner.actionsController->heroSpellcastingModeActive());
 	setShortcutBlocked(EShortcut::BATTLE_TACTICS_END, on || !owner.tacticsMode);
 	setShortcutBlocked(EShortcut::BATTLE_TACTICS_NEXT, on || !owner.tacticsMode);
 	setShortcutBlocked(EShortcut::BATTLE_CONSOLE_DOWN, on && !owner.tacticsMode);
 	setShortcutBlocked(EShortcut::BATTLE_CONSOLE_UP, on && !owner.tacticsMode);
+
+	quickSpellWindow->setInputEnabled(!on);
 }
 
 void BattleWindow::bOpenActiveUnit()
@@ -773,7 +866,7 @@
 	const auto * unit = owner.stacksController->getActiveStack();
 
 	if (unit)
-		GH.windows().createAndPushWindow<CStackWindow>(unit, false);;
+		GH.windows().createAndPushWindow<CStackWindow>(unit, false);
 }
 
 void BattleWindow::bOpenHoveredUnit()
diff --color -urN vcmi-1.5.7/client/battle/BattleWindow.h vcmi/client/battle/BattleWindow.h
--- vcmi-1.5.7/client/battle/BattleWindow.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/battle/BattleWindow.h	2024-12-19 15:00:22.249121117 +0100
@@ -27,6 +27,7 @@
 class TurnTimerWidget;
 class HeroInfoBasicPanel;
 class StackInfoBasicPanel;
+class QuickSpellPanel;
 
 /// GUI object that handles functionality of panel at the bottom of combat screen
 class BattleWindow : public InterfaceObjectConfigurable
@@ -40,6 +41,8 @@
 	std::shared_ptr<StackInfoBasicPanel> attackerStackWindow;
 	std::shared_ptr<StackInfoBasicPanel> defenderStackWindow;
 
+	std::shared_ptr<QuickSpellPanel> quickSpellWindow;
+
 	std::shared_ptr<TurnTimerWidget> attackerTimerWidget;
 	std::shared_ptr<TurnTimerWidget> defenderTimerWidget;
 
@@ -68,12 +71,16 @@
 	PossiblePlayerBattleAction lastAlternativeAction;
 	void showAlternativeActionIcon(PossiblePlayerBattleAction);
 
+	void useSpellIfPossible(int slot);
+
 	/// flip battle queue visibility to opposite
 	void toggleQueueVisibility();
 	void createQueue();
 
 	void toggleStickyHeroWindowsVisibility();
+	void toggleStickyQuickSpellVisibility();
 	void createStickyHeroInfoWindows();
+	void createQuickSpellWindow();
 	void createTimerInfoWindows();
 
 	std::shared_ptr<BattleConsole> buildBattleConsole(const JsonNode &) const;
@@ -94,6 +101,10 @@
 	void hideStickyHeroWindows();
 	void showStickyHeroWindows();
 
+	/// Toggle permanent quickspell windows visibility
+	void hideStickyQuickSpellWindow();
+	void showStickyQuickSpellWindow();
+
 	/// Event handler for netpack changing hero mana points
 	void heroManaPointsChanged(const CGHeroInstance * hero);
 
diff --color -urN vcmi-1.5.7/client/battle/CreatureAnimation.cpp vcmi/client/battle/CreatureAnimation.cpp
--- vcmi-1.5.7/client/battle/CreatureAnimation.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/battle/CreatureAnimation.cpp	2024-12-19 15:00:22.249121117 +0100
@@ -14,8 +14,10 @@
 #include "../../lib/CCreatureHandler.h"
 
 #include "../gui/CGuiHandler.h"
+#include "../render/CAnimation.h"
 #include "../render/Canvas.h"
 #include "../render/ColorFilter.h"
+#include "../render/Colors.h"
 #include "../render/IRenderHandler.h"
 
 static const ColorRGBA creatureBlueBorder = { 0, 255, 255, 255 };
@@ -198,12 +200,8 @@
 	  speedController(controller),
 	  once(false)
 {
-	forward = GH.renderHandler().loadAnimation(name_);
-	reverse = GH.renderHandler().loadAnimation(name_);
-
-	//todo: optimize
-	forward->preload();
-	reverse->preload();
+	forward = GH.renderHandler().loadAnimation(name_, EImageBlitMode::WITH_SHADOW_AND_OVERLAY);
+	reverse = GH.renderHandler().loadAnimation(name_, EImageBlitMode::WITH_SHADOW_AND_OVERLAY);
 
 	// if necessary, add one frame into vcmi-only group DEAD
 	if(forward->size(size_t(ECreatureAnimType::DEAD)) == 0)
@@ -326,33 +324,6 @@
 	return ColorRGBA(base.r, base.g, base.b, ui8(base.a * alpha / 256));
 }
 
-static ui8 mixChannels(ui8 c1, ui8 c2, ui8 a1, ui8 a2)
-{
-	return c1*a1 / 256 + c2*a2*(255 - a1) / 256 / 256;
-}
-
-static ColorRGBA addColors(const ColorRGBA & base, const ColorRGBA & over)
-{
-	return ColorRGBA(
-			mixChannels(over.r, base.r, over.a, base.a),
-			mixChannels(over.g, base.g, over.a, base.a),
-			mixChannels(over.b, base.b, over.a, base.a),
-			ui8(over.a + base.a * (255 - over.a) / 256)
-			);
-}
-
-void CreatureAnimation::genSpecialPalette(IImage::SpecialPalette & target)
-{
-	target.resize(8);
-	target[0] = genShadow(0);
-	target[1] = genShadow(shadowAlpha / 2);
-	// colors 2 & 3 are not used in creatures
-	target[4] = genShadow(shadowAlpha);
-	target[5] = genBorderColor(getBorderStrength(elapsedTime), border);
-	target[6] = addColors(genShadow(shadowAlpha),     genBorderColor(getBorderStrength(elapsedTime), border));
-	target[7] = addColors(genShadow(shadowAlpha / 2), genBorderColor(getBorderStrength(elapsedTime), border));
-}
-
 void CreatureAnimation::nextFrame(Canvas & canvas, const ColorFilter & shifter, bool facingRight)
 {
 	ColorRGBA shadowTest = shifter.shiftColor(genShadow(128));
@@ -369,14 +340,14 @@
 
 	if(image)
 	{
-		IImage::SpecialPalette SpecialPalette;
-		genSpecialPalette(SpecialPalette);
+		if (isIdle())
+			image->setOverlayColor(genBorderColor(getBorderStrength(elapsedTime), border));
+		else
+			image->setOverlayColor(Colors::TRANSPARENCY);
 
-		image->setSpecialPallete(SpecialPalette, IImage::SPECIAL_PALETTE_MASK_CREATURES);
-		image->adjustPalette(shifter, IImage::SPECIAL_PALETTE_MASK_CREATURES);
+		image->adjustPalette(shifter, 0);
 
 		canvas.draw(image, pos.topLeft(), Rect(0, 0, pos.w, pos.h));
-
 	}
 }
 
diff --color -urN vcmi-1.5.7/client/battle/CreatureAnimation.h vcmi/client/battle/CreatureAnimation.h
--- vcmi-1.5.7/client/battle/CreatureAnimation.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/battle/CreatureAnimation.h	2024-12-19 15:00:22.249121117 +0100
@@ -12,7 +12,6 @@
 #include "../../lib/FunctionList.h"
 #include "../../lib/Color.h"
 #include "../widgets/Images.h"
-#include "../render/CAnimation.h"
 #include "../render/IImage.h"
 
 class CIntObject;
@@ -108,9 +107,7 @@
 
 	void endAnimation();
 
-	void genSpecialPalette(IImage::SpecialPalette & target);
 public:
-
 	/// function(s) that will be called when animation ends, after reset to 1st frame
 	/// NOTE that these functions will be fired only once
 	CFunctionList<void()> onAnimationReset;
diff --color -urN vcmi-1.5.7/client/CFocusableHelper.cpp vcmi/client/CFocusableHelper.cpp
--- vcmi-1.5.7/client/CFocusableHelper.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/CFocusableHelper.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,18 +0,0 @@
-/*
- * CFocusableHelper.cpp, part of VCMI engine
- *
- * Authors: listed in file AUTHORS in main folder
- *
- * License: GNU General Public License v2.0 or later
- * Full text of license available in license.txt file, in main folder
- *
- */
-#include "StdInc.h"
-#include "CFocusableHelper.h"
-#include "widgets/CTextInput.h"
-
-void removeFocusFromActiveInput()
-{
-    if(CFocusable::inputWithFocus != nullptr)
-        CFocusable::inputWithFocus->removeFocus();
-}
diff --color -urN vcmi-1.5.7/client/CFocusableHelper.h vcmi/client/CFocusableHelper.h
--- vcmi-1.5.7/client/CFocusableHelper.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/CFocusableHelper.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,12 +0,0 @@
-/*
- * CFocusableHelper.h, part of VCMI engine
- *
- * Authors: listed in file AUTHORS in main folder
- *
- * License: GNU General Public License v2.0 or later
- * Full text of license available in license.txt file, in main folder
- *
- */
-#pragma once
-
-void removeFocusFromActiveInput();
diff --color -urN vcmi-1.5.7/client/CGameInfo.cpp vcmi/client/CGameInfo.cpp
--- vcmi-1.5.7/client/CGameInfo.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/CGameInfo.cpp	2024-12-19 15:00:22.238120662 +0100
@@ -92,14 +92,9 @@
 	return globalServices->obstacles();
 }
 
-const IGameSettings * CGameInfo::settings() const
+const IGameSettings * CGameInfo::engineSettings() const
 {
-	return globalServices->settings();
-}
-
-void CGameInfo::updateEntity(Metatype metatype, int32_t index, const JsonNode & data)
-{
-	logGlobal->error("CGameInfo::updateEntity call is not expected.");
+	return globalServices->engineSettings();
 }
 
 spells::effects::Registry * CGameInfo::spellEffects()
diff --color -urN vcmi-1.5.7/client/CGameInfo.h vcmi/client/CGameInfo.h
--- vcmi-1.5.7/client/CGameInfo.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/CGameInfo.h	2024-12-19 15:00:22.238120662 +0100
@@ -20,7 +20,6 @@
 class CCreatureHandler;
 class CSpellHandler;
 class CSkillHandler;
-class CBuildingHandler;
 class CObjectHandler;
 class CObjectClassesHandler;
 class CTownHandler;
@@ -36,26 +35,26 @@
 VCMI_LIB_NAMESPACE_END
 
 class CMapHandler;
-class CSoundHandler;
-class CMusicHandler;
+class ISoundPlayer;
+class IMusicPlayer;
 class CursorHandler;
-class IMainVideoPlayer;
+class IVideoPlayer;
 class CServerHandler;
 
 //a class for non-mechanical client GUI classes
 class CClientState
 {
 public:
-	CSoundHandler * soundh;
-	CMusicHandler * musich;
+	ISoundPlayer * soundh;
+	IMusicPlayer * musich;
 	CConsoleHandler * consoleh;
 	CursorHandler * curh;
-	IMainVideoPlayer * videoh;
+	IVideoPlayer * videoh;
 };
 extern CClientState * CCS;
 
 /// CGameInfo class
-/// for allowing different functions for accessing game informations
+/// for allowing different functions for accessing game information
 class CGameInfo final : public Services
 {
 public:
@@ -71,9 +70,7 @@
 	const SkillService * skills() const override;
 	const BattleFieldService * battlefields() const override;
 	const ObstacleService * obstacles() const override;
-	const IGameSettings * settings() const override;
-
-	void updateEntity(Metatype metatype, int32_t index, const JsonNode & data) override;
+	const IGameSettings * engineSettings() const override;
 
 	const spells::effects::Registry * spellEffects() const override;
 	spells::effects::Registry * spellEffects() override;
diff --color -urN vcmi-1.5.7/client/ClientCommandManager.cpp vcmi/client/ClientCommandManager.cpp
--- vcmi-1.5.7/client/ClientCommandManager.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/ClientCommandManager.cpp	2024-12-19 15:00:22.239120704 +0100
@@ -18,6 +18,7 @@
 #include "gui/CGuiHandler.h"
 #include "gui/WindowHandler.h"
 #include "render/IRenderHandler.h"
+#include "render/AssetGenerator.h"
 #include "ClientNetPackVisitors.h"
 #include "../lib/CConfigHandler.h"
 #include "../lib/gameState/CGameState.h"
@@ -30,15 +31,14 @@
 #include "../lib/mapObjects/CGHeroInstance.h"
 #include "render/CAnimation.h"
 #include "../CCallback.h"
-#include "../lib/CGeneralTextHandler.h"
+#include "../lib/texts/CGeneralTextHandler.h"
 #include "../lib/filesystem/Filesystem.h"
 #include "../lib/modding/CModHandler.h"
 #include "../lib/modding/ContentTypeHandler.h"
 #include "../lib/modding/ModUtility.h"
-#include "../lib/CHeroHandler.h"
 #include "../lib/VCMIDirs.h"
 #include "../lib/logging/VisualLogger.h"
-#include "CMT.h"
+#include "../lib/serializer/Connection.h"
 
 #ifdef SCRIPTING_ENABLED
 #include "../lib/ScriptHandler.h"
@@ -82,31 +82,37 @@
 		printCommandMessage("Game is not in playing state");
 		return;
 	}
-	PlayerColor color;
+
 	if(session["aiSolo"].Bool())
 	{
-		for(auto & elem : CSH->client->gameState()->players)
+		// unlikely it will work but just in case to be consistent
+		for(auto & color : CSH->getAllClientPlayers(CSH->logicConnection->connectionID))
 		{
-			if(elem.second.human)
-				CSH->client->installNewPlayerInterface(std::make_shared<CPlayerInterface>(elem.first), elem.first);
+			if(color.isValidPlayer() && CSH->client->getStartInfo()->playerInfos.at(color).isControlledByHuman())
+			{
+				CSH->client->installNewPlayerInterface(std::make_shared<CPlayerInterface>(color), color);
+			}
 		}
 	}
 	else
 	{
-		color = LOCPLINT->playerID;
+		PlayerColor currentColor = LOCPLINT->playerID;
 		CSH->client->removeGUI();
-		for(auto & elem : CSH->client->gameState()->players)
+		
+		for(auto & color : CSH->getAllClientPlayers(CSH->logicConnection->connectionID))
 		{
-			if(elem.second.human)
+			if(color.isValidPlayer() && CSH->client->getStartInfo()->playerInfos.at(color).isControlledByHuman())
 			{
-				auto AiToGive = CSH->client->aiNameForPlayer(*CSH->client->getPlayerSettings(elem.first), false, false);
-				printCommandMessage("Player " + elem.first.toString() + " will be lead by " + AiToGive, ELogLevel::INFO);
-				CSH->client->installNewPlayerInterface(CDynLibHandler::getNewAI(AiToGive), elem.first);
+				auto AiToGive = CSH->client->aiNameForPlayer(*CSH->client->getPlayerSettings(color), false, false);
+				printCommandMessage("Player " + color.toString() + " will be lead by " + AiToGive, ELogLevel::INFO);
+				CSH->client->installNewPlayerInterface(CDynLibHandler::getNewAI(AiToGive), color);
 			}
 		}
+
 		GH.windows().totalRedraw();
-		giveTurn(color);
+		giveTurn(currentColor);
 	}
+
 	session["aiSolo"].Bool() = !session["aiSolo"].Bool();
 }
 
@@ -179,12 +185,12 @@
 	GH.windows().totalRedraw();
 }
 
-void ClientCommandManager::handleTranslateGameCommand()
+void ClientCommandManager::handleTranslateGameCommand(bool onlyMissing)
 {
 	std::map<std::string, std::map<std::string, std::string>> textsByMod;
-	VLC->generaltexth->exportAllTexts(textsByMod);
+	VLC->generaltexth->exportAllTexts(textsByMod, onlyMissing);
 
-	const boost::filesystem::path outPath = VCMIDirs::get().userExtractedPath() / "translation";
+	const boost::filesystem::path outPath = VCMIDirs::get().userExtractedPath() / ( onlyMissing ? "translationMissing" : "translation");
 	boost::filesystem::create_directories(outPath);
 
 	for(const auto & modEntry : textsByMod)
@@ -248,13 +254,20 @@
 	logGlobal->info("Loading campaigns for export");
 	for (auto const & campaignName : campaignList)
 	{
-		loadedCampaigns.push_back(CampaignHandler::getCampaign(campaignName.getName()));
-		for (auto const & part : loadedCampaigns.back()->allScenarios())
-			loadedCampaigns.back()->getMap(part, nullptr);
+		try
+		{
+			loadedCampaigns.push_back(CampaignHandler::getCampaign(campaignName.getName()));
+			for (auto const & part : loadedCampaigns.back()->allScenarios())
+				loadedCampaigns.back()->getMap(part, nullptr);
+		}
+		catch(std::exception & e)
+		{
+			logGlobal->warn("Campaign %s is invalid. Message: %s", campaignName.getName(), e.what());
+		}
 	}
 
 	std::map<std::string, std::map<std::string, std::string>> textsByMod;
-	VLC->generaltexth->exportAllTexts(textsByMod);
+	VLC->generaltexth->exportAllTexts(textsByMod, false);
 
 	const boost::filesystem::path outPath = VCMIDirs::get().userExtractedPath() / "translation";
 	boost::filesystem::create_directories(outPath);
@@ -381,8 +394,7 @@
 {
 	std::string URI;
 	singleWordBuffer >> URI;
-	auto anim = GH.renderHandler().loadAnimation(AnimationPath::builtin(URI));
-	anim->preload();
+	auto anim = GH.renderHandler().loadAnimation(AnimationPath::builtin(URI), EImageBlitMode::SIMPLE);
 	anim->exportBitmaps(VCMIDirs::get().userExtractedPath());
 }
 
@@ -447,7 +459,7 @@
 	if(what == "hs")
 	{
 		for(const CGHeroInstance* h : LOCPLINT->cb->getHeroesInfo())
-			if(h->type->getIndex() == id1)
+			if(h->getHeroTypeID().getNum() == id1)
 				if(const CArtifactInstance* a = h->getArt(ArtifactPosition(id2)))
 					printCommandMessage(a->nodeName());
 	}
@@ -496,6 +508,12 @@
 	logVisual->setKey(key);
 }
 
+void ClientCommandManager::handleGenerateAssets()
+{
+	AssetGenerator::generateAll();
+	printCommandMessage("All assets generated");
+}
+
 void ClientCommandManager::printCommandMessage(const std::string &commandMessage, ELogLevel::ELogLevel messageType)
 {
 	switch(messageType)
@@ -580,7 +598,10 @@
 		handleRedrawCommand();
 
 	else if(message=="translate" || message=="translate game")
-		handleTranslateGameCommand();
+		handleTranslateGameCommand(false);
+
+	else if(message=="translate missing")
+		handleTranslateGameCommand(true);
 
 	else if(message=="translate maps")
 		handleTranslateMapsCommand();
@@ -618,6 +639,9 @@
 	else if(commandName == "vslog")
 		handleVsLog(singleWordBuffer);
 
+	else if(message=="generate assets")
+		handleGenerateAssets();
+
 	else
 	{
 		if (!commandName.empty() && !vstd::iswithin(commandName[0], 0, ' ')) // filter-out debugger/IDE noise
diff --color -urN vcmi-1.5.7/client/ClientCommandManager.h vcmi/client/ClientCommandManager.h
--- vcmi-1.5.7/client/ClientCommandManager.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/ClientCommandManager.h	2024-12-19 15:00:22.239120704 +0100
@@ -46,7 +46,7 @@
 	void handleRedrawCommand();
 
 	// Extracts all translateable game texts into Translation directory, separating files on per-mod basis
-	void handleTranslateGameCommand();
+	void handleTranslateGameCommand(bool onlyMissing);
 
 	// Extracts all translateable texts from maps and campaigns into Translation directory, separating files on per-mod basis
 	void handleTranslateMapsCommand();
@@ -66,7 +66,7 @@
 	// Export file into Extracted directory
 	void handleExtractCommand(std::istringstream& singleWordBuffer);
 
-	// Print in console the current bonuses for curent army
+	// Print in console the current bonuses for current army
 	void handleBonusesCommand(std::istringstream & singleWordBuffer);
 
 	// Get what artifact is present on artifact slot with specified ID for hero with specified ID
@@ -84,6 +84,9 @@
 	// shows object graph
 	void handleVsLog(std::istringstream & singleWordBuffer);
 
+	// generate all assets
+	void handleGenerateAssets();
+
 	// Prints in Chat the given message
 	void printCommandMessage(const std::string &commandMessage, ELogLevel::ELogLevel messageType = ELogLevel::NOT_SET);
 	void giveTurn(const PlayerColor &color);
diff --color -urN vcmi-1.5.7/client/Client.cpp vcmi/client/Client.cpp
--- vcmi-1.5.7/client/Client.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/Client.cpp	2024-12-19 15:00:22.239120704 +0100
@@ -13,6 +13,7 @@
 
 #include "CGameInfo.h"
 #include "CPlayerInterface.h"
+#include "PlayerLocalState.h"
 #include "CServerHandler.h"
 #include "ClientNetPackVisitors.h"
 #include "adventureMap/AdventureMapInterface.h"
@@ -29,13 +30,10 @@
 #include "../lib/VCMIDirs.h"
 #include "../lib/UnlockGuard.h"
 #include "../lib/battle/BattleInfo.h"
-#include "../lib/serializer/BinaryDeserializer.h"
-#include "../lib/serializer/BinarySerializer.h"
 #include "../lib/serializer/Connection.h"
 #include "../lib/mapping/CMapService.h"
 #include "../lib/pathfinder/CGPathNode.h"
 #include "../lib/filesystem/Filesystem.h"
-#include "../lib/registerTypes/RegisterTypesClientPacks.h"
 
 #include <memory>
 #include <vcmi/events/EventBus.h>
@@ -50,53 +48,6 @@
 
 ThreadSafeVector<int> CClient::waitingRequest;
 
-template<typename T> class CApplyOnCL;
-
-class CBaseForCLApply
-{
-public:
-	virtual void applyOnClAfter(CClient * cl, CPack * pack) const =0;
-	virtual void applyOnClBefore(CClient * cl, CPack * pack) const =0;
-	virtual ~CBaseForCLApply(){}
-
-	template<typename U> static CBaseForCLApply * getApplier(const U * t = nullptr)
-	{
-		return new CApplyOnCL<U>();
-	}
-};
-
-template<typename T> class CApplyOnCL : public CBaseForCLApply
-{
-public:
-	void applyOnClAfter(CClient * cl, CPack * pack) const override
-	{
-		T * ptr = static_cast<T *>(pack);
-		ApplyClientNetPackVisitor visitor(*cl, *cl->gameState());
-		ptr->visit(visitor);
-	}
-	void applyOnClBefore(CClient * cl, CPack * pack) const override
-	{
-		T * ptr = static_cast<T *>(pack);
-		ApplyFirstClientNetPackVisitor visitor(*cl, *cl->gameState());
-		ptr->visit(visitor);
-	}
-};
-
-template<> class CApplyOnCL<CPack>: public CBaseForCLApply
-{
-public:
-	void applyOnClAfter(CClient * cl, CPack * pack) const override
-	{
-		logGlobal->error("Cannot apply on CL plain CPack!");
-		assert(0);
-	}
-	void applyOnClBefore(CClient * cl, CPack * pack) const override
-	{
-		logGlobal->error("Cannot apply on CL plain CPack!");
-		assert(0);
-	}
-};
-
 CPlayerEnvironment::CPlayerEnvironment(PlayerColor player_, CClient * cl_, std::shared_ptr<CCallback> mainCallback_)
 	: player(player_),
 	cl(cl_),
@@ -130,12 +81,9 @@
 	return mainCallback.get();
 }
 
-
 CClient::CClient()
 {
 	waitingRequest.clear();
-	applier = std::make_shared<CApplier<CBaseForCLApply>>();
-	registerTypesClientPacks(*applier);
 	gs = nullptr;
 }
 
@@ -203,137 +151,9 @@
 	reinitScripting();
 
 	initPlayerEnvironments();
-	
-	// Loading of client state - disabled for now
-	// Since client no longer writes or loads its own state and instead receives it from server
-	// client state serializer will serialize its own copies of all pointers, e.g. heroes/towns/objects
-	// and on deserialize will create its own copies (instead of using copies from state received from server)
-	// Potential solutions:
-	// 1) Use server gamestate to deserialize pointers, so any pointer to same object will point to server instance and not our copy
-	// 2) Remove all serialization of pointers with instance ID's and restore them on load (including AI deserializer code)
-	// 3) Completely remove client savegame and send all information, like hero paths and sleeping status to server (either in form of hero properties or as some generic "client options" message
-#ifdef BROKEN_CLIENT_STATE_SERIALIZATION_HAS_BEEN_FIXED
-	// try to deserialize client data including sleepingHeroes
-	try
-	{
-		boost::filesystem::path clientSaveName = *CResourceHandler::get()->getResourceName(ResourcePath(CSH->si->mapname, EResType::CLIENT_SAVEGAME));
-
-		if(clientSaveName.empty())
-			throw std::runtime_error("Cannot open client part of " + CSH->si->mapname);
-
-		std::unique_ptr<CLoadFile> loader (new CLoadFile(clientSaveName));
-		serialize(loader->serializer, loader->serializer.version);
-
-		logNetwork->info("Client data loaded.");
-	}
-	catch(std::exception & e)
-	{
-		logGlobal->info("Cannot load client data for game %s. Error: %s", CSH->si->mapname, e.what());
-	}
-#endif
-
 	initPlayerInterfaces();
 }
 
-void CClient::serialize(BinarySerializer & h)
-{
-	assert(h.saving);
-	ui8 players = static_cast<ui8>(playerint.size());
-	h & players;
-
-	for(auto i = playerint.begin(); i != playerint.end(); i++)
-	{
-		logGlobal->trace("Saving player %s interface", i->first);
-		assert(i->first == i->second->playerID);
-		h & i->first;
-		h & i->second->dllName;
-		h & i->second->human;
-		i->second->saveGame(h);
-	}
-
-#if SCRIPTING_ENABLED
-	JsonNode scriptsState;
-	clientScripts->serializeState(h.saving, scriptsState);
-	h & scriptsState;
-#endif
-}
-
-void CClient::serialize(BinaryDeserializer & h)
-{
-	assert(!h.saving);
-	ui8 players = 0;
-	h & players;
-
-	for(int i = 0; i < players; i++)
-	{
-		std::string dllname;
-		PlayerColor pid;
-		bool isHuman = false;
-		auto prevInt = LOCPLINT;
-
-		h & pid;
-		h & dllname;
-		h & isHuman;
-		assert(dllname.length() == 0 || !isHuman);
-		if(pid == PlayerColor::NEUTRAL)
-		{
-			logGlobal->trace("Neutral battle interfaces are not serialized.");
-			continue;
-		}
-
-		logGlobal->trace("Loading player %s interface", pid);
-		std::shared_ptr<CGameInterface> nInt;
-		if(dllname.length())
-			nInt = CDynLibHandler::getNewAI(dllname);
-		else
-			nInt = std::make_shared<CPlayerInterface>(pid);
-
-		nInt->dllName = dllname;
-		nInt->human = isHuman;
-		nInt->playerID = pid;
-
-		bool shouldResetInterface = true;
-		// Client no longer handle this player at all
-		if(!vstd::contains(CSH->getAllClientPlayers(CSH->logicConnection->connectionID), pid))
-		{
-			logGlobal->trace("Player %s is not belong to this client. Destroying interface", pid);
-		}
-		else if(isHuman && !vstd::contains(CSH->getHumanColors(), pid))
-		{
-			logGlobal->trace("Player %s is no longer controlled by human. Destroying interface", pid);
-		}
-		else if(!isHuman && vstd::contains(CSH->getHumanColors(), pid))
-		{
-			logGlobal->trace("Player %s is no longer controlled by AI. Destroying interface", pid);
-		}
-		else
-		{
-			installNewPlayerInterface(nInt, pid);
-			shouldResetInterface = false;
-		}
-
-		// loadGame needs to be called after initGameInterface to load paths correctly
-		// initGameInterface is called in installNewPlayerInterface
-		nInt->loadGame(h);
-
-		if (shouldResetInterface)
-		{
-			nInt.reset();
-			LOCPLINT = prevInt;
-		}
-	}
-
-#if SCRIPTING_ENABLED
-	{
-		JsonNode scriptsState;
-		h & scriptsState;
-		clientScripts->serializeState(h.saving, scriptsState);
-	}
-#endif
-
-	logNetwork->trace("Loaded client part of save %d ms", CSH->th->getDiff());
-}
-
 void CClient::save(const std::string & fname)
 {
 	if(!gs->currentBattles.empty())
@@ -343,7 +163,7 @@
 	}
 
 	SaveGame save_game(fname);
-	sendRequest(&save_game, PlayerColor::NEUTRAL);
+	sendRequest(save_game, PlayerColor::NEUTRAL);
 }
 
 void CClient::endNetwork()
@@ -476,7 +296,7 @@
 	logNetwork->trace("Initialized player interfaces %d ms", CSH->th->getDiff());
 }
 
-std::string CClient::aiNameForPlayer(const PlayerSettings & ps, bool battleAI, bool alliedToHuman)
+std::string CClient::aiNameForPlayer(const PlayerSettings & ps, bool battleAI, bool alliedToHuman) const
 {
 	if(ps.name.size())
 	{
@@ -488,7 +308,7 @@
 	return aiNameForPlayer(battleAI, alliedToHuman);
 }
 
-std::string CClient::aiNameForPlayer(bool battleAI, bool alliedToHuman)
+std::string CClient::aiNameForPlayer(bool battleAI, bool alliedToHuman) const
 {
 	const int sensibleAILimit = settings["session"]["oneGoodAI"].Bool() ? 1 : PlayerColor::PLAYER_LIMIT_I;
 	std::string goodAdventureAI = alliedToHuman ? settings["server"]["alliedAI"].String() : settings["server"]["playerAI"].String();
@@ -528,41 +348,35 @@
 	}
 }
 
-void CClient::handlePack(CPack * pack)
+void CClient::handlePack(CPackForClient & pack)
 {
-	CBaseForCLApply * apply = applier->getApplier(CTypeList::getInstance().getTypeID(pack)); //find the applier
-	if(apply)
-	{
-		apply->applyOnClBefore(this, pack);
-		logNetwork->trace("\tMade first apply on cl: %s", typeid(*pack).name());
-		{
-			boost::unique_lock<boost::shared_mutex> lock(CGameState::mutex);
-			gs->apply(pack);
-		}
-		logNetwork->trace("\tApplied on gs: %s", typeid(*pack).name());
-		apply->applyOnClAfter(this, pack);
-		logNetwork->trace("\tMade second apply on cl: %s", typeid(*pack).name());
-	}
-	else
+	ApplyClientNetPackVisitor afterVisitor(*this, *gameState());
+	ApplyFirstClientNetPackVisitor beforeVisitor(*this, *gameState());
+
+	pack.visit(beforeVisitor);
+	logNetwork->trace("\tMade first apply on cl: %s", typeid(pack).name());
 	{
-		logNetwork->error("Message %s cannot be applied, cannot find applier!", typeid(*pack).name());
+		boost::unique_lock lock(CGameState::mutex);
+		gs->apply(pack);
 	}
-	delete pack;
+	logNetwork->trace("\tApplied on gs: %s", typeid(pack).name());
+	pack.visit(afterVisitor);
+	logNetwork->trace("\tMade second apply on cl: %s", typeid(pack).name());
 }
 
-int CClient::sendRequest(const CPackForServer * request, PlayerColor player)
+int CClient::sendRequest(const CPackForServer & request, PlayerColor player)
 {
 	static ui32 requestCounter = 1;
 
 	ui32 requestID = requestCounter++;
-	logNetwork->trace("Sending a request \"%s\". It'll have an ID=%d.", typeid(*request).name(), requestID);
+	logNetwork->trace("Sending a request \"%s\". It'll have an ID=%d.", typeid(request).name(), requestID);
 
 	waitingRequest.pushBack(requestID);
-	request->requestID = requestID;
-	request->player = player;
+	request.requestID = requestID;
+	request.player = player;
 	CSH->logicConnection->sendPack(request);
 	if(vstd::contains(playerint, player))
-		playerint[player]->requestSent(request, requestID);
+		playerint[player]->requestSent(&request, requestID);
 
 	return requestID;
 }
@@ -571,8 +385,8 @@
 {
 	std::shared_ptr<CPlayerInterface> att;
 	std::shared_ptr<CPlayerInterface> def;
-	auto & leftSide = info->sides[0];
-	auto & rightSide = info->sides[1];
+	const auto & leftSide = info->getSide(BattleSide::LEFT_SIDE);
+	const auto & rightSide = info->getSide(BattleSide::RIGHT_SIDE);
 
 	for(auto & battleCb : battleCallbacks)
 	{
@@ -581,17 +395,17 @@
 	}
 
 	//If quick combat is not, do not prepare interfaces for battleint
-	auto callBattleStart = [&](PlayerColor color, ui8 side)
+	auto callBattleStart = [&](PlayerColor color, BattleSide side)
 	{
 		if(vstd::contains(battleints, color))
 			battleints[color]->battleStart(info->battleID, leftSide.armyObject, rightSide.armyObject, info->tile, leftSide.hero, rightSide.hero, side, info->replayAllowed);
 	};
 	
-	callBattleStart(leftSide.color, 0);
-	callBattleStart(rightSide.color, 1);
-	callBattleStart(PlayerColor::UNFLAGGABLE, 1);
+	callBattleStart(leftSide.color, BattleSide::LEFT_SIDE);
+	callBattleStart(rightSide.color, BattleSide::RIGHT_SIDE);
+	callBattleStart(PlayerColor::UNFLAGGABLE, BattleSide::RIGHT_SIDE);
 	if(settings["session"]["spectate"].Bool() && !settings["session"]["spectate-skip-battle"].Bool())
-		callBattleStart(PlayerColor::SPECTATOR, 1);
+		callBattleStart(PlayerColor::SPECTATOR, BattleSide::RIGHT_SIDE);
 	
 	if(vstd::contains(playerint, leftSide.color) && playerint[leftSide.color]->human)
 		att = std::dynamic_pointer_cast<CPlayerInterface>(playerint[leftSide.color]);
@@ -608,9 +422,9 @@
 			{
 				auto side = interface->cb->getBattle(info->battleID)->playerToSide(interface->playerID);
 
-				if(interface->playerID == info->sides[info->tacticsSide].color)
+				if(interface->playerID == info->getSide(info->tacticsSide).color)
 				{
-					auto action = BattleAction::makeEndOFTacticPhase(*side);
+					auto action = BattleAction::makeEndOFTacticPhase(side);
 					interface->cb->battleMakeTacticAction(info->battleID, action);
 				}
 			}
@@ -642,7 +456,7 @@
 
 	if(info->tacticDistance)
 	{
-		auto tacticianColor = info->sides[info->tacticsSide].color;
+		auto tacticianColor = info->getSide(info->tacticsSide).color;
 
 		if (vstd::contains(battleints, tacticianColor))
 			battleints[tacticianColor]->yourTacticPhase(info->battleID, info->tacticDistance);
@@ -651,9 +465,11 @@
 
 void CClient::battleFinished(const BattleID & battleID)
 {
-	for(auto & side : gs->getBattle(battleID)->sides)
-		if(battleCallbacks.count(side.color))
-			battleCallbacks[side.color]->onBattleEnded(battleID);
+	for(auto side : { BattleSide::ATTACKER, BattleSide::DEFENDER })
+	{
+		if(battleCallbacks.count(gs->getBattle(battleID)->getSide(side).color))
+			battleCallbacks[gs->getBattle(battleID)->getSide(side).color]->onBattleEnded(battleID);
+	}
 
 	if(settings["session"]["spectate"].Bool() && !settings["session"]["spectate-skip-battle"].Bool())
 		battleCallbacks[PlayerColor::SPECTATOR]->onBattleEnded(battleID);
@@ -678,12 +494,32 @@
 	}
 }
 
+void CClient::updatePath(const ObjectInstanceID & id)
+{
+	invalidatePaths();
+	auto hero = getHero(id);
+	updatePath(hero);
+}
+
+void CClient::updatePath(const CGHeroInstance * hero)
+{
+	if(LOCPLINT && hero)
+		LOCPLINT->localState->verifyPath(hero);
+}
+
 void CClient::invalidatePaths()
 {
 	boost::unique_lock<boost::mutex> pathLock(pathCacheMutex);
 	pathCache.clear();
 }
 
+vstd::RNG & CClient::getRandomGenerator()
+{
+	// Client should use CRandomGenerator::getDefault() for UI logic
+	// Gamestate should never call this method on client!
+	throw std::runtime_error("Illegal access to random number generator from client code!");
+}
+
 std::shared_ptr<const CPathsInfo> CClient::getPathsInfo(const CGHeroInstance * h)
 {
 	assert(h);
diff --color -urN vcmi-1.5.7/client/Client.h vcmi/client/Client.h
--- vcmi-1.5.7/client/Client.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/Client.h	2024-12-19 15:00:22.239120704 +0100
@@ -16,17 +16,13 @@
 
 VCMI_LIB_NAMESPACE_BEGIN
 
-struct CPack;
 struct CPackForServer;
 class IBattleEventsReceiver;
 class CBattleGameInterface;
 class CGameInterface;
-class BinaryDeserializer;
-class BinarySerializer;
 class BattleAction;
 class BattleInfo;
-
-template<typename T> class CApplier;
+struct BankConfig;
 
 #if SCRIPTING_ENABLED
 namespace scripting
@@ -131,8 +127,6 @@
 
 	void newGame(CGameState * gameState);
 	void loadGame(CGameState * gameState);
-	void serialize(BinarySerializer & h);
-	void serialize(BinaryDeserializer & h);
 
 	void save(const std::string & fname);
 	void endNetwork();
@@ -141,35 +135,38 @@
 	void initMapHandler();
 	void initPlayerEnvironments();
 	void initPlayerInterfaces();
-	std::string aiNameForPlayer(const PlayerSettings & ps, bool battleAI, bool alliedToHuman); //empty means no AI -> human
-	std::string aiNameForPlayer(bool battleAI, bool alliedToHuman);
+	std::string aiNameForPlayer(const PlayerSettings & ps, bool battleAI, bool alliedToHuman) const; //empty means no AI -> human
+	std::string aiNameForPlayer(bool battleAI, bool alliedToHuman) const;
 	void installNewPlayerInterface(std::shared_ptr<CGameInterface> gameInterface, PlayerColor color, bool battlecb = false);
 	void installNewBattleInterface(std::shared_ptr<CBattleGameInterface> battleInterface, PlayerColor color, bool needCallback = true);
 
 	static ThreadSafeVector<int> waitingRequest; //FIXME: make this normal field (need to join all threads before client destruction)
 
-	void handlePack(CPack * pack); //applies the given pack and deletes it
-	int sendRequest(const CPackForServer * request, PlayerColor player); //returns ID given to that request
+	void handlePack(CPackForClient & pack); //applies the given pack and deletes it
+	int sendRequest(const CPackForServer & request, PlayerColor player); //returns ID given to that request
 
 	void battleStarted(const BattleInfo * info);
 	void battleFinished(const BattleID & battleID);
 	void startPlayerBattleAction(const BattleID & battleID, PlayerColor color);
 
-	void invalidatePaths();
+	void invalidatePaths(); // clears this->pathCache()
+	void updatePath(const ObjectInstanceID & heroID); // invalidatePaths and update displayed hero path 
+	void updatePath(const CGHeroInstance * hero);
 	std::shared_ptr<const CPathsInfo> getPathsInfo(const CGHeroInstance * h);
 
 	friend class CCallback; //handling players actions
 	friend class CBattleCallback; //handling players actions
 
 	void changeSpells(const CGHeroInstance * hero, bool give, const std::set<SpellID> & spells) override {};
+	void setResearchedSpells(const CGTownInstance * town, int level, const std::vector<SpellID> & spells, bool accepted) override {};
 	bool removeObject(const CGObjectInstance * obj, const PlayerColor & initiator) override {return false;};
-	void createObject(const int3 & visitablePosition, const PlayerColor & initiator, MapObjectID type, MapObjectSubID subtype) override {};
+	void createBoat(const int3 & visitablePosition, BoatId type, PlayerColor initiator) override {};
 	void setOwner(const CGObjectInstance * obj, PlayerColor owner) override {};
 	void giveExperience(const CGHeroInstance * hero, TExpType val) override {};
 	void changePrimSkill(const CGHeroInstance * hero, PrimarySkill which, si64 val, bool abs = false) override {};
 	void changeSecSkill(const CGHeroInstance * hero, SecondarySkill which, int val, bool abs = false) override {};
 
-	void showBlockingDialog(BlockingDialog * iw) override {};
+	void showBlockingDialog(const IObjectInterface * caller, BlockingDialog * iw) override {};
 	void showGarrisonDialog(ObjectInstanceID upobj, ObjectInstanceID hid, bool removableUnits) override {};
 	void showTeleportDialog(TeleportDialog * iw) override {};
 	void showObjectWindow(const CGObjectInstance * object, EOpenWindowMode window, const CGHeroInstance * visitor, bool addQuery) override {};
@@ -189,17 +186,17 @@
 
 	void removeAfterVisit(const CGObjectInstance * object) override {};
 	bool swapGarrisonOnSiege(ObjectInstanceID tid) override {return false;};
-	bool giveHeroNewArtifact(const CGHeroInstance * h, const CArtifact * artType, ArtifactPosition pos) override {return false;}
-	bool putArtifact(const ArtifactLocation & al, const CArtifactInstance * art, std::optional<bool> askAssemble) override {return false;};
+	bool giveHeroNewArtifact(const CGHeroInstance * h, const ArtifactID & artId, const ArtifactPosition & pos) override {return false;};
+	bool giveHeroNewScroll(const CGHeroInstance * h, const SpellID & spellId, const ArtifactPosition & pos) override {return false;};
+	bool putArtifact(const ArtifactLocation & al, const ArtifactInstanceID & id, std::optional<bool> askAssemble) override {return false;};
 	void removeArtifact(const ArtifactLocation & al) override {};
 	bool moveArtifact(const PlayerColor & player, const ArtifactLocation & al1, const ArtifactLocation & al2) override {return false;};
 
 	void heroVisitCastle(const CGTownInstance * obj, const CGHeroInstance * hero) override {};
 	void visitCastleObjects(const CGTownInstance * obj, const CGHeroInstance * hero) override {};
 	void stopHeroVisitCastle(const CGTownInstance * obj, const CGHeroInstance * hero) override {};
-	void startBattlePrimary(const CArmedInstance * army1, const CArmedInstance * army2, int3 tile, const CGHeroInstance * hero1, const CGHeroInstance * hero2, bool creatureBank = false, const CGTownInstance * town = nullptr) override {}; //use hero=nullptr for no hero
-	void startBattleI(const CArmedInstance * army1, const CArmedInstance * army2, int3 tile, bool creatureBank = false) override {}; //if any of armies is hero, hero will be used
-	void startBattleI(const CArmedInstance * army1, const CArmedInstance * army2, bool creatureBank = false) override {}; //if any of armies is hero, hero will be used, visitable tile of second obj is place of battle
+	void startBattle(const CArmedInstance * army1, const CArmedInstance * army2, int3 tile, const CGHeroInstance * hero1, const CGHeroInstance * hero2, const BattleLayout & layout, const CGTownInstance * town) override {}; //use hero=nullptr for no hero
+	void startBattle(const CArmedInstance * army1, const CArmedInstance * army2) override {}; //if any of armies is hero, hero will be used
 	bool moveHero(ObjectInstanceID hid, int3 dst, EMovementMode movementMode, bool transit = false, PlayerColor asker = PlayerColor::NEUTRAL) override {return false;};
 	void giveHeroBonus(GiveBonus * bonus) override {};
 	void setMovePoints(SetMovePoints * smp) override {};
@@ -207,19 +204,24 @@
 	void setManaPoints(ObjectInstanceID hid, int val) override {};
 	void giveHero(ObjectInstanceID id, PlayerColor player, ObjectInstanceID boatId = ObjectInstanceID()) override {};
 	void changeObjPos(ObjectInstanceID objid, int3 newPos, const PlayerColor & initiator) override {};
-	void sendAndApply(CPackForClient * pack) override {};
+	void sendAndApply(CPackForClient & pack) override {};
 	void heroExchange(ObjectInstanceID hero1, ObjectInstanceID hero2) override {};
 	void castSpell(const spells::Caster * caster, SpellID spellID, const int3 &pos) override {};
 
 	void changeFogOfWar(int3 center, ui32 radius, PlayerColor player, ETileVisibility mode) override {}
-	void changeFogOfWar(std::unordered_set<int3> & tiles, PlayerColor player, ETileVisibility mode) override {}
+	void changeFogOfWar(const std::unordered_set<int3> & tiles, PlayerColor player, ETileVisibility mode) override {}
 
 	void setObjPropertyValue(ObjectInstanceID objid, ObjProperty prop, int32_t value) override {};
 	void setObjPropertyID(ObjectInstanceID objid, ObjProperty prop, ObjPropertyID identifier) override {};
+	void setBankObjectConfiguration(ObjectInstanceID objid, const BankConfig & configuration) override {};
+	void setRewardableObjectConfiguration(ObjectInstanceID objid, const Rewardable::Configuration & configuration) override {};
+	void setRewardableObjectConfiguration(ObjectInstanceID townInstanceID, BuildingID buildingID, const Rewardable::Configuration & configuration) override{};
 
 	void showInfoDialog(InfoWindow * iw) override {};
 	void removeGUI() const;
 
+	vstd::RNG & getRandomGenerator() override;
+
 #if SCRIPTING_ENABLED
 	scripting::Pool * getGlobalContextPool() const override;
 #endif
@@ -233,8 +235,6 @@
 #endif
 	std::unique_ptr<events::EventBus> clientEventBus;
 
-	std::shared_ptr<CApplier<CBaseForCLApply>> applier;
-
 	mutable boost::mutex pathCacheMutex;
 	std::map<const CGHeroInstance *, std::shared_ptr<CPathsInfo>> pathCache;
 
diff --color -urN vcmi-1.5.7/client/ClientNetPackVisitors.h vcmi/client/ClientNetPackVisitors.h
--- vcmi-1.5.7/client/ClientNetPackVisitors.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/ClientNetPackVisitors.h	2024-12-19 15:00:22.240120745 +0100
@@ -37,6 +37,7 @@
 	void visitHeroVisitCastle(HeroVisitCastle & pack) override;
 	void visitSetMana(SetMana & pack) override;
 	void visitSetMovePoints(SetMovePoints & pack) override;
+	void visitSetResearchedSpells(SetResearchedSpells & pack) override;
 	void visitFoWChange(FoWChange & pack) override;
 	void visitChangeStackCount(ChangeStackCount & pack) override;
 	void visitSetStackType(SetStackType & pack) override;
@@ -47,8 +48,7 @@
 	void visitBulkRebalanceStacks(BulkRebalanceStacks & pack) override;
 	void visitBulkSmartRebalanceStacks(BulkSmartRebalanceStacks & pack) override;
 	void visitPutArtifact(PutArtifact & pack) override;
-	void visitEraseArtifact(EraseArtifact & pack) override;
-	void visitMoveArtifact(MoveArtifact & pack) override;
+	void visitEraseArtifact(BulkEraseArtifacts & pack) override;
 	void visitBulkMoveArtifacts(BulkMoveArtifacts & pack) override;
 	void visitAssembledArtifact(AssembledArtifact & pack) override;
 	void visitDisassembledArtifact(DisassembledArtifact & pack) override;
diff --color -urN vcmi-1.5.7/client/CMakeLists.txt vcmi/client/CMakeLists.txt
--- vcmi-1.5.7/client/CMakeLists.txt	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/CMakeLists.txt	2024-12-19 15:00:22.238120662 +0100
@@ -1,4 +1,4 @@
-set(client_SRCS
+set(vcmiclientcommon_SRCS
 	StdInc.cpp
 	../CCallback.cpp
 
@@ -27,6 +27,7 @@
 	battle/BattleStacksController.cpp
 	battle/BattleWindow.cpp
 	battle/CreatureAnimation.cpp
+	battle/BattleOverlayLogVisualizer.cpp
 
 	eventsSDL/NotificationHandler.cpp
 	eventsSDL/InputHandler.cpp
@@ -64,6 +65,7 @@
 	mainmenu/CPrologEpilogVideo.cpp
 	mainmenu/CreditsScreen.cpp
 	mainmenu/CHighScoreScreen.cpp
+	mainmenu/CStatisticScreen.cpp
 
 	mapView/MapRenderer.cpp
 	mapView/MapRendererContext.cpp
@@ -74,7 +76,14 @@
 	mapView/MapViewController.cpp
 	mapView/MapViewModel.cpp
 	mapView/mapHandler.cpp
+	mapView/MapOverlayLogVisualizer.cpp
 
+	media/CAudioBase.cpp
+	media/CMusicHandler.cpp
+	media/CSoundHandler.cpp
+	media/CVideoHandler.cpp
+
+	render/AssetGenerator.cpp
 	render/CAnimation.cpp
 	render/CBitmapHandler.cpp
 	render/CDefFile.cpp
@@ -83,12 +92,14 @@
 	render/Colors.cpp
 	render/Graphics.cpp
 	render/IFont.cpp
+	render/ImageLocator.cpp
 
 	renderSDL/CBitmapFont.cpp
-	renderSDL/CBitmapHanFont.cpp
 	renderSDL/CTrueTypeFont.cpp
 	renderSDL/CursorHardware.cpp
 	renderSDL/CursorSoftware.cpp
+	renderSDL/FontChain.cpp
+	renderSDL/ImageScaled.cpp
 	renderSDL/RenderHandler.cpp
 	renderSDL/SDLImage.cpp
 	renderSDL/SDLImageLoader.cpp
@@ -105,8 +116,8 @@
 	globalLobby/GlobalLobbyWindow.cpp
 
 	widgets/Buttons.cpp
-	widgets/CArtPlace.cpp
 	widgets/CComponent.cpp
+	widgets/CComponentHolder.cpp
 	widgets/CExchangeController.cpp
 	widgets/CGarrisonInt.cpp
 	widgets/CreatureCostBox.cpp
@@ -126,6 +137,7 @@
 	widgets/CArtifactsOfHeroMarket.cpp
 	widgets/CArtifactsOfHeroBackpack.cpp
 	widgets/RadialMenu.cpp
+	widgets/VideoWidget.cpp
 	widgets/markets/CAltarArtifacts.cpp
 	widgets/markets/CAltarCreatures.cpp
 	widgets/markets/CArtifactsBuying.cpp
@@ -162,13 +174,13 @@
 	windows/settings/BattleOptionsTab.cpp
 	windows/settings/AdventureOptionsTab.cpp
 
+	xBRZ/xbrz.cpp
+
+	ArtifactsUIController.cpp
 	CGameInfo.cpp
-	CMT.cpp
-	CMusicHandler.cpp
 	CPlayerInterface.cpp
 	PlayerLocalState.cpp
 	CServerHandler.cpp
-	CVideoHandler.cpp
 	Client.cpp
 	ClientCommandManager.cpp
 	GameChatHandler.cpp
@@ -178,7 +190,7 @@
 	ServerRunner.cpp
 )
 
-set(client_HEADERS
+set(vcmiclientcommon_HEADERS
 	StdInc.h
 
 	adventureMap/AdventureMapInterface.h
@@ -208,6 +220,7 @@
 	battle/BattleStacksController.h
 	battle/BattleWindow.h
 	battle/CreatureAnimation.h
+	battle/BattleOverlayLogVisualizer.h
 
 	eventsSDL/NotificationHandler.h
 	eventsSDL/InputHandler.h
@@ -248,6 +261,7 @@
 	mainmenu/CPrologEpilogVideo.h
 	mainmenu/CreditsScreen.h
 	mainmenu/CHighScoreScreen.h
+	mainmenu/CStatisticScreen.h
 
 	mapView/IMapRendererContext.h
 	mapView/IMapRendererObserver.h
@@ -260,7 +274,18 @@
 	mapView/MapViewController.h
 	mapView/MapViewModel.h
 	mapView/mapHandler.h
+	mapView/MapOverlayLogVisualizer.h
 
+	media/CAudioBase.h
+	media/CEmptyVideoPlayer.h
+	media/CMusicHandler.h
+	media/CSoundHandler.h
+	media/CVideoHandler.h
+	media/IMusicPlayer.h
+	media/ISoundPlayer.h
+	media/IVideoPlayer.h
+
+	render/AssetGenerator.h
 	render/CAnimation.h
 	render/CBitmapHandler.h
 	render/CDefFile.h
@@ -273,14 +298,16 @@
 	render/IFont.h
 	render/IImage.h
 	render/IImageLoader.h
+	render/ImageLocator.h
 	render/IRenderHandler.h
 	render/IScreenHandler.h
 
 	renderSDL/CBitmapFont.h
-	renderSDL/CBitmapHanFont.h
 	renderSDL/CTrueTypeFont.h
 	renderSDL/CursorHardware.h
 	renderSDL/CursorSoftware.h
+	renderSDL/FontChain.h
+	renderSDL/ImageScaled.h
 	renderSDL/RenderHandler.h
 	renderSDL/SDLImage.h
 	renderSDL/SDLImageLoader.h
@@ -300,8 +327,8 @@
 	globalLobby/GlobalLobbyWindow.h
 
 	widgets/Buttons.h
-	widgets/CArtPlace.h
 	widgets/CComponent.h
+	widgets/CComponentHolder.h
 	widgets/CExchangeController.h
 	widgets/CGarrisonInt.h
 	widgets/CreatureCostBox.h
@@ -320,7 +347,9 @@
 	widgets/CArtifactsOfHeroAltar.h
 	widgets/CArtifactsOfHeroMarket.h
 	widgets/CArtifactsOfHeroBackpack.h
+	widgets/IVideoHolder.h
 	widgets/RadialMenu.h
+	widgets/VideoWidget.h
 	widgets/markets/CAltarArtifacts.h
 	widgets/markets/CAltarCreatures.h
 	widgets/markets/CArtifactsBuying.h
@@ -357,13 +386,15 @@
 	windows/settings/BattleOptionsTab.h
 	windows/settings/AdventureOptionsTab.h
 
+	xBRZ/xbrz.h
+	xBRZ/xbrz_tools.h
+
+	ArtifactsUIController.h
 	CGameInfo.h
 	CMT.h
-	CMusicHandler.h
 	CPlayerInterface.h
 	PlayerLocalState.h
 	CServerHandler.h
-	CVideoHandler.h
 	Client.h
 	ClientCommandManager.h
 	ClientNetPackVisitors.h
@@ -376,76 +407,50 @@
 )
 
 if(APPLE_IOS)
-	set(client_SRCS ${client_SRCS}
-		CFocusableHelper.cpp
-		ios/GameChatKeyboardHandler.m
-		ios/main.m
-		ios/startSDL.mm
+	set(vcmiclientcommon_SRCS ${vcmiclientcommon_SRCS}
 		ios/utils.mm
 	)
-	set(client_HEADERS ${client_HEADERS}
-		CFocusableHelper.h
-		ios/GameChatKeyboardHandler.h
-		ios/startSDL.h
+	set(vcmiclientcommon_HEADERS ${vcmiclientcommon_HEADERS}
 		ios/utils.h
 	)
 endif()
 
-assign_source_group(${client_SRCS} ${client_HEADERS} VCMI_client.rc)
-
-if(ANDROID)
-	add_library(vcmiclient SHARED ${client_SRCS} ${client_HEADERS})
-	set_target_properties(vcmiclient PROPERTIES
-		OUTPUT_NAME "vcmiclient_${ANDROID_ABI}" # required by Qt
-	)
-else()
-	add_executable(vcmiclient ${client_SRCS} ${client_HEADERS})
-endif()
+assign_source_group(${vcmiclientcommon_SRCS} ${vcmiclientcommon_HEADERS})
+add_library(vcmiclientcommon STATIC ${vcmiclientcommon_SRCS} ${vcmiclientcommon_HEADERS})
 
 if(NOT ENABLE_STATIC_LIBS)
-	add_dependencies(vcmiclient
+	add_dependencies(vcmiclientcommon
 		BattleAI
 		EmptyAI
 		StupidAI
 		VCAI
 	)
 	if(ENABLE_NULLKILLER_AI)
-		add_dependencies(vcmiclient Nullkiller)
+		add_dependencies(vcmiclientcommon Nullkiller)
 	endif()
 endif()
 if(APPLE_IOS)
 	if(ENABLE_ERM)
-		add_dependencies(vcmiclient vcmiERM)
+		add_dependencies(vcmiclientcommon vcmiERM)
 	endif()
 	if(ENABLE_LUA)
-		add_dependencies(vcmiclient vcmiLua)
+		add_dependencies(vcmiclientcommon vcmiLua)
 	endif()
 endif()
 
 if(WIN32)
-	target_sources(vcmiclient PRIVATE "VCMI_client.rc")
-	set_target_properties(vcmiclient
+	set_target_properties(vcmiclientcommon
 		PROPERTIES
-			OUTPUT_NAME "VCMI_client"
-			PROJECT_LABEL "VCMI_client"
+			OUTPUT_NAME "VCMI_vcmiclientcommon"
+			PROJECT_LABEL "VCMI_vcmiclientcommon"
 	)
-	set_property(DIRECTORY ${CMAKE_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT vcmiclient)
+	set_property(DIRECTORY ${CMAKE_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT vcmiclientcommon)
 	if(NOT ENABLE_DEBUG_CONSOLE)
-		set_target_properties(vcmiclient PROPERTIES WIN32_EXECUTABLE)
-		target_link_libraries(vcmiclient SDL2::SDL2main)
-	endif()
-	target_compile_definitions(vcmiclient PRIVATE WINDOWS_IGNORE_PACKING_MISMATCH)
-
-# TODO: very hacky, find proper solution to copy AI dlls into bin dir
-	if(MSVC)
-		add_custom_command(TARGET vcmiclient POST_BUILD
-			WORKING_DIRECTORY "$<TARGET_FILE_DIR:vcmiclient>"
-			COMMAND ${CMAKE_COMMAND} -E copy AI/fuzzylite.dll fuzzylite.dll
-			COMMAND ${CMAKE_COMMAND} -E copy AI/tbb12.dll tbb12.dll
-		)
+		target_link_libraries(vcmiclientcommon SDL2::SDL2main)
 	endif()
+	target_compile_definitions(vcmiclientcommon PRIVATE WINDOWS_IGNORE_PACKING_MISMATCH)
 elseif(APPLE_IOS)
-	target_link_libraries(vcmiclient PRIVATE
+	target_link_libraries(vcmiclientcommon PRIVATE
 		iOS_utils
 
 		# FFmpeg
@@ -457,101 +462,31 @@
 		"-framework CoreMedia"
 		"-framework VideoToolbox"
 	)
-
-	set_target_properties(vcmiclient PROPERTIES
-		MACOSX_BUNDLE_INFO_PLIST "${CMAKE_CURRENT_LIST_DIR}/ios/Info.plist"
-		XCODE_ATTRIBUTE_LD_RUNPATH_SEARCH_PATHS "@executable_path/Frameworks"
-		XCODE_ATTRIBUTE_CODE_SIGNING_ALLOWED "$(CODE_SIGNING_ALLOWED_FOR_APPS)"
-		XCODE_ATTRIBUTE_ASSETCATALOG_COMPILER_APPICON_NAME AppIcon
-	)
-
-	foreach(XCODE_RESOURCE LaunchScreen.storyboard Images.xcassets Settings.bundle vcmi_logo.png)
-		set(XCODE_RESOURCE_PATH ios/${XCODE_RESOURCE})
-		target_sources(vcmiclient PRIVATE ${XCODE_RESOURCE_PATH})
-		set_source_files_properties(${XCODE_RESOURCE_PATH} PROPERTIES MACOSX_PACKAGE_LOCATION Resources)
-
-		# workaround to prevent CMAKE_SKIP_PRECOMPILE_HEADERS being added as compile flag
-		if(CMAKE_VERSION VERSION_GREATER_EQUAL "3.22.0" AND CMAKE_VERSION VERSION_LESS "3.25.0")
-			set_source_files_properties(${XCODE_RESOURCE_PATH} PROPERTIES LANGUAGE CXX)
-		endif()
-	endforeach()
-
-	set(CMAKE_EXE_LINKER_FLAGS "-Wl,-e,_client_main")
 endif()
 
-target_link_libraries(vcmiclient PRIVATE vcmiservercommon)
-if(ENABLE_SINGLE_APP_BUILD AND ENABLE_LAUNCHER)
-	target_link_libraries(vcmiclient PRIVATE vcmilauncher)
-endif()
+target_link_libraries(vcmiclientcommon PRIVATE vcmiservercommon)
 
-target_link_libraries(vcmiclient PRIVATE
+target_link_libraries(vcmiclientcommon PUBLIC
 		vcmi SDL2::SDL2 SDL2::Image SDL2::Mixer SDL2::TTF
 )
 
 if(ffmpeg_LIBRARIES)
-	target_link_libraries(vcmiclient PRIVATE
+	target_link_libraries(vcmiclientcommon PRIVATE
 		${ffmpeg_LIBRARIES}
 	)
 else()
-	target_compile_definitions(vcmiclient PRIVATE DISABLE_VIDEO)
+	target_compile_definitions(vcmiclientcommon PRIVATE DISABLE_VIDEO)
 endif()
 
-target_include_directories(vcmiclient PUBLIC
+target_include_directories(vcmiclientcommon PUBLIC
 	${CMAKE_CURRENT_SOURCE_DIR}
 )
 
 if (ffmpeg_INCLUDE_DIRS)
-	target_include_directories(vcmiclient PRIVATE
+	target_include_directories(vcmiclientcommon PRIVATE
 		${ffmpeg_INCLUDE_DIRS}
 	)
 endif()
 
-vcmi_set_output_dir(vcmiclient "")
-enable_pch(vcmiclient)
-
-if(APPLE_IOS)
-	vcmi_install_conan_deps("\${CMAKE_INSTALL_PREFIX}")
-	add_custom_command(TARGET vcmiclient POST_BUILD
-		COMMAND ios/set_build_version.sh "$<TARGET_BUNDLE_CONTENT_DIR:vcmiclient>"
-		COMMAND ${CMAKE_COMMAND} --install "${CMAKE_BINARY_DIR}" --component "${CMAKE_INSTALL_DEFAULT_COMPONENT_NAME}" --config "$<CONFIG>" --prefix "$<TARGET_BUNDLE_CONTENT_DIR:vcmiclient>"
-		COMMAND ios/rpath_remove_symlinks.sh
-		COMMAND ios/codesign.sh
-		WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}
-	)
-	install(TARGETS vcmiclient DESTINATION Payload COMPONENT app) # for ipa generation with cpack
-elseif(ANDROID)
-	find_program(androidDeployQt androiddeployqt
-		PATHS "${qtBinDir}"
-	)
-	vcmi_install_conan_deps("\${CMAKE_INSTALL_PREFIX}/${LIB_DIR}")
-
-	add_custom_target(android_deploy ALL
-		COMMAND ${CMAKE_COMMAND} --install "${CMAKE_BINARY_DIR}" --config "$<CONFIG>" --prefix "${androidQtBuildDir}"
-		COMMAND "${androidDeployQt}" --input "${CMAKE_BINARY_DIR}/androiddeployqt.json" --output "${androidQtBuildDir}" --android-platform "android-${ANDROID_TARGET_SDK_VERSION}" --verbose $<$<NOT:$<CONFIG:Debug>>:--release> ${ANDROIDDEPLOYQT_OPTIONS}
-		COMMAND_EXPAND_LISTS
-		VERBATIM
-		COMMENT "Create android package"
-	)
-	add_dependencies(android_deploy vcmiclient)
-else()
-	install(TARGETS vcmiclient DESTINATION ${BIN_DIR})
-endif()
-
-#install icons and desktop file on Linux
-if(NOT WIN32 AND NOT APPLE AND NOT ANDROID)
-	#FIXME: move to client makefile?
-	foreach(iconSize 16 22 32 48 64 128 256 512 1024 2048)
-		install(FILES "icons/vcmiclient.${iconSize}x${iconSize}.png"
-			DESTINATION "share/icons/hicolor/${iconSize}x${iconSize}/apps"
-			RENAME vcmiclient.png
-		)
-	endforeach()
-
-	install(FILES icons/vcmiclient.svg
-		DESTINATION share/icons/hicolor/scalable/apps
-		RENAME vcmiclient.svg
-	)
-	install(FILES icons/vcmiclient.desktop
-		DESTINATION share/applications
-	)
-endif()
+vcmi_set_output_dir(vcmiclientcommon "")
+enable_pch(vcmiclientcommon)
diff --color -urN vcmi-1.5.7/client/CMT.cpp vcmi/client/CMT.cpp
--- vcmi-1.5.7/client/CMT.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/CMT.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,549 +0,0 @@
-/*
- * CMT.cpp, part of VCMI engine
- *
- * Authors: listed in file AUTHORS in main folder
- *
- * License: GNU General Public License v2.0 or later
- * Full text of license available in license.txt file, in main folder
- *
- */
-
-// CMT.cpp : Defines the entry point for the console application.
-#include "StdInc.h"
-#include "CMT.h"
-
-#include "CGameInfo.h"
-#include "mainmenu/CMainMenu.h"
-#include "gui/CursorHandler.h"
-#include "eventsSDL/InputHandler.h"
-#include "CPlayerInterface.h"
-#include "CVideoHandler.h"
-#include "CMusicHandler.h"
-#include "gui/CGuiHandler.h"
-#include "gui/WindowHandler.h"
-#include "CServerHandler.h"
-#include "ClientCommandManager.h"
-#include "windows/CMessage.h"
-#include "windows/InfoWindows.h"
-#include "render/IScreenHandler.h"
-#include "render/Graphics.h"
-
-#include "../lib/CConfigHandler.h"
-#include "../lib/CGeneralTextHandler.h"
-#include "../lib/CThreadHelper.h"
-#include "../lib/ExceptionsCommon.h"
-#include "../lib/VCMIDirs.h"
-#include "../lib/VCMI_Lib.h"
-#include "../lib/filesystem/Filesystem.h"
-
-#include "../lib/logging/CBasicLogConfigurator.h"
-
-#include <boost/program_options.hpp>
-#include <vstd/StringUtils.h>
-
-#include <SDL_main.h>
-#include <SDL.h>
-
-#ifdef VCMI_ANDROID
-#include "../lib/CAndroidVMHelper.h"
-#include <SDL_system.h>
-#endif
-
-#if __MINGW32__
-#undef main
-#endif
-
-namespace po = boost::program_options;
-namespace po_style = boost::program_options::command_line_style;
-
-static std::atomic<bool> headlessQuit = false;
-static std::optional<std::string> criticalInitializationError;
-
-#ifndef VCMI_IOS
-void processCommand(const std::string &message);
-#endif
-void playIntro();
-[[noreturn]] static void quitApplication();
-static void mainLoop();
-
-static CBasicLogConfigurator *logConfig;
-
-void init()
-{
-	CStopWatch tmh;
-	try
-	{
-		loadDLLClasses();
-		CGI->setFromLib();
-	}
-	catch (const DataLoadingException & e)
-	{
-		criticalInitializationError = e.what();
-		return;
-	}
-
-	logGlobal->info("Initializing VCMI_Lib: %d ms", tmh.getDiff());
-
-	// Debug code to load all maps on start
-	//ClientCommandManager commandController;
-	//commandController.processCommand("convert txt", false);
-}
-
-static void prog_version()
-{
-	printf("%s\n", GameConstants::VCMI_VERSION.c_str());
-	std::cout << VCMIDirs::get().genHelpString();
-}
-
-static void prog_help(const po::options_description &opts)
-{
-	auto time = std::time(nullptr);
-	printf("%s - A Heroes of Might and Magic 3 clone\n", GameConstants::VCMI_VERSION.c_str());
-	printf("Copyright (C) 2007-%d VCMI dev team - see AUTHORS file\n", std::localtime(&time)->tm_year + 1900);
-	printf("This is free software; see the source for copying conditions. There is NO\n");
-	printf("warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n");
-	printf("\n");
-	std::cout << opts;
-}
-
-#if defined(VCMI_WINDOWS) && !defined(__GNUC__) && defined(VCMI_WITH_DEBUG_CONSOLE)
-int wmain(int argc, wchar_t* argv[])
-#elif defined(VCMI_MOBILE)
-int SDL_main(int argc, char *argv[])
-#else
-int main(int argc, char * argv[])
-#endif
-{
-#ifdef VCMI_ANDROID
-	CAndroidVMHelper::initClassloader(SDL_AndroidGetJNIEnv());
-	// boost will crash without this
-	setenv("LANG", "C", 1);
-#endif
-
-#if !defined(VCMI_MOBILE)
-	// Correct working dir executable folder (not bundle folder) so we can use executable relative paths
-	boost::filesystem::current_path(boost::filesystem::system_complete(argv[0]).parent_path());
-#endif
-	std::cout << "Starting... " << std::endl;
-	po::options_description opts("Allowed options");
-	po::variables_map vm;
-
-	opts.add_options()
-		("help,h", "display help and exit")
-		("version,v", "display version information and exit")
-		("testmap", po::value<std::string>(), "")
-		("testsave", po::value<std::string>(), "")
-		("spectate,s", "enable spectator interface for AI-only games")
-		("spectate-ignore-hero", "wont follow heroes on adventure map")
-		("spectate-hero-speed", po::value<int>(), "hero movement speed on adventure map")
-		("spectate-battle-speed", po::value<int>(), "battle animation speed for spectator")
-		("spectate-skip-battle", "skip battles in spectator view")
-		("spectate-skip-battle-result", "skip battle result window")
-		("onlyAI", "allow one to run without human player, all players will be default AI")
-		("headless", "runs without GUI, implies --onlyAI")
-		("ai", po::value<std::vector<std::string>>(), "AI to be used for the player, can be specified several times for the consecutive players")
-		("oneGoodAI", "puts one default AI and the rest will be EmptyAI")
-		("autoSkip", "automatically skip turns in GUI")
-		("disable-video", "disable video player")
-		("nointro,i", "skips intro movies")
-		("donotstartserver,d","do not attempt to start server and just connect to it instead server")
-		("serverport", po::value<si64>(), "override port specified in config file")
-		("savefrequency", po::value<si64>(), "limit auto save creation to each N days");
-
-	if(argc > 1)
-	{
-		try
-		{
-			po::store(po::parse_command_line(argc, argv, opts, po_style::unix_style|po_style::case_insensitive), vm);
-		}
-		catch(boost::program_options::error &e)
-		{
-			std::cerr << "Failure during parsing command-line options:\n" << e.what() << std::endl;
-		}
-	}
-
-	po::notify(vm);
-	if(vm.count("help"))
-	{
-		prog_help(opts);
-#ifdef VCMI_IOS
-		exit(0);
-#else
-		return 0;
-#endif
-	}
-	if(vm.count("version"))
-	{
-		prog_version();
-#ifdef VCMI_IOS
-		exit(0);
-#else
-		return 0;
-#endif
-	}
-
-	// Init old logging system and new (temporary) logging system
-	CStopWatch total;
-	CStopWatch pomtime;
-	std::cout.flags(std::ios::unitbuf);
-#ifndef VCMI_IOS
-	console = new CConsoleHandler();
-
-	auto callbackFunction = [](std::string buffer, bool calledFromIngameConsole)
-	{
-		ClientCommandManager commandController;
-		commandController.processCommand(buffer, calledFromIngameConsole);
-	};
-
-	*console->cb = callbackFunction;
-	console->start();
-#endif
-
-	setThreadNameLoggingOnly("MainGUI");
-	const boost::filesystem::path logPath = VCMIDirs::get().userLogsPath() / "VCMI_Client_log.txt";
-	logConfig = new CBasicLogConfigurator(logPath, console);
-	logConfig->configureDefault();
-	logGlobal->info("Starting client of '%s'", GameConstants::VCMI_VERSION);
-	logGlobal->info("Creating console and configuring logger: %d ms", pomtime.getDiff());
-	logGlobal->info("The log file will be saved to %s", logPath);
-
-	// Init filesystem and settings
-	try
-	{
-		preinitDLL(::console, false);
-	}
-	catch (const DataLoadingException & e)
-	{
-		handleFatalError(e.what(), true);
-	}
-
-	Settings session = settings.write["session"];
-	auto setSettingBool = [&](std::string key, std::string arg) {
-		Settings s = settings.write(vstd::split(key, "/"));
-		if(vm.count(arg))
-			s->Bool() = true;
-		else if(s->isNull())
-			s->Bool() = false;
-	};
-	auto setSettingInteger = [&](std::string key, std::string arg, si64 defaultValue) {
-		Settings s = settings.write(vstd::split(key, "/"));
-		if(vm.count(arg))
-			s->Integer() = vm[arg].as<si64>();
-		else if(s->isNull())
-			s->Integer() = defaultValue;
-	};
-
-	setSettingBool("session/onlyai", "onlyAI");
-	if(vm.count("headless"))
-	{
-		session["headless"].Bool() = true;
-		session["onlyai"].Bool() = true;
-	}
-	else if(vm.count("spectate"))
-	{
-		session["spectate"].Bool() = true;
-		session["spectate-ignore-hero"].Bool() = vm.count("spectate-ignore-hero");
-		session["spectate-skip-battle"].Bool() = vm.count("spectate-skip-battle");
-		session["spectate-skip-battle-result"].Bool() = vm.count("spectate-skip-battle-result");
-		if(vm.count("spectate-hero-speed"))
-			session["spectate-hero-speed"].Integer() = vm["spectate-hero-speed"].as<int>();
-		if(vm.count("spectate-battle-speed"))
-			session["spectate-battle-speed"].Float() = vm["spectate-battle-speed"].as<int>();
-	}
-	// Server settings
-	setSettingBool("session/donotstartserver", "donotstartserver");
-
-	// Init special testing settings
-	setSettingInteger("session/serverport", "serverport", 0);
-	setSettingInteger("general/saveFrequency", "savefrequency", 1);
-
-	// Initialize logging based on settings
-	logConfig->configure();
-	logGlobal->debug("settings = %s", settings.toJsonNode().toString());
-
-	// Some basic data validation to produce better error messages in cases of incorrect install
-	auto testFile = [](std::string filename, std::string message)
-	{
-		if (!CResourceHandler::get()->existsResource(ResourcePath(filename)))
-			handleFatalError(message, false);
-	};
-
-	testFile("DATA/HELP.TXT", "VCMI requires Heroes III: Shadow of Death or Heroes III: Complete data files to run!");
-	testFile("DATA/TENTCOLR.TXT", "Heroes III: Restoration of Erathia (including HD Edition) data files are not supported!");
-	testFile("MODS/VCMI/MOD.JSON", "VCMI installation is corrupted! Built-in mod was not found!");
-	testFile("DATA/PLAYERS.PAL", "Heroes III data files (Data/H3Bitmap.lod) are incomplete or corruped! Please reinstall them.");
-	testFile("SPRITES/DEFAULT.DEF", "Heroes III data files (Data/H3Sprite.lod) are incomplete or corruped! Please reinstall them.");
-
-	srand ( (unsigned int)time(nullptr) );
-
-	if(!settings["session"]["headless"].Bool())
-		GH.init();
-
-	CCS = new CClientState();
-	CGI = new CGameInfo(); //contains all global informations about game (texts, lodHandlers, map handler etc.)
-	CSH = new CServerHandler();
-	
-	// Initialize video
-#ifdef DISABLE_VIDEO
-	CCS->videoh = new CEmptyVideoPlayer();
-#else
-	if (!settings["session"]["headless"].Bool() && !vm.count("disable-video"))
-		CCS->videoh = new CVideoPlayer();
-	else
-		CCS->videoh = new CEmptyVideoPlayer();
-#endif
-
-	logGlobal->info("\tInitializing video: %d ms", pomtime.getDiff());
-
-	if(!settings["session"]["headless"].Bool())
-	{
-		//initializing audio
-		CCS->soundh = new CSoundHandler();
-		CCS->soundh->init();
-		CCS->soundh->setVolume((ui32)settings["general"]["sound"].Float());
-		CCS->musich = new CMusicHandler();
-		CCS->musich->init();
-		CCS->musich->setVolume((ui32)settings["general"]["music"].Float());
-		logGlobal->info("Initializing screen and sound handling: %d ms", pomtime.getDiff());
-	}
-
-#ifndef VCMI_NO_THREADED_LOAD
-	//we can properly play intro only in the main thread, so we have to move loading to the separate thread
-	boost::thread loading([]()
-	{
-		setThreadName("initialize");
-		init();
-	});
-#else
-	init();
-#endif
-
-	if(!settings["session"]["headless"].Bool())
-	{
-		if(!vm.count("battle") && !vm.count("nointro") && settings["video"]["showIntro"].Bool())
-			playIntro();
-		GH.screenHandler().clearScreen();
-	}
-
-#ifndef VCMI_NO_THREADED_LOAD
-	#ifdef VCMI_ANDROID // android loads the data quite slowly so we display native progressbar to prevent having only black screen for few seconds
-	{
-		CAndroidVMHelper vmHelper;
-		vmHelper.callStaticVoidMethod(CAndroidVMHelper::NATIVE_METHODS_DEFAULT_CLASS, "showProgress");
-	#endif // ANDROID
-		loading.join();
-	#ifdef VCMI_ANDROID
-		vmHelper.callStaticVoidMethod(CAndroidVMHelper::NATIVE_METHODS_DEFAULT_CLASS, "hideProgress");
-	}
-	#endif // ANDROID
-#endif // THREADED
-
-	if (criticalInitializationError.has_value())
-	{
-		handleFatalError(criticalInitializationError.value(), false);
-	}
-
-	if(!settings["session"]["headless"].Bool())
-	{
-		pomtime.getDiff();
-		graphics = new Graphics(); // should be before curh
-
-		CCS->curh = new CursorHandler();
-		logGlobal->info("Screen handler: %d ms", pomtime.getDiff());
-
-		CMessage::init();
-		logGlobal->info("Message handler: %d ms", pomtime.getDiff());
-
-		CCS->curh->show();
-	}
-
-	logGlobal->info("Initialization of VCMI (together): %d ms", total.getDiff());
-
-	session["autoSkip"].Bool()  = vm.count("autoSkip");
-	session["oneGoodAI"].Bool() = vm.count("oneGoodAI");
-	session["aiSolo"].Bool() = false;
-	
-	if(vm.count("testmap"))
-	{
-		session["testmap"].String() = vm["testmap"].as<std::string>();
-		session["onlyai"].Bool() = true;
-		boost::thread(&CServerHandler::debugStartTest, CSH, session["testmap"].String(), false);
-	}
-	else if(vm.count("testsave"))
-	{
-		session["testsave"].String() = vm["testsave"].as<std::string>();
-		session["onlyai"].Bool() = true;
-		boost::thread(&CServerHandler::debugStartTest, CSH, session["testsave"].String(), true);
-	}
-	else
-	{
-		auto mmenu = CMainMenu::create();
-		GH.curInt = mmenu.get();
-	}
-	
-	std::vector<std::string> names;
-
-	if(!settings["session"]["headless"].Bool())
-	{
-		mainLoop();
-	}
-	else
-	{
-		while(!headlessQuit)
-			boost::this_thread::sleep_for(boost::chrono::milliseconds(200));
-
-		boost::this_thread::sleep_for(boost::chrono::milliseconds(500));
-
-		quitApplication();
-	}
-
-	return 0;
-}
-
-//plays intro, ends when intro is over or button has been pressed (handles events)
-void playIntro()
-{
-	auto audioData = CCS->videoh->getAudio(VideoPath::builtin("3DOLOGO.SMK"));
-	int sound = CCS->soundh->playSound(audioData);
-	if(CCS->videoh->openAndPlayVideo(VideoPath::builtin("3DOLOGO.SMK"), 0, 1, EVideoType::INTRO))
-	{
-		audioData = CCS->videoh->getAudio(VideoPath::builtin("NWCLOGO.SMK"));
-		sound = CCS->soundh->playSound(audioData);
-		if (CCS->videoh->openAndPlayVideo(VideoPath::builtin("NWCLOGO.SMK"), 0, 1, EVideoType::INTRO))
-		{
-			audioData = CCS->videoh->getAudio(VideoPath::builtin("H3INTRO.SMK"));
-			sound = CCS->soundh->playSound(audioData);
-			CCS->videoh->openAndPlayVideo(VideoPath::builtin("H3INTRO.SMK"), 0, 1, EVideoType::INTRO);
-		}
-	}
-	CCS->soundh->stopSound(sound);
-}
-
-static void mainLoop()
-{
-#ifndef VCMI_UNIX
-	// on Linux, name of main thread is also name of our process. Which we don't want to change
-	setThreadName("MainGUI");
-#endif
-
-	while(1) //main SDL events loop
-	{
-		GH.input().fetchEvents();
-		GH.renderFrame();
-	}
-}
-
-[[noreturn]] static void quitApplicationImmediately(int error_code)
-{
-	// Perform quick exit without executing static destructors and let OS cleanup anything that we did not
-	// We generally don't care about them and this leads to numerous issues, e.g.
-	// destruction of locked mutexes (fails an assertion), even in third-party libraries (as well as native libs on Android)
-	// Android - std::quick_exit is available only starting from API level 21
-	// Mingw, macOS and iOS - std::quick_exit is unavailable (at least in current version of CI)
-#if (defined(__ANDROID_API__) && __ANDROID_API__ < 21) || (defined(__MINGW32__)) || defined(VCMI_APPLE)
-	::exit(error_code);
-#else
-	std::quick_exit(error_code);
-#endif
-}
-
-[[noreturn]] static void quitApplication()
-{
-	CSH->endNetwork();
-
-	if(!settings["session"]["headless"].Bool())
-	{
-		if(CSH->client)
-			CSH->endGameplay();
-
-		GH.windows().clear();
-	}
-
-	vstd::clear_pointer(CSH);
-
-	CMM.reset();
-
-	if(!settings["session"]["headless"].Bool())
-	{
-		// cleanup, mostly to remove false leaks from analyzer
-		if(CCS)
-		{
-			CCS->musich->release();
-			CCS->soundh->release();
-
-			delete CCS->consoleh;
-			delete CCS->curh;
-			delete CCS->videoh;
-			delete CCS->musich;
-			delete CCS->soundh;
-
-			vstd::clear_pointer(CCS);
-		}
-		CMessage::dispose();
-
-		vstd::clear_pointer(graphics);
-	}
-
-	vstd::clear_pointer(VLC);
-
-	// sometimes leads to a hang. TODO: investigate
-	//vstd::clear_pointer(console);// should be removed after everything else since used by logging
-
-	if(!settings["session"]["headless"].Bool())
-		GH.screenHandler().close();
-
-	if(logConfig != nullptr)
-	{
-		logConfig->deconfigure();
-		delete logConfig;
-		logConfig = nullptr;
-	}
-
-	std::cout << "Ending...\n";
-	quitApplicationImmediately(0);
-}
-
-void handleQuit(bool ask)
-{
-	if(!ask)
-	{
-		if(settings["session"]["headless"].Bool())
-		{
-			headlessQuit = true;
-		}
-		else
-		{
-			quitApplication();
-		}
-
-		return;
-	}
-
-	// FIXME: avoids crash if player attempts to close game while opening is still playing
-	// use cursor handler as indicator that loading is not done yet
-	// proper solution would be to abort init thread (or wait for it to finish)
-	if (!CCS->curh)
-	{
-		quitApplicationImmediately(0);
-	}
-
-	if (LOCPLINT)
-		LOCPLINT->showYesNoDialog(CGI->generaltexth->allTexts[69], quitApplication, nullptr);
-	else
-		CInfoWindow::showYesNoDialog(CGI->generaltexth->allTexts[69], {}, quitApplication, {}, PlayerColor(1));
-}
-
-void handleFatalError(const std::string & message, bool terminate)
-{
-	logGlobal->error("FATAL ERROR ENCOUTERED, VCMI WILL NOW TERMINATE");
-	logGlobal->error("Reason: %s", message);
-
-	std::string messageToShow = "Fatal error! " + message;
-
-	SDL_ShowSimpleMessageBox(SDL_MESSAGEBOX_ERROR, "Fatal error!", messageToShow.c_str(), nullptr);
-
-	if (terminate)
-		throw std::runtime_error(message);
-	else
-		quitApplicationImmediately(1);
-}
diff --color -urN vcmi-1.5.7/client/CMT.h vcmi/client/CMT.h
--- vcmi-1.5.7/client/CMT.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/CMT.h	2024-12-19 15:00:22.238120662 +0100
@@ -20,8 +20,8 @@
 extern SDL_Surface *screen2;     // and hlp surface (used to store not-active interfaces layer)
 extern SDL_Surface *screenBuf; // points to screen (if only advmapint is present) or screen2 (else) - should be used when updating controls which are not regularly redrawed
 
-void handleQuit(bool ask = true);
-
-/// Notify user about encoutered fatal error and terminate the game
+/// Notify user about encountered fatal error and terminate the game
+/// Defined in clientapp EntryPoint
 /// TODO: decide on better location for this method
 [[noreturn]] void handleFatalError(const std::string & message, bool terminate);
+void handleQuit(bool ask = true);
diff --color -urN vcmi-1.5.7/client/CMusicHandler.cpp vcmi/client/CMusicHandler.cpp
--- vcmi-1.5.7/client/CMusicHandler.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/CMusicHandler.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,753 +0,0 @@
-/*
- * CMusicHandler.cpp, part of VCMI engine
- *
- * Authors: listed in file AUTHORS in main folder
- *
- * License: GNU General Public License v2.0 or later
- * Full text of license available in license.txt file, in main folder
- *
- */
-#include "StdInc.h"
-#include <SDL_mixer.h>
-#include <SDL_timer.h>
-
-#include "CMusicHandler.h"
-#include "CGameInfo.h"
-#include "renderSDL/SDLRWwrapper.h"
-#include "eventsSDL/InputHandler.h"
-#include "gui/CGuiHandler.h"
-
-#include "../lib/GameConstants.h"
-#include "../lib/filesystem/Filesystem.h"
-#include "../lib/constants/StringConstants.h"
-#include "../lib/CRandomGenerator.h"
-#include "../lib/VCMIDirs.h"
-#include "../lib/TerrainHandler.h"
-
-
-#define VCMI_SOUND_NAME(x)
-#define VCMI_SOUND_FILE(y) #y,
-
-// sounds mapped to soundBase enum
-static const std::string sounds[] = {
-	"", // invalid
-	"", // todo
-	VCMI_SOUND_LIST
-};
-#undef VCMI_SOUND_NAME
-#undef VCMI_SOUND_FILE
-
-void CAudioBase::init()
-{
-	if (initialized)
-		return;
-
-	if (Mix_OpenAudio(44100, MIX_DEFAULT_FORMAT, 2, 1024)==-1)
-	{
-		logGlobal->error("Mix_OpenAudio error: %s", Mix_GetError());
-		return;
-	}
-
-	initialized = true;
-}
-
-void CAudioBase::release()
-{
-	if(!(CCS->soundh->initialized && CCS->musich->initialized))
-		Mix_CloseAudio();
-
-	initialized = false;
-}
-
-void CAudioBase::setVolume(ui32 percent)
-{
-	if (percent > 100)
-		percent = 100;
-
-	volume = percent;
-}
-
-void CSoundHandler::onVolumeChange(const JsonNode &volumeNode)
-{
-	setVolume((ui32)volumeNode.Float());
-}
-
-CSoundHandler::CSoundHandler():
-	listener(settings.listen["general"]["sound"]),
-	ambientConfig(JsonPath::builtin("config/ambientSounds.json"))
-{
-	listener(std::bind(&CSoundHandler::onVolumeChange, this, _1));
-
-	battleIntroSounds =
-	{
-		soundBase::battle00, soundBase::battle01,
-		soundBase::battle02, soundBase::battle03, soundBase::battle04,
-		soundBase::battle05, soundBase::battle06, soundBase::battle07
-	};
-}
-
-void CSoundHandler::init()
-{
-	CAudioBase::init();
-	if(ambientConfig["allocateChannels"].isNumber())
-		Mix_AllocateChannels((int)ambientConfig["allocateChannels"].Integer());
-
-	if (initialized)
-	{
-		Mix_ChannelFinished([](int channel)
-		{
-			CCS->soundh->soundFinishedCallback(channel);
-		});
-	}
-}
-
-void CSoundHandler::release()
-{
-	if (initialized)
-	{
-		Mix_HaltChannel(-1);
-
-		for (auto &chunk : soundChunks)
-		{
-			if (chunk.second.first)
-				Mix_FreeChunk(chunk.second.first);
-		}
-	}
-
-	CAudioBase::release();
-}
-
-// Allocate an SDL chunk and cache it.
-Mix_Chunk *CSoundHandler::GetSoundChunk(const AudioPath & sound, bool cache)
-{
-	try
-	{
-		if (cache && soundChunks.find(sound) != soundChunks.end())
-			return soundChunks[sound].first;
-
-		auto data = CResourceHandler::get()->load(sound.addPrefix("SOUNDS/"))->readAll();
-		SDL_RWops *ops = SDL_RWFromMem(data.first.get(), (int)data.second);
-		Mix_Chunk *chunk = Mix_LoadWAV_RW(ops, 1);	// will free ops
-
-		if (cache)
-			soundChunks.insert({sound, std::make_pair (chunk, std::move (data.first))});
-
-		return chunk;
-	}
-	catch(std::exception &e)
-	{
-		logGlobal->warn("Cannot get sound %s chunk: %s", sound.getOriginalName(), e.what());
-		return nullptr;
-	}
-}
-
-Mix_Chunk *CSoundHandler::GetSoundChunk(std::pair<std::unique_ptr<ui8 []>, si64> & data, bool cache)
-{
-	try
-	{
-		std::vector<ui8> startBytes = std::vector<ui8>(data.first.get(), data.first.get() + std::min((si64)100, data.second));
-
-		if (cache && soundChunksRaw.find(startBytes) != soundChunksRaw.end())
-			return soundChunksRaw[startBytes].first;
-
-		SDL_RWops *ops = SDL_RWFromMem(data.first.get(), (int)data.second);
-		Mix_Chunk *chunk = Mix_LoadWAV_RW(ops, 1);	// will free ops
-
-		if (cache)
-			soundChunksRaw.insert({startBytes, std::make_pair (chunk, std::move (data.first))});
-
-		return chunk;
-	}
-	catch(std::exception &e)
-	{
-		logGlobal->warn("Cannot get sound chunk: %s", e.what());
-		return nullptr;
-	}
-}
-
-int CSoundHandler::ambientDistToVolume(int distance) const
-{
-	const auto & distancesVector = ambientConfig["distances"].Vector();
-
-	if(distance >= distancesVector.size())
-		return 0;
-
-	int volume = static_cast<int>(distancesVector[distance].Integer());
-	return volume * (int)ambientConfig["volume"].Integer() / 100;
-}
-
-void CSoundHandler::ambientStopSound(const AudioPath & soundId)
-{
-	stopSound(ambientChannels[soundId]);
-	setChannelVolume(ambientChannels[soundId], volume);
-}
-
-uint32_t CSoundHandler::getSoundDurationMilliseconds(const AudioPath & sound)
-{
-	if (!initialized || sound.empty())
-		return 0;
-
-	auto resourcePath = sound.addPrefix("SOUNDS/");
-
-	if (!CResourceHandler::get()->existsResource(resourcePath))
-		return 0;
-
-	auto data = CResourceHandler::get()->load(resourcePath)->readAll();
-
-	SDL_AudioSpec spec;
-	uint32_t audioLen;
-	uint8_t *audioBuf;
-	uint32_t miliseconds = 0;
-
-	if(SDL_LoadWAV_RW(SDL_RWFromMem(data.first.get(), (int)data.second), 1, &spec, &audioBuf, &audioLen) != nullptr)
-	{
-		SDL_FreeWAV(audioBuf);
-		uint32_t sampleSize = SDL_AUDIO_BITSIZE(spec.format) / 8;
-		uint32_t sampleCount = audioLen / sampleSize;
-		uint32_t sampleLen = sampleCount / spec.channels;
-		miliseconds = 1000 * sampleLen / spec.freq;
-	}
-
-	return miliseconds ;
-}
-
-// Plays a sound, and return its channel so we can fade it out later
-int CSoundHandler::playSound(soundBase::soundID soundID, int repeats)
-{
-	assert(soundID < soundBase::sound_after_last);
-	auto sound = AudioPath::builtin(sounds[soundID]);
-	logGlobal->trace("Attempt to play sound %d with file name %s with cache", soundID, sound.getOriginalName());
-
-	return playSound(sound, repeats, true);
-}
-
-int CSoundHandler::playSound(const AudioPath & sound, int repeats, bool cache)
-{
-	if (!initialized || sound.empty())
-		return -1;
-
-	int channel;
-	Mix_Chunk *chunk = GetSoundChunk(sound, cache);
-
-	if (chunk)
-	{
-		channel = Mix_PlayChannel(-1, chunk, repeats);
-		if (channel == -1)
-		{
-			logGlobal->error("Unable to play sound file %s , error %s", sound.getOriginalName(), Mix_GetError());
-			if (!cache)
-				Mix_FreeChunk(chunk);
-		}
-		else if (cache)
-			initCallback(channel);
-		else
-			initCallback(channel, [chunk](){ Mix_FreeChunk(chunk);});
-	}
-	else
-		channel = -1;
-
-	return channel;
-}
-
-int CSoundHandler::playSound(std::pair<std::unique_ptr<ui8 []>, si64> & data, int repeats, bool cache)
-{
-	int channel = -1;
-	if (Mix_Chunk *chunk = GetSoundChunk(data, cache))
-	{
-		channel = Mix_PlayChannel(-1, chunk, repeats);
-		if (channel == -1)
-		{
-			logGlobal->error("Unable to play sound, error %s", Mix_GetError());
-			if (!cache)
-				Mix_FreeChunk(chunk);
-		}
-		else if (cache)
-			initCallback(channel);
-		else
-			initCallback(channel, [chunk](){ Mix_FreeChunk(chunk);});
-	}
-	return channel;
-}
-
-// Helper. Randomly select a sound from an array and play it
-int CSoundHandler::playSoundFromSet(std::vector<soundBase::soundID> &sound_vec)
-{
-	return playSound(*RandomGeneratorUtil::nextItem(sound_vec, CRandomGenerator::getDefault()));
-}
-
-void CSoundHandler::stopSound(int handler)
-{
-	if (initialized && handler != -1)
-		Mix_HaltChannel(handler);
-}
-
-// Sets the sound volume, from 0 (mute) to 100
-void CSoundHandler::setVolume(ui32 percent)
-{
-	CAudioBase::setVolume(percent);
-
-	if (initialized)
-	{
-		setChannelVolume(-1, volume);
-
-		for (auto const & channel : channelVolumes)
-			updateChannelVolume(channel.first);
-	}
-}
-
-void CSoundHandler::updateChannelVolume(int channel)
-{
-	if (channelVolumes.count(channel))
-		setChannelVolume(channel, getVolume() * channelVolumes[channel] / 100);
-	else
-		setChannelVolume(channel, getVolume());
-}
-
-// Sets the sound volume, from 0 (mute) to 100
-void CSoundHandler::setChannelVolume(int channel, ui32 percent)
-{
-	Mix_Volume(channel, (MIX_MAX_VOLUME * percent)/100);
-}
-
-void CSoundHandler::setCallback(int channel, std::function<void()> function)
-{
-	boost::mutex::scoped_lock lockGuard(mutexCallbacks);
-
-	auto iter = callbacks.find(channel);
-
-	//channel not found. It may have finished so fire callback now
-	if(iter == callbacks.end())
-		function();
-	else
-		iter->second.push_back(function);
-}
-
-void CSoundHandler::resetCallback(int channel)
-{
-	boost::mutex::scoped_lock lockGuard(mutexCallbacks);
-
-	callbacks.erase(channel);
-}
-
-void CSoundHandler::soundFinishedCallback(int channel)
-{
-	boost::mutex::scoped_lock lockGuard(mutexCallbacks);
-
-	if (callbacks.count(channel) == 0)
-		return;
-
-	// store callbacks from container locally - SDL might reuse this channel for another sound
-	// but do actualy execution in separate thread, to avoid potential deadlocks in case if callback requires locks of its own
-	auto callback = callbacks.at(channel);
-	callbacks.erase(channel);
-
-	if (!callback.empty())
-	{
-		GH.dispatchMainThread([callback](){
-			for (auto entry : callback)
-				entry();
-		});
-	}
-}
-
-void CSoundHandler::initCallback(int channel)
-{
-	boost::mutex::scoped_lock lockGuard(mutexCallbacks);
-	assert(callbacks.count(channel) == 0);
-	callbacks[channel] = {};
-}
-
-void CSoundHandler::initCallback(int channel, const std::function<void()> & function)
-{
-	boost::mutex::scoped_lock lockGuard(mutexCallbacks);
-	assert(callbacks.count(channel) == 0);
-	callbacks[channel].push_back(function);
-}
-
-int CSoundHandler::ambientGetRange() const
-{
-	return static_cast<int>(ambientConfig["range"].Integer());
-}
-
-void CSoundHandler::ambientUpdateChannels(std::map<AudioPath, int> soundsArg)
-{
-	boost::mutex::scoped_lock guard(mutex);
-
-	std::vector<AudioPath> stoppedSounds;
-	for(auto & pair : ambientChannels)
-	{
-		const auto & soundId = pair.first;
-		const int channel = pair.second;
-
-		if(!vstd::contains(soundsArg, soundId))
-		{
-			ambientStopSound(soundId);
-			stoppedSounds.push_back(soundId);
-		}
-		else
-		{
-			int volume = ambientDistToVolume(soundsArg[soundId]);
-			channelVolumes[channel] = volume;
-			updateChannelVolume(channel);
-		}
-	}
-	for(auto soundId : stoppedSounds)
-	{
-		channelVolumes.erase(ambientChannels[soundId]);
-		ambientChannels.erase(soundId);
-	}
-
-	for(auto & pair : soundsArg)
-	{
-		const auto & soundId = pair.first;
-		const int distance = pair.second;
-
-		if(!vstd::contains(ambientChannels, soundId))
-		{
-			int channel = playSound(soundId, -1);
-			int volume = ambientDistToVolume(distance);
-			channelVolumes[channel] = volume;
-
-			updateChannelVolume(channel);
-			ambientChannels[soundId] = channel;
-		}
-	}
-}
-
-void CSoundHandler::ambientStopAllChannels()
-{
-	boost::mutex::scoped_lock guard(mutex);
-
-	for(auto ch : ambientChannels)
-	{
-		ambientStopSound(ch.first);
-	}
-	channelVolumes.clear();
-	ambientChannels.clear();
-}
-
-void CMusicHandler::onVolumeChange(const JsonNode &volumeNode)
-{
-	setVolume((ui32)volumeNode.Float());
-}
-
-CMusicHandler::CMusicHandler():
-	listener(settings.listen["general"]["music"])
-{
-	listener(std::bind(&CMusicHandler::onVolumeChange, this, _1));
-
-	auto mp3files = CResourceHandler::get()->getFilteredFiles([](const ResourcePath & id) ->  bool
-	{
-		if(id.getType() != EResType::SOUND)
-			return false;
-
-		if(!boost::algorithm::istarts_with(id.getName(), "MUSIC/"))
-			return false;
-
-		logGlobal->trace("Found music file %s", id.getName());
-		return true;
-	});
-
-	for(const ResourcePath & file : mp3files)
-	{
-		if(boost::algorithm::istarts_with(file.getName(), "MUSIC/Combat"))
-			addEntryToSet("battle", AudioPath::fromResource(file));
-		else if(boost::algorithm::istarts_with(file.getName(), "MUSIC/AITheme"))
-			addEntryToSet("enemy-turn", AudioPath::fromResource(file));
-	}
-
-}
-
-void CMusicHandler::loadTerrainMusicThemes()
-{
-	for (const auto & terrain : CGI->terrainTypeHandler->objects)
-	{
-		addEntryToSet("terrain_" + terrain->getJsonKey(), terrain->musicFilename);
-	}
-}
-
-void CMusicHandler::addEntryToSet(const std::string & set, const AudioPath & musicURI)
-{
-	musicsSet[set].push_back(musicURI);
-}
-
-void CMusicHandler::init()
-{
-	CAudioBase::init();
-
-	if (initialized)
-	{
-		Mix_HookMusicFinished([]()
-		{
-			CCS->musich->musicFinishedCallback();
-		});
-	}
-}
-
-void CMusicHandler::release()
-{
-	if (initialized)
-	{
-		boost::mutex::scoped_lock guard(mutex);
-
-		Mix_HookMusicFinished(nullptr);
-		current->stop();
-
-		current.reset();
-		next.reset();
-	}
-
-	CAudioBase::release();
-}
-
-void CMusicHandler::playMusic(const AudioPath & musicURI, bool loop, bool fromStart)
-{
-	boost::mutex::scoped_lock guard(mutex);
-
-	if (current && current->isPlaying() && current->isTrack(musicURI))
-		return;
-
-	queueNext(this, "", musicURI, loop, fromStart);
-}
-
-void CMusicHandler::playMusicFromSet(const std::string & musicSet, const std::string & entryID, bool loop, bool fromStart)
-{
-	playMusicFromSet(musicSet + "_" + entryID, loop, fromStart);
-}
-
-void CMusicHandler::playMusicFromSet(const std::string & whichSet, bool loop, bool fromStart)
-{
-	boost::mutex::scoped_lock guard(mutex);
-
-	auto selectedSet = musicsSet.find(whichSet);
-	if (selectedSet == musicsSet.end())
-	{
-		logGlobal->error("Error: playing music from non-existing set: %s", whichSet);
-		return;
-	}
-
-	if (current && current->isPlaying() && current->isSet(whichSet))
-		return;
-
-	// in this mode - play random track from set
-	queueNext(this, whichSet, AudioPath(), loop, fromStart);
-}
-
-void CMusicHandler::queueNext(std::unique_ptr<MusicEntry> queued)
-{
-	if (!initialized)
-		return;
-
-	next = std::move(queued);
-
-	if (current.get() == nullptr || !current->stop(1000))
-	{
-		current.reset(next.release());
-		current->play();
-	}
-}
-
-void CMusicHandler::queueNext(CMusicHandler *owner, const std::string & setName, const AudioPath & musicURI, bool looped, bool fromStart)
-{
-	queueNext(std::make_unique<MusicEntry>(owner, setName, musicURI, looped, fromStart));
-}
-
-void CMusicHandler::stopMusic(int fade_ms)
-{
-	if (!initialized)
-		return;
-
-	boost::mutex::scoped_lock guard(mutex);
-
-	if (current.get() != nullptr)
-		current->stop(fade_ms);
-	next.reset();
-}
-
-void CMusicHandler::setVolume(ui32 percent)
-{
-	CAudioBase::setVolume(percent);
-
-	if (initialized)
-		Mix_VolumeMusic((MIX_MAX_VOLUME * volume)/100);
-}
-
-void CMusicHandler::musicFinishedCallback()
-{
-	// call music restart in separate thread to avoid deadlock in some cases
-	// It is possible for:
-	// 1) SDL thread to call this method on end of playback
-	// 2) VCMI code to call queueNext() method to queue new file
-	// this leads to:
-	// 1) SDL thread waiting to acquire music lock in this method (while keeping internal SDL mutex locked)
-	// 2) VCMI thread waiting to acquire internal SDL mutex (while keeping music mutex locked)
-
-	GH.dispatchMainThread([this]()
-	{
-		boost::unique_lock lockGuard(mutex);
-		if (current.get() != nullptr)
-		{
-			// if music is looped, play it again
-			if (current->play())
-				return;
-			else
-				current.reset();
-		}
-
-		if (current.get() == nullptr && next.get() != nullptr)
-		{
-			current.reset(next.release());
-			current->play();
-		}
-	});
-}
-
-MusicEntry::MusicEntry(CMusicHandler *owner, std::string setName, const AudioPath & musicURI, bool looped, bool fromStart):
-	owner(owner),
-	music(nullptr),
-	playing(false),
-	startTime(uint32_t(-1)),
-	startPosition(0),
-	loop(looped ? -1 : 1),
-	fromStart(fromStart),
-	setName(std::move(setName))
-{
-	if (!musicURI.empty())
-		load(std::move(musicURI));
-}
-MusicEntry::~MusicEntry()
-{
-	if (playing && loop > 0)
-	{
-		assert(0);
-		logGlobal->error("Attempt to delete music while playing!");
-		Mix_HaltMusic();
-	}
-
-	if (loop == 0 && Mix_FadingMusic() != MIX_NO_FADING)
-	{
-		assert(0);
-		logGlobal->error("Attempt to delete music while fading out!");
-		Mix_HaltMusic();
-	}
-
-	logGlobal->trace("Del-ing music file %s", currentName.getOriginalName());
-	if (music)
-		Mix_FreeMusic(music);
-}
-
-void MusicEntry::load(const AudioPath & musicURI)
-{
-	if (music)
-	{
-		logGlobal->trace("Del-ing music file %s", currentName.getOriginalName());
-		Mix_FreeMusic(music);
-		music = nullptr;
-	}
-
-	if (CResourceHandler::get()->existsResource(musicURI))
-		currentName = musicURI;
-	else
-		currentName = musicURI.addPrefix("MUSIC/");
-
-	music = nullptr;
-
-	logGlobal->trace("Loading music file %s", currentName.getOriginalName());
-
-	try
-	{
-		auto musicFile = MakeSDLRWops(CResourceHandler::get()->load(currentName));
-		music = Mix_LoadMUS_RW(musicFile, SDL_TRUE);
-	}
-	catch(std::exception &e)
-	{
-		logGlobal->error("Failed to load music. setName=%s\tmusicURI=%s", setName, currentName.getOriginalName());
-		logGlobal->error("Exception: %s", e.what());
-	}
-
-	if(!music)
-	{
-		logGlobal->warn("Warning: Cannot open %s: %s", currentName.getOriginalName(), Mix_GetError());
-		return;
-	}
-}
-
-bool MusicEntry::play()
-{
-	if (!(loop--) && music) //already played once - return
-		return false;
-
-	if (!setName.empty())
-	{
-		const auto & set = owner->musicsSet[setName];
-		const auto & iter = RandomGeneratorUtil::nextItem(set, CRandomGenerator::getDefault());
-		load(*iter);
-	}
-
-	logGlobal->trace("Playing music file %s", currentName.getOriginalName());
-
-	if (!fromStart && owner->trackPositions.count(currentName) > 0 && owner->trackPositions[currentName] > 0)
-	{
-		float timeToStart = owner->trackPositions[currentName];
-		startPosition = std::round(timeToStart * 1000);
-
-		// erase stored position:
-		// if music track will be interrupted again - new position will be written in stop() method
-		// if music track is not interrupted and will finish by timeout/end of file - it will restart from begginning as it should
-		owner->trackPositions.erase(owner->trackPositions.find(currentName));
-
-		if (Mix_FadeInMusicPos(music, 1, 1000, timeToStart) == -1)
-		{
-			logGlobal->error("Unable to play music (%s)", Mix_GetError());
-			return false;
-		}
-	}
-	else
-	{
-		startPosition = 0;
-
-		if(Mix_PlayMusic(music, 1) == -1)
-		{
-			logGlobal->error("Unable to play music (%s)", Mix_GetError());
-			return false;
-		}
-	}
-
-	startTime = GH.input().getTicks();
-	
-	playing = true;
-	return true;
-}
-
-bool MusicEntry::stop(int fade_ms)
-{
-	if (Mix_PlayingMusic())
-	{
-		playing = false;
-		loop = 0;
-		uint32_t endTime = GH.input().getTicks();
-		assert(startTime != uint32_t(-1));
-		float playDuration = (endTime - startTime + startPosition) / 1000.f;
-		owner->trackPositions[currentName] = playDuration;
-		logGlobal->trace("Stopping music file %s at %f", currentName.getOriginalName(), playDuration);
-
-		Mix_FadeOutMusic(fade_ms);
-		return true;
-	}
-	return false;
-}
-
-bool MusicEntry::isPlaying()
-{
-	return playing;
-}
-
-bool MusicEntry::isSet(std::string set)
-{
-	return !setName.empty() && set == setName;
-}
-
-bool MusicEntry::isTrack(const AudioPath & track)
-{
-	return setName.empty() && track == currentName;
-}
diff --color -urN vcmi-1.5.7/client/CMusicHandler.h vcmi/client/CMusicHandler.h
--- vcmi-1.5.7/client/CMusicHandler.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/CMusicHandler.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,170 +0,0 @@
-/*
- * CMusicHandler.h, part of VCMI engine
- *
- * Authors: listed in file AUTHORS in main folder
- *
- * License: GNU General Public License v2.0 or later
- * Full text of license available in license.txt file, in main folder
- *
- */
-#pragma once
-
-#include "../lib/CConfigHandler.h"
-#include "../lib/CSoundBase.h"
-
-struct _Mix_Music;
-struct SDL_RWops;
-using Mix_Music = struct _Mix_Music;
-struct Mix_Chunk;
-
-class CAudioBase {
-protected:
-	boost::mutex mutex;
-	bool initialized;
-	int volume;					// from 0 (mute) to 100
-
-	CAudioBase(): initialized(false), volume(0) {};
-	~CAudioBase() = default;
-public:
-	virtual void init() = 0;
-	virtual void release() = 0;
-
-	virtual void setVolume(ui32 percent);
-	ui32 getVolume() const { return volume; };
-};
-
-class CSoundHandler final : public CAudioBase
-{
-private:
-	//update volume on configuration change
-	SettingsListener listener;
-	void onVolumeChange(const JsonNode &volumeNode);
-
-	using CachedChunk = std::pair<Mix_Chunk *, std::unique_ptr<ui8[]>>;
-	std::map<AudioPath, CachedChunk> soundChunks;
-	std::map<std::vector<ui8>, CachedChunk> soundChunksRaw;
-
-	Mix_Chunk *GetSoundChunk(const AudioPath & sound, bool cache);
-	Mix_Chunk *GetSoundChunk(std::pair<std::unique_ptr<ui8 []>, si64> & data, bool cache);
-
-	/// have entry for every currently active channel
-	/// vector will be empty if callback was not set
-	std::map<int, std::vector<std::function<void()>> > callbacks;
-
-	/// Protects access to callbacks member to avoid data races:
-	/// SDL calls sound finished callbacks from audio thread
-	boost::mutex mutexCallbacks;
-
-	int ambientDistToVolume(int distance) const;
-	void ambientStopSound(const AudioPath & soundId);
-	void updateChannelVolume(int channel);
-
-	const JsonNode ambientConfig;
-
-	std::map<AudioPath, int> ambientChannels;
-	std::map<int, int> channelVolumes;
-
-	void initCallback(int channel, const std::function<void()> & function);
-	void initCallback(int channel);
-
-public:
-	CSoundHandler();
-
-	void init() override;
-	void release() override;
-
-	void setVolume(ui32 percent) override;
-	void setChannelVolume(int channel, ui32 percent);
-
-	// Sounds
-	uint32_t getSoundDurationMilliseconds(const AudioPath & sound);
-	int playSound(soundBase::soundID soundID, int repeats=0);
-	int playSound(const AudioPath & sound, int repeats=0, bool cache=false);
-	int playSound(std::pair<std::unique_ptr<ui8 []>, si64> & data, int repeats=0, bool cache=false);
-	int playSoundFromSet(std::vector<soundBase::soundID> &sound_vec);
-	void stopSound(int handler);
-
-	void setCallback(int channel, std::function<void()> function);
-	void resetCallback(int channel);
-	void soundFinishedCallback(int channel);
-
-	int ambientGetRange() const;
-	void ambientUpdateChannels(std::map<AudioPath, int> currentSounds);
-	void ambientStopAllChannels();
-
-	// Sets
-	std::vector<soundBase::soundID> battleIntroSounds;
-};
-
-class CMusicHandler;
-
-//Class for handling one music file
-class MusicEntry
-{
-	CMusicHandler *owner;
-	Mix_Music *music;
-
-	int loop; // -1 = indefinite
-	bool fromStart;
-	bool playing;
-	uint32_t startTime;
-	uint32_t startPosition;
-	//if not null - set from which music will be randomly selected
-	std::string setName;
-	AudioPath currentName;
-
-	void load(const AudioPath & musicURI);
-
-public:
-	MusicEntry(CMusicHandler *owner, std::string setName, const AudioPath & musicURI, bool looped, bool fromStart);
-	~MusicEntry();
-
-	bool isSet(std::string setName);
-	bool isTrack(const AudioPath & trackName);
-	bool isPlaying();
-
-	bool play();
-	bool stop(int fade_ms=0);
-};
-
-class CMusicHandler final: public CAudioBase
-{
-private:
-	//update volume on configuration change
-	SettingsListener listener;
-	void onVolumeChange(const JsonNode &volumeNode);
-
-	std::unique_ptr<MusicEntry> current;
-	std::unique_ptr<MusicEntry> next;
-
-	void queueNext(CMusicHandler *owner, const std::string & setName, const AudioPath & musicURI, bool looped, bool fromStart);
-	void queueNext(std::unique_ptr<MusicEntry> queued);
-	void musicFinishedCallback();
-
-	/// map <set name> -> <list of URI's to tracks belonging to the said set>
-	std::map<std::string, std::vector<AudioPath>> musicsSet;
-	/// stored position, in seconds at which music player should resume playing this track
-	std::map<AudioPath, float> trackPositions;
-
-public:
-	CMusicHandler();
-
-	/// add entry with URI musicURI in set. Track will have ID musicID
-	void addEntryToSet(const std::string & set, const AudioPath & musicURI);
-
-	void init() override;
-	void loadTerrainMusicThemes();
-	void release() override;
-	void setVolume(ui32 percent) override;
-
-	/// play track by URI, if loop = true music will be looped
-	void playMusic(const AudioPath & musicURI, bool loop, bool fromStart);
-	/// play random track from this set
-	void playMusicFromSet(const std::string & musicSet, bool loop, bool fromStart);
-	/// play random track from set (musicSet, entryID)
-	void playMusicFromSet(const std::string & musicSet, const std::string & entryID, bool loop, bool fromStart);
-	/// stops currently playing music by fading out it over fade_ms and starts next scheduled track, if any
-	void stopMusic(int fade_ms=1000);
-
-	friend class MusicEntry;
-};
diff --color -urN vcmi-1.5.7/client/ConditionalWait.h vcmi/client/ConditionalWait.h
--- vcmi-1.5.7/client/ConditionalWait.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/ConditionalWait.h	2024-12-19 15:00:22.240120745 +0100
@@ -33,7 +33,7 @@
 
 	void set(bool value)
 	{
-		boost::unique_lock<std::mutex> lock(mx);
+		std::unique_lock lock(mx);
 		isBusyValue = value;
 	}
 
@@ -59,15 +59,14 @@
 
 	bool isBusy()
 	{
-		std::unique_lock<std::mutex> lock(mx);
+		std::unique_lock lock(mx);
 		return isBusyValue;
 	}
 
 	void waitWhileBusy()
 	{
-		std::unique_lock<std::mutex> un(mx);
-		while(isBusyValue)
-			cond.wait(un);
+		std::unique_lock un(mx);
+		cond.wait(un, [this](){ return !isBusyValue;});
 
 		if (isTerminating)
 			throw TerminationRequestedException();
diff --color -urN vcmi-1.5.7/client/CPlayerInterface.cpp vcmi/client/CPlayerInterface.cpp
--- vcmi-1.5.7/client/CPlayerInterface.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/CPlayerInterface.cpp	2024-12-19 15:00:22.238120662 +0100
@@ -13,8 +13,6 @@
 #include <vcmi/Artifact.h>
 
 #include "CGameInfo.h"
-#include "CMT.h"
-#include "CMusicHandler.h"
 #include "CServerHandler.h"
 #include "HeroMovementController.h"
 #include "PlayerLocalState.h"
@@ -41,6 +39,9 @@
 
 #include "mapView/mapHandler.h"
 
+#include "media/IMusicPlayer.h"
+#include "media/ISoundPlayer.h"
+
 #include "render/CAnimation.h"
 #include "render/IImage.h"
 #include "render/IRenderHandler.h"
@@ -64,20 +65,17 @@
 
 #include "../CCallback.h"
 
-#include "../lib/CArtHandler.h"
 #include "../lib/CConfigHandler.h"
-#include "../lib/CGeneralTextHandler.h"
-#include "../lib/CHeroHandler.h"
+#include "../lib/texts/CGeneralTextHandler.h"
 #include "../lib/CPlayerState.h"
+#include "../lib/CRandomGenerator.h"
 #include "../lib/CStack.h"
 #include "../lib/CStopWatch.h"
 #include "../lib/CThreadHelper.h"
-#include "../lib/CTownHandler.h"
 #include "../lib/GameConstants.h"
 #include "../lib/RoadHandler.h"
 #include "../lib/StartInfo.h"
 #include "../lib/TerrainHandler.h"
-#include "../lib/TextOperations.h"
 #include "../lib/UnlockGuard.h"
 #include "../lib/VCMIDirs.h"
 
@@ -100,12 +98,13 @@
 
 #include "../lib/pathfinder/CGPathNode.h"
 
-#include "../lib/serializer/BinaryDeserializer.h"
-#include "../lib/serializer/BinarySerializer.h"
 #include "../lib/serializer/CTypeList.h"
+#include "../lib/serializer/ESerializationVersion.h"
 
 #include "../lib/spells/CSpellHandler.h"
 
+#include "../lib/texts/TextOperations.h"
+
 // The macro below is used to mark functions that are called by client when game state changes.
 // They all assume that interface mutex is locked.
 #define EVENT_HANDLER_CALLED_BY_CLIENT
@@ -130,10 +129,11 @@
 
 CPlayerInterface::CPlayerInterface(PlayerColor Player):
 	localState(std::make_unique<PlayerLocalState>(*this)),
-	movementController(std::make_unique<HeroMovementController>())
+	movementController(std::make_unique<HeroMovementController>()),
+	artifactController(std::make_unique<ArtifactsUIController>())
+	
 {
 	logGlobal->trace("\tHuman player interface for player %s being constructed", Player.toString());
-	GH.defActionsDef = 0;
 	LOCPLINT = this;
 	playerID=Player;
 	human=true;
@@ -142,12 +142,10 @@
 	makingTurn = false;
 	showingDialog = new ConditionalWait();
 	cingconsole = new CInGameConsole();
-	firstCall = 1; //if loading will be overwritten in serialize
 	autosaveCount = 0;
 	isAutoFightOn = false;
 	isAutoFightEndBattle = false;
 	ignoreEvents = false;
-	numOfMovedArts = 0;
 }
 
 CPlayerInterface::~CPlayerInterface()
@@ -172,10 +170,11 @@
 void CPlayerInterface::closeAllDialogs()
 {
 	// remove all active dialogs that do not expect query answer
-	for (;;)
+	while(true)
 	{
 		auto adventureWindow = GH.windows().topWindow<AdventureMapInterface>();
 		auto infoWindow = GH.windows().topWindow<CInfoWindow>();
+		auto topWindow = GH.windows().topWindow<WindowBase>();
 
 		if(adventureWindow != nullptr)
 			break;
@@ -183,16 +182,8 @@
 		if(infoWindow && infoWindow->ID != QueryID::NONE)
 			break;
 
-		if (infoWindow)
-			infoWindow->close();
-		else
-			GH.windows().popWindows(1);
+		topWindow->close();
 	}
-
-	if(castleInt)
-		castleInt->close();
-
-	castleInt = nullptr;
 }
 
 void CPlayerInterface::playerEndsTurn(PlayerColor player)
@@ -247,7 +238,7 @@
 				std::string name = cb->getMapHeader()->name.toString();
 				int txtlen = TextOperations::getUnicodeCharactersCount(name);
 
-				TextOperations::trimRightUnicode(name, std::max(0, txtlen - 15));
+				TextOperations::trimRightUnicode(name, std::max(0, txtlen - 14));
 				auto const & isSymbolIllegal = [&](char c) {
 					static const std::string forbiddenChars("\\/:*?\"<>| ");
 
@@ -258,7 +249,7 @@
 				};
 				std::replace_if(name.begin(), name.end(), isSymbolIllegal, '_' );
 
-				prefix = name + "_" + cb->getStartInfo()->startTimeIso8601 + "/";
+				prefix = vstd::getFormattedDateTime(cb->getStartInfo()->startTime, "%Y-%m-%d_%H-%M") + "_" + name + "/";
 			}
 		}
 
@@ -412,13 +403,26 @@
 	localState->erasePath(hero);
 }
 
+void CPlayerInterface::townRemoved(const CGTownInstance* town)
+{
+	EVENT_HANDLER_CALLED_BY_CLIENT;
+
+	if(town->tempOwner == playerID)
+	{
+		localState->removeOwnedTown(town);
+		adventureInt->onTownChanged(town);
+	}
+}
+
+
 void CPlayerInterface::heroVisit(const CGHeroInstance * visitor, const CGObjectInstance * visitedObj, bool start)
 {
 	EVENT_HANDLER_CALLED_BY_CLIENT;
 	if(start && visitedObj)
 	{
-		if(visitedObj->getVisitSound())
-			CCS->soundh->playSound(visitedObj->getVisitSound().value());
+		auto visitSound = visitedObj->getVisitSound(CRandomGenerator::getDefault());
+		if (visitSound)
+			CCS->soundh->playSound(visitSound.value());
 	}
 }
 
@@ -427,6 +431,8 @@
 	EVENT_HANDLER_CALLED_BY_CLIENT;
 	localState->addWanderingHero(hero);
 	adventureInt->onHeroChanged(hero);
+	if(castleInt)
+		CCS->soundh->playSound(soundBase::newBuilding);
 }
 void CPlayerInterface::openTownWindow(const CGTownInstance * town)
 {
@@ -444,18 +450,20 @@
 	EVENT_HANDLER_CALLED_BY_CLIENT;
 	if (which == PrimarySkill::EXPERIENCE)
 	{
-		for(auto ctw : GH.windows().findWindows<CMarketWindow>())
-			ctw->updateHero();
+		for(auto ctw : GH.windows().findWindows<IMarketHolder>())
+			ctw->updateExperience();
 	}
 	else
+	{
 		adventureInt->onHeroChanged(hero);
+	}
 }
 
 void CPlayerInterface::heroSecondarySkillChanged(const CGHeroInstance * hero, int which, int val)
 {
 	EVENT_HANDLER_CALLED_BY_CLIENT;
-	for (auto cuw : GH.windows().findWindows<CUniversityWindow>())
-		cuw->redraw();
+	for (auto cuw : GH.windows().findWindows<IMarketHolder>())
+		cuw->updateSecondarySkills();
 }
 
 void CPlayerInterface::heroManaPointsChanged(const CGHeroInstance * hero)
@@ -474,8 +482,8 @@
 void CPlayerInterface::receivedResource()
 {
 	EVENT_HANDLER_CALLED_BY_CLIENT;
-	for (auto mw : GH.windows().findWindows<CMarketWindow>())
-		mw->updateResource();
+	for (auto mw : GH.windows().findWindows<IMarketHolder>())
+		mw->updateResources();
 
 	GH.windows().totalRedraw();
 }
@@ -623,7 +631,7 @@
 	waitForAllDialogs();
 }
 
-void CPlayerInterface::battleStart(const BattleID & battleID, const CCreatureSet *army1, const CCreatureSet *army2, int3 tile, const CGHeroInstance *hero1, const CGHeroInstance *hero2, bool side, bool replayAllowed)
+void CPlayerInterface::battleStart(const BattleID & battleID, const CCreatureSet *army1, const CCreatureSet *army2, int3 tile, const CGHeroInstance *hero1, const CGHeroInstance *hero2, BattleSide side, bool replayAllowed)
 {
 	EVENT_HANDLER_CALLED_BY_CLIENT;
 
@@ -935,7 +943,7 @@
 			info.secondaryDefender.push_back(cb->getBattle(battleID)->battleGetStackByID(elem.stackAttacked));
 		}
 	}
-	assert(info.defender != nullptr);
+	assert(info.defender != nullptr || (info.spellEffect != SpellID::NONE && info.indirectAttack));
 	assert(info.attacker != nullptr);
 
 	battleInt->stackAttacking(info);
@@ -1125,7 +1133,7 @@
 	std::vector<int> tempList;
 	tempList.reserve(objectGuiOrdered.size());
 
-	for(auto item : objectGuiOrdered)
+	for(const auto & item : objectGuiOrdered)
 		tempList.push_back(item.getNum());
 
 	CComponent localIconC(icon);
@@ -1134,16 +1142,16 @@
 	localIconC.removeChild(localIcon.get(), false);
 
 	std::vector<std::shared_ptr<IImage>> images;
-	for(auto & obj : objectGuiOrdered)
+	for(const auto & obj : objectGuiOrdered)
 	{
 		if(!settings["general"]["enableUiEnhancements"].Bool())
 			break;
 		const CGTownInstance * t = dynamic_cast<const CGTownInstance *>(cb->getObj(obj));
 		if(t)
 		{
-			std::shared_ptr<CAnimation> a = GH.renderHandler().loadAnimation(AnimationPath::builtin("ITPA"));
-			a->preload();
-			images.push_back(a->getImage(t->town->clientInfo.icons[t->hasFort()][false] + 2)->scaleFast(Point(35, 23)));
+			auto image = GH.renderHandler().loadImage(AnimationPath::builtin("ITPA"), t->getTown()->clientInfo.icons[t->hasFort()][false] + 2, 0, EImageBlitMode::OPAQUE);
+			image->scaleTo(Point(35, 23));
+			images.push_back(image);
 		}
 	}
 
@@ -1211,19 +1219,6 @@
 	}
 }
 
-void CPlayerInterface::saveGame( BinarySerializer & h )
-{
-	EVENT_HANDLER_CALLED_BY_CLIENT;
-	localState->serialize(h);
-}
-
-void CPlayerInterface::loadGame( BinaryDeserializer & h )
-{
-	EVENT_HANDLER_CALLED_BY_CLIENT;
-	localState->serialize(h);
-	firstCall = -1;
-}
-
 void CPlayerInterface::moveHero( const CGHeroInstance *h, const CGPath& path )
 {
 	LOG_TRACE(logGlobal);
@@ -1265,35 +1260,6 @@
 	GH.windows().pushWindow(cgw);
 }
 
-/**
- * Shows the dialog that appears when right-clicking an artifact that can be assembled
- * into a combinational one on an artifact screen. Does not require the combination of
- * artifacts to be legal.
- */
-void CPlayerInterface::showArtifactAssemblyDialog(const Artifact * artifact, const Artifact * assembledArtifact, CFunctionList<void()> onYes)
-{
-	std::string text = artifact->getDescriptionTranslated();
-	text += "\n\n";
-	std::vector<std::shared_ptr<CComponent>> scs;
-
-	if(assembledArtifact)
-	{
-		// You possess all of the components to...
-		text += boost::str(boost::format(CGI->generaltexth->allTexts[732]) % assembledArtifact->getNameTranslated());
-
-		// Picture of assembled artifact at bottom.
-		auto sc = std::make_shared<CComponent>(ComponentType::ARTIFACT, assembledArtifact->getId());
-		scs.push_back(sc);
-	}
-	else
-	{
-		// Do you wish to disassemble this artifact?
-		text += CGI->generaltexth->allTexts[733];
-	}
-
-	showYesNoDialog(text, onYes, nullptr, scs);
-}
-
 void CPlayerInterface::requestRealized( PackageApplied *pa )
 {
 	if(pa->packType == CTypeList::getInstance().getTypeID<MoveHero>(nullptr))
@@ -1378,6 +1344,8 @@
 			localState->addOwnedTown(town);
 	}
 
+	localState->deserialize(*cb->getPlayerState(playerID)->playerLocalSettings);
+
 	if(adventureInt)
 		adventureInt->onHeroChanged(nullptr);
 }
@@ -1452,10 +1420,14 @@
 void CPlayerInterface::objectRemoved(const CGObjectInstance * obj, const PlayerColor & initiator)
 {
 	EVENT_HANDLER_CALLED_BY_CLIENT;
-	if(playerID == initiator && obj->getRemovalSound())
+	if(playerID == initiator)
 	{
-		waitWhileDialog();
-		CCS->soundh->playSound(obj->getRemovalSound().value());
+		auto removalSound = obj->getRemovalSound(CRandomGenerator::getDefault());
+		if (removalSound)
+		{
+			waitWhileDialog();
+			CCS->soundh->playSound(removalSound.value());
+		}
 	}
 	CGI->mh->waitForOngoingAnimations();
 
@@ -1464,6 +1436,12 @@
 		const CGHeroInstance * h = static_cast<const CGHeroInstance *>(obj);
 		heroKilled(h);
 	}
+
+	if(obj->ID == Obj::TOWN && obj->tempOwner == playerID)
+	{
+		const CGTownInstance * t = static_cast<const CGTownInstance *>(obj);
+		townRemoved(t);
+	}
 	GH.fakeMouseMove();
 }
 
@@ -1496,6 +1474,7 @@
 			cmp.push_back(std::make_shared<CComponent>(ComponentType::FLAG, playerID));
 			makingTurn = true; //workaround for stiff showInfoDialog implementation
 			showInfoDialog(msg, cmp);
+			waitWhileDialog();
 			makingTurn = false;
 		}
 	}
@@ -1504,7 +1483,7 @@
 void CPlayerInterface::update()
 {
 	// Make sure that gamestate won't change when GUI objects may obtain its parts on event processing or drawing request
-	boost::shared_lock<boost::shared_mutex> gsLock(CGameState::mutex);
+	boost::shared_lock gsLock(CGameState::mutex);
 
 	// While mutexes were locked away we may be have stopped being the active interface
 	if (LOCPLINT != this)
@@ -1667,30 +1646,30 @@
 	battleInt->newRoundFirst();
 }
 
-void CPlayerInterface::showMarketWindow(const IMarket *market, const CGHeroInstance *visitor, QueryID queryID)
+void CPlayerInterface::showMarketWindow(const IMarket * market, const CGHeroInstance * visitor, QueryID queryID)
 {
 	EVENT_HANDLER_CALLED_BY_CLIENT;
 	auto onWindowClosed = [this, queryID](){
 		cb->selectionMade(0, queryID);
 	};
 
-	if (market->allowsTrade(EMarketMode::ARTIFACT_EXP) && dynamic_cast<const CGArtifactsAltar*>(market) == nullptr)
-	{
-		// compatibility check, safe to remove for 1.6
-		// 1.4 saves loaded in 1.5 will not be able to visit Altar of Sacrifice due to Altar now requiring different map object class
-		static_assert(ESerializationVersion::RELEASE_143 < ESerializationVersion::CURRENT, "Please remove this compatibility check once it no longer needed");
-		onWindowClosed();
-		return;
-	}
-
 	if(market->allowsTrade(EMarketMode::ARTIFACT_EXP) && visitor->getAlignment() != EAlignment::EVIL)
 		GH.windows().createAndPushWindow<CMarketWindow>(market, visitor, onWindowClosed, EMarketMode::ARTIFACT_EXP);
 	else if(market->allowsTrade(EMarketMode::CREATURE_EXP) && visitor->getAlignment() != EAlignment::GOOD)
 		GH.windows().createAndPushWindow<CMarketWindow>(market, visitor, onWindowClosed, EMarketMode::CREATURE_EXP);
 	else if(market->allowsTrade(EMarketMode::CREATURE_UNDEAD))
 		GH.windows().createAndPushWindow<CTransformerWindow>(market, visitor, onWindowClosed);
-	else if(!market->availableModes().empty())
-		GH.windows().createAndPushWindow<CMarketWindow>(market, visitor, onWindowClosed, market->availableModes().front());
+	else if (!market->availableModes().empty())
+		for(auto mode = EMarketMode::RESOURCE_RESOURCE; mode != EMarketMode::MARKET_AFTER_LAST_PLACEHOLDER; mode = vstd::next(mode, 1))
+		{
+			if(vstd::contains(market->availableModes(), mode))
+			{
+				GH.windows().createAndPushWindow<CMarketWindow>(market, visitor, onWindowClosed, mode);
+				break;
+			}
+		}
+	else
+		onWindowClosed();
 }
 
 void CPlayerInterface::showUniversityWindow(const IMarket *market, const CGHeroInstance *visitor, QueryID queryID)
@@ -1699,7 +1678,7 @@
 	auto onWindowClosed = [this, queryID](){
 		cb->selectionMade(0, queryID);
 	};
-	GH.windows().createAndPushWindow<CUniversityWindow>(visitor, market, onWindowClosed);
+	GH.windows().createAndPushWindow<CUniversityWindow>(visitor, BuildingID::NONE, market, onWindowClosed);
 }
 
 void CPlayerInterface::showHillFortWindow(const CGObjectInstance *object, const CGHeroInstance *visitor)
@@ -1711,7 +1690,7 @@
 void CPlayerInterface::availableArtifactsChanged(const CGBlackMarket * bm)
 {
 	EVENT_HANDLER_CALLED_BY_CLIENT;
-	for (auto cmw : GH.windows().findWindows<CMarketWindow>())
+	for (auto cmw : GH.windows().findWindows<IMarketHolder>())
 		cmw->updateArtifacts();
 }
 
@@ -1751,17 +1730,7 @@
 
 void CPlayerInterface::askToAssembleArtifact(const ArtifactLocation &al)
 {
-	if(auto hero = cb->getHero(al.artHolder))
-	{
-		auto art = hero->getArt(al.slot);
-		if(art == nullptr)
-		{
-			logGlobal->error("artifact location %d points to nothing",
-							 al.slot.num);
-			return;
-		}
-		ArtifactUtilsClient::askToAssemble(hero, al.slot);
-	}
+	artifactController->askToAssemble(al, true, true);
 }
 
 void CPlayerInterface::artifactPut(const ArtifactLocation &al)
@@ -1774,54 +1743,33 @@
 {
 	EVENT_HANDLER_CALLED_BY_CLIENT;
 	adventureInt->onHeroChanged(cb->getHero(al.artHolder));
-
-	for(auto artWin : GH.windows().findWindows<CWindowWithArtifacts>())
-		artWin->artifactRemoved(al);
-
-	waitWhileDialog();
+	artifactController->artifactRemoved();
 }
 
 void CPlayerInterface::artifactMoved(const ArtifactLocation &src, const ArtifactLocation &dst)
 {
 	EVENT_HANDLER_CALLED_BY_CLIENT;
 	adventureInt->onHeroChanged(cb->getHero(dst.artHolder));
-
-	bool redraw = true;
-	// If a bulk transfer has arrived, then redrawing only the last art movement.
-	if(numOfMovedArts != 0)
-	{
-		numOfMovedArts--;
-		if(numOfMovedArts != 0)
-			redraw = false;
-	}
-
-	for(auto artWin : GH.windows().findWindows<CWindowWithArtifacts>())
-		artWin->artifactMoved(src, dst, redraw);
-
-	waitWhileDialog();
+	artifactController->artifactMoved();
 }
 
-void CPlayerInterface::bulkArtMovementStart(size_t numOfArts)
+void CPlayerInterface::bulkArtMovementStart(size_t totalNumOfArts, size_t possibleAssemblyNumOfArts)
 {
-	numOfMovedArts = numOfArts;
+	artifactController->bulkArtMovementStart(totalNumOfArts, possibleAssemblyNumOfArts);
 }
 
 void CPlayerInterface::artifactAssembled(const ArtifactLocation &al)
 {
 	EVENT_HANDLER_CALLED_BY_CLIENT;
 	adventureInt->onHeroChanged(cb->getHero(al.artHolder));
-
-	for(auto artWin : GH.windows().findWindows<CWindowWithArtifacts>())
-		artWin->artifactAssembled(al);
+	artifactController->artifactAssembled();
 }
 
 void CPlayerInterface::artifactDisassembled(const ArtifactLocation &al)
 {
 	EVENT_HANDLER_CALLED_BY_CLIENT;
 	adventureInt->onHeroChanged(cb->getHero(al.artHolder));
-
-	for(auto artWin : GH.windows().findWindows<CWindowWithArtifacts>())
-		artWin->artifactDisassembled(al);
+	artifactController->artifactDisassembled();
 }
 
 void CPlayerInterface::waitForAllDialogs()
@@ -1844,7 +1792,6 @@
 		[]()
 		{
 			CSH->endGameplay();
-			GH.defActionsDef = 63;
 			CMM->menu->switchToTab("load");
 		},
 		nullptr
diff --color -urN vcmi-1.5.7/client/CPlayerInterface.h vcmi/client/CPlayerInterface.h
--- vcmi-1.5.7/client/CPlayerInterface.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/CPlayerInterface.h	2024-12-19 15:00:22.238120662 +0100
@@ -9,6 +9,8 @@
  */
 #pragma once
 
+#include "ArtifactsUIController.h"
+
 #include "../lib/FunctionList.h"
 #include "../lib/CGameInterface.h"
 #include "gui/CIntObject.h"
@@ -16,9 +18,7 @@
 VCMI_LIB_NAMESPACE_BEGIN
 
 class Artifact;
-
 struct TryMoveHero;
-class CGHeroInstance;
 class CStack;
 class CCreature;
 struct CGPath;
@@ -59,16 +59,13 @@
 class CPlayerInterface : public CGameInterface, public IUpdateable
 {
 	bool ignoreEvents;
-	size_t numOfMovedArts;
-
-	// -1 - just loaded game; 1 - just started game; 0 otherwise
-	int firstCall;
 	int autosaveCount;
 
 	std::list<std::shared_ptr<CInfoWindow>> dialogs; //queue of dialogs awaiting to be shown (not currently shown!)
 
 	std::unique_ptr<HeroMovementController> movementController;
 public: // TODO: make private
+	std::unique_ptr<ArtifactsUIController> artifactController;
 	std::shared_ptr<Environment> env;
 
 	std::unique_ptr<PlayerLocalState> localState;
@@ -100,7 +97,7 @@
 	void artifactPut(const ArtifactLocation &al) override;
 	void artifactRemoved(const ArtifactLocation &al) override;
 	void artifactMoved(const ArtifactLocation &src, const ArtifactLocation &dst) override;
-	void bulkArtMovementStart(size_t numOfArts) override;
+	void bulkArtMovementStart(size_t totalNumOfArts, size_t possibleAssemblyNumOfArts) override;
 	void artifactAssembled(const ArtifactLocation &al) override;
 	void askToAssembleArtifact(const ArtifactLocation & dst) override;
 	void artifactDisassembled(const ArtifactLocation &al) override;
@@ -123,7 +120,7 @@
 	void showTeleportDialog(const CGHeroInstance * hero, TeleportChannelID channel, TTeleportExitsList exits, bool impassable, QueryID askID) override;
 	void showGarrisonDialog(const CArmedInstance *up, const CGHeroInstance *down, bool removableUnits, QueryID queryID) override;
 	void showMapObjectSelectDialog(QueryID askID, const Component & icon, const MetaString & title, const MetaString & description, const std::vector<ObjectInstanceID> & objects) override;
-	void showMarketWindow(const IMarket *market, const CGHeroInstance *visitor, QueryID queryID) override;
+	void showMarketWindow(const IMarket * market, const CGHeroInstance * visitor, QueryID queryID) override;
 	void showUniversityWindow(const IMarket *market, const CGHeroInstance *visitor, QueryID queryID) override;
 	void showHillFortWindow(const CGObjectInstance *object, const CGHeroInstance *visitor) override;
 	void advmapSpellCast(const CGHeroInstance * caster, SpellID spellID) override; //called when a hero casts a spell
@@ -144,10 +141,8 @@
 	void objectRemovedAfter() override;
 	void playerBlocked(int reason, bool start) override;
 	void gameOver(PlayerColor player, const EVictoryLossCheckResult & victoryLossCheckResult) override;
-	void playerStartsTurn(PlayerColor player) override; //called before yourTurn on active itnerface
+	void playerStartsTurn(PlayerColor player) override; //called before yourTurn on active interface
 	void playerEndsTurn(PlayerColor player) override;
-	void saveGame(BinarySerializer & h) override; //saving
-	void loadGame(BinaryDeserializer & h) override; //loading
 	void showWorldViewEx(const std::vector<ObjectPosInfo> & objectPositions, bool showTerrain) override;
 
 	//for battles
@@ -165,7 +160,7 @@
 	void battleTriggerEffect(const BattleID & battleID, const BattleTriggerEffect & bte) override; //various one-shot effect
 	void battleStacksAttacked(const BattleID & battleID, const std::vector<BattleStackAttacked> & bsa, bool ranged) override;
 	void battleStartBefore(const BattleID & battleID, const CCreatureSet *army1, const CCreatureSet *army2, int3 tile, const CGHeroInstance *hero1, const CGHeroInstance *hero2) override; //called by engine just before battle starts; side=0 - left, side=1 - right
-	void battleStart(const BattleID & battleID, const CCreatureSet *army1, const CCreatureSet *army2, int3 tile, const CGHeroInstance *hero1, const CGHeroInstance *hero2, bool side, bool replayAllowed) override; //called by engine when battle starts; side=0 - left, side=1 - right
+	void battleStart(const BattleID & battleID, const CCreatureSet *army1, const CCreatureSet *army2, int3 tile, const CGHeroInstance *hero1, const CGHeroInstance *hero2, BattleSide side, bool replayAllowed) override; //called by engine when battle starts; side=0 - left, side=1 - right
 	void battleUnitsChanged(const BattleID & battleID, const std::vector<UnitChanges> & units) override;
 	void battleObstaclesChanged(const BattleID & battleID, const std::vector<ObstacleChanges> & obstacles) override;
 	void battleCatapultAttacked(const BattleID & battleID, const CatapultAttack & ca) override; //called when catapult makes an attack
@@ -184,7 +179,6 @@
 	void showShipyardDialog(const IShipyard *obj) override; //obj may be town or shipyard;
 
 	void showHeroExchange(ObjectInstanceID hero1, ObjectInstanceID hero2);
-	void showArtifactAssemblyDialog(const Artifact * artifact, const Artifact * assembledArtifact, CFunctionList<void()> onYes);
 	void waitWhileDialog();
 	void waitForAllDialogs();
 	void openTownWindow(const CGTownInstance * town); //shows townscreen
@@ -226,6 +220,7 @@
 	};
 
 	void heroKilled(const CGHeroInstance* hero);
+	void townRemoved(const CGTownInstance* town);
 	void garrisonsChanged(std::vector<const CArmedInstance *> objs);
 	void requestReturningToMainMenu(bool won);
 	void acceptTurn(QueryID queryID, bool hotseatWait); //used during hot seat after your turn message is close
diff --color -urN vcmi-1.5.7/client/CServerHandler.cpp vcmi/client/CServerHandler.cpp
--- vcmi-1.5.7/client/CServerHandler.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/CServerHandler.cpp	2024-12-19 15:00:22.239120704 +0100
@@ -21,20 +21,27 @@
 #include "globalLobby/GlobalLobbyClient.h"
 #include "lobby/CSelectionBase.h"
 #include "lobby/CLobbyScreen.h"
+#include "lobby/CBonusSelection.h"
 #include "windows/InfoWindows.h"
+#include "windows/GUIClasses.h"
+#include "media/CMusicHandler.h"
+#include "media/IVideoPlayer.h"
+
 
 #include "mainmenu/CMainMenu.h"
 #include "mainmenu/CPrologEpilogVideo.h"
 #include "mainmenu/CHighScoreScreen.h"
 
 #include "../lib/CConfigHandler.h"
-#include "../lib/CGeneralTextHandler.h"
+#include "../lib/texts/CGeneralTextHandler.h"
 #include "ConditionalWait.h"
 #include "../lib/CThreadHelper.h"
 #include "../lib/StartInfo.h"
 #include "../lib/TurnTimerInfo.h"
 #include "../lib/VCMIDirs.h"
 #include "../lib/campaign/CampaignState.h"
+#include "../lib/gameState/CGameState.h"
+#include "../lib/gameState/HighScore.h"
 #include "../lib/CPlayerState.h"
 #include "../lib/mapping/CMapInfo.h"
 #include "../lib/mapObjects/CGTownInstance.h"
@@ -43,73 +50,16 @@
 #include "../lib/rmg/CMapGenOptions.h"
 #include "../lib/serializer/Connection.h"
 #include "../lib/filesystem/Filesystem.h"
-#include "../lib/registerTypes/RegisterTypesLobbyPacks.h"
 #include "../lib/serializer/CMemorySerializer.h"
 #include "../lib/UnlockGuard.h"
 
 #include <boost/uuid/uuid.hpp>
 #include <boost/uuid/uuid_io.hpp>
 #include <boost/uuid/uuid_generators.hpp>
-#include "../lib/serializer/Cast.h"
 #include "LobbyClientNetPackVisitors.h"
 
 #include <vcmi/events/EventBus.h>
 
-template<typename T> class CApplyOnLobby;
-
-class CBaseForLobbyApply
-{
-public:
-	virtual bool applyOnLobbyHandler(CServerHandler * handler, CPackForLobby & pack) const = 0;
-	virtual void applyOnLobbyScreen(CLobbyScreen * lobby, CServerHandler * handler, CPackForLobby & pack) const = 0;
-	virtual ~CBaseForLobbyApply(){};
-	template<typename U> static CBaseForLobbyApply * getApplier(const U * t = nullptr)
-	{
-		return new CApplyOnLobby<U>();
-	}
-};
-
-template<typename T> class CApplyOnLobby : public CBaseForLobbyApply
-{
-public:
-	bool applyOnLobbyHandler(CServerHandler * handler, CPackForLobby & pack) const override
-	{
-		auto & ref = static_cast<T&>(pack);
-		ApplyOnLobbyHandlerNetPackVisitor visitor(*handler);
-
-		logNetwork->trace("\tImmediately apply on lobby: %s", typeid(ref).name());
-		ref.visit(visitor);
-
-		return visitor.getResult();
-	}
-
-	void applyOnLobbyScreen(CLobbyScreen * lobby, CServerHandler * handler, CPackForLobby & pack) const override
-	{
-		auto & ref = static_cast<T &>(pack);
-		ApplyOnLobbyScreenNetPackVisitor visitor(*handler, lobby);
-
-		logNetwork->trace("\tApply on lobby from queue: %s", typeid(ref).name());
-		ref.visit(visitor);
-	}
-};
-
-template<> class CApplyOnLobby<CPack>: public CBaseForLobbyApply
-{
-public:
-	bool applyOnLobbyHandler(CServerHandler * handler, CPackForLobby & pack) const override
-	{
-		logGlobal->error("Cannot apply plain CPack!");
-		assert(0);
-		return false;
-	}
-
-	void applyOnLobbyScreen(CLobbyScreen * lobby, CServerHandler * handler, CPackForLobby & pack) const override
-	{
-		logGlobal->error("Cannot apply plain CPack!");
-		assert(0);
-	}
-};
-
 CServerHandler::~CServerHandler()
 {
 	if (serverRunner)
@@ -147,7 +97,6 @@
 	: networkHandler(INetworkHandler::createHandler())
 	, lobbyClient(std::make_unique<GlobalLobbyClient>())
 	, gameChat(std::make_unique<GameChatHandler>())
-	, applier(std::make_unique<CApplier<CBaseForLobbyApply>>())
 	, threadNetwork(&CServerHandler::threadRunNetwork, this)
 	, state(EClientState::NONE)
 	, serverPort(0)
@@ -158,12 +107,6 @@
 	, client(nullptr)
 {
 	uuid = boost::uuids::to_string(boost::uuids::random_generator()());
-	registerTypesLobbyPacks(*applier);
-}
-
-void CServerHandler::setHighScoreCalc(const std::shared_ptr<HighScoreCalculation> &newHighScoreCalc)
-{
-	campaignScoreCalculator = newHighScoreCalc;
 }
 
 void CServerHandler::threadRunNetwork()
@@ -173,7 +116,7 @@
 	try {
 		networkHandler->run();
 	}
-	catch (const TerminationRequestedException & e)
+	catch (const TerminationRequestedException &)
 	{
 		logGlobal->info("Terminating network thread");
 		return;
@@ -198,7 +141,12 @@
 	if(!playerNames.empty()) //if have custom set of player names - use it
 		localPlayerNames = playerNames;
 	else
-		localPlayerNames.push_back(settings["general"]["playerName"].String());
+	{
+		std::string playerName = settings["general"]["playerName"].String();
+		if(playerName == "Player")
+			playerName = CGI->generaltexth->translate("core.genrltxt.434");
+		localPlayerNames.push_back(playerName);
+	}
 
 	gameChat->resetMatchState();
 	lobbyClient->resetMatchState();
@@ -238,9 +186,9 @@
 	si->difficulty = lastDifficulty.Integer();
 
 	logNetwork->trace("\tStarting local server");
-	serverRunner->start(getLocalPort(), connectToLobby, si);
+	uint16_t srvport = serverRunner->start(getLocalPort(), connectToLobby, si);
 	logNetwork->trace("\tConnecting to local server");
-	connectToServer(getLocalHostname(), getLocalPort());
+	connectToServer(getLocalHostname(), srvport);
 	logNetwork->trace("\tWaiting for connection");
 }
 
@@ -324,8 +272,8 @@
 
 void CServerHandler::applyPackOnLobbyScreen(CPackForLobby & pack)
 {
-	const CBaseForLobbyApply * apply = applier->getApplier(CTypeList::getInstance().getTypeID(&pack)); //find the applier
-	apply->applyOnLobbyScreen(dynamic_cast<CLobbyScreen *>(SEL), this, pack);
+	ApplyOnLobbyScreenNetPackVisitor visitor(*this, dynamic_cast<CLobbyScreen *>(SEL));
+	pack.visit(visitor);
 	GH.windows().totalRedraw();
 }
 
@@ -497,6 +445,14 @@
 	sendLobbyPack(lspn);
 }
 
+void CServerHandler::setPlayerHandicap(PlayerColor color, Handicap handicap) const
+{
+	LobbySetPlayerHandicap lsph;
+	lsph.color = color;
+	lsph.handicap = handicap;
+	sendLobbyPack(lsph);
+}
+
 void CServerHandler::setPlayerOption(ui8 what, int32_t value, PlayerColor player) const
 {
 	LobbyChangePlayerOption lcpo;
@@ -585,7 +541,10 @@
 
 void CServerHandler::sendRestartGame() const
 {
-	GH.windows().createAndPushWindow<CLoadingScreen>();
+	if(si->campState && !si->campState->getLoadingBackground().empty())
+		GH.windows().createAndPushWindow<CLoadingScreen>(si->campState->getLoadingBackground());
+	else
+		GH.windows().createAndPushWindow<CLoadingScreen>();
 	
 	LobbyRestartGame endGame;
 	sendLobbyPack(endGame);
@@ -629,7 +588,12 @@
 	verifyStateBeforeStart(allowOnlyAI ? true : settings["session"]["onlyai"].Bool());
 
 	if(!settings["session"]["headless"].Bool())
-		GH.windows().createAndPushWindow<CLoadingScreen>();
+	{
+		if(si->campState && !si->campState->getLoadingBackground().empty())
+			GH.windows().createAndPushWindow<CLoadingScreen>(si->campState->getLoadingBackground());
+		else
+			GH.windows().createAndPushWindow<CLoadingScreen>();
+	}
 	
 	LobbyPrepareStartGame lpsg;
 	sendLobbyPack(lpsg);
@@ -655,7 +619,7 @@
 		break;
 	case EStartMode::CAMPAIGN:
 		if(si->campState->conqueredScenarios().empty())
-			campaignScoreCalculator.reset();
+			si->campState->highscoreParameters.clear();
 		client->newGame(gameState);
 		break;
 	case EStartMode::LOAD_GAME:
@@ -669,43 +633,13 @@
 	setState(EClientState::GAMEPLAY);
 }
 
-HighScoreParameter CServerHandler::prepareHighScores(PlayerColor player, bool victory)
-{
-	const auto * gs = client->gameState();
-	const auto * playerState = gs->getPlayerState(player);
-
-	HighScoreParameter param;
-	param.difficulty = gs->getStartInfo()->difficulty;
-	param.day = gs->getDate();
-	param.townAmount = gs->howManyTowns(player);
-	param.usedCheat = gs->getPlayerState(player)->cheated;
-	param.hasGrail = false;
-	for(const CGHeroInstance * h : playerState->heroes)
-		if(h->hasArt(ArtifactID::GRAIL))
-			param.hasGrail = true;
-	for(const CGTownInstance * t : playerState->towns)
-		if(t->builtBuildings.count(BuildingID::GRAIL))
-			param.hasGrail = true;
-	param.allDefeated = true;
-	for (PlayerColor otherPlayer(0); otherPlayer < PlayerColor::PLAYER_LIMIT; ++otherPlayer)
-	{
-		auto ps = gs->getPlayerState(otherPlayer, false);
-		if(ps && otherPlayer != player && !ps->checkVanquished())
-			param.allDefeated = false;
-	}
-	param.scenarioName = gs->getMapHeader()->name.toString();
-	param.playerName = gs->getStartInfo()->playerInfos.find(player)->second.name;
-
-	return param;
-}
-
-void CServerHandler::showHighScoresAndEndGameplay(PlayerColor player, bool victory)
+void CServerHandler::showHighScoresAndEndGameplay(PlayerColor player, bool victory, const StatisticDataSet & statistic)
 {
-	HighScoreParameter param = prepareHighScores(player, victory);
+	HighScoreParameter param = HighScore::prepareHighScores(client->gameState(), player, victory);
 
 	if(victory && client->gameState()->getStartInfo()->campState)
 	{
-		startCampaignScenario(param, client->gameState()->getStartInfo()->campState);
+		startCampaignScenario(param, client->gameState()->getStartInfo()->campState, statistic);
 	}
 	else
 	{
@@ -714,9 +648,8 @@
 		scenarioHighScores.isCampaign = false;
 
 		endGameplay();
-		GH.defActionsDef = 63;
 		CMM->menu->switchToTab("main");
-		GH.windows().createAndPushWindow<CHighScoreInputScreen>(victory, scenarioHighScores);
+		GH.windows().createAndPushWindow<CHighScoreInputScreen>(victory, scenarioHighScores, statistic);
 	}
 }
 
@@ -734,10 +667,13 @@
 	{
 		GH.curInt = CMM.get();
 		CMM->enable();
+		CMM->playMusic();
 	}
 	else
 	{
-		GH.curInt = CMainMenu::create().get();
+		auto mainMenu = CMainMenu::create();
+		GH.curInt = mainMenu.get();
+		mainMenu->playMusic();
 	}
 }
 
@@ -749,26 +685,23 @@
 	logicConnection->enterLobbyConnectionMode();
 }
 
-void CServerHandler::startCampaignScenario(HighScoreParameter param, std::shared_ptr<CampaignState> cs)
+void CServerHandler::startCampaignScenario(HighScoreParameter param, std::shared_ptr<CampaignState> cs, const StatisticDataSet & statistic)
 {
 	std::shared_ptr<CampaignState> ourCampaign = cs;
 
 	if (!cs)
 		ourCampaign = si->campState;
 
-	if(campaignScoreCalculator == nullptr)
-	{
-		campaignScoreCalculator = std::make_shared<HighScoreCalculation>();
-		campaignScoreCalculator->isCampaign = true;
-		campaignScoreCalculator->parameters.clear();
-	}
 	param.campaignName = cs->getNameTranslated();
-	campaignScoreCalculator->parameters.push_back(param);
+	cs->highscoreParameters.push_back(param);
+	auto campaignScoreCalculator = std::make_shared<HighScoreCalculation>();
+	campaignScoreCalculator->isCampaign = true;
+	campaignScoreCalculator->parameters = cs->highscoreParameters;
 
 	endGameplay();
 
 	auto & epilogue = ourCampaign->scenario(*ourCampaign->lastScenario()).epilog;
-	auto finisher = [this, ourCampaign]()
+	auto finisher = [ourCampaign, campaignScoreCalculator, statistic]()
 	{
 		if(ourCampaign->campaignSet != "" && ourCampaign->isCampaignFinished())
 		{
@@ -784,7 +717,15 @@
 		else
 		{
 			CMM->openCampaignScreen(ourCampaign->campaignSet);
-			GH.windows().createAndPushWindow<CHighScoreInputScreen>(true, *campaignScoreCalculator);
+			if(!ourCampaign->getOutroVideo().empty() && CCS->videoh->open(ourCampaign->getOutroVideo(), 1))
+			{
+				CCS->musich->stopMusic();
+				GH.windows().createAndPushWindow<VideoWindow>(ourCampaign->getOutroVideo(), ourCampaign->getVideoRim().empty() ? ImagePath::builtin("INTRORIM") : ourCampaign->getVideoRim(), false, 1, [campaignScoreCalculator, statistic](bool skipped){
+					GH.windows().createAndPushWindow<CHighScoreInputScreen>(true, *campaignScoreCalculator, statistic);
+				});
+			}
+			else
+				GH.windows().createAndPushWindow<CHighScoreInputScreen>(true, *campaignScoreCalculator, statistic);
 		}
 	};
 
@@ -917,7 +858,7 @@
 	if(getState() == EClientState::DISCONNECTING)
 		return;
 
-	CPack * pack = logicConnection->retrievePack(message);
+	auto pack = logicConnection->retrievePack(message);
 	ServerHandlerCPackVisitor visitor(*this);
 	pack->visit(visitor);
 }
@@ -948,7 +889,6 @@
 	if(client)
 	{
 		endGameplay();
-		GH.defActionsDef = 63;
 		CMM->menu->switchToTab("main");
 		showServerError(CGI->generaltexth->translate("vcmi.server.errors.disconnected"));
 	}
@@ -991,7 +931,10 @@
 
 void CServerHandler::visitForLobby(CPackForLobby & lobbyPack)
 {
-	if(applier->getApplier(CTypeList::getInstance().getTypeID(&lobbyPack))->applyOnLobbyHandler(this, lobbyPack))
+	ApplyOnLobbyHandlerNetPackVisitor visitor(*this);
+	lobbyPack.visit(visitor);
+
+	if(visitor.getResult())
 	{
 		if(!settings["session"]["headless"].Bool())
 			applyPackOnLobbyScreen(lobbyPack);
@@ -1000,14 +943,14 @@
 
 void CServerHandler::visitForClient(CPackForClient & clientPack)
 {
-	client->handlePack(&clientPack);
+	client->handlePack(clientPack);
 }
 
 
 void CServerHandler::sendLobbyPack(const CPackForLobby & pack) const
 {
 	if(getState() != EClientState::STARTING)
-		logicConnection->sendPack(&pack);
+		logicConnection->sendPack(pack);
 }
 
 bool CServerHandler::inLobbyRoom() const
diff --color -urN vcmi-1.5.7/client/CServerHandler.h vcmi/client/CServerHandler.h
--- vcmi-1.5.7/client/CServerHandler.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/CServerHandler.h	2024-12-19 15:00:22.239120704 +0100
@@ -13,6 +13,7 @@
 
 #include "../lib/network/NetworkInterface.h"
 #include "../lib/StartInfo.h"
+#include "../lib/gameState/GameStatistics.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
@@ -24,11 +25,10 @@
 class CMapInfo;
 class CGameState;
 struct ClientPlayer;
-struct CPack;
 struct CPackForLobby;
 struct CPackForClient;
 
-template<typename T> class CApplier;
+class HighScoreParameter;
 
 VCMI_LIB_NAMESPACE_END
 
@@ -38,9 +38,6 @@
 class GameChatHandler;
 class IServerRunner;
 
-class HighScoreCalculation;
-class HighScoreParameter;
-
 enum class ESelectionScreen : ui8;
 enum class ELoadMode : ui8;
 
@@ -81,6 +78,7 @@
 	virtual void setMapInfo(std::shared_ptr<CMapInfo> to, std::shared_ptr<CMapGenOptions> mapGenOpts = {}) const = 0;
 	virtual void setPlayer(PlayerColor color) const = 0;
 	virtual void setPlayerName(PlayerColor color, const std::string & name) const = 0;
+	virtual void setPlayerHandicap(PlayerColor color, Handicap handicap) const = 0;
 	virtual void setPlayerOption(ui8 what, int32_t value, PlayerColor player) const = 0;
 	virtual void setDifficulty(int to) const = 0;
 	virtual void setTurnTimerInfo(const TurnTimerInfo &) const = 0;
@@ -101,11 +99,9 @@
 	std::shared_ptr<INetworkConnection> networkConnection;
 	std::unique_ptr<GlobalLobbyClient> lobbyClient;
 	std::unique_ptr<GameChatHandler> gameChat;
-	std::unique_ptr<CApplier<CBaseForLobbyApply>> applier;
 	std::unique_ptr<IServerRunner> serverRunner;
 	std::shared_ptr<CMapInfo> mapToStart;
 	std::vector<std::string> localPlayerNames;
-	std::shared_ptr<HighScoreCalculation> campaignScoreCalculator;
 
 	boost::thread threadNetwork;
 
@@ -127,8 +123,6 @@
 
 	bool isServerLocal() const;
 
-	HighScoreParameter prepareHighScores(PlayerColor player, bool victory);
-
 public:
 	/// High-level connection overlay that is capable of (de)serializing network data
 	std::shared_ptr<CConnection> logicConnection;
@@ -191,6 +185,7 @@
 	void setMapInfo(std::shared_ptr<CMapInfo> to, std::shared_ptr<CMapGenOptions> mapGenOpts = {}) const override;
 	void setPlayer(PlayerColor color) const override;
 	void setPlayerName(PlayerColor color, const std::string & name) const override;
+	void setPlayerHandicap(PlayerColor color, Handicap handicap) const override;
 	void setPlayerOption(ui8 what, int32_t value, PlayerColor player) const override;
 	void setDifficulty(int to) const override;
 	void setTurnTimerInfo(const TurnTimerInfo &) const override;
@@ -206,11 +201,11 @@
 	void debugStartTest(std::string filename, bool save = false);
 
 	void startGameplay(VCMI_LIB_WRAP_NAMESPACE(CGameState) * gameState = nullptr);
-	void showHighScoresAndEndGameplay(PlayerColor player, bool victory);
+	void showHighScoresAndEndGameplay(PlayerColor player, bool victory, const StatisticDataSet & statistic);
 	void endNetwork();
 	void endGameplay();
 	void restartGameplay();
-	void startCampaignScenario(HighScoreParameter param, std::shared_ptr<CampaignState> cs = {});
+	void startCampaignScenario(HighScoreParameter param, std::shared_ptr<CampaignState> cs, const StatisticDataSet & statistic);
 	void showServerError(const std::string & txt) const;
 
 	// TODO: LobbyState must be updated within game so we should always know how many player interfaces our client handle
@@ -219,7 +214,6 @@
 
 	void visitForLobby(CPackForLobby & lobbyPack);
 	void visitForClient(CPackForClient & clientPack);
-	void setHighScoreCalc(const std::shared_ptr<HighScoreCalculation> &newHighScoreCalc);
 };
 
 extern CServerHandler * CSH;
diff --color -urN vcmi-1.5.7/client/CVideoHandler.cpp vcmi/client/CVideoHandler.cpp
--- vcmi-1.5.7/client/CVideoHandler.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/CVideoHandler.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,713 +0,0 @@
-/*
- * CVideoHandler.cpp, part of VCMI engine
- *
- * Authors: listed in file AUTHORS in main folder
- *
- * License: GNU General Public License v2.0 or later
- * Full text of license available in license.txt file, in main folder
- *
- */
-#include "StdInc.h"
-#include "CVideoHandler.h"
-
-#include "CMT.h"
-#include "gui/CGuiHandler.h"
-#include "eventsSDL/InputHandler.h"
-#include "gui/FramerateManager.h"
-#include "renderSDL/SDL_Extensions.h"
-#include "CPlayerInterface.h"
-#include "../lib/filesystem/Filesystem.h"
-#include "../lib/filesystem/CInputStream.h"
-
-#include <SDL_render.h>
-
-#ifndef DISABLE_VIDEO
-
-extern "C" {
-#include <libavformat/avformat.h>
-#include <libavcodec/avcodec.h>
-#include <libavutil/imgutils.h>
-#include <libswscale/swscale.h>
-}
-
-#ifdef _MSC_VER
-#pragma comment(lib, "avcodec.lib")
-#pragma comment(lib, "avutil.lib")
-#pragma comment(lib, "avformat.lib")
-#pragma comment(lib, "swscale.lib")
-#endif // _MSC_VER
-
-// Define a set of functions to read data
-static int lodRead(void* opaque, uint8_t* buf, int size)
-{
-	auto video = reinterpret_cast<CVideoPlayer *>(opaque);
-	int bytes = static_cast<int>(video->data->read(buf, size));
-	if(bytes == 0)
-    	return AVERROR_EOF;
-
-	return bytes;
-}
-
-static si64 lodSeek(void * opaque, si64 pos, int whence)
-{
-	auto video = reinterpret_cast<CVideoPlayer *>(opaque);
-
-	if (whence & AVSEEK_SIZE)
-		return video->data->getSize();
-
-	return video->data->seek(pos);
-}
-
-// Define a set of functions to read data
-static int lodReadAudio(void* opaque, uint8_t* buf, int size)
-{
-	auto video = reinterpret_cast<CVideoPlayer *>(opaque);
-	int bytes = static_cast<int>(video->dataAudio->read(buf, size));
-	if(bytes == 0)
-    	return AVERROR_EOF;
-
-	return bytes;
-}
-
-static si64 lodSeekAudio(void * opaque, si64 pos, int whence)
-{
-	auto video = reinterpret_cast<CVideoPlayer *>(opaque);
-
-	if (whence & AVSEEK_SIZE)
-		return video->dataAudio->getSize();
-
-	return video->dataAudio->seek(pos);
-}
-
-CVideoPlayer::CVideoPlayer()
-	: stream(-1)
-	, format (nullptr)
-	, codecContext(nullptr)
-	, codec(nullptr)
-	, frame(nullptr)
-	, sws(nullptr)
-	, context(nullptr)
-	, texture(nullptr)
-	, dest(nullptr)
-	, destRect(0,0,0,0)
-	, pos(0,0,0,0)
-	, frameTime(0)
-	, doLoop(false)
-{}
-
-bool CVideoPlayer::open(const VideoPath & fname, bool scale)
-{
-	return open(fname, true, false);
-}
-
-// loop = to loop through the video
-// overlay = directly write to the screen.
-bool CVideoPlayer::open(const VideoPath & videoToOpen, bool loop, bool overlay, bool scale)
-{
-	close();
-
-	doLoop = loop;
-	frameTime = 0;
-
-	if (CResourceHandler::get()->existsResource(videoToOpen))
-		fname = videoToOpen;
-	else
-		fname = videoToOpen.addPrefix("VIDEO/");
-
-	if (!CResourceHandler::get()->existsResource(fname))
-	{
-		logGlobal->error("Error: video %s was not found", fname.getName());
-		return false;
-	}
-
-	data = CResourceHandler::get()->load(fname);
-
-	static const int BUFFER_SIZE = 4096;
-
-	unsigned char * buffer  = (unsigned char *)av_malloc(BUFFER_SIZE);// will be freed by ffmpeg
-	context = avio_alloc_context( buffer, BUFFER_SIZE, 0, (void *)this, lodRead, nullptr, lodSeek);
-
-	format = avformat_alloc_context();
-	format->pb = context;
-	// filename is not needed - file was already open and stored in this->data;
-	int avfopen = avformat_open_input(&format, "dummyFilename", nullptr, nullptr);
-
-	if (avfopen != 0)
-	{
-		return false;
-	}
-	// Retrieve stream information
-	if (avformat_find_stream_info(format, nullptr) < 0)
-		return false;
-
-	// Find the first video stream
-	stream = -1;
-	for(ui32 i=0; i<format->nb_streams; i++)
-	{
-		if (format->streams[i]->codecpar->codec_type == AVMEDIA_TYPE_VIDEO)
-		{
-			stream = i;
-			break;
-		}
-	}
-
-	if (stream < 0)
-		// No video stream in that file
-		return false;
-
-	// Find the decoder for the video stream
-	codec = avcodec_find_decoder(format->streams[stream]->codecpar->codec_id);
-
-	if (codec == nullptr)
-	{
-		// Unsupported codec
-		return false;
-	}
-
-	codecContext = avcodec_alloc_context3(codec);
-	if(!codecContext)
-		return false;
-	// Get a pointer to the codec context for the video stream
-	int ret = avcodec_parameters_to_context(codecContext, format->streams[stream]->codecpar);
-	if (ret < 0)
-	{
-		//We cannot get codec from parameters
-		avcodec_free_context(&codecContext);
-		return false;
-	}
-
-	// Open codec
-	if ( avcodec_open2(codecContext, codec, nullptr) < 0 )
-	{
-		// Could not open codec
-		codec = nullptr;
-		return false;
-	}
-	// Allocate video frame
-	frame = av_frame_alloc();
-
-	//setup scaling
-	if(scale)
-	{
-		pos.w = screen->w;
-		pos.h = screen->h;
-	}
-	else
-	{
-		pos.w  = codecContext->width;
-		pos.h = codecContext->height;
-	}
-
-	// Allocate a place to put our YUV image on that screen
-	if (overlay)
-	{
-		texture = SDL_CreateTexture( mainRenderer, SDL_PIXELFORMAT_IYUV, SDL_TEXTUREACCESS_STATIC, pos.w, pos.h);
-	}
-	else
-	{
-		dest = CSDL_Ext::newSurface(pos.w, pos.h);
-		destRect.x = destRect.y = 0;
-		destRect.w = pos.w;
-		destRect.h = pos.h;
-	}
-
-	if (texture == nullptr && dest == nullptr)
-		return false;
-
-	if (texture)
-	{ // Convert the image into YUV format that SDL uses
-		sws = sws_getContext(codecContext->width, codecContext->height, codecContext->pix_fmt,
-							 pos.w, pos.h,
-							 AV_PIX_FMT_YUV420P,
-							 SWS_BICUBIC, nullptr, nullptr, nullptr);
-	}
-	else
-	{
-		AVPixelFormat screenFormat = AV_PIX_FMT_NONE;
-		if (screen->format->Bshift > screen->format->Rshift)
-		{
-			// this a BGR surface
-			switch (screen->format->BytesPerPixel)
-			{
-				case 2: screenFormat = AV_PIX_FMT_BGR565; break;
-				case 3: screenFormat = AV_PIX_FMT_BGR24; break;
-				case 4: screenFormat = AV_PIX_FMT_BGR32; break;
-				default: return false;
-			}
-		}
-		else
-		{
-			// this a RGB surface
-			switch (screen->format->BytesPerPixel)
-			{
-				case 2: screenFormat = AV_PIX_FMT_RGB565; break;
-				case 3: screenFormat = AV_PIX_FMT_RGB24; break;
-				case 4: screenFormat = AV_PIX_FMT_RGB32; break;
-				default: return false;
-			}
-		}
-
-		sws = sws_getContext(codecContext->width, codecContext->height, codecContext->pix_fmt,
-							 pos.w, pos.h, screenFormat,
-							 SWS_BICUBIC, nullptr, nullptr, nullptr);
-	}
-
-	if (sws == nullptr)
-		return false;
-
-	return true;
-}
-
-// Read the next frame. Return false on error/end of file.
-bool CVideoPlayer::nextFrame()
-{
-	AVPacket packet;
-	int frameFinished = 0;
-	bool gotError = false;
-
-	if (sws == nullptr)
-		return false;
-
-	while(!frameFinished)
-	{
-		int ret = av_read_frame(format, &packet);
-		if (ret < 0)
-		{
-			// Error. It's probably an end of file.
-			if (doLoop && !gotError)
-			{
-				// Rewind
-				frameTime = 0;
-				if (av_seek_frame(format, stream, 0, AVSEEK_FLAG_BYTE) < 0)
-					break;
-				gotError = true;
-			}
-			else
-			{
-				break;
-			}
-		}
-		else
-		{
-			// Is this a packet from the video stream?
-			if (packet.stream_index == stream)
-			{
-				// Decode video frame
-				int rc = avcodec_send_packet(codecContext, &packet);
-				if (rc >=0)
-					packet.size = 0;
-				rc = avcodec_receive_frame(codecContext, frame);
-				if (rc >= 0)
-					frameFinished = 1;
-				// Did we get a video frame?
-				if (frameFinished)
-				{
-					uint8_t *data[4];
-					int linesize[4];
-
-					if (texture) {
-						av_image_alloc(data, linesize, pos.w, pos.h, AV_PIX_FMT_YUV420P, 1);
-
-						sws_scale(sws, frame->data, frame->linesize,
-								  0, codecContext->height, data, linesize);
-
-						SDL_UpdateYUVTexture(texture, nullptr, data[0], linesize[0],
-								data[1], linesize[1],
-								data[2], linesize[2]);
-						av_freep(&data[0]);
-					}
-					else
-					{
-						/* Avoid buffer overflow caused by sws_scale():
-						 *     http://trac.ffmpeg.org/ticket/9254
-						 * Currently (ffmpeg-4.4 with SSE3 enabled) sws_scale()
-						 * has a few requirements for target data buffers on rescaling:
-						 * 1. buffer has to be aligned to be usable for SIMD instructions
-						 * 2. buffer has to be padded to allow small overflow by SIMD instructions
-						 * Unfortunately SDL_Surface does not provide these guarantees.
-						 * This means that atempt to rescale directly into SDL surface causes
-						 * memory corruption. Usually it happens on campaign selection screen
-						 * where short video moves start spinning on mouse hover.
-						 *
-						 * To fix [1.] we use av_malloc() for memory allocation.
-						 * To fix [2.] we add an `ffmpeg_pad` that provides plenty of space.
-						 * We have to use intermdiate buffer and then use memcpy() to land it
-						 * to SDL_Surface.
-						 */
-						size_t pic_bytes = dest->pitch * dest->h;
-						size_t ffmped_pad = 1024; /* a few bytes of overflow will go here */
-						void * for_sws = av_malloc (pic_bytes + ffmped_pad);
-						data[0] = (ui8 *)for_sws;
-						linesize[0] = dest->pitch;
-
-						sws_scale(sws, frame->data, frame->linesize,
-								  0, codecContext->height, data, linesize);
-						memcpy(dest->pixels, for_sws, pic_bytes);
-						av_free(for_sws);
-					}
-				}
-			}
-
-			av_packet_unref(&packet);
-		}
-	}
-
-	return frameFinished != 0;
-}
-
-void CVideoPlayer::show( int x, int y, SDL_Surface *dst, bool update )
-{
-	if (sws == nullptr)
-		return;
-
-	pos.x = x;
-	pos.y = y;
-	CSDL_Ext::blitSurface(dest, destRect, dst, pos.topLeft());
-
-	if (update)
-		CSDL_Ext::updateRect(dst, pos);
-}
-
-void CVideoPlayer::redraw( int x, int y, SDL_Surface *dst, bool update )
-{
-	show(x, y, dst, update);
-}
-
-void CVideoPlayer::update( int x, int y, SDL_Surface *dst, bool forceRedraw, bool update, std::function<void()> onVideoRestart)
-{
-	if (sws == nullptr)
-		return;
-
-#if (LIBAVUTIL_VERSION_MAJOR < 58)   
-	auto packet_duration = frame->pkt_duration;
-#else
-	auto packet_duration = frame->duration;
-#endif
-	double frameEndTime = (frame->pts + packet_duration) * av_q2d(format->streams[stream]->time_base);
-	frameTime += GH.framerate().getElapsedMilliseconds() / 1000.0;
-
-	if (frameTime >= frameEndTime )
-	{
-		if (nextFrame())
-			show(x,y,dst,update);
-		else
-		{
-			if(onVideoRestart)
-				onVideoRestart();
-			VideoPath filenameToReopen = fname; // create copy to backup this->fname
-			open(filenameToReopen);
-			nextFrame();
-
-			// The y position is wrong at the first frame.
-			// Note: either the windows player or the linux player is
-			// broken. Compensate here until the bug is found.
-			show(x, y--, dst, update);
-		}
-	}
-	else
-	{
-		redraw(x, y, dst, update);
-	}
-}
-
-void CVideoPlayer::close()
-{
-	fname = VideoPath();
-
-	if (sws)
-	{
-		sws_freeContext(sws);
-		sws = nullptr;
-	}
-
-	if (texture)
-	{
-		SDL_DestroyTexture(texture);
-		texture = nullptr;
-	}
-
-	if (dest)
-	{
-		SDL_FreeSurface(dest);
-		dest = nullptr;
-	}
-
-	if (frame)
-	{
-		av_frame_free(&frame);//will be set to null
-	}
-
-	if (codec)
-	{
-		avcodec_close(codecContext);
-		codec = nullptr;
-	}
-	if (codecContext)
-	{
-		avcodec_free_context(&codecContext);
-	}
-
-	if (format)
-	{
-		avformat_close_input(&format);
-	}
-
-	if (context)
-	{
-		av_free(context);
-		context = nullptr;
-	}
-}
-
-std::pair<std::unique_ptr<ui8 []>, si64> CVideoPlayer::getAudio(const VideoPath & videoToOpen)
-{
-	std::pair<std::unique_ptr<ui8 []>, si64> dat(std::make_pair(nullptr, 0));
-
-	VideoPath fnameAudio;
-
-	if (CResourceHandler::get()->existsResource(videoToOpen))
-		fnameAudio = videoToOpen;
-	else
-		fnameAudio = videoToOpen.addPrefix("VIDEO/");
-
-	if (!CResourceHandler::get()->existsResource(fnameAudio))
-	{
-		logGlobal->error("Error: video %s was not found", fnameAudio.getName());
-		return dat;
-	}
-
-	dataAudio = CResourceHandler::get()->load(fnameAudio);
-
-	static const int BUFFER_SIZE = 4096;
-
-	unsigned char * bufferAudio  = (unsigned char *)av_malloc(BUFFER_SIZE);// will be freed by ffmpeg
-	AVIOContext * contextAudio = avio_alloc_context( bufferAudio, BUFFER_SIZE, 0, (void *)this, lodReadAudio, nullptr, lodSeekAudio);
-
-	AVFormatContext * formatAudio = avformat_alloc_context();
-	formatAudio->pb = contextAudio;
-	// filename is not needed - file was already open and stored in this->data;
-	int avfopen = avformat_open_input(&formatAudio, "dummyFilename", nullptr, nullptr);
-
-	if (avfopen != 0)
-	{
-		return dat;
-	}
-	// Retrieve stream information
-	if (avformat_find_stream_info(formatAudio, nullptr) < 0)
-		return dat;
-
-	// Find the first audio stream
-	int streamAudio = -1;
-	for(ui32 i = 0; i < formatAudio->nb_streams; i++)
-	{
-		if (formatAudio->streams[i]->codecpar->codec_type == AVMEDIA_TYPE_AUDIO)
-		{
-			streamAudio = i;
-			break;
-		}
-	}
-
-	if(streamAudio < 0)
-		return dat;
-
-	const AVCodec *codecAudio = avcodec_find_decoder(formatAudio->streams[streamAudio]->codecpar->codec_id);
-		
-	AVCodecContext *codecContextAudio;
-	if (codecAudio != nullptr)
-		codecContextAudio = avcodec_alloc_context3(codecAudio);
-
-	// Get a pointer to the codec context for the audio stream
-	if (streamAudio > -1)
-	{
-		int ret = avcodec_parameters_to_context(codecContextAudio, formatAudio->streams[streamAudio]->codecpar);
-		if (ret < 0)
-		{
-			//We cannot get codec from parameters
-			avcodec_free_context(&codecContextAudio);
-		}
-	}
-	
-	// Open codec
-	AVFrame *frameAudio;
-	if (codecAudio != nullptr)
-	{
-		if ( avcodec_open2(codecContextAudio, codecAudio, nullptr) < 0 )
-		{
-			// Could not open codec
-			codecAudio = nullptr;
-		}
-		// Allocate audio frame
-		frameAudio = av_frame_alloc();
-	}
-		
-	AVPacket packet;
-
-	std::vector<ui8> samples;
-
-	while (av_read_frame(formatAudio, &packet) >= 0)
-	{
-		if(packet.stream_index == streamAudio)
-		{
-			int rc = avcodec_send_packet(codecContextAudio, &packet);
-			if (rc >= 0)
-				packet.size = 0;
-			rc = avcodec_receive_frame(codecContextAudio, frameAudio);
-			int bytesToRead = (frameAudio->nb_samples * 2 * (formatAudio->streams[streamAudio]->codecpar->bits_per_coded_sample / 8));
-			if (rc >= 0)
-				for (int s = 0; s < bytesToRead; s += sizeof(ui8))
-				{
-					ui8 value;
-					memcpy(&value, &frameAudio->data[0][s], sizeof(ui8));
-					samples.push_back(value);
-				}
-		}
-
-		av_packet_unref(&packet);
-	}
-
-	typedef struct WAV_HEADER {
-		ui8 RIFF[4] = {'R', 'I', 'F', 'F'};
-		ui32 ChunkSize;
-		ui8 WAVE[4] = {'W', 'A', 'V', 'E'};
-		ui8 fmt[4] = {'f', 'm', 't', ' '};
-		ui32 Subchunk1Size = 16;
-		ui16 AudioFormat = 1;
-		ui16 NumOfChan = 2;
-		ui32 SamplesPerSec = 22050;
-		ui32 bytesPerSec = 22050 * 2;
-		ui16 blockAlign = 2;
-		ui16 bitsPerSample = 16;
-		ui8 Subchunk2ID[4] = {'d', 'a', 't', 'a'};
-		ui32 Subchunk2Size;
-	} wav_hdr;
-
-	wav_hdr wav;
-	wav.ChunkSize = samples.size() + sizeof(wav_hdr) - 8;
-  	wav.Subchunk2Size = samples.size() + sizeof(wav_hdr) - 44;
-	wav.SamplesPerSec = formatAudio->streams[streamAudio]->codecpar->sample_rate;
-	wav.bitsPerSample = formatAudio->streams[streamAudio]->codecpar->bits_per_coded_sample;
-	auto wavPtr = reinterpret_cast<ui8*>(&wav);
-
-	dat = std::make_pair(std::make_unique<ui8[]>(samples.size() + sizeof(wav_hdr)), samples.size() + sizeof(wav_hdr));
-	std::copy(wavPtr, wavPtr + sizeof(wav_hdr), dat.first.get());
-	std::copy(samples.begin(), samples.end(), dat.first.get() + sizeof(wav_hdr));
-
-	if (frameAudio)
-		av_frame_free(&frameAudio);
-
-	if (codecAudio)
-	{
-		avcodec_close(codecContextAudio);
-		codecAudio = nullptr;
-	}
-	if (codecContextAudio)
-		avcodec_free_context(&codecContextAudio);
-
-	if (formatAudio)
-		avformat_close_input(&formatAudio);
-
-	if (contextAudio)
-	{
-		av_free(contextAudio);
-		contextAudio = nullptr;
-	}
-
-	return dat;
-}
-
-Point CVideoPlayer::size()
-{
-	if(frame)
-		return Point(frame->width, frame->height);
-	else
-		return Point(0, 0);
-}
-
-// Plays a video. Only works for overlays.
-bool CVideoPlayer::playVideo(int x, int y, bool stopOnKey, bool overlay)
-{
-	// Note: either the windows player or the linux player is
-	// broken. Compensate here until the bug is found.
-	y--;
-
-	pos.x = x;
-	pos.y = y;
-	frameTime = 0.0;
-
-	auto lastTimePoint = boost::chrono::steady_clock::now();
-
-	while(nextFrame())
-	{
-		if(stopOnKey)
-		{
-			GH.input().fetchEvents();
-			if(GH.input().ignoreEventsUntilInput())
-				return false;
-		}
-
-		SDL_Rect rect = CSDL_Ext::toSDL(pos);
-
-		if(overlay)
-		{
-			SDL_RenderFillRect(mainRenderer, &rect);
-		}
-		else
-		{
-			SDL_RenderClear(mainRenderer);
-		}
-		SDL_RenderCopy(mainRenderer, texture, nullptr, &rect);
-		SDL_RenderPresent(mainRenderer);
-
-#if (LIBAVUTIL_VERSION_MAJOR < 58)
-		auto packet_duration = frame->pkt_duration;
-#else
-		auto packet_duration = frame->duration;
-#endif
-		// Framerate delay
-		double targetFrameTimeSeconds = packet_duration * av_q2d(format->streams[stream]->time_base);
-		auto targetFrameTime = boost::chrono::milliseconds(static_cast<int>(1000 * (targetFrameTimeSeconds)));
-
-		auto timePointAfterPresent = boost::chrono::steady_clock::now();
-		auto timeSpentBusy = boost::chrono::duration_cast<boost::chrono::milliseconds>(timePointAfterPresent - lastTimePoint);
-
-		if (targetFrameTime > timeSpentBusy)
-			boost::this_thread::sleep_for(targetFrameTime - timeSpentBusy);
-
-		lastTimePoint = boost::chrono::steady_clock::now();
-	}
-
-	return true;
-}
-
-bool CVideoPlayer::openAndPlayVideo(const VideoPath & name, int x, int y, EVideoType videoType)
-{
-	bool scale;
-	bool stopOnKey;
-	bool overlay;
-
-	switch(videoType)
-	{
-		case EVideoType::INTRO:
-			stopOnKey = true;
-			scale = true;
-			overlay = false;
-			break;
-		case EVideoType::SPELLBOOK:
-		default:
-			stopOnKey = false;
-			scale = false;
-			overlay = true;
-	}
-	open(name, false, true, scale);
-	bool ret = playVideo(x, y,  stopOnKey, overlay);
-	close();
-	return ret;
-}
-
-CVideoPlayer::~CVideoPlayer()
-{
-	close();
-}
-
-#endif
-
diff --color -urN vcmi-1.5.7/client/CVideoHandler.h vcmi/client/CVideoHandler.h
--- vcmi-1.5.7/client/CVideoHandler.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/CVideoHandler.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,131 +0,0 @@
-/*
- * CVideoHandler.h, part of VCMI engine
- *
- * Authors: listed in file AUTHORS in main folder
- *
- * License: GNU General Public License v2.0 or later
- * Full text of license available in license.txt file, in main folder
- *
- */
-#pragma once
-
-#include "../lib/Rect.h"
-#include "../lib/filesystem/ResourcePath.h"
-
-struct SDL_Surface;
-struct SDL_Texture;
-
-enum class EVideoType : ui8
-{
-	INTRO = 0, // use entire window: stopOnKey = true, scale = true, overlay = false
-	SPELLBOOK  // overlay video: stopOnKey = false, scale = false, overlay = true
-};
-
-class IVideoPlayer : boost::noncopyable
-{
-public:
-	virtual bool open(const VideoPath & name, bool scale = false)=0; //true - succes
-	virtual void close()=0;
-	virtual bool nextFrame()=0;
-	virtual void show(int x, int y, SDL_Surface *dst, bool update = true)=0;
-	virtual void redraw(int x, int y, SDL_Surface *dst, bool update = true)=0; //reblits buffer
-	virtual bool wait()=0;
-	virtual int curFrame() const =0;
-	virtual int frameCount() const =0;
-};
-
-class IMainVideoPlayer : public IVideoPlayer
-{
-public:
-	virtual ~IMainVideoPlayer() = default;
-	virtual void update(int x, int y, SDL_Surface *dst, bool forceRedraw, bool update = true, std::function<void()> restart = nullptr){}
-	virtual bool openAndPlayVideo(const VideoPath & name, int x, int y, EVideoType videoType)
-	{
-		return false;
-	}
-	virtual std::pair<std::unique_ptr<ui8 []>, si64> getAudio(const VideoPath & videoToOpen) { return std::make_pair(nullptr, 0); };
-	virtual Point size() { return Point(0, 0); };
-};
-
-class CEmptyVideoPlayer final : public IMainVideoPlayer
-{
-public:
-	int curFrame() const override {return -1;};
-	int frameCount() const override {return -1;};
-	void redraw( int x, int y, SDL_Surface *dst, bool update = true ) override {};
-	void show( int x, int y, SDL_Surface *dst, bool update = true ) override {};
-	bool nextFrame() override {return false;};
-	void close() override {};
-	bool wait() override {return false;};
-	bool open(const VideoPath & name, bool scale = false) override {return false;};
-};
-
-#ifndef DISABLE_VIDEO
-
-struct AVFormatContext;
-struct AVCodecContext;
-struct AVCodec;
-struct AVFrame;
-struct AVIOContext;
-
-VCMI_LIB_NAMESPACE_BEGIN
-class CInputStream;
-VCMI_LIB_NAMESPACE_END
-
-class CVideoPlayer final : public IMainVideoPlayer
-{
-	int stream;					// stream index in video
-	AVFormatContext *format;
-	AVCodecContext *codecContext; // codec context for stream
-	const AVCodec *codec;
-	AVFrame *frame;
-	struct SwsContext *sws;
-
-	AVIOContext * context;
-
-	VideoPath fname;  //name of current video file (empty if idle)
-
-	// Destination. Either overlay or dest.
-
-	SDL_Texture *texture;
-	SDL_Surface *dest;
-	Rect destRect;			// valid when dest is used
-	Rect pos;				// destination on screen
-
-	/// video playback currnet progress, in seconds
-	double frameTime;
-	bool doLoop;				// loop through video
-
-	bool playVideo(int x, int y, bool stopOnKey, bool overlay);
-	bool open(const VideoPath & fname, bool loop, bool useOverlay = false, bool scale = false);
-public:
-	CVideoPlayer();
-	~CVideoPlayer();
-
-	bool init();
-	bool open(const VideoPath & fname, bool scale = false) override;
-	void close() override;
-	bool nextFrame() override;			// display next frame
-
-	void show(int x, int y, SDL_Surface *dst, bool update = true) override; //blit current frame
-	void redraw(int x, int y, SDL_Surface *dst, bool update = true) override; //reblits buffer
-	void update(int x, int y, SDL_Surface *dst, bool forceRedraw, bool update = true, std::function<void()> onVideoRestart = nullptr) override; //moves to next frame if appropriate, and blits it or blits only if redraw parameter is set true
-
-	// Opens video, calls playVideo, closes video; returns playVideo result (if whole video has been played)
-	bool openAndPlayVideo(const VideoPath & name, int x, int y, EVideoType videoType) override;
-
-	std::pair<std::unique_ptr<ui8 []>, si64> getAudio(const VideoPath & videoToOpen) override;
-
-	Point size() override;
-
-	//TODO:
-	bool wait() override {return false;};
-	int curFrame() const override {return -1;};
-	int frameCount() const override {return -1;};
-
-	// public to allow access from ffmpeg IO functions
-	std::unique_ptr<CInputStream> data;
-	std::unique_ptr<CInputStream> dataAudio;
-};
-
-#endif
diff --color -urN vcmi-1.5.7/client/eventsSDL/InputHandler.cpp vcmi/client/eventsSDL/InputHandler.cpp
--- vcmi-1.5.7/client/eventsSDL/InputHandler.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/eventsSDL/InputHandler.cpp	2024-12-19 15:00:22.249121117 +0100
@@ -22,25 +22,28 @@
 #include "../gui/CursorHandler.h"
 #include "../gui/EventDispatcher.h"
 #include "../gui/MouseButton.h"
+#include "../media/IMusicPlayer.h"
+#include "../media/ISoundPlayer.h"
 #include "../CMT.h"
 #include "../CPlayerInterface.h"
 #include "../CGameInfo.h"
-#include "../CMusicHandler.h"
 
 #include "../../lib/CConfigHandler.h"
 
 #include <SDL_events.h>
 #include <SDL_timer.h>
+#include <SDL_clipboard.h>
 
 InputHandler::InputHandler()
-	: mouseHandler(std::make_unique<InputSourceMouse>())
+	: enableMouse(settings["input"]["enableMouse"].Bool())
+	, enableTouch(settings["input"]["enableTouch"].Bool())
+	, enableController(settings["input"]["enableController"].Bool())
+	, currentInputMode(InputMode::KEYBOARD_AND_MOUSE)
+	, mouseHandler(std::make_unique<InputSourceMouse>())
 	, keyboardHandler(std::make_unique<InputSourceKeyboard>())
 	, fingerHandler(std::make_unique<InputSourceTouch>())
 	, textHandler(std::make_unique<InputSourceText>())
 	, gameControllerHandler(std::make_unique<InputSourceGameController>())
-	, enableMouse(settings["input"]["enableMouse"].Bool())
-	, enableTouch(settings["input"]["enableTouch"].Bool())
-	, enableController(settings["input"]["enableController"].Bool())
 {
 }
 
@@ -51,6 +54,7 @@
 	switch (current.type)
 	{
 		case SDL_KEYDOWN:
+			setCurrentInputMode(InputMode::KEYBOARD_AND_MOUSE);
 			keyboardHandler->handleEventKeyDown(current.key);
 			return;
 		case SDL_KEYUP:
@@ -59,11 +63,17 @@
 #ifndef VCMI_EMULATE_TOUCHSCREEN_WITH_MOUSE
 		case SDL_MOUSEMOTION:
 			if (enableMouse)
+			{
+				setCurrentInputMode(InputMode::KEYBOARD_AND_MOUSE);
 				mouseHandler->handleEventMouseMotion(current.motion);
+			}
 			return;
 		case SDL_MOUSEBUTTONDOWN:
 			if (enableMouse)
+			{
+				setCurrentInputMode(InputMode::KEYBOARD_AND_MOUSE);
 				mouseHandler->handleEventMouseButtonDown(current.button);
+			}
 			return;
 		case SDL_MOUSEBUTTONUP:
 			if (enableMouse)
@@ -82,11 +92,17 @@
 			return;
 		case SDL_FINGERMOTION:
 			if (enableTouch)
+			{
+				setCurrentInputMode(InputMode::TOUCH);
 				fingerHandler->handleEventFingerMotion(current.tfinger);
+			}
 			return;
 		case SDL_FINGERDOWN:
 			if (enableTouch)
+			{
+				setCurrentInputMode(InputMode::TOUCH);
 				fingerHandler->handleEventFingerDown(current.tfinger);
+			}
 			return;
 		case SDL_FINGERUP:
 			if (enableTouch)
@@ -94,11 +110,17 @@
 			return;
 		case SDL_CONTROLLERAXISMOTION:
 			if (enableController)
+			{
+				setCurrentInputMode(InputMode::CONTROLLER);
 				gameControllerHandler->handleEventAxisMotion(current.caxis);
+			}
 			return;
 		case SDL_CONTROLLERBUTTONDOWN:
 			if (enableController)
+			{
+				setCurrentInputMode(InputMode::CONTROLLER);
 				gameControllerHandler->handleEventButtonDown(current.cbutton);
+			}
 			return;
 		case SDL_CONTROLLERBUTTONUP:
 			if (enableController)
@@ -107,6 +129,25 @@
 	}
 }
 
+void InputHandler::setCurrentInputMode(InputMode modi)
+{
+	if(currentInputMode != modi)
+	{
+		currentInputMode = modi;
+		GH.events().dispatchInputModeChanged(modi);
+	}
+}
+
+InputMode InputHandler::getCurrentInputMode()
+{
+	return currentInputMode;
+}
+
+void InputHandler::copyToClipBoard(const std::string & text)
+{
+	SDL_SetClipboardText(text.c_str());
+}
+
 std::vector<SDL_Event> InputHandler::acquireEvents()
 {
 	boost::unique_lock<boost::mutex> lock(eventsMutex);
@@ -334,7 +375,8 @@
 
 void InputHandler::hapticFeedback()
 {
-	fingerHandler->hapticFeedback();
+	if(currentInputMode == InputMode::TOUCH)
+		fingerHandler->hapticFeedback();
 }
 
 uint32_t InputHandler::getTicks()
diff --color -urN vcmi-1.5.7/client/eventsSDL/InputHandler.h vcmi/client/eventsSDL/InputHandler.h
--- vcmi-1.5.7/client/eventsSDL/InputHandler.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/eventsSDL/InputHandler.h	2024-12-19 15:00:22.249121117 +0100
@@ -23,6 +23,13 @@
 class InputSourceText;
 class InputSourceGameController;
 
+enum class InputMode
+{
+	KEYBOARD_AND_MOUSE,
+	TOUCH,
+	CONTROLLER
+};
+
 class InputHandler
 {
 	std::vector<SDL_Event> eventsQueue;
@@ -34,6 +41,9 @@
 	const bool enableTouch;
 	const bool enableController;
 
+	InputMode currentInputMode;
+	void setCurrentInputMode(InputMode modi);
+
 	std::vector<SDL_Event> acquireEvents();
 
 	void preprocessEvent(const SDL_Event & event);
@@ -91,4 +101,8 @@
 	bool isKeyboardCmdDown() const;
 	bool isKeyboardCtrlDown() const;
 	bool isKeyboardShiftDown() const;
+
+	InputMode getCurrentInputMode();
+
+	void copyToClipBoard(const std::string & text);
 };
diff --color -urN vcmi-1.5.7/client/eventsSDL/InputSourceGameController.cpp vcmi/client/eventsSDL/InputSourceGameController.cpp
--- vcmi-1.5.7/client/eventsSDL/InputSourceGameController.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/eventsSDL/InputSourceGameController.cpp	2024-12-19 15:00:22.250121158 +0100
@@ -18,6 +18,7 @@
 #include "../gui/CursorHandler.h"
 #include "../gui/EventDispatcher.h"
 #include "../gui/ShortcutHandler.h"
+#include "../render/IScreenHandler.h"
 
 #include "../../lib/CConfigHandler.h"
 
@@ -28,11 +29,6 @@
 }
 
 InputSourceGameController::InputSourceGameController():
-	configTriggerTreshold(settings["input"]["controllerTriggerTreshold"].Float()),
-	configAxisDeadZone(settings["input"]["controllerAxisDeadZone"].Float()),
-	configAxisFullZone(settings["input"]["controllerAxisFullZone"].Float()),
-	configAxisSpeed(settings["input"]["controllerAxisSpeed"].Float()),
-	configAxisScale(settings["input"]["controllerAxisScale"].Float()),
 	cursorAxisValueX(0),
 	cursorAxisValueY(0),
 	cursorPlanDisX(0.0),
@@ -43,7 +39,12 @@
 	scrollAxisValueX(0),
 	scrollAxisValueY(0),
 	scrollPlanDisX(0.0),
-	scrollPlanDisY(0.0)
+	scrollPlanDisY(0.0),
+	configTriggerThreshold(settings["input"]["controllerTriggerThreshold"].Float()),
+	configAxisDeadZone(settings["input"]["controllerAxisDeadZone"].Float()),
+	configAxisFullZone(settings["input"]["controllerAxisFullZone"].Float()),
+	configAxisSpeed(settings["input"]["controllerAxisSpeed"].Float()),
+	configAxisScale(settings["input"]["controllerAxisScale"].Float())
 {
 	tryOpenAllGameControllers();
 }
@@ -127,7 +128,7 @@
 	openGameController(device.which);
 }
 
-double InputSourceGameController::getRealAxisValue(int value)
+double InputSourceGameController::getRealAxisValue(int value) const
 {
 	double ratio = static_cast<double>(value) / SDL_JOYSTICK_AXIS_MAX;
 	double greenZone = configAxisFullZone - configAxisDeadZone;
@@ -142,7 +143,7 @@
 
 void InputSourceGameController::dispatchAxisShortcuts(const std::vector<EShortcut> & shortcutsVector, SDL_GameControllerAxis axisID, int axisValue)
 {
-	if(getRealAxisValue(axisValue) > configTriggerTreshold)
+	if(getRealAxisValue(axisValue) > configTriggerThreshold)
 	{
 		if(!pressedAxes.count(axisID))
 		{
@@ -198,9 +199,10 @@
 	assert(CCS->curh);
 	if(CCS->curh->getShowType() == Cursor::ShowType::HARDWARE)
 	{
+		int scalingFactor = GH.screenHandler().getScalingFactor();
 		const Point & cursorPosition = GH.getCursorPosition();
 		CCS->curh->changeCursor(Cursor::ShowType::SOFTWARE);
-		CCS->curh->cursorMove(cursorPosition.x, cursorPosition.y);
+		CCS->curh->cursorMove(cursorPosition.x * scalingFactor, cursorPosition.y * scalingFactor);
 		GH.input().setCursorPosition(cursorPosition);
 	}
 }
@@ -225,12 +227,13 @@
 		return;
 	const Point & screenSize = GH.screenDimensions();
 	const Point & cursorPosition = GH.getCursorPosition();
+	int scalingFactor = GH.screenHandler().getScalingFactor();
 	int newX = std::min(std::max(cursorPosition.x + deltaX, 0), screenSize.x);
 	int newY = std::min(std::max(cursorPosition.y + deltaY, 0), screenSize.y);
 	Point targetPosition{newX, newY};
 	GH.input().setCursorPosition(targetPosition);
 	if(CCS && CCS->curh)
-		CCS->curh->cursorMove(GH.getCursorPosition().x, GH.getCursorPosition().y);
+		CCS->curh->cursorMove(GH.getCursorPosition().x * scalingFactor, GH.getCursorPosition().y * scalingFactor);
 }
 
 int InputSourceGameController::getMoveDis(float planDis)
@@ -321,7 +324,7 @@
 	}
 }
 
-bool InputSourceGameController::isScrollAxisReleased()
+bool InputSourceGameController::isScrollAxisReleased() const
 {
-	return scrollAxisValueX == 0 && scrollAxisValueY == 0;
+	return vstd::isAlmostZero(scrollAxisValueX) && vstd::isAlmostZero(scrollAxisValueY);
 }
diff --color -urN vcmi-1.5.7/client/eventsSDL/InputSourceGameController.h vcmi/client/eventsSDL/InputSourceGameController.h
--- vcmi-1.5.7/client/eventsSDL/InputSourceGameController.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/eventsSDL/InputSourceGameController.h	2024-12-19 15:00:22.250121158 +0100
@@ -39,7 +39,7 @@
 	double scrollPlanDisX;
 	double scrollPlanDisY;
 
-	const double configTriggerTreshold;
+	const double configTriggerThreshold;
 	const double configAxisDeadZone;
 	const double configAxisFullZone;
 	const double configAxisSpeed;
@@ -47,14 +47,14 @@
 
 	void openGameController(int index);
 	int getJoystickIndex(SDL_GameController * controller);
-	double getRealAxisValue(int value);
+	double getRealAxisValue(int value) const;
 	void dispatchAxisShortcuts(const std::vector<EShortcut> & shortcutsVector, SDL_GameControllerAxis axisID, int axisValue);
 	void tryToConvertCursor();
 	void doCursorMove(int deltaX, int deltaY);
 	int getMoveDis(float planDis);
 	void handleCursorUpdate(int32_t deltaTimeMs);
 	void handleScrollUpdate(int32_t deltaTimeMs);
-	bool isScrollAxisReleased();
+	bool isScrollAxisReleased() const;
 
 public:
 	InputSourceGameController();
diff --color -urN vcmi-1.5.7/client/eventsSDL/InputSourceKeyboard.cpp vcmi/client/eventsSDL/InputSourceKeyboard.cpp
--- vcmi-1.5.7/client/eventsSDL/InputSourceKeyboard.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/eventsSDL/InputSourceKeyboard.cpp	2024-12-19 15:00:22.250121158 +0100
@@ -111,7 +111,7 @@
 	if(key.repeat != 0)
 		return; // ignore periodic event resends
 
-	std::string keyName = SDL_GetKeyName(key.keysym.sym);
+	std::string keyName = getKeyNameWithModifiers(SDL_GetKeyName(key.keysym.sym));
 	logGlobal->trace("keyboard: key '%s' released", keyName);
 
 	if (SDL_IsTextInputActive() == SDL_TRUE)
diff --color -urN vcmi-1.5.7/client/eventsSDL/InputSourceMouse.cpp vcmi/client/eventsSDL/InputSourceMouse.cpp
--- vcmi-1.5.7/client/eventsSDL/InputSourceMouse.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/eventsSDL/InputSourceMouse.cpp	2024-12-19 15:00:22.250121158 +0100
@@ -16,11 +16,14 @@
 #include "../gui/EventDispatcher.h"
 #include "../gui/MouseButton.h"
 
+#include "../render/IScreenHandler.h"
+
 #include "../../lib/Point.h"
 #include "../../lib/CConfigHandler.h"
 
 #include <SDL_events.h>
 #include <SDL_hints.h>
+#include <SDL_version.h>
 
 InputSourceMouse::InputSourceMouse()
 	:mouseToleranceDistance(settings["input"]["mouseToleranceDistance"].Integer())
@@ -30,8 +33,8 @@
 
 void InputSourceMouse::handleEventMouseMotion(const SDL_MouseMotionEvent & motion)
 {
-	Point newPosition(motion.x, motion.y);
-	Point distance(-motion.xrel, -motion.yrel);
+	Point newPosition = Point(motion.x, motion.y) / GH.screenHandler().getScalingFactor();
+	Point distance = Point(-motion.xrel, -motion.yrel) / GH.screenHandler().getScalingFactor();
 
 	mouseButtonsMask = motion.state;
 
@@ -39,13 +42,15 @@
 		GH.events().dispatchGesturePanning(middleClickPosition, newPosition, distance);
 	else if (mouseButtonsMask & SDL_BUTTON(SDL_BUTTON_LEFT))
 		GH.events().dispatchMouseDragged(newPosition, distance);
+	else if (mouseButtonsMask & SDL_BUTTON(SDL_BUTTON_RIGHT))
+		GH.events().dispatchMouseDraggedPopup(newPosition, distance);
 	else
 		GH.input().setCursorPosition(newPosition);
 }
 
 void InputSourceMouse::handleEventMouseButtonDown(const SDL_MouseButtonEvent & button)
 {
-	Point position(button.x, button.y);
+	Point position = Point(button.x, button.y) / GH.screenHandler().getScalingFactor();
 
 	switch(button.button)
 	{
@@ -67,12 +72,18 @@
 
 void InputSourceMouse::handleEventMouseWheel(const SDL_MouseWheelEvent & wheel)
 {
+	//NOTE: while mouseX / mouseY properties are available since 2.26.0, they are not converted into logical coordinates so don't account for resolution scaling
+	// This SDL bug was fixed in 2.30.1: https://github.com/libsdl-org/SDL/issues/9097
+#if SDL_VERSION_ATLEAST(2,30,1)
+	GH.events().dispatchMouseScrolled(Point(wheel.x, wheel.y), Point(wheel.mouseX, wheel.mouseY) / GH.screenHandler().getScalingFactor());
+#else
 	GH.events().dispatchMouseScrolled(Point(wheel.x, wheel.y), GH.getCursorPosition());
+#endif
 }
 
 void InputSourceMouse::handleEventMouseButtonUp(const SDL_MouseButtonEvent & button)
 {
-	Point position(button.x, button.y);
+	Point position = Point(button.x, button.y) / GH.screenHandler().getScalingFactor();
 
 	switch(button.button)
 	{
diff --color -urN vcmi-1.5.7/client/eventsSDL/InputSourceText.cpp vcmi/client/eventsSDL/InputSourceText.cpp
--- vcmi-1.5.7/client/eventsSDL/InputSourceText.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/eventsSDL/InputSourceText.cpp	2024-12-19 15:00:22.250121158 +0100
@@ -11,7 +11,6 @@
 #include "StdInc.h"
 #include "InputSourceText.h"
 
-#include "../CMT.h"
 #include "../gui/CGuiHandler.h"
 #include "../gui/EventDispatcher.h"
 #include "../render/IScreenHandler.h"
diff --color -urN vcmi-1.5.7/client/eventsSDL/InputSourceTouch.cpp vcmi/client/eventsSDL/InputSourceTouch.cpp
--- vcmi-1.5.7/client/eventsSDL/InputSourceTouch.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/eventsSDL/InputSourceTouch.cpp	2024-12-19 15:00:22.250121158 +0100
@@ -14,7 +14,6 @@
 #include "InputHandler.h"
 
 #include "../../lib/CConfigHandler.h"
-#include "../CMT.h"
 #include "../CGameInfo.h"
 #include "../gui/CursorHandler.h"
 #include "../gui/CGuiHandler.h"
@@ -84,16 +83,18 @@
 			break;
 		}
 		case TouchState::TAP_DOWN_SHORT:
+		case TouchState::TAP_DOWN_LONG_AWAIT:
 		{
 			Point distance = convertTouchToMouse(tfinger) - lastTapPosition;
 			if ( std::abs(distance.x) > params.panningSensitivityThreshold || std::abs(distance.y) > params.panningSensitivityThreshold)
 			{
-				state = TouchState::TAP_DOWN_PANNING;
+				state = state == TouchState::TAP_DOWN_SHORT ? TouchState::TAP_DOWN_PANNING : TouchState::TAP_DOWN_PANNING_POPUP;
 				GH.events().dispatchGesturePanningStarted(lastTapPosition);
 			}
 			break;
 		}
 		case TouchState::TAP_DOWN_PANNING:
+		case TouchState::TAP_DOWN_PANNING_POPUP:
 		{
 			emitPanningEvent(tfinger);
 			break;
@@ -104,7 +105,6 @@
 			break;
 		}
 		case TouchState::TAP_DOWN_LONG:
-		case TouchState::TAP_DOWN_LONG_AWAIT:
 		{
 			// no-op
 			break;
@@ -158,8 +158,11 @@
 			CSH->getGlobalLobby().activateInterface();
 			break;
 		}
-		case TouchState::TAP_DOWN_LONG:
 		case TouchState::TAP_DOWN_LONG_AWAIT:
+			lastTapPosition = convertTouchToMouse(tfinger);
+			break;
+		case TouchState::TAP_DOWN_LONG:
+		case TouchState::TAP_DOWN_PANNING_POPUP:
 		{
 			// no-op
 			break;
@@ -206,9 +209,10 @@
 			break;
 		}
 		case TouchState::TAP_DOWN_PANNING:
+		case TouchState::TAP_DOWN_PANNING_POPUP:
 		{
 			GH.events().dispatchGesturePanningEnded(lastTapPosition, convertTouchToMouse(tfinger));
-			state = TouchState::IDLE;
+			state = state == TouchState::TAP_DOWN_PANNING ? TouchState::IDLE : TouchState::TAP_DOWN_LONG_AWAIT;
 			break;
 		}
 		case TouchState::TAP_DOWN_DOUBLE:
diff --color -urN vcmi-1.5.7/client/eventsSDL/InputSourceTouch.h vcmi/client/eventsSDL/InputSourceTouch.h
--- vcmi-1.5.7/client/eventsSDL/InputSourceTouch.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/eventsSDL/InputSourceTouch.h	2024-12-19 15:00:22.251121200 +0100
@@ -45,6 +45,12 @@
 	// UP -> transition to IDLE
 	TAP_DOWN_PANNING,
 
+	// single finger is moving across screen
+	// DOWN -> ignored
+	// MOTION -> emit panning event
+	// UP -> transition to TAP_DOWN_LONG_AWAIT
+	TAP_DOWN_PANNING_POPUP,
+
 	// two fingers are touching the screen
 	// DOWN -> ??? how to handle 3rd finger? Ignore?
 	// MOTION -> emit pinch event
@@ -59,7 +65,7 @@
 
 	// right-click popup is active, waiting for new tap to hide popup
 	// DOWN -> ignored
-	// MOTION -> ignored
+	// MOTION -> transition to TAP_DOWN_PANNING_POPUP
 	// UP -> transition to IDLE, generate closePopup() event
 	TAP_DOWN_LONG_AWAIT,
 };
@@ -79,7 +85,7 @@
 	uint32_t doubleTouchToleranceDistance = 50;
 
 	/// moving finger for distance larger than specified will be qualified as panning gesture instead of long press
-	uint32_t panningSensitivityThreshold = 10;
+	uint32_t panningSensitivityThreshold = 15;
 
 	/// gesture will be qualified as pinch if distance between fingers is at least specified here
 	uint32_t pinchSensitivityThreshold = 10;
diff --color -urN vcmi-1.5.7/client/GameChatHandler.cpp vcmi/client/GameChatHandler.cpp
--- vcmi-1.5.7/client/GameChatHandler.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/GameChatHandler.cpp	2024-12-19 15:00:22.240120745 +0100
@@ -21,12 +21,11 @@
 #include "../CCallback.h"
 
 #include "../lib/networkPacks/PacksForLobby.h"
-#include "../lib/TextOperations.h"
 #include "../lib/mapObjects/CArmedInstance.h"
 #include "../lib/CConfigHandler.h"
-#include "../lib/MetaString.h"
 #include "../lib/VCMI_Lib.h"
-#include "../lib/CGeneralTextHandler.h"
+#include "../lib/texts/CGeneralTextHandler.h"
+#include "../lib/texts/TextOperations.h"
 
 const std::vector<GameChatMessage> & GameChatHandler::getChatHistory() const
 {
@@ -94,7 +93,7 @@
 		playerName = LOCPLINT->cb->getStartInfo()->playerInfos.at(sender).name;
 
 	if (sender.isSpectator())
-		playerName = "Spectator"; // FIXME: translate? Provide nickname somewhere?
+		playerName = VLC->generaltexth->translate("vcmi.lobby.login.spectator");
 
 	chatHistory.push_back({playerName, messageText, timeFormatted});
 
diff --color -urN vcmi-1.5.7/client/globalLobby/GlobalLobbyClient.cpp vcmi/client/globalLobby/GlobalLobbyClient.cpp
--- vcmi-1.5.7/client/globalLobby/GlobalLobbyClient.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/globalLobby/GlobalLobbyClient.cpp	2024-12-19 15:00:22.251121200 +0100
@@ -17,18 +17,18 @@
 #include "GlobalLobbyWindow.h"
 
 #include "../CGameInfo.h"
-#include "../CMusicHandler.h"
 #include "../CServerHandler.h"
 #include "../gui/CGuiHandler.h"
 #include "../gui/WindowHandler.h"
 #include "../mainmenu/CMainMenu.h"
+#include "../media/ISoundPlayer.h"
 #include "../windows/InfoWindows.h"
 
 #include "../../lib/CConfigHandler.h"
-#include "../../lib/MetaString.h"
 #include "../../lib/json/JsonUtils.h"
-#include "../../lib/TextOperations.h"
-#include "../../lib/CGeneralTextHandler.h"
+#include "../../lib/texts/CGeneralTextHandler.h"
+#include "../../lib/texts/MetaString.h"
+#include "../../lib/texts/TextOperations.h"
 
 GlobalLobbyClient::GlobalLobbyClient()
 {
@@ -43,7 +43,7 @@
 {
 	boost::mutex::scoped_lock interfaceLock(GH.interfaceMutex);
 
-	JsonNode json(message.data(), message.size());
+	JsonNode json(message.data(), message.size(), "<lobby network packet>");
 
 	if(json["type"].String() == "accountCreated")
 		return receiveAccountCreated(json);
diff --color -urN vcmi-1.5.7/client/globalLobby/GlobalLobbyInviteWindow.cpp vcmi/client/globalLobby/GlobalLobbyInviteWindow.cpp
--- vcmi-1.5.7/client/globalLobby/GlobalLobbyInviteWindow.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/globalLobby/GlobalLobbyInviteWindow.cpp	2024-12-19 15:00:22.251121200 +0100
@@ -22,8 +22,8 @@
 #include "../widgets/ObjectLists.h"
 #include "../widgets/TextControls.h"
 
-#include "../../lib/MetaString.h"
 #include "../../lib/json/JsonNode.h"
+#include "../../lib/texts/MetaString.h"
 
 GlobalLobbyInviteAccountCard::GlobalLobbyInviteAccountCard(const GlobalLobbyAccount & accountDescription)
 	: accountID(accountDescription.accountID)
@@ -47,7 +47,7 @@
 		}
 	}
 
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 	if (thisAccountInvited)
 		backgroundOverlay = std::make_shared<TransparentFilledRectangle>(Rect(0, 0, pos.w, pos.h), ColorRGBA(0, 0, 0, 128), Colors::WHITE, 1);
 	else
@@ -73,13 +73,13 @@
 GlobalLobbyInviteWindow::GlobalLobbyInviteWindow()
 	: CWindowObject(BORDERED)
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 
 	pos.w = 236;
 	pos.h = 420;
 
-	filledBackground = std::make_shared<FilledTexturePlayerColored>(ImagePath::builtin("DiBoxBck"), Rect(0, 0, pos.w, pos.h));
-	filledBackground->playerColored(PlayerColor(1));
+	filledBackground = std::make_shared<FilledTexturePlayerColored>(Rect(0, 0, pos.w, pos.h));
+	filledBackground->setPlayerColor(PlayerColor(1));
 	labelTitle = std::make_shared<CLabel>(
 		pos.w / 2, 20, FONT_BIG, ETextAlignment::CENTER, Colors::YELLOW, MetaString::createFromTextID("vcmi.lobby.invite.header").toString()
 	);
diff --color -urN vcmi-1.5.7/client/globalLobby/GlobalLobbyLoginWindow.cpp vcmi/client/globalLobby/GlobalLobbyLoginWindow.cpp
--- vcmi-1.5.7/client/globalLobby/GlobalLobbyLoginWindow.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/globalLobby/GlobalLobbyLoginWindow.cpp	2024-12-19 15:00:22.252121241 +0100
@@ -25,13 +25,13 @@
 #include "../widgets/TextControls.h"
 
 #include "../../lib/CConfigHandler.h"
-#include "../../lib/CGeneralTextHandler.h"
-#include "../../lib/MetaString.h"
+#include "../../lib/texts/CGeneralTextHandler.h"
+#include "../../lib/texts/MetaString.h"
 
 GlobalLobbyLoginWindow::GlobalLobbyLoginWindow()
 	: CWindowObject(BORDERED)
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 
 	pos.w = 284;
 	pos.h = 220;
@@ -40,7 +40,7 @@
 	loginAs.appendTextID("vcmi.lobby.login.as");
 	loginAs.replaceRawString(CSH->getGlobalLobby().getAccountDisplayName());
 
-	filledBackground = std::make_shared<FilledTexturePlayerColored>(ImagePath::builtin("DiBoxBck"), Rect(0, 0, pos.w, pos.h));
+	filledBackground = std::make_shared<FilledTexturePlayerColored>(Rect(0, 0, pos.w, pos.h));
 	labelTitle = std::make_shared<CLabel>( pos.w / 2, 20, FONT_BIG, ETextAlignment::CENTER, Colors::YELLOW, CGI->generaltexth->translate("vcmi.lobby.login.title"));
 	labelUsernameTitle = std::make_shared<CLabel>( 10, 65, FONT_MEDIUM, ETextAlignment::TOPLEFT, Colors::WHITE, CGI->generaltexth->translate("vcmi.lobby.login.username"));
 	labelUsername = std::make_shared<CLabel>( 10, 65, FONT_MEDIUM, ETextAlignment::TOPLEFT, Colors::WHITE, loginAs.toString(), 265);
@@ -65,7 +65,7 @@
 	{
 		buttonLogin->block(true);
 		toggleMode->setSelected(0);
-		onLoginModeChanged(0); // call it manually to disable widgets - toggleMode will not emit this call if this is currenly selected option
+		onLoginModeChanged(0); // call it manually to disable widgets - toggleMode will not emit this call if this is currently selected option
 	}
 	else
 	{
@@ -73,7 +73,7 @@
 		onLoginModeChanged(1);
 	}
 
-	filledBackground->playerColored(PlayerColor(1));
+	filledBackground->setPlayerColor(PlayerColor(1));
 	inputUsername->setCallback([this](const std::string & text)
 	{
 		this->buttonLogin->block(text.empty());
diff --color -urN vcmi-1.5.7/client/globalLobby/GlobalLobbyRoomWindow.cpp vcmi/client/globalLobby/GlobalLobbyRoomWindow.cpp
--- vcmi-1.5.7/client/globalLobby/GlobalLobbyRoomWindow.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/globalLobby/GlobalLobbyRoomWindow.cpp	2024-12-19 15:00:22.252121241 +0100
@@ -26,14 +26,14 @@
 #include "../widgets/GraphicalPrimitiveCanvas.h"
 #include "../widgets/ObjectLists.h"
 
-#include "../../lib/CGeneralTextHandler.h"
-#include "../../lib/MetaString.h"
 #include "../../lib/modding/CModHandler.h"
-#include "../../lib/modding/CModInfo.h"
+#include "../../lib/modding/ModDescription.h"
+#include "../../lib/texts/CGeneralTextHandler.h"
+#include "../../lib/texts/MetaString.h"
 
 GlobalLobbyRoomAccountCard::GlobalLobbyRoomAccountCard(const GlobalLobbyAccount & accountDescription)
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 	pos.w = 130;
 	pos.h = 40;
 	backgroundOverlay = std::make_shared<TransparentFilledRectangle>(Rect(0, 0, pos.w, pos.h), ColorRGBA(0, 0, 0, 128), ColorRGBA(64, 64, 64, 64), 1);
@@ -51,7 +51,7 @@
 		{ ModVerificationStatus::FULL_MATCH, "compatible" }
 	};
 
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 	pos.w = 200;
 	pos.h = 40;
 	backgroundOverlay = std::make_shared<TransparentFilledRectangle>(Rect(0, 0, pos.w, pos.h), ColorRGBA(0, 0, 0, 128), ColorRGBA(64, 64, 64, 64), 1);
@@ -66,7 +66,7 @@
 	labelStatus = std::make_shared<CLabel>(5, 30, FONT_SMALL, ETextAlignment::CENTERLEFT, statusColor, CGI->generaltexth->translate("vcmi.lobby.mod.state." + statusToString.at(modInfo.status)));
 }
 
-static const std::string getJoinRoomErrorMessage(const GlobalLobbyRoom & roomDescription, const std::vector<GlobalLobbyRoomModInfo> & modVerificationList)
+static std::string getJoinRoomErrorMessage(const GlobalLobbyRoom & roomDescription, const std::vector<GlobalLobbyRoomModInfo> & modVerificationList)
 {
 	bool publicRoom = roomDescription.statusID == "public";
 	bool privateRoom = roomDescription.statusID == "private";
@@ -114,10 +114,10 @@
 
 GlobalLobbyRoomWindow::GlobalLobbyRoomWindow(GlobalLobbyWindow * window, const std::string & roomUUID)
 	: CWindowObject(BORDERED)
-	, roomUUID(roomUUID)
 	, window(window)
+	, roomUUID(roomUUID)
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 
 	pos.w = 400;
 	pos.h = 400;
@@ -128,14 +128,14 @@
 		GlobalLobbyRoomModInfo modInfo;
 		modInfo.status = modEntry.second;
 		if (modEntry.second == ModVerificationStatus::EXCESSIVE)
-			modInfo.version = CGI->modh->getModInfo(modEntry.first).getVerificationInfo().version.toString();
+			modInfo.version = CGI->modh->getModInfo(modEntry.first).getVersion().toString();
 		else
 			modInfo.version = roomDescription.modList.at(modEntry.first).version.toString();
 
 		if (modEntry.second == ModVerificationStatus::NOT_INSTALLED)
 			modInfo.modName = roomDescription.modList.at(modEntry.first).name;
 		else
-			modInfo.modName = CGI->modh->getModInfo(modEntry.first).getVerificationInfo().name;
+			modInfo.modName = CGI->modh->getModInfo(modEntry.first).getName();
 
 		modVerificationList.push_back(modInfo);
 	}
@@ -152,7 +152,7 @@
 	subtitleText.replaceRawString(roomDescription.description);
 	subtitleText.replaceRawString(roomDescription.hostAccountDisplayName);
 
-	filledBackground = std::make_shared<FilledTexturePlayerColored>(ImagePath::builtin("DiBoxBck"), Rect(0, 0, pos.w, pos.h));
+	filledBackground = std::make_shared<FilledTexturePlayerColored>(Rect(0, 0, pos.w, pos.h));
 	labelTitle = std::make_shared<CLabel>( pos.w / 2, 20, FONT_BIG, ETextAlignment::CENTER, Colors::YELLOW, MetaString::createFromTextID("vcmi.lobby.preview.title").toString());
 	labelSubtitle = std::make_shared<CLabel>( pos.w / 2, 40, FONT_MEDIUM, ETextAlignment::CENTER, Colors::YELLOW, subtitleText.toString(), 400);
 
@@ -200,7 +200,7 @@
 	modListTitle = std::make_shared<CLabel>( 182, 59, FONT_SMALL, ETextAlignment::CENTERLEFT, Colors::YELLOW, MetaString::createFromTextID("vcmi.lobby.preview.mods").toString());
 
 	buttonJoin->block(!errorMessage.empty());
-	filledBackground->playerColored(PlayerColor(1));
+	filledBackground->setPlayerColor(PlayerColor(1));
 	center();
 }
 
diff --color -urN vcmi-1.5.7/client/globalLobby/GlobalLobbyServerSetup.cpp vcmi/client/globalLobby/GlobalLobbyServerSetup.cpp
--- vcmi-1.5.7/client/globalLobby/GlobalLobbyServerSetup.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/globalLobby/GlobalLobbyServerSetup.cpp	2024-12-19 15:00:22.252121241 +0100
@@ -23,18 +23,18 @@
 #include "../widgets/TextControls.h"
 
 #include "../../lib/CConfigHandler.h"
-#include "../../lib/CGeneralTextHandler.h"
-#include "../../lib/MetaString.h"
+#include "../../lib/texts/CGeneralTextHandler.h"
+#include "../../lib/texts/MetaString.h"
 
 GlobalLobbyServerSetup::GlobalLobbyServerSetup()
 	: CWindowObject(BORDERED)
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 
 	pos.w = 284;
 	pos.h = 340;
 
-	filledBackground = std::make_shared<FilledTexturePlayerColored>(ImagePath::builtin("DiBoxBck"), Rect(0, 0, pos.w, pos.h));
+	filledBackground = std::make_shared<FilledTexturePlayerColored>(Rect(0, 0, pos.w, pos.h));
 	labelTitle = std::make_shared<CLabel>( pos.w / 2, 20, FONT_BIG, ETextAlignment::CENTER, Colors::YELLOW, CGI->generaltexth->translate("vcmi.lobby.room.create"));
 	labelPlayerLimit = std::make_shared<CLabel>( pos.w / 2, 48, FONT_MEDIUM, ETextAlignment::CENTER, Colors::YELLOW, CGI->generaltexth->translate("vcmi.lobby.room.players.limit"));
 	labelRoomType = std::make_shared<CLabel>( pos.w / 2, 108, FONT_MEDIUM, ETextAlignment::CENTER, Colors::YELLOW, CGI->generaltexth->translate("vcmi.lobby.room.type"));
@@ -78,7 +78,7 @@
 	buttonCreate = std::make_shared<CButton>(Point(10, 300), AnimationPath::builtin("MuBchck"), CButton::tooltip(), [this](){ onCreate(); }, EShortcut::GLOBAL_ACCEPT);
 	buttonClose = std::make_shared<CButton>(Point(210, 300), AnimationPath::builtin("MuBcanc"), CButton::tooltip(), [this](){ onClose(); }, EShortcut::GLOBAL_CANCEL);
 
-	filledBackground->playerColored(PlayerColor(1));
+	filledBackground->setPlayerColor(PlayerColor(1));
 
 	updateDescription();
 	center();
diff --color -urN vcmi-1.5.7/client/globalLobby/GlobalLobbyWidget.cpp vcmi/client/globalLobby/GlobalLobbyWidget.cpp
--- vcmi-1.5.7/client/globalLobby/GlobalLobbyWidget.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/globalLobby/GlobalLobbyWidget.cpp	2024-12-19 15:00:22.252121241 +0100
@@ -16,10 +16,10 @@
 #include "GlobalLobbyRoomWindow.h"
 
 #include "../CGameInfo.h"
-#include "../CMusicHandler.h"
 #include "../CServerHandler.h"
 #include "../gui/CGuiHandler.h"
 #include "../gui/WindowHandler.h"
+#include "../media/ISoundPlayer.h"
 #include "../render/Colors.h"
 #include "../widgets/Buttons.h"
 #include "../widgets/CTextInput.h"
@@ -30,8 +30,8 @@
 #include "../widgets/TextControls.h"
 
 #include "../../lib/CConfigHandler.h"
-#include "../../lib/Languages.h"
-#include "../../lib/MetaString.h"
+#include "../../lib/texts/Languages.h"
+#include "../../lib/texts/MetaString.h"
 
 GlobalLobbyWidget::GlobalLobbyWidget(GlobalLobbyWindow * window)
 	: window(window)
@@ -187,7 +187,7 @@
 	pos.h = dimensions.y;
 	addUsedEvents(LCLICK);
 
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 
 	if (window->isChannelOpen(channelType, channelName))
 		backgroundOverlay = std::make_shared<TransparentFilledRectangle>(Rect(0, 0, pos.w, pos.h), ColorRGBA(0, 0, 0, 128), Colors::YELLOW, 2);
@@ -206,16 +206,16 @@
 GlobalLobbyAccountCard::GlobalLobbyAccountCard(GlobalLobbyWindow * window, const GlobalLobbyAccount & accountDescription)
 	: GlobalLobbyChannelCardBase(window, Point(130, 40), "player", accountDescription.accountID, accountDescription.displayName)
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 	labelName = std::make_shared<CLabel>(5, 10, FONT_SMALL, ETextAlignment::CENTERLEFT, Colors::WHITE, accountDescription.displayName, 120);
 	labelStatus = std::make_shared<CLabel>(5, 30, FONT_SMALL, ETextAlignment::CENTERLEFT, Colors::YELLOW, accountDescription.status);
 }
 
 GlobalLobbyRoomCard::GlobalLobbyRoomCard(GlobalLobbyWindow * window, const GlobalLobbyRoom & roomDescription)
-	: roomUUID(roomDescription.gameRoomID)
-	, window(window)
+	: window(window)
+	, roomUUID(roomDescription.gameRoomID)
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 	addUsedEvents(LCLICK);
 
 	bool hasInvite = CSH->getGlobalLobby().isInvitedToRoom(roomDescription.gameRoomID);
@@ -253,14 +253,14 @@
 GlobalLobbyChannelCard::GlobalLobbyChannelCard(GlobalLobbyWindow * window, const std::string & channelName)
 	: GlobalLobbyChannelCardBase(window, Point(146, 40), "global", channelName, Languages::getLanguageOptions(channelName).nameNative)
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 	labelName = std::make_shared<CLabel>(5, 20, FONT_SMALL, ETextAlignment::CENTERLEFT, Colors::WHITE, Languages::getLanguageOptions(channelName).nameNative);
 }
 
 GlobalLobbyMatchCard::GlobalLobbyMatchCard(GlobalLobbyWindow * window, const GlobalLobbyRoom & matchDescription)
 	: GlobalLobbyChannelCardBase(window, Point(130, 40), "match", matchDescription.gameRoomID, matchDescription.startDateFormatted)
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 	labelMatchDate = std::make_shared<CLabel>(5, 10, FONT_SMALL, ETextAlignment::CENTERLEFT, Colors::WHITE, matchDescription.startDateFormatted);
 
 	MetaString opponentDescription;
diff --color -urN vcmi-1.5.7/client/globalLobby/GlobalLobbyWindow.cpp vcmi/client/globalLobby/GlobalLobbyWindow.cpp
--- vcmi-1.5.7/client/globalLobby/GlobalLobbyWindow.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/globalLobby/GlobalLobbyWindow.cpp	2024-12-19 15:00:22.252121241 +0100
@@ -23,14 +23,14 @@
 #include "../widgets/ObjectLists.h"
 #include "../widgets/TextControls.h"
 
-#include "../../lib/Languages.h"
-#include "../../lib/MetaString.h"
-#include "../../lib/TextOperations.h"
+#include "../../lib/texts/Languages.h"
+#include "../../lib/texts/MetaString.h"
+#include "../../lib/texts/TextOperations.h"
 
 GlobalLobbyWindow::GlobalLobbyWindow()
 	: CWindowObject(BORDERED)
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 	widget = std::make_shared<GlobalLobbyWidget>(this);
 	pos = widget->pos;
 	center();
diff --color -urN vcmi-1.5.7/client/gui/CGuiHandler.cpp vcmi/client/gui/CGuiHandler.cpp
--- vcmi-1.5.7/client/gui/CGuiHandler.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/gui/CGuiHandler.cpp	2024-12-19 15:00:22.253121282 +0100
@@ -39,33 +39,17 @@
 
 static thread_local bool inGuiThread = false;
 
-SObjectConstruction::SObjectConstruction(CIntObject *obj)
-:myObj(obj)
+ObjectConstruction::ObjectConstruction(CIntObject *obj)
 {
 	GH.createdObj.push_front(obj);
 	GH.captureChildren = true;
 }
 
-SObjectConstruction::~SObjectConstruction()
+ObjectConstruction::~ObjectConstruction()
 {
-	assert(GH.createdObj.size());
-	assert(GH.createdObj.front() == myObj);
+	assert(!GH.createdObj.empty());
 	GH.createdObj.pop_front();
-	GH.captureChildren = GH.createdObj.size();
-}
-
-SSetCaptureState::SSetCaptureState(bool allow, ui8 actions)
-{
-	previousCapture = GH.captureChildren;
-	GH.captureChildren = false;
-	prevActions = GH.defActionsDef;
-	GH.defActionsDef = actions;
-}
-
-SSetCaptureState::~SSetCaptureState()
-{
-	GH.captureChildren = previousCapture;
-	GH.defActionsDef = prevActions;
+	GH.captureChildren = !GH.createdObj.empty();
 }
 
 void CGuiHandler::init()
@@ -139,8 +123,7 @@
 }
 
 CGuiHandler::CGuiHandler()
-	: defActionsDef(0)
-	, captureChildren(false)
+	: captureChildren(false)
 	, curInt(nullptr)
 	, fakeStatusBar(std::make_shared<EmptyStatusBar>())
 {
@@ -193,22 +176,24 @@
 
 Point CGuiHandler::screenDimensions() const
 {
-	return Point(screen->w, screen->h);
+	return screenHandlerInstance->getLogicalResolution();
 }
 
 void CGuiHandler::drawFPSCounter()
 {
-	int x = 7;
-	int y = screen->h-20;
-	int width3digitFPSIncludingPadding = 48;
-	int heightFPSTextIncludingPadding = 11;
+	int scaling = screenHandlerInstance->getScalingFactor();
+	int x = 7 * scaling;
+	int y = screen->h-20 * scaling;
+	int width3digitFPSIncludingPadding = 48 * scaling;
+	int heightFPSTextIncludingPadding = 11 * scaling;
 	SDL_Rect overlay = { x, y, width3digitFPSIncludingPadding, heightFPSTextIncludingPadding};
 	uint32_t black = SDL_MapRGB(screen->format, 10, 10, 10);
 	SDL_FillRect(screen, &overlay, black);
 
 	std::string fps = std::to_string(framerate().getFramerate())+" FPS";
 
-	graphics->fonts[FONT_SMALL]->renderTextLeft(screen, fps, Colors::WHITE, Point(8, screen->h-22));
+	const auto & font = GH.renderHandler().loadFont(FONT_SMALL);
+	font->renderTextLeft(screen, fps, Colors::WHITE, Point(8 * scaling, screen->h-22 * scaling));
 }
 
 bool CGuiHandler::amIGuiThread()
@@ -265,8 +250,8 @@
 void CGuiHandler::onScreenResize(bool resolutionChanged)
 {
 	if(resolutionChanged)
-	{
 		screenHandler().onScreenResize();
-	}
+
 	windows().onScreenResize();
+	CCS->curh->onScreenResize();
 }
diff --color -urN vcmi-1.5.7/client/gui/CGuiHandler.h vcmi/client/gui/CGuiHandler.h
--- vcmi-1.5.7/client/gui/CGuiHandler.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/gui/CGuiHandler.h	2024-12-19 15:00:22.253121282 +0100
@@ -89,7 +89,6 @@
 
 	IUpdateable *curInt;
 
-	ui8 defActionsDef; //default auto actions
 	bool captureChildren; //all newly created objects will get their parents from stack and will be added to parents children list
 	std::list<CIntObject *> createdObj; //stack of objs being created
 
@@ -113,25 +112,3 @@
 };
 
 extern CGuiHandler GH; //global gui handler
-
-struct SObjectConstruction
-{
-	CIntObject *myObj;
-	SObjectConstruction(CIntObject *obj);
-	~SObjectConstruction();
-};
-
-struct SSetCaptureState
-{
-	bool previousCapture;
-	ui8 prevActions;
-	SSetCaptureState(bool allow, ui8 actions);
-	~SSetCaptureState();
-};
-
-#define OBJ_CONSTRUCTION SObjectConstruction obj__i(this)
-#define OBJ_CONSTRUCTION_TARGETED(obj) SObjectConstruction obj__i(obj)
-#define OBJECT_CONSTRUCTION_CAPTURING(actions) defActions = actions; SSetCaptureState obj__i1(true, actions); SObjectConstruction obj__i(this)
-#define OBJECT_CONSTRUCTION_CUSTOM_CAPTURING(actions) SSetCaptureState obj__i1(true, actions); SObjectConstruction obj__i(this)
-
-#define OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE defActions = 255 - DISPOSE; SSetCaptureState obj__i1(true, 255 - DISPOSE); SObjectConstruction obj__i(this)
diff --color -urN vcmi-1.5.7/client/gui/CIntObject.cpp vcmi/client/gui/CIntObject.cpp
--- vcmi-1.5.7/client/gui/CIntObject.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/gui/CIntObject.cpp	2024-12-19 15:00:22.253121282 +0100
@@ -24,8 +24,7 @@
 	redrawParent(false),
 	inputEnabled(true),
 	used(used_),
-	recActions(GH.defActionsDef),
-	defActions(GH.defActionsDef),
+	recActions(ALL_ACTIONS),
 	pos(pos_, Point())
 {
 	if(GH.captureChildren)
@@ -38,12 +37,7 @@
 		deactivate();
 
 	while(!children.empty())
-	{
-		if((defActions & DISPOSE) && (children.front()->recActions & DISPOSE))
-			delete children.front();
-		else
-			removeChild(children.front());
-	}
+		removeChild(children.front());
 
 	if(parent_m)
 		parent_m->removeChild(this);
@@ -51,20 +45,16 @@
 
 void CIntObject::show(Canvas & to)
 {
-	if(defActions & UPDATE)
-		for(auto & elem : children)
-			if(elem->recActions & UPDATE)
-				elem->show(to);
+	for(auto & elem : children)
+		if(elem->recActions & UPDATE)
+			elem->show(to);
 }
 
 void CIntObject::showAll(Canvas & to)
 {
-	if(defActions & SHOWALL)
-	{
-		for(auto & elem : children)
-			if(elem->recActions & SHOWALL)
-				elem->showAll(to);
-	}
+	for(auto & elem : children)
+		if(elem->recActions & SHOWALL)
+			elem->showAll(to);
 }
 
 void CIntObject::activate()
@@ -79,10 +69,9 @@
 
 	assert(isActive());
 
-	if(defActions & ACTIVATE)
-		for(auto & elem : children)
-			if(elem->recActions & ACTIVATE)
-				elem->activate();
+	for(auto & elem : children)
+		if(elem->recActions & ACTIVATE)
+			elem->activate();
 }
 
 void CIntObject::deactivate()
@@ -94,10 +83,9 @@
 
 	assert(!isActive());
 
-	if(defActions & DEACTIVATE)
-		for(auto & elem : children)
-			if(elem->recActions & DEACTIVATE)
-				elem->deactivate();
+	for(auto & elem : children)
+		if(elem->recActions & DEACTIVATE)
+			elem->deactivate();
 }
 
 void CIntObject::addUsedEvents(ui16 newActions)
@@ -119,7 +107,7 @@
 	if(isActive())
 		deactivate();
 
-	recActions = DISPOSE;
+	recActions = NO_ACTIONS;
 }
 
 void CIntObject::enable()
@@ -130,7 +118,7 @@
 		redraw();
 	}
 
-	recActions = 255;
+	recActions = ALL_ACTIONS;
 }
 
 void CIntObject::setEnabled(bool on)
@@ -169,11 +157,16 @@
 
 void CIntObject::fitToScreen(int borderWidth, bool propagate)
 {
+	fitToRect(Rect(Point(0, 0), GH.screenDimensions()), borderWidth, propagate);
+}
+
+void CIntObject::fitToRect(Rect rect, int borderWidth, bool propagate)
+{
 	Point newPos = pos.topLeft();
-	vstd::amax(newPos.x, borderWidth);
-	vstd::amax(newPos.y, borderWidth);
-	vstd::amin(newPos.x, GH.screenDimensions().x - borderWidth - pos.w);
-	vstd::amin(newPos.y, GH.screenDimensions().y - borderWidth - pos.h);
+	vstd::amax(newPos.x, rect.x + borderWidth);
+	vstd::amax(newPos.y, rect.y + borderWidth);
+	vstd::amin(newPos.x, rect.x + rect.w - borderWidth - pos.w);
+	vstd::amin(newPos.y, rect.y + rect.h - borderWidth - pos.h);
 	if (newPos != pos.topLeft())
 		moveTo(newPos, propagate);
 }
@@ -245,12 +238,12 @@
 		}
 		else
 		{
-			Canvas buffer = Canvas::createFromSurface(screenBuf);
+			Canvas buffer = Canvas::createFromSurface(screenBuf, CanvasScalingPolicy::AUTO);
 
 			showAll(buffer);
 			if(screenBuf != screen)
 			{
-				Canvas screenBuffer = Canvas::createFromSurface(screen);
+				Canvas screenBuffer = Canvas::createFromSurface(screen, CanvasScalingPolicy::AUTO);
 
 				showAll(screenBuffer);
 			}
@@ -258,6 +251,15 @@
 	}
 }
 
+void CIntObject::moveChildForeground(const CIntObject * childToMove)
+{
+	for(auto child = children.begin(); child != children.end(); child++)
+		if(*child == childToMove && child != children.end())
+		{
+			std::rotate(child, child + 1, children.end());
+		}
+}
+
 bool CIntObject::receiveEvent(const Point & position, int eventType) const
 {
 	return pos.isInside(position);
@@ -341,6 +343,6 @@
 void WindowBase::close()
 {
 	if(!GH.windows().isTopWindow(this))
-		logGlobal->error("Only top interface must be closed");
+		throw std::runtime_error("Only top interface can be closed");
 	GH.windows().popWindows(1);
 }
diff --color -urN vcmi-1.5.7/client/gui/CIntObject.h vcmi/client/gui/CIntObject.h
--- vcmi-1.5.7/client/gui/CIntObject.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/gui/CIntObject.h	2024-12-19 15:00:22.253121282 +0100
@@ -73,13 +73,12 @@
 	void addUsedEvents(ui16 newActions);
 	void removeUsedEvents(ui16 newActions);
 
-	enum {ACTIVATE=1, DEACTIVATE=2, UPDATE=4, SHOWALL=8, DISPOSE=16, SHARE_POS=32};
-	ui8 defActions; //which calls will be tried to be redirected to children
+	enum {NO_ACTIONS = 0, ACTIVATE=1, DEACTIVATE=2, UPDATE=4, SHOWALL=8, SHARE_POS=16, ALL_ACTIONS=31};
 	ui8 recActions; //which calls we allow to receive from parent
 
 	/// deactivates if needed, blocks all automatic activity, allows only disposal
 	void disable();
-	/// activates if needed, all activity enabled (Warning: may not be symetric with disable if recActions was limited!)
+	/// activates if needed, all activity enabled (Warning: may not be symmetric with disable if recActions was limited!)
 	void enable();
 	/// deactivates or activates UI element based on flag
 	void setEnabled(bool on);
@@ -102,6 +101,8 @@
 	void showAll(Canvas & to) override;
 	//request complete redraw of this object
 	void redraw() override;
+	// Move child object to foreground
+	void moveChildForeground(const CIntObject * childToMove);
 
 	/// returns true if this element is a popup window
 	/// called only for windows
@@ -121,6 +122,7 @@
 	const Rect & center(const Point &p, bool propagate = true);  //moves object so that point p will be in its center
 	const Rect & center(bool propagate = true); //centers when pos.w and pos.h are set, returns new position
 	void fitToScreen(int borderWidth, bool propagate = true); //moves window to fit into screen
+	void fitToRect(Rect rect, int borderWidth, bool propagate = true); //moves window to fit into rect
 	void moveBy(const Point &p, bool propagate = true);
 	void moveTo(const Point &p, bool propagate = true);//move this to new position, coordinates are absolute (0,0 is topleft screen corner)
 
@@ -146,7 +148,6 @@
 {
 public:
 	WindowBase(int used_ = 0, Point pos_ = Point());
-protected:
 	virtual void close();
 };
 
@@ -165,6 +166,15 @@
 	virtual void updateGarrisons() = 0;
 };
 
+class IMarketHolder
+{
+public:
+	virtual void updateResources() {};
+	virtual void updateExperience() {};
+	virtual void updateSecondarySkills() {};
+	virtual void updateArtifacts() {};
+};
+
 class ITownHolder
 {
 public:
@@ -201,3 +211,16 @@
 	virtual void setEnteringMode(bool on){};
 	virtual void setEnteredText(const std::string & text){};
 };
+
+class ObjectConstruction : boost::noncopyable
+{
+public:
+	ObjectConstruction(CIntObject *obj);
+	~ObjectConstruction();
+};
+
+/// If used, all UI widgets created inside this scope will be added to children of 'this'
+#define OBJECT_CONSTRUCTION ObjectConstruction obj__i(this)
+
+/// If used, all UI widgets created inside this scope will be added to children of provided object
+#define OBJECT_CONSTRUCTION_TARGETED(obj) ObjectConstruction obj__i(obj)
diff --color -urN vcmi-1.5.7/client/gui/CursorHandler.cpp vcmi/client/gui/CursorHandler.cpp
--- vcmi-1.5.7/client/gui/CursorHandler.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/gui/CursorHandler.cpp	2024-12-19 15:00:22.253121282 +0100
@@ -17,6 +17,7 @@
 #include "../renderSDL/CursorHardware.h"
 #include "../render/CAnimation.h"
 #include "../render/IImage.h"
+#include "../render/IScreenHandler.h"
 #include "../render/IRenderHandler.h"
 
 #include "../../lib/CConfigHandler.h"
@@ -47,15 +48,12 @@
 
 	cursors =
 	{
-		GH.renderHandler().loadAnimation(AnimationPath::builtin("CRADVNTR")),
-		GH.renderHandler().loadAnimation(AnimationPath::builtin("CRCOMBAT")),
-		GH.renderHandler().loadAnimation(AnimationPath::builtin("CRDEFLT")),
-		GH.renderHandler().loadAnimation(AnimationPath::builtin("CRSPELL"))
+		GH.renderHandler().loadAnimation(AnimationPath::builtin("CRADVNTR"), EImageBlitMode::COLORKEY),
+		GH.renderHandler().loadAnimation(AnimationPath::builtin("CRCOMBAT"), EImageBlitMode::COLORKEY),
+		GH.renderHandler().loadAnimation(AnimationPath::builtin("CRDEFLT"), EImageBlitMode::COLORKEY),
+		GH.renderHandler().loadAnimation(AnimationPath::builtin("CRSPELL"), EImageBlitMode::COLORKEY)
 	};
 
-	for (auto & cursor : cursors)
-		cursor->preload();
-
 	set(Cursor::Map::POINTER);
 	showType = dynamic_cast<CursorSoftware *>(cursor.get()) ? Cursor::ShowType::SOFTWARE : Cursor::ShowType::HARDWARE;
 }
@@ -104,8 +102,7 @@
 
 void CursorHandler::dragAndDropCursor (const AnimationPath & path, size_t index)
 {
-	auto anim = GH.renderHandler().loadAnimation(path);
-	anim->load(index);
+	auto anim = GH.renderHandler().loadAnimation(path, EImageBlitMode::COLORKEY);
 	dragAndDropCursor(anim->getImage(index));
 }
 
@@ -179,7 +176,7 @@
 
 	assert(offsets.size() == size_t(Cursor::Map::COUNT)); //Invalid number of pivot offsets for cursor
 	assert(index < offsets.size());
-	return offsets[index];
+	return offsets[index] * GH.screenHandler().getScalingFactor();
 }
 
 Point CursorHandler::getPivotOffsetCombat(size_t index)
@@ -209,12 +206,12 @@
 
 	assert(offsets.size() == size_t(Cursor::Combat::COUNT)); //Invalid number of pivot offsets for cursor
 	assert(index < offsets.size());
-	return offsets[index];
+	return offsets[index] * GH.screenHandler().getScalingFactor();
 }
 
 Point CursorHandler::getPivotOffsetSpellcast()
 {
-	return { 18, 28};
+	return Point(18, 28) * GH.screenHandler().getScalingFactor();
 }
 
 Point CursorHandler::getPivotOffset()
@@ -315,3 +312,8 @@
 			break;
 	}
 }
+
+void CursorHandler::onScreenResize()
+{
+	cursor->setImage(getCurrentImage(), getPivotOffset());
+}
diff --color -urN vcmi-1.5.7/client/gui/CursorHandler.h vcmi/client/gui/CursorHandler.h
--- vcmi-1.5.7/client/gui/CursorHandler.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/gui/CursorHandler.h	2024-12-19 15:00:22.253121282 +0100
@@ -182,6 +182,7 @@
 
 	void hide();
 	void show();
+	void onScreenResize();
 
 	/// change cursor's positions to (x, y)
 	void cursorMove(const int & x, const int & y);
diff --color -urN vcmi-1.5.7/client/gui/EventDispatcher.cpp vcmi/client/gui/EventDispatcher.cpp
--- vcmi-1.5.7/client/gui/EventDispatcher.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/gui/EventDispatcher.cpp	2024-12-19 15:00:22.253121282 +0100
@@ -19,6 +19,7 @@
 
 #include "../../lib/CConfigHandler.h"
 #include "../../lib/Rect.h"
+#include "../eventsSDL/InputHandler.h"
 
 template<typename Functor>
 void EventDispatcher::processLists(ui16 activityFlag, const Functor & cb)
@@ -34,12 +35,14 @@
 	processList(AEventsReceiver::HOVER, hoverable);
 	processList(AEventsReceiver::MOVE, motioninterested);
 	processList(AEventsReceiver::DRAG, draginterested);
+	processList(AEventsReceiver::DRAG_POPUP, dragPopupInterested);
 	processList(AEventsReceiver::KEYBOARD, keyinterested);
 	processList(AEventsReceiver::TIME, timeinterested);
 	processList(AEventsReceiver::WHEEL, wheelInterested);
 	processList(AEventsReceiver::DOUBLECLICK, doubleClickInterested);
 	processList(AEventsReceiver::TEXTINPUT, textInterested);
 	processList(AEventsReceiver::GESTURE, panningInterested);
+	processList(AEventsReceiver::INPUT_MODE_CHANGE, inputModeChangeInterested);
 }
 
 void EventDispatcher::activateElement(AEventsReceiver * elem, ui16 activityFlag)
@@ -251,6 +254,10 @@
 				i->mouseClickedState = isPressed;
 				i->clickCancel(position);
 			}
+			else if(isPressed)
+			{
+				i->notFocusedClick();
+			}
 		}
 	}
 }
@@ -304,7 +311,7 @@
 {
 	for(auto it : textInterested)
 	{
-		it->textInputed(text);
+		it->textInputted(text);
 	}
 }
 
@@ -316,6 +323,14 @@
 	}
 }
 
+void EventDispatcher::dispatchInputModeChanged(const InputMode & modi)
+{
+	for(auto it : inputModeChangeInterested)
+	{
+		it->inputModeChanged(modi);
+	}
+}
+
 void EventDispatcher::dispatchGesturePanningStarted(const Point & initialPosition)
 {
 	auto copied = panningInterested;
@@ -423,3 +438,10 @@
 			elem->mouseDragged(currentPosition, lastUpdateDistance);
 	}
 }
+
+void EventDispatcher::dispatchMouseDraggedPopup(const Point & currentPosition, const Point & lastUpdateDistance)
+{
+	EventReceiversList diCopy = dragPopupInterested;
+	for(auto & elem : diCopy)
+		elem->mouseDraggedPopup(currentPosition, lastUpdateDistance);
+}
diff --color -urN vcmi-1.5.7/client/gui/EventDispatcher.h vcmi/client/gui/EventDispatcher.h
--- vcmi-1.5.7/client/gui/EventDispatcher.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/gui/EventDispatcher.h	2024-12-19 15:00:22.254121324 +0100
@@ -16,6 +16,7 @@
 class AEventsReceiver;
 enum class MouseButton;
 enum class EShortcut;
+enum class InputMode;
 
 /// Class that receives events from event producers and dispatches it to UI elements that are interested in this event
 class EventDispatcher
@@ -29,11 +30,13 @@
 	EventReceiversList keyinterested;
 	EventReceiversList motioninterested;
 	EventReceiversList draginterested;
+	EventReceiversList dragPopupInterested;
 	EventReceiversList timeinterested;
 	EventReceiversList wheelInterested;
 	EventReceiversList doubleClickInterested;
 	EventReceiversList textInterested;
 	EventReceiversList panningInterested;
+	EventReceiversList inputModeChangeInterested;
 
 	void handleLeftButtonClick(const Point & position, int tolerance, bool isPressed);
 	void handleDoubleButtonClick(const Point & position, int tolerance);
@@ -64,6 +67,7 @@
 	void dispatchMouseMoved(const Point & distance, const Point & position);
 
 	void dispatchMouseDragged(const Point & currentPosition, const Point & lastUpdateDistance);
+	void dispatchMouseDraggedPopup(const Point & currentPosition, const Point & lastUpdateDistance);
 
 	void dispatchShowPopup(const Point & position, int tolerance);
 	void dispatchClosePopup(const Point & position);
@@ -76,4 +80,6 @@
 	/// Text input events
 	void dispatchTextInput(const std::string & text);
 	void dispatchTextEditing(const std::string & text);
+
+	void dispatchInputModeChanged(const InputMode & modi);
 };
diff --color -urN vcmi-1.5.7/client/gui/EventsReceiver.h vcmi/client/gui/EventsReceiver.h
--- vcmi-1.5.7/client/gui/EventsReceiver.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/gui/EventsReceiver.h	2024-12-19 15:00:22.254121324 +0100
@@ -16,6 +16,7 @@
 
 class EventDispatcher;
 enum class EShortcut;
+enum class InputMode;
 
 /// Class that is capable of subscribing and receiving input events
 /// Acts as base class for all UI elements
@@ -50,6 +51,7 @@
 	virtual void clickCancel(const Point & cursorPosition) {}
 	virtual void showPopupWindow(const Point & cursorPosition) {}
 	virtual void clickDouble(const Point & cursorPosition) {}
+	virtual void notFocusedClick() {};
 
 	/// Called when user pans screen by specified distance
 	virtual void gesturePanning(const Point & initialPosition, const Point & currentPosition, const Point & lastUpdateDistance) {}
@@ -60,6 +62,7 @@
 	virtual void wheelScrolled(int distance) {}
 	virtual void mouseMoved(const Point & cursorPosition, const Point & lastUpdateDistance) {}
 	virtual void mouseDragged(const Point & cursorPosition, const Point & lastUpdateDistance) {}
+	virtual void mouseDraggedPopup(const Point & cursorPosition, const Point & lastUpdateDistance) {}
 
 	/// Called when UI element hover status changes
 	virtual void hover(bool on) {}
@@ -67,7 +70,7 @@
 	/// Called when UI element gesture status changes
 	virtual void gesture(bool on, const Point & initialPosition, const Point & finalPosition) {}
 
-	virtual void textInputed(const std::string & enteredText) {}
+	virtual void textInputted(const std::string & enteredText) {}
 	virtual void textEdited(const std::string & enteredText) {}
 
 	virtual void keyPressed(EShortcut key) {}
@@ -75,6 +78,8 @@
 
 	virtual void tick(uint32_t msPassed) {}
 
+	virtual void inputModeChanged(InputMode modi) {}
+
 public:
 	AEventsReceiver();
 	virtual ~AEventsReceiver() = default;
@@ -94,6 +99,8 @@
 		TEXTINPUT = 512,
 		GESTURE = 1024,
 		DRAG = 2048,
+		INPUT_MODE_CHANGE = 4096,
+		DRAG_POPUP = 8192
 	};
 
 	/// Returns true if element is currently hovered by mouse
diff --color -urN vcmi-1.5.7/client/gui/FramerateManager.h vcmi/client/gui/FramerateManager.h
--- vcmi-1.5.7/client/gui/FramerateManager.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/gui/FramerateManager.h	2024-12-19 15:00:22.254121324 +0100
@@ -22,7 +22,7 @@
 	Duration targetFrameTime;
 	TimePoint lastTimePoint;
 
-	/// index of last measured frome in lastFrameTimes array
+	/// index of last measured from in lastFrameTimes array
 	ui32 lastFrameIndex;
 
 	bool vsyncEnabled;
diff --color -urN vcmi-1.5.7/client/gui/InterfaceObjectConfigurable.cpp vcmi/client/gui/InterfaceObjectConfigurable.cpp
--- vcmi-1.5.7/client/gui/InterfaceObjectConfigurable.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/gui/InterfaceObjectConfigurable.cpp	2024-12-19 15:00:22.254121324 +0100
@@ -19,6 +19,7 @@
 #include "../gui/Shortcut.h"
 #include "../render/Graphics.h"
 #include "../render/IFont.h"
+#include "../render/IRenderHandler.h"
 #include "../widgets/CComponent.h"
 #include "../widgets/ComboBox.h"
 #include "../widgets/Buttons.h"
@@ -32,7 +33,7 @@
 
 #include "../../lib/constants/StringConstants.h"
 #include "../../lib/json/JsonUtils.h"
-#include "../../lib/CGeneralTextHandler.h"
+#include "../../lib/texts/CGeneralTextHandler.h"
 #include "../../lib/filesystem/ResourcePath.h"
 
 InterfaceObjectConfigurable::InterfaceObjectConfigurable(const JsonNode & config, int used, Point offset):
@@ -106,7 +107,7 @@
 
 void InterfaceObjectConfigurable::build(const JsonNode &config)
 {
-	OBJ_CONSTRUCTION;
+	OBJECT_CONSTRUCTION;
 
 	logGlobal->debug("Building configurable interface object");
 	auto * items = &config;
@@ -284,7 +285,7 @@
 			return EFonts::FONT_CALLI;
 	}
 	logGlobal->debug("Unknown font attribute");
-	return EFonts::FONT_TIMES;
+	return EFonts::FONT_MEDIUM;
 }
 
 std::pair<std::string, std::string> InterfaceObjectConfigurable::readHintText(const JsonNode & config) const
@@ -333,7 +334,7 @@
 	auto pic = std::make_shared<CPicture>(image, position.x, position.y);
 
 	if ( config["playerColored"].Bool() && LOCPLINT)
-		pic->colorize(LOCPLINT->playerID);
+		pic->setPlayerColor(LOCPLINT->playerID);
 	return pic;
 }
 
@@ -357,8 +358,9 @@
 	auto color = readColor(config["color"]);
 	auto text = readText(config["text"]);
 	Rect rect = readRect(config["rect"]);
+	const auto & fontPtr = GH.renderHandler().loadFont(font);
 	if(!config["adoptHeight"].isNull() && config["adoptHeight"].Bool())
-		rect.h = graphics->fonts[font]->getLineHeight() * 2;
+		rect.h = fontPtr->getLineHeight() * 2;
 	return std::make_shared<CMultiLineLabel>(rect, font, alignment, color, text);
 }
 
@@ -371,7 +373,7 @@
 	group->pos += position;
 	if(!config["items"].isNull())
 	{
-		OBJ_CONSTRUCTION_TARGETED(group.get());
+		OBJECT_CONSTRUCTION_TARGETED(group.get());
 		int itemIdx = -1;
 		for(const auto & item : config["items"].Vector())
 		{
@@ -566,16 +568,19 @@
 std::shared_ptr<CFilledTexture> InterfaceObjectConfigurable::buildTexture(const JsonNode & config) const
 {
 	logGlobal->debug("Building widget CFilledTexture");
-	auto image = ImagePath::fromJson(config["image"]);
 	auto rect = readRect(config["rect"]);
 	auto playerColor = readPlayerColor(config["color"]);
 	if(playerColor.isValidPlayer())
 	{
-		auto result = std::make_shared<FilledTexturePlayerColored>(image, rect);
-		result->playerColored(playerColor);
+		auto result = std::make_shared<FilledTexturePlayerColored>(rect);
+		result->setPlayerColor(playerColor);
 		return result;
 	}
-	return std::make_shared<CFilledTexture>(image, rect);
+	else
+	{
+		auto image = ImagePath::fromJson(config["image"]);
+		return std::make_shared<CFilledTexture>(image, rect);
+	}
 }
 
 std::shared_ptr<ComboBox> InterfaceObjectConfigurable::buildComboBox(const JsonNode & config)
diff --color -urN vcmi-1.5.7/client/gui/InterfaceObjectConfigurable.h vcmi/client/gui/InterfaceObjectConfigurable.h
--- vcmi-1.5.7/client/gui/InterfaceObjectConfigurable.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/gui/InterfaceObjectConfigurable.h	2024-12-19 15:00:22.254121324 +0100
@@ -41,7 +41,7 @@
 	InterfaceObjectConfigurable(const JsonNode & config, int used=0, Point offset=Point());
 
 protected:
-	/// Set blocked status for all buttons assotiated with provided shortcut
+	/// Set blocked status for all buttons associated with provided shortcut
 	void setShortcutBlocked(EShortcut shortcut, bool isBlocked);
 
 	/// Registers provided callback to be called whenever specified shortcut is triggered
diff --color -urN vcmi-1.5.7/client/gui/Shortcut.h vcmi/client/gui/Shortcut.h
--- vcmi-1.5.7/client/gui/Shortcut.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/gui/Shortcut.h	2024-12-19 15:00:22.254121324 +0100
@@ -74,6 +74,7 @@
 	HIGH_SCORES_CAMPAIGNS,
 	HIGH_SCORES_SCENARIOS,
 	HIGH_SCORES_RESET,
+	HIGH_SCORES_STATISTICS,
 
 	// Game lobby / scenario selection
 	LOBBY_BEGIN_STANDARD_GAME, // b
@@ -91,6 +92,7 @@
 	LOBBY_FLIP_COIN,
 	LOBBY_RANDOM_TOWN,
 	LOBBY_RANDOM_TOWN_VS,
+	LOBBY_HANDICAP,
 
 	MAPS_SIZE_S,
 	MAPS_SIZE_M,
@@ -120,6 +122,8 @@
 	// Adventure map screen
 	ADVENTURE_GAME_OPTIONS, // 'o', Open CAdventureOptions window
 	ADVENTURE_TOGGLE_GRID,  // F6, Toggles map grid
+	ADVENTURE_TOGGLE_VISITABLE,  // Toggles visitable tiles overlay
+	ADVENTURE_TOGGLE_BLOCKED,  // Toggles blocked tiles overlay
 	ADVENTURE_TOGGLE_SLEEP, // Toggles hero sleep status
 	ADVENTURE_SET_HERO_ASLEEP, // Moves hero to sleep state
 	ADVENTURE_SET_HERO_AWAKE, // Move hero to awake state
@@ -157,6 +161,8 @@
 	ADVENTURE_RESTART_GAME,
 	ADVENTURE_TO_MAIN_MENU,
 	ADVENTURE_QUIT_GAME,
+	ADVENTURE_SEARCH,
+	ADVENTURE_SEARCH_CONTINUE,
 
 	// Move hero one tile in specified direction. Bound to cursors & numpad buttons
 	ADVENTURE_MOVE_HERO_SW,
@@ -186,6 +192,19 @@
 	BATTLE_TOGGLE_HEROES_STATS,
 	BATTLE_OPEN_ACTIVE_UNIT,
 	BATTLE_OPEN_HOVERED_UNIT,
+	BATTLE_TOGGLE_QUICKSPELL,
+	BATTLE_SPELL_SHORTCUT_0,
+	BATTLE_SPELL_SHORTCUT_1,
+	BATTLE_SPELL_SHORTCUT_2,
+	BATTLE_SPELL_SHORTCUT_3,
+	BATTLE_SPELL_SHORTCUT_4,
+	BATTLE_SPELL_SHORTCUT_5,
+	BATTLE_SPELL_SHORTCUT_6,
+	BATTLE_SPELL_SHORTCUT_7,
+	BATTLE_SPELL_SHORTCUT_8,
+	BATTLE_SPELL_SHORTCUT_9,
+	BATTLE_SPELL_SHORTCUT_10,
+	BATTLE_SPELL_SHORTCUT_11,
 
 	MARKET_DEAL,
 	MARKET_MAX_AMOUNT,
@@ -277,5 +296,15 @@
 	SPELLBOOK_TAB_ADVENTURE,
 	SPELLBOOK_TAB_COMBAT,
 
+	LIST_HERO_UP,
+	LIST_HERO_DOWN,
+	LIST_HERO_TOP,
+	LIST_HERO_BOTTOM,
+	LIST_HERO_DISMISS,
+	LIST_TOWN_UP,
+	LIST_TOWN_DOWN,
+	LIST_TOWN_TOP,
+	LIST_TOWN_BOTTOM,
+
 	AFTER_LAST
 };
diff --color -urN vcmi-1.5.7/client/gui/ShortcutHandler.cpp vcmi/client/gui/ShortcutHandler.cpp
--- vcmi-1.5.7/client/gui/ShortcutHandler.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/gui/ShortcutHandler.cpp	2024-12-19 15:00:22.255121365 +0100
@@ -171,6 +171,8 @@
 		{"gameActivateConsole",      EShortcut::GAME_ACTIVATE_CONSOLE     },
 		{"adventureGameOptions",     EShortcut::ADVENTURE_GAME_OPTIONS    },
 		{"adventureToggleGrid",      EShortcut::ADVENTURE_TOGGLE_GRID     },
+		{"adventureToggleVisitable", EShortcut::ADVENTURE_TOGGLE_VISITABLE},
+		{"adventureToggleBlocked",   EShortcut::ADVENTURE_TOGGLE_BLOCKED  },
 		{"adventureToggleSleep",     EShortcut::ADVENTURE_TOGGLE_SLEEP    },
 		{"adventureSetHeroAsleep",   EShortcut::ADVENTURE_SET_HERO_ASLEEP },
 		{"adventureSetHeroAwake",    EShortcut::ADVENTURE_SET_HERO_AWAKE  },
@@ -207,6 +209,8 @@
 		{"adventureZoomIn",          EShortcut::ADVENTURE_ZOOM_IN         },
 		{"adventureZoomOut",         EShortcut::ADVENTURE_ZOOM_OUT        },
 		{"adventureZoomReset",       EShortcut::ADVENTURE_ZOOM_RESET      },
+		{"adventureSearch",          EShortcut::ADVENTURE_SEARCH          },
+		{"adventureSearchContinue",  EShortcut::ADVENTURE_SEARCH_CONTINUE },
 		{"battleToggleHeroesStats",  EShortcut::BATTLE_TOGGLE_HEROES_STATS},
 		{"battleToggleQueue",        EShortcut::BATTLE_TOGGLE_QUEUE       },
 		{"battleUseCreatureSpell",   EShortcut::BATTLE_USE_CREATURE_SPELL },
@@ -222,6 +226,19 @@
 		{"battleTacticsNext",        EShortcut::BATTLE_TACTICS_NEXT       },
 		{"battleTacticsEnd",         EShortcut::BATTLE_TACTICS_END        },
 		{"battleSelectAction",       EShortcut::BATTLE_SELECT_ACTION      },
+		{"battleToggleQuickSpell",   EShortcut::BATTLE_TOGGLE_QUICKSPELL   },
+		{"battleSpellShortcut0",     EShortcut::BATTLE_SPELL_SHORTCUT_0   },
+		{"battleSpellShortcut1",     EShortcut::BATTLE_SPELL_SHORTCUT_1   },
+		{"battleSpellShortcut2",     EShortcut::BATTLE_SPELL_SHORTCUT_2   },
+		{"battleSpellShortcut3",     EShortcut::BATTLE_SPELL_SHORTCUT_3   },
+		{"battleSpellShortcut4",     EShortcut::BATTLE_SPELL_SHORTCUT_4   },
+		{"battleSpellShortcut5",     EShortcut::BATTLE_SPELL_SHORTCUT_5   },
+		{"battleSpellShortcut6",     EShortcut::BATTLE_SPELL_SHORTCUT_6   },
+		{"battleSpellShortcut7",     EShortcut::BATTLE_SPELL_SHORTCUT_7   },
+		{"battleSpellShortcut8",     EShortcut::BATTLE_SPELL_SHORTCUT_8   },
+		{"battleSpellShortcut9",     EShortcut::BATTLE_SPELL_SHORTCUT_9   },
+		{"battleSpellShortcut10",    EShortcut::BATTLE_SPELL_SHORTCUT_10  },
+		{"battleSpellShortcut11",    EShortcut::BATTLE_SPELL_SHORTCUT_11  },
 		{"spectateTrackHero",        EShortcut::SPECTATE_TRACK_HERO       },
 		{"spectateSkipBattle",       EShortcut::SPECTATE_SKIP_BATTLE      },
 		{"spectateSkipBattleResult", EShortcut::SPECTATE_SKIP_BATTLE_RESULT },
@@ -260,12 +277,22 @@
 		{"heroCostumeLoad9",         EShortcut::HERO_COSTUME_LOAD_9       },
 		{"spellbookTabAdventure",    EShortcut::SPELLBOOK_TAB_ADVENTURE   },
 		{"spellbookTabCombat",       EShortcut::SPELLBOOK_TAB_COMBAT      },
+		{"listHeroUp",               EShortcut::LIST_HERO_UP              },
+		{"listHeroDown",             EShortcut::LIST_HERO_DOWN            },
+		{"listHeroTop",              EShortcut::LIST_HERO_TOP             },
+		{"listHeroBottom",           EShortcut::LIST_HERO_BOTTOM          },
+		{"listHeroDismiss",          EShortcut::LIST_HERO_DISMISS         },
+		{"listTownUp",               EShortcut::LIST_TOWN_UP              },
+		{"listTownDown",             EShortcut::LIST_TOWN_DOWN            },
+		{"listTownTop",              EShortcut::LIST_TOWN_TOP             },
+		{"listTownBottom",           EShortcut::LIST_TOWN_BOTTOM          },
 		{"mainMenuHotseat",          EShortcut::MAIN_MENU_HOTSEAT         },
 		{"mainMenuHostGame",         EShortcut::MAIN_MENU_HOST_GAME       },
 		{"mainMenuJoinGame",         EShortcut::MAIN_MENU_JOIN_GAME       },
 		{"highScoresCampaigns",      EShortcut::HIGH_SCORES_CAMPAIGNS     },
 		{"highScoresScenarios",      EShortcut::HIGH_SCORES_SCENARIOS     },
 		{"highScoresReset",          EShortcut::HIGH_SCORES_RESET         },
+		{"highScoresStatistics",     EShortcut::HIGH_SCORES_STATISTICS    },
 		{"lobbyReplayVideo",         EShortcut::LOBBY_REPLAY_VIDEO        },
 		{"lobbyExtraOptions",        EShortcut::LOBBY_EXTRA_OPTIONS       },
 		{"lobbyTurnOptions",         EShortcut::LOBBY_TURN_OPTIONS        },
@@ -273,6 +300,7 @@
 		{"lobbyFlipCoin",            EShortcut::LOBBY_FLIP_COIN           },
 		{"lobbyRandomTown",          EShortcut::LOBBY_RANDOM_TOWN         },
 		{"lobbyRandomTownVs",        EShortcut::LOBBY_RANDOM_TOWN_VS      },
+		{"lobbyHandicap",            EShortcut::LOBBY_HANDICAP            },
 		{"mapsSizeS",                EShortcut::MAPS_SIZE_S               },
 		{"mapsSizeM",                EShortcut::MAPS_SIZE_M               },
 		{"mapsSizeL",                EShortcut::MAPS_SIZE_L               },
diff --color -urN vcmi-1.5.7/client/gui/WindowHandler.cpp vcmi/client/gui/WindowHandler.cpp
--- vcmi-1.5.7/client/gui/WindowHandler.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/gui/WindowHandler.cpp	2024-12-19 15:00:22.255121365 +0100
@@ -111,7 +111,7 @@
 {
 	logGlobal->debug("totalRedraw requested!");
 
-	Canvas target = Canvas::createFromSurface(screen2);
+	Canvas target = Canvas::createFromSurface(screen2, CanvasScalingPolicy::AUTO);
 
 	for(auto & elem : windowsStack)
 		elem->showAll(target);
@@ -134,7 +134,7 @@
 	if(windowsStack.size() > 1)
 		CSDL_Ext::blitAt(screen2, 0, 0, screen); //blit background
 
-	Canvas target = Canvas::createFromSurface(screen);
+	Canvas target = Canvas::createFromSurface(screen, CanvasScalingPolicy::AUTO);
 
 	if(!windowsStack.empty())
 		windowsStack.back()->show(target); //blit active interface/window
diff --color -urN vcmi-1.5.7/client/HeroMovementController.cpp vcmi/client/HeroMovementController.cpp
--- vcmi-1.5.7/client/HeroMovementController.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/HeroMovementController.cpp	2024-12-19 15:00:22.240120745 +0100
@@ -11,7 +11,6 @@
 #include "HeroMovementController.h"
 
 #include "CGameInfo.h"
-#include "CMusicHandler.h"
 #include "CPlayerInterface.h"
 #include "PlayerLocalState.h"
 #include "adventureMap/AdventureMapInterface.h"
@@ -19,10 +18,13 @@
 #include "gui/CGuiHandler.h"
 #include "gui/CursorHandler.h"
 #include "mapView/mapHandler.h"
+#include "media/ISoundPlayer.h"
 
 #include "../CCallback.h"
 
 #include "ConditionalWait.h"
+#include "../lib/CConfigHandler.h"
+#include "../lib/CRandomGenerator.h"
 #include "../lib/pathfinder/CGPathNode.h"
 #include "../lib/mapObjects/CGHeroInstance.h"
 #include "../lib/networkPacks/PacksForClient.h"
@@ -152,8 +154,12 @@
 
 	if(details.result == TryMoveHero::EMBARK || details.result == TryMoveHero::DISEMBARK)
 	{
-		if(hero->getRemovalSound() && hero->tempOwner == LOCPLINT->playerID)
-			CCS->soundh->playSound(hero->getRemovalSound().value());
+		if (hero->tempOwner == LOCPLINT->playerID)
+		{
+			auto removalSound = hero->getRemovalSound(CRandomGenerator::getDefault());
+			if (removalSound)
+				CCS->soundh->playSound(removalSound.value());
+		}
 	}
 
 	bool directlyAttackingCreature =
@@ -285,14 +291,12 @@
 	auto prevTile = LOCPLINT->cb->getTile(posPrev);
 	auto nextTile = LOCPLINT->cb->getTile(posNext);
 
-	auto prevRoad = prevTile->roadType;
-	auto nextRoad = nextTile->roadType;
-	bool movingOnRoad = prevRoad->getId() != Road::NO_ROAD && nextRoad->getId() != Road::NO_ROAD;
+	bool movingOnRoad = prevTile->hasRoad() && nextTile->hasRoad();
 
 	if(movingOnRoad)
-		return nextTile->terType->horseSound;
+		return nextTile->getTerrain()->horseSound;
 	else
-		return nextTile->terType->horseSoundPenalty;
+		return nextTile->getTerrain()->horseSoundPenalty;
 };
 
 void HeroMovementController::updateMovementSound(const CGHeroInstance * h, int3 posPrev, int3 nextCoord, EPathNodeAction moveType)
@@ -369,7 +373,7 @@
 	{
 		updateMovementSound(h, currNode.coord, nextNode.coord, nextNode.action);
 
-		assert(h->pos.z == nextNode.coord.z); // Z should change only if it's movement via teleporter and in this case this code shouldn't be executed at all
+		assert(h->anchorPos().z == nextNode.coord.z); // Z should change only if it's movement via teleporter and in this case this code shouldn't be executed at all
 
 		logGlobal->trace("Requesting hero movement to %s", nextNode.coord.toString());
 
diff --color -urN vcmi-1.5.7/client/icons/generate_icns.py vcmi/client/icons/generate_icns.py
--- vcmi-1.5.7/client/icons/generate_icns.py	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/icons/generate_icns.py	1970-01-01 01:00:00.000000000 +0100
@@ -1,18 +0,0 @@
-from PIL import Image
-import os, sys, shutil
-
-img = Image.open(sys.argv[1])
-if img.size != (1024,1024):
-    print("Input image must be 1024x1024. Provided image is %dx%d" % img.size)
-
-os.mkdir("vcmi.iconset")
-for i in [16, 32, 128, 256, 512]:
-    resized = img.resize((i, i), Image.ANTIALIAS)
-    resized.save("vcmi.iconset/icon_%dx%d.png" % (i, i))
-
-    resized2x = img.resize((2*i, 2*i), Image.ANTIALIAS)
-    resized2x.save("vcmi.iconset/icon_%dx%d@2x.png" % (i, i))
-
-os.system("iconutil -c icns vcmi.iconset")
-shutil.rmtree("vcmi.iconset")
-
Binary files vcmi-1.5.7/client/icons/vcmiclient.1024x1024.png and vcmi/client/icons/vcmiclient.1024x1024.png differ
Binary files vcmi-1.5.7/client/icons/vcmiclient.128x128.png and vcmi/client/icons/vcmiclient.128x128.png differ
Binary files vcmi-1.5.7/client/icons/vcmiclient.16x16.png and vcmi/client/icons/vcmiclient.16x16.png differ
Binary files vcmi-1.5.7/client/icons/vcmiclient.2048x2048.png and vcmi/client/icons/vcmiclient.2048x2048.png differ
Binary files vcmi-1.5.7/client/icons/vcmiclient.22x22.png and vcmi/client/icons/vcmiclient.22x22.png differ
Binary files vcmi-1.5.7/client/icons/vcmiclient.256x256.png and vcmi/client/icons/vcmiclient.256x256.png differ
Binary files vcmi-1.5.7/client/icons/vcmiclient.32x32.png and vcmi/client/icons/vcmiclient.32x32.png differ
Binary files vcmi-1.5.7/client/icons/vcmiclient.48x48.png and vcmi/client/icons/vcmiclient.48x48.png differ
Binary files vcmi-1.5.7/client/icons/vcmiclient.512x512.png and vcmi/client/icons/vcmiclient.512x512.png differ
Binary files vcmi-1.5.7/client/icons/vcmiclient.64x64.png and vcmi/client/icons/vcmiclient.64x64.png differ
diff --color -urN vcmi-1.5.7/client/icons/vcmiclient.desktop vcmi/client/icons/vcmiclient.desktop
--- vcmi-1.5.7/client/icons/vcmiclient.desktop	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/icons/vcmiclient.desktop	1970-01-01 01:00:00.000000000 +0100
@@ -1,10 +0,0 @@
-[Desktop Entry]
-Type=Application
-Name=VCMI Client
-GenericName=Strategy Game Engine
-Comment=Open engine for Heroes of Might and Magic 3
-Icon=vcmiclient
-Exec=vcmiclient
-Categories=Game;StrategyGame;
-Version=1.0
-Keywords=heroes;homm3;
diff --color -urN vcmi-1.5.7/client/icons/vcmiclient.svg vcmi/client/icons/vcmiclient.svg
--- vcmi-1.5.7/client/icons/vcmiclient.svg	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/icons/vcmiclient.svg	1970-01-01 01:00:00.000000000 +0100
@@ -1,265 +0,0 @@
-<?xml version="1.0" encoding="UTF-8" standalone="no"?>
-<!-- Created with Inkscape (http://www.inkscape.org/) -->
-
-<svg
-   width="128"
-   height="128"
-   viewBox="0 0 33.866667 33.866667"
-   version="1.1"
-   id="svg8061"
-   sodipodi:docname="vcmiclient.svg"
-   inkscape:version="1.3 (0e150ed6c4, 2023-07-21)"
-   xml:space="preserve"
-   inkscape:export-filename="vcmiclient.16x16.png"
-   inkscape:export-xdpi="12"
-   inkscape:export-ydpi="12"
-   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
-   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
-   xmlns:xlink="http://www.w3.org/1999/xlink"
-   xmlns="http://www.w3.org/2000/svg"
-   xmlns:svg="http://www.w3.org/2000/svg"><sodipodi:namedview
-     id="namedview71"
-     pagecolor="#ffffff"
-     bordercolor="#000000"
-     borderopacity="0.25"
-     inkscape:showpageshadow="2"
-     inkscape:pageopacity="0.0"
-     inkscape:pagecheckerboard="0"
-     inkscape:deskcolor="#d1d1d1"
-     showgrid="true"
-     showguides="true"
-     inkscape:zoom="3.6120448"
-     inkscape:cx="-11.904614"
-     inkscape:cy="104.64987"
-     inkscape:window-width="1920"
-     inkscape:window-height="1017"
-     inkscape:window-x="-8"
-     inkscape:window-y="-8"
-     inkscape:window-maximized="1"
-     inkscape:current-layer="g959"><inkscape:grid
-       id="grid1"
-       units="px"
-       originx="0"
-       originy="0"
-       spacingx="0.26458334"
-       spacingy="0.26458334"
-       empcolor="#0099e5"
-       empopacity="0.30196078"
-       color="#0099e5"
-       opacity="0.14901961"
-       empspacing="5"
-       dotted="false"
-       gridanglex="30"
-       gridanglez="30"
-       visible="true" /></sodipodi:namedview><defs
-     id="defs8058"><linearGradient
-       id="linearGradient13"
-       inkscape:collect="always"><stop
-         style="stop-color:#fdf2c2;stop-opacity:1"
-         offset="0"
-         id="stop12" /><stop
-         style="stop-color:#b9843c;stop-opacity:1"
-         offset="1"
-         id="stop13" /></linearGradient><linearGradient
-       id="linearGradient11"
-       inkscape:collect="always"><stop
-         style="stop-color:#fdf2c2;stop-opacity:1"
-         offset="0"
-         id="stop10" /><stop
-         style="stop-color:#b9843c;stop-opacity:1"
-         offset="1"
-         id="stop11" /></linearGradient><linearGradient
-       id="linearGradient9"
-       inkscape:collect="always"><stop
-         style="stop-color:#fdf2c2;stop-opacity:1"
-         offset="0"
-         id="stop8" /><stop
-         style="stop-color:#b9843c;stop-opacity:1"
-         offset="1"
-         id="stop9" /></linearGradient><linearGradient
-       id="linearGradient6"
-       inkscape:collect="always"><stop
-         style="stop-color:#fdf2c2;stop-opacity:1"
-         offset="0"
-         id="stop6" /><stop
-         style="stop-color:#b9843c;stop-opacity:1"
-         offset="1"
-         id="stop7" /></linearGradient><filter
-       style="color-interpolation-filters:sRGB"
-       id="filter6247"
-       x="-0.2707397"
-       y="-0.19854234"
-       width="1.5414794"
-       height="1.3970847"><feFlood
-         flood-opacity="0.741176"
-         flood-color="rgb(0,0,0)"
-         result="flood"
-         id="feFlood6237" /><feComposite
-         in="flood"
-         in2="SourceGraphic"
-         operator="in"
-         result="composite1"
-         id="feComposite6239" /><feGaussianBlur
-         in="composite1"
-         stdDeviation="5"
-         result="blur"
-         id="feGaussianBlur6241" /><feOffset
-         dx="0"
-         dy="0"
-         result="offset"
-         id="feOffset6243" /><feComposite
-         in="SourceGraphic"
-         in2="offset"
-         operator="over"
-         result="composite2"
-         id="feComposite6245" /></filter><filter
-       style="color-interpolation-filters:sRGB"
-       id="filter6259"
-       x="-0.2206027"
-       y="-0.19854242"
-       width="1.4412054"
-       height="1.3970848"><feFlood
-         flood-opacity="0.741176"
-         flood-color="rgb(0,0,0)"
-         result="flood"
-         id="feFlood6249" /><feComposite
-         in="flood"
-         in2="SourceGraphic"
-         operator="in"
-         result="composite1"
-         id="feComposite6251" /><feGaussianBlur
-         in="composite1"
-         stdDeviation="5"
-         result="blur"
-         id="feGaussianBlur6253" /><feOffset
-         dx="0"
-         dy="0"
-         result="offset"
-         id="feOffset6255" /><feComposite
-         in="SourceGraphic"
-         in2="offset"
-         operator="over"
-         result="composite2"
-         id="feComposite6257" /></filter><filter
-       style="color-interpolation-filters:sRGB"
-       id="filter6271"
-       x="-0.17518451"
-       y="-0.19854242"
-       width="1.3506831"
-       height="1.3970848"><feFlood
-         flood-opacity="0.741176"
-         flood-color="rgb(0,0,0)"
-         result="flood"
-         id="feFlood6261" /><feComposite
-         in="flood"
-         in2="SourceGraphic"
-         operator="in"
-         result="composite1"
-         id="feComposite6263" /><feGaussianBlur
-         in="composite1"
-         stdDeviation="5"
-         result="blur"
-         id="feGaussianBlur6265" /><feOffset
-         dx="0"
-         dy="0"
-         result="offset"
-         id="feOffset6267" /><feComposite
-         in="SourceGraphic"
-         in2="offset"
-         operator="over"
-         result="composite2"
-         id="feComposite6269" /></filter><filter
-       style="color-interpolation-filters:sRGB"
-       id="filter6283"
-       x="-0.85087486"
-       y="-0.19853745"
-       width="2.7017497"
-       height="1.3970749"><feFlood
-         flood-opacity="0.741176"
-         flood-color="rgb(0,0,0)"
-         result="flood"
-         id="feFlood6273" /><feComposite
-         in="flood"
-         in2="SourceGraphic"
-         operator="in"
-         result="composite1"
-         id="feComposite6275" /><feGaussianBlur
-         in="composite1"
-         stdDeviation="5"
-         result="blur"
-         id="feGaussianBlur6277" /><feOffset
-         dx="0"
-         dy="0"
-         result="offset"
-         id="feOffset6279" /><feComposite
-         in="SourceGraphic"
-         in2="offset"
-         operator="over"
-         result="composite2"
-         id="feComposite6281" /></filter><linearGradient
-       inkscape:collect="always"
-       xlink:href="#linearGradient6"
-       id="linearGradient2"
-       x1="175.1637"
-       y1="120.33793"
-       x2="233.46321"
-       y2="272.96185"
-       gradientUnits="userSpaceOnUse" /><linearGradient
-       inkscape:collect="always"
-       xlink:href="#linearGradient13"
-       id="linearGradient3"
-       x1="175.1637"
-       y1="120.33793"
-       x2="233.46321"
-       y2="272.96185"
-       gradientUnits="userSpaceOnUse"
-       gradientTransform="translate(1.5699347,0.84779727)" /><linearGradient
-       inkscape:collect="always"
-       xlink:href="#linearGradient11"
-       id="linearGradient4"
-       x1="175.1637"
-       y1="120.33793"
-       x2="233.46321"
-       y2="272.96185"
-       gradientUnits="userSpaceOnUse" /><linearGradient
-       inkscape:collect="always"
-       xlink:href="#linearGradient9"
-       id="linearGradient5"
-       x1="175.1637"
-       y1="120.33793"
-       x2="233.46321"
-       y2="272.96185"
-       gradientUnits="userSpaceOnUse" /></defs><g
-     id="g959"
-     inkscape:label="vcmi_icon"><image
-       width="23.476202"
-       height="33.866669"
-       preserveAspectRatio="none"
-       xlink:href="data:image/png;base64,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&#10;"
-       id="image1"
-       x="5.1952324"
-       y="0" /><g
-       id="g947"
-       transform="matrix(0.07899105,0,0,0.07899105,-0.64590914,0.80432555)"
-       style="display:inline"
-       inkscape:label="vcmi_text"><path
-         style="fill:url(#linearGradient2);fill-opacity:1;stroke:#282828;stroke-width:15.9015;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1;paint-order:stroke fill markers;filter:url(#filter6247)"
-         d="m 21.575135,153.94476 h 23.44675 v 26.79629 h 10.048608 v 40.19443 l 6.616247,-0.0246 0.08282,-40.16979 H 71.818167 V 153.9448 h 23.446751 v 33.49536 H 81.866779 v 40.19443 H 68.468636 v 26.79629 H 48.371421 V 227.63455 H 34.973278 V 187.44012 H 21.575135 Z"
-         id="path104"
-         sodipodi:nodetypes="cccccccccccccccccccccc"
-         inkscape:label="v" /><path
-         style="fill:url(#linearGradient3);fill-opacity:1;stroke:#282828;stroke-width:15.9015;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1;paint-order:stroke fill markers;filter:url(#filter6259)"
-         d="m 125.41074,170.69244 h 13.39815 v -16.74768 h 63.64118 v 16.74768 h 13.39814 v 16.74768 h -23.44675 v -13.39814 h -43.54397 v 60.29164 h 43.54397 v -13.39814 h 23.44675 v 20.09721 h -13.39814 v 13.39815 h -60.29165 v -13.39815 h -16.74768 v -70.34025 0"
-         id="path1189"
-         sodipodi:nodetypes="cccccccccccccccccccccc"
-         inkscape:label="c" /><path
-         style="fill:url(#linearGradient4);fill-opacity:1;stroke:#282828;stroke-width:15.9015;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1;paint-order:stroke fill markers;filter:url(#filter6271)"
-         d="m 242.6445,153.94476 h 33.49535 v 26.79629 H 289.538 v 26.79629 h 20.09721 v -26.79629 h 13.39815 v -26.79629 h 33.49535 l -0.44464,99.06637 h -19.9543 l 0.30173,-65.57101 h -6.69907 v 26.79629 h -13.39815 v 26.79628 h -33.49535 v -26.79628 h -13.39815 v -26.79629 h -6.69907 v 66.99072 H 242.6445 V 153.94476"
-         id="path1228"
-         sodipodi:nodetypes="ccccccccccccccccccccccccc"
-         inkscape:label="m" /><path
-         style="fill:url(#linearGradient5);fill-opacity:1;stroke:#282828;stroke-width:15.9005;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1;paint-order:stroke fill markers;filter:url(#filter6283)"
-         d="m 386.67454,153.94476 h 23.44675 v 100.48608 h -23.44675 z"
-         id="path1263"
-         sodipodi:nodetypes="ccccc"
-         inkscape:label="i" /></g></g></svg>
diff --color -urN vcmi-1.5.7/client/ios/GameChatKeyboardHandler.h vcmi/client/ios/GameChatKeyboardHandler.h
--- vcmi-1.5.7/client/ios/GameChatKeyboardHandler.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/ios/GameChatKeyboardHandler.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,24 +0,0 @@
-/*
- * GameChatKeyboardHandler.h, part of VCMI engine
- *
- * Authors: listed in file AUTHORS in main folder
- *
- * License: GNU General Public License v2.0 or later
- * Full text of license available in license.txt file, in main folder
- *
- */
-#pragma once
-
-#import <UIKit/UIKit.h>
-
-#include <SDL_events.h>
-
-NS_ASSUME_NONNULL_BEGIN
-
-@interface GameChatKeyboardHandler : NSObject
-
-+ (void)sendKeyEventWithKeyCode:(SDL_KeyCode)keyCode;
-
-@end
-
-NS_ASSUME_NONNULL_END
diff --color -urN vcmi-1.5.7/client/ios/GameChatKeyboardHandler.m vcmi/client/ios/GameChatKeyboardHandler.m
--- vcmi-1.5.7/client/ios/GameChatKeyboardHandler.m	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/ios/GameChatKeyboardHandler.m	1970-01-01 01:00:00.000000000 +0100
@@ -1,70 +0,0 @@
-/*
- * GameChatKeyboardHandler.m, part of VCMI engine
- *
- * Authors: listed in file AUTHORS in main folder
- *
- * License: GNU General Public License v2.0 or later
- * Full text of license available in license.txt file, in main folder
- *
- */
-
-#import "GameChatKeyboardHandler.h"
-
-static int watchReturnKey(void * userdata, SDL_Event * event);
-
-
-@interface GameChatKeyboardHandler ()
-@property (nonatomic) BOOL wasChatMessageSent;
-@end
-
-@implementation GameChatKeyboardHandler
-
-+ (void)sendKeyEventWithKeyCode:(SDL_KeyCode)keyCode
-{
-	SDL_Event keyEvent;
-	keyEvent.key = (SDL_KeyboardEvent){
-		.type = SDL_KEYDOWN,
-		.state = SDL_PRESSED,
-		.keysym.sym = keyCode,
-	};
-	SDL_PushEvent(&keyEvent);
-}
-
-- (instancetype)init {
-	self = [super init];
-
-	__auto_type notificationCenter = NSNotificationCenter.defaultCenter;
-	[notificationCenter addObserver:self selector:@selector(textDidBeginEditing:) name:UITextFieldTextDidBeginEditingNotification object:nil];
-	[notificationCenter addObserver:self selector:@selector(textDidEndEditing:) name:UITextFieldTextDidEndEditingNotification object:nil];
-
-	return self;
-}
-
-#pragma mark - Notifications
-
-- (void)textDidBeginEditing:(NSNotification *)n {
-	self.wasChatMessageSent = NO;
-
-	// watch for pressing Return to ignore sending Escape key after keyboard is closed
-	SDL_AddEventWatch(watchReturnKey, (__bridge void *)self);
-}
-
-- (void)textDidEndEditing:(NSNotification *)n {
-	// discard chat message
-	if(!self.wasChatMessageSent)
-		[[self class] sendKeyEventWithKeyCode:SDLK_ESCAPE];
-}
-
-@end
-
-
-static int watchReturnKey(void * userdata, SDL_Event * event)
-{
-	if(event->type == SDL_KEYDOWN && event->key.keysym.scancode == SDL_SCANCODE_RETURN)
-	{
-		__auto_type self = (__bridge GameChatKeyboardHandler *)userdata;
-		self.wasChatMessageSent = YES;
-		SDL_DelEventWatch(watchReturnKey, userdata);
-	}
-	return 1;
-}
diff --color -urN vcmi-1.5.7/client/ios/Images.xcassets/AppIcon.appiconset/Contents.json vcmi/client/ios/Images.xcassets/AppIcon.appiconset/Contents.json
--- vcmi-1.5.7/client/ios/Images.xcassets/AppIcon.appiconset/Contents.json	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/ios/Images.xcassets/AppIcon.appiconset/Contents.json	1970-01-01 01:00:00.000000000 +0100
@@ -1,121 +0,0 @@
-{
-  "images" : [
-    {
-      "filename" : "Icon-App-20x20@2x.png",
-      "idiom" : "iphone",
-      "scale" : "2x",
-      "size" : "20x20"
-    },
-    {
-      "filename" : "Icon-App-20x20@3x.png",
-      "idiom" : "iphone",
-      "scale" : "3x",
-      "size" : "20x20"
-    },
-    {
-      "filename" : "Icon-App-29x29@1x.png",
-      "idiom" : "iphone",
-      "scale" : "1x",
-      "size" : "29x29"
-    },
-    {
-      "filename" : "Icon-App-29x29@2x.png",
-      "idiom" : "iphone",
-      "scale" : "2x",
-      "size" : "29x29"
-    },
-    {
-      "filename" : "Icon-App-29x29@3x.png",
-      "idiom" : "iphone",
-      "scale" : "3x",
-      "size" : "29x29"
-    },
-    {
-      "filename" : "Icon-App-40x40@2x.png",
-      "idiom" : "iphone",
-      "scale" : "2x",
-      "size" : "40x40"
-    },
-    {
-      "filename" : "Icon-App-40x40@3x.png",
-      "idiom" : "iphone",
-      "scale" : "3x",
-      "size" : "40x40"
-    },
-    {
-      "filename" : "Icon-App-60x60@2x.png",
-      "idiom" : "iphone",
-      "scale" : "2x",
-      "size" : "60x60"
-    },
-    {
-      "filename" : "Icon-App-60x60@3x.png",
-      "idiom" : "iphone",
-      "scale" : "3x",
-      "size" : "60x60"
-    },
-    {
-      "filename" : "Icon-App-20x20@1x.png",
-      "idiom" : "ipad",
-      "scale" : "1x",
-      "size" : "20x20"
-    },
-    {
-      "filename" : "Icon-App-20x20@2x.png",
-      "idiom" : "ipad",
-      "scale" : "2x",
-      "size" : "20x20"
-    },
-    {
-      "filename" : "Icon-App-29x29@1x.png",
-      "idiom" : "ipad",
-      "scale" : "1x",
-      "size" : "29x29"
-    },
-    {
-      "filename" : "Icon-App-29x29@2x.png",
-      "idiom" : "ipad",
-      "scale" : "2x",
-      "size" : "29x29"
-    },
-    {
-      "filename" : "Icon-App-40x40@1x.png",
-      "idiom" : "ipad",
-      "scale" : "1x",
-      "size" : "40x40"
-    },
-    {
-      "filename" : "Icon-App-40x40@2x.png",
-      "idiom" : "ipad",
-      "scale" : "2x",
-      "size" : "40x40"
-    },
-    {
-      "filename" : "Icon-App-76x76@1x.png",
-      "idiom" : "ipad",
-      "scale" : "1x",
-      "size" : "76x76"
-    },
-    {
-      "filename" : "Icon-App-76x76@2x.png",
-      "idiom" : "ipad",
-      "scale" : "2x",
-      "size" : "76x76"
-    },
-    {
-      "filename" : "Icon-App-83.5x83.5@2x.png",
-      "idiom" : "ipad",
-      "scale" : "2x",
-      "size" : "83.5x83.5"
-    },
-    {
-      "idiom" : "ios-marketing",
-      "scale" : "1x",
-      "size" : "1024x1024"
-    }
-  ],
-  "info" : {
-    "author" : "xcode",
-    "version" : 1
-  }
-}
Binary files vcmi-1.5.7/client/ios/Images.xcassets/AppIcon.appiconset/Icon-App-20x20@1x.png and vcmi/client/ios/Images.xcassets/AppIcon.appiconset/Icon-App-20x20@1x.png differ
Binary files vcmi-1.5.7/client/ios/Images.xcassets/AppIcon.appiconset/Icon-App-20x20@2x.png and vcmi/client/ios/Images.xcassets/AppIcon.appiconset/Icon-App-20x20@2x.png differ
Binary files vcmi-1.5.7/client/ios/Images.xcassets/AppIcon.appiconset/Icon-App-20x20@3x.png and vcmi/client/ios/Images.xcassets/AppIcon.appiconset/Icon-App-20x20@3x.png differ
Binary files vcmi-1.5.7/client/ios/Images.xcassets/AppIcon.appiconset/Icon-App-29x29@1x.png and vcmi/client/ios/Images.xcassets/AppIcon.appiconset/Icon-App-29x29@1x.png differ
Binary files vcmi-1.5.7/client/ios/Images.xcassets/AppIcon.appiconset/Icon-App-29x29@2x.png and vcmi/client/ios/Images.xcassets/AppIcon.appiconset/Icon-App-29x29@2x.png differ
Binary files vcmi-1.5.7/client/ios/Images.xcassets/AppIcon.appiconset/Icon-App-29x29@3x.png and vcmi/client/ios/Images.xcassets/AppIcon.appiconset/Icon-App-29x29@3x.png differ
Binary files vcmi-1.5.7/client/ios/Images.xcassets/AppIcon.appiconset/Icon-App-40x40@1x.png and vcmi/client/ios/Images.xcassets/AppIcon.appiconset/Icon-App-40x40@1x.png differ
Binary files vcmi-1.5.7/client/ios/Images.xcassets/AppIcon.appiconset/Icon-App-40x40@2x.png and vcmi/client/ios/Images.xcassets/AppIcon.appiconset/Icon-App-40x40@2x.png differ
Binary files vcmi-1.5.7/client/ios/Images.xcassets/AppIcon.appiconset/Icon-App-40x40@3x.png and vcmi/client/ios/Images.xcassets/AppIcon.appiconset/Icon-App-40x40@3x.png differ
Binary files vcmi-1.5.7/client/ios/Images.xcassets/AppIcon.appiconset/Icon-App-60x60@2x.png and vcmi/client/ios/Images.xcassets/AppIcon.appiconset/Icon-App-60x60@2x.png differ
Binary files vcmi-1.5.7/client/ios/Images.xcassets/AppIcon.appiconset/Icon-App-60x60@3x.png and vcmi/client/ios/Images.xcassets/AppIcon.appiconset/Icon-App-60x60@3x.png differ
Binary files vcmi-1.5.7/client/ios/Images.xcassets/AppIcon.appiconset/Icon-App-76x76@1x.png and vcmi/client/ios/Images.xcassets/AppIcon.appiconset/Icon-App-76x76@1x.png differ
Binary files vcmi-1.5.7/client/ios/Images.xcassets/AppIcon.appiconset/Icon-App-76x76@2x.png and vcmi/client/ios/Images.xcassets/AppIcon.appiconset/Icon-App-76x76@2x.png differ
Binary files vcmi-1.5.7/client/ios/Images.xcassets/AppIcon.appiconset/Icon-App-83.5x83.5@2x.png and vcmi/client/ios/Images.xcassets/AppIcon.appiconset/Icon-App-83.5x83.5@2x.png differ
diff --color -urN vcmi-1.5.7/client/ios/Images.xcassets/Contents.json vcmi/client/ios/Images.xcassets/Contents.json
--- vcmi-1.5.7/client/ios/Images.xcassets/Contents.json	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/ios/Images.xcassets/Contents.json	1970-01-01 01:00:00.000000000 +0100
@@ -1,6 +0,0 @@
-{
-  "info" : {
-    "author" : "xcode",
-    "version" : 1
-  }
-}
diff --color -urN vcmi-1.5.7/client/ios/Info.plist vcmi/client/ios/Info.plist
--- vcmi-1.5.7/client/ios/Info.plist	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/ios/Info.plist	1970-01-01 01:00:00.000000000 +0100
@@ -1,62 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
-<plist version="1.0">
-<dict>
-	<key>CFBundleDevelopmentRegion</key>
-	<string>en</string>
-	<key>CFBundleExecutable</key>
-	<string>$(PRODUCT_NAME)</string>
-	<key>CFBundleIdentifier</key>
-	<string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
-	<key>CFBundleInfoDictionaryVersion</key>
-	<string>6.0</string>
-	<key>CFBundleName</key>
-	<string>$(APP_DISPLAY_NAME)</string>
-	<key>CFBundlePackageType</key>
-	<string>APPL</string>
-	<key>CFBundleShortVersionString</key>
-	<string>$(MARKETING_VERSION)</string>
-	<key>CFBundleSignature</key>
-	<string>????</string>
-	<key>CFBundleURLTypes</key>
-	<array>
-		<dict>
-			<key>CFBundleURLSchemes</key>
-			<array>
-				<string>vcmi</string>
-			</array>
-		</dict>
-	</array>
-	<key>CFBundleVersion</key>
-	<string>1</string>
-	<key>LSRequiresIPhoneOS</key>
-	<true/>
-	<key>LSSupportsOpeningDocumentsInPlace</key>
-	<true/>
-	<key>NSAppTransportSecurity</key>
-	<dict>
-		<key>NSAllowsArbitraryLoads</key>
-		<true/>
-	</dict>
-	<key>UIApplicationSupportsIndirectInputEvents</key>
-	<true/>
-	<key>UIFileSharingEnabled</key>
-	<true/>
-	<key>UILaunchStoryboardName</key>
-	<string>LaunchScreen</string>
-	<key>UIRequiredDeviceCapabilities</key>
-	<array>
-		<string>armv7</string>
-		<string>opengles-2</string>
-	</array>
-	<key>UIRequiresFullScreen</key>
-	<true/>
-	<key>UIStatusBarHidden</key>
-	<true/>
-	<key>UISupportedInterfaceOrientations</key>
-	<array>
-		<string>UIInterfaceOrientationLandscapeLeft</string>
-		<string>UIInterfaceOrientationLandscapeRight</string>
-	</array>
-</dict>
-</plist>
diff --color -urN vcmi-1.5.7/client/ios/LaunchScreen.storyboard vcmi/client/ios/LaunchScreen.storyboard
--- vcmi-1.5.7/client/ios/LaunchScreen.storyboard	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/ios/LaunchScreen.storyboard	1970-01-01 01:00:00.000000000 +0100
@@ -1,39 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="20037" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" launchScreen="YES" useTraitCollections="YES" useSafeAreas="YES" colorMatched="YES" initialViewController="01J-lp-oVM">
-    <device id="retina4_7" orientation="portrait" appearance="light"/>
-    <dependencies>
-        <deployment identifier="iOS"/>
-        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="20020"/>
-        <capability name="Safe area layout guides" minToolsVersion="9.0"/>
-        <capability name="documents saved in the Xcode 8 format" minToolsVersion="8.0"/>
-    </dependencies>
-    <scenes>
-        <!--View Controller-->
-        <scene sceneID="EHf-IW-A2E">
-            <objects>
-                <viewController id="01J-lp-oVM" sceneMemberID="viewController">
-                    <view key="view" contentMode="scaleToFill" id="Ze5-6b-2t3">
-                        <rect key="frame" x="0.0" y="0.0" width="375" height="667"/>
-                        <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
-                        <subviews>
-                            <imageView clipsSubviews="YES" userInteractionEnabled="NO" contentMode="scaleAspectFit" horizontalHuggingPriority="251" verticalHuggingPriority="251" image="vcmi_logo.png" translatesAutoresizingMaskIntoConstraints="NO" id="xBx-rS-h4V">
-                                <rect key="frame" x="87.5" y="233.5" width="200" height="200"/>
-                            </imageView>
-                        </subviews>
-                        <viewLayoutGuide key="safeArea" id="Jnx-JV-IwA"/>
-                        <color key="backgroundColor" white="0.0" alpha="1" colorSpace="custom" customColorSpace="genericGamma22GrayColorSpace"/>
-                        <constraints>
-                            <constraint firstItem="xBx-rS-h4V" firstAttribute="centerY" secondItem="Jnx-JV-IwA" secondAttribute="centerY" id="OgR-oG-SHt"/>
-                            <constraint firstItem="xBx-rS-h4V" firstAttribute="centerX" secondItem="Jnx-JV-IwA" secondAttribute="centerX" id="eTp-at-qVT"/>
-                        </constraints>
-                    </view>
-                </viewController>
-                <placeholder placeholderIdentifier="IBFirstResponder" id="iYj-Kq-Ea1" userLabel="First Responder" sceneMemberID="firstResponder"/>
-            </objects>
-            <point key="canvasLocation" x="53" y="375"/>
-        </scene>
-    </scenes>
-    <resources>
-        <image name="vcmi_logo.png" width="200" height="200"/>
-    </resources>
-</document>
diff --color -urN vcmi-1.5.7/client/ios/main.m vcmi/client/ios/main.m
--- vcmi-1.5.7/client/ios/main.m	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/ios/main.m	1970-01-01 01:00:00.000000000 +0100
@@ -1,63 +0,0 @@
-/*
- * main.m, part of VCMI engine
- *
- * Authors: listed in file AUTHORS in main folder
- *
- * License: GNU General Public License v2.0 or later
- * Full text of license available in license.txt file, in main folder
- *
- */
-#import "startSDL.h"
-
-#import <UIKit/UIKit.h>
-
-#import <objc/runtime.h>
-
-#include <stdlib.h>
-
-static void startSDLManually(int argc, char * argv[])
-{
-	id<UIApplicationDelegate> appDelegate;
-	@autoreleasepool {
-		__auto_type sdlAppDelegateClass = NSClassFromString(@"SDLUIKitDelegate");
-		NSCAssert(sdlAppDelegateClass != nil, @"SDL AppDelegate class doesn't exist");
-		NSCAssert(class_conformsToProtocol(sdlAppDelegateClass, @protocol(UIApplicationDelegate)), @"SDL AppDelegate doesn't conform to UIApplicationDelegate");
-		appDelegate = [sdlAppDelegateClass new];
-	}
-	UIApplication.sharedApplication.delegate = appDelegate;
-
-	int result = startSDL(argc, argv, YES);
-	exit(result);
-}
-
-int qt_main_wrapper(int argc, char * argv[]);
-
-int client_main(int argc, char * argv[])
-{
-	NSInteger launchType;
-	__auto_type envVar = getenv("VCMI_LAUNCH_TYPE");
-	if (envVar)
-		launchType = envVar[0] == '0' ? 0 : 1;
-	else {
-		@autoreleasepool {
-			launchType = [NSUserDefaults.standardUserDefaults integerForKey:@"LaunchType"];
-		}
-	}
-	if (launchType == 1)
-		return startSDL(argc, argv, NO);
-
-	@autoreleasepool {
-		id __block startGameObserver = [NSNotificationCenter.defaultCenter addObserverForName:@"StartGame" object:nil queue:nil usingBlock:^(NSNotification * _Nonnull note) {
-			[NSNotificationCenter.defaultCenter removeObserver:startGameObserver];
-			startGameObserver = nil;
-
-			NSArray<NSString *> * args = note.userInfo[@"args"];
-			const char * newArgv[args.count];
-			NSUInteger i = 0;
-			for (NSString * obj in args)
-				newArgv[i++] = obj.UTF8String;
-			startSDLManually(args.count, (char **)(newArgv));
-		}];
-		return qt_main_wrapper(argc, argv);
-	}
-}
diff --color -urN vcmi-1.5.7/client/ios/Settings.bundle/en.lproj/Root.strings vcmi/client/ios/Settings.bundle/en.lproj/Root.strings
--- vcmi-1.5.7/client/ios/Settings.bundle/en.lproj/Root.strings	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/ios/Settings.bundle/en.lproj/Root.strings	1970-01-01 01:00:00.000000000 +0100
@@ -1,6 +0,0 @@
-"LaunchType" = "App start type";
-"Launcher" = "Launcher";
-"Game" = "Game";
-
-"AppVersion" = "Application version";
-"BuildVersion" = "Build version";
diff --color -urN vcmi-1.5.7/client/ios/Settings.bundle/Root.plist vcmi/client/ios/Settings.bundle/Root.plist
--- vcmi-1.5.7/client/ios/Settings.bundle/Root.plist	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/ios/Settings.bundle/Root.plist	1970-01-01 01:00:00.000000000 +0100
@@ -1,51 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
-<plist version="1.0">
-<dict>
-	<key>StringsTable</key>
-	<string>Root</string>
-	<key>PreferenceSpecifiers</key>
-	<array>
-		<dict>
-			<key>Type</key>
-			<string>PSTitleValueSpecifier</string>
-			<key>Title</key>
-			<string>AppVersion</string>
-			<key>Key</key>
-			<string>foo1</string>
-			<key>DefaultValue</key>
-			<string></string>
-		</dict>
-		<dict>
-			<key>Type</key>
-			<string>PSTitleValueSpecifier</string>
-			<key>Title</key>
-			<string>BuildVersion</string>
-			<key>Key</key>
-			<string>foo2</string>
-			<key>DefaultValue</key>
-			<string></string>
-		</dict>
-		<dict>
-			<key>Type</key>
-			<string>PSRadioGroupSpecifier</string>
-			<key>Title</key>
-			<string>LaunchType</string>
-			<key>Key</key>
-			<string>LaunchType</string>
-			<key>DefaultValue</key>
-			<integer>0</integer>
-			<key>Values</key>
-			<array>
-				<integer>0</integer>
-				<integer>1</integer>
-			</array>
-			<key>Titles</key>
-			<array>
-				<string>Launcher</string>
-				<string>Game</string>
-			</array>
-		</dict>
-	</array>
-</dict>
-</plist>
diff --color -urN vcmi-1.5.7/client/ios/Settings.bundle/ru.lproj/Root.strings vcmi/client/ios/Settings.bundle/ru.lproj/Root.strings
--- vcmi-1.5.7/client/ios/Settings.bundle/ru.lproj/Root.strings	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/ios/Settings.bundle/ru.lproj/Root.strings	1970-01-01 01:00:00.000000000 +0100
@@ -1,6 +0,0 @@
-"LaunchType" = "  ";
-"Launcher" = " ()";
-"Game" = "";
-
-"AppVersion" = " ";
-"BuildVersion" = " ";
diff --color -urN vcmi-1.5.7/client/ios/startSDL.h vcmi/client/ios/startSDL.h
--- vcmi-1.5.7/client/ios/startSDL.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/ios/startSDL.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,19 +0,0 @@
-/*
- * startSDL.h, part of VCMI engine
- *
- * Authors: listed in file AUTHORS in main folder
- *
- * License: GNU General Public License v2.0 or later
- * Full text of license available in license.txt file, in main folder
- *
- */
-#pragma once
-
-#ifdef __OBJC__
-#include <objc/objc.h>
-#endif
-
-#ifdef __cplusplus
-extern "C"
-#endif
-int startSDL(int argc, char * argv[], BOOL startManually);
diff --color -urN vcmi-1.5.7/client/ios/startSDL.mm vcmi/client/ios/startSDL.mm
--- vcmi-1.5.7/client/ios/startSDL.mm	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/ios/startSDL.mm	1970-01-01 01:00:00.000000000 +0100
@@ -1,59 +0,0 @@
-/*
- * startSDL.mm, part of VCMI engine
- *
- * Authors: listed in file AUTHORS in main folder
- *
- * License: GNU General Public License v2.0 or later
- * Full text of license available in license.txt file, in main folder
- *
- */
-#include "StdInc.h"
-#import "startSDL.h"
-#import "GameChatKeyboardHandler.h"
-
-#include "../Global.h"
-#include "CMT.h"
-#include "CServerHandler.h"
-#include "CFocusableHelper.h"
-
-#include <SDL_main.h>
-#include <SDL_events.h>
-#include <SDL_render.h>
-#include <SDL_system.h>
-
-#import <UIKit/UIKit.h>
-
-@interface SDLViewObserver : NSObject <UIGestureRecognizerDelegate>
-@property (nonatomic, strong) GameChatKeyboardHandler * gameChatHandler;
-@end
-
-@implementation SDLViewObserver
-
-@end
-
-int startSDL(int argc, char * argv[], BOOL startManually)
-{
-	@autoreleasepool {
-		auto observer = [SDLViewObserver new];
-		observer.gameChatHandler = [GameChatKeyboardHandler new];
-
-		id textFieldObserver = [NSNotificationCenter.defaultCenter addObserverForName:UITextFieldTextDidEndEditingNotification object:nil queue:nil usingBlock:^(NSNotification * _Nonnull note) {
-			removeFocusFromActiveInput();
-		}];
-
-		int result;
-		if (startManually)
-		{
-			// copied from -[SDLUIKitDelegate postFinishLaunch]
-			SDL_SetMainReady();
-			SDL_iOSSetEventPump(SDL_TRUE);
-			result = SDL_main(argc, argv);
-			SDL_iOSSetEventPump(SDL_FALSE);
-		}
-		else
-			result = SDL_UIKitRunApp(argc, argv, SDL_main);
-
-		[NSNotificationCenter.defaultCenter removeObserver:textFieldObserver];
-		return result;
-	}
-}
Binary files vcmi-1.5.7/client/ios/vcmi_logo.png and vcmi/client/ios/vcmi_logo.png differ
diff --color -urN vcmi-1.5.7/client/lobby/CBonusSelection.cpp vcmi/client/lobby/CBonusSelection.cpp
--- vcmi-1.5.7/client/lobby/CBonusSelection.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/lobby/CBonusSelection.cpp	2024-12-19 15:00:22.255121365 +0100
@@ -18,17 +18,17 @@
 #include "ExtraOptionsTab.h"
 
 #include "../CGameInfo.h"
-#include "../CMusicHandler.h"
-#include "../CVideoHandler.h"
 #include "../CPlayerInterface.h"
 #include "../CServerHandler.h"
 #include "../mainmenu/CMainMenu.h"
 #include "../mainmenu/CPrologEpilogVideo.h"
+#include "../media/IMusicPlayer.h"
 #include "../widgets/CComponent.h"
 #include "../widgets/Buttons.h"
 #include "../widgets/MiscWidgets.h"
 #include "../widgets/ObjectLists.h"
 #include "../widgets/TextControls.h"
+#include "../widgets/VideoWidget.h"
 #include "../windows/GUIClasses.h"
 #include "../windows/InfoWindows.h"
 #include "../render/IImage.h"
@@ -38,25 +38,28 @@
 #include "../gui/CGuiHandler.h"
 #include "../gui/Shortcut.h"
 #include "../gui/WindowHandler.h"
+#include "../adventureMap/AdventureMapInterface.h"
 
-#include "../../lib/filesystem/Filesystem.h"
-#include "../../lib/CGeneralTextHandler.h"
-
-#include "../../lib/CBuildingHandler.h"
-
-#include "../../lib/CSkillHandler.h"
-#include "../../lib/CTownHandler.h"
-#include "../../lib/CHeroHandler.h"
+#include "../../lib/CConfigHandler.h"
 #include "../../lib/CCreatureHandler.h"
+#include "../../lib/CSkillHandler.h"
 #include "../../lib/StartInfo.h"
+#include "../../lib/entities/building/CBuilding.h"
+#include "../../lib/entities/building/CBuildingHandler.h"
+#include "../../lib/entities/faction/CFaction.h"
+#include "../../lib/entities/faction/CTown.h"
+#include "../../lib/entities/faction/CTownHandler.h"
+#include "../../lib/entities/hero/CHeroHandler.h"
+#include "../../lib/filesystem/Filesystem.h"
+#include "../../lib/texts/CGeneralTextHandler.h"
 
 #include "../../lib/campaign/CampaignState.h"
 #include "../../lib/mapping/CMapService.h"
 #include "../../lib/mapping/CMapInfo.h"
+#include "../../lib/mapping/CMapHeader.h"
 
 #include "../../lib/mapObjects/CGHeroInstance.h"
 
-
 std::shared_ptr<CampaignState> CBonusSelection::getCampaign()
 {
 	return CSH->si->campState;
@@ -65,7 +68,7 @@
 CBonusSelection::CBonusSelection()
 	: CWindowObject(BORDERED)
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 
 	setBackground(getCampaign()->getRegions().getBackgroundName());
 
@@ -85,16 +88,18 @@
 	buttonVideo = std::make_shared<CButton>(Point(705, 214), AnimationPath::builtin("CBVIDEB.DEF"), CButton::tooltip(), playVideo, EShortcut::LOBBY_REPLAY_VIDEO);
 	buttonBack = std::make_shared<CButton>(Point(624, 536), AnimationPath::builtin("CBCANCB.DEF"), CButton::tooltip(), std::bind(&CBonusSelection::goBack, this), EShortcut::GLOBAL_CANCEL);
 
-	campaignName = std::make_shared<CLabel>(481, 28, FONT_BIG, ETextAlignment::TOPLEFT, Colors::YELLOW, CSH->si->getCampaignName());
+	campaignName = std::make_shared<CLabel>(481, 28, FONT_BIG, ETextAlignment::TOPLEFT, Colors::YELLOW, CSH->si->getCampaignName(), 250);
 
 	iconsMapSizes = std::make_shared<CAnimImage>(AnimationPath::builtin("SCNRMPSZ"), 4, 0, 735, 26);
 
 	labelCampaignDescription = std::make_shared<CLabel>(481, 63, FONT_SMALL, ETextAlignment::TOPLEFT, Colors::YELLOW, CGI->generaltexth->allTexts[38]);
 	campaignDescription = std::make_shared<CTextBox>(getCampaign()->getDescriptionTranslated(), Rect(480, 86, 286, 117), 1);
 
-	mapName = std::make_shared<CLabel>(481, 219, FONT_BIG, ETextAlignment::TOPLEFT, Colors::YELLOW, CSH->mi->getNameTranslated());
+	bool videoButtonActive = CSH->getState() == EClientState::GAMEPLAY;
+	int availableSpace = videoButtonActive ? 225 : 285;
+	mapName = std::make_shared<CLabel>(481, 219, FONT_BIG, ETextAlignment::TOPLEFT, Colors::YELLOW, CSH->mi->getNameTranslated(), availableSpace );
 	labelMapDescription = std::make_shared<CLabel>(481, 253, FONT_SMALL, ETextAlignment::TOPLEFT, Colors::YELLOW, CGI->generaltexth->allTexts[496]);
-	mapDescription = std::make_shared<CTextBox>("", Rect(480, 278, 292, 108), 1);
+	mapDescription = std::make_shared<CTextBox>("", Rect(480, 278, 286, 108), 1);
 
 	labelChooseBonus = std::make_shared<CLabel>(475, 432, FONT_SMALL, ETextAlignment::TOPLEFT, Colors::WHITE, CGI->generaltexth->allTexts[71]);
 	groupBonuses = std::make_shared<CToggleGroup>(std::bind(&IServerAPI::setCampaignBonus, CSH, _1));
@@ -123,9 +128,11 @@
 	for(auto scenarioID : getCampaign()->allScenarios())
 	{
 		if(getCampaign()->isAvailable(scenarioID))
-			regions.push_back(std::make_shared<CRegion>(scenarioID, true, true, getCampaign()->getRegions()));
+			regions.push_back(std::make_shared<CRegion>(scenarioID, true, true, false, getCampaign()->getRegions()));
 		else if(getCampaign()->isConquered(scenarioID)) //display as striped
-			regions.push_back(std::make_shared<CRegion>(scenarioID, false, false, getCampaign()->getRegions()));
+			regions.push_back(std::make_shared<CRegion>(scenarioID, false, false, false, getCampaign()->getRegions()));
+		else
+			regions.push_back(std::make_shared<CRegion>(scenarioID, false, false, true, getCampaign()->getRegions()));
 	}
 
 	if (!getCampaign()->getMusic().empty())
@@ -144,7 +151,7 @@
 
 void CBonusSelection::createBonusesIcons()
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 	const CampaignScenario & scenario = getCampaign()->scenario(CSH->campaignMap);
 	const std::vector<CampaignBonus> & bonDescs = scenario.travelOptions.bonusesToChoose;
 	groupBonuses = std::make_shared<CToggleGroup>(std::bind(&IServerAPI::setCampaignBonus, CSH, _1));
@@ -311,7 +318,10 @@
 			break;
 		}
 
-		std::shared_ptr<CToggleButton> bonusButton = std::make_shared<CToggleButton>(Point(475 + i * 68, 455), AnimationPath::builtin("campaignBonusSelection"), CButton::tooltip(desc.toString(), desc.toString()));
+		std::shared_ptr<CToggleButton> bonusButton = std::make_shared<CToggleButton>(Point(475 + i * 68, 455), AnimationPath::builtin("campaignBonusSelection"), CButton::tooltip(desc.toString(), desc.toString()), nullptr, EShortcut::NONE, false, [this](){
+			if(buttonStart->isActive() && !buttonStart->isBlocked())	
+				CBonusSelection::startMap();
+		});
 
 		if(picNumber != -1)
 			bonusButton->setOverlay(std::make_shared<CAnimImage>(AnimationPath::builtin(picName), picNumber));
@@ -380,10 +390,13 @@
 	if(CSH->getState() != EClientState::GAMEPLAY)
 	{
 		GH.windows().popWindows(2);
+		CMM->playMusic();
 	}
 	else
 	{
 		close();
+		if(adventureInt)
+			adventureInt->onAudioResumed();
 	}
 	// TODO: we can actually only pop bonus selection interface for custom campaigns
 	// Though this would require clearing CLobbyScreen::bonusSel pointer when poping this interface
@@ -470,10 +483,10 @@
 		CSH->setDifficulty(CSH->si->difficulty - 1);
 }
 
-CBonusSelection::CRegion::CRegion(CampaignScenarioID id, bool accessible, bool selectable, const CampaignRegions & campDsc)
-	: CIntObject(LCLICK | SHOW_POPUP), idOfMapAndRegion(id), accessible(accessible), selectable(selectable)
+CBonusSelection::CRegion::CRegion(CampaignScenarioID id, bool accessible, bool selectable, bool labelOnly, const CampaignRegions & campDsc)
+	: CIntObject(LCLICK | SHOW_POPUP), idOfMapAndRegion(id), accessible(accessible), selectable(selectable), labelOnly(labelOnly)
 {
-	OBJ_CONSTRUCTION;
+	OBJECT_CONSTRUCTION;
 
 	pos += campDsc.getPosition(id);
 
@@ -487,10 +500,20 @@
 	graphicsStriped->disable();
 	pos.w = graphicsNotSelected->pos.w;
 	pos.h = graphicsNotSelected->pos.h;
+
+	auto labelPos = campDsc.getLabelPosition(id);
+	if(labelPos)
+	{
+		auto mapHeader = CSH->si->campState->getMapHeader(idOfMapAndRegion);
+		label = std::make_shared<CLabel>((*labelPos).x, (*labelPos).y, FONT_SMALL, ETextAlignment::CENTER, Colors::WHITE, mapHeader->name.toString());
+	}
 }
 
 void CBonusSelection::CRegion::updateState()
 {
+	if(labelOnly)
+		return;
+
 	if(!accessible)
 	{
 		graphicsNotSelected->disable();
@@ -513,7 +536,7 @@
 
 void CBonusSelection::CRegion::clickReleased(const Point & cursorPosition)
 {
-	if(selectable && !graphicsNotSelected->getSurface()->isTransparent(cursorPosition - pos.topLeft()))
+	if(!labelOnly && selectable && !graphicsNotSelected->getSurface()->isTransparent(cursorPosition - pos.topLeft()))
 	{
 		CSH->setCampaignMap(idOfMapAndRegion);
 	}
@@ -523,7 +546,7 @@
 {
 	// FIXME: For some reason "down" is only ever contain indeterminate_value
 	auto & text = CSH->si->campState->scenario(idOfMapAndRegion).regionText;
-	if(!graphicsNotSelected->getSurface()->isTransparent(cursorPosition - pos.topLeft()) && !text.empty())
+	if(!labelOnly && !graphicsNotSelected->getSurface()->isTransparent(cursorPosition - pos.topLeft()) && !text.empty())
 	{
 		CRClickPopup::createAndPush(text.toString());
 	}
diff --color -urN vcmi-1.5.7/client/lobby/CBonusSelection.h vcmi/client/lobby/CBonusSelection.h
--- vcmi-1.5.7/client/lobby/CBonusSelection.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/lobby/CBonusSelection.h	2024-12-19 15:00:22.255121365 +0100
@@ -12,6 +12,7 @@
 #include "../windows/CWindowObject.h"
 
 #include "../lib/campaign/CampaignConstants.h"
+#include "../lib/filesystem/ResourcePath.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
@@ -28,6 +29,9 @@
 class CFlagBox;
 class ISelectionScreenInfo;
 class ExtraOptionsTab;
+class VideoWidgetOnce;
+class CBonusSelection;
+
 
 /// Campaign screen where you can choose one out of three starting bonuses
 class CBonusSelection : public CWindowObject
@@ -45,8 +49,10 @@
 		CampaignScenarioID idOfMapAndRegion;
 		bool accessible; // false if region should be striped
 		bool selectable; // true if region should be selectable
+		bool labelOnly;
+		std::shared_ptr<CLabel> label;
 	public:
-		CRegion(CampaignScenarioID id, bool accessible, bool selectable, const CampaignRegions & campDsc);
+		CRegion(CampaignScenarioID id, bool accessible, bool selectable, bool labelOnly, const CampaignRegions & campDsc);
 		void updateState();
 		void clickReleased(const Point & cursorPosition) override;
 		void showPopupWindow(const Point & cursorPosition) override;
diff --color -urN vcmi-1.5.7/client/lobby/CCampaignInfoScreen.cpp vcmi/client/lobby/CCampaignInfoScreen.cpp
--- vcmi-1.5.7/client/lobby/CCampaignInfoScreen.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/lobby/CCampaignInfoScreen.cpp	2024-12-19 15:00:22.256121406 +0100
@@ -12,7 +12,7 @@
 #include "CCampaignInfoScreen.h"
 
 #include "../../CCallback.h"
-#include "../../lib/CGeneralTextHandler.h"
+#include "../../lib/texts/CGeneralTextHandler.h"
 #include "../../lib/StartInfo.h"
 #include "../../lib/mapping/CMapInfo.h"
 #include "../../lib/mapping/CMapHeader.h"
@@ -22,7 +22,7 @@
 
 CCampaignInfoScreen::CCampaignInfoScreen()
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 	localSi = new StartInfo(*LOCPLINT->cb->getStartInfo());
 	localMi = new CMapInfo();
 	localMi->mapHeader = std::unique_ptr<CMapHeader>(new CMapHeader(*LOCPLINT->cb->getMapHeader()));
diff --color -urN vcmi-1.5.7/client/lobby/CLobbyScreen.cpp vcmi/client/lobby/CLobbyScreen.cpp
--- vcmi-1.5.7/client/lobby/CLobbyScreen.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/lobby/CLobbyScreen.cpp	2024-12-19 15:00:22.256121406 +0100
@@ -28,7 +28,7 @@
 #include "../../CCallback.h"
 
 #include "../../lib/CConfigHandler.h"
-#include "../../lib/CGeneralTextHandler.h"
+#include "../../lib/texts/CGeneralTextHandler.h"
 #include "../../lib/campaign/CampaignHandler.h"
 #include "../../lib/mapping/CMapInfo.h"
 #include "../../lib/networkPacks/PacksForLobby.h"
@@ -38,7 +38,7 @@
 CLobbyScreen::CLobbyScreen(ESelectionScreen screenType)
 	: CSelectionBase(screenType), bonusSel(nullptr)
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 	tabSel = std::make_shared<SelectionTab>(screenType);
 	curTab = tabSel;
 
@@ -188,7 +188,7 @@
 		return;
 
 	auto buttonColor = host ? Colors::WHITE : Colors::ORANGE;
-	buttonSelect->setTextOverlay(CGI->generaltexth->allTexts[500], FONT_SMALL, buttonColor);
+	buttonSelect->setTextOverlay("  " + CGI->generaltexth->allTexts[500], FONT_SMALL, buttonColor);
 	buttonOptions->setTextOverlay(CGI->generaltexth->allTexts[501], FONT_SMALL, buttonColor);
 
 	if (buttonTurnOptions)
@@ -199,7 +199,7 @@
 
 	if(buttonRMG)
 	{
-		buttonRMG->setTextOverlay(CGI->generaltexth->allTexts[740], FONT_SMALL, buttonColor);
+		buttonRMG->setTextOverlay("  " + CGI->generaltexth->allTexts[740], FONT_SMALL, buttonColor);
 		buttonRMG->block(!host);
 	}
 	buttonSelect->block(!host);
diff --color -urN vcmi-1.5.7/client/lobby/CSavingScreen.cpp vcmi/client/lobby/CSavingScreen.cpp
--- vcmi-1.5.7/client/lobby/CSavingScreen.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/lobby/CSavingScreen.cpp	2024-12-19 15:00:22.256121406 +0100
@@ -21,7 +21,7 @@
 
 #include "../../CCallback.h"
 #include "../../lib/CConfigHandler.h"
-#include "../../lib/CGeneralTextHandler.h"
+#include "../../lib/texts/CGeneralTextHandler.h"
 #include "../../lib/StartInfo.h"
 #include "../../lib/filesystem/Filesystem.h"
 #include "../../lib/mapping/CMapInfo.h"
@@ -30,7 +30,7 @@
 CSavingScreen::CSavingScreen()
 	: CSelectionBase(ESelectionScreen::saveGame)
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 	center(pos);
 	localMi = std::make_shared<CMapInfo>();
 	localMi->mapHeader = std::unique_ptr<CMapHeader>(new CMapHeader(*LOCPLINT->cb->getMapHeader()));
diff --color -urN vcmi-1.5.7/client/lobby/CScenarioInfoScreen.cpp vcmi/client/lobby/CScenarioInfoScreen.cpp
--- vcmi-1.5.7/client/lobby/CScenarioInfoScreen.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/lobby/CScenarioInfoScreen.cpp	2024-12-19 15:00:22.256121406 +0100
@@ -20,14 +20,14 @@
 
 #include "../../CCallback.h"
 
-#include "../../lib/CGeneralTextHandler.h"
+#include "../../lib/texts/CGeneralTextHandler.h"
 #include "../../lib/StartInfo.h"
 #include "../../lib/mapping/CMapInfo.h"
 #include "../../lib/mapping/CMapHeader.h"
 
 CScenarioInfoScreen::CScenarioInfoScreen()
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 	pos.w = 800;
 	pos.h = 600;
 	pos = center();
diff --color -urN vcmi-1.5.7/client/lobby/CSelectionBase.cpp vcmi/client/lobby/CSelectionBase.cpp
--- vcmi-1.5.7/client/lobby/CSelectionBase.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/lobby/CSelectionBase.cpp	2024-12-19 15:00:22.256121406 +0100
@@ -20,14 +20,13 @@
 
 #include "../CGameInfo.h"
 #include "../CPlayerInterface.h"
-#include "../CMusicHandler.h"
-#include "../CVideoHandler.h"
 #include "../CServerHandler.h"
 #include "../gui/CGuiHandler.h"
 #include "../gui/Shortcut.h"
 #include "../gui/WindowHandler.h"
 #include "../globalLobby/GlobalLobbyClient.h"
 #include "../mainmenu/CMainMenu.h"
+#include "../media/ISoundPlayer.h"
 #include "../widgets/Buttons.h"
 #include "../widgets/CComponent.h"
 #include "../widgets/CTextInput.h"
@@ -44,16 +43,16 @@
 #include "../render/IFont.h"
 #include "../render/IRenderHandler.h"
 
-#include "../../lib/CGeneralTextHandler.h"
-#include "../../lib/CHeroHandler.h"
-#include "../../lib/CTownHandler.h"
 #include "../../lib/CRandomGenerator.h"
 #include "../../lib/CThreadHelper.h"
-#include "../../lib/MetaString.h"
 #include "../../lib/filesystem/Filesystem.h"
 #include "../../lib/mapping/CMapHeader.h"
 #include "../../lib/mapping/CMapInfo.h"
 #include "../../lib/networkPacks/PacksForLobby.h"
+#include "../../lib/texts/CGeneralTextHandler.h"
+#include "../../lib/entities/faction/CFaction.h"
+#include "../../lib/entities/faction/CTown.h"
+#include "../../lib/entities/faction/CTownHandler.h"
 
 ISelectionScreenInfo::ISelectionScreenInfo(ESelectionScreen ScreenType)
 	: screenType(ScreenType)
@@ -81,7 +80,7 @@
 CSelectionBase::CSelectionBase(ESelectionScreen type)
 	: CWindowObject(BORDERED | SHADOW_DISABLED), ISelectionScreenInfo(type)
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 	pos.w = 762;
 	pos.h = 584;
 	if(screenType == ESelectionScreen::campaignList)
@@ -102,14 +101,12 @@
 {
 	if(curTab && curTab->isActive())
 	{
-		curTab->deactivate();
-		curTab->recActions = 0;
+		curTab->disable();
 	}
 
 	if(curTab != tab)
 	{
-		tab->recActions = 255 - DISPOSE;
-		tab->activate();
+		tab->enable();
 		curTab = tab;
 	}
 	else
@@ -130,14 +127,14 @@
 InfoCard::InfoCard()
 	: showChat(true)
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 	setRedrawParent(true);
 	pos.x += 393;
 	pos.y += 6;
 
 	labelSaveDate = std::make_shared<CLabel>(310, 38, FONT_SMALL, ETextAlignment::BOTTOMRIGHT, Colors::WHITE);
 	labelMapSize = std::make_shared<CLabel>(333, 56, FONT_TINY, ETextAlignment::CENTER, Colors::WHITE);
-	mapName = std::make_shared<CLabel>(26, 39, FONT_BIG, ETextAlignment::TOPLEFT, Colors::YELLOW, "", 285);
+	mapName = std::make_shared<CLabel>(26, 39, FONT_BIG, ETextAlignment::TOPLEFT, Colors::YELLOW, "", SEL->screenType == ESelectionScreen::campaignList ? 325 : 285);
 	Rect descriptionRect(26, 149, 320, 115);
 	mapDescription = std::make_shared<CTextBox>("", descriptionRect, 1);
 	playerListBg = std::make_shared<CPicture>(ImagePath::builtin("CHATPLUG.bmp"), 16, 276);
@@ -190,8 +187,8 @@
 		iconsVictoryCondition = std::make_shared<CAnimImage>(AnimationPath::builtin("SCNRVICT"), 0, 0, 24, 302);
 		iconsLossCondition = std::make_shared<CAnimImage>(AnimationPath::builtin("SCNRLOSS"), 0, 0, 24, 359);
 
-		labelVictoryConditionText = std::make_shared<CLabel>(60, 307, FONT_SMALL, ETextAlignment::TOPLEFT, Colors::WHITE);
-		labelLossConditionText = std::make_shared<CLabel>(60, 366, FONT_SMALL, ETextAlignment::TOPLEFT, Colors::WHITE);
+		labelVictoryConditionText = std::make_shared<CLabel>(60, 307, FONT_SMALL, ETextAlignment::TOPLEFT, Colors::WHITE, "", 290);
+		labelLossConditionText = std::make_shared<CLabel>(60, 366, FONT_SMALL, ETextAlignment::TOPLEFT, Colors::WHITE, "", 290);
 
 		labelDifficulty = std::make_shared<CLabel>(62, 472, FONT_SMALL, ETextAlignment::CENTER, Colors::WHITE);
 		labelDifficultyPercent = std::make_shared<CLabel>(311, 472, FONT_SMALL, ETextAlignment::CENTER, Colors::WHITE);
@@ -252,21 +249,23 @@
 	const std::array<std::string, 5> difficultyPercent = {"80%", "100%", "130%", "160%", "200%"};
 	labelDifficultyPercent->setText(difficultyPercent[SEL->getCurrentDifficulty()]);
 
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 	// FIXME: We recreate them each time because CLabelGroup don't use smart pointers
 	labelGroupPlayers = std::make_shared<CLabelGroup>(FONT_SMALL, ETextAlignment::TOPLEFT, Colors::WHITE);
 	if(!showChat)
 		labelGroupPlayers->disable();
 
+	const auto & font = GH.renderHandler().loadFont(FONT_SMALL);
+
 	for(const auto & p : CSH->playerNames)
 	{
 		int slotsUsed = labelGroupPlayers->currentSize();
 		Point labelPosition;
 
 		if(slotsUsed < 4)
-			labelPosition = Point(24, 285 + slotsUsed * graphics->fonts[FONT_SMALL]->getLineHeight()); // left column
+			labelPosition = Point(24, 285 + slotsUsed * font->getLineHeight()); // left column
 		else
-			labelPosition = Point(193, 285 + (slotsUsed - 4) * graphics->fonts[FONT_SMALL]->getLineHeight()); // right column
+			labelPosition = Point(193, 285 + (slotsUsed - 4) * font->getLineHeight()); // right column
 
 		labelGroupPlayers->add(labelPosition.x, labelPosition.y, p.second.name);
 	}
@@ -356,11 +355,12 @@
 CChatBox::CChatBox(const Rect & rect)
 	: CIntObject(KEYBOARD | TEXTINPUT)
 {
-	OBJ_CONSTRUCTION;
+	OBJECT_CONSTRUCTION;
 	pos += rect.topLeft();
 	setRedrawParent(true);
 
-	const int height = static_cast<int>(graphics->fonts[FONT_SMALL]->getLineHeight());
+	const auto & font = GH.renderHandler().loadFont(FONT_SMALL);
+	const int height = font->getLineHeight();
 	Rect textInputArea(1, rect.h - height, rect.w - 1, height);
 	Rect chatHistoryArea(3, 1, rect.w - 3, rect.h - height - 1);
 	inputBackground = std::make_shared<TransparentFilledRectangle>(textInputArea, ColorRGBA(0,0,0,192));
@@ -397,19 +397,19 @@
 
 PvPBox::PvPBox(const Rect & rect)
 {
-	OBJ_CONSTRUCTION;
+	OBJECT_CONSTRUCTION;
 	pos += rect.topLeft();
 	setRedrawParent(true);
 
-	backgroundTexture = std::make_shared<FilledTexturePlayerColored>(ImagePath::builtin("DiBoxBck"), Rect(0, 0, rect.w, rect.h));
-	backgroundTexture->playerColored(PlayerColor(1));
+	backgroundTexture = std::make_shared<FilledTexturePlayerColored>(Rect(0, 0, rect.w, rect.h));
+	backgroundTexture->setPlayerColor(PlayerColor(1));
 	backgroundBorder = std::make_shared<TransparentFilledRectangle>(Rect(0, 0, rect.w, rect.h), ColorRGBA(0, 0, 0, 64), ColorRGBA(96, 96, 96, 255), 1);
 
 	townSelector = std::make_shared<TownSelector>(Point(5, 3));
 
 	auto getBannedTowns = [this](){
 		std::vector<FactionID> bannedTowns;
-		for(auto & town : townSelector->townsEnabled)
+		for(const auto & town : townSelector->townsEnabled)
 			if(!town.second)
 				bannedTowns.push_back(town.first);
 		return bannedTowns;
@@ -437,20 +437,27 @@
 		CSH->sendLobbyPack(lpa);
 	}, EShortcut::LOBBY_RANDOM_TOWN_VS);
 	buttonRandomTownVs->setTextOverlay(CGI->generaltexth->translate("vcmi.lobby.pvp.randomTownVs.hover"), EFonts::FONT_SMALL, Colors::WHITE);
+
+	buttonHandicap = std::make_shared<CButton>(Point(190, 81), AnimationPath::builtin("GSPBUT2.DEF"), CButton::tooltip("", CGI->generaltexth->translate("vcmi.lobby.handicap")), [](){
+		if(!CSH->isHost())
+			return;
+		GH.windows().createAndPushWindow<OptionsTab::HandicapWindow>();
+	}, EShortcut::LOBBY_HANDICAP);
+	buttonHandicap->setTextOverlay(CGI->generaltexth->translate("vcmi.lobby.handicap"), EFonts::FONT_SMALL, Colors::WHITE);
 }
 
 TownSelector::TownSelector(const Point & loc)
 {
-	OBJ_CONSTRUCTION;
+	OBJECT_CONSTRUCTION;
 	pos += loc;
 	setRedrawParent(true);
 
 	int count = 0;
-	for(auto const & factionID : VLC->townh->getDefaultAllowed())
+	for(auto const & factionID : CGI->townh->getDefaultAllowed())
 	{
 		townsEnabled[factionID] = true;
 		count++;
-	};
+	}
 
 	auto divisionRoundUp = [](int x, int y){ return (x + (y - 1)) / y; };
 
@@ -466,7 +473,7 @@
 
 void TownSelector::updateListItems()
 {
-	OBJ_CONSTRUCTION;
+	OBJECT_CONSTRUCTION;
 	int line = slider ? slider->getValue() : 0;
 	int x_offset = slider ? 0 : 8;
 	
@@ -475,20 +482,17 @@
 
 	int x = 0;
 	int y = 0;
-	CGI->factions()->forEach([this, &x, &y, line, x_offset](const Faction *entity, bool &stop){
-		if(!entity->hasTown())
-			return;
-
+	for (auto const & factionID : CGI->townh->getDefaultAllowed())
+	{
 		if(y >= line && (y - line) < 3)
 		{
-			FactionID factionID = entity->getFaction();
-			auto getImageIndex = [](FactionID factionID, bool enabled){ return (*CGI->townh)[factionID]->town->clientInfo.icons[true][!enabled] + 2; }; 
+			auto getImageIndex = [](FactionID targetFactionID, bool enabled){ return targetFactionID.toFaction()->town->clientInfo.icons[true][!enabled] + 2; };
 			towns[factionID] = std::make_shared<CAnimImage>(AnimationPath::builtin("ITPA"), getImageIndex(factionID, townsEnabled[factionID]), 0, x_offset + 48 * x, 32 * (y - line));
 			townsArea[factionID] = std::make_shared<LRClickableArea>(Rect(x_offset + 48 * x, 32 * (y - line), 48, 32), [this, getImageIndex, factionID](){
 				townsEnabled[factionID] = !townsEnabled[factionID];
 				towns[factionID]->setFrame(getImageIndex(factionID, townsEnabled[factionID]));
 				redraw();
-			}, [factionID](){ CRClickPopup::createAndPush((*CGI->townh)[factionID]->town->faction->getNameTranslated()); });
+			}, [factionID](){ CRClickPopup::createAndPush(factionID.toFaction()->town->faction->getNameTranslated()); });
 		}
 
 		if (x < 2)
@@ -498,7 +502,7 @@
 			x = 0;
 			y++;
 		}
-	});
+	}
 }
 
 void TownSelector::sliderMove(int slidPos)
@@ -515,25 +519,22 @@
 	pos += rect.topLeft();
 	pos.w = rect.w;
 	pos.h = rect.h;
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 
 	labelAllies = std::make_shared<CLabel>(0, 0, FONT_SMALL, ETextAlignment::TOPLEFT, Colors::WHITE, CGI->generaltexth->allTexts[390] + ":");
 	labelEnemies = std::make_shared<CLabel>(133, 0, FONT_SMALL, ETextAlignment::TOPLEFT, Colors::WHITE, CGI->generaltexth->allTexts[391] + ":");
-
-	iconsTeamFlags = GH.renderHandler().loadAnimation(AnimationPath::builtin("ITGFLAGS.DEF"));
-	iconsTeamFlags->preload();
 }
 
 void CFlagBox::recreate()
 {
 	flagsAllies.clear();
 	flagsEnemies.clear();
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 	const int alliesX = 5 + (int)labelAllies->getWidth();
 	const int enemiesX = 5 + 133 + (int)labelEnemies->getWidth();
 	for(auto i = CSH->si->playerInfos.cbegin(); i != CSH->si->playerInfos.cend(); i++)
 	{
-		auto flag = std::make_shared<CAnimImage>(iconsTeamFlags, i->first.getNum(), 0);
+		auto flag = std::make_shared<CAnimImage>(AnimationPath::builtin("ITGFLAGS.DEF"), i->first.getNum(), 0);
 		if(i->first == CSH->myFirstColor() || CSH->getPlayerTeamId(i->first) == CSH->getPlayerTeamId(CSH->myFirstColor()))
 		{
 			flag->moveTo(Point(pos.x + alliesX + (int)flagsAllies.size()*flag->pos.w, pos.y));
@@ -550,13 +551,13 @@
 void CFlagBox::showPopupWindow(const Point & cursorPosition)
 {
 	if(SEL->getMapInfo())
-		GH.windows().createAndPushWindow<CFlagBoxTooltipBox>(iconsTeamFlags);
+		GH.windows().createAndPushWindow<CFlagBoxTooltipBox>();
 }
 
-CFlagBox::CFlagBoxTooltipBox::CFlagBoxTooltipBox(std::shared_ptr<CAnimation> icons)
+CFlagBox::CFlagBoxTooltipBox::CFlagBoxTooltipBox()
 	: CWindowObject(BORDERED | RCLICK_POPUP | SHADOW_DISABLED, ImagePath::builtin("DIBOXBCK"))
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 
 	labelTeamAlignment = std::make_shared<CLabel>(128, 30, FONT_MEDIUM, ETextAlignment::CENTER, Colors::YELLOW, CGI->generaltexth->allTexts[657]);
 	labelGroupTeams = std::make_shared<CLabelGroup>(FONT_SMALL, ETextAlignment::CENTER, Colors::WHITE);
@@ -581,7 +582,7 @@
 		int curx = 128 - 9 * team.size();
 		for(const auto & player : team)
 		{
-			iconsFlags.push_back(std::make_shared<CAnimImage>(icons, player, 0, curx, 75 + 50 * curIdx));
+			iconsFlags.push_back(std::make_shared<CAnimImage>(AnimationPath::builtin("ITGFLAGS.DEF"), player, 0, curx, 75 + 50 * curIdx));
 			curx += 18;
 		}
 		++curIdx;
diff --color -urN vcmi-1.5.7/client/lobby/CSelectionBase.h vcmi/client/lobby/CSelectionBase.h
--- vcmi-1.5.7/client/lobby/CSelectionBase.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/lobby/CSelectionBase.h	2024-12-19 15:00:22.256121406 +0100
@@ -153,6 +153,7 @@
 	std::shared_ptr<CButton> buttonFlipCoin;
 	std::shared_ptr<CButton> buttonRandomTown;
 	std::shared_ptr<CButton> buttonRandomTownVs;
+	std::shared_ptr<CButton> buttonHandicap;
 public:
 	PvPBox(const Rect & rect);
 };
@@ -174,7 +175,6 @@
 
 class CFlagBox : public CIntObject
 {
-	std::shared_ptr<CAnimation> iconsTeamFlags;
 	std::shared_ptr<CLabel> labelAllies;
 	std::shared_ptr<CLabel> labelEnemies;
 	std::vector<std::shared_ptr<CAnimImage>> flagsAllies;
@@ -192,7 +192,7 @@
 		std::shared_ptr<CLabelGroup> labelGroupTeams;
 		std::vector<std::shared_ptr<CAnimImage>> iconsFlags;
 	public:
-		CFlagBoxTooltipBox(std::shared_ptr<CAnimation> icons);
+		CFlagBoxTooltipBox();
 	};
 };
 
diff --color -urN vcmi-1.5.7/client/lobby/OptionsTabBase.cpp vcmi/client/lobby/OptionsTabBase.cpp
--- vcmi-1.5.7/client/lobby/OptionsTabBase.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/lobby/OptionsTabBase.cpp	2024-12-19 15:00:22.257121448 +0100
@@ -18,11 +18,12 @@
 #include "../widgets/TextControls.h"
 #include "../CServerHandler.h"
 #include "../CGameInfo.h"
+#include "../render/AssetGenerator.h"
 
 #include "../../lib/StartInfo.h"
-#include "../../lib/Languages.h"
-#include "../../lib/MetaString.h"
-#include "../../lib/CGeneralTextHandler.h"
+#include "../../lib/texts/CGeneralTextHandler.h"
+#include "../../lib/texts/Languages.h"
+#include "../../lib/texts/MetaString.h"
 #include "../../lib/CConfigHandler.h"
 
 static std::string timeToString(int time)
@@ -68,6 +69,8 @@
 
 OptionsTabBase::OptionsTabBase(const JsonPath & configPath)
 {
+	AssetGenerator::createAdventureOptionsCleanBackground();
+
 	recActions = 0;
 
 	auto setTimerPresetCallback = [this](int index){
diff --color -urN vcmi-1.5.7/client/lobby/OptionsTab.cpp vcmi/client/lobby/OptionsTab.cpp
--- vcmi-1.5.7/client/lobby/OptionsTab.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/lobby/OptionsTab.cpp	2024-12-19 15:00:22.257121448 +0100
@@ -14,12 +14,13 @@
 
 #include "../CGameInfo.h"
 #include "../CServerHandler.h"
-#include "../CMusicHandler.h"
 #include "../gui/CGuiHandler.h"
 #include "../gui/Shortcut.h"
 #include "../gui/WindowHandler.h"
 #include "../render/Graphics.h"
 #include "../render/IFont.h"
+#include "../render/IRenderHandler.h"
+#include "../media/ISoundPlayer.h"
 #include "../widgets/CComponent.h"
 #include "../widgets/ComboBox.h"
 #include "../widgets/CTextInput.h"
@@ -29,17 +30,22 @@
 #include "../widgets/ObjectLists.h"
 #include "../widgets/Slider.h"
 #include "../widgets/TextControls.h"
+#include "../widgets/GraphicalPrimitiveCanvas.h"
 #include "../windows/GUIClasses.h"
 #include "../windows/InfoWindows.h"
 #include "../windows/CHeroOverview.h"
 #include "../eventsSDL/InputHandler.h"
 
+#include "../../lib/entities/faction/CFaction.h"
+#include "../../lib/entities/faction/CTown.h"
+#include "../../lib/entities/faction/CTownHandler.h"
+#include "../../lib/entities/hero/CHeroHandler.h"
+#include "../../lib/entities/hero/CHeroClass.h"
 #include "../../lib/filesystem/Filesystem.h"
 #include "../../lib/networkPacks/PacksForLobby.h"
-#include "../../lib/CGeneralTextHandler.h"
+#include "../../lib/texts/CGeneralTextHandler.h"
 #include "../../lib/CArtHandler.h"
-#include "../../lib/CTownHandler.h"
-#include "../../lib/CHeroHandler.h"
+#include "../../lib/CConfigHandler.h"
 #include "../../lib/mapping/CMapInfo.h"
 #include "../../lib/mapping/CMapHeader.h"
 
@@ -67,7 +73,7 @@
 		selectionWindow->reopen();
 	}
 
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 	for(auto & pInfo : SEL->getStartInfo()->playerInfos)
 	{
 		if(pInfo.second.isControlledByHuman())
@@ -329,7 +335,7 @@
 OptionsTab::CPlayerOptionTooltipBox::CPlayerOptionTooltipBox(CPlayerSettingsHelper & helper)
 	: CWindowObject(BORDERED | RCLICK_POPUP), CPlayerSettingsHelper(helper)
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 
 	switch(selectionType)
 	{
@@ -401,7 +407,7 @@
 	textBonusDescription = std::make_shared<CTextBox>(getDescription(), Rect(10, 100, pos.w - 20, 70), 0, FONT_SMALL, ETextAlignment::CENTER, Colors::WHITE);
 }
 
-OptionsTab::SelectionWindow::SelectionWindow(const PlayerColor & color, SelType _type)
+OptionsTab::SelectionWindow::SelectionWindow(const PlayerColor & color, SelType _type, int sliderPos)
 	: CWindowObject(BORDERED), color(color)
 {
 	addUsedEvents(LCLICK | SHOW_POPUP);
@@ -433,25 +439,31 @@
 	if(initialFaction.isValid())
 		allowedBonus.push_back(PlayerStartingBonus::RESOURCE);
 
-	recreate();
+	recreate(sliderPos);
 }
 
-int OptionsTab::SelectionWindow::calcLines(FactionID faction)
+std::tuple<int, int> OptionsTab::SelectionWindow::calcLines(FactionID faction)
 {
-	double additionalItems = 1; // random
+	int additionalItems = 1; // random
 
 	if(!faction.isValid())
-		return std::ceil(((double)allowedFactions.size() + additionalItems) / elementsPerLine);
+		return std::make_tuple(
+			std::ceil(((double)allowedFactions.size() + additionalItems) / MAX_ELEM_PER_LINES),
+			(allowedFactions.size() + additionalItems) % MAX_ELEM_PER_LINES
+		);
 
 	int count = 0;
 	for(auto & elemh : allowedHeroes)
 	{
-		CHero * type = VLC->heroh->objects[elemh];
+		const CHero * type = elemh.toHeroType();
 		if(type->heroClass->faction == faction)
 			count++;
 	}
 
-	return std::ceil(std::max((double)count + additionalItems, (double)allowedFactions.size() + additionalItems) / (double)elementsPerLine);
+	return std::make_tuple(
+		std::ceil(((double)count + additionalItems) / MAX_ELEM_PER_LINES),
+		(count + additionalItems) % MAX_ELEM_PER_LINES
+	);
 }
 
 void OptionsTab::SelectionWindow::apply()
@@ -481,48 +493,38 @@
 
 void OptionsTab::SelectionWindow::reopen()
 {
-	auto window = std::shared_ptr<SelectionWindow>(new SelectionWindow(color, type));
-	close();
-	if(CSH->isMyColor(color) || CSH->isHost())
-		GH.windows().pushWindow(window);
+	if(type == SelType::HERO && SEL->getStartInfo()->playerInfos.find(color)->second.castle == FactionID::RANDOM)
+		close();
+	else{
+		auto window = std::make_shared<SelectionWindow>(color, type, slider ? slider->getValue() : 0);
+		close();
+		if(CSH->isMyColor(color) || CSH->isHost())
+			GH.windows().pushWindow(window);
+	}
 }
 
-void OptionsTab::SelectionWindow::recreate()
+void OptionsTab::SelectionWindow::recreate(int sliderPos)
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 
 	int amountLines = 1;
 	if(type == SelType::BONUS)
 		elementsPerLine = allowedBonus.size();
 	else
 	{
-		// try to make squarish
-		if(type == SelType::TOWN)
-			elementsPerLine = floor(sqrt(allowedFactions.size()));
-		if(type == SelType::HERO)
-		{
-			int count = 0;
-			for(auto & elem : allowedHeroes)
-			{
-				const CHero * type = elem.toHeroType();
-				if(type->heroClass->faction == selectedFaction)
-				{
-					count++;
-				}
-			}
-			elementsPerLine = floor(sqrt(count));
-		}
-
-		amountLines = calcLines((type > SelType::TOWN) ? selectedFaction : FactionID::RANDOM);
+		std::tie(amountLines, elementsPerLine) = calcLines((type > SelType::TOWN) ? selectedFaction : FactionID::RANDOM);
+		if(amountLines > 1 || elementsPerLine == 0)
+			elementsPerLine = MAX_ELEM_PER_LINES;
 	}
 
 	int x = (elementsPerLine) * (ICON_BIG_WIDTH-1);
-	int y = (amountLines) * (ICON_BIG_HEIGHT-1);
+	int y = (std::min(amountLines, MAX_LINES)) * (ICON_BIG_HEIGHT-1);
 
-	pos = Rect(0, 0, x, y);
+	int sliderWidth = ((amountLines > MAX_LINES) ? 16 : 0);
 
-	backgroundTexture = std::make_shared<FilledTexturePlayerColored>(ImagePath::builtin("DiBoxBck"), pos);
-	backgroundTexture->playerColored(PlayerColor(1));
+	pos = Rect(pos.x, pos.y, x + sliderWidth, y);
+	backgroundTexture = std::make_shared<FilledTexturePlayerColored>(Rect(0, 0, pos.w - sliderWidth, pos.h));
+	backgroundTexture->setPlayerColor(PlayerColor(1));
 	updateShadow();
 
 	if(type == SelType::TOWN)
@@ -531,7 +533,15 @@
 		genContentHeroes();
 	if(type == SelType::BONUS)
 		genContentBonus();
-	genContentGrid(amountLines);
+	genContentGrid(std::min(amountLines, MAX_LINES));
+
+	if(!slider && amountLines > MAX_LINES)
+	{
+		slider = std::make_shared<CSlider>(Point(x, 0), y, std::bind(&OptionsTab::SelectionWindow::sliderMove, this, _1), MAX_LINES, amountLines, 0, Orientation::VERTICAL, CSlider::BLUE);
+		slider->setPanningStep(ICON_BIG_HEIGHT);
+		slider->setScrollBounds(Rect(-pos.w + slider->pos.w, 0, x + slider->pos.w, y));
+		slider->scrollTo(sliderPos);
+	}
 
 	center();
 }
@@ -569,22 +579,26 @@
 	if(selectedFaction == FactionID::RANDOM)
 		components.push_back(std::make_shared<CPicture>(ImagePath::builtin("lobby/townBorderSmallActivated"), 6, (ICON_SMALL_HEIGHT/2)));
 
+	factions.clear();
 	for(auto & elem : allowedFactions)
 	{
 		int x = i % elementsPerLine;
-		int y = i / elementsPerLine;
+		int y = (i / elementsPerLine) - (slider ? slider->getValue() : 0);
 
 		PlayerSettings set = PlayerSettings();
 		set.castle = elem;
 
 		CPlayerSettingsHelper helper = CPlayerSettingsHelper(set, SelType::TOWN);
 
+		factions.push_back(elem);
+		i++;
+
+		if(y < 0 || y > MAX_LINES - 1)
+			continue;
+			
 		components.push_back(std::make_shared<CAnimImage>(helper.getImageName(true), helper.getImageIndex(true), 0, x * (ICON_BIG_WIDTH-1), y * (ICON_BIG_HEIGHT-1)));
 		components.push_back(std::make_shared<CPicture>(ImagePath::builtin(selectedFaction == elem ? "lobby/townBorderBigActivated" : "lobby/townBorderBig"), x * (ICON_BIG_WIDTH-1), y * (ICON_BIG_HEIGHT-1)));
 		drawOutlinedText(x * (ICON_BIG_WIDTH-1) + TEXT_POS_X, y * (ICON_BIG_HEIGHT-1) + TEXT_POS_Y, (selectedFaction == elem) ? Colors::YELLOW : Colors::WHITE, helper.getName());
-		factions.push_back(elem);
-
-		i++;
 	}
 }
 
@@ -601,33 +615,36 @@
 	if(selectedHero == HeroTypeID::RANDOM)
 		components.push_back(std::make_shared<CPicture>(ImagePath::builtin("lobby/townBorderSmallActivated"), 6, (ICON_SMALL_HEIGHT/2)));
 
+	heroes.clear();
 	for(auto & elem : allowedHeroes)
 	{
-		CHero * type = VLC->heroh->objects[elem];
+		const CHero * type = elem.toHeroType();
 
-		if(type->heroClass->faction == selectedFaction)
-		{
+		if(type->heroClass->faction != selectedFaction)
+			continue;
 
-			int x = i % elementsPerLine;
-			int y = i / elementsPerLine;
+		int x = i % elementsPerLine;
+		int y = (i / elementsPerLine) - (slider ? slider->getValue() : 0);
+
+		PlayerSettings set = PlayerSettings();
+		set.hero = elem;
 
-			PlayerSettings set = PlayerSettings();
-			set.hero = elem;
+		CPlayerSettingsHelper helper = CPlayerSettingsHelper(set, SelType::HERO);
 
-			CPlayerSettingsHelper helper = CPlayerSettingsHelper(set, SelType::HERO);
+		heroes.push_back(elem);
+		i++;
 
-			components.push_back(std::make_shared<CAnimImage>(helper.getImageName(true), helper.getImageIndex(true), 0, x * (ICON_BIG_WIDTH-1), y * (ICON_BIG_HEIGHT-1)));
-			drawOutlinedText(x * (ICON_BIG_WIDTH-1) + TEXT_POS_X, y * (ICON_BIG_HEIGHT-1) + TEXT_POS_Y, (selectedHero == elem) ? Colors::YELLOW : Colors::WHITE, helper.getName());
-			ImagePath image = ImagePath::builtin("lobby/townBorderBig");
-			if(selectedHero == elem)
-				image = ImagePath::builtin("lobby/townBorderBigActivated");
-			if(unusableHeroes.count(elem))
-				image = ImagePath::builtin("lobby/townBorderBigGrayedOut");
-			components.push_back(std::make_shared<CPicture>(image, x * (ICON_BIG_WIDTH-1), y * (ICON_BIG_HEIGHT-1)));
-			heroes.push_back(elem);
+		if(y < 0 || y > MAX_LINES - 1)
+			continue;
 
-			i++;
-		}
+		components.push_back(std::make_shared<CAnimImage>(helper.getImageName(true), helper.getImageIndex(true), 0, x * (ICON_BIG_WIDTH-1), y * (ICON_BIG_HEIGHT-1)));
+		drawOutlinedText(x * (ICON_BIG_WIDTH-1) + TEXT_POS_X, y * (ICON_BIG_HEIGHT-1) + TEXT_POS_Y, (selectedHero == elem) ? Colors::YELLOW : Colors::WHITE, helper.getName());
+		ImagePath image = ImagePath::builtin("lobby/townBorderBig");
+		if(selectedHero == elem)
+			image = ImagePath::builtin("lobby/townBorderBigActivated");
+		if(unusableHeroes.count(elem))
+			image = ImagePath::builtin("lobby/townBorderBigGrayedOut");
+		components.push_back(std::make_shared<CPicture>(image, x * (ICON_BIG_WIDTH-1), y * (ICON_BIG_HEIGHT-1)));
 	}
 }
 
@@ -658,7 +675,7 @@
 int OptionsTab::SelectionWindow::getElement(const Point & cursorPosition)
 {
 	int x = (cursorPosition.x - pos.x) / (ICON_BIG_WIDTH-1);
-	int y = (cursorPosition.y - pos.y) / (ICON_BIG_HEIGHT-1);
+	int y = (cursorPosition.y - pos.y) / (ICON_BIG_HEIGHT-1) + (slider ? slider->getValue() : 0);
 
 	return x + y * elementsPerLine;
 }
@@ -740,18 +757,23 @@
 		apply();
 }
 
-bool OptionsTab::SelectionWindow::receiveEvent(const Point & position, int eventType) const
+void OptionsTab::SelectionWindow::sliderMove(int slidPos)
 {
-	return true;  // capture click also outside of window
+	if(!slider)
+		return; // ignore spurious call when slider is being created
+	recreate();
+	redraw();
+}
+
+void OptionsTab::SelectionWindow::notFocusedClick()
+{
+	close();
 }
 
 void OptionsTab::SelectionWindow::clickReleased(const Point & cursorPosition)
 {
-	if(!pos.isInside(cursorPosition))
-	{
-		close();
+	if(slider && slider->pos.isInside(cursorPosition))
 		return;
-	}
 
 	int elem = getElement(cursorPosition);
 
@@ -760,7 +782,7 @@
 
 void OptionsTab::SelectionWindow::showPopupWindow(const Point & cursorPosition)
 {
-	if(!pos.isInside(cursorPosition))
+	if(!pos.isInside(cursorPosition) || (slider && slider->pos.isInside(cursorPosition)))
 		return;
 
 	int elem = getElement(cursorPosition);
@@ -768,11 +790,118 @@
 	setElement(elem, false);
 }
 
+OptionsTab::HandicapWindow::HandicapWindow()
+	: CWindowObject(BORDERED)
+{
+	OBJECT_CONSTRUCTION;
+
+	addUsedEvents(LCLICK);
+
+	pos = Rect(0, 0, 660, 100 + SEL->getStartInfo()->playerInfos.size() * 30);
+
+	backgroundTexture = std::make_shared<FilledTexturePlayerColored>(pos);
+	backgroundTexture->setPlayerColor(PlayerColor(1));
+
+	labels.push_back(std::make_shared<CLabel>(pos.w / 2 + 8, 15, FONT_BIG, ETextAlignment::CENTER, Colors::YELLOW, CGI->generaltexth->translate("vcmi.lobby.handicap")));
+
+	enum Columns : int32_t
+	{
+		INCOME = 1000,
+		GROWTH = 2000,
+	};
+	auto columns = std::vector<EGameResID>{EGameResID::GOLD, EGameResID::WOOD, EGameResID::MERCURY, EGameResID::ORE, EGameResID::SULFUR, EGameResID::CRYSTAL, EGameResID::GEMS, Columns::INCOME, Columns::GROWTH};
+
+	int i = 0;
+	for(auto & pInfo : SEL->getStartInfo()->playerInfos)
+	{
+		PlayerColor player = pInfo.first;
+		anim.push_back(std::make_shared<CAnimImage>(AnimationPath::builtin("ITGFLAGS"), player.getNum(), 0, 7, 57 + i * 30));
+		for(int j = 0; j < columns.size(); j++)
+		{
+			bool isIncome = int(columns[j]) == Columns::INCOME;
+			bool isGrowth = int(columns[j]) == Columns::GROWTH;
+			EGameResID resource = columns[j];
+
+			const PlayerSettings &ps = SEL->getStartInfo()->getIthPlayersSettings(player);
+
+			int xPos = 30 + j * 70;
+			xPos += j > 0 ? 10 : 0; // Gold field is larger
+
+			if(i == 0)
+			{
+				if(isIncome)
+					labels.push_back(std::make_shared<CLabel>(xPos, 38, FONT_TINY, ETextAlignment::TOPLEFT, Colors::WHITE, CGI->generaltexth->translate("core.jktext.32")));
+				else if(isGrowth)
+					labels.push_back(std::make_shared<CLabel>(xPos, 38, FONT_TINY, ETextAlignment::TOPLEFT, Colors::WHITE, CGI->generaltexth->translate("core.genrltxt.194")));
+				else
+					anim.push_back(std::make_shared<CAnimImage>(AnimationPath::builtin("SMALRES"), GameResID(resource), 0, 15 + xPos + (j == 0 ? 10 : 0), 35));
+			}
+
+			auto area = Rect(xPos, 60 + i * 30, j == 0 ? 60 : 50, 16);
+			textinputbackgrounds.push_back(std::make_shared<TransparentFilledRectangle>(area.resize(3), ColorRGBA(0,0,0,128), ColorRGBA(64,64,64,64)));
+			textinputs[player][resource] = std::make_shared<CTextInput>(area, FONT_SMALL, ETextAlignment::CENTERLEFT, true);
+			textinputs[player][resource]->setText(std::to_string(isIncome ? ps.handicap.percentIncome : (isGrowth ? ps.handicap.percentGrowth : ps.handicap.startBonus[resource])));
+			textinputs[player][resource]->setCallback([this, player, resource, isIncome, isGrowth](const std::string & s){
+				// text input processing: add/remove sign when pressing "-"; remove non digits; cut length; fill empty field with 0
+				std::string tmp = s;
+				bool negative = std::count_if( s.begin(), s.end(), []( char c ){ return c == '-'; }) == 1 && !isIncome && !isGrowth;
+				tmp.erase(std::remove_if(tmp.begin(), tmp.end(), [](char c) { return !isdigit(c); }), tmp.end());
+				int maxLength = isIncome || isGrowth ? 3 : (resource == EGameResID::GOLD ? 6 : 5);
+				tmp = tmp.substr(0, maxLength);
+				textinputs[player][resource]->setText(tmp.length() == 0 ? "0" : (negative ? "-" : "") + std::to_string(stoi(tmp)));
+			});
+			textinputs[player][resource]->setPopupCallback([isIncome, isGrowth](){
+				// Help for the textinputs
+				if(isIncome)
+					CRClickPopup::createAndPush(CGI->generaltexth->translate("vcmi.lobby.handicap.income"));
+				else if(isGrowth)
+					CRClickPopup::createAndPush(CGI->generaltexth->translate("vcmi.lobby.handicap.growth"));
+				else
+					CRClickPopup::createAndPush(CGI->generaltexth->translate("vcmi.lobby.handicap.resource"));
+			});
+			if(isIncome || isGrowth)
+				labels.push_back(std::make_shared<CLabel>(area.topRight().x, area.center().y, FONT_SMALL, ETextAlignment::CENTERRIGHT, Colors::WHITE, "%"));
+		}
+		i++;
+	}
+	
+	buttons.push_back(std::make_shared<CButton>(Point(pos.w / 2 - 32, 60 + SEL->getStartInfo()->playerInfos.size() * 30), AnimationPath::builtin("MuBchck"), CButton::tooltip(), [this](){
+		for (const auto& player : textinputs)
+		{
+			TResources resources = TResources();
+			int income = 100;
+			int growth = 100;
+			for (const auto& resource : player.second)
+			{
+				bool isIncome = int(resource.first) == Columns::INCOME;
+				bool isGrowth = int(resource.first) == Columns::GROWTH;
+				if(isIncome)
+					income = std::stoi(resource.second->getText());
+				else if(isGrowth)
+					growth = std::stoi(resource.second->getText());
+				else
+					resources[resource.first] = std::stoi(resource.second->getText());
+			}
+			CSH->setPlayerHandicap(player.first, Handicap{resources, income, growth});
+		}
+	    		
+		close();
+	}, EShortcut::GLOBAL_RETURN));
+
+	updateShadow();
+	center();
+}
+
+void OptionsTab::HandicapWindow::notFocusedClick()
+{
+	close();
+}
+
 OptionsTab::SelectedBox::SelectedBox(Point position, PlayerSettings & playerSettings, SelType type)
 	: Scrollable(LCLICK | SHOW_POPUP, position, Orientation::HORIZONTAL)
 	, CPlayerSettingsHelper(playerSettings, type)
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 
 	image = std::make_shared<CAnimImage>(getImageName(), getImageIndex());
 	subtitle = std::make_shared<CLabel>(24, 39, FONT_TINY, ETextAlignment::CENTER, Colors::WHITE, getName(), 71);
@@ -853,8 +982,7 @@
 	, parentTab(parent)
 	, name(S.name)
 {
-	OBJ_CONSTRUCTION;
-	defActions |= SHARE_POS;
+	OBJECT_CONSTRUCTION;
 
 	int serial = 0;
 	for(PlayerColor g = PlayerColor(0); g < s->color; ++g)
@@ -896,7 +1024,49 @@
 		labelPlayerNameEdit = std::make_shared<CTextInput>(Rect(6, 3, 95, 15), EFonts::FONT_SMALL, ETextAlignment::CENTER, false);
 		labelPlayerNameEdit->setText(name);
 	}
-	labelWhoCanPlay = std::make_shared<CMultiLineLabel>(Rect(6, 23, 45, (int)graphics->fonts[EFonts::FONT_TINY]->getLineHeight()*2), EFonts::FONT_TINY, ETextAlignment::CENTER, Colors::WHITE, CGI->generaltexth->arraytxt[206 + whoCanPlay]);
+
+	labelWhoCanPlay = std::make_shared<CMultiLineLabel>(Rect(6, 21, 45, 26), EFonts::FONT_TINY, ETextAlignment::CENTER, Colors::WHITE, CGI->generaltexth->arraytxt[206 + whoCanPlay]);
+
+	auto hasHandicap = [this](){ return s->handicap.startBonus.empty() && s->handicap.percentIncome == 100 && s->handicap.percentGrowth == 100; };
+	std::string labelHandicapText = hasHandicap() ? CGI->generaltexth->arraytxt[210] : MetaString::createFromTextID("vcmi.lobby.handicap").toString();
+	labelHandicap = std::make_shared<CMultiLineLabel>(Rect(55, 23, 46, 24), EFonts::FONT_TINY, ETextAlignment::CENTER, Colors::WHITE, labelHandicapText);
+	handicap = std::make_shared<LRClickableArea>(Rect(53, 23, 50, 24), [](){
+		if(!CSH->isHost())
+			return;
+		
+		GH.windows().createAndPushWindow<HandicapWindow>();
+	}, [this, hasHandicap](){
+		if(hasHandicap())
+			CRClickPopup::createAndPush(MetaString::createFromTextID("core.help.124.help").toString());
+		else
+		{
+			auto str = MetaString::createFromTextID("vcmi.lobby.handicap");
+			str.appendRawString(":\n");
+			for(auto & res : EGameResID::ALL_RESOURCES())
+				if(s->handicap.startBonus[res] != 0)
+				{
+					str.appendRawString("\n");
+					str.appendName(res);
+					str.appendRawString(": ");
+					str.appendRawString(std::to_string(s->handicap.startBonus[res]));
+				}
+			if(s->handicap.percentIncome != 100)
+			{
+				str.appendRawString("\n");
+				str.appendTextID("core.jktext.32");
+				str.appendRawString(": ");
+				str.appendRawString(std::to_string(s->handicap.percentIncome) + "%");
+			}
+			if(s->handicap.percentGrowth != 100)
+			{
+				str.appendRawString("\n");
+				str.appendTextID("core.genrltxt.194");
+				str.appendRawString(": ");
+				str.appendRawString(std::to_string(s->handicap.percentGrowth) + "%");
+			}
+			CRClickPopup::createAndPush(str.toString());
+		}
+	});
 
 	if(SEL->screenType == ESelectionScreen::newGame)
 	{
diff --color -urN vcmi-1.5.7/client/lobby/OptionsTab.h vcmi/client/lobby/OptionsTab.h
--- vcmi-1.5.7/client/lobby/OptionsTab.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/lobby/OptionsTab.h	2024-12-19 15:00:22.257121448 +0100
@@ -26,8 +26,11 @@
 class CComponentBox;
 class CTextBox;
 class CButton;
+class CSlider;
+class LRClickableArea;
 
 class FilledTexturePlayerColored;
+class TransparentFilledRectangle;
 
 /// The options tab which is shown at the map selection phase.
 class OptionsTab : public OptionsTabBase
@@ -50,6 +53,21 @@
 		BONUS
 	};
 
+	class HandicapWindow : public CWindowObject
+	{
+		std::shared_ptr<FilledTexturePlayerColored> backgroundTexture;
+
+		std::vector<std::shared_ptr<CLabel>> labels;
+		std::vector<std::shared_ptr<CAnimImage>> anim;
+		std::vector<std::shared_ptr<TransparentFilledRectangle>> textinputbackgrounds;
+		std::map<PlayerColor, std::map<EGameResID, std::shared_ptr<CTextInput>>> textinputs;
+		std::vector<std::shared_ptr<CButton>> buttons;
+
+		void notFocusedClick() override;
+	public:
+		HandicapWindow();
+	};
+
 private:
 	
 	struct CPlayerSettingsHelper
@@ -105,8 +123,13 @@
 		const int TEXT_POS_X = 29;
 		const int TEXT_POS_Y = 56;
 
+		const int MAX_LINES = 5;
+		const int MAX_ELEM_PER_LINES = 5;
+
 		int elementsPerLine;
 
+		std::shared_ptr<CSlider> slider;
+
 		PlayerColor color;
 		SelType type;
 
@@ -134,21 +157,23 @@
 		void genContentBonus();
 
 		void drawOutlinedText(int x, int y, ColorRGBA color, std::string text);
-		int calcLines(FactionID faction);
+		std::tuple<int, int> calcLines(FactionID faction);
 		void apply();
-		void recreate();
+		void recreate(int sliderPos = 0);
 		void setSelection();
 		int getElement(const Point & cursorPosition);
 		void setElement(int element, bool doApply);
 
-		bool receiveEvent(const Point & position, int eventType) const override;
+		void sliderMove(int slidPos);
+
+		void notFocusedClick() override;
 		void clickReleased(const Point & cursorPosition) override;
 		void showPopupWindow(const Point & cursorPosition) override;
 
 	public:
 		void reopen();
 
-		SelectionWindow(const PlayerColor & color, SelType _type);
+		SelectionWindow(const PlayerColor & color, SelType _type, int sliderPos = 0);
 	};
 
 	/// Image with current town/hero/bonus
@@ -184,6 +209,8 @@
 		std::shared_ptr<SelectedBox> town;
 		std::shared_ptr<SelectedBox> hero;
 		std::shared_ptr<SelectedBox> bonus;
+		std::shared_ptr<LRClickableArea> handicap;
+		std::shared_ptr<CMultiLineLabel> labelHandicap;
 		enum {HUMAN_OR_CPU, HUMAN, CPU} whoCanPlay;
 
 		PlayerOptionsEntry(const PlayerSettings & S, const OptionsTab & parentTab);
diff --color -urN vcmi-1.5.7/client/lobby/RandomMapTab.cpp vcmi/client/lobby/RandomMapTab.cpp
--- vcmi-1.5.7/client/lobby/RandomMapTab.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/lobby/RandomMapTab.cpp	2024-12-19 15:00:22.258121489 +0100
@@ -29,7 +29,7 @@
 #include "../windows/GUIClasses.h"
 #include "../windows/InfoWindows.h"
 
-#include "../../lib/CGeneralTextHandler.h"
+#include "../../lib/texts/CGeneralTextHandler.h"
 #include "../../lib/mapping/CMapInfo.h"
 #include "../../lib/mapping/CMapHeader.h"
 #include "../../lib/mapping/MapFormat.h"
@@ -114,12 +114,12 @@
 		GH.windows().createAndPushWindow<TeamAlignments>(*this);
 	});
 	
-	for(auto road : VLC->roadTypeHandler->objects)
+	for(const auto & road : VLC->roadTypeHandler->objects)
 	{
 		std::string cbRoadType = "selectRoad_" + road->getJsonKey();
-		addCallback(cbRoadType, [&, road](bool on)
+		addCallback(cbRoadType, [&, roadID = road->getId()](bool on)
 		{
-			mapGenOptions->setRoadEnabled(road->getId(), on);
+			mapGenOptions->setRoadEnabled(roadID, on);
 			updateMapInfoByHost();
 		});
 	}
@@ -263,7 +263,7 @@
 		humanCountAllowed = tmpl->getHumanPlayers().getNumbers(); // Unused now?
 	}
 	
-	si8 playerLimit = opts->getMaxPlayersCount();
+	si8 playerLimit = opts->getPlayerLimit();
 	si8 humanOrCpuPlayerCount = opts->getHumanOrCpuPlayerCount();
 	si8 compOnlyPlayersCount = opts->getCompOnlyPlayerCount();
 
@@ -372,7 +372,7 @@
 		else
 			w->setTextOverlay(readText(variables["randomTemplate"]), EFonts::FONT_SMALL, Colors::WHITE);
 	}
-	for(auto r : VLC->roadTypeHandler->objects)
+	for(const auto & r : VLC->roadTypeHandler->objects)
 	{
 		// Workaround for vcmi-extras bug
 		std::string jsonKey = r->getJsonKey();
@@ -447,7 +447,7 @@
 TeamAlignments::TeamAlignments(RandomMapTab & randomMapTab)
 	: CWindowObject(BORDERED)
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 
 	widget = std::make_shared<TeamAlignmentsWidget>(randomMapTab);
 	pos = widget->pos;
@@ -469,6 +469,8 @@
 	variables["totalPlayers"].Integer() = totalPlayers;
 	
 	pos.w = variables["windowSize"]["x"].Integer() + totalPlayers * variables["cellMargin"]["x"].Integer();
+	auto widthExtend = std::max(pos.w, 220) - pos.w; // too small for buttons
+	pos.w += widthExtend;
 	pos.h = variables["windowSize"]["y"].Integer() + totalPlayers * variables["cellMargin"]["y"].Integer();
 	variables["backgroundRect"]["x"].Integer() = 0;
 	variables["backgroundRect"]["y"].Integer() = 0;
@@ -501,7 +503,7 @@
 	
 	center(pos);
 	
-	OBJ_CONSTRUCTION;
+	OBJECT_CONSTRUCTION;
 	
 	// Window should have X * X columns, where X is max players allowed for current settings
 	// For random player count, X is 8
@@ -529,7 +531,7 @@
 		players.push_back(std::make_shared<CToggleGroup>([&, totalPlayers, plId](int sel)
 		{
 			variables["player_id"].Integer() = plId;
-			OBJ_CONSTRUCTION_TARGETED(players[plId].get());
+			OBJECT_CONSTRUCTION_TARGETED(players[plId].get());
 			for(int teamId = 0; teamId < totalPlayers; ++teamId)
 			{
 				auto button = std::dynamic_pointer_cast<CToggleButton>(players[plId]->buttons[teamId]);
@@ -549,17 +551,17 @@
 			}
 		}));
 		
-		OBJ_CONSTRUCTION_TARGETED(players.back().get());
+		OBJECT_CONSTRUCTION_TARGETED(players.back().get());
 
 		for(int teamId = 0; teamId < totalPlayers; ++teamId)
 		{
-			variables["point"]["x"].Integer() = variables["cellOffset"]["x"].Integer() + plId * variables["cellMargin"]["x"].Integer();
+			variables["point"]["x"].Integer() = variables["cellOffset"]["x"].Integer() + plId * variables["cellMargin"]["x"].Integer() + (widthExtend / 2);
 			variables["point"]["y"].Integer() = variables["cellOffset"]["y"].Integer() + teamId * variables["cellMargin"]["y"].Integer();
 			auto button = buildWidget(variables["button"]);
 			players.back()->addToggle(teamId, std::dynamic_pointer_cast<CToggleBase>(button));
 		}
 		
-		// plId is not neccessarily player color, just an index
+		// plId is not necessarily player color, just an index
 		auto team = settingsVec.at(plId).getTeam();
 		if(team == TeamID::NO_TEAM)
 		{
@@ -601,8 +603,14 @@
 		{
 			w->setItem(mapGenOptions->getMapTemplate());
 		}
+	} else
+	{
+		// Default settings
+		mapGenOptions->setRoadEnabled(RoadId(Road::DIRT_ROAD), true);
+		mapGenOptions->setRoadEnabled(RoadId(Road::GRAVEL_ROAD), true);
+		mapGenOptions->setRoadEnabled(RoadId(Road::COBBLESTONE_ROAD), true);
 	}
 	updateMapInfoByHost();
 
 	// TODO: Save & load difficulty?
-}
\ No newline at end of file
+}
diff --color -urN vcmi-1.5.7/client/lobby/SelectionTab.cpp vcmi/client/lobby/SelectionTab.cpp
--- vcmi-1.5.7/client/lobby/SelectionTab.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/lobby/SelectionTab.cpp	2024-12-19 15:00:22.258121489 +0100
@@ -35,15 +35,18 @@
 
 #include "../../CCallback.h"
 
-#include "../../lib/CGeneralTextHandler.h"
 #include "../../lib/CConfigHandler.h"
-#include "../../lib/GameSettings.h"
+#include "../../lib/IGameSettings.h"
 #include "../../lib/filesystem/Filesystem.h"
 #include "../../lib/campaign/CampaignState.h"
 #include "../../lib/mapping/CMapInfo.h"
 #include "../../lib/mapping/CMapHeader.h"
 #include "../../lib/mapping/MapFormat.h"
+#include "../../lib/networkPacks/PacksForLobby.h"
+#include "../../lib/texts/CGeneralTextHandler.h"
+#include "../../lib/texts/TextOperations.h"
 #include "../../lib/TerrainHandler.h"
+#include "../../lib/UnlockGuard.h"
 
 bool mapSorter::operator()(const std::shared_ptr<ElementInfo> aaa, const std::shared_ptr<ElementInfo> bbb)
 {
@@ -151,9 +154,9 @@
 }
 
 SelectionTab::SelectionTab(ESelectionScreen Type)
-	: CIntObject(LCLICK | SHOW_POPUP | KEYBOARD | DOUBLECLICK), callOnSelect(nullptr), tabType(Type), selectionPos(0), sortModeAscending(true), inputNameRect{32, 539, 350, 20}, curFolder(""), currentMapSizeFilter(0), showRandom(false)
+	: CIntObject(LCLICK | SHOW_POPUP | KEYBOARD | DOUBLECLICK), callOnSelect(nullptr), tabType(Type), selectionPos(0), sortModeAscending(true), inputNameRect{32, 539, 350, 20}, curFolder(""), currentMapSizeFilter(0), showRandom(false), deleteMode(false)
 {
-	OBJ_CONSTRUCTION;
+	OBJECT_CONSTRUCTION;
 		
 	generalSortingBy = getSortBySelectionScreen(tabType);
 	sortingBy = _format;
@@ -191,20 +194,23 @@
 
 	int positionsToShow = 18;
 	std::string tabTitle;
+	std::string tabTitleDelete;
 	switch(tabType)
 	{
 	case ESelectionScreen::newGame:
-		tabTitle = CGI->generaltexth->arraytxt[229];
+		tabTitle = "{" + CGI->generaltexth->arraytxt[229] + "}";
+		tabTitleDelete = "{red|" + CGI->generaltexth->translate("vcmi.lobby.deleteMapTitle") + "}";
 		break;
 	case ESelectionScreen::loadGame:
-		tabTitle = CGI->generaltexth->arraytxt[230];
+		tabTitle = "{" + CGI->generaltexth->arraytxt[230] + "}";
+		tabTitleDelete = "{red|" + CGI->generaltexth->translate("vcmi.lobby.deleteSaveGameTitle") + "}";
 		break;
 	case ESelectionScreen::saveGame:
 		positionsToShow = 16;
-		tabTitle = CGI->generaltexth->arraytxt[231];
+		tabTitle = "{" + CGI->generaltexth->arraytxt[231] + "}";
 		break;
 	case ESelectionScreen::campaignList:
-		tabTitle = CGI->generaltexth->allTexts[726];
+		tabTitle = "{" + CGI->generaltexth->allTexts[726] + "}";
 		setRedrawParent(true); // we use parent background so we need to make sure it's will be redrawn too
 		pos.w = parent->pos.w;
 		pos.h = parent->pos.h;
@@ -224,15 +230,26 @@
 		auto sortByDate = std::make_shared<CButton>(Point(371, 85), AnimationPath::builtin("selectionTabSortDate"), CButton::tooltip("", CGI->generaltexth->translate("vcmi.lobby.sortDate")), std::bind(&SelectionTab::sortBy, this, ESortBy::_changeDate), EShortcut::MAPS_SORT_CHANGEDATE);
 		sortByDate->setOverlay(std::make_shared<CPicture>(ImagePath::builtin("lobby/selectionTabSortDate")));
 		buttonsSortBy.push_back(sortByDate);
+
+		if(tabType == ESelectionScreen::loadGame || tabType == ESelectionScreen::newGame)
+		{
+			buttonDeleteMode = std::make_shared<CButton>(Point(367, 18), AnimationPath::builtin("lobby/deleteButton"), CButton::tooltip("", CGI->generaltexth->translate("vcmi.lobby.deleteMode")), [this, tabTitle, tabTitleDelete](){
+				deleteMode = !deleteMode;
+				if(deleteMode)
+					labelTabTitle->setText(tabTitleDelete);
+				else
+					labelTabTitle->setText(tabTitle);
+			});
+
+			if(tabType == ESelectionScreen::newGame)
+				buttonDeleteMode->setEnabled(false);
+		}
 	}
 
-	iconsMapFormats = GH.renderHandler().loadAnimation(AnimationPath::builtin("SCSELC.DEF"));
-	iconsVictoryCondition = GH.renderHandler().loadAnimation(AnimationPath::builtin("SCNRVICT.DEF"));
-	iconsLossCondition = GH.renderHandler().loadAnimation(AnimationPath::builtin("SCNRLOSS.DEF"));
 	for(int i = 0; i < positionsToShow; i++)
-		listItems.push_back(std::make_shared<ListItem>(Point(30, 129 + i * 25), iconsMapFormats, iconsVictoryCondition, iconsLossCondition));
+		listItems.push_back(std::make_shared<ListItem>(Point(30, 129 + i * 25)));
 
-	labelTabTitle = std::make_shared<CLabel>(205, 28, FONT_MEDIUM, ETextAlignment::CENTER, Colors::YELLOW, tabTitle);
+	labelTabTitle = std::make_shared<CLabel>(205, 28, FONT_MEDIUM, ETextAlignment::CENTER, Colors::WHITE, tabTitle);
 	slider = std::make_shared<CSlider>(Point(372, 86 + (enableUiEnhancements ? 30 : 0)), (tabType != ESelectionScreen::saveGame ? 480 : 430) - (enableUiEnhancements ? 30 : 0), std::bind(&SelectionTab::sliderMove, this, _1), positionsToShow, (int)curItems.size(), 0, Orientation::VERTICAL, CSlider::BLUE);
 	slider->setPanningStep(24);
 
@@ -244,10 +261,10 @@
 
 void SelectionTab::toggleMode()
 {
+	allItems.clear();
+	curItems.clear();
 	if(CSH->isGuest())
 	{
-		allItems.clear();
-		curItems.clear();
 		if(slider)
 			slider->block(true);
 	}
@@ -265,9 +282,12 @@
 			}
 
 		case ESelectionScreen::loadGame:
-			inputName->disable();
-			parseSaves(getFiles("Saves/", EResType::SAVEGAME));
-			break;
+			{
+				inputName->disable();
+				auto unsupported = parseSaves(getFiles("Saves/", EResType::SAVEGAME));
+				handleUnsupportedSavegames(unsupported);
+				break;
+			}
 
 		case ESelectionScreen::saveGame:
 			parseSaves(getFiles("Saves/", EResType::SAVEGAME));
@@ -309,9 +329,37 @@
 {
 	int line = getLine();
 
-	if(line != -1)
+	if(line != -1 && curItems.size() > line)
 	{
-		select(line);
+		if(!deleteMode)
+			select(line);
+		else
+		{
+			int py = line + slider->getValue();
+			vstd::amax(py, 0);
+			vstd::amin(py, curItems.size() - 1);
+
+			if(curItems[py]->isFolder && boost::algorithm::starts_with(curItems[py]->folderName, ".."))
+			{
+				select(line);
+				return;
+			}
+
+			if(!curItems[py]->isFolder)
+				CInfoWindow::showYesNoDialog(CGI->generaltexth->translate("vcmi.lobby.deleteFile") + "\n\n" + curItems[py]->fullFileURI, std::vector<std::shared_ptr<CComponent>>(), [this, py](){
+					LobbyDelete ld;
+					ld.type = tabType == ESelectionScreen::newGame ? LobbyDelete::EType::RANDOMMAP : LobbyDelete::EType::SAVEGAME;
+					ld.name = curItems[py]->fileURI;
+					CSH->sendLobbyPack(ld);
+				}, nullptr);
+			else
+				CInfoWindow::showYesNoDialog(CGI->generaltexth->translate("vcmi.lobby.deleteFolder") + "\n\n" + curFolder + curItems[py]->folderName, std::vector<std::shared_ptr<CComponent>>(), [this, py](){
+					LobbyDelete ld;
+					ld.type = LobbyDelete::EType::SAVEGAME_FOLDER;
+					ld.name = curFolder + curItems[py]->folderName;
+					CSH->sendLobbyPack(ld);
+				}, nullptr);
+		}
 	}
 #ifdef VCMI_MOBILE
 	// focus input field if clicked inside it
@@ -391,7 +439,33 @@
 		return;
 
 	if(!curItems[py]->isFolder)
-		GH.windows().createAndPushWindow<CMapOverview>(curItems[py]->getNameTranslated(), curItems[py]->fullFileURI, curItems[py]->date, ResourcePath(curItems[py]->fileURI), tabType);
+	{
+		std::string creationDateTime;
+		std::string author;
+		std::string mapVersion;
+		if(tabType != ESelectionScreen::campaignList)
+		{
+			author = curItems[py]->mapHeader->author.toString() + (!curItems[py]->mapHeader->authorContact.toString().empty() ? (" <" + curItems[py]->mapHeader->authorContact.toString() + ">") : "");
+			mapVersion = curItems[py]->mapHeader->mapVersion.toString();
+			creationDateTime = tabType == ESelectionScreen::newGame && curItems[py]->mapHeader->creationDateTime ? TextOperations::getFormattedDateTimeLocal(curItems[py]->mapHeader->creationDateTime) : curItems[py]->date;
+		}
+		else
+		{
+			author = curItems[py]->campaign->getAuthor() + (!curItems[py]->campaign->getAuthorContact().empty() ? (" <" + curItems[py]->campaign->getAuthorContact() + ">") : "");
+			mapVersion = curItems[py]->campaign->getCampaignVersion();
+			creationDateTime = curItems[py]->campaign->getCreationDateTime() ? TextOperations::getFormattedDateTimeLocal(curItems[py]->campaign->getCreationDateTime()) : curItems[py]->date;
+		}
+
+		GH.windows().createAndPushWindow<CMapOverview>(
+			curItems[py]->getNameTranslated(),
+			curItems[py]->fullFileURI,
+			creationDateTime,
+			author,
+			mapVersion,
+			ResourcePath(curItems[py]->fileURI),
+			tabType
+		);
+	}
 	else
 		CRClickPopup::createAndPush(curItems[py]->folderName);
 }
@@ -451,16 +525,19 @@
 
 	curItems.clear();
 
+	if(buttonDeleteMode)
+		buttonDeleteMode->setEnabled(tabType != ESelectionScreen::newGame || showRandom);
+
 	for(auto elem : allItems)
 	{
 		if((elem->mapHeader && (!size || elem->mapHeader->width == size)) || tabType == ESelectionScreen::campaignList)
 		{
 			if(showRandom)
-				curFolder = "RANDOMMAPS/";
+				curFolder = "RandomMaps/";
 
 			auto [folderName, baseFolder, parentExists, fileInFolder] = checkSubfolder(elem->originalFileURI);
 
-			if((showRandom && baseFolder != "RANDOMMAPS") || (!showRandom && baseFolder == "RANDOMMAPS"))
+			if((showRandom && baseFolder != "RandomMaps") || (!showRandom && baseFolder == "RandomMaps"))
 				continue;
 
 			if(parentExists && !showRandom)
@@ -477,6 +554,7 @@
 			auto folder = std::make_shared<ElementInfo>();
 			folder->isFolder = true;
 			folder->folderName = folderName;
+			folder->isAutoSaveFolder = boost::starts_with(baseFolder, "Autosave/") && folderName != "Autosave";
 			auto itemIt = boost::range::find_if(curItems, [folder](std::shared_ptr<ElementInfo> e) { return e->folderName == folder->folderName; });
 			if (itemIt == curItems.end() && folderName != "") {
 				curItems.push_back(folder);
@@ -537,7 +615,11 @@
 
 	int firstMapIndex = boost::range::find_if(curItems, [](std::shared_ptr<ElementInfo> e) { return !e->isFolder; }) - curItems.begin();
 	if(!sortModeAscending)
+	{
+		if(firstMapIndex)
+			std::reverse(std::next(curItems.begin(), boost::starts_with(curItems[0]->folderName, "..") ? 1 : 0), std::next(curItems.begin(), firstMapIndex - 1));
 		std::reverse(std::next(curItems.begin(), firstMapIndex), curItems.end());
+	}
 
 	updateListItems();
 	redraw();
@@ -669,7 +751,7 @@
 
 	for(int i = (int)allItems.size() - 1; i >= 0; i--)
 	{
-		if(allItems[i]->fileURI == fname)
+		if(boost::to_upper_copy(allItems[i]->fileURI) == fname)
 		{
 			auto [folderName, baseFolder, parentExists, fileInFolder] = checkSubfolder(allItems[i]->originalFileURI);
 			curFolder = baseFolder != "" ? baseFolder + "/" : "";
@@ -680,7 +762,7 @@
 
 	for(int i = (int)curItems.size() - 1; i >= 0; i--)
 	{
-		if(curItems[i]->fileURI == fname)
+		if(boost::to_upper_copy(curItems[i]->fileURI) == fname)
 		{
 			slider->scrollTo(i);
 			selectAbs(i);
@@ -691,14 +773,14 @@
 	selectAbs(-1);
 
 	if(tabType == ESelectionScreen::saveGame && inputName->getText().empty())
-		inputName->setText("NEWGAME");
+		inputName->setText(CGI->generaltexth->translate("core.genrltxt.11"));
 }
 
 void SelectionTab::selectNewestFile()
 {
 	time_t newestTime = 0;
 	std::string newestFile = "";
-	for(int i = (int)allItems.size() - 1; i >= 0; i--)
+	for(int i = static_cast<int>(allItems.size()) - 1; i >= 0; i--)
 		if(allItems[i]->lastWrite > newestTime)
 		{
 			newestTime = allItems[i]->lastWrite;
@@ -758,17 +840,19 @@
 	switch (info.mapHeader->version)
 	{
 		case EMapFormat::ROE:
-			return CGI->settings()->getValue(EGameSettings::MAP_FORMAT_RESTORATION_OF_ERATHIA)["supported"].Bool();
+			return CGI->engineSettings()->getValue(EGameSettings::MAP_FORMAT_RESTORATION_OF_ERATHIA)["supported"].Bool();
 		case EMapFormat::AB:
-			return CGI->settings()->getValue(EGameSettings::MAP_FORMAT_ARMAGEDDONS_BLADE)["supported"].Bool();
+			return CGI->engineSettings()->getValue(EGameSettings::MAP_FORMAT_ARMAGEDDONS_BLADE)["supported"].Bool();
 		case EMapFormat::SOD:
-			return CGI->settings()->getValue(EGameSettings::MAP_FORMAT_SHADOW_OF_DEATH)["supported"].Bool();
+			return CGI->engineSettings()->getValue(EGameSettings::MAP_FORMAT_SHADOW_OF_DEATH)["supported"].Bool();
+		case EMapFormat::CHR:
+			return CGI->engineSettings()->getValue(EGameSettings::MAP_FORMAT_CHRONICLES)["supported"].Bool();
 		case EMapFormat::WOG:
-			return CGI->settings()->getValue(EGameSettings::MAP_FORMAT_IN_THE_WAKE_OF_GODS)["supported"].Bool();
+			return CGI->engineSettings()->getValue(EGameSettings::MAP_FORMAT_IN_THE_WAKE_OF_GODS)["supported"].Bool();
 		case EMapFormat::HOTA:
-			return CGI->settings()->getValue(EGameSettings::MAP_FORMAT_HORN_OF_THE_ABYSS)["supported"].Bool();
+			return CGI->engineSettings()->getValue(EGameSettings::MAP_FORMAT_HORN_OF_THE_ABYSS)["supported"].Bool();
 		case EMapFormat::VCMI:
-			return CGI->settings()->getValue(EGameSettings::MAP_FORMAT_JSON_VCMI)["supported"].Bool();
+			return CGI->engineSettings()->getValue(EGameSettings::MAP_FORMAT_JSON_VCMI)["supported"].Bool();
 	}
 	return false;
 }
@@ -782,7 +866,8 @@
 		try
 		{
 			auto mapInfo = std::make_shared<ElementInfo>();
-			mapInfo->mapInit(file.getName());
+			mapInfo->mapInit(file.getOriginalName());
+			mapInfo->name = mapInfo->getNameForList();
 
 			if (isMapSupported(*mapInfo))
 				allItems.push_back(mapInfo);
@@ -794,14 +879,17 @@
 	}
 }
 
-void SelectionTab::parseSaves(const std::unordered_set<ResourcePath> & files)
+std::vector<ResourcePath> SelectionTab::parseSaves(const std::unordered_set<ResourcePath> & files)
 {
+	std::vector<ResourcePath> unsupported;
+
 	for(auto & file : files)
 	{
 		try
 		{
 			auto mapInfo = std::make_shared<ElementInfo>();
 			mapInfo->saveInit(file);
+			mapInfo->name = mapInfo->getNameForList();
 
 			// Filter out other game modes
 			bool isCampaign = mapInfo->scenarioOptionsOfSave->mode == EStartMode::CAMPAIGN;
@@ -833,24 +921,72 @@
 
 			allItems.push_back(mapInfo);
 		}
+		catch(const IdentifierResolutionException & e)
+		{
+			logGlobal->error("Error: Failed to process %s: %s", file.getName(), e.what());
+		}
 		catch(const std::exception & e)
 		{
+			unsupported.push_back(file); // IdentifierResolutionException is not relevant -> not ask to delete, when mods are disabled
 			logGlobal->error("Error: Failed to process %s: %s", file.getName(), e.what());
 		}
 	}
+
+	return unsupported;
+}
+
+void SelectionTab::handleUnsupportedSavegames(const std::vector<ResourcePath> & files)
+{
+	if(CSH->isHost() && files.size())
+	{
+		MetaString text = MetaString::createFromTextID("vcmi.lobby.deleteUnsupportedSave");
+		text.replaceNumber(files.size());
+		CInfoWindow::showYesNoDialog(text.toString(), std::vector<std::shared_ptr<CComponent>>(), [files](){
+			for(auto & file : files)
+			{
+				LobbyDelete ld;
+				ld.type = LobbyDelete::EType::SAVEGAME;
+				ld.name = file.getName();
+				CSH->sendLobbyPack(ld);
+			}
+		}, nullptr);
+	}
 }
 
 void SelectionTab::parseCampaigns(const std::unordered_set<ResourcePath> & files)
 {
+	auto campaignSets = JsonNode(JsonPath::builtin("config/campaignSets.json"));
+	auto mainmenu = JsonNode(JsonPath::builtin("config/mainmenu.json"));
+
 	allItems.reserve(files.size());
 	for(auto & file : files)
 	{
 		auto info = std::make_shared<ElementInfo>();
-		//allItems[i].date = std::asctime(std::localtime(&files[i].date));
-		info->fileURI = file.getName();
+		info->fileURI = file.getOriginalName();
 		info->campaignInit();
+		info->name = info->getNameForList();
+				
 		if(info->campaign)
-			allItems.push_back(info);
+		{
+			// skip campaigns organized in sets
+			std::string foundInSet = "";
+			for (auto const & set : campaignSets.Struct())
+				for (auto const & item : set.second["items"].Vector())
+					if(file.getName() == ResourcePath(item["file"].String()).getName())
+						foundInSet = set.first;
+			
+			// set has to be used in main menu
+			bool setInMainmenu = false;
+			if(!foundInSet.empty())
+				for (auto const & item : mainmenu["window"]["items"].Vector())
+					if(item["name"].String() == "campaign")
+						for (auto const & button : item["buttons"].Vector())
+							if(boost::algorithm::ends_with(boost::algorithm::to_lower_copy(button["command"].String()), boost::algorithm::to_lower_copy(foundInSet)))
+								setInMainmenu = true;
+
+			if(!setInMainmenu)
+				allItems.push_back(info);
+		}
 	}
 }
 
@@ -870,12 +1006,12 @@
 	return ret;
 }
 
-SelectionTab::ListItem::ListItem(Point position, std::shared_ptr<CAnimation> iconsFormats, std::shared_ptr<CAnimation> iconsVictory, std::shared_ptr<CAnimation> iconsLoss)
+SelectionTab::ListItem::ListItem(Point position)
 	: CIntObject(LCLICK, position)
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
-	pictureEmptyLine = std::make_shared<CPicture>(GH.renderHandler().loadImage(ImagePath::builtin("camcust")), Rect(25, 121, 349, 26), -8, -14);
-	labelName = std::make_shared<CLabel>(184, 0, FONT_SMALL, ETextAlignment::CENTER, Colors::WHITE, "", 185);
+	OBJECT_CONSTRUCTION;
+	pictureEmptyLine = std::make_shared<CPicture>(ImagePath::builtin("camcust"), Rect(25, 121, 349, 26), -8, -14);
+	labelName = std::make_shared<CLabel>(LABEL_POS_X, 0, FONT_SMALL, ETextAlignment::CENTER, Colors::WHITE, "", 185);
 	labelName->setAutoRedraw(false);
 	labelAmountOfPlayers = std::make_shared<CLabel>(8, 0, FONT_SMALL, ETextAlignment::CENTER, Colors::WHITE);
 	labelAmountOfPlayers->setAutoRedraw(false);
@@ -885,9 +1021,9 @@
 	labelMapSizeLetter->setAutoRedraw(false);
 	// FIXME: This -12 should not be needed, but for some reason CAnimImage displaced otherwise
 	iconFolder = std::make_shared<CPicture>(ImagePath::builtin("lobby/iconFolder.png"), -8, -12);
-	iconFormat = std::make_shared<CAnimImage>(iconsFormats, 0, 0, 59, -12);
-	iconVictoryCondition = std::make_shared<CAnimImage>(iconsVictory, 0, 0, 277, -12);
-	iconLossCondition = std::make_shared<CAnimImage>(iconsLoss, 0, 0, 310, -12);
+	iconFormat = std::make_shared<CAnimImage>(AnimationPath::builtin("SCSELC.DEF"), 0, 0, 59, -12);
+	iconVictoryCondition = std::make_shared<CAnimImage>(AnimationPath::builtin("SCNRVICT.DEF"), 0, 0, 277, -12);
+	iconLossCondition = std::make_shared<CAnimImage>(AnimationPath::builtin("SCNRLOSS.DEF"), 0, 0, 310, -12);
 }
 
 void SelectionTab::ListItem::updateItem(std::shared_ptr<ElementInfo> info, bool selected)
@@ -919,6 +1055,16 @@
 		labelNumberOfCampaignMaps->disable();
 		labelName->enable();
 		labelName->setMaxWidth(316);
+		if(info->isAutoSaveFolder) // align autosave folder left (starting timestamps in list should be in one line)
+		{
+			labelName->alignment = ETextAlignment::CENTERLEFT;
+			labelName->moveTo(Point(pos.x + 80, labelName->pos.y));
+		}
+		else
+		{
+			labelName->alignment = ETextAlignment::CENTER;
+			labelName->moveTo(Point(pos.x + LABEL_POS_X, labelName->pos.y));
+		}
 		labelName->setText(info->folderName);
 		labelName->setColor(color);
 		return;
@@ -940,6 +1086,8 @@
 		labelNumberOfCampaignMaps->setText(ostr.str());
 		labelNumberOfCampaignMaps->setColor(color);
 		labelName->setMaxWidth(316);
+		labelName->alignment = ETextAlignment::CENTER;
+		labelName->moveTo(Point(pos.x + LABEL_POS_X, labelName->pos.y));
 	}
 	else
 	{
@@ -961,7 +1109,9 @@
 		iconLossCondition->enable();
 		iconLossCondition->setFrame(info->mapHeader->defeatIconIndex, 0);
 		labelName->setMaxWidth(185);
+		labelName->alignment = ETextAlignment::CENTER;
+		labelName->moveTo(Point(pos.x + LABEL_POS_X, labelName->pos.y));
 	}
-	labelName->setText(info->getNameForList());
+	labelName->setText(info->name);
 	labelName->setColor(color);
 }
diff --color -urN vcmi-1.5.7/client/lobby/SelectionTab.h vcmi/client/lobby/SelectionTab.h
--- vcmi-1.5.7/client/lobby/SelectionTab.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/lobby/SelectionTab.h	2024-12-19 15:00:22.258121489 +0100
@@ -20,6 +20,7 @@
 class CLabel;
 class CPicture;
 class IImage;
+class CAnimation;
 
 enum ESortBy
 {
@@ -32,7 +33,9 @@
 	ElementInfo() : CMapInfo() { }
 	~ElementInfo() { }
 	std::string folderName = "";
+	std::string name = "";
 	bool isFolder = false;
+	bool isAutoSaveFolder = false;
 };
 
 /// Class which handles map sorting by different criteria
@@ -58,7 +61,9 @@
 		std::shared_ptr<CPicture> pictureEmptyLine;
 		std::shared_ptr<CLabel> labelName;
 
-		ListItem(Point position, std::shared_ptr<CAnimation> iconsFormats, std::shared_ptr<CAnimation> iconsVictory, std::shared_ptr<CAnimation> iconsLoss);
+		const int LABEL_POS_X = 184;
+
+		ListItem(Point position);
 		void updateItem(std::shared_ptr<ElementInfo> info = {}, bool selected = false);
 	};
 	std::vector<std::shared_ptr<ListItem>> listItems;
@@ -67,6 +72,8 @@
 	// FIXME: CSelectionBase use them too!
 	std::shared_ptr<CAnimation> iconsVictoryCondition;
 	std::shared_ptr<CAnimation> iconsLossCondition;
+
+	std::vector<std::shared_ptr<ListItem>> unSupportedSaves;
 public:
 	std::vector<std::shared_ptr<ElementInfo>> allItems;
 	std::vector<std::shared_ptr<ElementInfo>> curItems;
@@ -115,11 +122,16 @@
 	ESelectionScreen tabType;
 	Rect inputNameRect;
 
+	std::shared_ptr<CButton> buttonDeleteMode;
+	bool deleteMode;
+
 	auto checkSubfolder(std::string path);
 
 	bool isMapSupported(const CMapInfo & info);
 	void parseMaps(const std::unordered_set<ResourcePath> & files);
-	void parseSaves(const std::unordered_set<ResourcePath> & files);
+	std::vector<ResourcePath> parseSaves(const std::unordered_set<ResourcePath> & files);
 	void parseCampaigns(const std::unordered_set<ResourcePath> & files);
 	std::unordered_set<ResourcePath> getFiles(std::string dirURI, EResType resType);
+
+	void handleUnsupportedSavegames(const std::vector<ResourcePath> & files);
 };
diff --color -urN vcmi-1.5.7/client/mainmenu/CCampaignScreen.cpp vcmi/client/mainmenu/CCampaignScreen.cpp
--- vcmi-1.5.7/client/mainmenu/CCampaignScreen.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/mainmenu/CCampaignScreen.cpp	2024-12-19 15:00:22.259121530 +0100
@@ -14,32 +14,29 @@
 #include "CMainMenu.h"
 
 #include "../CGameInfo.h"
-#include "../CMusicHandler.h"
-#include "../CVideoHandler.h"
 #include "../CPlayerInterface.h"
 #include "../CServerHandler.h"
 #include "../gui/CGuiHandler.h"
 #include "../gui/Shortcut.h"
+#include "../media/IMusicPlayer.h"
 #include "../render/Canvas.h"
 #include "../widgets/CComponent.h"
 #include "../widgets/Buttons.h"
 #include "../widgets/MiscWidgets.h"
 #include "../widgets/ObjectLists.h"
 #include "../widgets/TextControls.h"
+#include "../widgets/VideoWidget.h"
 #include "../windows/GUIClasses.h"
 #include "../windows/InfoWindows.h"
 #include "../windows/CWindowObject.h"
 
 #include "../../lib/filesystem/Filesystem.h"
-#include "../../lib/CGeneralTextHandler.h"
+#include "../../lib/texts/CGeneralTextHandler.h"
 
 #include "../../lib/CArtHandler.h"
-#include "../../lib/CBuildingHandler.h"
 #include "../../lib/spells/CSpellHandler.h"
-
+#include "../../lib/CConfigHandler.h"
 #include "../../lib/CSkillHandler.h"
-#include "../../lib/CTownHandler.h"
-#include "../../lib/CHeroHandler.h"
 #include "../../lib/CCreatureHandler.h"
 
 #include "../../lib/campaign/CampaignHandler.h"
@@ -50,7 +47,7 @@
 CCampaignScreen::CCampaignScreen(const JsonNode & config, std::string name)
 	: CWindowObject(BORDERED), campaignSet(name)
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 
 	for(const JsonNode & node : config[name]["images"].Vector())
 		images.push_back(CMainMenu::createPicture(node));
@@ -70,7 +67,8 @@
 	}
 
 	for(const JsonNode & node : config[name]["items"].Vector())
-		campButtons.push_back(std::make_shared<CCampaignButton>(node, config, campaignSet));
+		if(CResourceHandler::get()->existsResource(ResourcePath(node["file"].String(), EResType::CAMPAIGN)))
+			campButtons.push_back(std::make_shared<CCampaignButton>(node, config, campaignSet));
 }
 
 void CCampaignScreen::activate()
@@ -92,7 +90,7 @@
 CCampaignScreen::CCampaignButton::CCampaignButton(const JsonNode & config, const JsonNode & parentConfig, std::string campaignSet)
 	: campaignSet(campaignSet)
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 
 	pos.x += static_cast<int>(config["x"].Float());
 	pos.y += static_cast<int>(config["y"].Float());
@@ -100,7 +98,7 @@
 	pos.h = 116;
 
 	campFile = config["file"].String();
-	video = VideoPath::fromJson(config["video"]);
+	videoPath = VideoPath::fromJson(config["video"]);
 
 	status = CCampaignScreen::ENABLED;
 
@@ -127,7 +125,6 @@
 	{
 		addUsedEvents(LCLICK | HOVER);
 		graphicsImage = std::make_shared<CPicture>(ImagePath::fromJson(config["image"]));
-
 		hoverLabel = std::make_shared<CLabel>(pos.w / 2, pos.h + 20, FONT_MEDIUM, ETextAlignment::CENTER, Colors::YELLOW, "");
 		parent->addChild(hoverLabel.get());
 	}
@@ -136,30 +133,19 @@
 		graphicsCompleted = std::make_shared<CPicture>(ImagePath::builtin("CAMPCHK"));
 }
 
-void CCampaignScreen::CCampaignButton::show(Canvas & to)
-{
-	if(status == CCampaignScreen::DISABLED)
-		return;
-
-	CIntObject::show(to);
-
-	// Play the campaign button video when the mouse cursor is placed over the button
-	if(isHovered())
-		CCS->videoh->update(pos.x, pos.y, to.getInternalSurface(), true, false); // plays sequentially frame by frame, starts at the beginning when the video is over
-}
-
 void CCampaignScreen::CCampaignButton::clickReleased(const Point & cursorPosition)
 {
-	CCS->videoh->close();
 	CMainMenu::openCampaignLobby(campFile, campaignSet);
 }
 
 void CCampaignScreen::CCampaignButton::hover(bool on)
 {
-	if (on)
-		CCS->videoh->open(video);
+	OBJECT_CONSTRUCTION;
+
+	if (on && !videoPath.empty())
+		videoPlayer = std::make_shared<VideoWidget>(Point(), videoPath, false);
 	else
-		CCS->videoh->close();
+		videoPlayer.reset();
 
 	if(hoverLabel)
 	{
diff --color -urN vcmi-1.5.7/client/mainmenu/CCampaignScreen.h vcmi/client/mainmenu/CCampaignScreen.h
--- vcmi-1.5.7/client/mainmenu/CCampaignScreen.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/mainmenu/CCampaignScreen.h	2024-12-19 15:00:22.259121530 +0100
@@ -20,6 +20,7 @@
 class CLabel;
 class CPicture;
 class CButton;
+class VideoWidget;
 
 class CCampaignScreen : public CWindowObject
 {
@@ -34,10 +35,11 @@
 		std::shared_ptr<CLabel> hoverLabel;
 		std::shared_ptr<CPicture> graphicsImage;
 		std::shared_ptr<CPicture> graphicsCompleted;
+		std::shared_ptr<VideoWidget> videoPlayer;
 		CampaignStatus status;
+		VideoPath videoPath;
 
 		std::string campFile; // the filename/resourcename of the campaign
-		VideoPath video; // the resource name of the video
 		std::string hoverText;
 
 		std::string campaignSet;
@@ -47,7 +49,6 @@
 
 	public:
 		CCampaignButton(const JsonNode & config, const JsonNode & parentConfig, std::string campaignSet);
-		void show(Canvas & to) override;
 	};
 
 	std::string campaignSet;
diff --color -urN vcmi-1.5.7/client/mainmenu/CHighScoreScreen.cpp vcmi/client/mainmenu/CHighScoreScreen.cpp
--- vcmi-1.5.7/client/mainmenu/CHighScoreScreen.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/mainmenu/CHighScoreScreen.cpp	2024-12-19 15:00:22.259121530 +0100
@@ -11,102 +11,38 @@
 #include "StdInc.h"
 
 #include "CHighScoreScreen.h"
+#include "CStatisticScreen.h"
+#include "CMainMenu.h"
 #include "../gui/CGuiHandler.h"
 #include "../gui/WindowHandler.h"
 #include "../gui/Shortcut.h"
+#include "../media/IMusicPlayer.h"
+#include "../media/ISoundPlayer.h"
 #include "../widgets/Buttons.h"
 #include "../widgets/CTextInput.h"
 #include "../widgets/Images.h"
 #include "../widgets/GraphicalPrimitiveCanvas.h"
+#include "../widgets/VideoWidget.h"
 #include "../windows/InfoWindows.h"
 #include "../widgets/TextControls.h"
 #include "../render/Canvas.h"
 #include "../render/IRenderHandler.h"
 
 #include "../CGameInfo.h"
-#include "../CVideoHandler.h"
-#include "../CMusicHandler.h"
-#include "../../lib/CGeneralTextHandler.h"
+#include "../../lib/texts/CGeneralTextHandler.h"
+#include "../../lib/texts/TextOperations.h"
 #include "../../lib/CConfigHandler.h"
 #include "../../lib/CCreatureHandler.h"
 #include "../../lib/constants/EntityIdentifiers.h"
-#include "../../lib/TextOperations.h"
-#include "../../lib/Languages.h"
-
-auto HighScoreCalculation::calculate()
-{
-	struct Result
-	{
-		int basic = 0;
-		int total = 0;
-		int sumDays = 0;
-		bool cheater = false;
-	};
-	
-	Result firstResult;
-	Result summary;
-	const std::array<double, 5> difficultyMultipliers{0.8, 1.0, 1.3, 1.6, 2.0}; 
-	for(auto & param : parameters)
-	{
-		double tmp = 200 - (param.day + 10) / (param.townAmount + 5) + (param.allDefeated ? 25 : 0) + (param.hasGrail ? 25 : 0);
-		firstResult = Result{static_cast<int>(tmp), static_cast<int>(tmp * difficultyMultipliers.at(param.difficulty)), param.day, param.usedCheat};
-		summary.basic += firstResult.basic * 5.0 / parameters.size();
-		summary.total += firstResult.total * 5.0 / parameters.size();
-		summary.sumDays += firstResult.sumDays;
-		summary.cheater |= firstResult.cheater;
-	}
-
-	if(parameters.size() == 1)
-		return firstResult;
-
-	return summary;
-}
-
-struct HighScoreCreature
-{
-	CreatureID creature;
-	int min;
-	int max;
-};
-
-static std::vector<HighScoreCreature> getHighscoreCreaturesList()
-{
-	JsonNode configCreatures(JsonPath::builtin("CONFIG/highscoreCreatures.json"));
-
-	std::vector<HighScoreCreature> ret;
-
-	for(auto & json : configCreatures["creatures"].Vector())
-	{
-		HighScoreCreature entry;
-		entry.creature = CreatureID::decode(json["creature"].String());
-		entry.max = json["max"].isNull() ? std::numeric_limits<int>::max() : json["max"].Integer();
-		entry.min = json["min"].isNull() ? std::numeric_limits<int>::min() : json["min"].Integer();
-
-		ret.push_back(entry);
-	}
-
-	return ret;
-}
-
-CreatureID HighScoreCalculation::getCreatureForPoints(int points, bool campaign)
-{
-	static const std::vector<HighScoreCreature> creatures = getHighscoreCreaturesList();
-
-	int divide = campaign ? 5 : 1;
-
-	for(auto & creature : creatures)
-		if(points / divide <= creature.max && points / divide >= creature.min)
-			return creature.creature;
-
-	throw std::runtime_error("Unable to find creature for score " + std::to_string(points));
-}
+#include "../../lib/gameState/HighScore.h"
+#include "../../lib/gameState/GameStatistics.h"
 
 CHighScoreScreen::CHighScoreScreen(HighScorePage highscorepage, int highlighted)
 	: CWindowObject(BORDERED), highscorepage(highscorepage), highlighted(highlighted)
 {
 	addUsedEvents(SHOW_POPUP);
 
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 	pos = center(Rect(0, 0, 800, 600));
 
 	backgroundAroundMenu = std::make_shared<CFilledTexture>(ImagePath::builtin("DIBOXBCK"), Rect(-pos.x, -pos.y, GH.screenDimensions().x, GH.screenDimensions().y));
@@ -133,19 +69,19 @@
 
 void CHighScoreScreen::addButtons()
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 	
 	buttons.clear();
 
-	buttons.push_back(std::make_shared<CButton>(Point(31, 113), AnimationPath::builtin("HISCCAM.DEF"), CButton::tooltip(), [&](){ buttonCampaignClick(); }, EShortcut::HIGH_SCORES_CAMPAIGNS));
-	buttons.push_back(std::make_shared<CButton>(Point(31, 345), AnimationPath::builtin("HISCSTA.DEF"), CButton::tooltip(), [&](){ buttonScenarioClick(); }, EShortcut::HIGH_SCORES_SCENARIOS));
-	buttons.push_back(std::make_shared<CButton>(Point(726, 113), AnimationPath::builtin("HISCRES.DEF"), CButton::tooltip(), [&](){ buttonResetClick(); }, EShortcut::HIGH_SCORES_RESET));
-	buttons.push_back(std::make_shared<CButton>(Point(726, 345), AnimationPath::builtin("HISCEXT.DEF"), CButton::tooltip(), [&](){ buttonExitClick(); }, EShortcut::GLOBAL_RETURN));
+	buttons.push_back(std::make_shared<CButton>(Point(31, 113), AnimationPath::builtin("HISCCAM.DEF"), CButton::tooltip(),  [this](){ buttonCampaignClick(); }, EShortcut::HIGH_SCORES_CAMPAIGNS));
+	buttons.push_back(std::make_shared<CButton>(Point(31, 345), AnimationPath::builtin("HISCSTA.DEF"), CButton::tooltip(),  [this](){ buttonScenarioClick(); }, EShortcut::HIGH_SCORES_SCENARIOS));
+	buttons.push_back(std::make_shared<CButton>(Point(726, 113), AnimationPath::builtin("HISCRES.DEF"), CButton::tooltip(), [this](){ buttonResetClick(); }, EShortcut::HIGH_SCORES_RESET));
+	buttons.push_back(std::make_shared<CButton>(Point(726, 345), AnimationPath::builtin("HISCEXT.DEF"), CButton::tooltip(), [this](){ buttonExitClick(); }, EShortcut::GLOBAL_RETURN));
 }
 
 void CHighScoreScreen::addHighScores()
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 
 	background = std::make_shared<CPicture>(ImagePath::builtin(highscorepage == HighScorePage::SCENARIO ? "HISCORE" : "HISCORE2"));
 
@@ -208,7 +144,7 @@
 
 void CHighScoreScreen::buttonScenarioClick()
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 	highscorepage = HighScorePage::SCENARIO;
 	addHighScores();
 	addButtons();
@@ -235,14 +171,15 @@
 void CHighScoreScreen::buttonExitClick()
 {
 	close();
+	CMM->playMusic();
 }
 
-CHighScoreInputScreen::CHighScoreInputScreen(bool won, HighScoreCalculation calc)
-	: CWindowObject(BORDERED), won(won), calc(calc), videoSoundHandle(-1)
+CHighScoreInputScreen::CHighScoreInputScreen(bool won, HighScoreCalculation calc, const StatisticDataSet & statistic)
+	: CWindowObject(BORDERED), won(won), calc(calc), stat(statistic)
 {
 	addUsedEvents(LCLICK | KEYBOARD);
 
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 	pos = center(Rect(0, 0, 800, 600));
 
 	backgroundAroundMenu = std::make_shared<CFilledTexture>(ImagePath::builtin("DIBOXBCK"), Rect(-pos.x, -pos.y, GH.screenDimensions().x, GH.screenDimensions().y));
@@ -250,6 +187,9 @@
 
 	if(won)
 	{
+
+		videoPlayer = std::make_shared<VideoWidget>(Point(0, 0), VideoPath::builtin("HSANIM.SMK"), VideoPath::builtin("HSLOOP.SMK"), true);
+
 		int border = 100;
 		int textareaW = ((pos.w - 2 * border) / 4);
 		std::vector<std::string> t = { "438", "439", "440", "441", "676" }; // time, score, difficulty, final score, rank
@@ -264,9 +204,21 @@
 		CCS->musich->playMusic(AudioPath::builtin("music/Win Scenario"), true, true);
 	}
 	else
+	{
+		videoPlayer = std::make_shared<VideoWidgetOnce>(Point(0, 0), VideoPath::builtin("LOSEGAME.SMK"), true, this);
 		CCS->musich->playMusic(AudioPath::builtin("music/UltimateLose"), false, true);
+	}
 
-	video = won ? "HSANIM.SMK" : "LOSEGAME.SMK";
+	if (settings["general"]["enableUiEnhancements"].Bool())
+	{
+		statisticButton = std::make_shared<CButton>(Point(726, 10), AnimationPath::builtin("TPTAV02.DEF"), CButton::tooltip(CGI->generaltexth->translate("vcmi.statisticWindow.statistics")), [this](){ GH.windows().createAndPushWindow<CStatisticScreen>(stat); }, EShortcut::HIGH_SCORES_STATISTICS);
+		texts.push_back(std::make_shared<CLabel>(716, 25, EFonts::FONT_HIGH_SCORE, ETextAlignment::CENTERRIGHT, Colors::WHITE, CGI->generaltexth->translate("vcmi.statisticWindow.statistics") + ":"));
+	}
+}
+
+void CHighScoreInputScreen::onVideoPlaybackFinished()
+{
+	close();
 }
 
 int CHighScoreInputScreen::addEntry(std::string text) {
@@ -311,56 +263,15 @@
 
 void CHighScoreInputScreen::show(Canvas & to)
 {
-	if(background)
-		background->show(to);
-
-	CCS->videoh->update(pos.x, pos.y, to.getInternalSurface(), true, false,
-	[&]()
-	{
-		if(won)
-		{
-			CCS->videoh->close();
-			video = "HSLOOP.SMK";
-			auto audioData = CCS->videoh->getAudio(VideoPath::builtin(video));
-			videoSoundHandle = CCS->soundh->playSound(audioData);
-			CCS->videoh->open(VideoPath::builtin(video));
-		}
-		else
-			close();
-	});
-
-	if(input)
-		input->showAll(to);
-	for(auto & text : texts)
-		text->showAll(to);
-
-	CIntObject::show(to);
-}
-
-void CHighScoreInputScreen::activate()
-{
-	auto audioData = CCS->videoh->getAudio(VideoPath::builtin(video));
-	videoSoundHandle = CCS->soundh->playSound(audioData);
-	if(!CCS->videoh->open(VideoPath::builtin(video)))
-	{
-		if(!won)
-			close();
-	}
-	else
-		background = nullptr;
-	CIntObject::activate();
-}
-
-void CHighScoreInputScreen::deactivate()
-{
-	CCS->videoh->close();
-	CCS->soundh->stopSound(videoSoundHandle);
-	CIntObject::deactivate();
+	CWindowObject::showAll(to);
 }
 
 void CHighScoreInputScreen::clickPressed(const Point & cursorPosition)
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	if(statisticButton->pos.isInside(cursorPosition))
+		return;
+
+	OBJECT_CONSTRUCTION;
 
 	if(!won)
 	{
@@ -387,13 +298,15 @@
 
 void CHighScoreInputScreen::keyPressed(EShortcut key)
 {
+	if(key == EShortcut::HIGH_SCORES_STATISTICS) // ignore shortcut for skipping video with key
+		return;
 	clickPressed(Point());
 }
 
 CHighScoreInput::CHighScoreInput(std::string playerName, std::function<void(std::string text)> readyCB)
 	: CWindowObject(NEEDS_ANIMATED_BACKGROUND, ImagePath::builtin("HIGHNAME")), ready(readyCB)
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 
 	pos = center(Rect(0, 0, 232, 212));
 	updateShadow();
diff --color -urN vcmi-1.5.7/client/mainmenu/CHighScoreScreen.h vcmi/client/mainmenu/CHighScoreScreen.h
--- vcmi-1.5.7/client/mainmenu/CHighScoreScreen.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/mainmenu/CHighScoreScreen.h	2024-12-19 15:00:22.259121530 +0100
@@ -8,41 +8,22 @@
  *
  */
 #pragma once
+
+#include "../widgets/IVideoHolder.h"
 #include "../windows/CWindowObject.h"
+#include "../../lib/gameState/HighScore.h"
+#include "../../lib/gameState/GameStatistics.h"
 
 class CButton;
 class CLabel;
 class CMultiLineLabel;
 class CAnimImage;
 class CTextInput;
+class VideoWidgetBase;
 class CFilledTexture;
 
 class TransparentFilledRectangle;
 
-class HighScoreParameter
-{
-public:
-	int difficulty;
-	int day;
-	int townAmount;
-	bool usedCheat;
-	bool hasGrail;
-	bool allDefeated;
-	std::string campaignName;
-	std::string scenarioName;
-	std::string playerName;
-};
-
-class HighScoreCalculation
-{
-public:
-	std::vector<HighScoreParameter> parameters = std::vector<HighScoreParameter>();
-	bool isCampaign = false;
-
-	auto calculate();
-	static CreatureID getCreatureForPoints(int points, bool campaign);
-};
-
 class CHighScoreScreen : public CWindowObject
 {
 public:
@@ -90,25 +71,27 @@
 	CHighScoreInput(std::string playerName, std::function<void(std::string text)> readyCB);
 };
 
-class CHighScoreInputScreen : public CWindowObject
+class CHighScoreInputScreen : public CWindowObject, public IVideoHolder
 {
-	std::vector<std::shared_ptr<CMultiLineLabel>> texts;
+	std::vector<std::shared_ptr<CLabel>> texts;
 	std::shared_ptr<CHighScoreInput> input;
 	std::shared_ptr<TransparentFilledRectangle> background;
+	std::shared_ptr<VideoWidgetBase> videoPlayer;
 	std::shared_ptr<CFilledTexture> backgroundAroundMenu;
 
-	std::string video;
-	int videoSoundHandle;
+	std::shared_ptr<CButton> statisticButton;
+
 	bool won;
 	HighScoreCalculation calc;
+	StatisticDataSet stat;
+
+	void onVideoPlaybackFinished() override;
 public:
-	CHighScoreInputScreen(bool won, HighScoreCalculation calc);
+	CHighScoreInputScreen(bool won, HighScoreCalculation calc, const StatisticDataSet & statistic);
 
 	int addEntry(std::string text);
 
-	void show(Canvas & to) override;
-	void activate() override;
-	void deactivate() override;
 	void clickPressed(const Point & cursorPosition) override;
 	void keyPressed(EShortcut key) override;
-};
\ No newline at end of file
+	void show(Canvas & to) override;
+};
diff --color -urN vcmi-1.5.7/client/mainmenu/CMainMenu.cpp vcmi/client/mainmenu/CMainMenu.cpp
--- vcmi-1.5.7/client/mainmenu/CMainMenu.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/mainmenu/CMainMenu.cpp	2024-12-19 15:00:22.259121530 +0100
@@ -17,6 +17,8 @@
 #include "../lobby/CBonusSelection.h"
 #include "../lobby/CSelectionBase.h"
 #include "../lobby/CLobbyScreen.h"
+#include "../media/IMusicPlayer.h"
+#include "../media/IVideoPlayer.h"
 #include "../gui/CursorHandler.h"
 #include "../windows/GUIClasses.h"
 #include "../gui/CGuiHandler.h"
@@ -33,21 +35,20 @@
 #include "../widgets/MiscWidgets.h"
 #include "../widgets/ObjectLists.h"
 #include "../widgets/TextControls.h"
+#include "../widgets/VideoWidget.h"
 #include "../windows/InfoWindows.h"
 #include "../CServerHandler.h"
+#include "../render/AssetGenerator.h"
 
 #include "../CGameInfo.h"
-#include "../CMusicHandler.h"
-#include "../CVideoHandler.h"
 #include "../CPlayerInterface.h"
 #include "../Client.h"
 #include "../CMT.h"
 
 #include "../../CCallback.h"
 
-#include "../../lib/CGeneralTextHandler.h"
+#include "../../lib/texts/CGeneralTextHandler.h"
 #include "../../lib/campaign/CampaignHandler.h"
-#include "../../lib/serializer/CTypeList.h"
 #include "../../lib/filesystem/Filesystem.h"
 #include "../../lib/filesystem/CCompressedStream.h"
 #include "../../lib/mapping/CMapInfo.h"
@@ -73,7 +74,7 @@
 CMenuScreen::CMenuScreen(const JsonNode & configNode)
 	: CWindowObject(BORDERED), config(configNode)
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 
 	background = std::make_shared<CPicture>(ImagePath::fromJson(config["background"]));
 	if(config["scalable"].Bool())
@@ -81,6 +82,12 @@
 
 	pos = background->center();
 
+	if(!config["video"].isNull())
+	{
+		Point videoPosition(config["video"]["x"].Integer(), config["video"]["y"].Integer());
+		videoPlayer = std::make_shared<VideoWidget>(videoPosition, VideoPath::fromJson(config["video"]["name"]), false);
+	}
+
 	for(const JsonNode & node : config["items"].Vector())
 		menuNameToEntry.push_back(node["name"].String());
 
@@ -93,6 +100,7 @@
 	tabs = std::make_shared<CTabbedInt>(std::bind(&CMenuScreen::createTab, this, _1));
 	if(config["video"].isNull())
 		tabs->setRedrawParent(true);
+
 }
 
 std::shared_ptr<CIntObject> CMenuScreen::createTab(size_t index)
@@ -105,32 +113,15 @@
 
 void CMenuScreen::show(Canvas & to)
 {
-	if(!config["video"].isNull())
-	{
-		// redraw order: background -> video -> buttons and pictures
-		background->showAll(to);
-		CCS->videoh->update((int)config["video"]["x"].Float() + pos.x, (int)config["video"]["y"].Float() + pos.y, to.getInternalSurface(), true, false);
-		tabs->showAll(to);
-	}
-	CIntObject::show(to);
+	// TODO: avoid excessive redraws
+	CIntObject::showAll(to);
 }
 
 void CMenuScreen::activate()
 {
-	CCS->musich->playMusic(AudioPath::builtin("Music/MainMenu"), true, true);
-	if(!config["video"].isNull())
-		CCS->videoh->open(VideoPath::fromJson(config["video"]["name"]));
 	CIntObject::activate();
 }
 
-void CMenuScreen::deactivate()
-{
-	if(!config["video"].isNull())
-		CCS->videoh->close();
-
-	CIntObject::deactivate();
-}
-
 void CMenuScreen::switchToTab(size_t index)
 {
 	tabs->setActive(index);
@@ -146,7 +137,7 @@
 	return tabs->getActive();
 }
 
-//funciton for std::string -> std::function conversion for main menu
+//function for std::string -> std::function conversion for main menu
 static std::function<void()> genCommand(CMenuScreen * menu, std::vector<std::string> menuType, const std::string & string)
 {
 	static const std::vector<std::string> commandType = {"to", "campaigns", "start", "load", "exit", "highscores"};
@@ -181,13 +172,13 @@
 				switch(std::find(gameType.begin(), gameType.end(), commands.front()) - gameType.begin())
 				{
 				case 0:
-					return []() { CMainMenu::openLobby(ESelectionScreen::newGame, true, {}, ELoadMode::NONE);};
+					return []() { CMainMenu::openLobby(ESelectionScreen::newGame, true, {}, ELoadMode::NONE); };
 				case 1:
 					return []() { GH.windows().createAndPushWindow<CMultiMode>(ESelectionScreen::newGame); };
 				case 2:
-					return []() { CMainMenu::openLobby(ESelectionScreen::campaignList, true, {}, ELoadMode::NONE);};
+					return []() { CMainMenu::openLobby(ESelectionScreen::campaignList, true, {}, ELoadMode::NONE); };
 				case 3:
-					return std::bind(CMainMenu::startTutorial);
+					return []() { CMainMenu::startTutorial(); };
 				}
 				break;
 			}
@@ -196,25 +187,25 @@
 				switch(std::find(gameType.begin(), gameType.end(), commands.front()) - gameType.begin())
 				{
 				case 0:
-					return []() { CMainMenu::openLobby(ESelectionScreen::loadGame, true, {}, ELoadMode::SINGLE);};
+					return []() { CMainMenu::openLobby(ESelectionScreen::loadGame, true, {}, ELoadMode::SINGLE); };
 				case 1:
 					return []() { GH.windows().createAndPushWindow<CMultiMode>(ESelectionScreen::loadGame); };
 				case 2:
-					return []() { CMainMenu::openLobby(ESelectionScreen::loadGame, true, {}, ELoadMode::CAMPAIGN);};
+					return []() { CMainMenu::openLobby(ESelectionScreen::loadGame, true, {}, ELoadMode::CAMPAIGN); };
 				case 3:
-					return []() { CMainMenu::openLobby(ESelectionScreen::loadGame, true, {}, ELoadMode::TUTORIAL);};
+					return []() { CMainMenu::openLobby(ESelectionScreen::loadGame, true, {}, ELoadMode::TUTORIAL); };
 
 				}
 			}
 			break;
 			case 4: //exit
 			{
-				return std::bind(CInfoWindow::showYesNoDialog, CGI->generaltexth->allTexts[69], std::vector<std::shared_ptr<CComponent>>(), do_quit, 0, PlayerColor(1));
+				return []() { CInfoWindow::showYesNoDialog(CGI->generaltexth->allTexts[69], std::vector<std::shared_ptr<CComponent>>(), do_quit, 0, PlayerColor(1)); };
 			}
 			break;
 			case 5: //highscores
 			{
-				return std::bind(CMainMenu::openHighScoreScreen);
+				return []() { CMainMenu::openHighScoreScreen(); };
 			}
 			}
 		}
@@ -255,7 +246,7 @@
 
 CMenuEntry::CMenuEntry(CMenuScreen * parent, const JsonNode & config)
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 	setRedrawParent(true);
 	pos = parent->pos;
 
@@ -299,9 +290,8 @@
 	pos.w = GH.screenDimensions().x;
 	pos.h = GH.screenDimensions().y;
 
-	GH.defActionsDef = 63;
 	menu = std::make_shared<CMenuScreen>(CMainMenuConfig::get().getConfig()["window"]);
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 	backgroundAroundMenu = std::make_shared<CFilledTexture>(ImagePath::builtin("DIBOXBCK"), pos);
 }
 
@@ -311,6 +301,35 @@
 		GH.curInt = nullptr;
 }
 
+void CMainMenu::playIntroVideos()
+{
+	auto playVideo = [](std::string video, bool rim, float scaleFactor, std::function<void(bool)> cb){
+		if(CCS->videoh->open(VideoPath::builtin(video), scaleFactor))
+			GH.windows().createAndPushWindow<VideoWindow>(VideoPath::builtin(video), rim ? ImagePath::builtin("INTRORIM") : ImagePath::builtin(""), true, scaleFactor, [cb](bool skipped){ cb(skipped); });
+		else
+			cb(true);
+	};
+
+	playVideo("3DOLOGO.SMK", false, 1.25, [playVideo, this](bool skipped){
+		if(!skipped)
+			playVideo("NWCLOGO.SMK", false, 2, [playVideo, this](bool skipped){
+				if(!skipped)
+					playVideo("H3INTRO.SMK", true, 1, [this](bool skipped){
+						playMusic();
+					});
+				else
+					playMusic();
+			});
+		else
+			playMusic();
+	});
+}
+
+void CMainMenu::playMusic()
+{
+	CCS->musich->playMusic(AudioPath::builtin("Music/MainMenu"), true, true);
+}
+
 void CMainMenu::activate()
 {
 	// check if screen was resized while main menu was inactive - e.g. in gameplay mode
@@ -343,17 +362,6 @@
 		menu->switchToTab(menu->getActiveTab());
 	}
 
-	static bool warnedAboutModDependencies = false;
-
-	if (!warnedAboutModDependencies)
-	{
-		warnedAboutModDependencies = true;
-		auto errorMessages = CGI->modh->getModLoadErrors();
-
-		if (!errorMessages.empty())
-			CInfoWindow::showInfoDialog(errorMessages, std::vector<std::shared_ptr<CComponent>>(), PlayerColor(1));
-	}
-
 	// Handles mouse and key input
 	GH.handleEvents();
 	GH.windows().simpleRedraw();
@@ -385,6 +393,9 @@
 {
 	auto const & config = CMainMenuConfig::get().getCampaigns();
 
+	AssetGenerator::createCampaignBackground();
+	AssetGenerator::createChroniclesCampaignImages();
+
 	if(!vstd::contains(config.Struct(), name))
 	{
 		logGlobal->error("Unknown campaign set: %s", name);
@@ -395,7 +406,9 @@
 	for (auto const & entry : config[name]["items"].Vector())
 	{
 		ResourcePath resourceID(entry["file"].String(), EResType::CAMPAIGN);
-		if (!CResourceHandler::get()->existsResource(resourceID))
+		if(entry["optional"].Bool())
+			continue;
+		if(!CResourceHandler::get()->existsResource(resourceID))
 			campaignsFound = false;
 	}
 
@@ -445,7 +458,7 @@
 CMultiMode::CMultiMode(ESelectionScreen ScreenType)
 	: screenType(ScreenType)
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 
 	background = std::make_shared<CPicture>(ImagePath::builtin("MUPOPUP.bmp"));
 	pos = background->center(); //center, window has size of bg graphic
@@ -454,7 +467,7 @@
 
 	statusBar = CGStatusBar::create(std::make_shared<CPicture>(background->getSurface(), Rect(7, 465, 440, 18), 7, 465));
 	playerName = std::make_shared<CTextInput>(Rect(19, 436, 334, 16), background->getSurface());
-	playerName->setText(getPlayerName());
+	playerName->setText(getPlayersNames()[0]);
 	playerName->setCallback(std::bind(&CMultiMode::onNameChange, this, _1));
 
 	buttonHotseat = std::make_shared<CButton>(Point(373, 78 + 57 * 0), AnimationPath::builtin("MUBHOT.DEF"), CGI->generaltexth->zelp[266], std::bind(&CMultiMode::hostTCP, this), EShortcut::MAIN_MENU_HOTSEAT);
@@ -476,22 +489,35 @@
 {
 	auto savedScreenType = screenType;
 	close();
-	GH.windows().createAndPushWindow<CMultiPlayers>(getPlayerName(), savedScreenType, true, ELoadMode::MULTI);
+	GH.windows().createAndPushWindow<CMultiPlayers>(getPlayersNames(), savedScreenType, true, ELoadMode::MULTI);
 }
 
 void CMultiMode::joinTCP()
 {
 	auto savedScreenType = screenType;
 	close();
-	GH.windows().createAndPushWindow<CMultiPlayers>(getPlayerName(), savedScreenType, false, ELoadMode::MULTI);
+	GH.windows().createAndPushWindow<CMultiPlayers>(getPlayersNames(), savedScreenType, false, ELoadMode::MULTI);
 }
 
-std::string CMultiMode::getPlayerName()
+std::vector<std::string> CMultiMode::getPlayersNames()
 {
-	std::string name = settings["general"]["playerName"].String();
-	if(name == "Player")
-		name = CGI->generaltexth->translate("core.genrltxt.434");
-	return name;
+	std::vector<std::string> playerNames;
+
+	std::string playerNameStr = settings["general"]["playerName"].String();
+	if (playerNameStr == "Player")
+		playerNameStr = CGI->generaltexth->translate("core.genrltxt.434");
+	playerNames.push_back(playerNameStr);
+
+	for (const auto & playerName : settings["general"]["multiPlayerNames"].Vector())
+	{
+		const std::string &nameStr = playerName.String();
+		if (!nameStr.empty())
+		{
+			playerNames.push_back(nameStr);
+		}
+	}
+
+	return playerNames;
 }
 
 void CMultiMode::onNameChange(std::string newText)
@@ -500,16 +526,16 @@
 	name->String() = newText;
 }
 
-CMultiPlayers::CMultiPlayers(const std::string & firstPlayer, ESelectionScreen ScreenType, bool Host, ELoadMode LoadMode)
+CMultiPlayers::CMultiPlayers(const std::vector<std::string> & playerNames, ESelectionScreen ScreenType, bool Host, ELoadMode LoadMode)
 	: loadMode(LoadMode), screenType(ScreenType), host(Host)
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 	background = std::make_shared<CPicture>(ImagePath::builtin("MUHOTSEA.bmp"));
 	pos = background->center(); //center, window has size of bg graphic
 
 	std::string text = CGI->generaltexth->allTexts[446];
 	boost::replace_all(text, "\t", "\n");
-	textTitle = std::make_shared<CTextBox>(text, Rect(25, 20, 315, 50), 0, FONT_BIG, ETextAlignment::CENTER, Colors::WHITE); //HOTSEAT	Please enter names
+	textTitle = std::make_shared<CTextBox>(text, Rect(25, 10, 315, 60), 0, FONT_BIG, ETextAlignment::CENTER, Colors::WHITE); //HOTSEAT	Please enter names
 
 	for(int i = 0; i < inputNames.size(); i++)
 	{
@@ -521,7 +547,10 @@
 	buttonCancel = std::make_shared<CButton>(Point(205, 338), AnimationPath::builtin("MUBCANC.DEF"), CGI->generaltexth->zelp[561], [=](){ close();}, EShortcut::GLOBAL_CANCEL);
 	statusBar = CGStatusBar::create(std::make_shared<CPicture>(background->getSurface(), Rect(7, 381, 348, 18), 7, 381));
 
-	inputNames[0]->setText(firstPlayer);
+	for(int i = 0; i < playerNames.size(); i++)
+	{
+		inputNames[i]->setText(playerNames[i]);
+	}
 #ifndef VCMI_MOBILE
 	inputNames[0]->giveFocus();
 #endif
@@ -533,22 +562,39 @@
 
 void CMultiPlayers::enterSelectionScreen()
 {
-	std::vector<std::string> names;
-	for(auto name : inputNames)
+	std::vector<std::string> playerNames;
+	for(auto playerName : inputNames)
 	{
-		if(name->getText().length())
-			names.push_back(name->getText());
+		if (playerName->getText().length())
+			playerNames.push_back(playerName->getText());
 	}
 
-	Settings name = settings.write["general"]["playerName"];
-	name->String() = names[0];
+	Settings playerName = settings.write["general"]["playerName"];
+	Settings multiPlayerNames = settings.write["general"]["multiPlayerNames"];
+	multiPlayerNames->Vector().clear();
+	if (!playerNames.empty())
+	{
+		playerName->String() = playerNames.front();
+		for (auto playerNameIt = playerNames.begin()+1; playerNameIt != playerNames.end(); playerNameIt++)
+		{
+			multiPlayerNames->Vector().push_back(JsonNode(*playerNameIt));
+		}
+	}
+	else
+	{
+		// Without the check the saving crashes directly.
+		// When empty reset the player's name. This would translate to it being
+		// the default for the next run. But enables deleting players, by just
+		// deleting the names, otherwise some UI element should have been added.
+		playerName->clear();
+	}
 
-	CMainMenu::openLobby(screenType, host, names, loadMode);
+	CMainMenu::openLobby(screenType, host, playerNames, loadMode);
 }
 
 CSimpleJoinScreen::CSimpleJoinScreen(bool host)
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 	background = std::make_shared<CPicture>(ImagePath::builtin("MUDIALOG.bmp")); // address background
 	pos = background->center(); //center, window has size of bg graphic (x,y = 396,278 w=232 h=212)
 
@@ -607,9 +653,14 @@
 }
 
 CLoadingScreen::CLoadingScreen()
-	: CWindowObject(BORDERED, getBackground())
+	: CLoadingScreen(getBackground())
+{
+}
+
+CLoadingScreen::CLoadingScreen(ImagePath background)
+	: CWindowObject(BORDERED, background)
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 	
 	addUsedEvents(TIME);
 	
diff --color -urN vcmi-1.5.7/client/mainmenu/CMainMenu.h vcmi/client/mainmenu/CMainMenu.h
--- vcmi-1.5.7/client/mainmenu/CMainMenu.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/mainmenu/CMainMenu.h	2024-12-19 15:00:22.260121572 +0100
@@ -24,11 +24,10 @@
 class CTextBox;
 class CTabbedInt;
 class CAnimImage;
-class CAnimation;
 class CButton;
 class CFilledTexture;
 class CLabel;
-
+class VideoWidget;
 
 // TODO: Find new location for these enums
 enum class ESelectionScreen : ui8 {
@@ -48,6 +47,7 @@
 	std::shared_ptr<CTabbedInt> tabs;
 
 	std::shared_ptr<CPicture> background;
+	std::shared_ptr<VideoWidget> videoPlayer;
 	std::vector<std::shared_ptr<CPicture>> images;
 
 	std::shared_ptr<CIntObject> createTab(size_t index);
@@ -57,9 +57,8 @@
 
 	CMenuScreen(const JsonNode & configNode);
 
-	void show(Canvas & to) override;
 	void activate() override;
-	void deactivate() override;
+	void show(Canvas & to) override;
 
 	void switchToTab(size_t index);
 	void switchToTab(std::string name);
@@ -96,7 +95,9 @@
 	void openLobby();
 	void hostTCP();
 	void joinTCP();
-	std::string getPlayerName();
+
+	/// Get all configured player names. The first name would always be present and initialized to its default value.
+	std::vector<std::string> getPlayersNames();
 
 	void onNameChange(std::string newText);
 };
@@ -118,7 +119,7 @@
 	void enterSelectionScreen();
 
 public:
-	CMultiPlayers(const std::string & firstPlayer, ESelectionScreen ScreenType, bool Host, ELoadMode LoadMode);
+	CMultiPlayers(const std::vector<std::string> & playerNames, ESelectionScreen ScreenType, bool Host, ELoadMode LoadMode);
 };
 
 /// Manages the configuration of pregame GUI elements like campaign screen, main menu, loading screen,...
@@ -141,6 +142,8 @@
 {
 	std::shared_ptr<CFilledTexture> backgroundAroundMenu;
 
+	std::vector<VideoPath> videoPlayList;
+
 	CMainMenu(); //Use CMainMenu::create
 
 public:
@@ -161,6 +164,8 @@
 
 	static std::shared_ptr<CPicture> createPicture(const JsonNode & config);
 
+	void playIntroVideos();
+	void playMusic();
 };
 
 /// Simple window to enter the server's address.
@@ -191,6 +196,7 @@
 
 public:	
 	CLoadingScreen();
+	CLoadingScreen(ImagePath background);
 	~CLoadingScreen();
 
 	void tick(uint32_t msPassed) override;
diff --color -urN vcmi-1.5.7/client/mainmenu/CPrologEpilogVideo.cpp vcmi/client/mainmenu/CPrologEpilogVideo.cpp
--- vcmi-1.5.7/client/mainmenu/CPrologEpilogVideo.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/mainmenu/CPrologEpilogVideo.cpp	2024-12-19 15:00:22.260121572 +0100
@@ -12,28 +12,43 @@
 
 #include "CPrologEpilogVideo.h"
 #include "../CGameInfo.h"
-#include "../CMusicHandler.h"
-#include "../CVideoHandler.h"
-#include "../gui/WindowHandler.h"
+#include "../media/IMusicPlayer.h"
+#include "../media/ISoundPlayer.h"
+//#include "../gui/WindowHandler.h"
 #include "../gui/CGuiHandler.h"
-#include "../gui/FramerateManager.h"
+//#include "../gui/FramerateManager.h"
 #include "../widgets/TextControls.h"
+#include "../widgets/VideoWidget.h"
 #include "../widgets/Images.h"
 #include "../render/Canvas.h"
 
-
 CPrologEpilogVideo::CPrologEpilogVideo(CampaignScenarioPrologEpilog _spe, std::function<void()> callback)
 	: CWindowObject(BORDERED), spe(_spe), positionCounter(0), voiceSoundHandle(-1), videoSoundHandle(-1), exitCb(callback), elapsedTimeMilliseconds(0)
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 	addUsedEvents(LCLICK | TIME);
 	pos = center(Rect(0, 0, 800, 600));
 
 	backgroundAroundMenu = std::make_shared<CFilledTexture>(ImagePath::builtin("DIBOXBCK"), Rect(-pos.x, -pos.y, GH.screenDimensions().x, GH.screenDimensions().y));
 
-	auto audioData = CCS->videoh->getAudio(spe.prologVideo);
-	videoSoundHandle = CCS->soundh->playSound(audioData, -1);
-	CCS->videoh->open(spe.prologVideo);
+	//TODO: remove hardcoded paths. Some of campaigns video actually consist from 2 parts
+	// however, currently our campaigns format expects only	a single video file
+	static const std::map<VideoPath, VideoPath> pairedVideoFiles = {
+		{ VideoPath::builtin("EVIL2AP1"),  VideoPath::builtin("EVIL2AP2") },
+		{ VideoPath::builtin("H3ABdb4"),   VideoPath::builtin("H3ABdb4b") },
+		{ VideoPath::builtin("H3x2_RNe1"), VideoPath::builtin("H3x2_RNe2") },
+	};
+
+	if (pairedVideoFiles.count(spe.prologVideo))
+		videoPlayer = std::make_shared<VideoWidget>(Point(0, 0), spe.prologVideo, pairedVideoFiles.at(spe.prologVideo), true);
+	else
+		videoPlayer = std::make_shared<VideoWidget>(Point(0, 0), spe.prologVideo, true);
+
+	//some videos are 800x600 in size while some are 800x400
+	if (videoPlayer->pos.h == 400)
+		videoPlayer->moveBy(Point(0, 100));
+
+	CCS->musich->setVolume(CCS->musich->getVolume() / 2); // background volume is too loud by default
 	CCS->musich->playMusic(spe.prologMusic, true, true);
 	voiceDurationMilliseconds = CCS->soundh->getSoundDurationMilliseconds(spe.prologVoice);
 	voiceSoundHandle = CCS->soundh->playSound(spe.prologVoice);
@@ -45,7 +60,10 @@
 	CCS->soundh->setCallback(voiceSoundHandle, onVoiceStop);
 
 	text = std::make_shared<CMultiLineLabel>(Rect(100, 500, 600, 100), EFonts::FONT_BIG, ETextAlignment::CENTER, Colors::METALLIC_GOLD, spe.prologText.toString());
-	text->scrollTextTo(-50); // beginning of text in the vertical middle of black area
+	if(text->getLines().size() == 3)
+		text->scrollTextTo(-25); // beginning of text in the vertical middle of black area
+	else if(text->getLines().size() > 3)
+		text->scrollTextTo(-50); // beginning of text in the vertical middle of black area
 }
 
 void CPrologEpilogVideo::tick(uint32_t msPassed)
@@ -67,14 +85,14 @@
 void CPrologEpilogVideo::show(Canvas & to)
 {
 	to.drawColor(pos, Colors::BLACK);
-	//some videos are 800x600 in size while some are 800x400
-	CCS->videoh->update(pos.x, pos.y + (CCS->videoh->size().y == 400 ? 100 : 0), to.getInternalSurface(), true, false);
 
+	videoPlayer->show(to);
 	text->showAll(to); // blit text over video, if needed
 }
 
 void CPrologEpilogVideo::clickPressed(const Point & cursorPosition)
 {
+	CCS->musich->setVolume(CCS->musich->getVolume() * 2); // restore background volume
 	close();
 	CCS->soundh->resetCallback(voiceSoundHandle); // reset callback to avoid memory corruption since 'this' will be destroyed
 	CCS->soundh->stopSound(voiceSoundHandle);
diff --color -urN vcmi-1.5.7/client/mainmenu/CPrologEpilogVideo.h vcmi/client/mainmenu/CPrologEpilogVideo.h
--- vcmi-1.5.7/client/mainmenu/CPrologEpilogVideo.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/mainmenu/CPrologEpilogVideo.h	2024-12-19 15:00:22.260121572 +0100
@@ -13,6 +13,7 @@
 #include "../../lib/campaign/CampaignScenarioPrologEpilog.h"
 
 class CMultiLineLabel;
+class VideoWidget;
 class CFilledTexture;
 
 class CPrologEpilogVideo : public CWindowObject
@@ -26,6 +27,7 @@
 	std::function<void()> exitCb;
 
 	std::shared_ptr<CMultiLineLabel> text;
+	std::shared_ptr<VideoWidget> videoPlayer;
 	std::shared_ptr<CFilledTexture> backgroundAroundMenu;
 
 	bool voiceStopped = false;
diff --color -urN vcmi-1.5.7/client/mainmenu/CreditsScreen.cpp vcmi/client/mainmenu/CreditsScreen.cpp
--- vcmi-1.5.7/client/mainmenu/CreditsScreen.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/mainmenu/CreditsScreen.cpp	2024-12-19 15:00:22.260121572 +0100
@@ -22,12 +22,14 @@
 #include "../../AUTHORS.h"
 
 CreditsScreen::CreditsScreen(Rect rect)
-	: CIntObject(LCLICK), positionCounter(0)
+	: CIntObject(LCLICK), timePassed(0)
 {
 	pos.w = rect.w;
 	pos.h = rect.h;
 	setRedrawParent(true);
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
+
+	addUsedEvents(TIME);
 
 	std::string contributorsText = "";
 	std::string contributorsTask = "";
@@ -48,15 +50,15 @@
 	credits->scrollTextTo(-600); // move all text below the screen
 }
 
-void CreditsScreen::show(Canvas & to)
+void CreditsScreen::tick(uint32_t msPassed)
 {
-	CIntObject::show(to);
-	positionCounter++;
-	if(positionCounter % 2 == 0)
-		credits->scrollTextBy(1);
+	static const int timeToScrollByOnePx = 20;
+	timePassed += msPassed;
+	int scrollPosition = timePassed / timeToScrollByOnePx - 600;
+	credits->scrollTextTo(scrollPosition);
 
 	//end of credits, close this screen
-	if(credits->textSize.y + 600 < positionCounter / 2)
+	if(credits->textSize.y < scrollPosition)
 		clickPressed(GH.getCursorPosition());
 }
 
diff --color -urN vcmi-1.5.7/client/mainmenu/CreditsScreen.h vcmi/client/mainmenu/CreditsScreen.h
--- vcmi-1.5.7/client/mainmenu/CreditsScreen.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/mainmenu/CreditsScreen.h	2024-12-19 15:00:22.261121613 +0100
@@ -15,11 +15,11 @@
 
 class CreditsScreen : public CIntObject
 {
-	int positionCounter;
+	int timePassed;
 	std::shared_ptr<CMultiLineLabel> credits;
 
 public:
 	CreditsScreen(Rect rect);
-	void show(Canvas & to) override;
+	void tick(uint32_t msPassed) override;
 	void clickPressed(const Point & cursorPosition) override;
 };
diff --color -urN vcmi-1.5.7/client/mainmenu/CStatisticScreen.cpp vcmi/client/mainmenu/CStatisticScreen.cpp
--- vcmi-1.5.7/client/mainmenu/CStatisticScreen.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/client/mainmenu/CStatisticScreen.cpp	2024-12-19 15:00:22.260121572 +0100
@@ -0,0 +1,563 @@
+/*
+ * CStatisticScreen.cpp, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+
+#include "StdInc.h"
+
+#include "CStatisticScreen.h"
+#include "../CGameInfo.h"
+
+#include "../gui/CGuiHandler.h"
+#include "../gui/WindowHandler.h"
+#include "../eventsSDL/InputHandler.h"
+#include "../gui/Shortcut.h"
+
+#include "../render/Graphics.h"
+#include "../render/IImage.h"
+#include "../render/IRenderHandler.h"
+
+#include "../widgets/ComboBox.h"
+#include "../widgets/Images.h"
+#include "../widgets/GraphicalPrimitiveCanvas.h"
+#include "../widgets/TextControls.h"
+#include "../widgets/Buttons.h"
+#include "../windows/InfoWindows.h"
+#include "../widgets/Slider.h"
+
+#include "../../lib/gameState/GameStatistics.h"
+#include "../../lib/gameState/CGameState.h"
+#include "../../lib/texts/CGeneralTextHandler.h"
+#include "../../lib/texts/TextOperations.h"
+
+#include <vstd/DateUtils.h>
+
+std::string CStatisticScreen::getDay(int d)
+{
+	return std::to_string(CGameState::getDate(d, Date::MONTH)) + "/" + std::to_string(CGameState::getDate(d, Date::WEEK)) + "/" + std::to_string(CGameState::getDate(d, Date::DAY_OF_WEEK));
+}
+
+CStatisticScreen::CStatisticScreen(const StatisticDataSet & stat)
+	: CWindowObject(BORDERED), statistic(stat)
+{
+	OBJECT_CONSTRUCTION;
+	pos = center(Rect(0, 0, 800, 600));
+	filledBackground = std::make_shared<FilledTexturePlayerColored>(Rect(0, 0, pos.w, pos.h));
+	filledBackground->setPlayerColor(PlayerColor(1));
+
+	contentArea = Rect(10, 40, 780, 510);
+	layout.emplace_back(std::make_shared<CLabel>(400, 20, FONT_BIG, ETextAlignment::CENTER, Colors::YELLOW, CGI->generaltexth->translate("vcmi.statisticWindow.statistics")));
+	layout.emplace_back(std::make_shared<TransparentFilledRectangle>(contentArea, ColorRGBA(0, 0, 0, 128), ColorRGBA(64, 80, 128, 255), 1));
+	layout.emplace_back(std::make_shared<CButton>(Point(725, 558), AnimationPath::builtin("MUBCHCK"), CButton::tooltip(), [this](){ close(); }, EShortcut::GLOBAL_ACCEPT));
+
+	buttonSelect = std::make_shared<CToggleButton>(Point(10, 564), AnimationPath::builtin("GSPBUT2"), CButton::tooltip(), [this](bool on){ onSelectButton(); });
+	buttonSelect->setTextOverlay(CGI->generaltexth->translate("vcmi.statisticWindow.selectView"), EFonts::FONT_SMALL, Colors::YELLOW);
+
+	buttonCsvSave = std::make_shared<CToggleButton>(Point(150, 564), AnimationPath::builtin("GSPBUT2"), CButton::tooltip(), [this](bool on){ GH.input().copyToClipBoard(statistic.toCsv("\t"));	});
+	buttonCsvSave->setTextOverlay(CGI->generaltexth->translate("vcmi.statisticWindow.tsvCopy"), EFonts::FONT_SMALL, Colors::YELLOW);
+
+	mainContent = getContent(OVERVIEW, EGameResID::NONE);
+}
+
+void CStatisticScreen::onSelectButton()
+{
+	std::vector<std::string> texts;
+	for(auto & val : contentInfo)
+		texts.emplace_back(CGI->generaltexth->translate(std::get<0>(val.second)));
+	GH.windows().createAndPushWindow<StatisticSelector>(texts, [this](int selectedIndex)
+	{
+		OBJECT_CONSTRUCTION;
+		if(!std::get<1>(contentInfo[static_cast<Content>(selectedIndex)]))
+			mainContent = getContent(static_cast<Content>(selectedIndex), EGameResID::NONE);
+		else
+		{
+			auto content = static_cast<Content>(selectedIndex);
+			auto possibleRes = std::vector<EGameResID>{EGameResID::GOLD, EGameResID::WOOD, EGameResID::MERCURY, EGameResID::ORE, EGameResID::SULFUR, EGameResID::CRYSTAL, EGameResID::GEMS};
+			std::vector<std::string> resourceText;
+			for(const auto & res : possibleRes)
+				resourceText.emplace_back(CGI->generaltexth->translate(TextIdentifier("core.restypes", res.getNum()).get()));
+			
+			GH.windows().createAndPushWindow<StatisticSelector>(resourceText, [this, content, possibleRes](int index)
+			{
+				OBJECT_CONSTRUCTION;
+				mainContent = getContent(content, possibleRes[index]);
+			});
+		}
+	});
+}
+
+TData CStatisticScreen::extractData(const StatisticDataSet & stat, const ExtractFunctor & selector) const
+{
+	auto tmpData = stat.data;
+	std::sort(tmpData.begin(), tmpData.end(), [](const StatisticDataSetEntry & v1, const StatisticDataSetEntry & v2){ return v1.player == v2.player ? v1.day < v2.day : v1.player < v2.player; });
+
+	PlayerColor tmpColor = PlayerColor::NEUTRAL;
+	std::vector<float> tmpColorSet;
+	TData plotData;
+	EPlayerStatus statusLastRound = EPlayerStatus::INGAME;
+	for(const auto & val : tmpData)
+	{
+		if(tmpColor != val.player)
+		{
+			if(tmpColorSet.size())
+			{
+				plotData.push_back({graphics->playerColors[tmpColor.getNum()], std::vector<float>(tmpColorSet)});
+				tmpColorSet.clear();
+			}
+
+			tmpColor = val.player;
+		}
+		if(val.status == EPlayerStatus::INGAME || (statusLastRound == EPlayerStatus::INGAME && val.status == EPlayerStatus::LOSER))
+			tmpColorSet.emplace_back(selector(val));
+		statusLastRound = val.status; //to keep at least one dataset after loose
+	}
+	if(tmpColorSet.size())
+		plotData.push_back({graphics->playerColors[tmpColor.getNum()], std::vector<float>(tmpColorSet)});
+
+	return plotData;
+}
+
+TIcons CStatisticScreen::extractIcons() const
+{
+	TIcons icons;
+
+	auto tmpData = statistic.data;
+	std::sort(tmpData.begin(), tmpData.end(), [](const StatisticDataSetEntry & v1, const StatisticDataSetEntry & v2){ return v1.player == v2.player ? v1.day < v2.day : v1.player < v2.player; });
+
+	auto imageTown = GH.renderHandler().loadImage(AnimationPath::builtin("cradvntr"), 3, 0, EImageBlitMode::COLORKEY);
+	auto imageBattle = GH.renderHandler().loadImage(AnimationPath::builtin("cradvntr"), 5, 0, EImageBlitMode::COLORKEY);
+	auto imageDefeated = GH.renderHandler().loadImage(AnimationPath::builtin("crcombat"), 0, 0, EImageBlitMode::COLORKEY);
+	auto imageGrail = GH.renderHandler().loadImage(AnimationPath::builtin("vwsymbol"), 2, 0, EImageBlitMode::COLORKEY);
+
+	std::map<PlayerColor, bool> foundDefeated;
+	std::map<PlayerColor, bool> foundGrail;
+
+	for(const auto & val : tmpData)
+	{
+		if(val.eventCapturedTown)
+			icons.push_back({ graphics->playerColors[val.player], val.day, imageTown, CGI->generaltexth->translate("vcmi.statisticWindow.icon.townCaptured") });
+		if(val.eventDefeatedStrongestHero)
+			icons.push_back({ graphics->playerColors[val.player], val.day, imageBattle, CGI->generaltexth->translate("vcmi.statisticWindow.icon.strongestHeroDefeated") });
+		if(val.status == EPlayerStatus::LOSER && !foundDefeated[val.player])
+		{
+			foundDefeated[val.player] = true;
+			icons.push_back({ graphics->playerColors[val.player], val.day, imageDefeated, CGI->generaltexth->translate("vcmi.statisticWindow.icon.defeated") });
+		}
+		if(val.hasGrail && !foundGrail[val.player])
+		{
+			foundGrail[val.player] = true;
+			icons.push_back({ graphics->playerColors[val.player], val.day, imageGrail, CGI->generaltexth->translate("vcmi.statisticWindow.icon.grailFound") });
+		}
+	}
+
+	return icons;
+}
+
+std::shared_ptr<CIntObject> CStatisticScreen::getContent(Content c, EGameResID res)
+{
+	TData plotData;
+	TIcons icons = extractIcons();
+
+	switch (c)
+	{
+	case OVERVIEW:
+		return std::make_shared<OverviewPanel>(contentArea.resize(-15), CGI->generaltexth->translate(std::get<0>(contentInfo[c])), statistic);
+	
+	case CHART_RESOURCES:
+		plotData = extractData(statistic, [res](const StatisticDataSetEntry & val) -> float { return val.resources[res]; });
+		return std::make_shared<LineChart>(contentArea.resize(-5), CGI->generaltexth->translate(std::get<0>(contentInfo[c])) + " - " + CGI->generaltexth->translate(TextIdentifier("core.restypes", res.getNum()).get()), plotData, icons, 0);
+	
+	case CHART_INCOME:
+		plotData = extractData(statistic, [](const StatisticDataSetEntry & val) -> float { return val.income; });
+		return std::make_shared<LineChart>(contentArea.resize(-5), CGI->generaltexth->translate(std::get<0>(contentInfo[c])), plotData, icons, 0);
+	
+	case CHART_NUMBER_OF_HEROES:
+		plotData = extractData(statistic, [](const StatisticDataSetEntry & val) -> float { return val.numberHeroes; });
+		return std::make_shared<LineChart>(contentArea.resize(-5), CGI->generaltexth->translate(std::get<0>(contentInfo[c])), plotData, icons, 0);
+	
+	case CHART_NUMBER_OF_TOWNS:
+		plotData = extractData(statistic, [](const StatisticDataSetEntry & val) -> float { return val.numberTowns; });
+		return std::make_shared<LineChart>(contentArea.resize(-5), CGI->generaltexth->translate(std::get<0>(contentInfo[c])), plotData, icons, 0);
+	
+	case CHART_NUMBER_OF_ARTIFACTS:
+		plotData = extractData(statistic, [](const StatisticDataSetEntry & val) -> float { return val.numberArtifacts; });
+		return std::make_shared<LineChart>(contentArea.resize(-5), CGI->generaltexth->translate(std::get<0>(contentInfo[c])), plotData, icons, 0);
+	
+	case CHART_NUMBER_OF_DWELLINGS:
+		plotData = extractData(statistic, [](const StatisticDataSetEntry & val) -> float { return val.numberDwellings; });
+		return std::make_shared<LineChart>(contentArea.resize(-5), CGI->generaltexth->translate(std::get<0>(contentInfo[c])), plotData, icons, 0);
+	
+	case CHART_NUMBER_OF_MINES:
+		plotData = extractData(statistic, [res](StatisticDataSetEntry val) -> float { return val.numMines[res]; });
+		return std::make_shared<LineChart>(contentArea.resize(-5), CGI->generaltexth->translate(std::get<0>(contentInfo[c])) + " - " + CGI->generaltexth->translate(TextIdentifier("core.restypes", res.getNum()).get()), plotData, icons, 0);
+	
+	case CHART_ARMY_STRENGTH:
+		plotData = extractData(statistic, [](const StatisticDataSetEntry & val) -> float { return val.armyStrength; });
+		return std::make_shared<LineChart>(contentArea.resize(-5), CGI->generaltexth->translate(std::get<0>(contentInfo[c])), plotData, icons, 0);
+	
+	case CHART_EXPERIENCE:
+		plotData = extractData(statistic, [](const StatisticDataSetEntry & val) -> float { return val.totalExperience; });
+		return std::make_shared<LineChart>(contentArea.resize(-5), CGI->generaltexth->translate(std::get<0>(contentInfo[c])), plotData, icons, 0);
+	
+	case CHART_RESOURCES_SPENT_ARMY:
+		plotData = extractData(statistic, [res](const StatisticDataSetEntry & val) -> float { return val.spentResourcesForArmy[res]; });
+		return std::make_shared<LineChart>(contentArea.resize(-5), CGI->generaltexth->translate(std::get<0>(contentInfo[c])) + " - " + CGI->generaltexth->translate(TextIdentifier("core.restypes", res.getNum()).get()), plotData, icons, 0);
+	
+	case CHART_RESOURCES_SPENT_BUILDINGS:
+		plotData = extractData(statistic, [res](const StatisticDataSetEntry & val) -> float { return val.spentResourcesForBuildings[res]; });
+		return std::make_shared<LineChart>(contentArea.resize(-5), CGI->generaltexth->translate(std::get<0>(contentInfo[c])) + " - " + CGI->generaltexth->translate(TextIdentifier("core.restypes", res.getNum()).get()), plotData, icons, 0);
+	
+	case CHART_MAP_EXPLORED:
+		plotData = extractData(statistic, [](const StatisticDataSetEntry & val) -> float { return val.mapExploredRatio; });
+		return std::make_shared<LineChart>(contentArea.resize(-5), CGI->generaltexth->translate(std::get<0>(contentInfo[c])), plotData, icons, 1);
+	}
+
+	return nullptr;
+}
+
+StatisticSelector::StatisticSelector(const std::vector<std::string> & texts, const std::function<void(int selectedIndex)> & cb)
+	: CWindowObject(BORDERED | NEEDS_ANIMATED_BACKGROUND), texts(texts), cb(cb)
+{
+	OBJECT_CONSTRUCTION;
+	pos = center(Rect(0, 0, 128 + 16, std::min(static_cast<int>(texts.size()), LINES) * 40));
+	filledBackground = std::make_shared<FilledTexturePlayerColored>(Rect(0, 0, pos.w, pos.h));
+	filledBackground->setPlayerColor(PlayerColor(1));
+
+	slider = std::make_shared<CSlider>(Point(pos.w - 16, 0), pos.h, [this](int to){ update(to); redraw(); }, LINES, texts.size(), 0, Orientation::VERTICAL, CSlider::BLUE);
+	slider->setPanningStep(40);
+	slider->setScrollBounds(Rect(-pos.w + slider->pos.w, 0, pos.w, pos.h));
+
+	update(0);
+}
+
+void StatisticSelector::update(int to)
+{
+	OBJECT_CONSTRUCTION;
+	buttons.clear();
+	for(int i = to; i < LINES + to; i++)
+	{
+		if(i>=texts.size())
+			continue;
+
+		auto button = std::make_shared<CToggleButton>(Point(0, 10 + (i - to) * 40), AnimationPath::builtin("GSPBUT2"), CButton::tooltip(), [this, i](bool on){ close(); cb(i); });
+		button->setTextOverlay(texts[i], EFonts::FONT_SMALL, Colors::WHITE);
+		buttons.emplace_back(button);
+	}
+}
+
+OverviewPanel::OverviewPanel(Rect position, std::string title, const StatisticDataSet & stat)
+	: CIntObject(), data(stat)
+{
+	OBJECT_CONSTRUCTION;
+
+	pos = position + pos.topLeft();
+
+	layout.emplace_back(std::make_shared<CLabel>(pos.w / 2, 10, FONT_MEDIUM, ETextAlignment::CENTER, Colors::WHITE, title));
+
+	canvas = std::make_shared<GraphicalPrimitiveCanvas>(Rect(0, Y_OFFS, pos.w - 16, pos.h - Y_OFFS));
+
+	dataExtract = {
+		{
+			CGI->generaltexth->translate("vcmi.statisticWindow.param.playerName"), [this](PlayerColor color){
+				return playerDataFilter(color).front().playerName;
+			}
+		},
+		{
+			CGI->generaltexth->translate("vcmi.statisticWindow.param.daysSurvived"), [this](PlayerColor color){
+				auto playerData = playerDataFilter(color);
+				for(int i = 0; i < playerData.size(); i++)
+					if(playerData[i].status == EPlayerStatus::LOSER)
+						return CStatisticScreen::getDay(i + 1);
+				return CStatisticScreen::getDay(playerData.size());
+			}
+		},
+		{
+			CGI->generaltexth->translate("vcmi.statisticWindow.param.maxHeroLevel"), [this](PlayerColor color){
+				int maxLevel = 0;
+				for(const auto & val : playerDataFilter(color))
+					if(maxLevel < val.maxHeroLevel)
+						maxLevel = val.maxHeroLevel;
+				return std::to_string(maxLevel);
+			}
+		},
+		{
+			CGI->generaltexth->translate("vcmi.statisticWindow.param.battleWinRatioHero"), [this](PlayerColor color){
+				auto val = playerDataFilter(color).back();
+				if(!val.numBattlesPlayer)
+					return std::string("");
+				float tmp = (static_cast<float>(val.numWinBattlesPlayer) / static_cast<float>(val.numBattlesPlayer)) * 100;
+				return std::to_string(static_cast<int>(tmp)) + " %";
+			}
+		},
+		{
+			CGI->generaltexth->translate("vcmi.statisticWindow.param.battleWinRatioNeutral"), [this](PlayerColor color){
+				auto val = playerDataFilter(color).back();
+				if(!val.numWinBattlesNeutral)
+					return std::string("");
+				float tmp = (static_cast<float>(val.numWinBattlesNeutral) / static_cast<float>(val.numBattlesNeutral)) * 100;
+				return std::to_string(static_cast<int>(tmp)) + " %";
+			}
+		},
+		{
+			CGI->generaltexth->translate("vcmi.statisticWindow.param.battlesHero"), [this](PlayerColor color){
+				auto val = playerDataFilter(color).back();
+				return std::to_string(val.numBattlesPlayer);
+			}
+		},
+		{
+			CGI->generaltexth->translate("vcmi.statisticWindow.param.battlesNeutral"), [this](PlayerColor color){
+				auto val = playerDataFilter(color).back();
+				return std::to_string(val.numBattlesNeutral);
+			}
+		},
+		{
+			CGI->generaltexth->translate("vcmi.statisticWindow.param.obeliskVisited"), [this](PlayerColor color){
+				auto val = playerDataFilter(color).back();
+				return std::to_string(static_cast<int>(val.obeliskVisitedRatio * 100)) + " %";
+			}
+		},
+		{
+			CGI->generaltexth->translate("vcmi.statisticWindow.param.maxArmyStrength"), [this](PlayerColor color){
+				int maxArmyStrength = 0;
+				for(const auto & val : playerDataFilter(color))
+					if(maxArmyStrength < val.armyStrength)
+						maxArmyStrength = val.armyStrength;
+				return TextOperations::formatMetric(maxArmyStrength, 6);
+			}
+		},
+		{
+			CGI->generaltexth->translate("vcmi.statisticWindow.param.tradeVolume") + " - " + CGI->generaltexth->translate(TextIdentifier("core.restypes", EGameResID::GOLD).get()), [this](PlayerColor color){
+				auto val = playerDataFilter(color).back();
+				return std::to_string(val.tradeVolume[EGameResID::GOLD]);
+			}
+		},
+		{
+			CGI->generaltexth->translate("vcmi.statisticWindow.param.tradeVolume") + " - " + CGI->generaltexth->translate(TextIdentifier("core.restypes", EGameResID::WOOD).get()), [this](PlayerColor color){
+				auto val = playerDataFilter(color).back();
+				return std::to_string(val.tradeVolume[EGameResID::WOOD]);
+			}
+		},
+		{
+			CGI->generaltexth->translate("vcmi.statisticWindow.param.tradeVolume") + " - " + CGI->generaltexth->translate(TextIdentifier("core.restypes", EGameResID::MERCURY).get()), [this](PlayerColor color){
+				auto val = playerDataFilter(color).back();
+				return std::to_string(val.tradeVolume[EGameResID::MERCURY]);
+			}
+		},
+		{
+			CGI->generaltexth->translate("vcmi.statisticWindow.param.tradeVolume") + " - " + CGI->generaltexth->translate(TextIdentifier("core.restypes", EGameResID::ORE).get()), [this](PlayerColor color){
+				auto val = playerDataFilter(color).back();
+				return std::to_string(val.tradeVolume[EGameResID::ORE]);
+			}
+		},
+		{
+			CGI->generaltexth->translate("vcmi.statisticWindow.param.tradeVolume") + " - " + CGI->generaltexth->translate(TextIdentifier("core.restypes", EGameResID::SULFUR).get()), [this](PlayerColor color){
+				auto val = playerDataFilter(color).back();
+				return std::to_string(val.tradeVolume[EGameResID::SULFUR]);
+			}
+		},
+		{
+			CGI->generaltexth->translate("vcmi.statisticWindow.param.tradeVolume") + " - " + CGI->generaltexth->translate(TextIdentifier("core.restypes", EGameResID::CRYSTAL).get()), [this](PlayerColor color){
+				auto val = playerDataFilter(color).back();
+				return std::to_string(val.tradeVolume[EGameResID::CRYSTAL]);
+			}
+		},
+		{
+			CGI->generaltexth->translate("vcmi.statisticWindow.param.tradeVolume") + " - " + CGI->generaltexth->translate(TextIdentifier("core.restypes", EGameResID::GEMS).get()), [this](PlayerColor color){
+				auto val = playerDataFilter(color).back();
+				return std::to_string(val.tradeVolume[EGameResID::GEMS]);
+			}
+		},
+	};
+
+	int usedLines = dataExtract.size();
+
+	slider = std::make_shared<CSlider>(Point(pos.w - 16, Y_OFFS), pos.h - Y_OFFS, [this](int to){ update(to); setRedrawParent(true); redraw(); }, LINES - 1, usedLines, 0, Orientation::VERTICAL, CSlider::BLUE);
+	slider->setPanningStep(canvas->pos.h / LINES);
+	slider->setScrollBounds(Rect(-pos.w + slider->pos.w, 0, pos.w, canvas->pos.h));
+
+	fieldSize = Point(canvas->pos.w / (graphics->playerColors.size() + 2), canvas->pos.h / LINES);
+	for(int x = 0; x < graphics->playerColors.size() + 1; x++)
+		for(int y = 0; y < LINES; y++)
+		{
+			int xStart = (x + (x == 0 ? 0 : 1)) * fieldSize.x;
+			int yStart = y * fieldSize.y;
+			if(x == 0 || y == 0)
+				canvas->addBox(Point(xStart, yStart), Point(x == 0 ? 2 * fieldSize.x : fieldSize.x, fieldSize.y), ColorRGBA(0, 0, 0, 100));
+			canvas->addRectangle(Point(xStart, yStart), Point(x == 0 ? 2 * fieldSize.x : fieldSize.x, fieldSize.y), ColorRGBA(127, 127, 127, 255));
+		}
+
+	update(0);
+}
+
+std::vector<StatisticDataSetEntry> OverviewPanel::playerDataFilter(PlayerColor color)
+{
+	std::vector<StatisticDataSetEntry> tmpData;
+	std::copy_if(data.data.begin(), data.data.end(), std::back_inserter(tmpData), [color](const StatisticDataSetEntry & e){ return e.player == color; });
+	return tmpData;
+}
+
+void OverviewPanel::update(int to)
+{
+	OBJECT_CONSTRUCTION;
+
+	content.clear();
+	for(int y = to; y < LINES - 1 + to; y++)
+	{
+		if(y >= dataExtract.size())
+			continue;
+
+		for(int x = 0; x < PlayerColor::PLAYER_LIMIT_I + 1; x++)
+		{
+			if(y == to && x < PlayerColor::PLAYER_LIMIT_I)
+				content.emplace_back(std::make_shared<CAnimImage>(AnimationPath::builtin("ITGFLAGS"), x, 0, 180 + x * fieldSize.x, 35));
+			int xStart = (x + (x == 0 ? 0 : 1)) * fieldSize.x + (x == 0 ? fieldSize.x : (fieldSize.x / 2));
+			int yStart = Y_OFFS + (y + 1 - to) * fieldSize.y + (fieldSize.y / 2);
+			PlayerColor tmpColor(x - 1);
+			if(playerDataFilter(tmpColor).size() || x == 0)
+				content.emplace_back(std::make_shared<CLabel>(xStart, yStart, FONT_TINY, ETextAlignment::CENTER, Colors::WHITE, (x == 0 ? dataExtract[y].first : dataExtract[y].second(tmpColor)), x == 0 ? (fieldSize.x * 2) : fieldSize.x));
+		}
+	}
+}
+
+int computeGridStep(int maxAmount, int linesLimit)
+{
+	for (int lineInterval = 1;;lineInterval *= 10)
+	{
+		for (int factor : { 1, 2, 5 } )
+		{
+			int lineIntervalToTest = lineInterval * factor;
+			if (maxAmount / lineIntervalToTest <= linesLimit)
+				return lineIntervalToTest;
+		}
+	}
+}
+
+LineChart::LineChart(Rect position, std::string title, TData data, TIcons icons, float maxY)
+	: CIntObject(), maxVal(0), maxDay(0)
+{
+	OBJECT_CONSTRUCTION;
+
+	addUsedEvents(LCLICK | MOVE | GESTURE);
+
+	pos = position + pos.topLeft();
+
+	layout.emplace_back(std::make_shared<CLabel>(pos.w / 2, 20, FONT_MEDIUM, ETextAlignment::CENTER, Colors::WHITE, title));
+
+	chartArea = pos.resize(-50);
+	chartArea.moveTo(Point(50, 50));
+
+	canvas = std::make_shared<GraphicalPrimitiveCanvas>(Rect(0, 0, pos.w, pos.h));
+
+	statusBar = CGStatusBar::create(0, 0, ImagePath::builtin("radialMenu/statusBar"));
+	static_cast<std::shared_ptr<CIntObject>>(statusBar)->setEnabled(false);
+
+	// additional calculations
+	bool skipMaxValCalc = maxY > 0;
+	maxVal = maxY;
+	for(const auto & line : data)
+	{
+		for(auto & val : line.second)
+			if(maxVal < val && !skipMaxValCalc)
+				maxVal = val;
+		if(maxDay < line.second.size())
+			maxDay = line.second.size();
+	}
+
+	//calculate nice maxVal
+	int gridLineCount = 10;
+	int gridStep = computeGridStep(maxVal, gridLineCount);
+	niceMaxVal = gridStep * std::ceil(maxVal / gridStep);
+	niceMaxVal = std::max(1, niceMaxVal); // avoid zero size Y axis (if all values are 0)
+
+	// calculate points in chart
+	auto getPoint = [this](int i, std::vector<float> data){
+		float x = (static_cast<float>(chartArea.w) / static_cast<float>(maxDay - 1)) * static_cast<float>(i);
+		float y = static_cast<float>(chartArea.h) - (static_cast<float>(chartArea.h) / niceMaxVal) * data[i];
+		return Point(x, y);
+	};
+
+	// draw grid (vertical lines)
+	int dayGridInterval = maxDay < 700 ? 7 : 28;
+	for(const auto & line : data)
+	{
+		for(int i = 0; i < line.second.size(); i += dayGridInterval)
+		{
+			Point p = getPoint(i, line.second) + chartArea.topLeft();
+			canvas->addLine(Point(p.x, chartArea.topLeft().y), Point(p.x, chartArea.topLeft().y + chartArea.h), ColorRGBA(70, 70, 70));
+		}
+	}
+
+	// draw grid (horizontal lines)
+	if(maxVal > 0)
+	{
+		int gridStepPx = int((static_cast<float>(chartArea.h) / niceMaxVal) * gridStep);
+		for(int i = 0; i < std::ceil(maxVal / gridStep) + 1; i++)
+		{
+			canvas->addLine(chartArea.topLeft() + Point(0, chartArea.h - gridStepPx * i), chartArea.topLeft() + Point(chartArea.w, chartArea.h - gridStepPx * i), ColorRGBA(70, 70, 70));
+			layout.emplace_back(std::make_shared<CLabel>(chartArea.topLeft().x - 5, chartArea.topLeft().y + 10 + chartArea.h - gridStepPx * i, FONT_SMALL, ETextAlignment::CENTERRIGHT, Colors::WHITE, TextOperations::formatMetric(i * gridStep, 5)));
+		}
+	}
+
+	// draw
+	for(const auto & line : data)
+	{
+		Point lastPoint(-1, -1);
+		for(int i = 0; i < line.second.size(); i++)
+		{
+			Point p = getPoint(i, line.second) + chartArea.topLeft();
+
+			if(lastPoint.x != -1)
+				canvas->addLine(lastPoint, p, line.first);
+			
+			// icons
+			for(auto & icon : icons)
+				if(std::get<0>(icon) == line.first && std::get<1>(icon) == i + 1) // color && day
+				{
+					pictures.emplace_back(std::make_shared<CPicture>(std::get<2>(icon), Point(p.x - (std::get<2>(icon)->width() / 2), p.y - (std::get<2>(icon)->height() / 2))));
+					pictures.back()->addRClickCallback([icon](){ CRClickPopup::createAndPush(std::get<3>(icon)); });
+				}
+
+			lastPoint = p;
+		}
+	}
+
+	// Axis
+	canvas->addLine(chartArea.topLeft() + Point(0, -10), chartArea.topLeft() + Point(0, chartArea.h + 10), Colors::WHITE);
+	canvas->addLine(chartArea.topLeft() + Point(-10, chartArea.h), chartArea.topLeft() + Point(chartArea.w + 10, chartArea.h), Colors::WHITE);
+
+	Point p = chartArea.topLeft() + Point(chartArea.w + 10, chartArea.h + 10);
+	layout.emplace_back(std::make_shared<CLabel>(p.x, p.y, FONT_SMALL, ETextAlignment::CENTER, Colors::WHITE, CStatisticScreen::getDay(maxDay)));
+	p = chartArea.bottomLeft() + Point(chartArea.w / 2, + 20);
+	layout.emplace_back(std::make_shared<CLabel>(p.x, p.y, FONT_MEDIUM, ETextAlignment::CENTER, Colors::WHITE, CGI->generaltexth->translate("core.genrltxt.64")));
+}
+
+void LineChart::updateStatusBar(const Point & cursorPosition)
+{
+	statusBar->moveTo(cursorPosition + Point(-statusBar->pos.w / 2, 20));
+	statusBar->fitToRect(pos, 10);
+	Rect r(pos.x + chartArea.x, pos.y + chartArea.y, chartArea.w, chartArea.h);
+	statusBar->setEnabled(r.isInside(cursorPosition));
+	if(r.isInside(cursorPosition))
+	{
+		float x = (static_cast<float>(maxDay - 1) / static_cast<float>(chartArea.w)) * (static_cast<float>(cursorPosition.x) - static_cast<float>(r.x)) + 1.0f;
+		float y = niceMaxVal - (niceMaxVal / static_cast<float>(chartArea.h)) * (static_cast<float>(cursorPosition.y) - static_cast<float>(r.y));
+		statusBar->write(CGI->generaltexth->translate("core.genrltxt.64") + ": " + CStatisticScreen::getDay(x) + "   " + CGI->generaltexth->translate("vcmi.statisticWindow.value") + ": " + (static_cast<int>(y) > 0 ? std::to_string(static_cast<int>(y)) : std::to_string(y)));
+	}
+	setRedrawParent(true);
+	redraw();
+}
+
+void LineChart::mouseMoved(const Point & cursorPosition, const Point & lastUpdateDistance)
+{
+	updateStatusBar(cursorPosition);
+}
+
+void LineChart::gesturePanning(const Point & initialPosition, const Point & currentPosition, const Point & lastUpdateDistance)
+{
+	updateStatusBar(currentPosition);
+}
diff --color -urN vcmi-1.5.7/client/mainmenu/CStatisticScreen.h vcmi/client/mainmenu/CStatisticScreen.h
--- vcmi-1.5.7/client/mainmenu/CStatisticScreen.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/client/mainmenu/CStatisticScreen.h	2024-12-19 15:00:22.260121572 +0100
@@ -0,0 +1,133 @@
+/*
+ * CStatisticScreen.h, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#pragma once
+#include "../windows/CWindowObject.h"
+#include "../../lib/gameState/GameStatistics.h"
+
+class FilledTexturePlayerColored;
+class CToggleButton;
+class GraphicalPrimitiveCanvas;
+class LineChart;
+class CGStatusBar;
+class ComboBox;
+class CSlider;
+class IImage;
+class CPicture;
+
+using TData = std::vector<std::pair<ColorRGBA, std::vector<float>>>;
+using TIcons = std::vector<std::tuple<ColorRGBA, int, std::shared_ptr<IImage>, std::string>>; // Color, Day, Image, Helptext
+
+class CStatisticScreen : public CWindowObject
+{
+	enum Content {
+		OVERVIEW,
+		CHART_RESOURCES,
+		CHART_INCOME,
+		CHART_NUMBER_OF_HEROES,
+		CHART_NUMBER_OF_TOWNS,
+		CHART_NUMBER_OF_ARTIFACTS,
+		CHART_NUMBER_OF_DWELLINGS,
+		CHART_NUMBER_OF_MINES,
+		CHART_ARMY_STRENGTH,
+		CHART_EXPERIENCE,
+		CHART_RESOURCES_SPENT_ARMY,
+		CHART_RESOURCES_SPENT_BUILDINGS,
+		CHART_MAP_EXPLORED,
+	};
+	std::map<Content, std::tuple<std::string, bool>> contentInfo = { // tuple: textid, resource selection needed
+		{ OVERVIEW,                        { "vcmi.statisticWindow.title.overview",                false } },
+		{ CHART_RESOURCES,                 { "vcmi.statisticWindow.title.resources",               true  } },
+		{ CHART_INCOME,                    { "vcmi.statisticWindow.title.income",                  false } },
+		{ CHART_NUMBER_OF_HEROES,          { "vcmi.statisticWindow.title.numberOfHeroes",          false } },
+		{ CHART_NUMBER_OF_TOWNS,           { "vcmi.statisticWindow.title.numberOfTowns",           false } },
+		{ CHART_NUMBER_OF_ARTIFACTS,       { "vcmi.statisticWindow.title.numberOfArtifacts",       false } },
+		{ CHART_NUMBER_OF_DWELLINGS,       { "vcmi.statisticWindow.title.numberOfDwellings",       false } },
+		{ CHART_NUMBER_OF_MINES,           { "vcmi.statisticWindow.title.numberOfMines",           true  } },
+		{ CHART_ARMY_STRENGTH,             { "vcmi.statisticWindow.title.armyStrength",            false } },
+		{ CHART_EXPERIENCE,                { "vcmi.statisticWindow.title.experience",              false } },
+		{ CHART_RESOURCES_SPENT_ARMY,      { "vcmi.statisticWindow.title.resourcesSpentArmy",      true  } },
+		{ CHART_RESOURCES_SPENT_BUILDINGS, { "vcmi.statisticWindow.title.resourcesSpentBuildings", true  } },
+		{ CHART_MAP_EXPLORED,              { "vcmi.statisticWindow.title.mapExplored",             false } },
+	};
+
+	std::shared_ptr<FilledTexturePlayerColored> filledBackground;
+	std::vector<std::shared_ptr<CIntObject>> layout;
+	std::shared_ptr<CToggleButton> buttonCsvSave;
+	std::shared_ptr<CToggleButton> buttonSelect;
+	StatisticDataSet statistic;
+	std::shared_ptr<CIntObject> mainContent;
+	Rect contentArea;
+
+	using ExtractFunctor = std::function<float(StatisticDataSetEntry val)>;
+	TData extractData(const StatisticDataSet & stat, const ExtractFunctor & selector) const;
+	TIcons extractIcons() const;
+	std::shared_ptr<CIntObject> getContent(Content c, EGameResID res);
+	void onSelectButton();
+public:
+	CStatisticScreen(const StatisticDataSet & stat);
+	static std::string getDay(int day);
+};
+
+class StatisticSelector : public CWindowObject
+{
+	std::shared_ptr<FilledTexturePlayerColored> filledBackground;
+	std::vector<std::shared_ptr<CToggleButton>> buttons;
+	std::shared_ptr<CSlider> slider;
+
+	const int LINES = 10;
+
+	std::vector<std::string> texts;
+	std::function<void(int selectedIndex)> cb;
+
+	void update(int to);
+public:
+	StatisticSelector(const std::vector<std::string> & texts, const std::function<void(int selectedIndex)> & cb);
+};
+
+class OverviewPanel : public CIntObject
+{
+	std::shared_ptr<GraphicalPrimitiveCanvas> canvas;
+	std::vector<std::shared_ptr<CIntObject>> layout;
+	std::vector<std::shared_ptr<CIntObject>> content;
+	std::shared_ptr<CSlider> slider;
+
+	Point fieldSize;
+	StatisticDataSet data;
+
+	std::vector<std::pair<std::string, std::function<std::string(PlayerColor color)>>> dataExtract;
+
+	const int LINES = 15;
+	const int Y_OFFS = 30;
+
+	std::vector<StatisticDataSetEntry> playerDataFilter(PlayerColor color);
+	void update(int to);
+public:
+	OverviewPanel(Rect position, std::string title, const StatisticDataSet & stat);
+};
+
+class LineChart : public CIntObject
+{
+	std::shared_ptr<GraphicalPrimitiveCanvas> canvas;
+	std::vector<std::shared_ptr<CIntObject>> layout;
+	std::shared_ptr<CGStatusBar> statusBar;
+	std::vector<std::shared_ptr<CPicture>> pictures;
+
+	Rect chartArea;
+	float maxVal;
+	int niceMaxVal;
+	int maxDay;
+
+	void updateStatusBar(const Point & cursorPosition);
+public:
+	LineChart(Rect position, std::string title, TData data, TIcons icons, float maxY);
+
+	void mouseMoved(const Point & cursorPosition, const Point & lastUpdateDistance) override;
+	void gesturePanning(const Point & initialPosition, const Point & currentPosition, const Point & lastUpdateDistance) override;
+};
diff --color -urN vcmi-1.5.7/client/mapView/IMapRendererContext.h vcmi/client/mapView/IMapRendererContext.h
--- vcmi-1.5.7/client/mapView/IMapRendererContext.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/mapView/IMapRendererContext.h	2024-12-19 15:00:22.261121613 +0100
@@ -16,6 +16,7 @@
 class CGObjectInstance;
 class ObjectInstanceID;
 struct TerrainTile;
+class ColorRGBA;
 struct CGPath;
 
 VCMI_LIB_NAMESPACE_END
@@ -67,6 +68,12 @@
 	/// returns index of image for overlay on specific tile, or numeric_limits::max if none
 	virtual size_t overlayImageIndex(const int3 & coordinates) const = 0;
 
+	/// returns text that should be used as overlay for current tile
+	virtual std::string overlayText(const int3 & coordinates) const = 0;
+
+	/// returns text that should be used as overlay for current tile
+	virtual ColorRGBA overlayTextColor(const int3 & coordinates) const = 0;
+
 	/// returns animation frame for terrain
 	virtual size_t terrainImageIndex(size_t groupSize) const = 0;
 
@@ -80,7 +87,10 @@
 	virtual bool showBorder() const = 0;
 
 	/// if true, world view overlay will be shown
-	virtual bool showOverlay() const = 0;
+	virtual bool showImageOverlay() const = 0;
+
+	// if true, new text overlay will be shown
+	virtual bool showTextOverlay() const = 0;
 
 	/// if true, map grid should be visible on map
 	virtual bool showGrid() const = 0;
diff --color -urN vcmi-1.5.7/client/mapView/mapHandler.cpp vcmi/client/mapView/mapHandler.cpp
--- vcmi-1.5.7/client/mapView/mapHandler.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/mapView/mapHandler.cpp	2024-12-19 15:00:22.263121696 +0100
@@ -17,7 +17,7 @@
 #include "../CPlayerInterface.h"
 #include "../gui/CGuiHandler.h"
 
-#include "../../lib/CGeneralTextHandler.h"
+#include "../../lib/texts/CGeneralTextHandler.h"
 #include "../../lib/TerrainHandler.h"
 #include "../../lib/mapObjectConstructors/CObjectClassesHandler.h"
 #include "../../lib/mapObjects/CGHeroInstance.h"
@@ -55,11 +55,11 @@
 	if(t.hasFavorableWinds())
 		return CGI->objtypeh->getObjectName(Obj::FAVORABLE_WINDS, 0);
 
-	std::string result = t.terType->getNameTranslated();
+	std::string result = t.getTerrain()->getNameTranslated();
 
 	for(const auto & object : map->objects)
 	{
-		if(object && object->coveringAt(pos.x, pos.y) && object->pos.z == pos.z && object->isTile2Terrain())
+		if(object && object->coveringAt(pos) && object->isTile2Terrain())
 		{
 			result = object->getObjectName();
 			break;
@@ -103,15 +103,15 @@
 
 	for(const auto & aOffset : a->getBlockedOffsets())
 	{
-		int3 testTarget = a->pos + aOffset + int3(0, 1, 0);
-		if(b->blockingAt(testTarget.x, testTarget.y))
+		int3 testTarget = a->anchorPos() + aOffset + int3(0, 1, 0);
+		if(b->blockingAt(testTarget))
 			bBlocksA += 1;
 	}
 
 	for(const auto & bOffset : b->getBlockedOffsets())
 	{
-		int3 testTarget = b->pos + bOffset + int3(0, 1, 0);
-		if(a->blockingAt(testTarget.x, testTarget.y))
+		int3 testTarget = b->anchorPos() + bOffset + int3(0, 1, 0);
+		if(a->blockingAt(testTarget))
 			aBlocksB += 1;
 	}
 
@@ -126,8 +126,8 @@
 		return aBlocksB < bBlocksA;
 
 	// object that don't have clear priority via tile blocking will appear based on their row
-	if(a->pos.y != b->pos.y)
-		return a->pos.y < b->pos.y;
+	if(a->anchorPos().y != b->anchorPos().y)
+		return a->anchorPos().y < b->anchorPos().y;
 
 	// heroes should appear on top of objects on the same tile
 	if(b->ID==Obj::HERO && a->ID!=Obj::HERO)
diff --color -urN vcmi-1.5.7/client/mapView/MapOverlayLogVisualizer.cpp vcmi/client/mapView/MapOverlayLogVisualizer.cpp
--- vcmi-1.5.7/client/mapView/MapOverlayLogVisualizer.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/client/mapView/MapOverlayLogVisualizer.cpp	2024-12-19 15:00:22.261121613 +0100
@@ -0,0 +1,98 @@
+/*
+ * MapOverlayLogVisualizer.cpp, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+
+#include "StdInc.h"
+#include "MapOverlayLogVisualizer.h"
+#include "MapViewModel.h"
+
+#include "../../lib/logging/VisualLogger.h"
+#include "../render/Canvas.h"
+#include "../render/Colors.h"
+#include "../render/EFont.h"
+#include "../render/IFont.h"
+#include "../render/IRenderHandler.h"
+#include "../render/Graphics.h"
+#include "../gui/TextAlignment.h"
+#include "../gui/CGuiHandler.h"
+
+
+MapOverlayLogVisualizer::MapOverlayLogVisualizer(Canvas & target, std::shared_ptr<MapViewModel> model)
+	: target(target), model(model)
+{
+}
+
+void MapOverlayLogVisualizer::drawLine(int3 start, int3 end)
+{
+	const Point offset = Point(30, 30);
+
+	auto level = model->getLevel();
+
+	if(start.z != level || end.z != level)
+		return;
+
+	auto pStart = model->getTargetTileArea(start).topLeft();
+	auto pEnd = model->getTargetTileArea(end).topLeft();
+	auto viewPort = target.getRenderArea();
+
+	pStart.x += 3;
+	pEnd.x -= 3;
+
+	pStart += offset;
+	pEnd += offset;
+
+	if(viewPort.isInside(pStart) && viewPort.isInside(pEnd))
+	{
+		target.drawLine(pStart, pEnd, ColorRGBA(255, 255, 0), ColorRGBA(255, 0, 0));
+	}
+}
+
+void MapOverlayLogVisualizer::drawText(
+	int3 tile,
+	int lineNumber,
+	const std::string & text,
+	const std::optional<ColorRGBA> & background)
+{
+	const Point offset = Point(6, 6);
+
+	auto level = model->getLevel();
+
+	if(tile.z != level)
+		return;
+
+	auto pStart = offset + model->getTargetTileArea(tile).topLeft();
+	auto viewPort = target.getRenderArea();
+
+	ColorRGBA color = Colors::YELLOW;
+	
+	if(background)
+	{
+		color = ((background->b + background->r + background->g) < 300)
+			? Colors::WHITE
+			: Colors::BLACK;
+	}
+
+	if(viewPort.isInside(pStart))
+	{
+		const auto & font = GH.renderHandler().loadFont(FONT_TINY);
+
+		int w = font->getStringWidth(text);
+		int h = font->getLineHeight();
+
+		pStart.y += h * lineNumber;
+
+		if(background)
+		{
+			target.drawColor(Rect(pStart, Point(w + 4, h)), *background);
+			pStart.x += 2;
+		}
+
+		target.drawText(pStart, EFonts::FONT_TINY, color, ETextAlignment::TOPLEFT, text);
+	}
+}
diff --color -urN vcmi-1.5.7/client/mapView/MapOverlayLogVisualizer.h vcmi/client/mapView/MapOverlayLogVisualizer.h
--- vcmi-1.5.7/client/mapView/MapOverlayLogVisualizer.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/client/mapView/MapOverlayLogVisualizer.h	2024-12-19 15:00:22.261121613 +0100
@@ -0,0 +1,33 @@
+/*
+ * MapOverlayLogVisualizer.h, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#pragma once
+
+#include "../../lib/logging/VisualLogger.h"
+
+VCMI_LIB_NAMESPACE_BEGIN
+
+class int3;
+
+VCMI_LIB_NAMESPACE_END
+
+class Canvas;
+class MapViewModel;
+
+class MapOverlayLogVisualizer : public IMapOverlayLogVisualizer
+{
+private:
+	Canvas & target;
+	std::shared_ptr<MapViewModel> model;
+
+public:
+	MapOverlayLogVisualizer(Canvas & target, std::shared_ptr<MapViewModel> model);
+	void drawLine(int3 start, int3 end) override;
+	void drawText(int3 tile, int lineNumber, const std::string & text, const std::optional<ColorRGBA> & color) override;
+};
diff --color -urN vcmi-1.5.7/client/mapView/MapRendererContext.cpp vcmi/client/mapView/MapRendererContext.cpp
--- vcmi-1.5.7/client/mapView/MapRendererContext.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/mapView/MapRendererContext.cpp	2024-12-19 15:00:22.262121654 +0100
@@ -113,14 +113,14 @@
 
 size_t MapRendererBaseContext::objectGroupIndex(ObjectInstanceID objectID) const
 {
-	static const std::vector<size_t> idleGroups = {0, 13, 0, 1, 2, 3, 4, 15, 14};
+	static const std::array<size_t, 9> idleGroups = {0, 13, 0, 1, 2, 3, 4, 15, 14};
 	return idleGroups[getObjectRotation(objectID)];
 }
 
 Point MapRendererBaseContext::objectImageOffset(ObjectInstanceID objectID, const int3 & coordinates) const
 {
 	const CGObjectInstance * object = getObject(objectID);
-	int3 offsetTiles(object->getPosition() - coordinates);
+	int3 offsetTiles(object->anchorPos() - coordinates);
 	return Point(offsetTiles) * Point(32, 32);
 }
 
@@ -156,6 +156,16 @@
 	return std::numeric_limits<size_t>::max();
 }
 
+std::string MapRendererBaseContext::overlayText(const int3 & coordinates) const
+{
+	return {};
+}
+
+ColorRGBA MapRendererBaseContext::overlayTextColor(const int3 & coordinates) const
+{
+	return {};
+}
+
 double MapRendererBaseContext::viewTransitionProgress() const
 {
 	return 0;
@@ -181,7 +191,12 @@
 	return false;
 }
 
-bool MapRendererBaseContext::showOverlay() const
+bool MapRendererBaseContext::showImageOverlay() const
+{
+	return false;
+}
+
+bool MapRendererBaseContext::showTextOverlay() const
 {
 	return false;
 }
@@ -253,6 +268,59 @@
 	return frameIndex;
 }
 
+std::string MapRendererAdventureContext::overlayText(const int3 & coordinates) const
+{
+	if(!isVisible(coordinates))
+		return {};
+
+	const auto & tile = getMapTile(coordinates);
+
+	if (!tile.visitable())
+		return {};
+
+	return tile.visitableObjects.back()->getObjectName();
+}
+
+ColorRGBA MapRendererAdventureContext::overlayTextColor(const int3 & coordinates) const
+{
+	if(!isVisible(coordinates))
+		return {};
+
+	const auto & tile = getMapTile(coordinates);
+
+	if (!tile.visitable())
+		return {};
+
+	const auto * object = tile.visitableObjects.back();
+
+	if (object->getOwner() == LOCPLINT->playerID)
+		return { 0, 192, 0};
+
+	if (LOCPLINT->cb->getPlayerRelations(object->getOwner(), LOCPLINT->playerID) == PlayerRelations::ALLIES)
+		return { 0, 128, 255};
+
+	if (object->getOwner().isValidPlayer())
+		return { 255, 0, 0};
+
+	if (object->ID == MapObjectID::MONSTER)
+		return { 255, 0, 0};
+
+	auto hero = LOCPLINT->localState->getCurrentHero();
+
+	if (hero)
+	{
+		if (object->wasVisited(hero))
+			return { 160, 160, 160 };
+	}
+	else
+	{
+		if (object->wasVisited(LOCPLINT->playerID))
+			return { 160, 160, 160 };
+	}
+
+	return { 255, 192, 0 };
+}
+
 bool MapRendererAdventureContext::showBorder() const
 {
 	return true;
@@ -273,6 +341,11 @@
 	return settingShowBlocked;
 }
 
+bool MapRendererAdventureContext::showTextOverlay() const
+{
+	return settingTextOverlay;
+}
+
 bool MapRendererAdventureContext::showSpellRange(const int3 & position) const
 {
 	if (!settingSpellRange)
@@ -330,7 +403,7 @@
 {
 	if(target == objectID)
 	{
-		static const std::vector<size_t> moveGroups = {0, 10, 5, 6, 7, 8, 9, 12, 11};
+		static const std::array<size_t, 9> moveGroups = {0, 10, 5, 6, 7, 8, 9, 12, 11};
 		return moveGroups[getObjectRotation(objectID)];
 	}
 	return MapRendererAdventureContext::objectGroupIndex(objectID);
@@ -411,7 +484,7 @@
 {
 }
 
-bool MapRendererWorldViewContext::showOverlay() const
+bool MapRendererWorldViewContext::showImageOverlay() const
 {
 	return true;
 }
@@ -425,7 +498,7 @@
 	{
 		const auto * object = getObject(objectID);
 
-		if(!object->visitableAt(coordinates.x, coordinates.y))
+		if(!object->visitableAt(coordinates))
 			continue;
 
 		ObjectPosInfo info(object);
@@ -475,7 +548,10 @@
 			return iconIndex;
 	}
 
-	return MapRendererWorldViewContext::overlayImageIndex(coordinates);
+	if (MapRendererBaseContext::isVisible(coordinates))
+		return MapRendererWorldViewContext::overlayImageIndex(coordinates);
+	else
+		return std::numeric_limits<size_t>::max();
 }
 
 MapRendererPuzzleMapContext::MapRendererPuzzleMapContext(const MapRendererContextState & viewState)
diff --color -urN vcmi-1.5.7/client/mapView/MapRendererContext.h vcmi/client/mapView/MapRendererContext.h
--- vcmi-1.5.7/client/mapView/MapRendererContext.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/mapView/MapRendererContext.h	2024-12-19 15:00:22.262121654 +0100
@@ -48,13 +48,16 @@
 	size_t objectImageIndex(ObjectInstanceID objectID, size_t groupSize) const override;
 	size_t terrainImageIndex(size_t groupSize) const override;
 	size_t overlayImageIndex(const int3 & coordinates) const override;
+	std::string overlayText(const int3 & coordinates) const override;
+	ColorRGBA overlayTextColor(const int3 & coordinates) const override;
 
 	double viewTransitionProgress() const override;
 	bool filterGrayscale() const override;
 	bool showRoads() const override;
 	bool showRivers() const override;
 	bool showBorder() const override;
-	bool showOverlay() const override;
+	bool showImageOverlay() const override;
+	bool showTextOverlay() const override;
 	bool showGrid() const override;
 	bool showVisitable() const override;
 	bool showBlocked() const override;
@@ -69,6 +72,7 @@
 	bool settingShowVisitable = false;
 	bool settingShowBlocked = false;
 	bool settingSpellRange= false;
+	bool settingTextOverlay = false;
 	bool settingsAdventureObjectAnimation = true;
 	bool settingsAdventureTerrainAnimation = true;
 
@@ -77,11 +81,14 @@
 	const CGPath * currentPath() const override;
 	size_t objectImageIndex(ObjectInstanceID objectID, size_t groupSize) const override;
 	size_t terrainImageIndex(size_t groupSize) const override;
+	std::string overlayText(const int3 & coordinates) const override;
+	ColorRGBA overlayTextColor(const int3 & coordinates) const override;
 
 	bool showBorder() const override;
 	bool showGrid() const override;
 	bool showVisitable() const override;
 	bool showBlocked() const override;
+	bool showTextOverlay() const override;
 
 	bool showSpellRange(const int3 & position) const override;
 };
@@ -133,7 +140,7 @@
 	explicit MapRendererWorldViewContext(const MapRendererContextState & viewState);
 
 	size_t overlayImageIndex(const int3 & coordinates) const override;
-	bool showOverlay() const override;
+	bool showImageOverlay() const override;
 };
 
 class MapRendererSpellViewContext : public MapRendererWorldViewContext
diff --color -urN vcmi-1.5.7/client/mapView/MapRendererContextState.cpp vcmi/client/mapView/MapRendererContextState.cpp
--- vcmi-1.5.7/client/mapView/MapRendererContextState.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/mapView/MapRendererContextState.cpp	2024-12-19 15:00:22.262121654 +0100
@@ -49,14 +49,13 @@
 	{
 		for(int fy = 0; fy < obj->getHeight(); ++fy)
 		{
-			int3 currTile(obj->pos.x - fx, obj->pos.y - fy, obj->pos.z);
+			int3 currTile(obj->anchorPos().x - fx, obj->anchorPos().y - fy, obj->anchorPos().z);
 
-			if(LOCPLINT->cb->isInTheMap(currTile) && obj->coveringAt(currTile.x, currTile.y))
+			if(LOCPLINT->cb->isInTheMap(currTile) && obj->coveringAt(currTile))
 			{
 				auto & container = objects[currTile.z][currTile.x][currTile.y];
-
-				container.push_back(obj->id);
-				boost::range::sort(container, compareObjectBlitOrder);
+				auto position = std::upper_bound(container.begin(), container.end(), obj->id, compareObjectBlitOrder);
+				container.insert(position, obj->id);
 			}
 		}
 	}
@@ -73,7 +72,7 @@
 	{
 		for(int y = yFrom; y <= yDest; ++y)
 		{
-			int3 currTile(x, y, object->pos.z);
+			int3 currTile(x, y, object->anchorPos().z);
 
 			if(LOCPLINT->cb->isInTheMap(currTile))
 			{
diff --color -urN vcmi-1.5.7/client/mapView/MapRenderer.cpp vcmi/client/mapView/MapRenderer.cpp
--- vcmi-1.5.7/client/mapView/MapRenderer.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/mapView/MapRenderer.cpp	2024-12-19 15:00:22.261121613 +0100
@@ -21,6 +21,7 @@
 #include "../render/IImage.h"
 #include "../render/IRenderHandler.h"
 #include "../render/Colors.h"
+#include "../render/Graphics.h"
 
 #include "../../CCallback.h"
 
@@ -104,31 +105,39 @@
 	for(auto & entry : terrainAnimations)
 	{
 		if (!filename.empty())
-		{
-			entry = GH.renderHandler().loadAnimation(filename);
-			entry->preload();
-		}
-		else
-			entry = GH.renderHandler().createAnimation();
-
-		for(size_t i = 0; i < entry->size(); ++i)
-			entry->getImage(i)->setBlitMode(blitMode);
+			entry = GH.renderHandler().loadAnimation(filename, blitMode);
 	}
 
-	for(size_t i = 0; i < terrainAnimations[0]->size(); ++i)
-	{
-		terrainAnimations[1]->getImage(i)->verticalFlip();
-		terrainAnimations[3]->getImage(i)->verticalFlip();
+	if (terrainAnimations[1])
+		terrainAnimations[1]->verticalFlip();
 
-		terrainAnimations[2]->getImage(i)->horizontalFlip();
-		terrainAnimations[3]->getImage(i)->horizontalFlip();
-	}
+	if (terrainAnimations[3])
+		terrainAnimations[3]->verticalFlip();
+
+	if (terrainAnimations[2])
+		terrainAnimations[2]->horizontalFlip();
+
+	if (terrainAnimations[3])
+		terrainAnimations[3]->horizontalFlip();
 }
 
-std::shared_ptr<IImage> MapTileStorage::find(size_t fileIndex, size_t rotationIndex, size_t imageIndex)
+std::shared_ptr<IImage> MapTileStorage::find(size_t fileIndex, size_t rotationIndex, size_t imageIndex, size_t groupIndex)
 {
 	const auto & animation = animations[fileIndex][rotationIndex];
-	return animation->getImage(imageIndex);
+	if (animation)
+		return animation->getImage(imageIndex, groupIndex);
+	else
+		return nullptr;
+}
+
+int MapTileStorage::groupCount(size_t fileIndex, size_t rotationIndex, size_t imageIndex)
+{
+	const auto & animation = animations[fileIndex][rotationIndex];
+	if (animation)
+		for(int i = 0;; i++)
+			if(!animation->getImage(imageIndex, i, false))
+				return i;
+	return 1;
 }
 
 MapRendererTerrain::MapRendererTerrain()
@@ -136,7 +145,7 @@
 {
 	logGlobal->debug("Loading map terrains");
 	for(const auto & terrain : VLC->terrainTypeHandler->objects)
-		storage.load(terrain->getIndex(), terrain->tilesFilename, EImageBlitMode::OPAQUE);
+		storage.load(terrain->getIndex(), AnimationPath::builtin(terrain->tilesFilename.getName() + (terrain->paletteAnimation.size() ? "_Shifted": "")), EImageBlitMode::OPAQUE);
 	logGlobal->debug("Done loading map terrains");
 }
 
@@ -144,22 +153,20 @@
 {
 	const TerrainTile & mapTile = context.getMapTile(coordinates);
 
-	int32_t terrainIndex = mapTile.terType->getIndex();
+	int32_t terrainIndex = mapTile.getTerrainID();
 	int32_t imageIndex = mapTile.terView;
 	int32_t rotationIndex = mapTile.extTileFlags % 4;
 
-	const auto & image = storage.find(terrainIndex, rotationIndex, imageIndex);
+	int groupCount = storage.groupCount(terrainIndex, rotationIndex, imageIndex);
+	const auto & image = storage.find(terrainIndex, rotationIndex, imageIndex, groupCount > 1 ? context.terrainImageIndex(groupCount) : 0);
 
 	assert(image);
 	if (!image)
 	{
-		logGlobal->error("Failed to find image %d for terrain %s on tile %s", imageIndex, mapTile.terType->getNameTranslated(), coordinates.toString());
+		logGlobal->error("Failed to find image %d for terrain %s on tile %s", imageIndex, mapTile.getTerrain()->getNameTranslated(), coordinates.toString());
 		return;
 	}
 
-	for( auto const & element : mapTile.terType->paletteAnimation)
-		image->shiftPalette(element.start, element.length, context.terrainImageIndex(element.length));
-
 	target.draw(image, Point(0, 0));
 }
 
@@ -167,7 +174,7 @@
 {
 	const TerrainTile & mapTile = context.getMapTile(coordinates);
 
-	if(!mapTile.terType->paletteAnimation.empty())
+	if(!mapTile.getTerrain()->paletteAnimation.empty())
 		return context.terrainImageIndex(250);
 	return 0xff - 1;
 }
@@ -177,7 +184,7 @@
 {
 	logGlobal->debug("Loading map rivers");
 	for(const auto & river : VLC->riverTypeHandler->objects)
-		storage.load(river->getIndex(), river->tilesFilename, EImageBlitMode::COLORKEY);
+		storage.load(river->getIndex(), AnimationPath::builtin(river->tilesFilename.getName() + (river->paletteAnimation.size() ? "_Shifted": "")), EImageBlitMode::COLORKEY);
 	logGlobal->debug("Done loading map rivers");
 }
 
@@ -185,17 +192,15 @@
 {
 	const TerrainTile & mapTile = context.getMapTile(coordinates);
 
-	if(mapTile.riverType->getId() == River::NO_RIVER)
+	if(!mapTile.hasRiver())
 		return;
 
-	int32_t terrainIndex = mapTile.riverType->getIndex();
+	int32_t terrainIndex = mapTile.getRiverID();
 	int32_t imageIndex = mapTile.riverDir;
 	int32_t rotationIndex = (mapTile.extTileFlags >> 2) % 4;
 
-	const auto & image = storage.find(terrainIndex, rotationIndex, imageIndex);
-
-	for( auto const & element : mapTile.riverType->paletteAnimation)
-		image->shiftPalette(element.start, element.length, context.terrainImageIndex(element.length));
+	int groupCount = storage.groupCount(terrainIndex, rotationIndex, imageIndex);
+	const auto & image = storage.find(terrainIndex, rotationIndex, imageIndex, groupCount > 1 ? context.terrainImageIndex(groupCount) : 0);
 
 	target.draw(image, Point(0, 0));
 }
@@ -204,7 +209,7 @@
 {
 	const TerrainTile & mapTile = context.getMapTile(coordinates);
 
-	if(!mapTile.riverType->paletteAnimation.empty())
+	if(!mapTile.getRiver()->paletteAnimation.empty())
 		return context.terrainImageIndex(250);
 	return 0xff-1;
 }
@@ -225,9 +230,9 @@
 	if(context.isInMap(coordinatesAbove))
 	{
 		const TerrainTile & mapTileAbove = context.getMapTile(coordinatesAbove);
-		if(mapTileAbove.roadType->getId() != Road::NO_ROAD)
+		if(mapTileAbove.hasRoad())
 		{
-			int32_t terrainIndex = mapTileAbove.roadType->getIndex();
+			int32_t terrainIndex = mapTileAbove.getRoadID();
 			int32_t imageIndex = mapTileAbove.roadDir;
 			int32_t rotationIndex = (mapTileAbove.extTileFlags >> 4) % 4;
 
@@ -237,9 +242,9 @@
 	}
 
 	const TerrainTile & mapTile = context.getMapTile(coordinates);
-	if(mapTile.roadType->getId() != Road::NO_ROAD)
+	if(mapTile.hasRoad())
 	{
-		int32_t terrainIndex = mapTile.roadType->getIndex();
+		int32_t terrainIndex = mapTile.getRoadID();
 		int32_t imageIndex = mapTile.roadDir;
 		int32_t rotationIndex = (mapTile.extTileFlags >> 4) % 4;
 
@@ -255,8 +260,7 @@
 
 MapRendererBorder::MapRendererBorder()
 {
-	animation = GH.renderHandler().loadAnimation(AnimationPath::builtin("EDG"));
-	animation->preload();
+	animation = GH.renderHandler().loadAnimation(AnimationPath::builtin("EDG"), EImageBlitMode::OPAQUE);
 }
 
 size_t MapRendererBorder::getIndexForTile(IMapRendererContext & context, const int3 & tile)
@@ -317,13 +321,8 @@
 
 MapRendererFow::MapRendererFow()
 {
-	fogOfWarFullHide = GH.renderHandler().loadAnimation(AnimationPath::builtin("TSHRC"));
-	fogOfWarFullHide->preload();
-	fogOfWarPartialHide = GH.renderHandler().loadAnimation(AnimationPath::builtin("TSHRE"));
-	fogOfWarPartialHide->preload();
-
-	for(size_t i = 0; i < fogOfWarFullHide->size(); ++i)
-		fogOfWarFullHide->getImage(i)->setBlitMode(EImageBlitMode::OPAQUE);
+	fogOfWarFullHide = GH.renderHandler().loadAnimation(AnimationPath::builtin("TSHRC"), EImageBlitMode::OPAQUE);
+	fogOfWarPartialHide = GH.renderHandler().loadAnimation(AnimationPath::builtin("TSHRE"), EImageBlitMode::SIMPLE);
 
 	static const std::vector<int> rotations = {22, 15, 2, 13, 12, 16, 28, 17, 20, 19, 7, 24, 26, 25, 30, 32, 27};
 
@@ -332,8 +331,7 @@
 	for(const int rotation : rotations)
 	{
 		fogOfWarPartialHide->duplicateImage(0, rotation, 0);
-		auto image = fogOfWarPartialHide->getImage(size, 0);
-		image->verticalFlip();
+		fogOfWarPartialHide->verticalFlip(size, 0);
 		size++;
 	}
 }
@@ -391,26 +389,26 @@
 	}
 
 	bool generateMovementGroups = (info->id == Obj::BOAT) || (info->id == Obj::HERO);
+	bool enableOverlay = obj->ID != Obj::BOAT && obj->ID != Obj::HERO && obj->getOwner() != PlayerColor::UNFLAGGABLE;
 
 	// Boat appearance files only contain single, unanimated image
 	// proper boat animations are actually in different file
 	if (info->id == Obj::BOAT)
 		if(auto boat = dynamic_cast<const CGBoat*>(obj); boat && !boat->actualAnimation.empty())
-			return getAnimation(boat->actualAnimation, generateMovementGroups);
+			return getAnimation(boat->actualAnimation, generateMovementGroups, enableOverlay);
 
-	return getAnimation(info->animationFile, generateMovementGroups);
+	return getAnimation(info->animationFile, generateMovementGroups, enableOverlay);
 }
 
-std::shared_ptr<CAnimation> MapRendererObjects::getAnimation(const AnimationPath & filename, bool generateMovementGroups)
+std::shared_ptr<CAnimation> MapRendererObjects::getAnimation(const AnimationPath & filename, bool generateMovementGroups, bool enableOverlay)
 {
 	auto it = animations.find(filename);
 
 	if(it != animations.end())
 		return it->second;
 
-	auto ret = GH.renderHandler().loadAnimation(filename);
+	auto ret = GH.renderHandler().loadAnimation(filename, enableOverlay ? EImageBlitMode::WITH_SHADOW_AND_OVERLAY : EImageBlitMode::WITH_SHADOW);
 	animations[filename] = ret;
-	ret->preload();
 
 	if(generateMovementGroups)
 	{
@@ -436,14 +434,14 @@
 	{
 		assert(dynamic_cast<const CGHeroInstance *>(obj) != nullptr);
 		assert(obj->tempOwner.isValidPlayer());
-		return getAnimation(AnimationPath::builtin(heroFlags[obj->tempOwner.getNum()]), true);
+		return getAnimation(AnimationPath::builtin(heroFlags[obj->tempOwner.getNum()]), true, false);
 	}
 
 	if(obj->ID == Obj::BOAT)
 	{
 		const auto * boat = dynamic_cast<const CGBoat *>(obj);
 		if(boat && boat->hero && !boat->flagAnimations[boat->hero->tempOwner.getNum()].empty())
-			return getAnimation(boat->flagAnimations[boat->hero->tempOwner.getNum()], true);
+			return getAnimation(boat->flagAnimations[boat->hero->tempOwner.getNum()], true, false);
 	}
 
 	return nullptr;
@@ -456,7 +454,7 @@
 		// Boats have additional animation with waves around boat
 		const auto * boat = dynamic_cast<const CGBoat *>(obj);
 		if(boat && boat->hero && !boat->overlayAnimation.empty())
-			return getAnimation(boat->overlayAnimation, true);
+			return getAnimation(boat->overlayAnimation, true, false);
 	}
 	return nullptr;
 }
@@ -487,23 +485,20 @@
 		return;
 
 	image->setAlpha(transparency);
-	image->setFlagColor(object->tempOwner);
+	if (object->ID != Obj::HERO) // heroes use separate image with flag instead of player-colored palette
+	{
+		if (object->getOwner().isValidPlayer())
+			image->setOverlayColor(graphics->playerColors[object->getOwner().getNum()]);
+
+		if (object->getOwner() == PlayerColor::NEUTRAL)
+			image->setOverlayColor(graphics->neutralColor);
+	}
 
 	Point offsetPixels = context.objectImageOffset(object->id, coordinates);
 
 	if ( offsetPixels.x < image->dimensions().x && offsetPixels.y < image->dimensions().y)
 	{
 		Point imagePos = image->dimensions() - offsetPixels - Point(32, 32);
-
-		//if (transparency == 255)
-		//{
-		//	Canvas intermediate(Point(32,32));
-		//	intermediate.enableTransparency(true);
-		//	image->setBlitMode(EImageBlitMode::OPAQUE);
-		//	intermediate.draw(image, Point(0, 0), Rect(imagePos, Point(32,32)));
-		//	target.draw(intermediate, Point(0,0));
-		//	return;
-		//}
 		target.draw(image, Point(0, 0), Rect(imagePos, Point(32,32)));
 	}
 }
@@ -571,10 +566,10 @@
 }
 
 MapRendererOverlay::MapRendererOverlay()
-	: imageGrid(GH.renderHandler().loadImage(ImagePath::builtin("debug/grid"), EImageBlitMode::ALPHA))
-	, imageBlocked(GH.renderHandler().loadImage(ImagePath::builtin("debug/blocked"), EImageBlitMode::ALPHA))
-	, imageVisitable(GH.renderHandler().loadImage(ImagePath::builtin("debug/visitable"), EImageBlitMode::ALPHA))
-	, imageSpellRange(GH.renderHandler().loadImage(ImagePath::builtin("debug/spellRange"), EImageBlitMode::ALPHA))
+	: imageGrid(GH.renderHandler().loadImage(ImagePath::builtin("debug/grid"), EImageBlitMode::COLORKEY))
+	, imageBlocked(GH.renderHandler().loadImage(ImagePath::builtin("debug/blocked"), EImageBlitMode::COLORKEY))
+	, imageVisitable(GH.renderHandler().loadImage(ImagePath::builtin("debug/visitable"), EImageBlitMode::COLORKEY))
+	, imageSpellRange(GH.renderHandler().loadImage(ImagePath::builtin("debug/spellRange"), EImageBlitMode::COLORKEY))
 {
 
 }
@@ -595,8 +590,8 @@
 
 			if(context.objectTransparency(objectID, coordinates) > 0 && !context.isActiveHero(object))
 			{
-				visitable |= object->visitableAt(coordinates.x, coordinates.y);
-				blocking |= object->blockingAt(coordinates.x, coordinates.y);
+				visitable |= object->visitableAt(coordinates);
+				blocking |= object->blockingAt(coordinates);
 			}
 		}
 
@@ -630,9 +625,8 @@
 }
 
 MapRendererPath::MapRendererPath()
-	: pathNodes(GH.renderHandler().loadAnimation(AnimationPath::builtin("ADAG")))
+	: pathNodes(GH.renderHandler().loadAnimation(AnimationPath::builtin("ADAG"), EImageBlitMode::SIMPLE))
 {
-	pathNodes->preload();
 }
 
 size_t MapRendererPath::selectImageReachability(bool reachableToday, size_t imageIndex)
diff --color -urN vcmi-1.5.7/client/mapView/MapRenderer.h vcmi/client/mapView/MapRenderer.h
--- vcmi-1.5.7/client/mapView/MapRenderer.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/mapView/MapRenderer.h	2024-12-19 15:00:22.261121613 +0100
@@ -23,7 +23,7 @@
 class IImage;
 class Canvas;
 class IMapRendererContext;
-enum class EImageBlitMode;
+enum class EImageBlitMode : uint8_t;
 
 class MapTileStorage
 {
@@ -33,7 +33,8 @@
 public:
 	explicit MapTileStorage(size_t capacity);
 	void load(size_t index, const AnimationPath & filename, EImageBlitMode blitMode);
-	std::shared_ptr<IImage> find(size_t fileIndex, size_t rotationIndex, size_t imageIndex);
+	std::shared_ptr<IImage> find(size_t fileIndex, size_t rotationIndex, size_t imageIndex, size_t groupIndex = 0);
+	int groupCount(size_t fileIndex, size_t rotationIndex, size_t imageIndex);
 };
 
 class MapRendererTerrain
@@ -77,7 +78,7 @@
 	std::shared_ptr<CAnimation> getFlagAnimation(const CGObjectInstance * obj);
 	std::shared_ptr<CAnimation> getOverlayAnimation(const CGObjectInstance * obj);
 
-	std::shared_ptr<CAnimation> getAnimation(const AnimationPath & filename, bool generateMovementGroups);
+	std::shared_ptr<CAnimation> getAnimation(const AnimationPath & filename, bool generateMovementGroups, bool enableOverlay);
 
 	std::shared_ptr<IImage> getImage(IMapRendererContext & context, const CGObjectInstance * obj, const std::shared_ptr<CAnimation> & animation) const;
 
diff --color -urN vcmi-1.5.7/client/mapView/MapViewActions.cpp vcmi/client/mapView/MapViewActions.cpp
--- vcmi-1.5.7/client/mapView/MapViewActions.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/mapView/MapViewActions.cpp	2024-12-19 15:00:22.262121654 +0100
@@ -34,7 +34,7 @@
 	pos.w = model->getPixelsVisibleDimensions().x;
 	pos.h = model->getPixelsVisibleDimensions().y;
 
-	addUsedEvents(LCLICK | SHOW_POPUP | DRAG | GESTURE | HOVER | MOVE | WHEEL);
+	addUsedEvents(LCLICK | SHOW_POPUP | DRAG | DRAG_POPUP | GESTURE | HOVER | MOVE | WHEEL);
 }
 
 void MapViewActions::setContext(const std::shared_ptr<IMapRendererContext> & context)
@@ -101,6 +101,11 @@
 		owner.onMapSwiped(lastUpdateDistance);
 }
 
+void MapViewActions::mouseDraggedPopup(const Point & cursorPosition, const Point & lastUpdateDistance)
+{
+	owner.onMapSwiped(lastUpdateDistance);
+}
+
 void MapViewActions::gesturePanning(const Point & initialPosition, const Point & currentPosition, const Point & lastUpdateDistance)
 {
 	owner.onMapSwiped(lastUpdateDistance);
diff --color -urN vcmi-1.5.7/client/mapView/MapViewActions.h vcmi/client/mapView/MapViewActions.h
--- vcmi-1.5.7/client/mapView/MapViewActions.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/mapView/MapViewActions.h	2024-12-19 15:00:22.262121654 +0100
@@ -42,6 +42,7 @@
 	void gesture(bool on, const Point & initialPosition, const Point & finalPosition) override;
 	void mouseMoved(const Point & cursorPosition, const Point & lastUpdateDistance) override;
 	void mouseDragged(const Point & cursorPosition, const Point & lastUpdateDistance) override;
+	void mouseDraggedPopup(const Point & cursorPosition, const Point & lastUpdateDistance) override;
 	void wheelScrolled(int distance) override;
 	
 	bool dragActive;
diff --color -urN vcmi-1.5.7/client/mapView/MapViewCache.cpp vcmi/client/mapView/MapViewCache.cpp
--- vcmi-1.5.7/client/mapView/MapViewCache.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/mapView/MapViewCache.cpp	2024-12-19 15:00:22.262121654 +0100
@@ -18,9 +18,12 @@
 #include "../render/CAnimation.h"
 #include "../render/Canvas.h"
 #include "../render/IImage.h"
+#include "../render/IFont.h"
 #include "../render/IRenderHandler.h"
+#include "../render/Graphics.h"
 
 #include "../gui/CGuiHandler.h"
+#include "../widgets/TextControls.h"
 
 #include "../../lib/mapObjects/CObjectHandler.h"
 #include "../../lib/int3.h"
@@ -30,16 +33,13 @@
 MapViewCache::MapViewCache(const std::shared_ptr<MapViewModel> & model)
 	: model(model)
 	, cachedLevel(0)
+	, overlayWasVisible(false)
 	, mapRenderer(new MapRenderer())
-	, iconsStorage(GH.renderHandler().loadAnimation(AnimationPath::builtin("VwSymbol")))
-	, intermediate(new Canvas(Point(32, 32)))
-	, terrain(new Canvas(model->getCacheDimensionsPixels()))
-	, terrainTransition(new Canvas(model->getPixelsVisibleDimensions()))
-{
-	iconsStorage->preload();
-	for(size_t i = 0; i < iconsStorage->size(); ++i)
-		iconsStorage->getImage(i)->setBlitMode(EImageBlitMode::COLORKEY);
-
+	, iconsStorage(GH.renderHandler().loadAnimation(AnimationPath::builtin("VwSymbol"), EImageBlitMode::COLORKEY))
+	, intermediate(new Canvas(Point(32, 32), CanvasScalingPolicy::AUTO))
+	, terrain(new Canvas(model->getCacheDimensionsPixels(), CanvasScalingPolicy::AUTO))
+	, terrainTransition(new Canvas(model->getPixelsVisibleDimensions(), CanvasScalingPolicy::AUTO))
+{
 	Point visibleSize = model->getTilesVisibleDimensions();
 	terrainChecksum.resize(boost::extents[visibleSize.x][visibleSize.y]);
 	tilesUpToDate.resize(boost::extents[visibleSize.x][visibleSize.y]);
@@ -141,7 +141,9 @@
 void MapViewCache::render(const std::shared_ptr<IMapRendererContext> & context, Canvas & target, bool fullRedraw)
 {
 	bool mapMoved = (cachedPosition != model->getMapViewCenter());
-	bool lazyUpdate = !mapMoved && !fullRedraw && vstd::isAlmostZero(context->viewTransitionProgress());
+	bool overlayVisible = context->showImageOverlay() || context->showTextOverlay();
+	bool overlayVisibilityChanged = overlayVisible != overlayWasVisible;
+	bool lazyUpdate = !overlayVisibilityChanged && !mapMoved && !fullRedraw && vstd::isAlmostZero(context->viewTransitionProgress());
 
 	Rect dimensions = model->getTilesTotalRect();
 
@@ -165,18 +167,18 @@
 		}
 	}
 
-	if(context->showOverlay())
+	if(context->showImageOverlay())
 	{
 		for(int y = dimensions.top(); y < dimensions.bottom(); ++y)
 		{
 			for(int x = dimensions.left(); x < dimensions.right(); ++x)
 			{
 				int3 tile(x, y, model->getLevel());
-				Rect targetRect = model->getTargetTileArea(tile);
 				auto overlay = getOverlayImageForTile(context, tile);
 
 				if(overlay)
 				{
+					Rect targetRect = model->getTargetTileArea(tile);
 					Point position = targetRect.center() - overlay->dimensions() / 2;
 					target.draw(overlay, position);
 				}
@@ -184,10 +186,42 @@
 		}
 	}
 
+	if(context->showTextOverlay())
+	{
+		const auto & font = GH.renderHandler().loadFont(FONT_TINY);
+
+		for(int y = dimensions.top(); y < dimensions.bottom(); ++y)
+		{
+			for(int x = dimensions.left(); x < dimensions.right(); ++x)
+			{
+				int3 tile(x, y, model->getLevel());
+				auto overlay = context->overlayText(tile);
+
+				if(!overlay.empty())
+				{
+					Rect targetRect = model->getTargetTileArea(tile);
+					Point position = targetRect.center();
+					if (x % 2 == 0)
+						position.y += targetRect.h / 4;
+					else
+						position.y -= targetRect.h / 4;
+
+					Point dimensions(font->getStringWidth(overlay), font->getLineHeight());
+					Rect textRect = Rect(position - dimensions / 2, dimensions).resize(2);
+
+					target.drawColor(textRect, context->overlayTextColor(tile));
+					target.drawBorder(textRect, Colors::BRIGHT_YELLOW);
+					target.drawText(position, EFonts::FONT_TINY, Colors::BLACK, ETextAlignment::CENTER, overlay);
+				}
+			}
+		}
+	}
+
 	if(!vstd::isAlmostZero(context->viewTransitionProgress()))
 		target.drawTransparent(*terrainTransition, Point(0, 0), 1.0 - context->viewTransitionProgress());
 
 	cachedPosition = model->getMapViewCenter();
+	overlayWasVisible = overlayVisible;
 }
 
 void MapViewCache::createTransitionSnapshot(const std::shared_ptr<IMapRendererContext> & context)
diff --color -urN vcmi-1.5.7/client/mapView/MapViewCache.h vcmi/client/mapView/MapViewCache.h
--- vcmi-1.5.7/client/mapView/MapViewCache.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/mapView/MapViewCache.h	2024-12-19 15:00:22.263121696 +0100
@@ -44,6 +44,7 @@
 	Point cachedSize;
 	Point cachedPosition;
 	int cachedLevel;
+	bool overlayWasVisible;
 
 	std::shared_ptr<MapViewModel> model;
 
diff --color -urN vcmi-1.5.7/client/mapView/MapViewController.cpp vcmi/client/mapView/MapViewController.cpp
--- vcmi-1.5.7/client/mapView/MapViewController.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/mapView/MapViewController.cpp	2024-12-19 15:00:22.263121696 +0100
@@ -224,6 +224,7 @@
 		adventureContext->settingShowVisitable = settings["session"]["showVisitable"].Bool();
 		adventureContext->settingShowBlocked = settings["session"]["showBlocked"].Bool();
 		adventureContext->settingSpellRange = settings["session"]["showSpellRange"].Bool();
+		adventureContext->settingTextOverlay = GH.isKeyboardAltDown();
 	}
 }
 
@@ -316,7 +317,7 @@
 	if(obj->isVisitable())
 		return context->isVisible(obj->visitablePos());
 	else
-		return context->isVisible(obj->pos);
+		return context->isVisible(obj->anchorPos());
 }
 
 bool MapViewController::isEventVisible(const CGHeroInstance * obj, const int3 & from, const int3 & dest)
diff --color -urN vcmi-1.5.7/client/mapView/MapView.cpp vcmi/client/mapView/MapView.cpp
--- vcmi-1.5.7/client/mapView/MapView.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/mapView/MapView.cpp	2024-12-19 15:00:22.262121654 +0100
@@ -31,7 +31,8 @@
 
 #include "../../lib/CConfigHandler.h"
 #include "../../lib/mapObjects/CGHeroInstance.h"
-#include "../../lib/logging/VisualLogger.h"
+
+#include "MapOverlayLogVisualizer.h"
 
 BasicMapView::~BasicMapView() = default;
 
@@ -52,56 +53,19 @@
 	, tilesCache(new MapViewCache(model))
 	, controller(new MapViewController(model, tilesCache))
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 	pos += offset;
 	pos.w = dimensions.x;
 	pos.h = dimensions.y;
 }
 
-class VisualLoggerRenderer : public ILogVisualizer
-{
-private:
-	Canvas & target;
-	std::shared_ptr<MapViewModel> model;
-
-public:
-	VisualLoggerRenderer(Canvas & target, std::shared_ptr<MapViewModel> model) : target(target), model(model)
-	{
-	}
-
-	virtual void drawLine(int3 start, int3 end) override
-	{
-		const Point offset = Point(30, 30);
-
-		auto level = model->getLevel();
-
-		if(start.z != level || end.z != level)
-			return;
-
-		auto pStart = model->getTargetTileArea(start).topLeft();
-		auto pEnd = model->getTargetTileArea(end).topLeft();
-		auto viewPort = target.getRenderArea();
-
-		pStart.x += 3;
-		pEnd.x -= 3;
-
-		pStart += offset;
-		pEnd += offset;
-
-		if(viewPort.isInside(pStart) && viewPort.isInside(pEnd))
-		{
-			target.drawLine(pStart, pEnd, ColorRGBA(255, 255, 0), ColorRGBA(255, 0, 0));
-		}
-	}
-};
-
 void BasicMapView::render(Canvas & target, bool fullUpdate)
 {
 	Canvas targetClipped(target, pos);
 	tilesCache->update(controller->getContext());
 	tilesCache->render(controller->getContext(), targetClipped, fullUpdate);
 
-	VisualLoggerRenderer r(target, model);
+	MapOverlayLogVisualizer r(target, model);
 	logVisual->visualize(r);
 }
 
@@ -141,7 +105,7 @@
 MapView::MapView(const Point & offset, const Point & dimensions)
 	: BasicMapView(offset, dimensions)
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 	actions = std::make_shared<MapViewActions>(*this, model);
 	actions->setContext(controller->getContext());
 
@@ -187,7 +151,7 @@
 			std::pair<uint32_t, Point> firstAccepted;
 			uint32_t now = GH.input().getTicks();
 			for (auto & x : swipeHistory) {
-				if(now - x.first < postSwipeCatchIntervalMs) { // only the last x ms are catched
+				if(now - x.first < postSwipeCatchIntervalMs) { // only the last x ms are caught
 					if(firstAccepted.first == 0)
 						firstAccepted = x;
 					diff += x.second;
diff --color -urN vcmi-1.5.7/client/media/CAudioBase.cpp vcmi/client/media/CAudioBase.cpp
--- vcmi-1.5.7/client/media/CAudioBase.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/client/media/CAudioBase.cpp	2024-12-19 15:00:22.264121737 +0100
@@ -0,0 +1,43 @@
+/*
+ * CAudioBase.cpp, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#include "StdInc.h"
+#include "CAudioBase.h"
+
+#include <SDL_mixer.h>
+
+int CAudioBase::initializationCounter = 0;
+bool CAudioBase::initializeSuccess = false;
+
+CAudioBase::CAudioBase()
+{
+	if(initializationCounter == 0)
+	{
+		if(Mix_OpenAudio(44100, MIX_DEFAULT_FORMAT, 2, 1024) == -1)
+			logGlobal->error("Mix_OpenAudio error: %s", Mix_GetError());
+		else
+			initializeSuccess = true;
+	}
+	++initializationCounter;
+}
+
+bool CAudioBase::isInitialized() const
+{
+	return initializeSuccess;
+}
+
+CAudioBase::~CAudioBase()
+{
+	--initializationCounter;
+
+	if(initializationCounter == 0 && initializeSuccess)
+		Mix_CloseAudio();
+
+	initializeSuccess = false;
+}
diff --color -urN vcmi-1.5.7/client/media/CAudioBase.h vcmi/client/media/CAudioBase.h
--- vcmi-1.5.7/client/media/CAudioBase.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/client/media/CAudioBase.h	2024-12-19 15:00:22.264121737 +0100
@@ -0,0 +1,22 @@
+/*
+ * CAudioBase.h, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#pragma once
+
+class CAudioBase : boost::noncopyable
+{
+	static int initializationCounter;
+	static bool initializeSuccess;
+
+protected:
+	bool isInitialized() const;
+
+	CAudioBase();
+	~CAudioBase();
+};
diff --color -urN vcmi-1.5.7/client/media/CEmptyVideoPlayer.h vcmi/client/media/CEmptyVideoPlayer.h
--- vcmi-1.5.7/client/media/CEmptyVideoPlayer.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/client/media/CEmptyVideoPlayer.h	2024-12-19 15:00:22.264121737 +0100
@@ -0,0 +1,28 @@
+/*
+ * CEmptyVideoPlayer.h, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#pragma once
+
+#include "IVideoPlayer.h"
+
+class CEmptyVideoPlayer final : public IVideoPlayer
+{
+public:
+	/// Load video from specified path
+	std::unique_ptr<IVideoInstance> open(const VideoPath & name, float scaleFactor) override
+	{
+		return nullptr;
+	};
+
+	/// Extracts audio data from provided video in wav format
+	std::pair<std::unique_ptr<ui8[]>, si64> getAudio(const VideoPath & videoToOpen) override
+	{
+		return {nullptr, 0};
+	};
+};
diff --color -urN vcmi-1.5.7/client/media/CMusicHandler.cpp vcmi/client/media/CMusicHandler.cpp
--- vcmi-1.5.7/client/media/CMusicHandler.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/client/media/CMusicHandler.cpp	2024-12-19 15:00:22.264121737 +0100
@@ -0,0 +1,367 @@
+/*
+ * CMusicHandler.cpp, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#include "StdInc.h"
+#include "CMusicHandler.h"
+
+#include "../CGameInfo.h"
+#include "../eventsSDL/InputHandler.h"
+#include "../gui/CGuiHandler.h"
+#include "../renderSDL/SDLRWwrapper.h"
+
+#include "../../lib/entities/faction/CFaction.h"
+#include "../../lib/entities/faction/CTown.h"
+#include "../../lib/entities/faction/CTownHandler.h"
+#include "../../lib/CRandomGenerator.h"
+#include "../../lib/TerrainHandler.h"
+#include "../../lib/filesystem/Filesystem.h"
+
+#include <SDL_mixer.h>
+
+void CMusicHandler::onVolumeChange(const JsonNode & volumeNode)
+{
+	setVolume(volumeNode.Integer());
+}
+
+CMusicHandler::CMusicHandler():
+	listener(settings.listen["general"]["music"])
+{
+	listener(std::bind(&CMusicHandler::onVolumeChange, this, _1));
+
+	auto mp3files = CResourceHandler::get()->getFilteredFiles([](const ResourcePath & id) ->  bool
+	{
+		if(id.getType() != EResType::SOUND)
+			return false;
+
+		if(!boost::algorithm::istarts_with(id.getName(), "MUSIC/"))
+			return false;
+
+		logGlobal->trace("Found music file %s", id.getName());
+		return true;
+	});
+
+	for(const ResourcePath & file : mp3files)
+	{
+		if(boost::algorithm::istarts_with(file.getName(), "MUSIC/Combat"))
+			addEntryToSet("battle", AudioPath::fromResource(file));
+		else if(boost::algorithm::istarts_with(file.getName(), "MUSIC/AITheme"))
+			addEntryToSet("enemy-turn", AudioPath::fromResource(file));
+	}
+
+	if (isInitialized())
+	{
+		Mix_HookMusicFinished([]()
+		{
+			CCS->musich->musicFinishedCallback();
+		});
+	}
+}
+
+void CMusicHandler::loadTerrainMusicThemes()
+{
+	for(const auto & terrain : CGI->terrainTypeHandler->objects)
+	{
+		for(const auto & filename : terrain->musicFilename)
+			addEntryToSet("terrain_" + terrain->getJsonKey(), filename);
+	}
+
+	for(const auto & faction : CGI->townh->objects)
+	{
+		if (!faction || !faction->hasTown())
+			continue;
+
+		for(const auto & filename : faction->town->clientInfo.musicTheme)
+			addEntryToSet("faction_" + faction->getJsonKey(), filename);
+	}
+}
+
+void CMusicHandler::addEntryToSet(const std::string & set, const AudioPath & musicURI)
+{
+	musicsSet[set].push_back(musicURI);
+}
+
+CMusicHandler::~CMusicHandler()
+{
+	if(isInitialized())
+	{
+		boost::mutex::scoped_lock guard(mutex);
+
+		Mix_HookMusicFinished(nullptr);
+		current->stop();
+
+		current.reset();
+		next.reset();
+	}
+}
+
+void CMusicHandler::playMusic(const AudioPath & musicURI, bool loop, bool fromStart)
+{
+	boost::mutex::scoped_lock guard(mutex);
+
+	if(current && current->isPlaying() && current->isTrack(musicURI))
+		return;
+
+	queueNext(this, "", musicURI, loop, fromStart);
+}
+
+void CMusicHandler::playMusicFromSet(const std::string & musicSet, const std::string & entryID, bool loop, bool fromStart)
+{
+	playMusicFromSet(musicSet + "_" + entryID, loop, fromStart);
+}
+
+void CMusicHandler::playMusicFromSet(const std::string & whichSet, bool loop, bool fromStart)
+{
+	boost::mutex::scoped_lock guard(mutex);
+
+	auto selectedSet = musicsSet.find(whichSet);
+	if(selectedSet == musicsSet.end())
+	{
+		logGlobal->error("Error: playing music from non-existing set: %s", whichSet);
+		return;
+	}
+
+	if(current && current->isPlaying() && current->isSet(whichSet))
+		return;
+
+	// in this mode - play random track from set
+	queueNext(this, whichSet, AudioPath(), loop, fromStart);
+}
+
+void CMusicHandler::queueNext(std::unique_ptr<MusicEntry> queued)
+{
+	if(!isInitialized())
+		return;
+
+	next = std::move(queued);
+
+	if(current == nullptr || !current->stop(1000))
+	{
+		current.reset(next.release());
+		current->play();
+	}
+}
+
+void CMusicHandler::queueNext(CMusicHandler * owner, const std::string & setName, const AudioPath & musicURI, bool looped, bool fromStart)
+{
+	queueNext(std::make_unique<MusicEntry>(owner, setName, musicURI, looped, fromStart));
+}
+
+void CMusicHandler::stopMusic(int fade_ms)
+{
+	if(!isInitialized())
+		return;
+
+	boost::mutex::scoped_lock guard(mutex);
+
+	if(current != nullptr)
+		current->stop(fade_ms);
+	next.reset();
+}
+
+ui32 CMusicHandler::getVolume() const
+{
+	return volume;
+}
+
+void CMusicHandler::setVolume(ui32 percent)
+{
+	volume = std::min(100u, percent);
+
+	if(isInitialized())
+		Mix_VolumeMusic((MIX_MAX_VOLUME * volume) / 100);
+}
+
+void CMusicHandler::musicFinishedCallback()
+{
+	// call music restart in separate thread to avoid deadlock in some cases
+	// It is possible for:
+	// 1) SDL thread to call this method on end of playback
+	// 2) VCMI code to call queueNext() method to queue new file
+	// this leads to:
+	// 1) SDL thread waiting to acquire music lock in this method (while keeping internal SDL mutex locked)
+	// 2) VCMI thread waiting to acquire internal SDL mutex (while keeping music mutex locked)
+
+	GH.dispatchMainThread(
+		[this]()
+		{
+			boost::unique_lock lockGuard(mutex);
+			if(current != nullptr)
+			{
+				// if music is looped, play it again
+				if(current->play())
+					return;
+				else
+					current.reset();
+			}
+
+			if(current == nullptr && next != nullptr)
+			{
+				current.reset(next.release());
+				current->play();
+			}
+		}
+		);
+}
+
+MusicEntry::MusicEntry(CMusicHandler * owner, std::string setName, const AudioPath & musicURI, bool looped, bool fromStart)
+	: owner(owner)
+	, music(nullptr)
+	, setName(std::move(setName))
+	, startTime(static_cast<uint32_t>(-1))
+	, startPosition(0)
+	, loop(looped ? -1 : 1)
+	, fromStart(fromStart)
+	, playing(false)
+
+{
+	if(!musicURI.empty())
+		load(musicURI);
+}
+
+MusicEntry::~MusicEntry()
+{
+	if(playing && loop > 0)
+	{
+		assert(0);
+		logGlobal->error("Attempt to delete music while playing!");
+		Mix_HaltMusic();
+	}
+
+	if(loop == 0 && Mix_FadingMusic() != MIX_NO_FADING)
+	{
+		assert(0);
+		logGlobal->error("Attempt to delete music while fading out!");
+		Mix_HaltMusic();
+	}
+
+	logGlobal->trace("Del-ing music file %s", currentName.getOriginalName());
+	if(music)
+		Mix_FreeMusic(music);
+}
+
+void MusicEntry::load(const AudioPath & musicURI)
+{
+	if(music)
+	{
+		logGlobal->trace("Del-ing music file %s", currentName.getOriginalName());
+		Mix_FreeMusic(music);
+		music = nullptr;
+	}
+
+	if(CResourceHandler::get()->existsResource(musicURI))
+		currentName = musicURI;
+	else
+		currentName = musicURI.addPrefix("MUSIC/");
+
+	music = nullptr;
+
+	logGlobal->trace("Loading music file %s", currentName.getOriginalName());
+
+	try
+	{
+		std::unique_ptr<CInputStream> stream = CResourceHandler::get()->load(currentName);
+
+		if(musicURI.getName() == "BLADEFWCAMPAIGN") // handle defect MP3 file - ffprobe says: Skipping 52 bytes of junk at 0.
+			stream->seek(52);
+
+		auto * musicFile = MakeSDLRWops(std::move(stream));
+		music = Mix_LoadMUS_RW(musicFile, SDL_TRUE);
+	}
+	catch(std::exception & e)
+	{
+		logGlobal->error("Failed to load music. setName=%s\tmusicURI=%s", setName, currentName.getOriginalName());
+		logGlobal->error("Exception: %s", e.what());
+	}
+
+	if(!music)
+	{
+		logGlobal->warn("Warning: Cannot open %s: %s", currentName.getOriginalName(), Mix_GetError());
+		return;
+	}
+}
+
+bool MusicEntry::play()
+{
+	if(!(loop--) && music) //already played once - return
+		return false;
+
+	if(!setName.empty())
+	{
+		const auto & set = owner->musicsSet[setName];
+		const auto & iter = RandomGeneratorUtil::nextItem(set, CRandomGenerator::getDefault());
+		load(*iter);
+	}
+
+	logGlobal->trace("Playing music file %s", currentName.getOriginalName());
+
+	if(!fromStart && owner->trackPositions.count(currentName) > 0 && owner->trackPositions[currentName] > 0)
+	{
+		float timeToStart = owner->trackPositions[currentName];
+		startPosition = std::round(timeToStart * 1000);
+
+		// erase stored position:
+		// if music track will be interrupted again - new position will be written in stop() method
+		// if music track is not interrupted and will finish by timeout/end of file - it will restart from beginning as it should
+		owner->trackPositions.erase(owner->trackPositions.find(currentName));
+
+		if(Mix_FadeInMusicPos(music, 1, 1000, timeToStart) == -1)
+		{
+			logGlobal->error("Unable to play music (%s)", Mix_GetError());
+			return false;
+		}
+	}
+	else
+	{
+		startPosition = 0;
+
+		if(Mix_PlayMusic(music, 1) == -1)
+		{
+			logGlobal->error("Unable to play music (%s)", Mix_GetError());
+			return false;
+		}
+	}
+
+	startTime = GH.input().getTicks();
+
+	playing = true;
+	return true;
+}
+
+bool MusicEntry::stop(int fade_ms)
+{
+	if(Mix_PlayingMusic())
+	{
+		playing = false;
+		loop = 0;
+		uint32_t endTime = GH.input().getTicks();
+		assert(startTime != uint32_t(-1));
+		float playDuration = (endTime - startTime + startPosition) / 1000.f;
+		owner->trackPositions[currentName] = playDuration;
+		logGlobal->trace("Stopping music file %s at %f", currentName.getOriginalName(), playDuration);
+
+		Mix_FadeOutMusic(fade_ms);
+		return true;
+	}
+	return false;
+}
+
+bool MusicEntry::isPlaying() const
+{
+	return playing;
+}
+
+bool MusicEntry::isSet(const std::string & set)
+{
+	return !setName.empty() && set == setName;
+}
+
+bool MusicEntry::isTrack(const AudioPath & track)
+{
+	return setName.empty() && track == currentName;
+}
diff --color -urN vcmi-1.5.7/client/media/CMusicHandler.h vcmi/client/media/CMusicHandler.h
--- vcmi-1.5.7/client/media/CMusicHandler.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/client/media/CMusicHandler.h	2024-12-19 15:00:22.265121778 +0100
@@ -0,0 +1,95 @@
+/*
+ * CMusicHandler.h, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#pragma once
+
+#include "CAudioBase.h"
+#include "IMusicPlayer.h"
+
+#include "../lib/CConfigHandler.h"
+
+struct _Mix_Music;
+using Mix_Music = struct _Mix_Music;
+
+class CMusicHandler;
+
+//Class for handling one music file
+class MusicEntry : boost::noncopyable
+{
+	CMusicHandler * owner;
+	Mix_Music * music;
+
+	//if not null - set from which music will be randomly selected
+	std::string setName;
+	AudioPath currentName;
+
+	uint32_t startTime;
+	uint32_t startPosition;
+	int loop; // -1 = indefinite
+	bool fromStart;
+	bool playing;
+
+	void load(const AudioPath & musicURI);
+
+public:
+	MusicEntry(CMusicHandler * owner, std::string setName, const AudioPath & musicURI, bool looped, bool fromStart);
+	~MusicEntry();
+
+	bool isSet(const std::string & setName);
+	bool isTrack(const AudioPath & trackName);
+	bool isPlaying() const;
+
+	bool play();
+	bool stop(int fade_ms = 0);
+};
+
+class CMusicHandler final : public CAudioBase, public IMusicPlayer
+{
+private:
+	//update volume on configuration change
+	SettingsListener listener;
+	void onVolumeChange(const JsonNode & volumeNode);
+
+	std::unique_ptr<MusicEntry> current;
+	std::unique_ptr<MusicEntry> next;
+
+	boost::mutex mutex;
+	int volume = 0; // from 0 (mute) to 100
+
+	void queueNext(CMusicHandler * owner, const std::string & setName, const AudioPath & musicURI, bool looped, bool fromStart);
+	void queueNext(std::unique_ptr<MusicEntry> queued);
+	void musicFinishedCallback() final;
+
+	/// map <set name> -> <list of URI's to tracks belonging to the said set>
+	std::map<std::string, std::vector<AudioPath>> musicsSet;
+	/// stored position, in seconds at which music player should resume playing this track
+	std::map<AudioPath, float> trackPositions;
+
+public:
+	CMusicHandler();
+	~CMusicHandler();
+
+	/// add entry with URI musicURI in set. Track will have ID musicID
+	void addEntryToSet(const std::string & set, const AudioPath & musicURI);
+
+	void loadTerrainMusicThemes() final;
+	void setVolume(ui32 percent) final;
+	ui32 getVolume() const final;
+
+	/// play track by URI, if loop = true music will be looped
+	void playMusic(const AudioPath & musicURI, bool loop, bool fromStart) final;
+	/// play random track from this set
+	void playMusicFromSet(const std::string & musicSet, bool loop, bool fromStart) final;
+	/// play random track from set (musicSet, entryID)
+	void playMusicFromSet(const std::string & musicSet, const std::string & entryID, bool loop, bool fromStart) final;
+	/// stops currently playing music by fading out it over fade_ms and starts next scheduled track, if any
+	void stopMusic(int fade_ms) final;
+
+	friend class MusicEntry;
+};
diff --color -urN vcmi-1.5.7/client/media/CSoundHandler.cpp vcmi/client/media/CSoundHandler.cpp
--- vcmi-1.5.7/client/media/CSoundHandler.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/client/media/CSoundHandler.cpp	2024-12-19 15:00:22.266121820 +0100
@@ -0,0 +1,406 @@
+/*
+ * CMusicHandler.cpp, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#include "StdInc.h"
+#include "CSoundHandler.h"
+
+#include "../gui/CGuiHandler.h"
+#include "../CGameInfo.h"
+
+#include "../lib/filesystem/Filesystem.h"
+#include "../lib/CRandomGenerator.h"
+
+#include <SDL_mixer.h>
+
+#define VCMI_SOUND_NAME(x)
+#define VCMI_SOUND_FILE(y) #y,
+
+// sounds mapped to soundBase enum
+static const std::string soundsList[] = {
+	"", // invalid
+	"", // todo
+	VCMI_SOUND_LIST
+};
+#undef VCMI_SOUND_NAME
+#undef VCMI_SOUND_FILE
+
+void CSoundHandler::onVolumeChange(const JsonNode & volumeNode)
+{
+	setVolume(volumeNode.Integer());
+}
+
+CSoundHandler::CSoundHandler():
+	listener(settings.listen["general"]["sound"]),
+	ambientConfig(JsonPath::builtin("config/ambientSounds.json"))
+{
+	listener(std::bind(&CSoundHandler::onVolumeChange, this, _1));
+
+	if(ambientConfig["allocateChannels"].isNumber())
+		Mix_AllocateChannels(ambientConfig["allocateChannels"].Integer());
+
+	if(isInitialized())
+	{
+		Mix_ChannelFinished([](int channel)
+		{
+			if (CCS)
+			{
+				CCS->soundh->soundFinishedCallback(channel);
+			}
+		});
+	}
+}
+
+CSoundHandler::~CSoundHandler()
+{
+	if(isInitialized())
+	{
+		Mix_HaltChannel(-1);
+
+		for(auto & chunk : soundChunks)
+		{
+			if(chunk.second.first)
+				Mix_FreeChunk(chunk.second.first);
+		}
+	}
+}
+
+// Allocate an SDL chunk and cache it.
+Mix_Chunk * CSoundHandler::GetSoundChunk(const AudioPath & sound, bool cache)
+{
+	try
+	{
+		if(cache && soundChunks.find(sound) != soundChunks.end())
+			return soundChunks[sound].first;
+
+		auto data = CResourceHandler::get()->load(sound.addPrefix("SOUNDS/"))->readAll();
+		SDL_RWops * ops = SDL_RWFromMem(data.first.get(), data.second);
+		Mix_Chunk * chunk = Mix_LoadWAV_RW(ops, 1); // will free ops
+
+		if(cache)
+			soundChunks.insert({sound, std::make_pair(chunk, std::move(data.first))});
+
+		return chunk;
+	}
+	catch(std::exception & e)
+	{
+		logGlobal->warn("Cannot get sound %s chunk: %s", sound.getOriginalName(), e.what());
+		return nullptr;
+	}
+}
+
+Mix_Chunk * CSoundHandler::GetSoundChunk(std::pair<std::unique_ptr<ui8[]>, si64> & data, bool cache)
+{
+	try
+	{
+		std::vector<ui8> startBytes = std::vector<ui8>(data.first.get(), data.first.get() + std::min(static_cast<si64>(100), data.second));
+
+		if(cache && soundChunksRaw.find(startBytes) != soundChunksRaw.end())
+			return soundChunksRaw[startBytes].first;
+
+		SDL_RWops * ops = SDL_RWFromMem(data.first.get(), data.second);
+		Mix_Chunk * chunk = Mix_LoadWAV_RW(ops, 1); // will free ops
+
+		if(cache)
+			soundChunksRaw.insert({startBytes, std::make_pair(chunk, std::move(data.first))});
+
+		return chunk;
+	}
+	catch(std::exception & e)
+	{
+		logGlobal->warn("Cannot get sound chunk: %s", e.what());
+		return nullptr;
+	}
+}
+
+int CSoundHandler::ambientDistToVolume(int distance) const
+{
+	const auto & distancesVector = ambientConfig["distances"].Vector();
+
+	if(distance >= distancesVector.size())
+		return 0;
+
+	int volumeByDistance = static_cast<int>(distancesVector[distance].Integer());
+	return volumeByDistance * ambientConfig["volume"].Integer() / 100;
+}
+
+void CSoundHandler::ambientStopSound(const AudioPath & soundId)
+{
+	stopSound(ambientChannels[soundId]);
+	setChannelVolume(ambientChannels[soundId], volume);
+}
+
+uint32_t CSoundHandler::getSoundDurationMilliseconds(const AudioPath & sound)
+{
+	if(!isInitialized() || sound.empty())
+		return 0;
+
+	auto resourcePath = sound.addPrefix("SOUNDS/");
+
+	if(!CResourceHandler::get()->existsResource(resourcePath))
+		return 0;
+
+	auto data = CResourceHandler::get()->load(resourcePath)->readAll();
+
+	uint32_t milliseconds = 0;
+
+	Mix_Chunk * chunk = Mix_LoadWAV_RW(SDL_RWFromMem(data.first.get(), data.second), 1);
+
+	int freq = 0;
+	Uint16 fmt = 0;
+	int channels = 0;
+	if(!Mix_QuerySpec(&freq, &fmt, &channels))
+		return 0;
+
+	if(chunk != nullptr)
+	{
+		Uint32 sampleSizeBytes = (fmt & 0xFF) / 8;
+		Uint32 samples = (chunk->alen / sampleSizeBytes);
+		Uint32 frames = (samples / channels);
+		milliseconds = ((frames * 1000) / freq);
+
+		Mix_FreeChunk(chunk);
+	}
+
+	return milliseconds;
+}
+
+// Plays a sound, and return its channel so we can fade it out later
+int CSoundHandler::playSound(soundBase::soundID soundID, int repeats)
+{
+	assert(soundID < soundBase::sound_after_last);
+	auto sound = AudioPath::builtin(soundsList[soundID]);
+	logGlobal->trace("Attempt to play sound %d with file name %s with cache", soundID, sound.getOriginalName());
+
+	return playSound(sound, repeats, true);
+}
+
+int CSoundHandler::playSound(const AudioPath & sound, int repeats, bool cache)
+{
+	if(!isInitialized() || sound.empty())
+		return -1;
+
+	int channel;
+	Mix_Chunk * chunk = GetSoundChunk(sound, cache);
+
+	if(chunk)
+	{
+		channel = Mix_PlayChannel(-1, chunk, repeats);
+		if(channel == -1)
+		{
+			logGlobal->error("Unable to play sound file %s , error %s", sound.getOriginalName(), Mix_GetError());
+			if(!cache)
+				Mix_FreeChunk(chunk);
+		}
+		else if(cache)
+			initCallback(channel);
+		else
+			initCallback(channel, [chunk](){ Mix_FreeChunk(chunk);});
+	}
+	else
+		channel = -1;
+
+	return channel;
+}
+
+int CSoundHandler::playSound(std::pair<std::unique_ptr<ui8[]>, si64> & data, int repeats, bool cache)
+{
+	int channel = -1;
+	if(Mix_Chunk * chunk = GetSoundChunk(data, cache))
+	{
+		channel = Mix_PlayChannel(-1, chunk, repeats);
+		if(channel == -1)
+		{
+			logGlobal->error("Unable to play sound, error %s", Mix_GetError());
+			if(!cache)
+				Mix_FreeChunk(chunk);
+		}
+		else if(cache)
+			initCallback(channel);
+		else
+			initCallback(channel, [chunk](){ Mix_FreeChunk(chunk);});
+	}
+	return channel;
+}
+
+// Helper. Randomly select a sound from an array and play it
+int CSoundHandler::playSoundFromSet(std::vector<soundBase::soundID> & sound_vec)
+{
+	return playSound(*RandomGeneratorUtil::nextItem(sound_vec, CRandomGenerator::getDefault()));
+}
+
+void CSoundHandler::stopSound(int handler)
+{
+	if(isInitialized() && handler != -1)
+		Mix_HaltChannel(handler);
+}
+
+void CSoundHandler::pauseSound(int handler)
+{
+	if(isInitialized() && handler != -1)
+		Mix_Pause(handler);
+}
+
+void CSoundHandler::resumeSound(int handler)
+{
+	if(isInitialized() && handler != -1)
+		Mix_Resume(handler);
+}
+
+ui32 CSoundHandler::getVolume() const
+{
+	return volume;
+}
+
+// Sets the sound volume, from 0 (mute) to 100
+void CSoundHandler::setVolume(ui32 percent)
+{
+	volume = std::min(100u, percent);
+
+	if(isInitialized())
+	{
+		setChannelVolume(-1, volume);
+
+		for(const auto & channel : channelVolumes)
+			updateChannelVolume(channel.first);
+	}
+}
+
+void CSoundHandler::updateChannelVolume(int channel)
+{
+	if(channelVolumes.count(channel))
+		setChannelVolume(channel, getVolume() * channelVolumes[channel] / 100);
+	else
+		setChannelVolume(channel, getVolume());
+}
+
+// Sets the sound volume, from 0 (mute) to 100
+void CSoundHandler::setChannelVolume(int channel, ui32 percent)
+{
+	Mix_Volume(channel, (MIX_MAX_VOLUME * percent) / 100);
+}
+
+void CSoundHandler::setCallback(int channel, std::function<void()> function)
+{
+	boost::mutex::scoped_lock lockGuard(mutexCallbacks);
+
+	auto iter = callbacks.find(channel);
+
+	//channel not found. It may have finished so fire callback now
+	if(iter == callbacks.end())
+		function();
+	else
+		iter->second.push_back(function);
+}
+
+void CSoundHandler::resetCallback(int channel)
+{
+	boost::mutex::scoped_lock lockGuard(mutexCallbacks);
+
+	callbacks.erase(channel);
+}
+
+void CSoundHandler::soundFinishedCallback(int channel)
+{
+	boost::mutex::scoped_lock lockGuard(mutexCallbacks);
+
+	if(callbacks.count(channel) == 0)
+		return;
+
+	// store callbacks from container locally - SDL might reuse this channel for another sound
+	// but do actually execution in separate thread, to avoid potential deadlocks in case if callback requires locks of its own
+	auto callback = callbacks.at(channel);
+	callbacks.erase(channel);
+
+	if(!callback.empty())
+	{
+		GH.dispatchMainThread(
+			[callback]()
+			{
+				for(const auto & entry : callback)
+					entry();
+			}
+			);
+	}
+}
+
+void CSoundHandler::initCallback(int channel)
+{
+	boost::mutex::scoped_lock lockGuard(mutexCallbacks);
+	assert(callbacks.count(channel) == 0);
+	callbacks[channel] = {};
+}
+
+void CSoundHandler::initCallback(int channel, const std::function<void()> & function)
+{
+	boost::mutex::scoped_lock lockGuard(mutexCallbacks);
+	assert(callbacks.count(channel) == 0);
+	callbacks[channel].push_back(function);
+}
+
+int CSoundHandler::ambientGetRange() const
+{
+	return ambientConfig["range"].Integer();
+}
+
+void CSoundHandler::ambientUpdateChannels(std::map<AudioPath, int> soundsArg)
+{
+	boost::mutex::scoped_lock guard(mutex);
+
+	std::vector<AudioPath> stoppedSounds;
+	for(const auto & pair : ambientChannels)
+	{
+		const auto & soundId = pair.first;
+		const int channel = pair.second;
+
+		if(!vstd::contains(soundsArg, soundId))
+		{
+			ambientStopSound(soundId);
+			stoppedSounds.push_back(soundId);
+		}
+		else
+		{
+			int channelVolume = ambientDistToVolume(soundsArg[soundId]);
+			channelVolumes[channel] = channelVolume;
+			updateChannelVolume(channel);
+		}
+	}
+	for(const auto & soundId : stoppedSounds)
+	{
+		channelVolumes.erase(ambientChannels[soundId]);
+		ambientChannels.erase(soundId);
+	}
+
+	for(const auto & pair : soundsArg)
+	{
+		const auto & soundId = pair.first;
+		const int distance = pair.second;
+
+		if(!vstd::contains(ambientChannels, soundId))
+		{
+			int channel = playSound(soundId, -1);
+			int channelVolume = ambientDistToVolume(distance);
+			channelVolumes[channel] = channelVolume;
+
+			updateChannelVolume(channel);
+			ambientChannels[soundId] = channel;
+		}
+	}
+}
+
+void CSoundHandler::ambientStopAllChannels()
+{
+	boost::mutex::scoped_lock guard(mutex);
+
+	for(const auto & ch : ambientChannels)
+	{
+		ambientStopSound(ch.first);
+	}
+	channelVolumes.clear();
+	ambientChannels.clear();
+}
diff --color -urN vcmi-1.5.7/client/media/CSoundHandler.h vcmi/client/media/CSoundHandler.h
--- vcmi-1.5.7/client/media/CSoundHandler.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/client/media/CSoundHandler.h	2024-12-19 15:00:22.267121861 +0100
@@ -0,0 +1,80 @@
+/*
+ * CSoundHandler.h, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#pragma once
+
+#include "CAudioBase.h"
+#include "ISoundPlayer.h"
+
+#include "../lib/CConfigHandler.h"
+
+struct Mix_Chunk;
+
+class CSoundHandler final : public CAudioBase, public ISoundPlayer
+{
+private:
+	//update volume on configuration change
+	SettingsListener listener;
+	void onVolumeChange(const JsonNode & volumeNode);
+
+	using CachedChunk = std::pair<Mix_Chunk *, std::unique_ptr<ui8[]>>;
+	std::map<AudioPath, CachedChunk> soundChunks;
+	std::map<std::vector<ui8>, CachedChunk> soundChunksRaw;
+
+	Mix_Chunk * GetSoundChunk(const AudioPath & sound, bool cache);
+	Mix_Chunk * GetSoundChunk(std::pair<std::unique_ptr<ui8[]>, si64> & data, bool cache);
+
+	/// have entry for every currently active channel
+	/// vector will be empty if callback was not set
+	std::map<int, std::vector<std::function<void()>>> callbacks;
+
+	/// Protects access to callbacks member to avoid data races:
+	/// SDL calls sound finished callbacks from audio thread
+	boost::mutex mutexCallbacks;
+
+	int ambientDistToVolume(int distance) const;
+	void ambientStopSound(const AudioPath & soundId);
+	void updateChannelVolume(int channel);
+
+	const JsonNode ambientConfig;
+
+	boost::mutex mutex;
+	std::map<AudioPath, int> ambientChannels;
+	std::map<int, int> channelVolumes;
+	int volume = 0;
+
+	void initCallback(int channel, const std::function<void()> & function);
+	void initCallback(int channel);
+
+public:
+	CSoundHandler();
+	~CSoundHandler();
+
+	ui32 getVolume() const final;
+	void setVolume(ui32 percent) final;
+	void setChannelVolume(int channel, ui32 percent);
+
+	// Sounds
+	uint32_t getSoundDurationMilliseconds(const AudioPath & sound) final;
+	int playSound(soundBase::soundID soundID, int repeats = 0) final;
+	int playSound(const AudioPath & sound, int repeats = 0, bool cache = false) final;
+	int playSound(std::pair<std::unique_ptr<ui8[]>, si64> & data, int repeats = 0, bool cache = false) final;
+	int playSoundFromSet(std::vector<soundBase::soundID> & sound_vec) final;
+	void stopSound(int handler) final;
+	void pauseSound(int handler) final;
+	void resumeSound(int handler) final;
+
+	void setCallback(int channel, std::function<void()> function) final;
+	void resetCallback(int channel) final;
+	void soundFinishedCallback(int channel) final;
+
+	int ambientGetRange() const final;
+	void ambientUpdateChannels(std::map<AudioPath, int> currentSounds) final;
+	void ambientStopAllChannels() final;
+};
diff --color -urN vcmi-1.5.7/client/media/CVideoHandler.cpp vcmi/client/media/CVideoHandler.cpp
--- vcmi-1.5.7/client/media/CVideoHandler.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/client/media/CVideoHandler.cpp	2024-12-19 15:00:22.268121902 +0100
@@ -0,0 +1,669 @@
+/*
+ * CVideoHandler.cpp, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#include "StdInc.h"
+#include "CVideoHandler.h"
+
+#ifndef DISABLE_VIDEO
+
+#include "ISoundPlayer.h"
+
+#include "../CGameInfo.h"
+#include "../CMT.h"
+#include "../eventsSDL/InputHandler.h"
+#include "../gui/CGuiHandler.h"
+#include "../render/Canvas.h"
+#include "../render/IScreenHandler.h"
+#include "../renderSDL/SDL_Extensions.h"
+
+#include "../../lib/filesystem/CInputStream.h"
+#include "../../lib/filesystem/Filesystem.h"
+#include "../../lib/texts/CGeneralTextHandler.h"
+#include "../../lib/texts/Languages.h"
+
+#include <SDL_render.h>
+
+extern "C" {
+#include <libavformat/avformat.h>
+#include <libavcodec/avcodec.h>
+#include <libavutil/imgutils.h>
+#include <libavutil/opt.h>
+#include <libswscale/swscale.h>
+#include <libswresample/swresample.h>
+}
+
+// Define a set of functions to read data
+static int lodRead(void * opaque, uint8_t * buf, int size)
+{
+	auto * data = static_cast<CInputStream *>(opaque);
+	auto bytesRead = data->read(buf, size);
+	if(bytesRead == 0)
+		return AVERROR_EOF;
+
+	return bytesRead;
+}
+
+static si64 lodSeek(void * opaque, si64 pos, int whence)
+{
+	auto * data = static_cast<CInputStream *>(opaque);
+
+	if(whence & AVSEEK_SIZE)
+		return data->getSize();
+
+	return data->seek(pos);
+}
+
+[[noreturn]] static void throwFFmpegError(int errorCode)
+{
+	std::array<char, AV_ERROR_MAX_STRING_SIZE> errorMessage{};
+	av_strerror(errorCode, errorMessage.data(), errorMessage.size());
+
+	throw std::runtime_error(errorMessage.data());
+}
+
+static std::unique_ptr<CInputStream> findVideoData(const VideoPath & videoToOpen)
+{
+	if(CResourceHandler::get()->existsResource(videoToOpen))
+		return CResourceHandler::get()->load(videoToOpen);
+
+	auto highQualityVideoToOpenWithDir = videoToOpen.addPrefix("VIDEO/");
+	auto lowQualityVideo = videoToOpen.toType<EResType::VIDEO_LOW_QUALITY>();
+	auto lowQualityVideoWithDir = highQualityVideoToOpenWithDir.toType<EResType::VIDEO_LOW_QUALITY>();
+
+	if(CResourceHandler::get()->existsResource(highQualityVideoToOpenWithDir))
+		return CResourceHandler::get()->load(highQualityVideoToOpenWithDir);
+
+	if(CResourceHandler::get()->existsResource(lowQualityVideo))
+		return CResourceHandler::get()->load(lowQualityVideo);
+
+	if(CResourceHandler::get()->existsResource(lowQualityVideoWithDir))
+		return CResourceHandler::get()->load(lowQualityVideoWithDir);
+
+	return nullptr;
+}
+
+bool FFMpegStream::openInput(const VideoPath & videoToOpen)
+{
+	input = findVideoData(videoToOpen);
+
+	return input != nullptr;
+}
+
+void FFMpegStream::openContext()
+{
+	static const int BUFFER_SIZE = 4096;
+	input->seek(0);
+
+	auto * buffer = static_cast<unsigned char *>(av_malloc(BUFFER_SIZE)); // will be freed by ffmpeg
+	context = avio_alloc_context(buffer, BUFFER_SIZE, 0, input.get(), lodRead, nullptr, lodSeek);
+
+	formatContext = avformat_alloc_context();
+	formatContext->pb = context;
+	// filename is not needed - file was already open and stored in this->data;
+	int avfopen = avformat_open_input(&formatContext, "dummyFilename", nullptr, nullptr);
+
+	if(avfopen != 0)
+		throwFFmpegError(avfopen);
+
+	// Retrieve stream information
+	int findStreamInfo = avformat_find_stream_info(formatContext, nullptr);
+
+	if(avfopen < 0)
+		throwFFmpegError(findStreamInfo);
+}
+
+void FFMpegStream::openCodec(int desiredStreamIndex)
+{
+	streamIndex = desiredStreamIndex;
+
+	// Find the decoder for the stream
+	codec = avcodec_find_decoder(formatContext->streams[streamIndex]->codecpar->codec_id);
+
+	if(codec == nullptr)
+		throw std::runtime_error("Unsupported codec");
+
+	codecContext = avcodec_alloc_context3(codec);
+	if(codecContext == nullptr)
+		throw std::runtime_error("Failed to create codec context");
+
+	// Get a pointer to the codec context for the video stream
+	int ret = avcodec_parameters_to_context(codecContext, formatContext->streams[streamIndex]->codecpar);
+	if(ret < 0)
+	{
+		//We cannot get codec from parameters
+		avcodec_free_context(&codecContext);
+		throwFFmpegError(ret);
+	}
+
+	// Open codec
+	ret = avcodec_open2(codecContext, codec, nullptr);
+	if(ret < 0)
+	{
+		// Could not open codec
+		codec = nullptr;
+		throwFFmpegError(ret);
+	}
+
+	// Allocate video frame
+	frame = av_frame_alloc();
+}
+
+const AVCodecParameters * FFMpegStream::getCodecParameters() const
+{
+	return formatContext->streams[streamIndex]->codecpar;
+}
+
+const AVCodecContext * FFMpegStream::getCodecContext() const
+{
+	return codecContext;
+}
+
+const AVFrame * FFMpegStream::getCurrentFrame() const
+{
+	return frame;
+}
+
+void CVideoInstance::openVideo()
+{
+	openContext();
+	openCodec(findVideoStream());
+}
+
+void CVideoInstance::prepareOutput(float scaleFactor, bool useTextureOutput)
+{
+	//setup scaling
+	dimensions = Point(getCodecContext()->width * scaleFactor, getCodecContext()->height * scaleFactor) * GH.screenHandler().getScalingFactor();
+
+	// Allocate a place to put our YUV image on that screen
+	if (useTextureOutput)
+	{
+		std::array potentialFormats = {
+			AV_PIX_FMT_YUV420P, // -> SDL_PIXELFORMAT_IYUV - most of H3 videos use YUV format, so it is preferred to save some space & conversion time
+			AV_PIX_FMT_RGB32,   // -> SDL_PIXELFORMAT_ARGB8888 - some .smk videos actually use palette, so RGB > YUV. This is also our screen texture format
+			AV_PIX_FMT_NONE
+		};
+
+		auto preferredFormat = avcodec_find_best_pix_fmt_of_list(potentialFormats.data(), getCodecContext()->pix_fmt, false, nullptr);
+
+		if (preferredFormat == AV_PIX_FMT_YUV420P)
+			textureYUV = SDL_CreateTexture( mainRenderer, SDL_PIXELFORMAT_IYUV, SDL_TEXTUREACCESS_STREAMING, dimensions.x, dimensions.y);
+		else
+			textureRGB = SDL_CreateTexture( mainRenderer, SDL_PIXELFORMAT_ARGB8888, SDL_TEXTUREACCESS_STREAMING, dimensions.x, dimensions.y);
+		sws = sws_getContext(getCodecContext()->width, getCodecContext()->height, getCodecContext()->pix_fmt,
+							dimensions.x, dimensions.y, preferredFormat,
+							 SWS_BICUBIC, nullptr, nullptr, nullptr);
+	}
+	else
+	{
+		surface = CSDL_Ext::newSurface(dimensions);
+		sws = sws_getContext(getCodecContext()->width, getCodecContext()->height, getCodecContext()->pix_fmt,
+							 dimensions.x, dimensions.y, AV_PIX_FMT_RGB32,
+							 SWS_BICUBIC, nullptr, nullptr, nullptr);
+	}
+
+	if (sws == nullptr)
+		throw std::runtime_error("Failed to create sws");
+}
+
+void FFMpegStream::decodeNextFrame()
+{
+	int rc = avcodec_receive_frame(codecContext, frame);
+
+	// frame extracted - data that was sent to codecContext before was sufficient
+	if (rc == 0)
+		return;
+
+	// returning AVERROR(EAGAIN) is legal - this indicates that codec requires more data from input stream to decode next frame
+	if(rc != AVERROR(EAGAIN))
+		throwFFmpegError(rc);
+
+	for(;;)
+	{
+		AVPacket packet;
+
+		// codecContext does not have enough input data - read next packet from input stream
+		int ret = av_read_frame(formatContext, &packet);
+		if(ret < 0)
+		{
+			if(ret == AVERROR_EOF)
+			{
+				av_packet_unref(&packet);
+				av_frame_free(&frame);
+				frame = nullptr;
+				return;
+			}
+			throwFFmpegError(ret);
+		}
+
+		// Is this a packet from the stream that needs decoding?
+		if(packet.stream_index == streamIndex)
+		{
+			// Decode read packet
+			// Note: this method may return AVERROR(EAGAIN). However this should never happen with ffmpeg API
+			// since there is guaranteed call to avcodec_receive_frame and ffmpeg API promises that *both* of these methods will never return AVERROR(EAGAIN).
+			int rc = avcodec_send_packet(codecContext, &packet);
+			if(rc < 0)
+				throwFFmpegError(rc);
+
+			rc = avcodec_receive_frame(codecContext, frame);
+			if(rc == AVERROR(EAGAIN))
+			{
+				// still need more data - read next packet
+				av_packet_unref(&packet);
+				continue;
+			}
+			else if(rc < 0)
+			{
+				throwFFmpegError(rc);
+			}
+			else
+			{
+				// read succesful. Exit the loop
+				av_packet_unref(&packet);
+				return;
+			}
+		}
+		av_packet_unref(&packet);
+	}
+}
+
+bool CVideoInstance::loadNextFrame()
+{
+	decodeNextFrame();
+	const AVFrame * frame = getCurrentFrame();
+
+	if(!frame)
+		return false;
+
+	uint8_t * data[4] = {};
+	int linesize[4] = {};
+
+	if(textureYUV)
+	{
+		av_image_alloc(data, linesize, dimensions.x, dimensions.y, AV_PIX_FMT_YUV420P, 1);
+		sws_scale(sws, frame->data, frame->linesize, 0, getCodecContext()->height, data, linesize);
+		SDL_UpdateYUVTexture(textureYUV, nullptr, data[0], linesize[0], data[1], linesize[1], data[2], linesize[2]);
+		av_freep(&data[0]);
+	}
+	if(textureRGB)
+	{
+		av_image_alloc(data, linesize, dimensions.x, dimensions.y, AV_PIX_FMT_RGB32, 1);
+		sws_scale(sws, frame->data, frame->linesize, 0, getCodecContext()->height, data, linesize);
+		SDL_UpdateTexture(textureRGB, nullptr, data[0], linesize[0]);
+		av_freep(&data[0]);
+	}
+	if(surface)
+	{
+		// Avoid buffer overflow caused by sws_scale():
+		// http://trac.ffmpeg.org/ticket/9254
+
+		size_t pic_bytes = surface->pitch * surface->h;
+		size_t ffmped_pad = 1024; /* a few bytes of overflow will go here */
+		void * for_sws = av_malloc(pic_bytes + ffmped_pad);
+		data[0] = (ui8 *)for_sws;
+		linesize[0] = surface->pitch;
+
+		sws_scale(sws, frame->data, frame->linesize, 0, getCodecContext()->height, data, linesize);
+		memcpy(surface->pixels, for_sws, pic_bytes);
+		av_free(for_sws);
+	}
+	return true;
+}
+
+
+double CVideoInstance::timeStamp()
+{
+	return getCurrentFrameEndTime();
+}
+
+bool CVideoInstance::videoEnded()
+{
+	return getCurrentFrame() == nullptr;
+}
+
+CVideoInstance::~CVideoInstance()
+{
+	sws_freeContext(sws);
+	SDL_DestroyTexture(textureYUV);
+	SDL_DestroyTexture(textureRGB);
+	SDL_FreeSurface(surface);
+}
+
+FFMpegStream::~FFMpegStream()
+{
+	av_frame_free(&frame);
+
+#if (LIBAVCODEC_VERSION_MAJOR < 61 )
+	// deprecated, apparently no longer necessary - avcodec_free_context should suffice
+	avcodec_close(codecContext);
+#endif
+
+	avcodec_free_context(&codecContext);
+
+	avformat_close_input(&formatContext);
+	av_free(context);
+}
+
+Point CVideoInstance::size()
+{
+	return dimensions / GH.screenHandler().getScalingFactor();
+}
+
+void CVideoInstance::show(const Point & position, Canvas & canvas)
+{
+	if(sws == nullptr)
+		throw std::runtime_error("No video to show!");
+
+	CSDL_Ext::blitSurface(surface, canvas.getInternalSurface(), position * GH.screenHandler().getScalingFactor());
+}
+
+double FFMpegStream::getCurrentFrameEndTime() const
+{
+#if(LIBAVUTIL_VERSION_MAJOR < 58)
+	auto packet_duration = frame->pkt_duration;
+#else
+	auto packet_duration = frame->duration;
+#endif
+	return (frame->pts + packet_duration) * av_q2d(formatContext->streams[streamIndex]->time_base);
+}
+
+double FFMpegStream::getCurrentFrameDuration() const
+{
+#if(LIBAVUTIL_VERSION_MAJOR < 58)
+	auto packet_duration = frame->pkt_duration;
+#else
+	auto packet_duration = frame->duration;
+#endif
+	return packet_duration * av_q2d(formatContext->streams[streamIndex]->time_base);
+}
+
+void CVideoInstance::tick(uint32_t msPassed)
+{
+	if(sws == nullptr)
+		throw std::runtime_error("No video to show!");
+
+	if(videoEnded())
+		throw std::runtime_error("Video already ended!");
+
+	if(startTime == std::chrono::steady_clock::time_point())
+		startTime = std::chrono::steady_clock::now();
+
+	auto nowTime = std::chrono::steady_clock::now();
+	double difference = std::chrono::duration_cast<std::chrono::milliseconds>(nowTime - startTime).count() / 1000.0;
+
+	int frameskipCounter = 0;
+	while(!videoEnded() && difference >= getCurrentFrameEndTime() + getCurrentFrameDuration() && frameskipCounter < MAX_FRAMESKIP) // Frameskip
+	{
+		decodeNextFrame();
+		frameskipCounter++;
+	}
+	if(!videoEnded() && difference >= getCurrentFrameEndTime())
+		loadNextFrame();
+}
+
+
+void CVideoInstance::activate()
+{
+	if(deactivationStartTime != std::chrono::steady_clock::time_point())
+	{
+		auto pauseDuration = std::chrono::steady_clock::now() - deactivationStartTime;
+		startTime += pauseDuration;
+		deactivationStartTime = std::chrono::steady_clock::time_point();
+	}
+}
+
+void CVideoInstance::deactivate()
+{
+	deactivationStartTime = std::chrono::steady_clock::now();
+}
+
+struct FFMpegFormatDescription
+{
+	uint8_t sampleSizeBytes;
+	uint8_t wavFormatID;
+	bool isPlanar;
+};
+
+static FFMpegFormatDescription getAudioFormatProperties(int audioFormat)
+{
+	switch (audioFormat)
+	{
+		case AV_SAMPLE_FMT_U8:   return { 1, 1, false};
+		case AV_SAMPLE_FMT_U8P:  return { 1, 1, true};
+		case AV_SAMPLE_FMT_S16:  return { 2, 1, false};
+		case AV_SAMPLE_FMT_S16P: return { 2, 1, true};
+		case AV_SAMPLE_FMT_S32:  return { 4, 1, false};
+		case AV_SAMPLE_FMT_S32P: return { 4, 1, true};
+		case AV_SAMPLE_FMT_S64:  return { 8, 1, false};
+		case AV_SAMPLE_FMT_S64P: return { 8, 1, true};
+		case AV_SAMPLE_FMT_FLT:  return { 4, 3, false};
+		case AV_SAMPLE_FMT_FLTP: return { 4, 3, true};
+		case AV_SAMPLE_FMT_DBL:  return { 8, 3, false};
+		case AV_SAMPLE_FMT_DBLP: return { 8, 3, true};
+	}
+	throw std::runtime_error("Invalid audio format");
+}
+
+int FFMpegStream::findAudioStream() const
+{
+	std::vector<int> audioStreamIndices;
+
+	for(int i = 0; i < formatContext->nb_streams; i++)
+		if(formatContext->streams[i]->codecpar->codec_type == AVMEDIA_TYPE_AUDIO)
+			audioStreamIndices.push_back(i);
+
+	if (audioStreamIndices.empty())
+		return -1;
+
+	if (audioStreamIndices.size() == 1)
+		return audioStreamIndices.front();
+
+	// multiple audio streams - try to pick best one based on language settings
+	std::map<int, std::string> streamToLanguage;
+
+	// Approach 1 - check if stream has language set in metadata
+	for (auto const & index : audioStreamIndices)
+	{
+		const AVDictionaryEntry *e = av_dict_get(formatContext->streams[index]->metadata, "language", nullptr, 0);
+		if (e)
+			streamToLanguage[index]	= e->value;
+	}
+
+	// Approach 2 - no metadata found. This may be video from Chronicles which have predefined (presumably hardcoded) list of languages
+	if (streamToLanguage.empty())
+	{
+		if (audioStreamIndices.size() == 2)
+		{
+			streamToLanguage[audioStreamIndices[0]] = Languages::getLanguageOptions(Languages::ELanguages::ENGLISH).tagISO2;
+			streamToLanguage[audioStreamIndices[1]] = Languages::getLanguageOptions(Languages::ELanguages::GERMAN).tagISO2;
+		}
+
+		if (audioStreamIndices.size() == 5)
+		{
+			streamToLanguage[audioStreamIndices[0]] = Languages::getLanguageOptions(Languages::ELanguages::ENGLISH).tagISO2;
+			streamToLanguage[audioStreamIndices[1]] = Languages::getLanguageOptions(Languages::ELanguages::FRENCH).tagISO2;
+			streamToLanguage[audioStreamIndices[2]] = Languages::getLanguageOptions(Languages::ELanguages::GERMAN).tagISO2;
+			streamToLanguage[audioStreamIndices[3]] = Languages::getLanguageOptions(Languages::ELanguages::ITALIAN).tagISO2;
+			streamToLanguage[audioStreamIndices[4]] = Languages::getLanguageOptions(Languages::ELanguages::SPANISH).tagISO2;
+		}
+	}
+
+	std::string preferredLanguageName = CGI->generaltexth->getPreferredLanguage();
+	std::string preferredTag = Languages::getLanguageOptions(preferredLanguageName).tagISO2;
+
+	for (auto const & entry : streamToLanguage)
+		if (entry.second == preferredTag)
+			return entry.first;
+
+	return audioStreamIndices.front();
+}
+
+int FFMpegStream::findVideoStream() const
+{
+	for(int i = 0; i < formatContext->nb_streams; i++)
+		if(formatContext->streams[i]->codecpar->codec_type == AVMEDIA_TYPE_VIDEO)
+			return i;
+
+	return -1;
+}
+
+std::pair<std::unique_ptr<ui8 []>, si64> CAudioInstance::extractAudio(const VideoPath & videoToOpen)
+{
+	if (!openInput(videoToOpen))
+		return { nullptr, 0};
+	openContext();
+
+	int audioStreamIndex = findAudioStream();
+	if (audioStreamIndex == -1)
+		return { nullptr, 0};
+	openCodec(audioStreamIndex);
+
+	const auto * codecpar = getCodecParameters();
+
+	std::vector<ui8> samples;
+
+	auto formatProperties = getAudioFormatProperties(codecpar->format);
+#if(LIBAVUTIL_VERSION_MAJOR < 58)
+	int numChannels = codecpar->channels;
+#else
+	int numChannels = codecpar->ch_layout.nb_channels;
+#endif
+
+	samples.reserve(44100 * 5); // arbitrary 5-second buffer to reduce reallocations
+
+	if (formatProperties.isPlanar && numChannels > 1)
+	{
+		// Format is 'planar', which is not supported by wav / SDL
+		// Use swresample part of ffmpeg to deplanarize audio into format supported by wav / SDL
+
+		auto sourceFormat = static_cast<AVSampleFormat>(codecpar->format);
+		auto targetFormat = av_get_alt_sample_fmt(sourceFormat, false);
+
+		SwrContext * swr_ctx = swr_alloc();
+
+#if (LIBAVUTIL_VERSION_MAJOR < 58)
+		av_opt_set_channel_layout(swr_ctx, "in_chlayout", codecpar->channel_layout, 0);
+		av_opt_set_channel_layout(swr_ctx, "out_chlayout", codecpar->channel_layout, 0);
+#else
+		av_opt_set_chlayout(swr_ctx, "in_chlayout", &codecpar->ch_layout, 0);
+		av_opt_set_chlayout(swr_ctx, "out_chlayout", &codecpar->ch_layout, 0);
+#endif
+		av_opt_set_int(swr_ctx, "in_sample_rate", codecpar->sample_rate, 0);
+		av_opt_set_sample_fmt(swr_ctx, "in_sample_fmt", sourceFormat, 0);
+		av_opt_set_int(swr_ctx, "out_sample_rate", codecpar->sample_rate, 0);
+		av_opt_set_sample_fmt(swr_ctx, "out_sample_fmt", targetFormat, 0);
+
+		int initResult = swr_init(swr_ctx);
+		if (initResult < 0)
+			throwFFmpegError(initResult);
+
+		std::vector<uint8_t> frameSamplesBuffer;
+		for (;;)
+		{
+			decodeNextFrame();
+			const AVFrame * frame = getCurrentFrame();
+
+			if (!frame)
+				break;
+
+			size_t samplesToRead = frame->nb_samples * numChannels;
+			size_t bytesToRead = samplesToRead * formatProperties.sampleSizeBytes;
+			frameSamplesBuffer.resize(std::max(frameSamplesBuffer.size(), bytesToRead));
+			uint8_t * frameSamplesPtr = frameSamplesBuffer.data();
+
+			int result = swr_convert(swr_ctx, &frameSamplesPtr, frame->nb_samples, const_cast<const uint8_t **>(frame->data), frame->nb_samples);
+
+			if (result < 0)
+				throwFFmpegError(result);
+
+			size_t samplesToCopy = result * numChannels;
+			size_t bytesToCopy = samplesToCopy * formatProperties.sampleSizeBytes;
+			samples.insert(samples.end(), frameSamplesBuffer.begin(), frameSamplesBuffer.begin() + bytesToCopy);
+		}
+		swr_free(&swr_ctx);
+	}
+	else
+	{
+		for (;;)
+		{
+			decodeNextFrame();
+			const AVFrame * frame = getCurrentFrame();
+
+			if (!frame)
+				break;
+
+			size_t samplesToRead = frame->nb_samples * numChannels;
+			size_t bytesToRead = samplesToRead * formatProperties.sampleSizeBytes;
+			samples.insert(samples.end(), frame->data[0], frame->data[0] + bytesToRead);
+		}
+	}
+
+	struct WavHeader {
+		ui8 RIFF[4] = {'R', 'I', 'F', 'F'};
+		ui32 ChunkSize;
+		ui8 WAVE[4] = {'W', 'A', 'V', 'E'};
+		ui8 fmt[4] = {'f', 'm', 't', ' '};
+		ui32 Subchunk1Size = 16;
+		ui16 AudioFormat = 1;
+		ui16 NumOfChan = 2;
+		ui32 SamplesPerSec = 22050;
+		ui32 bytesPerSec = 22050 * 2;
+		ui16 blockAlign = 1;
+		ui16 bitsPerSample = 32;
+		ui8 Subchunk2ID[4] = {'d', 'a', 't', 'a'};
+		ui32 Subchunk2Size;
+	};
+
+	WavHeader wav;
+	wav.ChunkSize = samples.size() + sizeof(WavHeader) - 8;
+	wav.AudioFormat = formatProperties.wavFormatID; // 1 = PCM, 3 = IEEE float
+	wav.NumOfChan = numChannels;
+	wav.SamplesPerSec = codecpar->sample_rate;
+	wav.bytesPerSec = codecpar->sample_rate * formatProperties.sampleSizeBytes;
+	wav.bitsPerSample = formatProperties.sampleSizeBytes * 8;
+	wav.Subchunk2Size = samples.size() + sizeof(WavHeader) - 44;
+	auto * wavPtr = reinterpret_cast<ui8*>(&wav);
+
+	auto dat = std::make_pair(std::make_unique<ui8[]>(samples.size() + sizeof(WavHeader)), samples.size() + sizeof(WavHeader));
+	std::copy(wavPtr, wavPtr + sizeof(WavHeader), dat.first.get());
+	std::copy(samples.begin(), samples.end(), dat.first.get() + sizeof(WavHeader));
+
+	return dat;
+}
+
+std::unique_ptr<IVideoInstance> CVideoPlayer::open(const VideoPath & name, float scaleFactor)
+{
+	auto result = std::make_unique<CVideoInstance>();
+
+	if (!result->openInput(name))
+		return nullptr;
+
+	result->openVideo();
+	result->prepareOutput(scaleFactor, false);
+	result->loadNextFrame(); // prepare 1st frame
+
+	return result;
+}
+
+std::pair<std::unique_ptr<ui8[]>, si64> CVideoPlayer::getAudio(const VideoPath & videoToOpen)
+{
+	AudioPath audioPath = videoToOpen.toType<EResType::SOUND>();
+	AudioPath audioPathVideoDir = audioPath.addPrefix("VIDEO/");
+
+	if(CResourceHandler::get()->existsResource(audioPath))
+		return CResourceHandler::get()->load(audioPath)->readAll();
+
+	if(CResourceHandler::get()->existsResource(audioPathVideoDir))
+		return CResourceHandler::get()->load(audioPathVideoDir)->readAll();
+
+	CAudioInstance audio;
+	return audio.extractAudio(videoToOpen);
+}
+
+#endif
diff --color -urN vcmi-1.5.7/client/media/CVideoHandler.h vcmi/client/media/CVideoHandler.h
--- vcmi-1.5.7/client/media/CVideoHandler.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/client/media/CVideoHandler.h	2024-12-19 15:00:22.269121944 +0100
@@ -0,0 +1,113 @@
+/*
+ * CVideoHandler.h, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#pragma once
+
+#ifndef DISABLE_VIDEO
+
+#include "../lib/Point.h"
+#include "IVideoPlayer.h"
+
+struct SDL_Surface;
+struct SDL_Texture;
+struct AVFormatContext;
+struct AVCodecContext;
+struct AVCodecParameters;
+struct AVCodec;
+struct AVFrame;
+struct AVIOContext;
+
+VCMI_LIB_NAMESPACE_BEGIN
+class CInputStream;
+class Point;
+VCMI_LIB_NAMESPACE_END
+
+class FFMpegStream : boost::noncopyable
+{
+	std::unique_ptr<CInputStream> input;
+
+	AVIOContext * context = nullptr;
+	AVFormatContext * formatContext = nullptr;
+
+	const AVCodec * codec = nullptr;
+	AVCodecContext * codecContext = nullptr;
+	int streamIndex = -1;
+
+	AVFrame * frame = nullptr;
+
+protected:
+	void openContext();
+	void openCodec(int streamIndex);
+
+	int findVideoStream() const;
+	int findAudioStream() const;
+
+	const AVCodecParameters * getCodecParameters() const;
+	const AVCodecContext * getCodecContext() const;
+	void decodeNextFrame();
+	const AVFrame * getCurrentFrame() const;
+	double getCurrentFrameEndTime() const;
+	double getCurrentFrameDuration() const;
+
+public:
+	virtual ~FFMpegStream();
+
+	bool openInput(const VideoPath & fname);
+};
+
+class CAudioInstance final : public FFMpegStream
+{
+public:
+	std::pair<std::unique_ptr<ui8[]>, si64> extractAudio(const VideoPath & videoToOpen);
+};
+
+class CVideoInstance final : public IVideoInstance, public FFMpegStream
+{
+	friend class CVideoPlayer;
+
+	struct SwsContext * sws = nullptr;
+	SDL_Texture * textureRGB = nullptr;
+	SDL_Texture * textureYUV = nullptr;
+	SDL_Surface * surface = nullptr;
+	Point dimensions;
+
+	/// video playback start time point
+	std::chrono::steady_clock::time_point startTime;
+	std::chrono::steady_clock::time_point deactivationStartTime;
+
+	void prepareOutput(float scaleFactor, bool useTextureOutput);
+	
+	const int MAX_FRAMESKIP = 5;
+
+public:
+	~CVideoInstance();
+
+	void openVideo();
+	bool loadNextFrame();
+
+	double timeStamp() final;
+	bool videoEnded() final;
+	Point size() final;
+
+	void show(const Point & position, Canvas & canvas) final;
+	void tick(uint32_t msPassed) final;
+	void activate() final;
+	void deactivate() final;
+};
+
+class CVideoPlayer final : public IVideoPlayer
+{
+	void openVideoFile(CVideoInstance & state, const VideoPath & fname);
+
+public:
+	std::unique_ptr<IVideoInstance> open(const VideoPath & name, float scaleFactor) final;
+	std::pair<std::unique_ptr<ui8[]>, si64> getAudio(const VideoPath & videoToOpen) final;
+};
+
+#endif
diff --color -urN vcmi-1.5.7/client/media/IMusicPlayer.h vcmi/client/media/IMusicPlayer.h
--- vcmi-1.5.7/client/media/IMusicPlayer.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/client/media/IMusicPlayer.h	2024-12-19 15:00:22.269121944 +0100
@@ -0,0 +1,33 @@
+/*
+ * IMusicPlayer.h, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#pragma once
+
+#include "../lib/filesystem/ResourcePath.h"
+
+class IMusicPlayer
+{
+public:
+	virtual ~IMusicPlayer() = default;
+
+	virtual void loadTerrainMusicThemes() = 0;
+	virtual void setVolume(ui32 percent) = 0;
+	virtual ui32 getVolume() const = 0;
+
+	virtual void musicFinishedCallback() = 0;
+
+	/// play track by URI, if loop = true music will be looped
+	virtual void playMusic(const AudioPath & musicURI, bool loop, bool fromStart) = 0;
+	/// play random track from this set
+	virtual void playMusicFromSet(const std::string & musicSet, bool loop, bool fromStart) = 0;
+	/// play random track from set (musicSet, entryID)
+	virtual void playMusicFromSet(const std::string & musicSet, const std::string & entryID, bool loop, bool fromStart) = 0;
+	/// stops currently playing music by fading out it over fade_ms and starts next scheduled track, if any
+	virtual void stopMusic(int fade_ms = 1000) = 0;
+};
diff --color -urN vcmi-1.5.7/client/media/ISoundPlayer.h vcmi/client/media/ISoundPlayer.h
--- vcmi-1.5.7/client/media/ISoundPlayer.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/client/media/ISoundPlayer.h	2024-12-19 15:00:22.269121944 +0100
@@ -0,0 +1,37 @@
+/*
+ * ISoundPlayer.h, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#pragma once
+
+#include "../lib/CSoundBase.h"
+#include "../lib/filesystem/ResourcePath.h"
+
+class ISoundPlayer
+{
+public:
+	virtual ~ISoundPlayer() = default;
+
+	virtual int playSound(soundBase::soundID soundID, int repeats = 0) = 0;
+	virtual int playSound(const AudioPath & sound, int repeats = 0, bool cache = false) = 0;
+	virtual int playSound(std::pair<std::unique_ptr<ui8[]>, si64> & data, int repeats = 0, bool cache = false) = 0;
+	virtual int playSoundFromSet(std::vector<soundBase::soundID> & sound_vec) = 0;
+	virtual void stopSound(int handler) = 0;
+	virtual void pauseSound(int handler) = 0;
+	virtual void resumeSound(int handler) = 0;
+
+	virtual ui32 getVolume() const = 0;
+	virtual void setVolume(ui32 percent) = 0;
+	virtual uint32_t getSoundDurationMilliseconds(const AudioPath & sound) = 0;
+	virtual void setCallback(int channel, std::function<void()> function) = 0;
+	virtual void resetCallback(int channel) = 0;
+	virtual void soundFinishedCallback(int channel) = 0;
+	virtual void ambientUpdateChannels(std::map<AudioPath, int> currentSounds) = 0;
+	virtual void ambientStopAllChannels() = 0;
+	virtual int ambientGetRange() const = 0;
+};
diff --color -urN vcmi-1.5.7/client/media/IVideoPlayer.h vcmi/client/media/IVideoPlayer.h
--- vcmi-1.5.7/client/media/IVideoPlayer.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/client/media/IVideoPlayer.h	2024-12-19 15:00:22.270121985 +0100
@@ -0,0 +1,55 @@
+/*
+ * IVideoPlayer.h, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#pragma once
+
+#include "../lib/filesystem/ResourcePath.h"
+
+class Canvas;
+
+VCMI_LIB_NAMESPACE_BEGIN
+class Point;
+VCMI_LIB_NAMESPACE_END
+
+class IVideoInstance
+{
+public:
+	/// Returns current video timestamp
+	virtual double timeStamp() = 0;
+
+	/// Returns true if video playback is over
+	virtual bool videoEnded() = 0;
+
+	/// Returns dimensions of the video
+	virtual Point size() = 0;
+
+	/// Displays current frame at specified position
+	virtual void show(const Point & position, Canvas & canvas) = 0;
+
+	/// Advances video playback by specified duration
+	virtual void tick(uint32_t msPassed) = 0;
+
+	/// activate or deactivate video
+	virtual void activate() = 0;
+	virtual void deactivate() = 0;
+
+	virtual ~IVideoInstance() = default;
+};
+
+class IVideoPlayer : boost::noncopyable
+{
+public:
+	/// Load video from specified path. Returns nullptr on failure
+	virtual std::unique_ptr<IVideoInstance> open(const VideoPath & name, float scaleFactor) = 0;
+
+	/// Extracts audio data from provided video in wav format
+	virtual std::pair<std::unique_ptr<ui8[]>, si64> getAudio(const VideoPath & videoToOpen) = 0;
+
+	virtual ~IVideoPlayer() = default;
+};
diff --color -urN vcmi-1.5.7/client/NetPacksClient.cpp vcmi/client/NetPacksClient.cpp
--- vcmi-1.5.7/client/NetPacksClient.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/NetPacksClient.cpp	2024-12-19 15:00:22.240120745 +0100
@@ -14,6 +14,7 @@
 #include "CPlayerInterface.h"
 #include "CGameInfo.h"
 #include "windows/GUIClasses.h"
+#include "windows/CCastleInterface.h"
 #include "mapView/mapHandler.h"
 #include "adventureMap/AdventureMapInterface.h"
 #include "adventureMap/CInGameConsole.h"
@@ -29,10 +30,8 @@
 #include "../CCallback.h"
 #include "../lib/filesystem/Filesystem.h"
 #include "../lib/filesystem/FileInfo.h"
-#include "../lib/serializer/BinarySerializer.h"
 #include "../lib/serializer/Connection.h"
-#include "../lib/CGeneralTextHandler.h"
-#include "../lib/CHeroHandler.h"
+#include "../lib/texts/CGeneralTextHandler.h"
 #include "../lib/VCMI_Lib.h"
 #include "../lib/mapping/CMap.h"
 #include "../lib/VCMIDirs.h"
@@ -102,14 +101,14 @@
 {
 	assert(cl.gameState()->getBattle(battleID));
 
-	if (!cl.gameState()->getBattle(battleID))
+	if(!cl.gameState()->getBattle(battleID))
 	{
 		logGlobal->error("Attempt to call battle interface without ongoing battle!");
 		return;
 	}
 
-	callOnlyThatBattleInterface(cl, cl.gameState()->getBattle(battleID)->sides[0].color, ptr, std::forward<Args2>(args)...);
-	callOnlyThatBattleInterface(cl, cl.gameState()->getBattle(battleID)->sides[1].color, ptr, std::forward<Args2>(args)...);
+	callOnlyThatBattleInterface(cl, cl.gameState()->getBattle(battleID)->getSide(BattleSide::ATTACKER).color, ptr, std::forward<Args2>(args)...);
+	callOnlyThatBattleInterface(cl, cl.gameState()->getBattle(battleID)->getSide(BattleSide::DEFENDER).color, ptr, std::forward<Args2>(args)...);
 	if(settings["session"]["spectate"].Bool() && !settings["session"]["spectate-skip-battle"].Bool() && LOCPLINT->battleInt)
 	{
 		callOnlyThatBattleInterface(cl, PlayerColor::SPECTATOR, ptr, std::forward<Args2>(args)...);
@@ -118,7 +117,7 @@
 
 void ApplyClientNetPackVisitor::visitSetResources(SetResources & pack)
 {
-	//todo: inform on actual resource set transfered
+	//todo: inform on actual resource set transferred
 	callInterfaceIfPresent(cl, pack.player, &IGameEventsReceiver::receivedResource);
 }
 
@@ -162,17 +161,23 @@
 	if(settings["session"]["headless"].Bool())
 		return;
 
-	for (auto window : GH.windows().findWindows<BattleWindow>())
+	for(auto window : GH.windows().findWindows<BattleWindow>())
 		window->heroManaPointsChanged(h);
 }
 
 void ApplyClientNetPackVisitor::visitSetMovePoints(SetMovePoints & pack)
 {
 	const CGHeroInstance *h = cl.getHero(pack.hid);
-	cl.invalidatePaths();
+	cl.updatePath(h);
 	callInterfaceIfPresent(cl, h->tempOwner, &IGameEventsReceiver::heroMovePointsChanged, h);
 }
 
+void ApplyClientNetPackVisitor::visitSetResearchedSpells(SetResearchedSpells & pack)
+{
+	for(const auto & win : GH.windows().findWindows<CMageGuildScreen>())
+		win->updateSpells(pack.tid);
+}
+
 void ApplyClientNetPackVisitor::visitFoWChange(FoWChange & pack)
 {
 	for(auto &i : cl.playerint)
@@ -230,7 +235,7 @@
 void ApplyClientNetPackVisitor::visitEraseStack(EraseStack & pack)
 {
 	dispatchGarrisonChange(cl, pack.army, ObjectInstanceID());
-	cl.invalidatePaths(); //it is possible to remove last non-native unit for current terrain and lose movement penalty
+	cl.updatePath(pack.army); //it is possible to remove last non-native unit for current terrain and lose movement penalty
 }
 
 void ApplyClientNetPackVisitor::visitSwapStacks(SwapStacks & pack)
@@ -238,15 +243,14 @@
 	dispatchGarrisonChange(cl, pack.srcArmy, pack.dstArmy);
 
 	if(pack.srcArmy != pack.dstArmy)
-		cl.invalidatePaths(); // adding/removing units may change terrain type penalty based on creature native terrains
+		cl.updatePath(pack.dstArmy); // adding/removing units may change terrain type penalty based on creature native terrains
 }
 
 void ApplyClientNetPackVisitor::visitInsertNewStack(InsertNewStack & pack)
 {
 	dispatchGarrisonChange(cl, pack.army, ObjectInstanceID());
 
-	if(gs.getHero(pack.army))
-		cl.invalidatePaths(); // adding/removing units may change terrain type penalty based on creature native terrains
+	cl.updatePath(pack.army); // adding/removing units may change terrain type penalty based on creature native terrains
 }
 
 void ApplyClientNetPackVisitor::visitRebalanceStacks(RebalanceStacks & pack)
@@ -254,7 +258,10 @@
 	dispatchGarrisonChange(cl, pack.srcArmy, pack.dstArmy);
 
 	if(pack.srcArmy != pack.dstArmy)
-		cl.invalidatePaths(); // adding/removing units may change terrain type penalty based on creature native terrains
+	{
+		cl.updatePath(pack.srcArmy); // adding/removing units may change terrain type penalty based on creature native terrains
+		cl.updatePath(pack.dstArmy);
+	}
 }
 
 void ApplyClientNetPackVisitor::visitBulkRebalanceStacks(BulkRebalanceStacks & pack)
@@ -267,7 +274,10 @@
 		dispatchGarrisonChange(cl, pack.moves[0].srcArmy, destArmy);
 
 		if(pack.moves[0].srcArmy != destArmy)
-			cl.invalidatePaths(); // adding/removing units may change terrain type penalty based on creature native terrains
+		{
+			cl.updatePath(destArmy); // adding/removing units may change terrain type penalty based on creature native terrains
+			cl.updatePath(pack.moves[0].srcArmy);
+		}
 	}
 }
 
@@ -291,50 +301,53 @@
 		callInterfaceIfPresent(cl, cl.getOwner(pack.al.artHolder), &IGameEventsReceiver::askToAssembleArtifact, pack.al);
 }
 
-void ApplyClientNetPackVisitor::visitEraseArtifact(EraseArtifact & pack)
+void ApplyClientNetPackVisitor::visitEraseArtifact(BulkEraseArtifacts & pack)
 {
-	callInterfaceIfPresent(cl, cl.getOwner(pack.al.artHolder), &IGameEventsReceiver::artifactRemoved, pack.al);
+	cl.updatePath(pack.artHolder);
+	for(const auto & slotErase : pack.posPack)
+		callInterfaceIfPresent(cl, cl.getOwner(pack.artHolder), &IGameEventsReceiver::artifactRemoved, ArtifactLocation(pack.artHolder, slotErase));
 }
 
-void ApplyClientNetPackVisitor::visitMoveArtifact(MoveArtifact & pack)
+void ApplyClientNetPackVisitor::visitBulkMoveArtifacts(BulkMoveArtifacts & pack)
 {
-	auto moveArtifact = [this, &pack](PlayerColor player) -> void
+	const auto dstOwner = cl.getOwner(pack.dstArtHolder);
+	const auto applyMove = [this, &pack, dstOwner](std::vector<BulkMoveArtifacts::LinkedSlots> & artsPack)
 	{
-		callInterfaceIfPresent(cl, player, &IGameEventsReceiver::artifactMoved, pack.src, pack.dst);
-		if(pack.askAssemble)
-			callInterfaceIfPresent(cl, player, &IGameEventsReceiver::askToAssembleArtifact, pack.dst);
-	};
+		for(const auto & slotToMove : artsPack)
+		{
+			const auto srcLoc = ArtifactLocation(pack.srcArtHolder, slotToMove.srcPos);
+			const auto dstLoc = ArtifactLocation(pack.dstArtHolder, slotToMove.dstPos);
 
-	moveArtifact(pack.interfaceOwner);
-	if(pack.interfaceOwner != cl.getOwner(pack.dst.artHolder))
-		moveArtifact(cl.getOwner(pack.dst.artHolder));
+			callInterfaceIfPresent(cl, pack.interfaceOwner, &IGameEventsReceiver::artifactMoved, srcLoc, dstLoc);
+			if(slotToMove.askAssemble)
+				callInterfaceIfPresent(cl, pack.interfaceOwner, &IGameEventsReceiver::askToAssembleArtifact, dstLoc);
+			if(pack.interfaceOwner != dstOwner)
+				callInterfaceIfPresent(cl, dstOwner, &IGameEventsReceiver::artifactMoved, srcLoc, dstLoc);
 
-	cl.invalidatePaths(); // hero might have equipped/unequipped Angel Wings
-}
+			cl.updatePath(pack.srcArtHolder); // hero might have equipped/unequipped Angel Wings
+			cl.updatePath(pack.dstArtHolder);
+		}
+	};
 
-void ApplyClientNetPackVisitor::visitBulkMoveArtifacts(BulkMoveArtifacts & pack)
-{
-	auto applyMove = [this, &pack](std::vector<BulkMoveArtifacts::LinkedSlots> & artsPack) -> void
+	size_t possibleAssemblyNumOfArts = 0;
+	const auto calcPossibleAssemblyNumOfArts = [&possibleAssemblyNumOfArts](const auto & slotToMove)
 	{
-		for(auto & slotToMove : artsPack)
-		{
-			auto srcLoc = ArtifactLocation(pack.srcArtHolder, slotToMove.srcPos);
-			auto dstLoc = ArtifactLocation(pack.dstArtHolder, slotToMove.dstPos);
-			MoveArtifact ma(pack.interfaceOwner, srcLoc, dstLoc, pack.askAssemble);
-			visitMoveArtifact(ma);
-		}
+		if(slotToMove.askAssemble)
+			possibleAssemblyNumOfArts++;
 	};
+	std::for_each(pack.artsPack0.cbegin(), pack.artsPack0.cend(), calcPossibleAssemblyNumOfArts);
+	std::for_each(pack.artsPack1.cbegin(), pack.artsPack1.cend(), calcPossibleAssemblyNumOfArts);
 
-	auto srcOwner = cl.getOwner(pack.srcArtHolder);
-	auto dstOwner = cl.getOwner(pack.dstArtHolder);
 
 	// Begin a session of bulk movement of arts. It is not necessary but useful for the client optimization.
-	callInterfaceIfPresent(cl, srcOwner, &IGameEventsReceiver::bulkArtMovementStart, pack.artsPack0.size() + pack.artsPack1.size());
-	if(srcOwner != dstOwner)
-		callInterfaceIfPresent(cl, dstOwner, &IGameEventsReceiver::bulkArtMovementStart, pack.artsPack0.size() + pack.artsPack1.size());
+	callInterfaceIfPresent(cl, pack.interfaceOwner, &IGameEventsReceiver::bulkArtMovementStart,
+		pack.artsPack0.size() + pack.artsPack1.size(), possibleAssemblyNumOfArts);
+	if(pack.interfaceOwner != dstOwner)
+		callInterfaceIfPresent(cl, dstOwner, &IGameEventsReceiver::bulkArtMovementStart,
+			pack.artsPack0.size() + pack.artsPack1.size(), possibleAssemblyNumOfArts);
 
 	applyMove(pack.artsPack0);
-	if(pack.swap)
+	if(!pack.artsPack1.empty())
 		applyMove(pack.artsPack1);
 }
 
@@ -342,14 +355,14 @@
 {
 	callInterfaceIfPresent(cl, cl.getOwner(pack.al.artHolder), &IGameEventsReceiver::artifactAssembled, pack.al);
 
-	cl.invalidatePaths(); // hero might have equipped/unequipped Angel Wings
+	cl.updatePath(pack.al.artHolder); // hero might have equipped/unequipped Angel Wings
 }
 
 void ApplyClientNetPackVisitor::visitDisassembledArtifact(DisassembledArtifact & pack)
 {
 	callInterfaceIfPresent(cl, cl.getOwner(pack.al.artHolder), &IGameEventsReceiver::artifactDisassembled, pack.al);
 
-	cl.invalidatePaths(); // hero might have equipped/unequipped Angel Wings
+	cl.updatePath(pack.al.artHolder); // hero might have equipped/unequipped Angel Wings
 }
 
 void ApplyClientNetPackVisitor::visitHeroVisit(HeroVisit & pack)
@@ -362,6 +375,14 @@
 void ApplyClientNetPackVisitor::visitNewTurn(NewTurn & pack)
 {
 	cl.invalidatePaths();
+
+	if(pack.newWeekNotification)
+	{
+		const auto & newWeek = *pack.newWeekNotification;
+
+		std::string str = newWeek.text.toString();
+		callAllInterfaces(cl, &CGameInterface::showInfoDialog, newWeek.type, str, newWeek.components,(soundBase::soundID)newWeek.soundID);
+	}
 }
 
 void ApplyClientNetPackVisitor::visitGiveBonus(GiveBonus & pack)
@@ -372,7 +393,7 @@
 	case GiveBonus::ETarget::OBJECT:
 		{
 			const CGHeroInstance *h = gs.getHero(pack.id.as<ObjectInstanceID>());
-			if (h)
+			if(h)
 				callInterfaceIfPresent(cl, h->tempOwner, &IGameEventsReceiver::heroBonusChanged, h, pack.bonus, true);
 		}
 		break;
@@ -411,7 +432,7 @@
 
 	bool lastHumanEndsGame = CSH->howManyPlayerInterfaces() == 1 && vstd::contains(cl.playerint, pack.player) && cl.getPlayerState(pack.player)->human && !settings["session"]["spectate"].Bool();
 
-	if (lastHumanEndsGame)
+	if(lastHumanEndsGame)
 	{
 		assert(adventureInt);
 		if(adventureInt)
@@ -420,7 +441,7 @@
 			adventureInt.reset();
 		}
 
-		CSH->showHighScoresAndEndGameplay(pack.player, pack.victoryLossCheckResult.victory());
+		CSH->showHighScoresAndEndGameplay(pack.player, pack.victoryLossCheckResult.victory(), pack.statistic);
 	}
 
 	// In auto testing pack.mode we always close client if red pack.player won or lose
@@ -438,9 +459,9 @@
 	{
 		cl.initPlayerInterfaces();
 
-		for (PlayerColor player(0); player < PlayerColor::PLAYER_LIMIT; ++player)
+		for(PlayerColor player(0); player < PlayerColor::PLAYER_LIMIT; ++player)
 		{
-			if (cl.gameState()->isPlayerMakingTurn(player))
+			if(cl.gameState()->isPlayerMakingTurn(player))
 			{
 				callAllInterfaces(cl, &IGameEventsReceiver::playerStartsTurn, player);
 				callOnlyThatInterface(cl, player, &CGameInterface::yourTurn, QueryID::NONE);
@@ -474,7 +495,7 @@
 	case GiveBonus::ETarget::OBJECT:
 		{
 			const CGHeroInstance *h = gs.getHero(pack.whoID.as<ObjectInstanceID>());
-			if (h)
+			if(h)
 				callInterfaceIfPresent(cl, h->tempOwner, &IGameEventsReceiver::heroBonusChanged, h, pack.bonus, false);
 		}
 		break;
@@ -649,7 +670,7 @@
 void ApplyClientNetPackVisitor::visitHeroRecruited(HeroRecruited & pack)
 {
 	CGHeroInstance *h = gs.map->heroesOnMap.back();
-	if(h->getHeroType() != pack.hid)
+	if(h->getHeroTypeID() != pack.hid)
 	{
 		logNetwork->error("Something wrong with hero recruited!");
 	}
@@ -693,7 +714,7 @@
 	}
 
 	// invalidate section of map view with our object and force an update with new flag color
-	if (pack.what == ObjProperty::OWNER && CGI->mh)
+	if(pack.what == ObjProperty::OWNER && CGI->mh)
 	{
 		auto object = gs.getObjInstance(pack.id);
 		CGI->mh->onObjectInstantRemove(object, object->getOwner());
@@ -710,7 +731,7 @@
 	}
 
 	// invalidate section of map view with our object and force an update with new flag color
-	if (pack.what == ObjProperty::OWNER && CGI->mh)
+	if(pack.what == ObjProperty::OWNER && CGI->mh)
 	{
 		auto object = gs.getObjInstance(pack.id);
 		CGI->mh->onObjectInstantAdd(object, object->getOwner());
@@ -769,12 +790,12 @@
 void ApplyFirstClientNetPackVisitor::visitBattleStart(BattleStart & pack)
 {
 	// Cannot use the usual code because curB is not set yet
-	callOnlyThatBattleInterface(cl, pack.info->sides[0].color, &IBattleEventsReceiver::battleStartBefore, pack.battleID, pack.info->sides[0].armyObject, pack.info->sides[1].armyObject,
-		pack.info->tile, pack.info->sides[0].hero, pack.info->sides[1].hero);
-	callOnlyThatBattleInterface(cl, pack.info->sides[1].color, &IBattleEventsReceiver::battleStartBefore, pack.battleID, pack.info->sides[0].armyObject, pack.info->sides[1].armyObject,
-		pack.info->tile, pack.info->sides[0].hero, pack.info->sides[1].hero);
-	callOnlyThatBattleInterface(cl, PlayerColor::SPECTATOR, &IBattleEventsReceiver::battleStartBefore, pack.battleID, pack.info->sides[0].armyObject, pack.info->sides[1].armyObject,
-		pack.info->tile, pack.info->sides[0].hero, pack.info->sides[1].hero);
+	callOnlyThatBattleInterface(cl, pack.info->getSide(BattleSide::ATTACKER).color, &IBattleEventsReceiver::battleStartBefore, pack.battleID, pack.info->getSide(BattleSide::ATTACKER).armyObject, pack.info->getSide(BattleSide::DEFENDER).armyObject,
+		pack.info->tile, pack.info->getSide(BattleSide::ATTACKER).hero, pack.info->getSide(BattleSide::DEFENDER).hero);
+	callOnlyThatBattleInterface(cl, pack.info->getSide(BattleSide::DEFENDER).color, &IBattleEventsReceiver::battleStartBefore, pack.battleID, pack.info->getSide(BattleSide::ATTACKER).armyObject, pack.info->getSide(BattleSide::DEFENDER).armyObject,
+		pack.info->tile, pack.info->getSide(BattleSide::ATTACKER).hero, pack.info->getSide(BattleSide::DEFENDER).hero);
+	callOnlyThatBattleInterface(cl, PlayerColor::SPECTATOR, &IBattleEventsReceiver::battleStartBefore, pack.battleID, pack.info->getSide(BattleSide::ATTACKER).armyObject, pack.info->getSide(BattleSide::DEFENDER).armyObject,
+		pack.info->tile, pack.info->getSide(BattleSide::ATTACKER).hero, pack.info->getSide(BattleSide::DEFENDER).hero);
 }
 
 void ApplyClientNetPackVisitor::visitBattleStart(BattleStart & pack)
@@ -799,11 +820,11 @@
 
 	const CStack *activated = gs.getBattle(pack.battleID)->battleGetStackByID(pack.stack);
 	PlayerColor playerToCall; //pack.player that will move activated stack
-	if (activated->hasBonusOfType(BonusType::HYPNOTIZED))
+	if(activated->hasBonusOfType(BonusType::HYPNOTIZED))
 	{
-		playerToCall = (gs.getBattle(pack.battleID)->sides[0].color == activated->unitOwner()
-			? gs.getBattle(pack.battleID)->sides[1].color
-			: gs.getBattle(pack.battleID)->sides[0].color);
+		playerToCall = gs.getBattle(pack.battleID)->getSide(BattleSide::ATTACKER).color == activated->unitOwner()
+			? gs.getBattle(pack.battleID)->getSide(BattleSide::DEFENDER).color
+			: gs.getBattle(pack.battleID)->getSide(BattleSide::ATTACKER).color;
 	}
 	else
 	{
@@ -844,7 +865,7 @@
 {
 	callBattleInterfaceIfPresentForBothSides(cl, pack.battleID, &IBattleEventsReceiver::battleAttack, pack.battleID, &pack);
 
-	// battleStacksAttacked should be excuted before BattleAttack.applyGs() to play animation before damaging unit
+	// battleStacksAttacked should be executed before BattleAttack.applyGs() to play animation before damaging unit
 	// so this has to be here instead of ApplyClientNetPackVisitor::visitBattleAttack()
 	callBattleInterfaceIfPresentForBothSides(cl, pack.battleID, &IBattleEventsReceiver::battleStacksAttacked, pack.battleID, pack.bsa, pack.shot());
 }
@@ -999,7 +1020,7 @@
 	case EOpenWindowMode::UNIVERSITY_WINDOW:
 		{
 			//displays University window (when hero enters University on adventure map)
-			const auto * market = dynamic_cast<const IMarket*>(cl.getObj(ObjectInstanceID(pack.object)));
+			const auto * market = cl.getMarket(ObjectInstanceID(pack.object));
 			const CGHeroInstance *hero = cl.getHero(ObjectInstanceID(pack.visitor));
 			callInterfaceIfPresent(cl, hero->tempOwner, &IGameEventsReceiver::showUniversityWindow, market, hero, pack.queryID);
 		}
@@ -1009,7 +1030,7 @@
 			//displays Thieves' Guild window (when hero enters Den of Thieves)
 			const CGObjectInstance *obj = cl.getObj(ObjectInstanceID(pack.object));
 			const CGHeroInstance *hero = cl.getHero(ObjectInstanceID(pack.visitor));
-			const auto *market = dynamic_cast<const IMarket*>(obj);
+			const auto market = cl.getMarket(pack.object);
 			callInterfaceIfPresent(cl, cl.getTile(obj->visitablePos())->visitableObjects.back()->tempOwner, &IGameEventsReceiver::showMarketWindow, market, hero, pack.queryID);
 		}
 		break;
@@ -1048,7 +1069,7 @@
 {
 	cl.invalidatePaths();
 
-	const CGObjectInstance *obj = cl.getObj(pack.createdObjectID);
+	const CGObjectInstance *obj = pack.newObject;
 	if(CGI->mh)
 		CGI->mh->onObjectFadeIn(obj, pack.initiator);
 
diff --color -urN vcmi-1.5.7/client/NetPacksLobbyClient.cpp vcmi/client/NetPacksLobbyClient.cpp
--- vcmi-1.5.7/client/NetPacksLobbyClient.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/NetPacksLobbyClient.cpp	2024-12-19 15:00:22.241120786 +0100
@@ -31,10 +31,14 @@
 #include "gui/WindowHandler.h"
 #include "widgets/Buttons.h"
 #include "widgets/TextControls.h"
+#include "media/CMusicHandler.h"
+#include "media/IVideoPlayer.h"
+#include "windows/GUIClasses.h"
 
 #include "../lib/CConfigHandler.h"
-#include "../lib/CGeneralTextHandler.h"
+#include "../lib/texts/CGeneralTextHandler.h"
 #include "../lib/serializer/Connection.h"
+#include "../lib/campaign/CampaignState.h"
 
 void ApplyOnLobbyHandlerNetPackVisitor::visitLobbyClientConnected(LobbyClientConnected & pack)
 {
@@ -202,8 +206,19 @@
 		
 	if(!lobby->bonusSel && handler.si->campState && handler.getState() == EClientState::LOBBY_CAMPAIGN)
 	{
-		lobby->bonusSel = std::make_shared<CBonusSelection>();
-		GH.windows().pushWindow(lobby->bonusSel);
+		auto bonusSel = std::make_shared<CBonusSelection>();
+		lobby->bonusSel = bonusSel;
+		if(!handler.si->campState->conqueredScenarios().size() && !handler.si->campState->getIntroVideo().empty() && CCS->videoh->open(handler.si->campState->getIntroVideo(), 1))
+		{
+			CCS->musich->stopMusic();
+			GH.windows().createAndPushWindow<VideoWindow>(handler.si->campState->getIntroVideo(), handler.si->campState->getVideoRim().empty() ? ImagePath::builtin("INTRORIM") : handler.si->campState->getVideoRim(), false, 1, [bonusSel](bool skipped){
+				if(!CSH->si->campState->getMusic().empty())
+					CCS->musich->playMusic(CSH->si->campState->getMusic(), true, false);
+				GH.windows().pushWindow(bonusSel);
+			});
+		}
+		else
+			GH.windows().pushWindow(bonusSel);
 	}
 
 	if(lobby->bonusSel)
@@ -211,7 +226,7 @@
 	else
 		lobby->updateAfterStateChange();
 
-	if(pack.hostChanged)
+	if(pack.hostChanged || pack.refreshList)
 		lobby->toggleMode(handler.isHost());
 }
 
diff --color -urN vcmi-1.5.7/client/PlayerLocalState.cpp vcmi/client/PlayerLocalState.cpp
--- vcmi-1.5.7/client/PlayerLocalState.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/PlayerLocalState.cpp	2024-12-19 15:00:22.241120786 +0100
@@ -11,6 +11,7 @@
 #include "PlayerLocalState.h"
 
 #include "../CCallback.h"
+#include "../lib/json/JsonNode.h"
 #include "../lib/mapObjects/CGHeroInstance.h"
 #include "../lib/mapObjects/CGTownInstance.h"
 #include "../lib/pathfinder/CGPathNode.h"
@@ -23,34 +24,20 @@
 {
 }
 
-void PlayerLocalState::saveHeroPaths(std::map<const CGHeroInstance *, int3> & pathsMap)
+const PlayerSpellbookSetting & PlayerLocalState::getSpellbookSettings() const
 {
-	for(auto & p : paths)
-	{
-		if(p.second.nodes.size())
-			pathsMap[p.first] = p.second.endPos();
-		else
-			logGlobal->debug("%s has assigned an empty path! Ignoring it...", p.first->getNameTranslated());
-	}
+	return spellbookSettings;
 }
 
-void PlayerLocalState::loadHeroPaths(std::map<const CGHeroInstance *, int3> & pathsMap)
+void PlayerLocalState::setSpellbookSettings(const PlayerSpellbookSetting & newSettings)
 {
-	if(owner.cb)
-	{
-		for(auto & p : pathsMap)
-		{
-			CGPath path;
-			owner.cb->getPathsInfo(p.first)->getPath(path, p.second);
-			paths[p.first] = path;
-			logGlobal->trace("Restored path for hero %s leading to %s with %d nodes", p.first->nodeName(), p.second.toString(), path.nodes.size());
-		}
-	}
+	spellbookSettings = newSettings;
 }
 
 void PlayerLocalState::setPath(const CGHeroInstance * h, const CGPath & path)
 {
 	paths[h] = path;
+	syncronizeState();
 }
 
 const CGPath & PlayerLocalState::getPath(const CGHeroInstance * h) const
@@ -70,6 +57,7 @@
 	if(!owner.cb->getPathsInfo(h)->getPath(path, destination))
 	{
 		paths.erase(h); //invalidate previously possible path if selected (before other hero blocked only path / fly spell expired)
+		syncronizeState();
 		return false;
 	}
 
@@ -93,6 +81,7 @@
 {
 	paths.erase(h);
 	adventureInt->onHeroChanged(h);
+	syncronizeState();
 }
 
 void PlayerLocalState::verifyPath(const CGHeroInstance * h)
@@ -170,6 +159,7 @@
 
 	if (adventureInt && selection)
 		adventureInt->onSelectionChanged(selection);
+	syncronizeState();
 }
 
 bool PlayerLocalState::isHeroSleeping(const CGHeroInstance * hero) const
@@ -184,6 +174,7 @@
 	assert(!vstd::contains(sleepingHeroes, hero));
 
 	sleepingHeroes.push_back(hero);
+	syncronizeState();
 }
 
 void PlayerLocalState::setHeroAwaken(const CGHeroInstance * hero)
@@ -193,6 +184,7 @@
 	assert(vstd::contains(sleepingHeroes, hero));
 
 	vstd::erase(sleepingHeroes, hero);
+	syncronizeState();
 }
 
 const std::vector<const CGHeroInstance *> & PlayerLocalState::getWanderingHeroes()
@@ -215,6 +207,8 @@
 
 	if (currentSelection == nullptr)
 		setSelection(hero);
+
+	syncronizeState();
 }
 
 void PlayerLocalState::removeWanderingHero(const CGHeroInstance * hero)
@@ -225,7 +219,12 @@
 	if (hero == currentSelection)
 	{
 		auto const * nextHero = getNextWanderingHero(hero);
-		setSelection(nextHero);
+		if (nextHero)
+			setSelection(nextHero);
+		else if (!ownedTowns.empty())
+			setSelection(ownedTowns.front());
+		else
+			setSelection(nullptr);
 	}
 
 	vstd::erase(wanderingHeroes, hero);
@@ -236,6 +235,8 @@
 
 	if (currentSelection == nullptr && !ownedTowns.empty())
 		setSelection(ownedTowns.front());
+
+	syncronizeState();
 }
 
 void PlayerLocalState::swapWanderingHero(size_t pos1, size_t pos2)
@@ -244,6 +245,8 @@
 	std::swap(wanderingHeroes.at(pos1), wanderingHeroes.at(pos2));
 
 	adventureInt->onHeroOrderChanged();
+
+	syncronizeState();
 }
 
 const std::vector<const CGTownInstance *> & PlayerLocalState::getOwnedTowns()
@@ -266,6 +269,8 @@
 
 	if (currentSelection == nullptr)
 		setSelection(town);
+
+	syncronizeState();
 }
 
 void PlayerLocalState::removeOwnedTown(const CGTownInstance * town)
@@ -282,6 +287,8 @@
 
 	if (currentSelection == nullptr && !ownedTowns.empty())
 		setSelection(ownedTowns.front());
+
+	syncronizeState();
 }
 
 void PlayerLocalState::swapOwnedTowns(size_t pos1, size_t pos2)
@@ -289,5 +296,123 @@
 	assert(ownedTowns[pos1] && ownedTowns[pos2]);
 	std::swap(ownedTowns.at(pos1), ownedTowns.at(pos2));
 
+	syncronizeState();
+
 	adventureInt->onTownOrderChanged();
 }
+
+void PlayerLocalState::syncronizeState()
+{
+	JsonNode data;
+	serialize(data);
+	owner.cb->saveLocalState(data);
+}
+
+void PlayerLocalState::serialize(JsonNode & dest) const
+{
+	dest.clear();
+
+	for (auto const * town : ownedTowns)
+	{
+		JsonNode record;
+		record["id"].Integer() = town->id;
+		dest["towns"].Vector().push_back(record);
+	}
+
+	for (auto const * hero : wanderingHeroes)
+	{
+		JsonNode record;
+		record["id"].Integer() = hero->id;
+		if (vstd::contains(sleepingHeroes, hero))
+			record["sleeping"].Bool() = true;
+
+		if (paths.count(hero))
+		{
+			record["path"]["x"].Integer() = paths.at(hero).lastNode().coord.x;
+			record["path"]["y"].Integer() = paths.at(hero).lastNode().coord.y;
+			record["path"]["z"].Integer() = paths.at(hero).lastNode().coord.z;
+		}
+		dest["heroes"].Vector().push_back(record);
+	}
+	dest["spellbook"]["pageBattle"].Integer() = spellbookSettings.spellbookLastPageBattle;
+	dest["spellbook"]["pageAdvmap"].Integer() = spellbookSettings.spellbookLastPageAdvmap;
+	dest["spellbook"]["tabBattle"].Integer() = spellbookSettings.spellbookLastTabBattle;
+	dest["spellbook"]["tabAdvmap"].Integer() = spellbookSettings.spellbookLastTabAdvmap;
+
+	if (currentSelection)
+		dest["currentSelection"].Integer() = currentSelection->id;
+}
+
+void PlayerLocalState::deserialize(const JsonNode & source)
+{
+	// this method must be called after player state has been initialized
+	assert(currentSelection != nullptr);
+	assert(!ownedTowns.empty() || !wanderingHeroes.empty());
+
+	auto oldHeroes = wanderingHeroes;
+	auto oldTowns = ownedTowns;
+
+	paths.clear();
+	sleepingHeroes.clear();
+	wanderingHeroes.clear();
+	ownedTowns.clear();
+
+	for (auto const & town : source["towns"].Vector())
+	{
+		ObjectInstanceID objID(town["id"].Integer());
+		const CGTownInstance * townPtr = owner.cb->getTown(objID);
+
+		if (!townPtr)
+			continue;
+
+		if (!vstd::contains(oldTowns, townPtr))
+			continue;
+
+		ownedTowns.push_back(townPtr);
+		vstd::erase(oldTowns, townPtr);
+	}
+
+	for (auto const & hero : source["heroes"].Vector())
+	{
+		ObjectInstanceID objID(hero["id"].Integer());
+		const CGHeroInstance * heroPtr = owner.cb->getHero(objID);
+
+		if (!heroPtr)
+			continue;
+
+		if (!vstd::contains(oldHeroes, heroPtr))
+			continue;
+
+		wanderingHeroes.push_back(heroPtr);
+		vstd::erase(oldHeroes, heroPtr);
+
+		if (hero["sleeping"].Bool())
+			sleepingHeroes.push_back(heroPtr);
+
+		if (hero["path"]["x"].isNumber() && hero["path"]["y"].isNumber() && hero["path"]["z"].isNumber())
+		{
+			int3 pathTarget(hero["path"]["x"].Integer(), hero["path"]["y"].Integer(), hero["path"]["z"].Integer());
+			setPath(heroPtr, pathTarget);
+		}
+	}
+
+	if (!source["spellbook"].isNull())
+	{
+		spellbookSettings.spellbookLastPageBattle = source["spellbook"]["pageBattle"].Integer();
+		spellbookSettings.spellbookLastPageAdvmap = source["spellbook"]["pageAdvmap"].Integer();
+		spellbookSettings.spellbookLastTabBattle = source["spellbook"]["tabBattle"].Integer();
+		spellbookSettings.spellbookLastTabAdvmap = source["spellbook"]["tabAdvmap"].Integer();
+	}
+
+	// append any owned heroes / towns that were not present in loaded state
+	wanderingHeroes.insert(wanderingHeroes.end(), oldHeroes.begin(), oldHeroes.end());
+	ownedTowns.insert(ownedTowns.end(), oldTowns.begin(), oldTowns.end());
+
+//FIXME: broken, anything that is selected in here will be overwritten on PlayerStartsTurn pack
+//	ObjectInstanceID selectedObjectID(source["currentSelection"].Integer());
+//	const CGObjectInstance * objectPtr = owner.cb->getObjInstance(selectedObjectID);
+//	const CArmedInstance * armyPtr = dynamic_cast<const CArmedInstance*>(objectPtr);
+//
+//	if (armyPtr)
+//		setSelection(armyPtr);
+}
diff --color -urN vcmi-1.5.7/client/PlayerLocalState.h vcmi/client/PlayerLocalState.h
--- vcmi-1.5.7/client/PlayerLocalState.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/PlayerLocalState.h	2024-12-19 15:00:22.241120786 +0100
@@ -14,6 +14,7 @@
 class CGHeroInstance;
 class CGTownInstance;
 class CArmedInstance;
+class JsonNode;
 struct CGPath;
 class int3;
 
@@ -21,6 +22,15 @@
 
 class CPlayerInterface;
 
+struct PlayerSpellbookSetting
+{
+	//on which page we left spellbook
+	int spellbookLastPageBattle = 0;
+	int spellbookLastPageAdvmap = 0;
+	int spellbookLastTabBattle = 4;
+	int spellbookLastTabAdvmap = 4;
+};
+
 /// Class that contains potentially serializeable state of a local player
 class PlayerLocalState
 {
@@ -34,27 +44,10 @@
 	std::vector<const CGHeroInstance *> wanderingHeroes; //our heroes on the adventure map (not the garrisoned ones)
 	std::vector<const CGTownInstance *> ownedTowns; //our towns on the adventure map
 
-	void saveHeroPaths(std::map<const CGHeroInstance *, int3> & paths);
-	void loadHeroPaths(std::map<const CGHeroInstance *, int3> & paths);
+	PlayerSpellbookSetting spellbookSettings;
 
+	void syncronizeState();
 public:
-	struct SpellbookLastSetting
-	{
-		//on which page we left spellbook
-		int spellbookLastPageBattle = 0;
-		int spellbookLastPageAdvmap = 0;
-		int spellbookLastTabBattle = 4;
-		int spellbookLastTabAdvmap = 4;
-
-		template<typename Handler>
-		void serialize(Handler & h)
-		{
-			h & spellbookLastPageBattle;
-			h & spellbookLastPageAdvmap;
-			h & spellbookLastTabBattle;
-			h & spellbookLastTabAdvmap;
-		}
-	} spellbookSettings;
 
 	explicit PlayerLocalState(CPlayerInterface & owner);
 
@@ -62,6 +55,9 @@
 	void setHeroAsleep(const CGHeroInstance * hero);
 	void setHeroAwaken(const CGHeroInstance * hero);
 
+	const PlayerSpellbookSetting & getSpellbookSettings() const;
+	void setSpellbookSettings(const PlayerSpellbookSetting & newSettings);
+
 	const std::vector<const CGTownInstance *> & getOwnedTowns();
 	const CGTownInstance * getOwnedTown(size_t index);
 	void addOwnedTown(const CGTownInstance * hero);
@@ -90,24 +86,9 @@
 	const CGTownInstance * getCurrentTown() const;
 	const CArmedInstance * getCurrentArmy() const;
 
+	void serialize(JsonNode & dest) const;
+	void deserialize(const JsonNode & source);
+
 	/// Changes currently selected object
 	void setSelection(const CArmedInstance *sel);
-
-	template<typename Handler>
-	void serialize(Handler & h)
-	{
-		//WARNING: this code is broken and not used. See CClient::loadGame
-		std::map<const CGHeroInstance *, int3> pathsMap; //hero -> dest
-		if(h.saving)
-			saveHeroPaths(pathsMap);
-
-		h & pathsMap;
-
-		if(!h.saving)
-			loadHeroPaths(pathsMap);
-
-		h & ownedTowns;
-		h & wanderingHeroes;
-		h & sleepingHeroes;
-	}
 };
diff --color -urN vcmi-1.5.7/client/render/AssetGenerator.cpp vcmi/client/render/AssetGenerator.cpp
--- vcmi-1.5.7/client/render/AssetGenerator.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/client/render/AssetGenerator.cpp	2024-12-19 15:00:22.272122067 +0100
@@ -0,0 +1,436 @@
+/*
+ * AssetGenerator.cpp, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#include "StdInc.h"
+#include "AssetGenerator.h"
+
+#include "../gui/CGuiHandler.h"
+#include "../render/IImage.h"
+#include "../render/IImageLoader.h"
+#include "../render/Canvas.h"
+#include "../render/ColorFilter.h"
+#include "../render/IRenderHandler.h"
+#include "../render/CAnimation.h"
+
+#include "../lib/filesystem/Filesystem.h"
+#include "../lib/GameSettings.h"
+#include "../lib/IGameSettings.h"
+#include "../lib/json/JsonNode.h"
+#include "../lib/VCMI_Lib.h"
+#include "../lib/RiverHandler.h"
+#include "../lib/RoadHandler.h"
+#include "../lib/TerrainHandler.h"
+
+void AssetGenerator::generateAll()
+{
+	createBigSpellBook();
+	createAdventureOptionsCleanBackground();
+	for (int i = 0; i < PlayerColor::PLAYER_LIMIT_I; ++i)
+		createPlayerColoredBackground(PlayerColor(i));
+	createCombatUnitNumberWindow();
+	createCampaignBackground();
+	createChroniclesCampaignImages();
+	createPaletteShiftedSprites();
+}
+
+void AssetGenerator::createAdventureOptionsCleanBackground()
+{
+	std::string filename = "data/AdventureOptionsBackgroundClear.png";
+
+	if(CResourceHandler::get()->existsResource(ResourcePath(filename))) // overridden by mod, no generation
+		return;
+
+	if(!CResourceHandler::get("local")->createResource(filename))
+		return;
+	ResourcePath savePath(filename, EResType::IMAGE);
+
+	auto locator = ImageLocator(ImagePath::builtin("ADVOPTBK"));
+	locator.scalingFactor = 1;
+
+	std::shared_ptr<IImage> img = GH.renderHandler().loadImage(locator, EImageBlitMode::OPAQUE);
+
+	Canvas canvas = Canvas(Point(575, 585), CanvasScalingPolicy::IGNORE);
+	canvas.draw(img, Point(0, 0), Rect(0, 0, 575, 585));
+	canvas.draw(img, Point(54, 121), Rect(54, 123, 335, 1));
+	canvas.draw(img, Point(158, 84), Rect(156, 84, 2, 37));
+	canvas.draw(img, Point(234, 84), Rect(232, 84, 2, 37));
+	canvas.draw(img, Point(310, 84), Rect(308, 84, 2, 37));
+	canvas.draw(img, Point(53, 567), Rect(53, 520, 339, 3));
+	canvas.draw(img, Point(53, 520), Rect(53, 264, 339, 47));
+
+	std::shared_ptr<IImage> image = GH.renderHandler().createImage(canvas.getInternalSurface());
+
+	image->exportBitmap(*CResourceHandler::get("local")->getResourceName(savePath));
+}
+
+void AssetGenerator::createBigSpellBook()
+{
+	std::string filename = "data/SpellBookLarge.png";
+
+	if(CResourceHandler::get()->existsResource(ResourcePath(filename))) // overridden by mod, no generation
+		return;
+
+	if(!CResourceHandler::get("local")->createResource(filename))
+		return;
+	ResourcePath savePath(filename, EResType::IMAGE);
+
+	auto locator = ImageLocator(ImagePath::builtin("SpelBack"));
+	locator.scalingFactor = 1;
+
+	std::shared_ptr<IImage> img = GH.renderHandler().loadImage(locator, EImageBlitMode::OPAQUE);
+	Canvas canvas = Canvas(Point(800, 600), CanvasScalingPolicy::IGNORE);
+	// edges
+	canvas.draw(img, Point(0, 0), Rect(15, 38, 90, 45));
+	canvas.draw(img, Point(0, 460), Rect(15, 400, 90, 141));
+	canvas.draw(img, Point(705, 0), Rect(509, 38, 95, 45));
+	canvas.draw(img, Point(705, 460), Rect(509, 400, 95, 141));
+	// left / right
+	Canvas tmp1 = Canvas(Point(90, 355 - 45), CanvasScalingPolicy::IGNORE);
+	tmp1.draw(img, Point(0, 0), Rect(15, 38 + 45, 90, 355 - 45));
+	canvas.drawScaled(tmp1, Point(0, 45), Point(90, 415));
+	Canvas tmp2 = Canvas(Point(95, 355 - 45), CanvasScalingPolicy::IGNORE);
+	tmp2.draw(img, Point(0, 0), Rect(509, 38 + 45, 95, 355 - 45));
+	canvas.drawScaled(tmp2, Point(705, 45), Point(95, 415));
+	// top / bottom
+	Canvas tmp3 = Canvas(Point(409, 45), CanvasScalingPolicy::IGNORE);
+	tmp3.draw(img, Point(0, 0), Rect(100, 38, 409, 45));
+	canvas.drawScaled(tmp3, Point(90, 0), Point(615, 45));
+	Canvas tmp4 = Canvas(Point(409, 141), CanvasScalingPolicy::IGNORE);
+	tmp4.draw(img, Point(0, 0), Rect(100, 400, 409, 141));
+	canvas.drawScaled(tmp4, Point(90, 460), Point(615, 141));
+	// middle
+	Canvas tmp5 = Canvas(Point(409, 141), CanvasScalingPolicy::IGNORE);
+	tmp5.draw(img, Point(0, 0), Rect(100, 38 + 45, 509 - 15, 400 - 38));
+	canvas.drawScaled(tmp5, Point(90, 45), Point(615, 415));
+	// carpet
+	Canvas tmp6 = Canvas(Point(590, 59), CanvasScalingPolicy::IGNORE);
+	tmp6.draw(img, Point(0, 0), Rect(15, 484, 590, 59));
+	canvas.drawScaled(tmp6, Point(0, 545), Point(800, 59));
+	// remove bookmarks
+	for (int i = 0; i < 56; i++)
+		canvas.draw(Canvas(canvas, Rect(i < 30 ? 268 : 327, 464, 1, 46)), Point(269 + i, 464));
+	for (int i = 0; i < 56; i++)
+		canvas.draw(Canvas(canvas, Rect(469, 464, 1, 42)), Point(470 + i, 464));
+	for (int i = 0; i < 57; i++)
+		canvas.draw(Canvas(canvas, Rect(i < 30 ? 564 : 630, 464, 1, 44)), Point(565 + i, 464));
+	for (int i = 0; i < 56; i++)
+		canvas.draw(Canvas(canvas, Rect(656, 464, 1, 47)), Point(657 + i, 464));
+	// draw bookmarks
+	canvas.draw(img, Point(278, 464), Rect(220, 405, 37, 47));
+	canvas.draw(img, Point(481, 465), Rect(354, 406, 37, 41));
+	canvas.draw(img, Point(575, 465), Rect(417, 406, 37, 45));
+	canvas.draw(img, Point(667, 465), Rect(478, 406, 37, 47));
+
+	std::shared_ptr<IImage> image = GH.renderHandler().createImage(canvas.getInternalSurface());
+
+	image->exportBitmap(*CResourceHandler::get("local")->getResourceName(savePath));
+}
+
+void AssetGenerator::createPlayerColoredBackground(const PlayerColor & player)
+{
+	std::string filename = "data/DialogBoxBackground_" + player.toString() + ".png";
+
+	if(CResourceHandler::get()->existsResource(ResourcePath(filename))) // overridden by mod, no generation
+		return;
+
+	if(!CResourceHandler::get("local")->createResource(filename))
+		return;
+
+	ResourcePath savePath(filename, EResType::IMAGE);
+
+	auto locator = ImageLocator(ImagePath::builtin("DiBoxBck"));
+	locator.scalingFactor = 1;
+
+	std::shared_ptr<IImage> texture = GH.renderHandler().loadImage(locator, EImageBlitMode::OPAQUE);
+
+	// transform to make color of brown DIBOX.PCX texture match color of specified player
+	auto filterSettings = VLC->settingsHandler->getFullConfig()["interface"]["playerColoredBackground"];
+	static const std::array<ColorFilter, PlayerColor::PLAYER_LIMIT_I> filters = {
+		ColorFilter::genRangeShifter( filterSettings["red"   ].convertTo<std::vector<float>>() ),
+		ColorFilter::genRangeShifter( filterSettings["blue"  ].convertTo<std::vector<float>>() ),
+		ColorFilter::genRangeShifter( filterSettings["tan"   ].convertTo<std::vector<float>>() ),
+		ColorFilter::genRangeShifter( filterSettings["green" ].convertTo<std::vector<float>>() ),
+		ColorFilter::genRangeShifter( filterSettings["orange"].convertTo<std::vector<float>>() ),
+		ColorFilter::genRangeShifter( filterSettings["purple"].convertTo<std::vector<float>>() ),
+		ColorFilter::genRangeShifter( filterSettings["teal"  ].convertTo<std::vector<float>>() ),
+		ColorFilter::genRangeShifter( filterSettings["pink"  ].convertTo<std::vector<float>>() )
+	};
+
+	assert(player.isValidPlayer());
+	if (!player.isValidPlayer())
+	{
+		logGlobal->error("Unable to colorize to invalid player color %d!", player.getNum());
+		return;
+	}
+
+	texture->adjustPalette(filters[player.getNum()], 0);
+	texture->exportBitmap(*CResourceHandler::get("local")->getResourceName(savePath));
+}
+
+void AssetGenerator::createCombatUnitNumberWindow()
+{
+	std::string filenameToSave = "data/combatUnitNumberWindow";
+
+	ResourcePath savePathDefault(filenameToSave + "Default.png", EResType::IMAGE);
+	ResourcePath savePathNeutral(filenameToSave + "Neutral.png", EResType::IMAGE);
+	ResourcePath savePathPositive(filenameToSave + "Positive.png", EResType::IMAGE);
+	ResourcePath savePathNegative(filenameToSave + "Negative.png", EResType::IMAGE);
+
+	if(CResourceHandler::get()->existsResource(savePathDefault)) // overridden by mod, no generation
+		return;
+
+	if(!CResourceHandler::get("local")->createResource(savePathDefault.getOriginalName() + ".png") ||
+	   !CResourceHandler::get("local")->createResource(savePathNeutral.getOriginalName() + ".png") ||
+	   !CResourceHandler::get("local")->createResource(savePathPositive.getOriginalName() + ".png") ||
+	   !CResourceHandler::get("local")->createResource(savePathNegative.getOriginalName() + ".png"))
+		return;
+
+	auto locator = ImageLocator(ImagePath::builtin("CMNUMWIN"));
+	locator.scalingFactor = 1;
+
+	std::shared_ptr<IImage> texture = GH.renderHandler().loadImage(locator, EImageBlitMode::OPAQUE);
+
+	static const auto shifterNormal   = ColorFilter::genRangeShifter( 0.f, 0.f, 0.f, 0.6f, 0.2f, 1.0f );
+	static const auto shifterPositive = ColorFilter::genRangeShifter( 0.f, 0.f, 0.f, 0.2f, 1.0f, 0.2f );
+	static const auto shifterNegative = ColorFilter::genRangeShifter( 0.f, 0.f, 0.f, 1.0f, 0.2f, 0.2f );
+	static const auto shifterNeutral  = ColorFilter::genRangeShifter( 0.f, 0.f, 0.f, 1.0f, 1.0f, 0.2f );
+
+	// do not change border color
+	static const int32_t ignoredMask = 1 << 26;
+
+	texture->adjustPalette(shifterNormal, ignoredMask);
+	texture->exportBitmap(*CResourceHandler::get("local")->getResourceName(savePathDefault));
+	texture->adjustPalette(shifterPositive, ignoredMask);
+	texture->exportBitmap(*CResourceHandler::get("local")->getResourceName(savePathPositive));
+	texture->adjustPalette(shifterNegative, ignoredMask);
+	texture->exportBitmap(*CResourceHandler::get("local")->getResourceName(savePathNegative));
+	texture->adjustPalette(shifterNeutral, ignoredMask);
+	texture->exportBitmap(*CResourceHandler::get("local")->getResourceName(savePathNeutral));
+}
+
+void AssetGenerator::createCampaignBackground()
+{
+	std::string filename = "data/CampaignBackground8.png";
+
+	if(CResourceHandler::get()->existsResource(ResourcePath(filename))) // overridden by mod, no generation
+		return;
+
+	if(!CResourceHandler::get("local")->createResource(filename))
+		return;
+	ResourcePath savePath(filename, EResType::IMAGE);
+
+	auto locator = ImageLocator(ImagePath::builtin("CAMPBACK"));
+	locator.scalingFactor = 1;
+
+	std::shared_ptr<IImage> img = GH.renderHandler().loadImage(locator, EImageBlitMode::OPAQUE);
+	Canvas canvas = Canvas(Point(800, 600), CanvasScalingPolicy::IGNORE);
+	
+	canvas.draw(img, Point(0, 0), Rect(0, 0, 800, 600));
+
+	// left image
+	canvas.draw(img, Point(220, 73), Rect(290, 73, 141, 115));
+	canvas.draw(img, Point(37, 70), Rect(87, 70, 207, 120));
+
+	// right image
+	canvas.draw(img, Point(513, 67), Rect(463, 67, 71, 126));
+	canvas.draw(img, Point(586, 71), Rect(536, 71, 207, 117));
+
+	// middle image
+	canvas.draw(img, Point(306, 68), Rect(86, 68, 209, 122));
+
+	// disabled fields
+	canvas.draw(img, Point(40, 72), Rect(313, 74, 197, 114));
+	canvas.draw(img, Point(310, 72), Rect(313, 74, 197, 114));
+	canvas.draw(img, Point(590, 72), Rect(313, 74, 197, 114));
+	canvas.draw(img, Point(43, 245), Rect(313, 74, 197, 114));
+	canvas.draw(img, Point(313, 244), Rect(313, 74, 197, 114));
+	canvas.draw(img, Point(586, 246), Rect(313, 74, 197, 114));
+	canvas.draw(img, Point(34, 417), Rect(313, 74, 197, 114));
+	canvas.draw(img, Point(404, 414), Rect(313, 74, 197, 114));
+
+	// skull
+	auto locatorSkull = ImageLocator(ImagePath::builtin("CAMPNOSC"));
+	locatorSkull.scalingFactor = 1;
+	std::shared_ptr<IImage> imgSkull = GH.renderHandler().loadImage(locatorSkull, EImageBlitMode::OPAQUE);
+	canvas.draw(imgSkull, Point(562, 509), Rect(178, 108, 43, 19));
+
+	std::shared_ptr<IImage> image = GH.renderHandler().createImage(canvas.getInternalSurface());
+
+	image->exportBitmap(*CResourceHandler::get("local")->getResourceName(savePath));
+}
+
+void AssetGenerator::createChroniclesCampaignImages()
+{
+	for(int i = 1; i < 9; i++)
+	{
+		std::string filename = "data/CampaignHc" + std::to_string(i) + "Image.png";
+
+		if(CResourceHandler::get()->existsResource(ResourcePath(filename))) // overridden by mod, no generation
+			continue;
+			
+		auto imgPathBg = ImagePath::builtin("data/chronicles_" + std::to_string(i) + "/GamSelBk");
+		if(!CResourceHandler::get()->existsResource(imgPathBg)) // Chronicle episode not installed
+			continue;
+
+		if(!CResourceHandler::get("local")->createResource(filename))
+			continue;
+		ResourcePath savePath(filename, EResType::IMAGE);
+
+		auto locator = ImageLocator(imgPathBg);
+		locator.scalingFactor = 1;
+
+		std::shared_ptr<IImage> img = GH.renderHandler().loadImage(locator, EImageBlitMode::OPAQUE);
+		Canvas canvas = Canvas(Point(200, 116), CanvasScalingPolicy::IGNORE);
+		
+		switch (i)
+		{
+		case 1:
+			canvas.draw(img, Point(0, 0), Rect(149, 144, 200, 116));
+			break;
+		case 2:
+			canvas.draw(img, Point(0, 0), Rect(156, 150, 200, 116));
+			break;
+		case 3:
+			canvas.draw(img, Point(0, 0), Rect(171, 153, 200, 116));
+			break;
+		case 4:
+			canvas.draw(img, Point(0, 0), Rect(35, 358, 200, 116));
+			break;
+		case 5:
+			canvas.draw(img, Point(0, 0), Rect(216, 248, 200, 116));
+			break;
+		case 6:
+			canvas.draw(img, Point(0, 0), Rect(58, 234, 200, 116));
+			break;
+		case 7:
+			canvas.draw(img, Point(0, 0), Rect(184, 219, 200, 116));
+			break;
+		case 8:
+			canvas.draw(img, Point(0, 0), Rect(268, 210, 200, 116));
+
+			//skull
+			auto locatorSkull = ImageLocator(ImagePath::builtin("CampSP1"));
+			locatorSkull.scalingFactor = 1;
+			std::shared_ptr<IImage> imgSkull = GH.renderHandler().loadImage(locatorSkull, EImageBlitMode::OPAQUE);
+			canvas.draw(imgSkull, Point(162, 94), Rect(162, 94, 41, 22));
+			canvas.draw(img, Point(162, 94), Rect(424, 304, 14, 4));
+			canvas.draw(img, Point(162, 98), Rect(424, 308, 10, 4));
+			canvas.draw(img, Point(158, 102), Rect(424, 312, 10, 4));
+			canvas.draw(img, Point(154, 106), Rect(424, 316, 10, 4));
+			break;
+		}
+
+		std::shared_ptr<IImage> image = GH.renderHandler().createImage(canvas.getInternalSurface());
+
+		image->exportBitmap(*CResourceHandler::get("local")->getResourceName(savePath));
+	}
+}
+
+void AssetGenerator::createPaletteShiftedSprites()
+{
+	std::vector<std::string> tiles;
+	std::vector<std::vector<std::variant<TerrainPaletteAnimation, RiverPaletteAnimation>>> paletteAnimations;
+	for(auto entity : VLC->terrainTypeHandler->objects)
+	{
+		if(entity->paletteAnimation.size())
+		{
+			tiles.push_back(entity->tilesFilename.getName());
+			std::vector<std::variant<TerrainPaletteAnimation, RiverPaletteAnimation>> tmpAnim;
+			for(auto & animEntity : entity->paletteAnimation)
+				tmpAnim.push_back(animEntity);
+			paletteAnimations.push_back(tmpAnim);
+		}
+	}
+	for(auto entity : VLC->riverTypeHandler->objects)
+	{
+		if(entity->paletteAnimation.size())
+		{
+			tiles.push_back(entity->tilesFilename.getName());
+			std::vector<std::variant<TerrainPaletteAnimation, RiverPaletteAnimation>> tmpAnim;
+			for(auto & animEntity : entity->paletteAnimation)
+				tmpAnim.push_back(animEntity);
+			paletteAnimations.push_back(tmpAnim);
+		}
+	}
+
+	for(int i = 0; i < tiles.size(); i++)
+	{
+		auto sprite = tiles[i];
+
+		JsonNode config;
+		config["basepath"].String() = sprite + "_Shifted/";
+		config["images"].Vector();
+
+		auto filename = AnimationPath::builtin(sprite).addPrefix("SPRITES/");
+		auto filenameNew = AnimationPath::builtin(sprite + "_Shifted").addPrefix("SPRITES/");
+
+		if(CResourceHandler::get()->existsResource(ResourcePath(filenameNew.getName(), EResType::JSON))) // overridden by mod, no generation
+			return;
+		
+		auto anim = GH.renderHandler().loadAnimation(filename, EImageBlitMode::COLORKEY);
+		for(int j = 0; j < anim->size(); j++)
+		{
+			int maxLen = 1;
+			for(int k = 0; k < paletteAnimations[i].size(); k++)
+			{
+				auto element = paletteAnimations[i][k];
+				if(std::holds_alternative<TerrainPaletteAnimation>(element))
+					maxLen = std::lcm(maxLen, std::get<TerrainPaletteAnimation>(element).length);
+				else
+					maxLen = std::lcm(maxLen, std::get<RiverPaletteAnimation>(element).length);
+			}
+			for(int l = 0; l < maxLen; l++)
+			{
+				std::string spriteName = sprite + boost::str(boost::format("%02d") % j) + "_" + std::to_string(l) + ".png";
+				std::string filenameNewImg = "sprites/" + sprite + "_Shifted" + "/" + spriteName;
+				ResourcePath savePath(filenameNewImg, EResType::IMAGE);
+
+				if(!CResourceHandler::get("local")->createResource(filenameNewImg))
+					return;
+
+				auto imgLoc = anim->getImageLocator(j, 0);
+				imgLoc.scalingFactor = 1;
+				auto img = GH.renderHandler().loadImage(imgLoc, EImageBlitMode::COLORKEY);
+				for(int k = 0; k < paletteAnimations[i].size(); k++)
+				{
+					auto element = paletteAnimations[i][k];
+					if(std::holds_alternative<TerrainPaletteAnimation>(element))
+					{
+						auto tmp = std::get<TerrainPaletteAnimation>(element);
+						img->shiftPalette(tmp.start, tmp.length, l % tmp.length);
+					}
+					else
+					{
+						auto tmp = std::get<RiverPaletteAnimation>(element);
+						img->shiftPalette(tmp.start, tmp.length, l % tmp.length);
+					}
+				}
+				
+				Canvas canvas = Canvas(Point(32, 32), CanvasScalingPolicy::IGNORE);
+				canvas.draw(img, Point((32 - img->dimensions().x) / 2, (32 - img->dimensions().y) / 2));
+				std::shared_ptr<IImage> image = GH.renderHandler().createImage(canvas.getInternalSurface());
+				image->exportBitmap(*CResourceHandler::get("local")->getResourceName(savePath));
+
+				JsonNode node(JsonMap{
+					{ "group", JsonNode(l) },
+					{ "frame", JsonNode(j) },
+					{ "file", JsonNode(spriteName) }
+				});
+				config["images"].Vector().push_back(node);
+			}
+		}
+
+		ResourcePath savePath(filenameNew.getOriginalName(), EResType::JSON);
+		if(!CResourceHandler::get("local")->createResource(filenameNew.getOriginalName() + ".json"))
+			return;
+
+		std::fstream file(CResourceHandler::get("local")->getResourceName(savePath)->c_str(), std::ofstream::out | std::ofstream::trunc);
+		file << config.toString();
+	}
+}
diff --color -urN vcmi-1.5.7/client/render/AssetGenerator.h vcmi/client/render/AssetGenerator.h
--- vcmi-1.5.7/client/render/AssetGenerator.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/client/render/AssetGenerator.h	2024-12-19 15:00:22.272122067 +0100
@@ -0,0 +1,27 @@
+/*
+ * AssetGenerator.h, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#pragma once
+
+VCMI_LIB_NAMESPACE_BEGIN
+class PlayerColor;
+VCMI_LIB_NAMESPACE_END
+
+class AssetGenerator
+{
+public:
+	static void generateAll();
+	static void createAdventureOptionsCleanBackground();
+	static void createBigSpellBook();
+	static void createPlayerColoredBackground(const PlayerColor & player);
+	static void createCombatUnitNumberWindow();
+	static void createCampaignBackground();
+	static void createChroniclesCampaignImages();
+	static void createPaletteShiftedSprites();
+};
diff --color -urN vcmi-1.5.7/client/render/CAnimation.cpp vcmi/client/render/CAnimation.cpp
--- vcmi-1.5.7/client/render/CAnimation.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/render/CAnimation.cpp	2024-12-19 15:00:22.273122109 +0100
@@ -10,77 +10,43 @@
 #include "StdInc.h"
 #include "CAnimation.h"
 
-#include "CDefFile.h"
+#include "../gui/CGuiHandler.h"
+#include "../render/IImage.h"
+#include "../render/IRenderHandler.h"
+#include "../render/IScreenHandler.h"
 
-#include "Graphics.h"
 #include "../../lib/filesystem/Filesystem.h"
 #include "../../lib/json/JsonUtils.h"
-#include "../renderSDL/SDLImage.h"
 
-std::shared_ptr<IImage> CAnimation::getFromExtraDef(std::string filename)
-{
-	size_t pos = filename.find(':');
-	if (pos == -1)
-		return nullptr;
-	CAnimation anim(AnimationPath::builtinTODO(filename.substr(0, pos)));
-	pos++;
-	size_t frame = atoi(filename.c_str()+pos);
-	size_t group = 0;
-	pos = filename.find(':', pos);
-	if (pos != -1)
-	{
-		pos++;
-		group = frame;
-		frame = atoi(filename.c_str()+pos);
-	}
-	anim.load(frame ,group);
-	auto ret = anim.images[group][frame];
-	anim.images.clear();
-	return ret;
-}
-
-bool CAnimation::loadFrame(size_t frame, size_t group)
+bool CAnimation::loadFrame(size_t frame, size_t group, bool verbose)
 {
 	if(size(group) <= frame)
 	{
-		printError(frame, group, "LoadFrame");
+		if(verbose)
+			printError(frame, group, "LoadFrame");
 		return false;
 	}
 
-	auto image = getImage(frame, group, false);
-	if(image)
-	{
+	if(auto image = getImageImpl(frame, group, false))
 		return true;
-	}
 
-	//try to get image from def
-	if(source[group][frame].getType() == JsonNode::JsonType::DATA_NULL)
-	{
-		if(defFile)
-		{
-			auto frameList = defFile->getEntries();
-
-			if(vstd::contains(frameList, group) && frameList.at(group) > frame) // frame is present
-			{
-				images[group][frame] = std::make_shared<SDLImage>(defFile.get(), frame, group);
-				return true;
-			}
-		}
-		// still here? image is missing
+	std::shared_ptr<IImage> image = GH.renderHandler().loadImage(getImageLocator(frame, group), mode);
 
-		printError(frame, group, "LoadFrame");
-		images[group][frame] = std::make_shared<SDLImage>(ImagePath::builtin("DEFAULT"), EImageBlitMode::ALPHA);
-	}
-	else //load from separate file
+	if(image)
 	{
-		auto img = getFromExtraDef(source[group][frame]["file"].String());
-		if(!img)
-			img = std::make_shared<SDLImage>(source[group][frame], EImageBlitMode::ALPHA);
+		images[group][frame] = image;
 
-		images[group][frame] = img;
+		if (player.isValidPlayer())
+			image->playerColored(player);
 		return true;
 	}
-	return false;
+	else
+	{
+		// image is missing
+		printError(frame, group, "LoadFrame");
+		images[group][frame] = GH.renderHandler().loadImage(ImagePath::builtin("DEFAULT"), EImageBlitMode::OPAQUE);
+		return false;
+	}
 }
 
 bool CAnimation::unloadFrame(size_t frame, size_t group)
@@ -97,45 +63,6 @@
 	return false;
 }
 
-void CAnimation::initFromJson(const JsonNode & config)
-{
-	std::string basepath;
-	basepath = config["basepath"].String();
-
-	JsonNode base;
-	base["margins"] = config["margins"];
-	base["width"] = config["width"];
-	base["height"] = config["height"];
-
-	for(const JsonNode & group : config["sequences"].Vector())
-	{
-		size_t groupID = group["group"].Integer();//TODO: string-to-value conversion("moving" -> MOVING)
-		source[groupID].clear();
-
-		for(const JsonNode & frame : group["frames"].Vector())
-		{
-			JsonNode toAdd;
-			JsonUtils::inherit(toAdd, base);
-			toAdd["file"].String() = basepath + frame.String();
-			source[groupID].push_back(toAdd);
-		}
-	}
-
-	for(const JsonNode & node : config["images"].Vector())
-	{
-		size_t group = node["group"].Integer();
-		size_t frame = node["frame"].Integer();
-
-		if (source[group].size() <= frame)
-			source[group].resize(frame+1);
-
-		JsonNode toAdd;
-		JsonUtils::inherit(toAdd, base);
-		toAdd["file"].String() = basepath + node["file"].String();
-		source[group][frame] = toAdd;
-	}
-}
-
 void CAnimation::exportBitmaps(const boost::filesystem::path& path) const
 {
 	if(images.empty())
@@ -169,109 +96,36 @@
 	logGlobal->info("Exported %d frames to %s", counter, actualPath.string());
 }
 
-void CAnimation::init()
-{
-	if(defFile)
-	{
-		const std::map<size_t, size_t> defEntries = defFile->getEntries();
-
-		for (auto & defEntry : defEntries)
-			source[defEntry.first].resize(defEntry.second);
-	}
-
-	if (vstd::contains(graphics->imageLists, name.getName()))
-		initFromJson(graphics->imageLists[name.getName()]);
-
-	auto jsonResource = name.toType<EResType::JSON>();
-	auto configList = CResourceHandler::get()->getResourcesWithName(jsonResource);
-
-	for(auto & loader : configList)
-	{
-		auto stream = loader->load(jsonResource);
-		std::unique_ptr<ui8[]> textData(new ui8[stream->getSize()]);
-		stream->read(textData.get(), stream->getSize());
-
-		const JsonNode config(reinterpret_cast<const std::byte*>(textData.get()), stream->getSize());
-
-		initFromJson(config);
-	}
-}
-
 void CAnimation::printError(size_t frame, size_t group, std::string type) const
 {
 	logGlobal->error("%s error: Request for frame not present in CAnimation! File name: %s, Group: %d, Frame: %d", type, name.getOriginalName(), group, frame);
 }
 
-CAnimation::CAnimation(const AnimationPath & Name):
+CAnimation::CAnimation(const AnimationPath & Name, std::map<size_t, std::vector <ImageLocator> > layout, EImageBlitMode mode):
 	name(boost::starts_with(Name.getName(), "SPRITES") ? Name : Name.addPrefix("SPRITES/")),
-	preloaded(false)
+	source(layout),
+	mode(mode)
 {
-	if(CResourceHandler::get()->existsResource(name))
-	{
-		try
-		{
-			defFile = std::make_shared<CDefFile>(name);
-		}
-		catch ( const std::runtime_error & e)
-		{
-			logAnim->error("Def file %s failed to load! Reason: %s", Name.getOriginalName(), e.what());
-		}
-	}
-
-	init();
-
 	if(source.empty())
 		logAnim->error("Animation %s failed to load", Name.getOriginalName());
 }
 
-CAnimation::CAnimation():
-	preloaded(false)
-{
-	init();
-}
-
 CAnimation::~CAnimation() = default;
 
 void CAnimation::duplicateImage(const size_t sourceGroup, const size_t sourceFrame, const size_t targetGroup)
 {
-	if(!source.count(sourceGroup))
-	{
-		logAnim->error("Group %d missing in %s", sourceGroup, name.getName());
-		return;
-	}
-
-	if(source[sourceGroup].size() <= sourceFrame)
-	{
-		logAnim->error("Frame [%d %d] missing in %s", sourceGroup, sourceFrame, name.getName());
-		return;
-	}
-
-	//todo: clone actual loaded Image object
-	JsonNode clone(source[sourceGroup][sourceFrame]);
-
-	if(clone.getType() == JsonNode::JsonType::DATA_NULL)
-	{
-		std::string temp =  name.getName()+":"+std::to_string(sourceGroup)+":"+std::to_string(sourceFrame);
-		clone["file"].String() = temp;
-	}
-
+	ImageLocator clone(getImageLocator(sourceFrame, sourceGroup));
 	source[targetGroup].push_back(clone);
-
-	size_t index = source[targetGroup].size() - 1;
-
-	if(preloaded)
-		load(index, targetGroup);
 }
 
-void CAnimation::setCustom(std::string filename, size_t frame, size_t group)
+std::shared_ptr<IImage> CAnimation::getImage(size_t frame, size_t group, bool verbose)
 {
-	if (source[group].size() <= frame)
-		source[group].resize(frame+1);
-	source[group][frame]["file"].String() = filename;
-	//FIXME: update image if already loaded
+	if (!loadFrame(frame, group, verbose))
+		return nullptr;
+	return getImageImpl(frame, group, verbose);
 }
 
-std::shared_ptr<IImage> CAnimation::getImage(size_t frame, size_t group, bool verbose) const
+std::shared_ptr<IImage> CAnimation::getImageImpl(size_t frame, size_t group, bool verbose)
 {
 	auto groupIter = images.find(group);
 	if (groupIter != images.end())
@@ -285,78 +139,63 @@
 	return nullptr;
 }
 
-void CAnimation::load()
-{
-	for (auto & elem : source)
-		for (size_t image=0; image < elem.second.size(); image++)
-			loadFrame(image, elem.first);
-}
-
-void CAnimation::unload()
+size_t CAnimation::size(size_t group) const
 {
-	for (auto & elem : source)
-		for (size_t image=0; image < elem.second.size(); image++)
-			unloadFrame(image, elem.first);
-
+	auto iter = source.find(group);
+	if (iter != source.end())
+		return iter->second.size();
+	return 0;
 }
 
-void CAnimation::preload()
+void CAnimation::horizontalFlip()
 {
-	if(!preloaded)
-	{
-		preloaded = true;
-		load();
-	}
+	for(auto & group : source)
+		for(size_t i = 0; i < group.second.size(); ++i)
+			horizontalFlip(i, group.first);
 }
 
-void CAnimation::loadGroup(size_t group)
+void CAnimation::verticalFlip()
 {
-	if (vstd::contains(source, group))
-		for (size_t image=0; image < source[group].size(); image++)
-			loadFrame(image, group);
+	for(auto & group : source)
+		for(size_t i = 0; i < group.second.size(); ++i)
+			verticalFlip(i, group.first);
 }
 
-void CAnimation::unloadGroup(size_t group)
+void CAnimation::horizontalFlip(size_t frame, size_t group)
 {
-	if (vstd::contains(source, group))
-		for (size_t image=0; image < source[group].size(); image++)
-			unloadFrame(image, group);
-}
+	auto i1 = images.find(group);
+	if(i1 != images.end())
+	{
+		auto i2 = i1->second.find(frame);
 
-void CAnimation::load(size_t frame, size_t group)
-{
-	loadFrame(frame, group);
-}
+		if(i2 != i1->second.end())
+			i2->second = nullptr;
+	}
 
-void CAnimation::unload(size_t frame, size_t group)
-{
-	unloadFrame(frame, group);
+	auto locator = getImageLocator(frame, group);
+	locator.horizontalFlip = !locator.horizontalFlip;
+	source[group][frame] = locator;
 }
 
-size_t CAnimation::size(size_t group) const
+void CAnimation::verticalFlip(size_t frame, size_t group)
 {
-	auto iter = source.find(group);
-	if (iter != source.end())
-		return iter->second.size();
-	return 0;
-}
+	auto i1 = images.find(group);
+	if(i1 != images.end())
+	{
+		auto i2 = i1->second.find(frame);
 
-void CAnimation::horizontalFlip()
-{
-	for(auto & group : images)
-		for(auto & image : group.second)
-			image.second->horizontalFlip();
-}
+		if(i2 != i1->second.end())
+			i2->second = nullptr;
+	}
 
-void CAnimation::verticalFlip()
-{
-	for(auto & group : images)
-		for(auto & image : group.second)
-			image.second->verticalFlip();
+	auto locator = getImageLocator(frame, group);
+	locator.verticalFlip = !locator.verticalFlip;
+	source[group][frame] = locator;
 }
 
-void CAnimation::playerColored(PlayerColor player)
+void CAnimation::playerColored(PlayerColor targetPlayer)
 {
+	player = targetPlayer;
 	for(auto & group : images)
 		for(auto & image : group.second)
 			image.second->playerColored(player);
@@ -367,9 +206,16 @@
 	for(size_t frame = 0; frame < size(sourceGroup); ++frame)
 	{
 		duplicateImage(sourceGroup, frame, targetGroup);
-
-		auto image = getImage(frame, targetGroup);
-		image->verticalFlip();
+		verticalFlip(frame, targetGroup);
 	}
 }
 
+ImageLocator CAnimation::getImageLocator(size_t frame, size_t group) const
+{
+	const ImageLocator & locator = source.at(group).at(frame);
+
+	if (!locator.empty())
+		return locator;
+
+	return ImageLocator(name, frame, group);
+}
diff --color -urN vcmi-1.5.7/client/render/CAnimation.h vcmi/client/render/CAnimation.h
--- vcmi-1.5.7/client/render/CAnimation.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/render/CAnimation.h	2024-12-19 15:00:22.273122109 +0100
@@ -9,6 +9,9 @@
  */
 #pragma once
 
+#include "IImage.h"
+#include "ImageLocator.h"
+
 #include "../../lib/GameConstants.h"
 #include "../../lib/filesystem/ResourcePath.h"
 
@@ -17,15 +20,14 @@
 VCMI_LIB_NAMESPACE_END
 
 class CDefFile;
-class IImage;
 class RenderHandler;
 
 /// Class for handling animation
 class CAnimation
 {
 private:
-	//source[group][position] - file with this frame, if string is empty - image located in def file
-	std::map<size_t, std::vector <JsonNode> > source;
+	//source[group][position] - location of this frame
+	std::map<size_t, std::vector <ImageLocator> > source;
 
 	//bitmap[group][position], store objects with loaded bitmaps
 	std::map<size_t, std::map<size_t, std::shared_ptr<IImage> > > images;
@@ -33,63 +35,44 @@
 	//animation file name
 	AnimationPath name;
 
-	bool preloaded;
+	EImageBlitMode mode;
 
-	std::shared_ptr<CDefFile> defFile;
+	// current player color, if any
+	PlayerColor player = PlayerColor::CANNOT_DETERMINE;
 
 	//loader, will be called by load(), require opened def file for loading from it. Returns true if image is loaded
-	bool loadFrame(size_t frame, size_t group);
+	bool loadFrame(size_t frame, size_t group, bool verbose = true);
 
 	//unloadFrame, returns true if image has been unloaded ( either deleted or decreased refCount)
 	bool unloadFrame(size_t frame, size_t group);
 
-	//initialize animation from file
-	void initFromJson(const JsonNode & input);
-	void init();
-
 	//to get rid of copy-pasting error message :]
 	void printError(size_t frame, size_t group, std::string type) const;
 
-	//not a very nice method to get image from another def file
-	//TODO: remove after implementing resource manager
-	std::shared_ptr<IImage> getFromExtraDef(std::string filename);
-
+	std::shared_ptr<IImage> getImageImpl(size_t frame, size_t group=0, bool verbose=true);
 public:
-	CAnimation(const AnimationPath & Name);
-	CAnimation();
+	CAnimation(const AnimationPath & Name, std::map<size_t, std::vector <ImageLocator> > layout, EImageBlitMode mode);
 	~CAnimation();
 
 	//duplicates frame at [sourceGroup, sourceFrame] as last frame in targetGroup
 	//and loads it if animation is preloaded
 	void duplicateImage(const size_t sourceGroup, const size_t sourceFrame, const size_t targetGroup);
 
-	//add custom surface to the selected position.
-	void setCustom(std::string filename, size_t frame, size_t group=0);
-
-	std::shared_ptr<IImage> getImage(size_t frame, size_t group=0, bool verbose=true) const;
+	std::shared_ptr<IImage> getImage(size_t frame, size_t group=0, bool verbose=true);
 
 	void exportBitmaps(const boost::filesystem::path & path) const;
 
-	//all available frames
-	void load  ();
-	void unload();
-	void preload();
-
-	//all frames from group
-	void loadGroup  (size_t group);
-	void unloadGroup(size_t group);
-
-	//single image
-	void load  (size_t frame, size_t group=0);
-	void unload(size_t frame, size_t group=0);
-
 	//total count of frames in group (including not loaded)
 	size_t size(size_t group=0) const;
 
+	void horizontalFlip(size_t frame, size_t group=0);
+	void verticalFlip(size_t frame, size_t group=0);
 	void horizontalFlip();
 	void verticalFlip();
 	void playerColored(PlayerColor player);
 
 	void createFlippedGroup(const size_t sourceGroup, const size_t targetGroup);
+
+	ImageLocator getImageLocator(size_t frame, size_t group) const;
 };
 
diff --color -urN vcmi-1.5.7/client/render/Canvas.cpp vcmi/client/render/Canvas.cpp
--- vcmi-1.5.7/client/render/Canvas.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/render/Canvas.cpp	2024-12-19 15:00:22.279122357 +0100
@@ -10,6 +10,9 @@
 #include "StdInc.h"
 #include "Canvas.h"
 
+#include "../gui/CGuiHandler.h"
+#include "../render/IRenderHandler.h"
+#include "../render/IScreenHandler.h"
 #include "../renderSDL/SDL_Extensions.h"
 #include "Colors.h"
 #include "IImage.h"
@@ -19,7 +22,8 @@
 #include <SDL_surface.h>
 #include <SDL_pixels.h>
 
-Canvas::Canvas(SDL_Surface * surface):
+Canvas::Canvas(SDL_Surface * surface, CanvasScalingPolicy scalingPolicy):
+	scalingPolicy(scalingPolicy),
 	surface(surface),
 	renderArea(0,0, surface->w, surface->h)
 {
@@ -27,6 +31,7 @@
 }
 
 Canvas::Canvas(const Canvas & other):
+	scalingPolicy(other.scalingPolicy),
 	surface(other.surface),
 	renderArea(other.renderArea)
 {
@@ -34,6 +39,7 @@
 }
 
 Canvas::Canvas(Canvas && other):
+	scalingPolicy(other.scalingPolicy),
 	surface(other.surface),
 	renderArea(other.renderArea)
 {
@@ -43,20 +49,39 @@
 Canvas::Canvas(const Canvas & other, const Rect & newClipRect):
 	Canvas(other)
 {
-	renderArea = other.renderArea.intersect(newClipRect + other.renderArea.topLeft());
+	Rect scaledClipRect( transformPos(newClipRect.topLeft()), transformPos(newClipRect.dimensions()));
+	renderArea = other.renderArea.intersect(scaledClipRect + other.renderArea.topLeft());
 }
 
-Canvas::Canvas(const Point & size):
-	renderArea(Point(0,0), size),
-	surface(CSDL_Ext::newSurface(size.x, size.y))
+Canvas::Canvas(const Point & size, CanvasScalingPolicy scalingPolicy):
+	scalingPolicy(scalingPolicy),
+	surface(CSDL_Ext::newSurface(size * getScalingFactor())),
+	renderArea(Point(0,0), size * getScalingFactor())
 {
 	CSDL_Ext::fillSurface(surface, CSDL_Ext::toSDL(Colors::TRANSPARENCY) );
 	SDL_SetSurfaceBlendMode(surface, SDL_BLENDMODE_NONE);
 }
 
-Canvas Canvas::createFromSurface(SDL_Surface * surface)
+int Canvas::getScalingFactor() const
 {
-	return Canvas(surface);
+	if (scalingPolicy == CanvasScalingPolicy::IGNORE)
+		return 1;
+	return GH.screenHandler().getScalingFactor();
+}
+
+Point Canvas::transformPos(const Point & input)
+{
+	return renderArea.topLeft() + input * getScalingFactor();
+}
+
+Point Canvas::transformSize(const Point & input)
+{
+	return input * getScalingFactor();
+}
+
+Canvas Canvas::createFromSurface(SDL_Surface * surface, CanvasScalingPolicy scalingPolicy)
+{
+	return Canvas(surface, scalingPolicy);
 }
 
 void Canvas::applyTransparency(bool on)
@@ -81,19 +106,20 @@
 {
 	assert(image);
 	if (image)
-		image->draw(surface, renderArea.x + pos.x, renderArea.y + pos.y);
+		image->draw(surface, transformPos(pos));
 }
 
 void Canvas::draw(const std::shared_ptr<IImage>& image, const Point & pos, const Rect & sourceRect)
 {
+	Rect realSourceRect = sourceRect * getScalingFactor();
 	assert(image);
 	if (image)
-		image->draw(surface, renderArea.x + pos.x, renderArea.y + pos.y, &sourceRect);
+		image->draw(surface, transformPos(pos), &realSourceRect);
 }
 
 void Canvas::draw(const Canvas & image, const Point & pos)
 {
-	CSDL_Ext::blitSurface(image.surface, image.renderArea, surface, renderArea.topLeft() + pos);
+	CSDL_Ext::blitSurface(image.surface, image.renderArea, surface, transformPos(pos));
 }
 
 void Canvas::drawTransparent(const Canvas & image, const Point & pos, double transparency)
@@ -103,42 +129,38 @@
 	SDL_GetSurfaceBlendMode(image.surface, &oldMode);
 	SDL_SetSurfaceBlendMode(image.surface, SDL_BLENDMODE_BLEND);
 	SDL_SetSurfaceAlphaMod(image.surface, 255 * transparency);
-	CSDL_Ext::blitSurface(image.surface, image.renderArea, surface, renderArea.topLeft() + pos);
+	CSDL_Ext::blitSurface(image.surface, image.renderArea, surface, transformPos(pos));
 	SDL_SetSurfaceAlphaMod(image.surface, 255);
 	SDL_SetSurfaceBlendMode(image.surface, oldMode);
 }
 
 void Canvas::drawScaled(const Canvas & image, const Point & pos, const Point & targetSize)
 {
-	SDL_Rect targetRect = CSDL_Ext::toSDL(Rect(pos + renderArea.topLeft(), targetSize));
+	SDL_Rect targetRect = CSDL_Ext::toSDL(Rect(transformPos(pos), transformSize(targetSize)));
 	SDL_BlitScaled(image.surface, nullptr, surface, &targetRect);
 }
 
 void Canvas::drawPoint(const Point & dest, const ColorRGBA & color)
 {
-	CSDL_Ext::putPixelWithoutRefreshIfInSurf(surface, dest.x, dest.y, color.r, color.g, color.b, color.a);
+	Point point = transformPos(dest);
+	CSDL_Ext::putPixelWithoutRefreshIfInSurf(surface, point.x, point.y, color.r, color.g, color.b, color.a);
 }
 
 void Canvas::drawLine(const Point & from, const Point & dest, const ColorRGBA & colorFrom, const ColorRGBA & colorDest)
 {
-	CSDL_Ext::drawLine(surface, renderArea.topLeft() + from, renderArea.topLeft() + dest, CSDL_Ext::toSDL(colorFrom), CSDL_Ext::toSDL(colorDest));
-}
-
-void Canvas::drawLineDashed(const Point & from, const Point & dest, const ColorRGBA & color)
-{
-	CSDL_Ext::drawLineDashed(surface, renderArea.topLeft() + from, renderArea.topLeft() + dest, CSDL_Ext::toSDL(color));
+	CSDL_Ext::drawLine(surface, transformPos(from), transformPos(dest), CSDL_Ext::toSDL(colorFrom), CSDL_Ext::toSDL(colorDest), getScalingFactor());
 }
 
 void Canvas::drawBorder(const Rect & target, const ColorRGBA & color, int width)
 {
-	Rect realTarget = target + renderArea.topLeft();
+	Rect realTarget = target * getScalingFactor() + renderArea.topLeft();
 
-	CSDL_Ext::drawBorder(surface, realTarget.x, realTarget.y, realTarget.w, realTarget.h, CSDL_Ext::toSDL(color), width);
+	CSDL_Ext::drawBorder(surface, realTarget.x, realTarget.y, realTarget.w, realTarget.h, CSDL_Ext::toSDL(color), width * getScalingFactor());
 }
 
 void Canvas::drawBorderDashed(const Rect & target, const ColorRGBA & color)
 {
-	Rect realTarget = target + renderArea.topLeft();
+	Rect realTarget = target * getScalingFactor() + renderArea.topLeft();
 
 	CSDL_Ext::drawLineDashed(surface, realTarget.topLeft(),    realTarget.topRight(),    CSDL_Ext::toSDL(color));
 	CSDL_Ext::drawLineDashed(surface, realTarget.bottomLeft(), realTarget.bottomRight(), CSDL_Ext::toSDL(color));
@@ -148,36 +170,40 @@
 
 void Canvas::drawText(const Point & position, const EFonts & font, const ColorRGBA & colorDest, ETextAlignment alignment, const std::string & text )
 {
+	const auto & fontPtr = GH.renderHandler().loadFont(font);
+
 	switch (alignment)
 	{
-	case ETextAlignment::TOPLEFT:      return graphics->fonts[font]->renderTextLeft  (surface, text, colorDest, renderArea.topLeft() + position);
-	case ETextAlignment::TOPCENTER:    return graphics->fonts[font]->renderTextCenter(surface, text, colorDest, renderArea.topLeft() + position);
-	case ETextAlignment::CENTER:       return graphics->fonts[font]->renderTextCenter(surface, text, colorDest, renderArea.topLeft() + position);
-	case ETextAlignment::BOTTOMRIGHT:  return graphics->fonts[font]->renderTextRight (surface, text, colorDest, renderArea.topLeft() + position);
+	case ETextAlignment::TOPLEFT:      return fontPtr->renderTextLeft  (surface, text, colorDest, transformPos(position));
+	case ETextAlignment::TOPCENTER:    return fontPtr->renderTextCenter(surface, text, colorDest, transformPos(position));
+	case ETextAlignment::CENTER:       return fontPtr->renderTextCenter(surface, text, colorDest, transformPos(position));
+	case ETextAlignment::BOTTOMRIGHT:  return fontPtr->renderTextRight (surface, text, colorDest, transformPos(position));
 	}
 }
 
 void Canvas::drawText(const Point & position, const EFonts & font, const ColorRGBA & colorDest, ETextAlignment alignment, const std::vector<std::string> & text )
 {
+	const auto & fontPtr = GH.renderHandler().loadFont(font);
+
 	switch (alignment)
 	{
-	case ETextAlignment::TOPLEFT:      return graphics->fonts[font]->renderTextLinesLeft  (surface, text, colorDest, renderArea.topLeft() + position);
-	case ETextAlignment::TOPCENTER:    return graphics->fonts[font]->renderTextLinesCenter(surface, text, colorDest, renderArea.topLeft() + position);
-	case ETextAlignment::CENTER:       return graphics->fonts[font]->renderTextLinesCenter(surface, text, colorDest, renderArea.topLeft() + position);
-	case ETextAlignment::BOTTOMRIGHT:  return graphics->fonts[font]->renderTextLinesRight (surface, text, colorDest, renderArea.topLeft() + position);
+	case ETextAlignment::TOPLEFT:      return fontPtr->renderTextLinesLeft  (surface, text, colorDest, transformPos(position));
+	case ETextAlignment::TOPCENTER:    return fontPtr->renderTextLinesCenter(surface, text, colorDest, transformPos(position));
+	case ETextAlignment::CENTER:       return fontPtr->renderTextLinesCenter(surface, text, colorDest, transformPos(position));
+	case ETextAlignment::BOTTOMRIGHT:  return fontPtr->renderTextLinesRight (surface, text, colorDest, transformPos(position));
 	}
 }
 
 void Canvas::drawColor(const Rect & target, const ColorRGBA & color)
 {
-	Rect realTarget = target + renderArea.topLeft();
+	Rect realTarget = target * getScalingFactor() + renderArea.topLeft();
 
 	CSDL_Ext::fillRect(surface, realTarget, CSDL_Ext::toSDL(color));
 }
 
 void Canvas::drawColorBlended(const Rect & target, const ColorRGBA & color)
 {
-	Rect realTarget = target + renderArea.topLeft();
+	Rect realTarget = target * getScalingFactor() + renderArea.topLeft();
 
 	CSDL_Ext::fillRectBlended(surface, realTarget, CSDL_Ext::toSDL(color));
 }
@@ -192,7 +218,7 @@
 	for (int y=0; y < surface->h; y+= imageArea.h)
 	{
 		for (int x=0; x < surface->w; x+= imageArea.w)
-			image->draw(surface, renderArea.x + x, renderArea.y + y);
+			image->draw(surface, Point(renderArea.x + x, renderArea.y + y));
 	}
 }
 
diff --color -urN vcmi-1.5.7/client/render/Canvas.h vcmi/client/render/Canvas.h
--- vcmi-1.5.7/client/render/Canvas.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/render/Canvas.h	2024-12-19 15:00:22.280122398 +0100
@@ -15,11 +15,21 @@
 
 struct SDL_Surface;
 class IImage;
-enum EFonts : int;
+enum EFonts : int8_t;
+
+enum class CanvasScalingPolicy
+{
+	AUTO,  // automatically scale canvas operations by global scaling factor
+	IGNORE // disable any scaling processing. Scaling factor will be set to 1
+
+};
 
 /// Class that represents surface for drawing on
 class Canvas
 {
+	/// Upscaler awareness. Must be first member for initialization
+	CanvasScalingPolicy scalingPolicy;
+
 	/// Target surface
 	SDL_Surface * surface;
 
@@ -27,27 +37,30 @@
 	Rect renderArea;
 
 	/// constructs canvas using existing surface. Caller maintains ownership on the surface
-	explicit Canvas(SDL_Surface * surface);
+	explicit Canvas(SDL_Surface * surface, CanvasScalingPolicy scalingPolicy);
 
-	/// copy contructor
+	/// copy constructor
 	Canvas(const Canvas & other);
 
+	Point transformPos(const Point & input);
+	Point transformSize(const Point & input);
+
 public:
 	Canvas & operator = (const Canvas & other) = delete;
 	Canvas & operator = (Canvas && other) = delete;
 
-	/// move contructor
+	/// move constructor
 	Canvas(Canvas && other);
 
 	/// creates canvas that only covers specified subsection of a surface
 	Canvas(const Canvas & other, const Rect & clipRect);
 
 	/// constructs canvas of specified size
-	explicit Canvas(const Point & size);
+	explicit Canvas(const Point & size, CanvasScalingPolicy scalingPolicy);
 
 	/// constructs canvas using existing surface. Caller maintains ownership on the surface
 	/// Compatibility method. AVOID USAGE. To be removed once SDL abstraction layer is finished.
-	static Canvas createFromSurface(SDL_Surface * surface);
+	static Canvas createFromSurface(SDL_Surface * surface, CanvasScalingPolicy scalingPolicy);
 
 	~Canvas();
 
@@ -78,9 +91,6 @@
 	/// renders continuous, 1-pixel wide line with color gradient
 	void drawLine(const Point & from, const Point & dest, const ColorRGBA & colorFrom, const ColorRGBA & colorDest);
 
-	/// renders dashed, 1-pixel wide line with specified color
-	void drawLineDashed(const Point & from, const Point & dest, const ColorRGBA & color);
-
 	/// renders rectangular, solid-color border in specified location
 	void drawBorder(const Rect & target, const ColorRGBA & color, int width = 1);
 
@@ -102,6 +112,8 @@
 	/// fills canvas with texture
 	void fillTexture(const std::shared_ptr<IImage>& image);
 
+	int getScalingFactor() const;
+
 	/// Compatibility method. AVOID USAGE. To be removed once SDL abstraction layer is finished.
 	SDL_Surface * getInternalSurface();
 
diff --color -urN vcmi-1.5.7/client/render/CDefFile.cpp vcmi/client/render/CDefFile.cpp
--- vcmi-1.5.7/client/render/CDefFile.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/render/CDefFile.cpp	2024-12-19 15:00:22.277122274 +0100
@@ -18,50 +18,6 @@
 
 #include <SDL_pixels.h>
 
-// Extremely simple file cache. TODO: smarter, more general solution
-class CFileCache
-{
-	static const int cacheSize = 50; //Max number of cached files
-	struct FileData
-	{
-		AnimationPath             name;
-		size_t                 size;
-		std::unique_ptr<ui8[]> data;
-
-		std::unique_ptr<ui8[]> getCopy()
-		{
-			auto ret = std::unique_ptr<ui8[]>(new ui8[size]);
-			std::copy(data.get(), data.get() + size, ret.get());
-			return ret;
-		}
-		FileData(AnimationPath name_, size_t size_, std::unique_ptr<ui8[]> data_):
-			name{std::move(name_)},
-			size{size_},
-			data{std::move(data_)}
-		{}
-	};
-
-	std::deque<FileData> cache;
-public:
-	std::unique_ptr<ui8[]> getCachedFile(AnimationPath rid)
-	{
-		for(auto & file : cache)
-		{
-			if (file.name == rid)
-				return file.getCopy();
-		}
-		// Still here? Cache miss
-		if (cache.size() > cacheSize)
-			cache.pop_front();
-
-		auto data =  CResourceHandler::get()->load(rid)->readAll();
-
-		cache.emplace_back(std::move(rid), data.second, std::move(data.first));
-
-		return cache.back().getCopy();
-	}
-};
-
 enum class DefType : uint32_t
 {
 	SPELL = 0x40,
@@ -76,55 +32,15 @@
 	BATTLE_HERO = 0x49
 };
 
-static CFileCache animationCache;
-
 /*************************************************************************
  *  DefFile, class used for def loading                                  *
  *************************************************************************/
 
-static bool colorsSimilar (const SDL_Color & lhs, const SDL_Color & rhs)
-{
-	// it seems that H3 does not requires exact match to replace colors -> (255, 103, 255) gets interpreted as shadow
-	// exact logic is not clear and requires extensive testing with image editing
-	// potential reason is that H3 uses 16-bit color format (565 RGB bits), meaning that 3 least significant bits are lost in red and blue component
-	static const int threshold = 8;
-
-	int diffR = static_cast<int>(lhs.r) - rhs.r;
-	int diffG = static_cast<int>(lhs.g) - rhs.g;
-	int diffB = static_cast<int>(lhs.b) - rhs.b;
-	int diffA = static_cast<int>(lhs.a) - rhs.a;
-
-	return std::abs(diffR) < threshold && std::abs(diffG) < threshold && std::abs(diffB) < threshold && std::abs(diffA) < threshold;
-}
-
 CDefFile::CDefFile(const AnimationPath & Name):
 	data(nullptr),
 	palette(nullptr)
 {
-	//First 8 colors in def palette used for transparency
-	static const SDL_Color sourcePalette[8] = {
-		{0,   255, 255, SDL_ALPHA_OPAQUE},
-		{255, 150, 255, SDL_ALPHA_OPAQUE},
-		{255, 100, 255, SDL_ALPHA_OPAQUE},
-		{255, 50,  255, SDL_ALPHA_OPAQUE},
-		{255, 0,   255, SDL_ALPHA_OPAQUE},
-		{255, 255, 0,   SDL_ALPHA_OPAQUE},
-		{180, 0,   255, SDL_ALPHA_OPAQUE},
-		{0,   255, 0,   SDL_ALPHA_OPAQUE}
-	};
-
-	static const SDL_Color targetPalette[8] = {
-		{0, 0, 0, 0  }, // transparency                  ( used in most images )
-		{0, 0, 0, 64 }, // shadow border                 ( used in battle, adventure map def's )
-		{0, 0, 0, 64 }, // shadow border                 ( used in fog-of-war def's )
-		{0, 0, 0, 128}, // shadow body                   ( used in fog-of-war def's )
-		{0, 0, 0, 128}, // shadow body                   ( used in battle, adventure map def's )
-		{0, 0, 0, 0  }, // selection / owner flag        ( used in battle, adventure map def's )
-		{0, 0, 0, 128}, // shadow body   below selection ( used in battle def's )
-		{0, 0, 0, 64 }  // shadow border below selection ( used in battle def's )
-	};
-
-	data = animationCache.getCachedFile(Name);
+	data = CResourceHandler::get()->load(Name)->readAll().first;
 
 	palette = std::unique_ptr<SDL_Color[]>(new SDL_Color[256]);
 	int it = 0;
@@ -145,18 +61,6 @@
 		palette[i].a = SDL_ALPHA_OPAQUE;
 	}
 
-	// these colors seems to be used unconditionally
-	palette[0] = targetPalette[0];
-	palette[1] = targetPalette[1];
-	palette[4] = targetPalette[4];
-
-	// rest of special colors are used only if their RGB values are close to H3
-	for (uint32_t i = 0; i < 8; ++i)
-	{
-		if (colorsSimilar(sourcePalette[i], palette[i]))
-			palette[i] = targetPalette[i];
-	}
-
 	for (ui32 i=0; i<totalBlocks; i++)
 	{
 		size_t blockID = read_le_u32(data.get() + it);
diff --color -urN vcmi-1.5.7/client/render/ColorFilter.cpp vcmi/client/render/ColorFilter.cpp
--- vcmi-1.5.7/client/render/ColorFilter.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/render/ColorFilter.cpp	2024-12-19 15:00:22.280122398 +0100
@@ -70,6 +70,13 @@
 				  1.f);
 }
 
+ColorFilter ColorFilter::genRangeShifter( std::vector<float> parameters )
+{
+	assert(std::size(parameters) == 6);
+
+	return genRangeShifter(parameters[0], parameters[1], parameters[2], parameters[3], parameters[4], parameters[5]);
+}
+
 ColorFilter ColorFilter::genMuxerShifter( ChannelMuxer r, ChannelMuxer g, ChannelMuxer b, float a )
 {
 	return ColorFilter(r, g, b, a);
diff --color -urN vcmi-1.5.7/client/render/ColorFilter.h vcmi/client/render/ColorFilter.h
--- vcmi-1.5.7/client/render/ColorFilter.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/render/ColorFilter.h	2024-12-19 15:00:22.281122439 +0100
@@ -44,6 +44,7 @@
 
 	/// Generates object that transforms each channel independently
 	static ColorFilter genRangeShifter( float minR, float minG, float minB, float maxR, float maxG, float maxB );
+	static ColorFilter genRangeShifter( std::vector<float> parameters );
 
 	/// Generates object that performs arbitrary mixing between any channels
 	static ColorFilter genMuxerShifter( ChannelMuxer r, ChannelMuxer g, ChannelMuxer b, float a );
diff --color -urN vcmi-1.5.7/client/render/Colors.cpp vcmi/client/render/Colors.cpp
--- vcmi-1.5.7/client/render/Colors.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/render/Colors.cpp	2024-12-19 15:00:22.281122439 +0100
@@ -15,6 +15,7 @@
 
 const ColorRGBA Colors::YELLOW = { 229, 215, 123, ColorRGBA::ALPHA_OPAQUE };
 const ColorRGBA Colors::WHITE = { 255, 243, 222, ColorRGBA::ALPHA_OPAQUE };
+const ColorRGBA Colors::WHITE_TRUE = { 255, 255, 255, ColorRGBA::ALPHA_OPAQUE };
 const ColorRGBA Colors::METALLIC_GOLD = { 173, 142, 66, ColorRGBA::ALPHA_OPAQUE };
 const ColorRGBA Colors::GREEN = { 0, 255, 0, ColorRGBA::ALPHA_OPAQUE };
 const ColorRGBA Colors::CYAN = { 0, 255, 255, ColorRGBA::ALPHA_OPAQUE };
diff --color -urN vcmi-1.5.7/client/render/Colors.h vcmi/client/render/Colors.h
--- vcmi-1.5.7/client/render/Colors.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/render/Colors.h	2024-12-19 15:00:22.282122481 +0100
@@ -23,6 +23,9 @@
 	/** the standard h3 white color */
 	static const ColorRGBA WHITE;
 
+	/** actual 100% white color */
+	static const ColorRGBA WHITE_TRUE;
+
 	/** the metallic gold color used mostly as a border around buttons */
 	static const ColorRGBA METALLIC_GOLD;
 
diff --color -urN vcmi-1.5.7/client/render/EFont.h vcmi/client/render/EFont.h
--- vcmi-1.5.7/client/render/EFont.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/render/EFont.h	2024-12-19 15:00:22.282122481 +0100
@@ -9,7 +9,15 @@
  */
 #pragma once
 
-enum EFonts : int
+enum EFonts : int8_t
 {
-	FONT_BIG, FONT_CALLI, FONT_CREDITS, FONT_HIGH_SCORE, FONT_MEDIUM, FONT_SMALL, FONT_TIMES, FONT_TINY, FONT_VERD
+	FONT_BIG,
+	FONT_CALLI,
+	FONT_CREDITS,
+	FONT_HIGH_SCORE,
+	FONT_MEDIUM,
+	FONT_SMALL,
+	FONT_TIMES,
+	FONT_TINY,
+	FONT_VERD
 };
diff --color -urN vcmi-1.5.7/client/render/Graphics.cpp vcmi/client/render/Graphics.cpp
--- vcmi-1.5.7/client/render/Graphics.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/render/Graphics.cpp	2024-12-19 15:00:22.283122522 +0100
@@ -19,26 +19,15 @@
 #include <vcmi/spells/Service.h>
 
 #include "../renderSDL/SDL_Extensions.h"
-#include "../renderSDL/CBitmapFont.h"
-#include "../renderSDL/CBitmapHanFont.h"
-#include "../renderSDL/CTrueTypeFont.h"
 #include "../render/CAnimation.h"
 #include "../render/IImage.h"
-#include "../render/IRenderHandler.h"
-#include "../gui/CGuiHandler.h"
 
 #include "../lib/filesystem/Filesystem.h"
 #include "../lib/filesystem/CBinaryReader.h"
 #include "../../lib/json/JsonNode.h"
 #include "../lib/modding/CModHandler.h"
 #include "../lib/modding/ModScope.h"
-#include "CGameInfo.h"
 #include "../lib/VCMI_Lib.h"
-#include "../CCallback.h"
-#include "../lib/CGeneralTextHandler.h"
-#include "../lib/vcmi_endian.h"
-#include "../lib/CStopWatch.h"
-#include "../lib/CHeroHandler.h"
 
 #include <SDL_surface.h>
 
@@ -127,103 +116,41 @@
 }
 Graphics::Graphics()
 {
-	loadFonts();
 	loadPaletteAndColors();
 	initializeBattleGraphics();
 	loadErmuToPicture();
-	initializeImageLists();
 
 	//(!) do not load any CAnimation here
 }
 
-void Graphics::blueToPlayersAdv(SDL_Surface * sur, PlayerColor player)
+void Graphics::setPlayerPalette(SDL_Palette * targetPalette, PlayerColor player)
 {
-	if(sur->format->palette)
+	SDL_Color palette[32];
+	if(player.isValidPlayer())
 	{
-		SDL_Color palette[32];
-		if(player.isValidPlayer())
-		{
-			for(int i=0; i<32; ++i)
-				palette[i] = CSDL_Ext::toSDL(playerColorPalette[player][i]);
-		}
-		else if(player == PlayerColor::NEUTRAL)
-		{
-			for(int i=0; i<32; ++i)
-				palette[i] = CSDL_Ext::toSDL(neutralColorPalette[i]);
-		}
-		else
-		{
-			logGlobal->error("Wrong player id in blueToPlayersAdv (%s)!", player.toString());
-			return;
-		}
-//FIXME: not all player colored images have player palette at last 32 indexes
-//NOTE: following code is much more correct but still not perfect (bugged with status bar)
-		CSDL_Ext::setColors(sur, palette, 224, 32);
-
-
-#if 0
-
-		SDL_Color * bluePalette = playerColorPalette + 32;
-
-		SDL_Palette * oldPalette = sur->format->palette;
-
-		SDL_Palette * newPalette = SDL_AllocPalette(256);
-
-		for(size_t destIndex = 0; destIndex < 256; destIndex++)
-		{
-			SDL_Color old = oldPalette->colors[destIndex];
-
-			bool found = false;
-
-			for(size_t srcIndex = 0; srcIndex < 32; srcIndex++)
-			{
-				if(old.b == bluePalette[srcIndex].b && old.g == bluePalette[srcIndex].g && old.r == bluePalette[srcIndex].r)
-				{
-					found = true;
-					newPalette->colors[destIndex] = palette[srcIndex];
-					break;
-				}
-			}
-			if(!found)
-				newPalette->colors[destIndex] = old;
-		}
-
-		SDL_SetSurfacePalette(sur, newPalette);
-
-		SDL_FreePalette(newPalette);
-
-#endif // 0
+		for(int i=0; i<32; ++i)
+			palette[i] = CSDL_Ext::toSDL(playerColorPalette[player][i]);
 	}
 	else
 	{
-		//TODO: implement. H3 method works only for images with palettes.
-		// Add some kind of player-colored overlay?
-		// Or keep palette approach here and replace only colors of specific value(s)
-		// Or just wait for OpenGL support?
-		logGlobal->warn("Image must have palette to be player-colored!");
+		for(int i=0; i<32; ++i)
+			palette[i] = CSDL_Ext::toSDL(neutralColorPalette[i]);
 	}
+
+	SDL_SetPaletteColors(targetPalette, palette, 224, 32);
 }
 
-void Graphics::loadFonts()
+void Graphics::setPlayerFlagColor(SDL_Palette * targetPalette, PlayerColor player)
 {
-	const JsonNode config(JsonPath::builtin("config/fonts.json"));
-
-	const JsonVector & bmpConf = config["bitmap"].Vector();
-	const JsonNode   & ttfConf = config["trueType"];
-	const JsonNode   & hanConf = config["bitmapHan"];
-
-	assert(bmpConf.size() == FONTS_NUMBER);
-
-	for (size_t i=0; i<FONTS_NUMBER; i++)
+	if(player.isValidPlayer())
 	{
-		std::string filename = bmpConf[i].String();
-
-		if (!hanConf[filename].isNull())
-			fonts[i] = std::make_shared<CBitmapHanFont>(hanConf[filename]);
-		else if (!ttfConf[filename].isNull()) // no ttf override
-			fonts[i] = std::make_shared<CTrueTypeFont>(ttfConf[filename]);
-		else
-			fonts[i] = std::make_shared<CBitmapFont>(filename);
+		SDL_Color color = CSDL_Ext::toSDL(playerColors[player.getNum()]);
+		SDL_SetPaletteColors(targetPalette, &color, 5, 1);
+	}
+	else
+	{
+		SDL_Color color = CSDL_Ext::toSDL(neutralColor);
+		SDL_SetPaletteColors(targetPalette, &color, 5, 1);
 	}
 }
 
@@ -244,51 +171,3 @@
 	}
 	assert (etp_idx == 44);
 }
-
-void Graphics::addImageListEntry(size_t index, size_t group, const std::string & listName, const std::string & imageName)
-{
-	if (!imageName.empty())
-	{
-		JsonNode entry;
-		if (group != 0)
-			entry["group"].Integer() = group;
-		entry["frame"].Integer() = index;
-		entry["file"].String() = imageName;
-
-		imageLists["SPRITES/" + listName]["images"].Vector().push_back(entry);
-	}
-}
-
-void Graphics::addImageListEntries(const EntityService * service)
-{
-	auto cb = std::bind(&Graphics::addImageListEntry, this, _1, _2, _3, _4);
-
-	auto loopCb = [&](const Entity * entity, bool & stop)
-	{
-		entity->registerIcons(cb);
-	};
-
-	service->forEachBase(loopCb);
-}
-
-void Graphics::initializeImageLists()
-{
-	addImageListEntries(CGI->creatures());
-	addImageListEntries(CGI->heroTypes());
-	addImageListEntries(CGI->artifacts());
-	addImageListEntries(CGI->factions());
-	addImageListEntries(CGI->spells());
-	addImageListEntries(CGI->skills());
-}
-
-std::shared_ptr<CAnimation> Graphics::getAnimation(const AnimationPath & path)
-{
-	if (cachedAnimations.count(path) != 0)
-		return cachedAnimations.at(path);
-
-	auto newAnimation = GH.renderHandler().loadAnimation(path);
-
-	newAnimation->preload();
-	cachedAnimations[path] = newAnimation;
-	return newAnimation;
-}
diff --color -urN vcmi-1.5.7/client/render/Graphics.h vcmi/client/render/Graphics.h
--- vcmi-1.5.7/client/render/Graphics.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/render/Graphics.h	2024-12-19 15:00:22.284122563 +0100
@@ -9,49 +9,20 @@
  */
 #pragma once
 
-#include "../lib/GameConstants.h"
+#include "../lib/constants/NumericConstants.h"
+#include "../lib/constants/EntityIdentifiers.h"
 #include "../lib/Color.h"
-#include "../lib/filesystem/ResourcePath.h"
 
-VCMI_LIB_NAMESPACE_BEGIN
-
-class CGHeroInstance;
-class CGTownInstance;
-class CHeroClass;
-struct InfoAboutHero;
-struct InfoAboutTown;
-class CGObjectInstance;
-class ObjectTemplate;
-class EntityService;
-class JsonNode;
-
-VCMI_LIB_NAMESPACE_END
-
-struct SDL_Surface;
-class CAnimation;
-class IFont;
+struct SDL_Palette;
 
 /// Handles fonts, hero images, town images, various graphics
 class Graphics
 {
-	void addImageListEntry(size_t index, size_t group, const std::string & listName, const std::string & imageName);
-	void addImageListEntries(const EntityService * service);
-
 	void initializeBattleGraphics();
 	void loadPaletteAndColors();
 	void loadErmuToPicture();
-	void loadFonts();
-	void initializeImageLists();
-
-	std::map<AnimationPath, std::shared_ptr<CAnimation>> cachedAnimations;
 
 public:
-	std::shared_ptr<CAnimation> getAnimation(const AnimationPath & path);
-
-	//Fonts
-	static const int FONTS_NUMBER = 9;
-	std::array< std::shared_ptr<IFont>, FONTS_NUMBER> fonts;
-
 	using PlayerPalette = std::array<ColorRGBA, 32>;
 
 	//various graphics
@@ -61,8 +32,6 @@
 	PlayerPalette neutralColorPalette;
 	ColorRGBA neutralColor;
 
-	std::map<std::string, JsonNode> imageLists;
-
 	//towns
 	std::map<int, std::string> ERMUtoPicture[GameConstants::F_NUMBER]; //maps building ID to it's picture's name for each town type
 	//for battles
@@ -71,7 +40,8 @@
 	//functions
 	Graphics();
 
-	void blueToPlayersAdv(SDL_Surface * sur, PlayerColor player); //replaces blue interface colour with a color of player
+	void setPlayerPalette(SDL_Palette * sur, PlayerColor player);
+	void setPlayerFlagColor(SDL_Palette * sur, PlayerColor player);
 };
 
 extern Graphics * graphics;
diff --color -urN vcmi-1.5.7/client/render/IFont.cpp vcmi/client/render/IFont.cpp
--- vcmi-1.5.7/client/render/IFont.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/render/IFont.cpp	2024-12-19 15:00:22.284122563 +0100
@@ -11,16 +11,45 @@
 #include "StdInc.h"
 #include "IFont.h"
 
+#include "../gui/CGuiHandler.h"
+
+#include "../render/IScreenHandler.h"
+
 #include "../../lib/Point.h"
-#include "../../lib/TextOperations.h"
+#include "../../lib/texts/TextOperations.h"
+
+int IFont::getScalingFactor() const
+{
+	return GH.screenHandler().getScalingFactor();
+}
+
+size_t IFont::getLineHeight() const
+{
+	return getLineHeightScaled() / getScalingFactor();
+}
+
+size_t IFont::getGlyphWidth(const char * data) const
+{
+	return getGlyphWidthScaled(data) / getScalingFactor();
+}
 
 size_t IFont::getStringWidth(const std::string & data) const
 {
+	return getStringWidthScaled(data) / getScalingFactor();
+}
+
+size_t IFont::getFontAscent() const
+{
+	return getFontAscentScaled() / getScalingFactor();
+}
+
+size_t IFont::getStringWidthScaled(const std::string & data) const
+{
 	size_t width = 0;
 
 	for(size_t i=0; i<data.size(); i += TextOperations::getUnicodeCharacterSize(data[i]))
 	{
-		width += getGlyphWidth(data.data() + i);
+		width += getGlyphWidthScaled(data.data() + i);
 	}
 	return width;
 }
@@ -32,13 +61,13 @@
 
 void IFont::renderTextRight(SDL_Surface * surface, const std::string & data, const ColorRGBA & color, const Point & pos) const
 {
-	Point size((int)getStringWidth(data), (int)getLineHeight());
+	Point size = Point(getStringWidth(data), getLineHeight()) * getScalingFactor();
 	renderText(surface, data, color, pos - size);
 }
 
 void IFont::renderTextCenter(SDL_Surface * surface, const std::string & data, const ColorRGBA & color, const Point & pos) const
 {
-	Point size((int)getStringWidth(data), (int)getLineHeight());
+	Point size = Point(getStringWidth(data), getLineHeight()) * getScalingFactor();
 	renderText(surface, data, color, pos - size / 2);
 }
 
@@ -49,31 +78,31 @@
 	for(const std::string & line : data)
 	{
 		renderTextLeft(surface, line, color, currPos);
-		currPos.y += (int)getLineHeight();
+		currPos.y += getLineHeight() * getScalingFactor();
 	}
 }
 
 void IFont::renderTextLinesRight(SDL_Surface * surface, const std::vector<std::string> & data, const ColorRGBA & color, const Point & pos) const
 {
 	Point currPos = pos;
-	currPos.y -= (int)data.size() * (int)getLineHeight();
+	currPos.y -= data.size() * getLineHeight() * getScalingFactor();
 
 	for(const std::string & line : data)
 	{
 		renderTextRight(surface, line, color, currPos);
-		currPos.y += (int)getLineHeight();
+		currPos.y += getLineHeight() * getScalingFactor();
 	}
 }
 
 void IFont::renderTextLinesCenter(SDL_Surface * surface, const std::vector<std::string> & data, const ColorRGBA & color, const Point & pos) const
 {
 	Point currPos = pos;
-	currPos.y -= (int)data.size() * (int)getLineHeight() / 2;
+	currPos.y -= data.size() * getLineHeight() / 2 * getScalingFactor();
 
 	for(const std::string & line : data)
 	{
 		renderTextCenter(surface, line, color, currPos);
-		currPos.y += (int)getLineHeight();
+		currPos.y += getLineHeight() * getScalingFactor();
 	}
 }
 
diff --color -urN vcmi-1.5.7/client/render/IFont.h vcmi/client/render/IFont.h
--- vcmi-1.5.7/client/render/IFont.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/render/IFont.h	2024-12-19 15:00:22.285122605 +0100
@@ -16,22 +16,38 @@
 
 struct SDL_Surface;
 
-class IFont
+class IFont : boost::noncopyable
 {
 protected:
-	/// Internal function to render font, see renderTextLeft
-	virtual void renderText(SDL_Surface * surface, const std::string & data, const ColorRGBA & color, const Point & pos) const = 0;
+
+	int getScalingFactor() const;
 
 public:
 	virtual ~IFont()
 	{}
 
 	/// Returns height of font
-	virtual size_t getLineHeight() const = 0;
+	virtual size_t getLineHeightScaled() const = 0;
 	/// Returns width, in pixels of a character glyph. Pointer must contain at least characterSize valid bytes
-	virtual size_t getGlyphWidth(const char * data) const = 0;
+	virtual size_t getGlyphWidthScaled(const char * data) const = 0;
 	/// Return width of the string
-	virtual size_t getStringWidth(const std::string & data) const;
+	virtual size_t getStringWidthScaled(const std::string & data) const;
+	/// Returns distance from top of the font glyphs to baseline
+	virtual size_t getFontAscentScaled() const = 0;
+
+	/// Returns height of font
+	size_t getLineHeight() const;
+	/// Returns width, in pixels of a character glyph. Pointer must contain at least characterSize valid bytes
+	size_t getGlyphWidth(const char * data) const;
+	/// Return width of the string
+	size_t getStringWidth(const std::string & data) const;
+	/// Returns distance from top of the font glyphs to baseline
+	size_t getFontAscent() const;
+
+	/// Internal function to render font, see renderTextLeft
+	virtual void renderText(SDL_Surface * surface, const std::string & data, const ColorRGBA & color, const Point & pos) const = 0;
+
+	virtual bool canRepresentCharacter(const char * data) const	= 0;
 
 	/**
 	 * @param surface - destination to print text on
diff --color -urN vcmi-1.5.7/client/render/IImage.h vcmi/client/render/IImage.h
--- vcmi-1.5.7/client/render/IImage.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/render/IImage.h	2024-12-19 15:00:22.286122646 +0100
@@ -21,43 +21,62 @@
 VCMI_LIB_NAMESPACE_END
 
 struct SDL_Surface;
+struct SDL_Palette;
 class ColorFilter;
+class ISharedImage;
 
 /// Defines which blit method will be selected when image is used for rendering
-enum class EImageBlitMode
+enum class EImageBlitMode : uint8_t
 {
-	/// Image can have no transparency and can be only used as background
+	/// Preferred for images that don't need any background
+	/// Indexed or RGBA: Image can have no transparency and can be only used as background
 	OPAQUE,
 
-	/// Image can have only a single color as transparency and has no semi-transparent areas
+	/// Preferred for images that may need transparency
+	/// Indexed: Image can have only a single color as transparency and has no semi-transparent areas
+	/// RGBA: full alpha transparency range, e.g. shadows
 	COLORKEY,
 
-	/// Image might have full alpha transparency range, e.g. shadows
-	ALPHA
+	/// Full transparency including shadow, but treated as a single image
+	/// Indexed: Image can have alpha transparency, e.g. shadow
+	/// RGBA: full alpha transparency range, e.g. shadows
+	/// Upscaled form: single image, no option to display shadow separately
+	SIMPLE,
+
+	/// RGBA, may consist from 2 separate parts: base and shadow, overlay not preset or treated as part of body
+	WITH_SHADOW,
+
+	/// RGBA, may consist from 3 separate parts: base, shadow, and overlay
+	WITH_SHADOW_AND_OVERLAY,
+
+	/// RGBA, contains only body, with shadow and overlay disabled
+	ONLY_BODY,
+
+	/// RGBA, contains only body, with shadow disabled and overlay treated as part of body
+	ONLY_BODY_IGNORE_OVERLAY,
+
+	/// RGBA, contains only shadow
+	ONLY_SHADOW,
+
+	/// RGBA, contains only overlay
+	ONLY_OVERLAY,
 };
 
-/*
- * Base class for images, can be used for non-animation pictures as well
- */
+/// Base class for images for use in client code.
+/// This class represents current state of image, with potential transformations applied, such as player coloring
 class IImage
 {
 public:
-	using SpecialPalette = std::vector<ColorRGBA>;
-	static constexpr int32_t SPECIAL_PALETTE_MASK_CREATURES = 0b11110011;
-
 	//draws image on surface "where" at position
-	virtual void draw(SDL_Surface * where, int posX = 0, int posY = 0, const Rect * src = nullptr) const = 0;
-	virtual void draw(SDL_Surface * where, const Rect * dest, const Rect * src) const = 0;
+	virtual void draw(SDL_Surface * where, const Point & pos, const Rect * src = nullptr) const = 0;
 
-	virtual std::shared_ptr<IImage> scaleFast(const Point & size) const = 0;
+	virtual void scaleTo(const Point & size) = 0;
+	virtual void scaleInteger(int factor) = 0;
 
 	virtual void exportBitmap(const boost::filesystem::path & path) const = 0;
 
 	//Change palette to specific player
-	virtual void playerColored(PlayerColor player)=0;
-
-	//set special color for flag
-	virtual void setFlagColor(PlayerColor player)=0;
+	virtual void playerColored(PlayerColor player) = 0;
 
 	//test transparency of specific pixel
 	virtual bool isTransparent(const Point & coords) const = 0;
@@ -69,20 +88,36 @@
 	//only indexed bitmaps, 16 colors maximum
 	virtual void shiftPalette(uint32_t firstColorID, uint32_t colorsToMove, uint32_t distanceToMove) = 0;
 	virtual void adjustPalette(const ColorFilter & shifter, uint32_t colorsToSkipMask) = 0;
-	virtual void resetPalette(int colorID) = 0;
-	virtual void resetPalette() = 0;
 
 	virtual void setAlpha(uint8_t value) = 0;
 	virtual void setBlitMode(EImageBlitMode mode) = 0;
 
 	//only indexed bitmaps with 7 special colors
-	virtual void setSpecialPallete(const SpecialPalette & SpecialPalette, uint32_t colorsToSkipMask) = 0;
+	virtual void setOverlayColor(const ColorRGBA & color) = 0;
 
-	virtual void horizontalFlip() = 0;
-	virtual void verticalFlip() = 0;
-	virtual void doubleFlip() = 0;
+	virtual std::shared_ptr<const ISharedImage> getSharedImage() const = 0;
 
-	IImage() = default;
 	virtual ~IImage() = default;
 };
 
+/// Base class for image data, mostly for internal use
+/// Represents unmodified pixel data, usually loaded from file
+/// This image can be shared between multiple image handlers (IImage instances)
+class ISharedImage
+{
+public:
+	virtual Point dimensions() const = 0;
+	virtual void exportBitmap(const boost::filesystem::path & path, SDL_Palette * palette) const = 0;
+	virtual bool isTransparent(const Point & coords) const = 0;
+	virtual void draw(SDL_Surface * where, SDL_Palette * palette, const Point & dest, const Rect * src, const ColorRGBA & colorMultiplier, uint8_t alpha, EImageBlitMode mode) const = 0;
+
+	virtual std::shared_ptr<IImage> createImageReference(EImageBlitMode mode) const = 0;
+
+	virtual std::shared_ptr<const ISharedImage> horizontalFlip() const = 0;
+	virtual std::shared_ptr<const ISharedImage> verticalFlip() const = 0;
+	virtual std::shared_ptr<const ISharedImage> scaleInteger(int factor, SDL_Palette * palette) const = 0;
+	virtual std::shared_ptr<const ISharedImage> scaleTo(const Point & size, SDL_Palette * palette) const = 0;
+
+
+	virtual ~ISharedImage() = default;
+};
diff --color -urN vcmi-1.5.7/client/render/IImageLoader.h vcmi/client/render/IImageLoader.h
--- vcmi-1.5.7/client/render/IImageLoader.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/render/IImageLoader.h	2024-12-19 15:00:22.286122646 +0100
@@ -14,8 +14,6 @@
 class Point;
 VCMI_LIB_NAMESPACE_END
 
-class SDLImage;
-
 struct SDL_Color;
 
 class IImageLoader
diff --color -urN vcmi-1.5.7/client/render/ImageLocator.cpp vcmi/client/render/ImageLocator.cpp
--- vcmi-1.5.7/client/render/ImageLocator.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/client/render/ImageLocator.cpp	2024-12-19 15:00:22.288122729 +0100
@@ -0,0 +1,137 @@
+/*
+ * ImageLocator.cpp, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#include "StdInc.h"
+#include "ImageLocator.h"
+
+#include "../gui/CGuiHandler.h"
+#include "IScreenHandler.h"
+
+#include "../../lib/json/JsonNode.h"
+
+ImageLocator::ImageLocator(const JsonNode & config)
+	: defFrame(config["defFrame"].Integer())
+	, defGroup(config["defGroup"].Integer())
+	, verticalFlip(config["verticalFlip"].Bool())
+	, horizontalFlip(config["horizontalFlip"].Bool())
+{
+	if(!config["file"].isNull())
+		image = ImagePath::fromJson(config["file"]);
+
+	if(!config["defFile"].isNull())
+		defFile = AnimationPath::fromJson(config["defFile"]);
+}
+
+ImageLocator::ImageLocator(const ImagePath & path)
+	: image(path)
+{
+}
+
+ImageLocator::ImageLocator(const AnimationPath & path, int frame, int group)
+	: defFile(path)
+	, defFrame(frame)
+	, defGroup(group)
+{
+}
+
+bool ImageLocator::operator<(const ImageLocator & other) const
+{
+	if(image != other.image)
+		return image < other.image;
+	if(defFile != other.defFile)
+		return defFile < other.defFile;
+	if(defGroup != other.defGroup)
+		return defGroup < other.defGroup;
+	if(defFrame != other.defFrame)
+		return defFrame < other.defFrame;
+	if(verticalFlip != other.verticalFlip)
+		return verticalFlip < other.verticalFlip;
+	if(horizontalFlip != other.horizontalFlip)
+		return horizontalFlip < other.horizontalFlip;
+	if(scalingFactor != other.scalingFactor)
+		return scalingFactor < other.scalingFactor;
+	if(playerColored != other.playerColored)
+		return playerColored < other.playerColored;
+	if(layer != other.layer)
+		return layer < other.layer;
+
+	return false;
+}
+
+bool ImageLocator::empty() const
+{
+	return !image.has_value() && !defFile.has_value();
+}
+
+ImageLocator ImageLocator::copyFile() const
+{
+	ImageLocator result;
+	result.scalingFactor = 1;
+	result.preScaledFactor = preScaledFactor;
+	result.image = image;
+	result.defFile = defFile;
+	result.defFrame = defFrame;
+	result.defGroup = defGroup;
+	return result;
+}
+
+ImageLocator ImageLocator::copyFileTransform() const
+{
+	ImageLocator result = copyFile();
+	result.horizontalFlip = horizontalFlip;
+	result.verticalFlip = verticalFlip;
+	return result;
+}
+
+ImageLocator ImageLocator::copyFileTransformScale() const
+{
+	return *this; // full copy
+}
+
+std::string ImageLocator::toString() const
+{
+	std::string result;
+	if (empty())
+		return "invalid";
+
+	if (image)
+	{
+		result += image->getOriginalName();
+		assert(!result.empty());
+	}
+
+	if (defFile)
+	{
+		result += defFile->getOriginalName();
+		assert(!result.empty());
+		result += "-" + std::to_string(defGroup);
+		result += "-" + std::to_string(defFrame);
+	}
+
+	if (verticalFlip)
+		result += "-vflip";
+
+	if (horizontalFlip)
+		result += "-hflip";
+
+	if (scalingFactor > 1)
+		result += "-scale" + std::to_string(scalingFactor);
+
+	if (playerColored.isValidPlayer())
+		result += "-player" + playerColored.toString();
+
+	if (layer == EImageBlitMode::ONLY_OVERLAY)
+		result += "-overlay";
+
+	if (layer == EImageBlitMode::ONLY_SHADOW)
+		result += "-shadow";
+
+
+	return result;
+}
diff --color -urN vcmi-1.5.7/client/render/ImageLocator.h vcmi/client/render/ImageLocator.h
--- vcmi-1.5.7/client/render/ImageLocator.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/client/render/ImageLocator.h	2024-12-19 15:00:22.289122770 +0100
@@ -0,0 +1,48 @@
+/*
+ * ImageLocator.h, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#pragma once
+
+#include "IImage.h"
+
+#include "../../lib/filesystem/ResourcePath.h"
+#include "../../lib/constants/EntityIdentifiers.h"
+
+struct ImageLocator
+{
+	std::optional<ImagePath> image;
+	std::optional<AnimationPath> defFile;
+	int defFrame = -1;
+	int defGroup = -1;
+
+	PlayerColor playerColored = PlayerColor::CANNOT_DETERMINE; // FIXME: treat as identical to blue to avoid double-loading?
+
+	bool verticalFlip = false;
+	bool horizontalFlip = false;
+	int8_t scalingFactor = 0; // 0 = auto / use default scaling
+	int8_t preScaledFactor = 1;
+	EImageBlitMode layer = EImageBlitMode::OPAQUE;
+
+	ImageLocator() = default;
+	ImageLocator(const AnimationPath & path, int frame, int group);
+	explicit ImageLocator(const JsonNode & config);
+	explicit ImageLocator(const ImagePath & path);
+
+	bool operator < (const ImageLocator & other) const;
+	bool empty() const;
+
+	ImageLocator copyFile() const;
+	ImageLocator copyFileTransform() const;
+	ImageLocator copyFileTransformScale() const;
+
+	// generates string representation of this image locator
+	// guaranteed to be a valid file path with no extension
+	// but may contain '/' if source file is in directory
+	std::string toString() const;
+};
diff --color -urN vcmi-1.5.7/client/render/IRenderHandler.h vcmi/client/render/IRenderHandler.h
--- vcmi-1.5.7/client/render/IRenderHandler.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/render/IRenderHandler.h	2024-12-19 15:00:22.287122687 +0100
@@ -9,30 +9,40 @@
  */
 #pragma once
 
-#include "../../lib/filesystem/ResourcePath.h"
+#include "ImageLocator.h"
+
+VCMI_LIB_NAMESPACE_BEGIN
+class Services;
+VCMI_LIB_NAMESPACE_END
 
 struct SDL_Surface;
 
+class IFont;
 class IImage;
 class CAnimation;
-enum class EImageBlitMode;
+enum class EImageBlitMode : uint8_t;
+enum EFonts : int8_t;
 
 class IRenderHandler : public boost::noncopyable
 {
 public:
 	virtual ~IRenderHandler() = default;
 
+	/// Must be called once VLC loading is over to initialize icons
+	virtual void onLibraryLoadingFinished(const Services * services) = 0;
+
 	/// Loads image using given path
-	virtual std::shared_ptr<IImage> loadImage(const ImagePath & path) = 0;
+	virtual std::shared_ptr<IImage> loadImage(const ImageLocator & locator, EImageBlitMode mode) = 0;
 	virtual std::shared_ptr<IImage> loadImage(const ImagePath & path, EImageBlitMode mode) = 0;
+	virtual std::shared_ptr<IImage> loadImage(const AnimationPath & path, int frame, int group, EImageBlitMode mode) = 0;
 
 	/// temporary compatibility method. Creates IImage from existing SDL_Surface
 	/// Surface will be shared, caller must still free it with SDL_FreeSurface
 	virtual std::shared_ptr<IImage> createImage(SDL_Surface * source) = 0;
 
 	/// Loads animation using given path
-	virtual std::shared_ptr<CAnimation> loadAnimation(const AnimationPath & path) = 0;
+	virtual std::shared_ptr<CAnimation> loadAnimation(const AnimationPath & path, EImageBlitMode mode) = 0;
 
-	/// Creates empty CAnimation
-	virtual std::shared_ptr<CAnimation> createAnimation() = 0;
+	/// Returns font with specified identifer
+	virtual std::shared_ptr<const IFont> loadFont(EFonts font) = 0;
 };
diff --color -urN vcmi-1.5.7/client/render/IScreenHandler.h vcmi/client/render/IScreenHandler.h
--- vcmi-1.5.7/client/render/IScreenHandler.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/render/IScreenHandler.h	2024-12-19 15:00:22.288122729 +0100
@@ -41,6 +41,13 @@
 	/// Dimensions of render output
 	virtual Point getRenderResolution() const = 0;
 
+	/// Dimensions of logical output. Can be different if scaling is used
+	virtual Point getLogicalResolution() const = 0;
+
+	virtual int getInterfaceScalingPercentage() const = 0;
+
+	virtual int getScalingFactor() const = 0;
+
 	/// Window has focus
 	virtual bool hasFocus() = 0;
 };
diff --color -urN vcmi-1.5.7/client/renderSDL/CBitmapFont.cpp vcmi/client/renderSDL/CBitmapFont.cpp
--- vcmi-1.5.7/client/renderSDL/CBitmapFont.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/renderSDL/CBitmapFont.cpp	2024-12-19 15:00:22.292122894 +0100
@@ -12,33 +12,96 @@
 
 #include "SDL_Extensions.h"
 #include "../CGameInfo.h"
+#include "../gui/CGuiHandler.h"
 #include "../render/Colors.h"
+#include "../render/IScreenHandler.h"
 
-#include "../../lib/Languages.h"
+#include "../../lib/CConfigHandler.h"
 #include "../../lib/Rect.h"
-#include "../../lib/TextOperations.h"
+#include "../../lib/VCMI_Lib.h"
 #include "../../lib/filesystem/Filesystem.h"
 #include "../../lib/modding/CModHandler.h"
+#include "../../lib/texts/Languages.h"
+#include "../../lib/texts/TextOperations.h"
 #include "../../lib/vcmi_endian.h"
-#include "../../lib/VCMI_Lib.h"
 
 #include <SDL_surface.h>
+#include <SDL_image.h>
 
-void CBitmapFont::loadModFont(const std::string & modName, const ResourcePath & resource)
+struct AtlasLayout
 {
-	if (!CResourceHandler::get(modName)->existsResource(resource))
+	Point dimensions;
+	std::map<int, Rect> images;
+};
+
+/// Attempts to pack provided list of images into 2d box of specified size
+/// Returns resulting layout on success and empty optional on failure
+static std::optional<AtlasLayout> tryAtlasPacking(Point dimensions, const std::map<int, Point> & images)
+{
+	// Simple atlas packing algorithm. Can be extended if needed, however optimal solution is NP-complete problem, so 'perfect' solution is too costly
+
+	AtlasLayout result;
+	result.dimensions = dimensions;
+
+	// a little interval to prevent potential 'bleeding' into adjacent symbols
+	// should be unnecessary for base game, but may be needed for upscaled filters
+	constexpr int interval = 1;
+	int currentHeight = 0;
+	int nextHeight = 0;
+	int currentWidth = 0;
+
+	for (auto const & image : images)
 	{
-		logGlobal->error("Failed to load font %s from mod %s", resource.getName(), modName);
-		return;
+		int nextWidth = currentWidth + image.second.x + interval;
+
+		if (nextWidth > dimensions.x)
+		{
+			currentHeight = nextHeight;
+			currentWidth = 0;
+			nextWidth = currentWidth + image.second.x + interval;
+		}
+
+		nextHeight = std::max(nextHeight, currentHeight + image.second.y + interval);
+		if (nextHeight > dimensions.y)
+			return std::nullopt; // failure - ran out of space
+
+		result.images[image.first] = Rect(Point(currentWidth, currentHeight), image.second);
+
+		currentWidth = nextWidth;
 	}
 
-	auto data = CResourceHandler::get(modName)->load(resource)->readAll();
-	std::string modLanguage = CGI->modh->getModLanguage(modName);
-	std::string modEncoding = Languages::getLanguageOptions(modLanguage).encoding;
+	return result;
+}
+
+/// Arranges images to fit into texture atlas with automatic selection of image size
+/// Returns images arranged into 2d box
+static AtlasLayout doAtlasPacking(const std::map<int, Point> & images)
+{
+	// initial size of an atlas. Smaller size won't even fit tiniest H3 font
+	Point dimensions(128, 128);
+
+	for (;;)
+	{
+		auto result = tryAtlasPacking(dimensions, images);
+
+		if (result)
+			return *result;
 
-	uint32_t dataHeight = data.first[5];
+		// else - packing failed. Increase atlas size and try again
+		// increase width and height in alternating form: (64,64) -> (128,64) -> (128,128) ...
+		if (dimensions.x > dimensions.y)
+			dimensions.y *= 2;
+		else
+			dimensions.x *= 2;
+	}
+}
+
+void CBitmapFont::loadFont(const ResourcePath & resource, std::unordered_map<CodePoint, EntryFNT> & loadedChars)
+{
+	auto data = CResourceHandler::get()->load(resource)->readAll();
+	std::string modEncoding = VLC->modh->findResourceEncoding(resource);
 
-	maxHeight = std::max(maxHeight, dataHeight);
+	height = data.first[5];
 
 	constexpr size_t symbolsInFile = 0x100;
 	constexpr size_t baseIndex = 32;
@@ -49,15 +112,15 @@
 	{
 		CodePoint codepoint = TextOperations::getUnicodeCodepoint(static_cast<char>(charIndex), modEncoding);
 
-		BitmapChar symbol;
+		EntryFNT symbol;
 
 		symbol.leftOffset =  read_le_u32(data.first.get() + baseIndex + charIndex * 12 + 0);
 		symbol.width =       read_le_u32(data.first.get() + baseIndex + charIndex * 12 + 4);
 		symbol.rightOffset = read_le_u32(data.first.get() + baseIndex + charIndex * 12 + 8);
-		symbol.height = dataHeight;
+		symbol.height = height;
 
 		uint32_t pixelDataOffset = read_le_u32(data.first.get() + offsetIndex + charIndex * 4);
-		uint32_t pixelsCount = dataHeight * symbol.width;
+		uint32_t pixelsCount = height * symbol.width;
 
 		symbol.pixels.resize(pixelsCount);
 
@@ -65,30 +128,107 @@
 
 		std::copy_n(pixelData, pixelsCount, symbol.pixels.data() );
 
-		chars[codepoint] = symbol;
+		loadedChars[codepoint] = symbol;
 	}
+
+	// Try to use symbol 'L' to detect font 'ascent' - number of pixels above text baseline
+	const auto & symbolL = loadedChars['L'];
+	uint32_t lastNonEmptyRow = 0;
+	for (uint32_t row = 0; row < symbolL.height; ++row)
+	{
+		for (uint32_t col = 0; col < symbolL.width; ++col)
+			if (symbolL.pixels.at(row * symbolL.width + col) == 255)
+				lastNonEmptyRow = std::max(lastNonEmptyRow, row);
+	}
+
+	ascent = lastNonEmptyRow + 1;
 }
 
 CBitmapFont::CBitmapFont(const std::string & filename):
-	maxHeight(0)
+	height(0)
 {
 	ResourcePath resource("data/" + filename, EResType::BMP_FONT);
 
-	loadModFont("core", resource);
+	std::unordered_map<CodePoint, EntryFNT> loadedChars;
+	loadFont(resource, loadedChars);
+
+	std::map<int, Point> atlasSymbol;
+	for (auto const & symbol : loadedChars)
+		atlasSymbol[symbol.first] = Point(symbol.second.width, symbol.second.height);
+
+	auto atlas = doAtlasPacking(atlasSymbol);
+
+	atlasImage = SDL_CreateRGBSurface(0, atlas.dimensions.x, atlas.dimensions.y, 8, 0, 0, 0, 0);
 
-	for(const auto & modName : VLC->modh->getActiveMods())
+	assert(atlasImage->format->palette != nullptr);
+	assert(atlasImage->format->palette->ncolors == 256);
+
+	atlasImage->format->palette->colors[0] = { 0, 255, 255, SDL_ALPHA_OPAQUE }; // transparency
+	atlasImage->format->palette->colors[1] = { 0, 0, 0, SDL_ALPHA_OPAQUE }; // black shadow
+
+	CSDL_Ext::fillSurface(atlasImage, CSDL_Ext::toSDL(Colors::CYAN));
+	CSDL_Ext::setColorKey(atlasImage, CSDL_Ext::toSDL(Colors::CYAN));
+
+	for (size_t i = 2; i < atlasImage->format->palette->ncolors; ++i)
+		atlasImage->format->palette->colors[i] = { 255, 255, 255, SDL_ALPHA_OPAQUE };
+
+	for (auto const	& symbol : loadedChars)
 	{
-		if (CResourceHandler::get(modName)->existsResource(resource))
-			loadModFont(modName, resource);
+		BitmapChar storedEntry;
+
+		storedEntry.leftOffset = symbol.second.leftOffset;
+		storedEntry.rightOffset = symbol.second.rightOffset;
+		storedEntry.positionInAtlas = atlas.images.at(symbol.first);
+
+		// Copy pixel data to atlas
+		uint8_t *dstPixels = static_cast<uint8_t*>(atlasImage->pixels);
+		uint8_t *dstLine   = dstPixels + storedEntry.positionInAtlas.y * atlasImage->pitch;
+		uint8_t *dst = dstLine + storedEntry.positionInAtlas.x;
+
+		for (size_t i = 0; i < storedEntry.positionInAtlas.h; ++i)
+		{
+			const uint8_t *srcPtr = symbol.second.pixels.data() + i * storedEntry.positionInAtlas.w;
+			uint8_t * dstPtr = dst + i * atlasImage->pitch;
+
+			std::copy_n(srcPtr, storedEntry.positionInAtlas.w, dstPtr);
+		}
+
+		chars[symbol.first] = storedEntry;
 	}
+
+	if (GH.screenHandler().getScalingFactor() != 1)
+	{
+		static const std::map<std::string, EScalingAlgorithm> filterNameToEnum = {
+			{ "nearest", EScalingAlgorithm::NEAREST},
+			{ "bilinear", EScalingAlgorithm::BILINEAR},
+			{ "xbrz", EScalingAlgorithm::XBRZ}
+		};
+
+		auto filterName = settings["video"]["fontUpscalingFilter"].String();
+		EScalingAlgorithm algorithm = filterNameToEnum.at(filterName);
+		auto scaledSurface = CSDL_Ext::scaleSurfaceIntegerFactor(atlasImage, GH.screenHandler().getScalingFactor(), algorithm);
+		SDL_FreeSurface(atlasImage);
+		atlasImage = scaledSurface;
+	}
+
+	logGlobal->debug("Loaded BMP font: '%s', height %d, ascent %d",
+					 filename,
+					 getLineHeightScaled(),
+					 getFontAscentScaled()
+					 );
 }
 
-size_t CBitmapFont::getLineHeight() const
+CBitmapFont::~CBitmapFont()
 {
-	return maxHeight;
+	SDL_FreeSurface(atlasImage);
 }
 
-size_t CBitmapFont::getGlyphWidth(const char * data) const
+size_t CBitmapFont::getLineHeightScaled() const
+{
+	return height * getScalingFactor();
+}
+
+size_t CBitmapFont::getGlyphWidthScaled(const char * data) const
 {
 	CodePoint localChar = TextOperations::getUnicodeCodepoint(data, 4);
 
@@ -97,7 +237,12 @@
 	if (iter == chars.end())
 		return 0;
 
-	return iter->second.leftOffset + iter->second.width + iter->second.rightOffset;
+	return (iter->second.leftOffset + iter->second.positionInAtlas.w + iter->second.rightOffset) * getScalingFactor();
+}
+
+size_t CBitmapFont::getFontAscentScaled() const
+{
+	return ascent * getScalingFactor();
 }
 
 bool CBitmapFont::canRepresentCharacter(const char *data) const
@@ -120,52 +265,21 @@
 
 void CBitmapFont::renderCharacter(SDL_Surface * surface, const BitmapChar & character, const ColorRGBA & color, int &posX, int &posY) const
 {
-	Rect clipRect;
-	CSDL_Ext::getClipRect(surface, clipRect);
-
-	posX += character.leftOffset;
-
-	CSDL_Ext::TColorPutter colorPutter = CSDL_Ext::getPutterFor(surface, 0);
+	int scalingFactor = GH.screenHandler().getScalingFactor();
 
-	uint8_t bpp = surface->format->BytesPerPixel;
+	posX += character.leftOffset * scalingFactor;
 
-	// start of line, may differ from 0 due to end of surface or clipped surface
-	int lineBegin = std::max<int>(0, clipRect.y - posY);
-	int lineEnd   = std::min<int>(character.height, clipRect.y + clipRect.h - posY - 1);
+	auto sdlColor = CSDL_Ext::toSDL(color);
 
-	// start end end of each row, may differ from 0
-	int rowBegin = std::max<int>(0, clipRect.x - posX);
-	int rowEnd   = std::min<int>(character.width, clipRect.x + clipRect.w - posX - 1);
+	if (atlasImage->format->palette)
+		SDL_SetPaletteColors(atlasImage->format->palette, &sdlColor, 255, 1);
+	else
+		SDL_SetSurfaceColorMod(atlasImage, color.r, color.g, color.b);
 
-	//for each line in symbol
-	for(int dy = lineBegin; dy <lineEnd; dy++)
-	{
-		uint8_t *dstLine = (uint8_t*)surface->pixels;
-		const uint8_t *srcLine = character.pixels.data();
-
-		// shift source\destination pixels to current position
-		dstLine += (posY+dy) * surface->pitch + posX * bpp;
-		srcLine += dy * character.width;
+	CSDL_Ext::blitSurface(atlasImage, character.positionInAtlas * scalingFactor, surface, Point(posX, posY));
 
-		//for each column in line
-		for(int dx = rowBegin; dx < rowEnd; dx++)
-		{
-			uint8_t* dstPixel = dstLine + dx*bpp;
-			switch(srcLine[dx])
-			{
-			case 1: //black "shadow"
-				colorPutter(dstPixel, 0, 0, 0);
-				break;
-			case 255: //text colour
-				colorPutter(dstPixel, color.r, color.g, color.b);
-				break;
-			default :
-				break; //transparency
-			}
-		}
-	}
-	posX += character.width;
-	posX += character.rightOffset;
+	posX += character.positionInAtlas.w * scalingFactor;
+	posX += character.rightOffset * scalingFactor;
 }
 
 void CBitmapFont::renderText(SDL_Surface * surface, const std::string & data, const ColorRGBA & color, const Point & pos) const
@@ -178,12 +292,6 @@
 	int posX = pos.x;
 	int posY = pos.y;
 
-	// Should be used to detect incorrect text parsing. Disabled right now due to some old UI code (mostly pregame and battles)
-	//assert(data[0] != '{');
-	//assert(data[data.size()-1] != '}');
-
-	SDL_LockSurface(surface);
-
 	for(size_t i=0; i<data.size(); i += TextOperations::getUnicodeCharacterSize(data[i]))
 	{
 		CodePoint codepoint = TextOperations::getUnicodeCodepoint(data.data() + i, data.size() - i);
@@ -193,6 +301,5 @@
 		if (iter != chars.end())
 			renderCharacter(surface, iter->second, color, posX, posY);
 	}
-	SDL_UnlockSurface(surface);
 }
 
diff --color -urN vcmi-1.5.7/client/renderSDL/CBitmapFont.h vcmi/client/renderSDL/CBitmapFont.h
--- vcmi-1.5.7/client/renderSDL/CBitmapFont.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/renderSDL/CBitmapFont.h	2024-12-19 15:00:22.293122935 +0100
@@ -11,38 +11,52 @@
 
 #include "../render/IFont.h"
 
+#include "../../lib/Rect.h"
+
 VCMI_LIB_NAMESPACE_BEGIN
 class ResourcePath;
 VCMI_LIB_NAMESPACE_END
 
-class CBitmapFont : public IFont
+class CBitmapFont final : public IFont
 {
+	SDL_Surface * atlasImage;
+
 	using CodePoint = uint32_t;
 
-	struct BitmapChar
+	struct EntryFNT
 	{
 		int32_t leftOffset;
 		uint32_t width;
 		uint32_t height;
 		int32_t rightOffset;
-		std::vector<uint8_t> pixels; // pixels of this character, part of BitmapFont::data
+		std::vector<uint8_t> pixels;
+	};
+
+	struct BitmapChar
+	{
+		Rect positionInAtlas;
+		int32_t leftOffset;
+		int32_t rightOffset;
 	};
 
 	std::unordered_map<CodePoint, BitmapChar> chars;
-	uint32_t maxHeight;
+	uint32_t height;
+	uint32_t ascent;
 
-	void loadModFont(const std::string & modName, const ResourcePath & resource);
+	void loadFont(const ResourcePath & resource, std::unordered_map<CodePoint, EntryFNT> & loadedChars);
 
 	void renderCharacter(SDL_Surface * surface, const BitmapChar & character, const ColorRGBA & color, int &posX, int &posY) const;
 	void renderText(SDL_Surface * surface, const std::string & data, const ColorRGBA & color, const Point & pos) const override;
 public:
 	explicit CBitmapFont(const std::string & filename);
+	~CBitmapFont();
 
-	size_t getLineHeight() const override;
-	size_t getGlyphWidth(const char * data) const override;
+	size_t getFontAscentScaled() const override;
+	size_t getLineHeightScaled() const override;
+	size_t getGlyphWidthScaled(const char * data) const override;
 
 	/// returns true if this font contains provided utf-8 character
-	bool canRepresentCharacter(const char * data) const;
+	bool canRepresentCharacter(const char * data) const override;
 	bool canRepresentString(const std::string & data) const;
 
 	friend class CBitmapHanFont;
diff --color -urN vcmi-1.5.7/client/renderSDL/CBitmapHanFont.cpp vcmi/client/renderSDL/CBitmapHanFont.cpp
--- vcmi-1.5.7/client/renderSDL/CBitmapHanFont.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/renderSDL/CBitmapHanFont.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,127 +0,0 @@
-/*
- * CBitmapHanFont.cpp, part of VCMI engine
- *
- * Authors: listed in file AUTHORS in main folder
- *
- * License: GNU General Public License v2.0 or later
- * Full text of license available in license.txt file, in main folder
- *
- */
-#include "StdInc.h"
-#include "CBitmapHanFont.h"
-
-#include "CBitmapFont.h"
-#include "SDL_Extensions.h"
-
-#include "../../lib/filesystem/Filesystem.h"
-#include "../../lib/json/JsonNode.h"
-#include "../../lib/TextOperations.h"
-#include "../../lib/Rect.h"
-
-#include <SDL_surface.h>
-
-size_t CBitmapHanFont::getCharacterDataOffset(size_t index) const
-{
-	size_t rowSize  = (size + 7) / 8; // 1 bit per pixel, rounded up
-	size_t charSize = rowSize * size; // glyph contains "size" rows
-	return index * charSize;
-}
-
-size_t CBitmapHanFont::getCharacterIndex(ui8 first, ui8 second) const
-{
-	if (second > 0x7f )
-		second--;
-
-	return (first - 0x81) * (12*16 - 2) + (second - 0x40);
-}
-
-void CBitmapHanFont::renderCharacter(SDL_Surface * surface, int characterIndex, const ColorRGBA & color, int &posX, int &posY) const
-{
-	//TODO: somewhat duplicated with CBitmapFont::renderCharacter();
-	Rect clipRect;
-	CSDL_Ext::getClipRect(surface, clipRect);
-
-	CSDL_Ext::TColorPutter colorPutter = CSDL_Ext::getPutterFor(surface, 0);
-	uint8_t bpp = surface->format->BytesPerPixel;
-
-	// start of line, may differ from 0 due to end of surface or clipped surface
-	int lineBegin = std::max<int>(0, clipRect.y - posY);
-	int lineEnd   = std::min((int)size, clipRect.y + clipRect.h - posY);
-
-	// start end end of each row, may differ from 0
-	int rowBegin = std::max<int>(0, clipRect.x - posX);
-	int rowEnd   = std::min<int>((int)size, clipRect.x + clipRect.w - posX);
-
-	//for each line in symbol
-	for(int dy = lineBegin; dy <lineEnd; dy++)
-	{
-		uint8_t *dstLine = (uint8_t*)surface->pixels;
-		uint8_t *source = data.first.get() + getCharacterDataOffset(characterIndex);
-
-		// shift source\destination pixels to current position
-		dstLine += (posY+dy) * surface->pitch + posX * bpp;
-		source += ((size + 7) / 8) * dy;
-
-		//for each column in line
-		for(int dx = rowBegin; dx < rowEnd; dx++)
-		{
-			// select current bit in bitmap
-			int bit = (source[dx / 8] << (dx % 8)) & 0x80;
-
-			uint8_t* dstPixel = dstLine + dx*bpp;
-			if (bit != 0)
-				colorPutter(dstPixel, color.r, color.g, color.b);
-		}
-	}
-	posX += (int)size + 1;
-}
-
-void CBitmapHanFont::renderText(SDL_Surface * surface, const std::string & data, const ColorRGBA & color, const Point & pos) const
-{
-	int posX = pos.x;
-	int posY = pos.y;
-
-	SDL_LockSurface(surface);
-
-	for(size_t i=0; i<data.size(); i += TextOperations::getUnicodeCharacterSize(data[i]))
-	{
-		std::string localChar = TextOperations::fromUnicode(data.substr(i, TextOperations::getUnicodeCharacterSize(data[i])), "GBK");
-
-		if (localChar.size() == 1)
-			fallback->renderCharacter(surface, fallback->chars[ui8(localChar[0])], color, posX, posY);
-
-		if (localChar.size() == 2)
-			renderCharacter(surface, (int)getCharacterIndex(localChar[0], localChar[1]), color, posX, posY);
-	}
-	SDL_UnlockSurface(surface);
-}
-
-CBitmapHanFont::CBitmapHanFont(const JsonNode &config):
-	fallback(new CBitmapFont(config["fallback"].String())),
-	data(CResourceHandler::get()->load(ResourcePath("data/" + config["name"].String(), EResType::OTHER))->readAll()),
-	size((size_t)config["size"].Float())
-{
-	// basic tests to make sure that fonts are OK
-	// 1) fonts must contain 190 "sections", 126 symbols each.
-	assert(getCharacterIndex(0xfe, 0xff) == 190*126);
-	// 2) ensure that font size is correct - enough to fit all possible symbols
-	assert(getCharacterDataOffset(getCharacterIndex(0xfe, 0xff)) == data.second);
-}
-
-size_t CBitmapHanFont::getLineHeight() const
-{
-	return std::max(size + 1, fallback->getLineHeight());
-}
-
-size_t CBitmapHanFont::getGlyphWidth(const char * data) const
-{
-	std::string localChar = TextOperations::fromUnicode(std::string(data, TextOperations::getUnicodeCharacterSize(data[0])), "GBK");
-
-	if (localChar.size() == 1)
-		return fallback->getGlyphWidth(data);
-
-	if (localChar.size() == 2)
-		return size + 1;
-
-	return 0;
-}
diff --color -urN vcmi-1.5.7/client/renderSDL/CBitmapHanFont.h vcmi/client/renderSDL/CBitmapHanFont.h
--- vcmi-1.5.7/client/renderSDL/CBitmapHanFont.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/renderSDL/CBitmapHanFont.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,40 +0,0 @@
-/*
- * CBitmapHanFont.h, part of VCMI engine
- *
- * Authors: listed in file AUTHORS in main folder
- *
- * License: GNU General Public License v2.0 or later
- * Full text of license available in license.txt file, in main folder
- *
- */
-#pragma once
-
-#include "../render/IFont.h"
-
-VCMI_LIB_NAMESPACE_BEGIN
-class JsonNode;
-VCMI_LIB_NAMESPACE_END
-
-class CBitmapFont;
-
-/// supports multi-byte characters for such languages like Chinese
-class CBitmapHanFont : public IFont
-{
-	std::unique_ptr<CBitmapFont> fallback;
-	// data, directly copied from file
-	const std::pair<std::unique_ptr<ui8[]>, ui64> data;
-
-	// size of the font. Not available in file but needed for proper rendering
-	const size_t size;
-
-	size_t getCharacterDataOffset(size_t index) const;
-	size_t getCharacterIndex(ui8 first, ui8 second) const;
-
-	void renderCharacter(SDL_Surface * surface, int characterIndex, const ColorRGBA & color, int &posX, int &posY) const;
-	void renderText(SDL_Surface * surface, const std::string & data, const ColorRGBA & color, const Point & pos) const override;
-public:
-	CBitmapHanFont(const JsonNode & config);
-
-	size_t getLineHeight() const override;
-	size_t getGlyphWidth(const char * data) const override;
-};
diff --color -urN vcmi-1.5.7/client/renderSDL/CTrueTypeFont.cpp vcmi/client/renderSDL/CTrueTypeFont.cpp
--- vcmi-1.5.7/client/renderSDL/CTrueTypeFont.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/renderSDL/CTrueTypeFont.cpp	2024-12-19 15:00:22.293122935 +0100
@@ -15,9 +15,10 @@
 #include "../render/Colors.h"
 #include "../renderSDL/SDL_Extensions.h"
 
-#include "../../lib/TextOperations.h"
+#include "../../lib/CConfigHandler.h"
 #include "../../lib/json/JsonNode.h"
 #include "../../lib/filesystem/Filesystem.h"
+#include "../../lib/texts/TextOperations.h"
 
 #include <SDL_ttf.h>
 
@@ -27,17 +28,26 @@
 	return CResourceHandler::get()->load(ResourcePath(filename, EResType::TTF_FONT))->readAll();
 }
 
-TTF_Font * CTrueTypeFont::loadFont(const JsonNode &config)
+int CTrueTypeFont::getPointSize(const JsonNode & config) const
 {
-	int pointSize = static_cast<int>(config["size"].Float());
+	float fontScale = settings["video"]["fontScalingFactor"].Float();
+	int scalingFactor = getScalingFactor();
+
+	if (config.isNumber())
+		return std::round(config.Integer() * scalingFactor * fontScale);
+	else
+		return std::round(config[scalingFactor-1].Integer() * fontScale);
+}
 
+TTF_Font * CTrueTypeFont::loadFont(const JsonNode &config)
+{
 	if(!TTF_WasInit() && TTF_Init()==-1)
 		throw std::runtime_error(std::string("Failed to initialize true type support: ") + TTF_GetError() + "\n");
 
-	return TTF_OpenFontRW(SDL_RWFromConstMem(data.first.get(), (int)data.second), 1, pointSize);
+	return TTF_OpenFontRW(SDL_RWFromConstMem(data.first.get(), data.second), 1, getPointSize(config["size"]));
 }
 
-int CTrueTypeFont::getFontStyle(const JsonNode &config)
+int CTrueTypeFont::getFontStyle(const JsonNode &config) const
 {
 	const JsonVector & names = config["style"].Vector();
 	int ret = 0;
@@ -54,60 +64,79 @@
 CTrueTypeFont::CTrueTypeFont(const JsonNode & fontConfig):
 	data(loadData(fontConfig)),
 	font(loadFont(fontConfig), TTF_CloseFont),
-	dropShadow(fontConfig["blend"].Bool()),
-	blended(fontConfig["blend"].Bool())
+	blended(true),
+	outline(fontConfig["outline"].Bool()),
+	dropShadow(!fontConfig["noShadow"].Bool())
 {
 	assert(font);
 
 	TTF_SetFontStyle(font.get(), getFontStyle(fontConfig));
+	TTF_SetFontHinting(font.get(),TTF_HINTING_MONO);
 
-	std::string fallbackName = fontConfig["fallback"].String();
-
-	if (!fallbackName.empty())
-		fallbackFont = std::make_unique<CBitmapFont>(fallbackName);
+	logGlobal->debug("Loaded TTF font: '%s', point size %d, height %d, ascent %d, descent %d, line skip %d",
+					 fontConfig["file"].String(),
+					 getPointSize(fontConfig["size"]),
+					 TTF_FontHeight(font.get()),
+					 TTF_FontAscent(font.get()),
+					 TTF_FontDescent(font.get()),
+					 TTF_FontLineSkip(font.get())
+	);
 }
 
 CTrueTypeFont::~CTrueTypeFont() = default;
 
-size_t CTrueTypeFont::getLineHeight() const
+size_t CTrueTypeFont::getFontAscentScaled() const
 {
-	if (fallbackFont)
-		return fallbackFont->getLineHeight();
+	return TTF_FontAscent(font.get());
+}
 
+size_t CTrueTypeFont::getLineHeightScaled() const
+{
 	return TTF_FontHeight(font.get());
 }
 
-size_t CTrueTypeFont::getGlyphWidth(const char *data) const
+size_t CTrueTypeFont::getGlyphWidthScaled(const char *text) const
 {
-	if (fallbackFont && fallbackFont->canRepresentCharacter(data))
-		return fallbackFont->getGlyphWidth(data);
-
-	return getStringWidth(std::string(data, TextOperations::getUnicodeCharacterSize(*data)));
-	int advance;
-	TTF_GlyphMetrics(font.get(), *data, nullptr, nullptr, nullptr, nullptr, &advance);
-	return advance;
+	return getStringWidthScaled(std::string(text, TextOperations::getUnicodeCharacterSize(*text)));
 }
 
-size_t CTrueTypeFont::getStringWidth(const std::string & data) const
+bool CTrueTypeFont::canRepresentCharacter(const char * text) const
 {
-	if (fallbackFont && fallbackFont->canRepresentString(data))
-		return fallbackFont->getStringWidth(data);
+	uint32_t codepoint = TextOperations::getUnicodeCodepoint(text, TextOperations::getUnicodeCharacterSize(*text));
+#if SDL_TTF_VERSION_ATLEAST(2, 0, 18)
+	return TTF_GlyphIsProvided32(font.get(), codepoint);
+#elif SDL_TTF_VERSION_ATLEAST(2, 0, 12)
+	if (codepoint <= 0xffff)
+		return TTF_GlyphIsProvided(font.get(), codepoint);
+	return true;
+#else
+	return true;
+#endif
+}
 
+size_t CTrueTypeFont::getStringWidthScaled(const std::string & text) const
+{
 	int width;
-	TTF_SizeUTF8(font.get(), data.c_str(), &width, nullptr);
+	TTF_SizeUTF8(font.get(), text.c_str(), &width, nullptr);
+
+	if (outline)
+		width += getScalingFactor();
+	if (dropShadow || outline)
+		width += getScalingFactor();
+		
 	return width;
 }
 
 void CTrueTypeFont::renderText(SDL_Surface * surface, const std::string & data, const ColorRGBA & color, const Point & pos) const
 {
-	if (fallbackFont && fallbackFont->canRepresentString(data))
+	if (color.r != 0 && color.g != 0 && color.b != 0) // not black - add shadow
 	{
-		fallbackFont->renderText(surface, data, color, pos);
-		return;
-	}
+		if (outline)
+			renderText(surface, data, Colors::BLACK, pos - Point(1,1) * getScalingFactor());
 
-	if (dropShadow && color.r != 0 && color.g != 0 && color.b != 0) // not black - add shadow
-		renderText(surface, data, Colors::BLACK, pos + Point(1,1));
+		if (dropShadow || outline)
+			renderText(surface, data, Colors::BLACK, pos + Point(1,1) * getScalingFactor());
+	}
 
 	if (!data.empty())
 	{
diff --color -urN vcmi-1.5.7/client/renderSDL/CTrueTypeFont.h vcmi/client/renderSDL/CTrueTypeFont.h
--- vcmi-1.5.7/client/renderSDL/CTrueTypeFont.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/renderSDL/CTrueTypeFont.h	2024-12-19 15:00:22.294122977 +0100
@@ -19,25 +19,29 @@
 
 using TTF_Font = struct _TTF_Font;
 
-class CTrueTypeFont : public IFont
+class CTrueTypeFont final : public IFont
 {
-	std::unique_ptr<CBitmapFont> fallbackFont;
 	const std::pair<std::unique_ptr<ui8[]>, ui64> data;
 
 	const std::unique_ptr<TTF_Font, void (*)(TTF_Font*)> font;
 	const bool blended;
+	const bool outline;
 	const bool dropShadow;
 
 	std::pair<std::unique_ptr<ui8[]>, ui64> loadData(const JsonNode & config);
 	TTF_Font * loadFont(const JsonNode & config);
-	int getFontStyle(const JsonNode & config);
+	int getPointSize(const JsonNode & config) const;
+	int getFontStyle(const JsonNode & config) const;
 
 	void renderText(SDL_Surface * surface, const std::string & data, const ColorRGBA & color, const Point & pos) const override;
+	size_t getFontAscentScaled() const override;
 public:
 	CTrueTypeFont(const JsonNode & fontConfig);
 	~CTrueTypeFont();
 
-	size_t getLineHeight() const override;
-	size_t getGlyphWidth(const char * data) const override;
-	size_t getStringWidth(const std::string & data) const override;
+	bool canRepresentCharacter(const char * data) const override;
+
+	size_t getLineHeightScaled() const override;
+	size_t getGlyphWidthScaled(const char * data) const override;
+	size_t getStringWidthScaled(const std::string & data) const override;
 };
diff --color -urN vcmi-1.5.7/client/renderSDL/CursorHardware.cpp vcmi/client/renderSDL/CursorHardware.cpp
--- vcmi-1.5.7/client/renderSDL/CursorHardware.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/renderSDL/CursorHardware.cpp	2024-12-19 15:00:22.294122977 +0100
@@ -11,11 +11,14 @@
 #include "StdInc.h"
 #include "CursorHardware.h"
 
+#include "SDL_Extensions.h"
+
 #include "../gui/CGuiHandler.h"
-#include "../renderSDL/ScreenHandler.h"
+#include "../render/IScreenHandler.h"
 #include "../render/Colors.h"
 #include "../render/IImage.h"
-#include "SDL_Extensions.h"
+
+#include "../../lib/CConfigHandler.h"
 
 #include <SDL_render.h>
 #include <SDL_events.h>
@@ -45,19 +48,28 @@
 
 void CursorHardware::setImage(std::shared_ptr<IImage> image, const Point & pivotOffset)
 {
-	auto cursorSurface = CSDL_Ext::newSurface(image->dimensions().x, image->dimensions().y);
+	int videoScalingSettings = GH.screenHandler().getInterfaceScalingPercentage();
+	float cursorScalingSettings = settings["video"]["cursorScalingFactor"].Float();
+	int cursorScalingPercent = videoScalingSettings * cursorScalingSettings;
+	Point cursorDimensions = image->dimensions() * GH.screenHandler().getScalingFactor();
+	Point cursorDimensionsScaled = image->dimensions() * cursorScalingPercent / 100;
+	Point pivotOffsetScaled = pivotOffset * cursorScalingPercent / 100 / GH.screenHandler().getScalingFactor();
+
+	auto cursorSurface = CSDL_Ext::newSurface(cursorDimensions);
 
 	CSDL_Ext::fillSurface(cursorSurface, CSDL_Ext::toSDL(Colors::TRANSPARENCY));
 
-	image->draw(cursorSurface);
+	image->draw(cursorSurface, Point(0,0));
+	auto cursorSurfaceScaled = CSDL_Ext::scaleSurface(cursorSurface, cursorDimensionsScaled.x, cursorDimensionsScaled.y );
 
 	auto oldCursor = cursor;
-	cursor = SDL_CreateColorCursor(cursorSurface, pivotOffset.x, pivotOffset.y);
+	cursor = SDL_CreateColorCursor(cursorSurfaceScaled, pivotOffsetScaled.x, pivotOffsetScaled.y);
 
 	if (!cursor)
 		logGlobal->error("Failed to set cursor! SDL says %s", SDL_GetError());
 
 	SDL_FreeSurface(cursorSurface);
+	SDL_FreeSurface(cursorSurfaceScaled);
 
 	GH.dispatchMainThread([this, oldCursor](){
 		SDL_SetCursor(cursor);
diff --color -urN vcmi-1.5.7/client/renderSDL/CursorHardware.h vcmi/client/renderSDL/CursorHardware.h
--- vcmi-1.5.7/client/renderSDL/CursorHardware.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/renderSDL/CursorHardware.h	2024-12-19 15:00:22.295123018 +0100
@@ -9,7 +9,6 @@
  */
 #pragma once
 
-class CAnimation;
 class IImage;
 struct SDL_Surface;
 struct SDL_Texture;
diff --color -urN vcmi-1.5.7/client/renderSDL/CursorSoftware.cpp vcmi/client/renderSDL/CursorSoftware.cpp
--- vcmi-1.5.7/client/renderSDL/CursorSoftware.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/renderSDL/CursorSoftware.cpp	2024-12-19 15:00:22.295123018 +0100
@@ -11,6 +11,8 @@
 #include "StdInc.h"
 #include "CursorSoftware.h"
 
+#include "../gui/CGuiHandler.h"
+#include "../render/IScreenHandler.h"
 #include "../render/Colors.h"
 #include "../render/IImage.h"
 #include "../CMT.h"
@@ -30,8 +32,8 @@
 	SDL_Rect destRect;
 	destRect.x = renderPos.x;
 	destRect.y = renderPos.y;
-	destRect.w = 40;
-	destRect.h = 40;
+	destRect.w = cursorSurface->w;
+	destRect.h = cursorSurface->h;
 
 	SDL_RenderCopy(mainRenderer, cursorTexture, nullptr, &destRect);
 }
@@ -44,7 +46,7 @@
 	if (cursorSurface)
 		SDL_FreeSurface(cursorSurface);
 
-	cursorSurface = CSDL_Ext::newSurface(dimensions.x, dimensions.y);
+	cursorSurface = CSDL_Ext::newSurface(dimensions);
 	cursorTexture = SDL_CreateTexture(mainRenderer, SDL_PIXELFORMAT_ARGB8888, SDL_TEXTUREACCESS_STREAMING, dimensions.x, dimensions.y);
 
 	SDL_SetSurfaceBlendMode(cursorSurface, SDL_BLENDMODE_NONE);
@@ -53,12 +55,17 @@
 
 void CursorSoftware::updateTexture()
 {
-	if (!cursorSurface ||  Point(cursorSurface->w, cursorSurface->h) != cursorImage->dimensions())
-		createTexture(cursorImage->dimensions());
+	if (!cursorSurface)
+		createTexture(cursorImage->dimensions() * GH.screenHandler().getScalingFactor());
+
+	Point currentSize = Point(cursorSurface->w, cursorSurface->h);
+
+	if (currentSize != cursorImage->dimensions() * GH.screenHandler().getScalingFactor())
+		createTexture(cursorImage->dimensions() * GH.screenHandler().getScalingFactor());
 
 	CSDL_Ext::fillSurface(cursorSurface, CSDL_Ext::toSDL(Colors::TRANSPARENCY));
 
-	cursorImage->draw(cursorSurface);
+	cursorImage->draw(cursorSurface, Point(0,0));
 	SDL_UpdateTexture(cursorTexture, nullptr, cursorSurface->pixels, cursorSurface->pitch);
 	needUpdate = false;
 }
diff --color -urN vcmi-1.5.7/client/renderSDL/CursorSoftware.h vcmi/client/renderSDL/CursorSoftware.h
--- vcmi-1.5.7/client/renderSDL/CursorSoftware.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/renderSDL/CursorSoftware.h	2024-12-19 15:00:22.295123018 +0100
@@ -9,7 +9,6 @@
  */
 #pragma once
 
-class CAnimation;
 class IImage;
 struct SDL_Surface;
 struct SDL_Texture;
diff --color -urN vcmi-1.5.7/client/renderSDL/FontChain.cpp vcmi/client/renderSDL/FontChain.cpp
--- vcmi-1.5.7/client/renderSDL/FontChain.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/client/renderSDL/FontChain.cpp	2024-12-19 15:00:22.295123018 +0100
@@ -0,0 +1,152 @@
+/*
+ * FontChain.cpp, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#include "StdInc.h"
+#include "FontChain.h"
+
+#include "CTrueTypeFont.h"
+#include "CBitmapFont.h"
+
+#include "../CGameInfo.h"
+
+#include "../../lib/CConfigHandler.h"
+#include "../../lib/modding/CModHandler.h"
+#include "../../lib/texts/TextOperations.h"
+#include "../../lib/texts/CGeneralTextHandler.h"
+#include "../../lib/texts/Languages.h"
+
+void FontChain::renderText(SDL_Surface * surface, const std::string & data, const ColorRGBA & color, const Point & pos) const
+{
+	auto chunks = splitTextToChunks(data);
+	int maxAscent = getFontAscentScaled();
+	Point currentPos = pos;
+	for (auto const & chunk : chunks)
+	{
+		Point chunkPos = currentPos;
+		int currAscent = chunk.font->getFontAscentScaled();
+		chunkPos.y += maxAscent - currAscent;
+		chunk.font->renderText(surface, chunk.text, color, chunkPos);
+		currentPos.x += chunk.font->getStringWidthScaled(chunk.text);
+	}
+}
+
+size_t FontChain::getFontAscentScaled() const
+{
+	size_t maxHeight = 0;
+	for(const auto & font : chain)
+		maxHeight = std::max(maxHeight, font->getFontAscentScaled());
+	return maxHeight;
+}
+
+bool FontChain::bitmapFontsPrioritized(const std::string & bitmapFontName) const
+{
+	const std::string & fontType = settings["video"]["fontsType"].String();
+	if (fontType == "original")
+		return true;
+	if (fontType == "scalable")
+		return false;
+
+	// else - autoselection.
+
+	if (getScalingFactor() != 1)
+		return false; // If xbrz in use ttf/scalable fonts are preferred
+
+	if (!vstd::isAlmostEqual(1.0, settings["video"]["fontScalingFactor"].Float()))
+		return false; // If player requested non-100% scaling - use scalable fonts
+
+	std::string gameLanguage = CGI->generaltexth->getPreferredLanguage();
+	std::string gameEncoding = Languages::getLanguageOptions(gameLanguage).encoding;
+	std::string fontEncoding = CGI->modh->findResourceEncoding(ResourcePath("data/" + bitmapFontName, EResType::BMP_FONT));
+
+	// player uses language with different encoding than his bitmap fonts
+	// for example, Polish language with English fonts or Chinese language which can't use H3 fonts at all
+	// this may result in unintended mixing of ttf and bitmap fonts, which may have a bit different look
+	// so in this case prefer ttf fonts that are likely to cover target language better than H3 fonts
+	if (fontEncoding != gameEncoding)
+		return false;
+
+	return true; // else - use original bitmap fonts
+}
+
+void FontChain::addTrueTypeFont(const JsonNode & trueTypeConfig)
+{
+	chain.insert(chain.begin(), std::make_unique<CTrueTypeFont>(trueTypeConfig));
+}
+
+void FontChain::addBitmapFont(const std::string & bitmapFilename)
+{
+	if (bitmapFontsPrioritized(bitmapFilename))
+		chain.insert(chain.begin(), std::make_unique<CBitmapFont>(bitmapFilename));
+	else
+		chain.push_back(std::make_unique<CBitmapFont>(bitmapFilename));
+}
+
+bool FontChain::canRepresentCharacter(const char * data) const
+{
+	for(const auto & font : chain)
+		if (font->canRepresentCharacter(data))
+			return true;
+	return false;
+}
+
+size_t FontChain::getLineHeightScaled() const
+{
+	size_t maxHeight = 0;
+	for(const auto & font : chain)
+		maxHeight = std::max(maxHeight, font->getLineHeightScaled());
+	return maxHeight;
+}
+
+size_t FontChain::getGlyphWidthScaled(const char * data) const
+{
+	for(const auto & font : chain)
+		if (font->canRepresentCharacter(data))
+			return font->getGlyphWidthScaled(data);
+	return 0;
+}
+
+std::vector<FontChain::TextChunk> FontChain::splitTextToChunks(const std::string & data) const
+{
+	std::vector<TextChunk> chunks;
+
+	for (size_t i = 0; i < data.size(); i += TextOperations::getUnicodeCharacterSize(data[i]))
+	{
+		const IFont * currentFont = nullptr;
+		for(const auto & font : chain)
+		{
+			if (font->canRepresentCharacter(data.data() + i))
+			{
+				currentFont = font.get();
+				break;
+			}
+		}
+
+		if (currentFont == nullptr)
+			continue; // not representable
+
+		std::string symbol = data.substr(i, TextOperations::getUnicodeCharacterSize(data[i]));
+
+		if (chunks.empty() || chunks.back().font != currentFont)
+			chunks.push_back({currentFont, symbol});
+		else
+			chunks.back().text += symbol;
+	}
+
+	return chunks;
+}
+
+size_t FontChain::getStringWidthScaled(const std::string & data) const
+{
+	size_t result = 0;
+	auto chunks = splitTextToChunks(data);
+	for (auto const & chunk : chunks)
+		result += chunk.font->getStringWidthScaled(chunk.text);
+
+	return result;
+}
diff --color -urN vcmi-1.5.7/client/renderSDL/FontChain.h vcmi/client/renderSDL/FontChain.h
--- vcmi-1.5.7/client/renderSDL/FontChain.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/client/renderSDL/FontChain.h	2024-12-19 15:00:22.296123059 +0100
@@ -0,0 +1,43 @@
+/*
+ * FontChain.h, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#pragma once
+
+#include "../render/IFont.h"
+
+VCMI_LIB_NAMESPACE_BEGIN
+class JsonNode;
+VCMI_LIB_NAMESPACE_END
+
+class FontChain final : public IFont
+{
+	struct TextChunk
+	{
+		const IFont * font;
+		std::string text;
+	};
+
+	std::vector<TextChunk> splitTextToChunks(const std::string & data) const;
+
+	std::vector<std::unique_ptr<IFont>> chain;
+
+	void renderText(SDL_Surface * surface, const std::string & data, const ColorRGBA & color, const Point & pos) const override;
+	size_t getFontAscentScaled() const override;
+	bool bitmapFontsPrioritized(const std::string & bitmapFontName) const;
+public:
+	FontChain() = default;
+
+	void addTrueTypeFont(const JsonNode & trueTypeConfig);
+	void addBitmapFont(const std::string & bitmapFilename);
+
+	size_t getLineHeightScaled() const override;
+	size_t getGlyphWidthScaled(const char * data) const override;
+	size_t getStringWidthScaled(const std::string & data) const override;
+	bool canRepresentCharacter(const char * data) const override;
+};
diff --color -urN vcmi-1.5.7/client/renderSDL/ImageScaled.cpp vcmi/client/renderSDL/ImageScaled.cpp
--- vcmi-1.5.7/client/renderSDL/ImageScaled.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/client/renderSDL/ImageScaled.cpp	2024-12-19 15:00:22.297123101 +0100
@@ -0,0 +1,165 @@
+/*
+ * ImageScaled.cpp, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#include "StdInc.h"
+#include "ImageScaled.h"
+
+#include "SDLImage.h"
+#include "SDL_Extensions.h"
+
+#include "../gui/CGuiHandler.h"
+#include "../render/IScreenHandler.h"
+#include "../render/Colors.h"
+
+#include "../../lib/constants/EntityIdentifiers.h"
+
+#include <SDL_surface.h>
+
+ImageScaled::ImageScaled(const ImageLocator & inputLocator, const std::shared_ptr<const ISharedImage> & source, EImageBlitMode mode)
+	: source(source)
+	, locator(inputLocator)
+	, colorMultiplier(Colors::WHITE_TRUE)
+	, alphaValue(SDL_ALPHA_OPAQUE)
+	, blitMode(mode)
+{
+	prepareImages();
+}
+
+std::shared_ptr<const ISharedImage> ImageScaled::getSharedImage() const
+{
+	return body;
+}
+
+void ImageScaled::scaleInteger(int factor)
+{
+	assert(0);
+}
+
+void ImageScaled::scaleTo(const Point & size)
+{
+	if (body)
+		body = body->scaleTo(size * GH.screenHandler().getScalingFactor(), nullptr);
+}
+
+void ImageScaled::exportBitmap(const boost::filesystem::path &path) const
+{
+	source->exportBitmap(path, nullptr);
+}
+
+bool ImageScaled::isTransparent(const Point &coords) const
+{
+	return source->isTransparent(coords);
+}
+
+Point ImageScaled::dimensions() const
+{
+	return source->dimensions();
+}
+
+void ImageScaled::setAlpha(uint8_t value)
+{
+	alphaValue = value;
+}
+
+void ImageScaled::setBlitMode(EImageBlitMode mode)
+{
+	blitMode = mode;
+}
+
+void ImageScaled::draw(SDL_Surface *where, const Point &pos, const Rect *src) const
+{
+	if (shadow)
+		shadow->draw(where, nullptr, pos, src, Colors::WHITE_TRUE, alphaValue, blitMode);
+	if (body)
+		body->draw(where, nullptr, pos, src, Colors::WHITE_TRUE, alphaValue, blitMode);
+	if (overlay)
+		overlay->draw(where, nullptr, pos, src, colorMultiplier, colorMultiplier.a * alphaValue / 255, blitMode);
+}
+
+void ImageScaled::setOverlayColor(const ColorRGBA & color)
+{
+	colorMultiplier = color;
+}
+
+void ImageScaled::playerColored(PlayerColor player)
+{
+	playerColor = player;
+	prepareImages();
+}
+
+void ImageScaled::shiftPalette(uint32_t firstColorID, uint32_t colorsToMove, uint32_t distanceToMove)
+{
+	// TODO: implement
+}
+
+void ImageScaled::adjustPalette(const ColorFilter &shifter, uint32_t colorsToSkipMask)
+{
+	// TODO: implement
+}
+
+void ImageScaled::prepareImages()
+{
+	switch(blitMode)
+	{
+		case EImageBlitMode::OPAQUE:
+		case EImageBlitMode::COLORKEY:
+		case EImageBlitMode::SIMPLE:
+			locator.layer = blitMode;
+			locator.playerColored = playerColor;
+			body = GH.renderHandler().loadImage(locator, blitMode)->getSharedImage();
+			break;
+
+		case EImageBlitMode::WITH_SHADOW_AND_OVERLAY:
+		case EImageBlitMode::ONLY_BODY:
+			locator.layer = EImageBlitMode::ONLY_BODY;
+			locator.playerColored = playerColor;
+			body = GH.renderHandler().loadImage(locator, blitMode)->getSharedImage();
+			break;
+
+		case EImageBlitMode::WITH_SHADOW:
+		case EImageBlitMode::ONLY_BODY_IGNORE_OVERLAY:
+			locator.layer = EImageBlitMode::ONLY_BODY_IGNORE_OVERLAY;
+			locator.playerColored = playerColor;
+			body = GH.renderHandler().loadImage(locator, blitMode)->getSharedImage();
+			break;
+
+		case EImageBlitMode::ONLY_SHADOW:
+		case EImageBlitMode::ONLY_OVERLAY:
+			body = nullptr;
+			break;
+	}
+
+	switch(blitMode)
+	{
+		case EImageBlitMode::SIMPLE:
+		case EImageBlitMode::WITH_SHADOW:
+		case EImageBlitMode::ONLY_SHADOW:
+		case EImageBlitMode::WITH_SHADOW_AND_OVERLAY:
+			locator.layer = EImageBlitMode::ONLY_SHADOW;
+			locator.playerColored = PlayerColor::CANNOT_DETERMINE;
+			shadow = GH.renderHandler().loadImage(locator, blitMode)->getSharedImage();
+			break;
+		default:
+			shadow = nullptr;
+			break;
+	}
+
+	switch(blitMode)
+	{
+		case EImageBlitMode::ONLY_OVERLAY:
+		case EImageBlitMode::WITH_SHADOW_AND_OVERLAY:
+			locator.layer = EImageBlitMode::ONLY_OVERLAY;
+			locator.playerColored = PlayerColor::CANNOT_DETERMINE;
+			overlay = GH.renderHandler().loadImage(locator, blitMode)->getSharedImage();
+			break;
+		default:
+			overlay = nullptr;
+			break;
+	}
+}
diff --color -urN vcmi-1.5.7/client/renderSDL/ImageScaled.h vcmi/client/renderSDL/ImageScaled.h
--- vcmi-1.5.7/client/renderSDL/ImageScaled.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/client/renderSDL/ImageScaled.h	2024-12-19 15:00:22.298123142 +0100
@@ -0,0 +1,65 @@
+/*
+ * ImageScaled.h, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#pragma once
+
+#include "../render/IImage.h"
+#include "../render/IRenderHandler.h"
+
+#include "../../lib/Color.h"
+#include "../../lib/constants/EntityIdentifiers.h"
+
+struct SDL_Palette;
+
+class SDLImageShared;
+
+// Upscaled image with several mechanisms to emulate H3 palette effects
+class ImageScaled final : public IImage
+{
+private:
+
+	/// Original unscaled image
+	std::shared_ptr<const ISharedImage> source;
+
+	/// Upscaled shadow of our image, may be null
+	std::shared_ptr<const ISharedImage> shadow;
+
+	/// Upscaled main part of our image, may be null
+	std::shared_ptr<const ISharedImage> body;
+
+	/// Upscaled overlay (player color, selection highlight) of our image, may be null
+	std::shared_ptr<const ISharedImage> overlay;
+
+	ImageLocator locator;
+
+	ColorRGBA colorMultiplier;
+	PlayerColor playerColor = PlayerColor::CANNOT_DETERMINE;
+
+	uint8_t alphaValue;
+	EImageBlitMode blitMode;
+
+	void prepareImages();
+public:
+	ImageScaled(const ImageLocator & locator, const std::shared_ptr<const ISharedImage> & source, EImageBlitMode mode);
+
+	void scaleInteger(int factor) override;
+	void scaleTo(const Point & size) override;
+	void exportBitmap(const boost::filesystem::path & path) const override;
+	bool isTransparent(const Point & coords) const override;
+	Point dimensions() const override;
+	void setAlpha(uint8_t value) override;
+	void setBlitMode(EImageBlitMode mode) override;
+	void draw(SDL_Surface * where, const Point & pos, const Rect * src) const override;
+	void setOverlayColor(const ColorRGBA & color) override;
+	void playerColored(PlayerColor player) override;
+	void shiftPalette(uint32_t firstColorID, uint32_t colorsToMove, uint32_t distanceToMove) override;
+	void adjustPalette(const ColorFilter & shifter, uint32_t colorsToSkipMask) override;
+
+	std::shared_ptr<const ISharedImage> getSharedImage() const override;
+};
diff --color -urN vcmi-1.5.7/client/renderSDL/RenderHandler.cpp vcmi/client/renderSDL/RenderHandler.cpp
--- vcmi-1.5.7/client/renderSDL/RenderHandler.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/renderSDL/RenderHandler.cpp	2024-12-19 15:00:22.299123183 +0100
@@ -10,31 +10,455 @@
 #include "StdInc.h"
 #include "RenderHandler.h"
 
-#include "../render/CAnimation.h"
 #include "SDLImage.h"
+#include "ImageScaled.h"
+#include "FontChain.h"
+
+#include "../gui/CGuiHandler.h"
+
+#include "../render/CAnimation.h"
+#include "../render/CDefFile.h"
+#include "../render/Colors.h"
+#include "../render/ColorFilter.h"
+#include "../render/IScreenHandler.h"
+#include "../../lib/json/JsonUtils.h"
+#include "../../lib/filesystem/Filesystem.h"
+#include "../../lib/VCMIDirs.h"
+
+#include <vcmi/ArtifactService.h>
+#include <vcmi/CreatureService.h>
+#include <vcmi/Entity.h>
+#include <vcmi/FactionService.h>
+#include <vcmi/HeroTypeService.h>
+#include <vcmi/Services.h>
+#include <vcmi/SkillService.h>
+#include <vcmi/spells/Service.h>
+
+std::shared_ptr<CDefFile> RenderHandler::getAnimationFile(const AnimationPath & path)
+{
+	AnimationPath actualPath = boost::starts_with(path.getName(), "SPRITES") ? path : path.addPrefix("SPRITES/");
+
+	auto it = animationFiles.find(actualPath);
+
+	if (it != animationFiles.end())
+		return it->second;
+
+	if (!CResourceHandler::get()->existsResource(actualPath))
+	{
+		animationFiles[actualPath] = nullptr;
+		return nullptr;
+	}
+
+	auto result = std::make_shared<CDefFile>(actualPath);
+
+	animationFiles[actualPath] = result;
+	return result;
+}
+
+std::optional<ResourcePath> RenderHandler::getPathForScaleFactor(const ResourcePath & path, const std::string & factor)
+{
+	if(path.getType() == EResType::IMAGE)
+	{
+		auto p = ImagePath::builtin(path.getName());
+		if(CResourceHandler::get()->existsResource(p.addPrefix("SPRITES" + factor + "X/")))
+			return std::optional<ResourcePath>(p.addPrefix("SPRITES" + factor + "X/"));
+		if(CResourceHandler::get()->existsResource(p.addPrefix("DATA" + factor + "X/")))
+			return std::optional<ResourcePath>(p.addPrefix("DATA" + factor + "X/"));
+	}
+	else
+	{
+		auto p = AnimationPath::builtin(path.getName());
+		auto pJson = p.toType<EResType::JSON>();
+		if(CResourceHandler::get()->existsResource(p.addPrefix("SPRITES" + factor + "X/")))
+			return std::optional<ResourcePath>(p.addPrefix("SPRITES" + factor + "X/"));
+		if(CResourceHandler::get()->existsResource(pJson))
+			return std::optional<ResourcePath>(p);
+		if(CResourceHandler::get()->existsResource(pJson.addPrefix("SPRITES" + factor + "X/")))
+			return std::optional<ResourcePath>(p.addPrefix("SPRITES" + factor + "X/"));
+	}
+
+	return std::nullopt;
+}
+
+std::pair<ResourcePath, int> RenderHandler::getScalePath(const ResourcePath & p)
+{
+	auto path = p;
+	int scaleFactor = 1;
+	if(getScalingFactor() > 1)
+	{
+		std::vector<int> factorsToCheck = {getScalingFactor(), 4, 3, 2};
+		for(auto factorToCheck : factorsToCheck)
+		{
+			std::string name = boost::algorithm::to_upper_copy(p.getName());
+			boost::replace_all(name, "SPRITES/", std::string("SPRITES") + std::to_string(factorToCheck) + std::string("X/"));
+			boost::replace_all(name, "DATA/", std::string("DATA") + std::to_string(factorToCheck) + std::string("X/"));
+			ResourcePath scaledPath = ImagePath::builtin(name);
+			if(p.getType() != EResType::IMAGE)
+				scaledPath = AnimationPath::builtin(name);
+			auto tmpPath = getPathForScaleFactor(scaledPath, std::to_string(factorToCheck));
+			if(tmpPath)
+			{
+				path = *tmpPath;
+				scaleFactor = factorToCheck;
+				break;
+			}
+		}
+	}
+
+	return std::pair<ResourcePath, int>(path, scaleFactor);
+};
+
+void RenderHandler::initFromJson(AnimationLayoutMap & source, const JsonNode & config)
+{
+	std::string basepath;
+	basepath = config["basepath"].String();
+
+	JsonNode base;
+	base["margins"] = config["margins"];
+	base["width"] = config["width"];
+	base["height"] = config["height"];
+
+	for(const JsonNode & group : config["sequences"].Vector())
+	{
+		size_t groupID = group["group"].Integer();//TODO: string-to-value conversion("moving" -> MOVING)
+		source[groupID].clear();
+
+		for(const JsonNode & frame : group["frames"].Vector())
+		{
+			JsonNode toAdd = frame;
+			JsonUtils::inherit(toAdd, base);
+			toAdd["file"].String() = basepath + frame.String();
+			source[groupID].emplace_back(toAdd);
+		}
+	}
+
+	for(const JsonNode & node : config["images"].Vector())
+	{
+		size_t group = node["group"].Integer();
+		size_t frame = node["frame"].Integer();
+
+		if (source[group].size() <= frame)
+			source[group].resize(frame+1);
+
+		JsonNode toAdd = node;
+		JsonUtils::inherit(toAdd, base);
+
+		if (toAdd.Struct().count("file"))
+			toAdd["file"].String() = basepath + node["file"].String();
+
+		if (toAdd.Struct().count("defFile"))
+			toAdd["defFile"].String() = basepath + node["defFile"].String();
+
+		source[group][frame] = ImageLocator(toAdd);
+	}
+}
+
+RenderHandler::AnimationLayoutMap & RenderHandler::getAnimationLayout(const AnimationPath & path)
+{
+	auto tmp = getScalePath(path);
+	auto animPath = AnimationPath::builtin(tmp.first.getName());
+	AnimationPath actualPath = boost::starts_with(animPath.getName(), "SPRITES") ? animPath : animPath.addPrefix("SPRITES/");
+
+	auto it = animationLayouts.find(actualPath);
+
+	if (it != animationLayouts.end())
+		return it->second;
+
+	AnimationLayoutMap result;
+
+	auto defFile = getAnimationFile(actualPath);
+	if(defFile)
+	{
+		const std::map<size_t, size_t> defEntries = defFile->getEntries();
+
+		for (const auto & defEntry : defEntries)
+			result[defEntry.first].resize(defEntry.second);
+	}
+
+	auto jsonResource = actualPath.toType<EResType::JSON>();
+	auto configList = CResourceHandler::get()->getResourcesWithName(jsonResource);
+
+	for(auto & loader : configList)
+	{
+		auto stream = loader->load(jsonResource);
+		std::unique_ptr<ui8[]> textData(new ui8[stream->getSize()]);
+		stream->read(textData.get(), stream->getSize());
+
+		const JsonNode config(reinterpret_cast<const std::byte*>(textData.get()), stream->getSize(), animPath.getOriginalName());
+
+		initFromJson(result, config);
+	}
+
+	for(auto & g : result)
+		for(auto & i : g.second)
+			i.preScaledFactor = tmp.second;
+
+	animationLayouts[actualPath] = result;
+	return animationLayouts[actualPath];
+}
+
+int RenderHandler::getScalingFactor() const
+{
+	return GH.screenHandler().getScalingFactor();
+}
+
+ImageLocator RenderHandler::getLocatorForAnimationFrame(const AnimationPath & path, int frame, int group)
+{
+	const auto & layout = getAnimationLayout(path);
+	if (!layout.count(group))
+		return ImageLocator(ImagePath::builtin("DEFAULT"));
+
+	if (frame >= layout.at(group).size())
+		return ImageLocator(ImagePath::builtin("DEFAULT"));
+
+	const auto & locator = layout.at(group).at(frame);
+	if (locator.image || locator.defFile)
+		return locator;
+
+	return ImageLocator(path, frame, group);
+}
+
+std::shared_ptr<const ISharedImage> RenderHandler::loadImageImpl(const ImageLocator & locator)
+{
+	auto it = imageFiles.find(locator);
+	if (it != imageFiles.end())
+		return it->second;
+
+	// TODO: order should be different:
+	// 1) try to find correctly scaled image
+	// 2) if fails -> try to find correctly transformed
+	// 3) if also fails -> try to find image from correct file
+	// 4) load missing part of the sequence
+	// TODO: check whether (load -> transform -> scale) or (load -> scale -> transform) order should be used for proper loading of pre-scaled data
+	auto imageFromFile = loadImageFromFile(locator.copyFile());
+	auto transformedImage = transformImage(locator.copyFileTransform(), imageFromFile);
+	auto scaledImage = scaleImage(locator.copyFileTransformScale(), transformedImage);
+
+	return scaledImage;
+}
+
+std::shared_ptr<const ISharedImage> RenderHandler::loadImageFromFileUncached(const ImageLocator & locator)
+{
+	if (locator.image)
+	{
+		// TODO: create EmptySharedImage class that will be instantiated if image does not exists or fails to load
+		return std::make_shared<SDLImageShared>(*locator.image, locator.preScaledFactor);
+	}
+
+	if (locator.defFile)
+	{
+		auto defFile = getAnimationFile(*locator.defFile);
+		int preScaledFactor = locator.preScaledFactor;
+		if(!defFile) // no prescale for this frame
+		{
+			auto tmpPath = (*locator.defFile).getName();
+			boost::algorithm::replace_all(tmpPath, "SPRITES2X/", "SPRITES/");
+			boost::algorithm::replace_all(tmpPath, "SPRITES3X/", "SPRITES/");
+			boost::algorithm::replace_all(tmpPath, "SPRITES4X/", "SPRITES/");
+			preScaledFactor = 1;
+			defFile = getAnimationFile(AnimationPath::builtin(tmpPath));
+		}
+		return std::make_shared<SDLImageShared>(defFile.get(), locator.defFrame, locator.defGroup, preScaledFactor);
+	}
+
+	throw std::runtime_error("Invalid image locator received!");
+}
+
+void RenderHandler::storeCachedImage(const ImageLocator & locator, std::shared_ptr<const ISharedImage> image)
+{
+	imageFiles[locator] = image;
+
+#if 0
+	const boost::filesystem::path outPath = VCMIDirs::get().userExtractedPath() / "imageCache" / (locator.toString() + ".png");
+	boost::filesystem::path outDir = outPath;
+	outDir.remove_filename();
+	boost::filesystem::create_directories(outDir);
+	image->exportBitmap(outPath , nullptr);
+#endif
+}
+
+std::shared_ptr<const ISharedImage> RenderHandler::loadImageFromFile(const ImageLocator & locator)
+{
+	if (imageFiles.count(locator))
+		return imageFiles.at(locator);
+
+	auto result = loadImageFromFileUncached(locator);
+	storeCachedImage(locator, result);
+	return result;
+}
+
+std::shared_ptr<const ISharedImage> RenderHandler::transformImage(const ImageLocator & locator, std::shared_ptr<const ISharedImage> image)
+{
+	if (imageFiles.count(locator))
+		return imageFiles.at(locator);
+
+	auto result = image;
+
+	if (locator.verticalFlip)
+		result = result->verticalFlip();
+
+	if (locator.horizontalFlip)
+		result = result->horizontalFlip();
+
+	storeCachedImage(locator, result);
+	return result;
+}
+
+std::shared_ptr<const ISharedImage> RenderHandler::scaleImage(const ImageLocator & locator, std::shared_ptr<const ISharedImage> image)
+{
+	if (imageFiles.count(locator))
+		return imageFiles.at(locator);
+
+	auto handle = image->createImageReference(locator.layer);
+
+	assert(locator.scalingFactor != 1); // should be filtered-out before
+	if (locator.playerColored != PlayerColor::CANNOT_DETERMINE)
+		handle->playerColored(locator.playerColored);
 
+	handle->scaleInteger(locator.scalingFactor);
 
-std::shared_ptr<IImage> RenderHandler::loadImage(const ImagePath & path)
+	auto result = handle->getSharedImage();
+	storeCachedImage(locator, result);
+	return result;
+}
+
+std::shared_ptr<IImage> RenderHandler::loadImage(const ImageLocator & locator, EImageBlitMode mode)
+{
+	ImageLocator adjustedLocator = locator;
+
+	if(adjustedLocator.image)
+	{
+		std::string imgPath = (*adjustedLocator.image).getName();
+		if(adjustedLocator.layer == EImageBlitMode::ONLY_OVERLAY)
+			imgPath += "-OVERLAY";
+		if(adjustedLocator.layer == EImageBlitMode::ONLY_SHADOW)
+			imgPath += "-SHADOW";
+
+		if(CResourceHandler::get()->existsResource(ImagePath::builtin(imgPath)) ||
+		   CResourceHandler::get()->existsResource(ImagePath::builtin(imgPath).addPrefix("DATA/")) ||
+		   CResourceHandler::get()->existsResource(ImagePath::builtin(imgPath).addPrefix("SPRITES/")))
+			adjustedLocator.image = ImagePath::builtin(imgPath);
+	}
+
+	if(adjustedLocator.defFile && adjustedLocator.scalingFactor == 0)
+	{
+		auto tmp = getScalePath(*adjustedLocator.defFile);
+		adjustedLocator.defFile = AnimationPath::builtin(tmp.first.getName());
+		adjustedLocator.preScaledFactor = tmp.second;
+	}
+	if(adjustedLocator.image && adjustedLocator.scalingFactor == 0)
+	{
+		auto tmp = getScalePath(*adjustedLocator.image);
+		adjustedLocator.image = ImagePath::builtin(tmp.first.getName());
+		adjustedLocator.preScaledFactor = tmp.second;
+	}
+
+	if (adjustedLocator.scalingFactor == 0 && getScalingFactor() != 1 )
+	{
+		auto unscaledLocator = adjustedLocator;
+		auto scaledLocator = adjustedLocator;
+
+		unscaledLocator.scalingFactor = 1;
+		scaledLocator.scalingFactor = getScalingFactor();
+		auto unscaledImage = loadImageImpl(unscaledLocator);
+
+		return std::make_shared<ImageScaled>(scaledLocator, unscaledImage, mode);
+	}
+
+	if (adjustedLocator.scalingFactor == 0)
+	{
+		auto scaledLocator = adjustedLocator;
+		scaledLocator.scalingFactor = getScalingFactor();
+
+		return loadImageImpl(scaledLocator)->createImageReference(mode);
+	}
+	else
+		return loadImageImpl(adjustedLocator)->createImageReference(mode);
+}
+
+std::shared_ptr<IImage> RenderHandler::loadImage(const AnimationPath & path, int frame, int group, EImageBlitMode mode)
 {
-	return loadImage(path, EImageBlitMode::ALPHA);
+	auto tmp = getScalePath(path);
+	ImageLocator locator = getLocatorForAnimationFrame(AnimationPath::builtin(tmp.first.getName()), frame, group);
+	locator.preScaledFactor = tmp.second;
+	return loadImage(locator, mode);
 }
 
 std::shared_ptr<IImage> RenderHandler::loadImage(const ImagePath & path, EImageBlitMode mode)
 {
-	return std::make_shared<SDLImage>(path, mode);
+	ImageLocator locator(path);
+	return loadImage(locator, mode);
 }
 
 std::shared_ptr<IImage> RenderHandler::createImage(SDL_Surface * source)
 {
-	return std::make_shared<SDLImage>(source, EImageBlitMode::ALPHA);
+	return std::make_shared<SDLImageShared>(source)->createImageReference(EImageBlitMode::SIMPLE);
+}
+
+std::shared_ptr<CAnimation> RenderHandler::loadAnimation(const AnimationPath & path, EImageBlitMode mode)
+{
+	return std::make_shared<CAnimation>(path, getAnimationLayout(path), mode);
+}
+
+void RenderHandler::addImageListEntries(const EntityService * service)
+{
+	service->forEachBase([this](const Entity * entity, bool & stop)
+	{
+		entity->registerIcons([this](size_t index, size_t group, const std::string & listName, const std::string & imageName)
+		{
+			if (imageName.empty())
+				return;
+
+			auto & layout = getAnimationLayout(AnimationPath::builtin("SPRITES/" + listName));
+
+			JsonNode entry;
+			entry["file"].String() = imageName;
+
+			if (index >= layout[group].size())
+				layout[group].resize(index + 1);
+
+			layout[group][index] = ImageLocator(entry);
+		});
+	});
 }
 
-std::shared_ptr<CAnimation> RenderHandler::loadAnimation(const AnimationPath & path)
+void RenderHandler::onLibraryLoadingFinished(const Services * services)
 {
-	return std::make_shared<CAnimation>(path);
+	addImageListEntries(services->creatures());
+	addImageListEntries(services->heroTypes());
+	addImageListEntries(services->artifacts());
+	addImageListEntries(services->factions());
+	addImageListEntries(services->spells());
+	addImageListEntries(services->skills());
 }
 
-std::shared_ptr<CAnimation> RenderHandler::createAnimation()
+std::shared_ptr<const IFont> RenderHandler::loadFont(EFonts font)
 {
-	return std::make_shared<CAnimation>();
+	if (fonts.count(font))
+		return fonts.at(font);
+
+	const int8_t index = static_cast<int8_t>(font);
+	logGlobal->debug("Loading font %d", static_cast<int>(index));
+
+	auto configList = CResourceHandler::get()->getResourcesWithName(JsonPath::builtin("config/fonts.json"));
+	std::shared_ptr<FontChain> loadedFont = std::make_shared<FontChain>();
+	std::string bitmapPath;
+
+	for(auto & loader : configList)
+	{
+		auto stream = loader->load(JsonPath::builtin("config/fonts.json"));
+		std::unique_ptr<ui8[]> textData(new ui8[stream->getSize()]);
+		stream->read(textData.get(), stream->getSize());
+		const JsonNode config(reinterpret_cast<const std::byte*>(textData.get()), stream->getSize(), "config/fonts.json");
+		const JsonVector & bmpConf = config["bitmap"].Vector();
+		const JsonNode   & ttfConf = config["trueType"];
+
+		bitmapPath = bmpConf[index].String();
+		if (!ttfConf[bitmapPath].isNull())
+			loadedFont->addTrueTypeFont(ttfConf[bitmapPath]);
+	}
+	loadedFont->addBitmapFont(bitmapPath);
+
+	fonts[font] = loadedFont;
+	return loadedFont;
 }
diff --color -urN vcmi-1.5.7/client/renderSDL/RenderHandler.h vcmi/client/renderSDL/RenderHandler.h
--- vcmi-1.5.7/client/renderSDL/RenderHandler.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/renderSDL/RenderHandler.h	2024-12-19 15:00:22.300123225 +0100
@@ -11,15 +11,58 @@
 
 #include "../render/IRenderHandler.h"
 
+VCMI_LIB_NAMESPACE_BEGIN
+class EntityService;
+VCMI_LIB_NAMESPACE_END
+
+class CDefFile;
+class SDLImageShared;
+class ISharedImage;
+
 class RenderHandler : public IRenderHandler
 {
+	using AnimationLayoutMap = std::map<size_t, std::vector<ImageLocator>>;
+
+	std::map<AnimationPath, std::shared_ptr<CDefFile>> animationFiles;
+	std::map<AnimationPath, AnimationLayoutMap> animationLayouts;
+	std::map<ImageLocator, std::shared_ptr<const ISharedImage>> imageFiles;
+	std::map<EFonts, std::shared_ptr<const IFont>> fonts;
+
+	std::shared_ptr<CDefFile> getAnimationFile(const AnimationPath & path);
+	std::optional<ResourcePath> getPathForScaleFactor(const ResourcePath & path, const std::string & factor);
+	std::pair<ResourcePath, int> getScalePath(const ResourcePath & p);
+	AnimationLayoutMap & getAnimationLayout(const AnimationPath & path);
+	void initFromJson(AnimationLayoutMap & layout, const JsonNode & config);
+
+	void addImageListEntry(size_t index, size_t group, const std::string & listName, const std::string & imageName);
+	void addImageListEntries(const EntityService * service);
+	void storeCachedImage(const ImageLocator & locator, std::shared_ptr<const ISharedImage> image);
+
+	std::shared_ptr<const ISharedImage> loadImageImpl(const ImageLocator & config);
+
+	std::shared_ptr<const ISharedImage> loadImageFromFileUncached(const ImageLocator & locator);
+	std::shared_ptr<const ISharedImage> loadImageFromFile(const ImageLocator & locator);
+
+	std::shared_ptr<const ISharedImage> transformImage(const ImageLocator & locator, std::shared_ptr<const ISharedImage> image);
+	std::shared_ptr<const ISharedImage> scaleImage(const ImageLocator & locator, std::shared_ptr<const ISharedImage> image);
+
+	ImageLocator getLocatorForAnimationFrame(const AnimationPath & path, int frame, int group);
+
+	int getScalingFactor() const;
+
 public:
-	std::shared_ptr<IImage> loadImage(const ImagePath & path) override;
+
+	// IRenderHandler implementation
+	void onLibraryLoadingFinished(const Services * services) override;
+
+	std::shared_ptr<IImage> loadImage(const ImageLocator & locator, EImageBlitMode mode) override;
 	std::shared_ptr<IImage> loadImage(const ImagePath & path, EImageBlitMode mode) override;
+	std::shared_ptr<IImage> loadImage(const AnimationPath & path, int frame, int group, EImageBlitMode mode) override;
 
-	std::shared_ptr<IImage> createImage(SDL_Surface * source) override;
+	std::shared_ptr<CAnimation> loadAnimation(const AnimationPath & path, EImageBlitMode mode) override;
 
-	std::shared_ptr<CAnimation> loadAnimation(const AnimationPath & path) override;
+	std::shared_ptr<IImage> createImage(SDL_Surface * source) override;
 
-	std::shared_ptr<CAnimation> createAnimation() override;
+	/// Returns font with specified identifer
+	std::shared_ptr<const IFont> loadFont(EFonts font) override;
 };
diff --color -urN vcmi-1.5.7/client/renderSDL/ScreenHandler.cpp vcmi/client/renderSDL/ScreenHandler.cpp
--- vcmi-1.5.7/client/renderSDL/ScreenHandler.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/renderSDL/ScreenHandler.cpp	2024-12-19 15:00:22.308123555 +0100
@@ -38,13 +38,14 @@
 SDL_Surface * screenBuf = screen; //points to screen (if only advmapint is present) or screen2 (else) - should be used when updating controls which are not regularly redrawed
 
 static const std::string NAME = GameConstants::VCMI_VERSION; //application name
+static constexpr Point heroes3Resolution = Point(800, 600);
 
 std::tuple<int, int> ScreenHandler::getSupportedScalingRange() const
 {
 	// H3 resolution, any resolution smaller than that is not correctly supported
-	static const Point minResolution = {800, 600};
+	static constexpr Point minResolution = heroes3Resolution;
 	// arbitrary limit on *downscaling*. Allow some downscaling, if requested by user. Should be generally limited to 100+ for all but few devices
-	static const double minimalScaling = 50;
+	static constexpr double minimalScaling = 50;
 
 	Point renderResolution = getRenderResolution();
 	double reservedAreaWidth = settings["video"]["reservedWidth"].Float();
@@ -83,22 +84,60 @@
 	return result;
 }
 
-Point ScreenHandler::getPreferredLogicalResolution() const
+int ScreenHandler::getInterfaceScalingPercentage() const
 {
-	Point renderResolution = getRenderResolution();
-	double reservedAreaWidth = settings["video"]["reservedWidth"].Float();
-	Point availableResolution = Point(renderResolution.x * (1 - reservedAreaWidth), renderResolution.y);
-
 	auto [minimalScaling, maximalScaling] = getSupportedScalingRange();
 
 	int userScaling = settings["video"]["resolution"]["scaling"].Integer();
+
+	if (userScaling == 0) // autodetection
+	{
+#ifdef VCMI_MOBILE
+		// for mobiles - stay at maximum scaling unless we have large screen
+		// might be better to check screen DPI / physical dimensions, but way more complex, and may result in different edge cases, e.g. chromebooks / tv's
+		int preferredMinimalScaling = 200;
+#else
+		// for PC - avoid downscaling if possible
+		int preferredMinimalScaling = 100;
+#endif
+		// prefer a little below maximum - to give space for extended UI
+		int preferredMaximalScaling = maximalScaling * 10 / 12;
+		userScaling = std::max(std::min(maximalScaling, preferredMinimalScaling), preferredMaximalScaling);
+	}
+
 	int scaling = std::clamp(userScaling, minimalScaling, maximalScaling);
+	return scaling;
+}
 
-	Point logicalResolution = availableResolution * 100.0 / scaling;
+Point ScreenHandler::getPreferredLogicalResolution() const
+{
+	Point renderResolution = getRenderResolution();
+	double reservedAreaWidth = settings["video"]["reservedWidth"].Float();
 
+	int scaling = getInterfaceScalingPercentage();
+	Point availableResolution = Point(renderResolution.x * (1 - reservedAreaWidth), renderResolution.y);
+	Point logicalResolution = availableResolution * 100.0 / scaling;
 	return logicalResolution;
 }
 
+int ScreenHandler::getScalingFactor() const
+{
+	switch (upscalingFilter)
+	{
+		case EUpscalingFilter::NONE: return 1;
+		case EUpscalingFilter::XBRZ_2: return 2;
+		case EUpscalingFilter::XBRZ_3: return 3;
+		case EUpscalingFilter::XBRZ_4: return 4;
+	}
+
+	throw std::runtime_error("invalid upscaling filter");
+}
+
+Point ScreenHandler::getLogicalResolution() const
+{
+	return Point(screen->w, screen->h) / getScalingFactor();
+}
+
 Point ScreenHandler::getRenderResolution() const
 {
 	assert(mainRenderer != nullptr);
@@ -291,12 +330,61 @@
 		handleFatalError(message, true);
 	}
 
+	selectUpscalingFilter();
+	selectDownscalingFilter();
+
 	SDL_RendererInfo info;
 	SDL_GetRendererInfo(mainRenderer, &info);
-	SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, settings["video"]["scalingMode"].String().c_str());
 	logGlobal->info("Created renderer %s", info.name);
 }
 
+EUpscalingFilter ScreenHandler::loadUpscalingFilter() const
+{
+	static const std::map<std::string, EUpscalingFilter> upscalingFilterTypes =
+	{
+		{"auto", EUpscalingFilter::AUTO },
+		{"none", EUpscalingFilter::NONE },
+		{"xbrz2", EUpscalingFilter::XBRZ_2 },
+		{"xbrz3", EUpscalingFilter::XBRZ_3 },
+		{"xbrz4", EUpscalingFilter::XBRZ_4 }
+	};
+
+	auto filterName = settings["video"]["upscalingFilter"].String();
+	auto filter = upscalingFilterTypes.at(filterName);
+
+	if (filter != EUpscalingFilter::AUTO)
+		return filter;
+
+	// else - autoselect
+	Point outputResolution = getRenderResolution();
+	Point logicalResolution = getPreferredLogicalResolution();
+
+	float scaleX = static_cast<float>(outputResolution.x) / logicalResolution.x;
+	float scaleY = static_cast<float>(outputResolution.x) / logicalResolution.x;
+	float scaling = std::min(scaleX, scaleY);
+
+	if (scaling <= 1.001f)
+		return EUpscalingFilter::NONE; // running at original resolution or even lower than that - no need for xbrz
+	if (scaling <= 2.001f)
+		return EUpscalingFilter::XBRZ_2; // resolutions below 1200p (including 1080p / FullHD)
+	if (scaling <= 3.001f)
+		return EUpscalingFilter::XBRZ_3; // resolutions below 2400p (including 1440p and 2160p / 4K)
+
+	return EUpscalingFilter::XBRZ_4; // Only for massive displays, e.g. 8K
+}
+
+void ScreenHandler::selectUpscalingFilter()
+{
+	upscalingFilter	= loadUpscalingFilter();
+	logGlobal->debug("Selected upscaling filter %d", static_cast<int>(upscalingFilter));
+}
+
+void ScreenHandler::selectDownscalingFilter()
+{
+	SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, settings["video"]["downscalingFilter"].String().c_str());
+	logGlobal->debug("Selected downscaling filter %s", settings["video"]["downscalingFilter"].String());
+}
+
 void ScreenHandler::initializeScreenBuffers()
 {
 #ifdef VCMI_ENDIAN_BIG
@@ -311,7 +399,7 @@
 	int amask = 0xFF000000;
 #endif
 
-	auto logicalSize = getPreferredLogicalResolution();
+	auto logicalSize = getPreferredLogicalResolution() * getScalingFactor();
 	SDL_RenderSetLogicalSize(mainRenderer, logicalSize.x, logicalSize.y);
 
 	screen = SDL_CreateRGBSurface(0, logicalSize.x, logicalSize.y, 32, rmask, gmask, bmask, amask);
diff --color -urN vcmi-1.5.7/client/renderSDL/ScreenHandler.h vcmi/client/renderSDL/ScreenHandler.h
--- vcmi-1.5.7/client/renderSDL/ScreenHandler.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/renderSDL/ScreenHandler.h	2024-12-19 15:00:22.308123555 +0100
@@ -29,9 +29,23 @@
 	FULLSCREEN_EXCLUSIVE
 };
 
+enum class EUpscalingFilter
+{
+	AUTO, // used only for loading from config, replaced with autoselected value on init
+	NONE,
+	//BILINEAR, // TODO?
+	//BICUBIC, // TODO?
+	XBRZ_2,
+	XBRZ_3,
+	XBRZ_4,
+	// NOTE: xbrz also provides x5 and x6 filters, but those would require high-end gaming PC's due to huge memory usage with no visible gain
+};
+
 /// This class is responsible for management of game window and its main rendering surface
 class ScreenHandler final : public IScreenHandler
 {
+	EUpscalingFilter upscalingFilter = EUpscalingFilter::AUTO;
+
 	/// Dimensions of target surfaces/textures, this value is what game logic views as screen size
 	Point getPreferredLogicalResolution() const;
 
@@ -69,6 +83,11 @@
 
 	/// Performs validation of settings and updates them to valid values if necessary
 	void validateSettings();
+
+	EUpscalingFilter loadUpscalingFilter() const;
+
+	void selectDownscalingFilter();
+	void selectUpscalingFilter();
 public:
 
 	/// Creates and initializes screen, window and SDL state
@@ -89,6 +108,12 @@
 	/// Window has focus
 	bool hasFocus() final;
 
+	Point getLogicalResolution() const final;
+
+	int getScalingFactor() const final;
+
+	int getInterfaceScalingPercentage() const final;
+
 	std::vector<Point> getSupportedResolutions() const final;
 	std::vector<Point> getSupportedResolutions(int displayIndex) const;
 	std::tuple<int, int> getSupportedScalingRange() const final;
diff --color -urN vcmi-1.5.7/client/renderSDL/SDL_Extensions.cpp vcmi/client/renderSDL/SDL_Extensions.cpp
--- vcmi-1.5.7/client/renderSDL/SDL_Extensions.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/renderSDL/SDL_Extensions.cpp	2024-12-19 15:00:22.305123431 +0100
@@ -12,13 +12,20 @@
 
 #include "SDL_PixelAccess.h"
 
+#include "../gui/CGuiHandler.h"
 #include "../render/Graphics.h"
+#include "../render/IScreenHandler.h"
 #include "../render/Colors.h"
 #include "../CMT.h"
+#include "../xBRZ/xbrz.h"
 
 #include "../../lib/GameConstants.h"
 
+#include <tbb/parallel_for.h>
+
 #include <SDL_render.h>
+#include <SDL_surface.h>
+#include <SDL_version.h>
 
 Rect CSDL_Ext::fromSDL(const SDL_Rect & rect)
 {
@@ -61,34 +68,21 @@
 	SDL_SetSurfaceAlphaMod(bg, value);
 }
 
-void CSDL_Ext::updateRect(SDL_Surface *surface, const Rect & rect )
-{
-	SDL_Rect rectSDL = CSDL_Ext::toSDL(rect);
-	if(0 !=SDL_UpdateTexture(screenTexture, &rectSDL, surface->pixels, surface->pitch))
-		logGlobal->error("%sSDL_UpdateTexture %s", __FUNCTION__, SDL_GetError());
-
-	SDL_RenderClear(mainRenderer);
-	if(0 != SDL_RenderCopy(mainRenderer, screenTexture, nullptr, nullptr))
-		logGlobal->error("%sSDL_RenderCopy %s", __FUNCTION__, SDL_GetError());
-	SDL_RenderPresent(mainRenderer);
-
-}
-
-SDL_Surface * CSDL_Ext::newSurface(int w, int h)
+SDL_Surface * CSDL_Ext::newSurface(const Point & dimensions)
 {
-	return newSurface(w, h, screen);
+	return newSurface(dimensions, screen);
 }
 
-SDL_Surface * CSDL_Ext::newSurface(int w, int h, SDL_Surface * mod) //creates new surface, with flags/format same as in surface given
+SDL_Surface * CSDL_Ext::newSurface(const Point & dimensions, SDL_Surface * mod) //creates new surface, with flags/format same as in surface given
 {
-	SDL_Surface * ret = SDL_CreateRGBSurface(0,w,h,mod->format->BitsPerPixel,mod->format->Rmask,mod->format->Gmask,mod->format->Bmask,mod->format->Amask);
+	SDL_Surface * ret = SDL_CreateRGBSurface(0,dimensions.x,dimensions.y,mod->format->BitsPerPixel,mod->format->Rmask,mod->format->Gmask,mod->format->Bmask,mod->format->Amask);
 
 	if(ret == nullptr)
 	{
 		const char * error = SDL_GetError();
 
 		std::string messagePattern = "Failed to create SDL Surface of size %d x %d, %d bpp. Reason: %s";
-		std::string message = boost::str(boost::format(messagePattern) % w % h % mod->format->BitsPerPixel % error);
+		std::string message = boost::str(boost::format(messagePattern) % dimensions.x % dimensions.y % mod->format->BitsPerPixel % error);
 
 		handleFatalError(message, true);
 	}
@@ -96,7 +90,7 @@
 	if (mod->format->palette)
 	{
 		assert(ret->format->palette);
-		assert(ret->format->palette->ncolors == mod->format->palette->ncolors);
+		assert(ret->format->palette->ncolors >= mod->format->palette->ncolors);
 		memcpy(ret->format->palette->colors, mod->format->palette->colors, mod->format->palette->ncolors * sizeof(SDL_Color));
 	}
 	return ret;
@@ -221,8 +215,8 @@
 	}
 }
 
-template<int bpp>
-int CSDL_Ext::blit8bppAlphaTo24bppT(const SDL_Surface * src, const Rect & srcRectInput, SDL_Surface * dst, const Point & dstPointInput)
+template<int bpp, bool useAlpha>
+int CSDL_Ext::blit8bppAlphaTo24bppT(const SDL_Surface * src, const Rect & srcRectInput, SDL_Surface * dst, const Point & dstPointInput, [[maybe_unused]] uint8_t alpha)
 {
 	SDL_Rect srcRectInstance = CSDL_Ext::toSDL(srcRectInput);
 	SDL_Rect dstRectInstance = CSDL_Ext::toSDL(Rect(dstPointInput, srcRectInput.dimensions()));
@@ -337,15 +331,20 @@
 			uint8_t *colory = (uint8_t*)src->pixels + srcy*src->pitch + srcx;
 			uint8_t *py = (uint8_t*)dst->pixels + dstRect->y*dst->pitch + dstRect->x*bpp;
 
-			for(int y=h; y; y--, colory+=src->pitch, py+=dst->pitch)
+			for(int y=0; y<h; ++y, colory+=src->pitch, py+=dst->pitch)
 			{
 				uint8_t *color = colory;
 				uint8_t *p = py;
 
-				for(int x = w; x; x--)
+				for(int x = 0; x < w; ++x)
 				{
 					const SDL_Color &tbc = colors[*color++]; //color to blit
-					ColorPutter<bpp, +1>::PutColorAlphaSwitch(p, tbc.r, tbc.g, tbc.b, tbc.a);
+					if constexpr (useAlpha)
+						ColorPutter<bpp>::PutColorAlphaSwitch(p, tbc.r, tbc.g, tbc.b, int(alpha) * tbc.a / 255 );
+					else
+						ColorPutter<bpp>::PutColorAlphaSwitch(p, tbc.r, tbc.g, tbc.b, tbc.a);
+
+					p += bpp;
 				}
 			}
 			SDL_UnlockSurface(dst);
@@ -354,17 +353,27 @@
 	return 0;
 }
 
-int CSDL_Ext::blit8bppAlphaTo24bpp(const SDL_Surface * src, const Rect & srcRect, SDL_Surface * dst, const Point & dstPoint)
+int CSDL_Ext::blit8bppAlphaTo24bpp(const SDL_Surface * src, const Rect & srcRect, SDL_Surface * dst, const Point & dstPoint, uint8_t alpha)
 {
-	switch(dst->format->BytesPerPixel)
+	if (alpha == SDL_ALPHA_OPAQUE)
 	{
-	case 2: return blit8bppAlphaTo24bppT<2>(src, srcRect, dst, dstPoint);
-	case 3: return blit8bppAlphaTo24bppT<3>(src, srcRect, dst, dstPoint);
-	case 4: return blit8bppAlphaTo24bppT<4>(src, srcRect, dst, dstPoint);
-	default:
-		logGlobal->error("%d bpp is not supported!", (int)dst->format->BitsPerPixel);
-		return -1;
+		switch(dst->format->BytesPerPixel)
+		{
+		case 3: return blit8bppAlphaTo24bppT<3, false>(src, srcRect, dst, dstPoint, alpha);
+		case 4: return blit8bppAlphaTo24bppT<4, false>(src, srcRect, dst, dstPoint, alpha);
+		}
+	}
+	else
+	{
+		switch(dst->format->BytesPerPixel)
+		{
+			case 3: return blit8bppAlphaTo24bppT<3, true>(src, srcRect, dst, dstPoint, alpha);
+			case 4: return blit8bppAlphaTo24bppT<4, true>(src, srcRect, dst, dstPoint, alpha);
+		}
 	}
+
+	logGlobal->error("%d bpp is not supported!", (int)dst->format->BitsPerPixel);
+	return -1;
 }
 
 uint32_t CSDL_Ext::colorTouint32_t(const SDL_Color * color)
@@ -422,7 +431,7 @@
 		uint8_t a = vstd::lerp(color1.a, color2.a, f);
 
 		uint8_t *p = CSDL_Ext::getPxPtr(sur, x, y);
-		ColorPutter<4, 0>::PutColor(p, r,g,b,a);
+		ColorPutter<4>::PutColor(p, r,g,b,a);
 	}
 }
 
@@ -440,36 +449,39 @@
 		uint8_t a = vstd::lerp(color1.a, color2.a, f);
 
 		uint8_t *p = CSDL_Ext::getPxPtr(sur, x, y);
-		ColorPutter<4, 0>::PutColor(p, r,g,b,a);
+		ColorPutter<4>::PutColor(p, r,g,b,a);
 	}
 }
 
-void CSDL_Ext::drawLine(SDL_Surface * sur, const Point & from, const Point & dest, const SDL_Color & color1, const SDL_Color & color2)
+void CSDL_Ext::drawLine(SDL_Surface * sur, const Point & from, const Point & dest, const SDL_Color & color1, const SDL_Color & color2, int thickness)
 {
 	//FIXME: duplicated code with drawLineDashed
-	int width  = std::abs(from.x - dest.x);
+	int width = std::abs(from.x - dest.x);
 	int height = std::abs(from.y - dest.y);
 
-	if ( width == 0 && height == 0)
+	if(width == 0 && height == 0)
 	{
-		uint8_t *p = CSDL_Ext::getPxPtr(sur, from.x, from.y);
-		ColorPutter<4, 0>::PutColorAlpha(p, color1);
+		uint8_t * p = CSDL_Ext::getPxPtr(sur, from.x, from.y);
+		ColorPutter<4>::PutColorAlpha(p, color1);
 		return;
 	}
 
-	if (width > height)
-	{
-		if ( from.x < dest.x)
-			drawLineX(sur, from.x, from.y, dest.x, dest.y, color1, color2);
-		else
-			drawLineX(sur, dest.x, dest.y, from.x, from.y, color2, color1);
-	}
-	else
+	for(int i = 0; i < thickness; ++i)
 	{
-		if ( from.y < dest.y)
-			drawLineY(sur, from.x, from.y, dest.x, dest.y, color1, color2);
+		if(width > height)
+		{
+			if(from.x < dest.x)
+				drawLineX(sur, from.x, from.y + i, dest.x, dest.y + i, color1, color2);
+			else
+				drawLineX(sur, dest.x, dest.y + i, from.x, from.y + i, color2, color1);
+		}
 		else
-			drawLineY(sur, dest.x, dest.y, from.x, from.y, color2, color1);
+		{
+			if(from.y < dest.y)
+				drawLineY(sur, from.x + i, from.y, dest.x + i, dest.y, color1, color2);
+			else
+				drawLineY(sur, dest.x + i, dest.y, from.x + i, from.y, color2, color1);
+		}
 	}
 }
 
@@ -524,59 +536,18 @@
 	drawBorder(sur, r.x, r.y, r.w, r.h, color, depth);
 }
 
-void CSDL_Ext::setPlayerColor(SDL_Surface * sur, const PlayerColor & player)
-{
-	if(player==PlayerColor::UNFLAGGABLE)
-		return;
-	if(sur->format->BitsPerPixel==8)
-	{
-		ColorRGBA color = (player == PlayerColor::NEUTRAL
-							? graphics->neutralColor
-							: graphics->playerColors[player.getNum()]);
-
-		SDL_Color colorSDL = toSDL(color);
-		CSDL_Ext::setColors(sur, &colorSDL, 5, 1);
-	}
-	else
-		logGlobal->warn("Warning, setPlayerColor called on not 8bpp surface!");
-}
-
-CSDL_Ext::TColorPutter CSDL_Ext::getPutterFor(SDL_Surface * const &dest, int incrementing)
-{
-#define CASE_BPP(BytesPerPixel)							\
-case BytesPerPixel:									\
-	if(incrementing > 0)								\
-		return ColorPutter<BytesPerPixel, 1>::PutColor;	\
-	else if(incrementing == 0)							\
-		return ColorPutter<BytesPerPixel, 0>::PutColor;	\
-	else												\
-		return ColorPutter<BytesPerPixel, -1>::PutColor;\
-	break;
-
-	switch(dest->format->BytesPerPixel)
-	{
-		CASE_BPP(2)
-		CASE_BPP(3)
-		CASE_BPP(4)
-	default:
-		logGlobal->error("%d bpp is not supported!", (int)dest->format->BitsPerPixel);
-		return nullptr;
-	}
-
-}
-
-CSDL_Ext::TColorPutterAlpha CSDL_Ext::getPutterAlphaFor(SDL_Surface * const &dest, int incrementing)
+CSDL_Ext::TColorPutter CSDL_Ext::getPutterFor(SDL_Surface * const &dest)
 {
 	switch(dest->format->BytesPerPixel)
 	{
-		CASE_BPP(2)
-		CASE_BPP(3)
-		CASE_BPP(4)
+		case 3:
+			return ColorPutter<3>::PutColor;
+		case 4:
+			return ColorPutter<4>::PutColor;
 	default:
 		logGlobal->error("%d bpp is not supported!", (int)dest->format->BitsPerPixel);
 		return nullptr;
 	}
-#undef CASE_BPP
 }
 
 uint8_t * CSDL_Ext::getPxPtr(const SDL_Surface * const &srf, const int x, const int y)
@@ -607,11 +578,10 @@
 void CSDL_Ext::putPixelWithoutRefresh(SDL_Surface *ekran, const int & x, const int & y, const uint8_t & R, const uint8_t & G, const uint8_t & B, uint8_t A)
 {
 	uint8_t *p = getPxPtr(ekran, x, y);
-	getPutterFor(ekran, false)(p, R, G, B);
+	getPutterFor(ekran)(p, R, G, B);
 
 	switch(ekran->format->BytesPerPixel)
 	{
-	case 2: Channels::px<2>::a.set(p, A); break;
 	case 3: Channels::px<3>::a.set(p, A); break;
 	case 4: Channels::px<4>::a.set(p, A); break;
 	}
@@ -655,127 +625,76 @@
 {
 	switch(surf->format->BytesPerPixel)
 	{
-		case 2: convertToGrayscaleBpp<2>(surf, rect); break;
 		case 3: convertToGrayscaleBpp<3>(surf, rect); break;
 		case 4: convertToGrayscaleBpp<4>(surf, rect); break;
 	}
 }
 
-template<int bpp>
-void scaleSurfaceFastInternal(SDL_Surface *surf, SDL_Surface *ret)
-{
-	const float factorX = static_cast<float>(surf->w) / static_cast<float>(ret->w);
-	const float factorY = static_cast<float>(surf->h) / static_cast<float>(ret->h);
-
-	for(int y = 0; y < ret->h; y++)
-	{
-		for(int x = 0; x < ret->w; x++)
-		{
-			//coordinates we want to calculate
-			auto origX = static_cast<int>(floor(factorX * x));
-			auto origY = static_cast<int>(floor(factorY * y));
-
-			// Get pointers to source pixels
-			uint8_t *srcPtr = (uint8_t*)surf->pixels + origY * surf->pitch + origX * bpp;
-			uint8_t *destPtr = (uint8_t*)ret->pixels + y * ret->pitch + x * bpp;
-
-			memcpy(destPtr, srcPtr, bpp);
-		}
-	}
-}
-
-SDL_Surface * CSDL_Ext::scaleSurfaceFast(SDL_Surface *surf, int width, int height)
+// scaling via bilinear interpolation algorithm.
+// NOTE: best results are for scaling in range 50%...200%.
+// And upscaling looks awful right now - should be fixed somehow
+SDL_Surface * CSDL_Ext::scaleSurface(SDL_Surface * surf, int width, int height)
 {
-	if (!surf || !width || !height)
+	if(!surf || !width || !height)
 		return nullptr;
 
-	//Same size? return copy - this should more be faster
-	if (width == surf->w && height == surf->h)
-		return copySurface(surf);
+	// TODO: use xBRZ if possible? E.g. when scaling to 150% do 100% -> 200% via xBRZ and then linear downscale 200% -> 150%?
+	// Need to investigate which is optimal	for performance and for visuals
 
-	SDL_Surface *ret = newSurface(width, height, surf);
-
-	switch(surf->format->BytesPerPixel)
-	{
-		case 1: scaleSurfaceFastInternal<1>(surf, ret); break;
-		case 2: scaleSurfaceFastInternal<2>(surf, ret); break;
-		case 3: scaleSurfaceFastInternal<3>(surf, ret); break;
-		case 4: scaleSurfaceFastInternal<4>(surf, ret); break;
-	}
-	return ret;
-}
+	SDL_Surface * intermediate = SDL_ConvertSurface(surf, screen->format, 0);
+	SDL_Surface * ret = newSurface(Point(width, height), intermediate);
 
-template<int bpp>
-void scaleSurfaceInternal(SDL_Surface *surf, SDL_Surface *ret)
-{
-	const float factorX = float(surf->w - 1) / float(ret->w),
-				factorY = float(surf->h - 1) / float(ret->h);
+#if SDL_VERSION_ATLEAST(2,0,16)
+	SDL_SoftStretchLinear(intermediate, nullptr, ret, nullptr);
+#else
+	SDL_SoftStretch(intermediate, nullptr, ret, nullptr);
+#endif
+	SDL_FreeSurface(intermediate);
 
-	for(int y = 0; y < ret->h; y++)
-	{
-		for(int x = 0; x < ret->w; x++)
-		{
-			//coordinates we want to interpolate
-			float origX = factorX * x,
-				  origY = factorY * y;
-
-			float x1 = floor(origX), x2 = floor(origX+1),
-				  y1 = floor(origY), y2 = floor(origY+1);
-			//assert( x1 >= 0 && y1 >= 0 && x2 < surf->w && y2 < surf->h);//All pixels are in range
-
-			// Calculate weights of each source pixel
-			float w11 = ((origX - x1) * (origY - y1));
-			float w12 = ((origX - x1) * (y2 - origY));
-			float w21 = ((x2 - origX) * (origY - y1));
-			float w22 = ((x2 - origX) * (y2 - origY));
-			//assert( w11 + w12 + w21 + w22 > 0.99 && w11 + w12 + w21 + w22 < 1.01);//total weight is ~1.0
-
-			// Get pointers to source pixels
-			uint8_t *p11 = (uint8_t*)surf->pixels + int(y1) * surf->pitch + int(x1) * bpp;
-			uint8_t *p12 = p11 + bpp;
-			uint8_t *p21 = p11 + surf->pitch;
-			uint8_t *p22 = p21 + bpp;
-			// Calculate resulting channels
-#define PX(X, PTR) Channels::px<bpp>::X.get(PTR)
-			int resR = static_cast<int>(PX(r, p11) * w11 + PX(r, p12) * w12 + PX(r, p21) * w21 + PX(r, p22) * w22);
-			int resG = static_cast<int>(PX(g, p11) * w11 + PX(g, p12) * w12 + PX(g, p21) * w21 + PX(g, p22) * w22);
-			int resB = static_cast<int>(PX(b, p11) * w11 + PX(b, p12) * w12 + PX(b, p21) * w21 + PX(b, p22) * w22);
-			int resA = static_cast<int>(PX(a, p11) * w11 + PX(a, p12) * w12 + PX(a, p21) * w21 + PX(a, p22) * w22);
-			//assert(resR < 256 && resG < 256 && resB < 256 && resA < 256);
-#undef PX
-			uint8_t *dest = (uint8_t*)ret->pixels + y * ret->pitch + x * bpp;
-			Channels::px<bpp>::r.set(dest, resR);
-			Channels::px<bpp>::g.set(dest, resG);
-			Channels::px<bpp>::b.set(dest, resB);
-			Channels::px<bpp>::a.set(dest, resA);
-		}
-	}
+	return ret;
 }
 
-// scaling via bilinear interpolation algorithm.
-// NOTE: best results are for scaling in range 50%...200%.
-// And upscaling looks awful right now - should be fixed somehow
-SDL_Surface * CSDL_Ext::scaleSurface(SDL_Surface *surf, int width, int height)
+SDL_Surface * CSDL_Ext::scaleSurfaceIntegerFactor(SDL_Surface * surf, int factor, EScalingAlgorithm algorithm)
 {
-	if (!surf || !width || !height)
+	if(surf == nullptr || factor == 0)
 		return nullptr;
 
-	if (surf->format->palette)
-		return scaleSurfaceFast(surf, width, height);
+	int newWidth = surf->w * factor;
+	int newHight = surf->h * factor;
 
-	//Same size? return copy - this should more be faster
-	if (width == surf->w && height == surf->h)
-		return copySurface(surf);
+	SDL_Surface * intermediate = SDL_ConvertSurfaceFormat(surf, SDL_PIXELFORMAT_ARGB8888, 0);
+	SDL_Surface * ret = newSurface(Point(newWidth, newHight), intermediate);
 
-	SDL_Surface *ret = newSurface(width, height, surf);
+	assert(intermediate->pitch == intermediate->w * 4);
+	assert(ret->pitch == ret->w * 4);
 
-	switch(surf->format->BytesPerPixel)
-	{
-	case 2: scaleSurfaceInternal<2>(surf, ret); break;
-	case 3: scaleSurfaceInternal<3>(surf, ret); break;
-	case 4: scaleSurfaceInternal<4>(surf, ret); break;
+	const uint32_t * srcPixels = static_cast<const uint32_t*>(intermediate->pixels);
+	uint32_t * dstPixels = static_cast<uint32_t*>(ret->pixels);
+
+	// avoid excessive granulation - xBRZ prefers at least 8-16 lines per task
+	// TODO: compare performance and size of images, recheck values for potentially better parameters
+	const int granulation = std::clamp(surf->h / 64 * 8, 8, 64);
+
+	switch (algorithm)
+	{
+		case EScalingAlgorithm::NEAREST:
+			xbrz::nearestNeighborScale(srcPixels, intermediate->w, intermediate->h, dstPixels, ret->w, ret->h);
+			break;
+		case EScalingAlgorithm::BILINEAR:
+			xbrz::bilinearScale(srcPixels, intermediate->w, intermediate->h, dstPixels, ret->w, ret->h);
+			break;
+		case EScalingAlgorithm::XBRZ:
+			tbb::parallel_for(tbb::blocked_range<size_t>(0, intermediate->h, granulation), [factor, srcPixels, dstPixels, intermediate](const tbb::blocked_range<size_t> & r)
+			{
+				xbrz::scale(factor, srcPixels, dstPixels, intermediate->w, intermediate->h, xbrz::ColorFormat::ARGB, {}, r.begin(), r.end());
+			});
+			break;
+		default:
+			throw std::runtime_error("invalid scaling algorithm!");
 	}
 
+	SDL_FreeSurface(intermediate);
+
 	return ret;
 }
 
@@ -868,7 +787,10 @@
 	other = CSDL_Ext::fromSDL(rect);
 }
 
-template SDL_Surface * CSDL_Ext::createSurfaceWithBpp<2>(int, int);
+int CSDL_Ext::CClipRectGuard::getScalingFactor() const
+{
+	return GH.screenHandler().getScalingFactor();
+}
+
 template SDL_Surface * CSDL_Ext::createSurfaceWithBpp<3>(int, int);
 template SDL_Surface * CSDL_Ext::createSurfaceWithBpp<4>(int, int);
-
diff --color -urN vcmi-1.5.7/client/renderSDL/SDL_Extensions.h vcmi/client/renderSDL/SDL_Extensions.h
--- vcmi-1.5.7/client/renderSDL/SDL_Extensions.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/renderSDL/SDL_Extensions.h	2024-12-19 15:00:22.306123473 +0100
@@ -27,6 +27,13 @@
 
 VCMI_LIB_NAMESPACE_END
 
+enum class EScalingAlgorithm : int8_t
+{
+	NEAREST,
+	BILINEAR,
+	XBRZ
+};
+
 namespace CSDL_Ext
 {
 
@@ -61,8 +68,6 @@
 	void fillRect(SDL_Surface * dst, const Rect & dstrect, const SDL_Color & color);
 	void fillRectBlended(SDL_Surface * dst, const Rect & dstrect, const SDL_Color & color);
 
-	void updateRect(SDL_Surface * surface, const Rect & rect);
-
 	void putPixelWithoutRefresh(SDL_Surface * ekran, const int & x, const int & y, const uint8_t & R, const uint8_t & G, const uint8_t & B, uint8_t A = 255);
 	void putPixelWithoutRefreshIfInSurf(SDL_Surface *ekran, const int & x, const int & y, const uint8_t & R, const uint8_t & G, const uint8_t & B, uint8_t A = 255);
 
@@ -73,32 +78,28 @@
 	bool isTransparent(SDL_Surface * srf, const Point & position); //checks if surface is transparent at given position
 
 	uint8_t * getPxPtr(const SDL_Surface * const & srf, const int x, const int y);
-	TColorPutter getPutterFor(SDL_Surface * const & dest, int incrementing); //incrementing: -1, 0, 1
-	TColorPutterAlpha getPutterAlphaFor(SDL_Surface * const & dest, int incrementing); //incrementing: -1, 0, 1
+	TColorPutter getPutterFor(SDL_Surface * const & dest);
 
-	template<int bpp>
-	int blit8bppAlphaTo24bppT(const SDL_Surface * src, const Rect & srcRect, SDL_Surface * dst, const Point & dstPoint); //blits 8 bpp surface with alpha channel to 24 bpp surface
-	int blit8bppAlphaTo24bpp(const SDL_Surface * src, const Rect & srcRect, SDL_Surface * dst, const Point & dstPoint); //blits 8 bpp surface with alpha channel to 24 bpp surface
+	template<int bpp, bool useAlpha>
+	int blit8bppAlphaTo24bppT(const SDL_Surface * src, const Rect & srcRect, SDL_Surface * dst, const Point & dstPoint, uint8_t alpha); //blits 8 bpp surface with alpha channel to 24 bpp surface
+	int blit8bppAlphaTo24bpp(const SDL_Surface * src, const Rect & srcRect, SDL_Surface * dst, const Point & dstPoint, uint8_t alpha); //blits 8 bpp surface with alpha channel to 24 bpp surface
 	uint32_t colorTouint32_t(const SDL_Color * color); //little endian only
 
-	void drawLine(SDL_Surface * sur, const Point & from, const Point & dest, const SDL_Color & color1, const SDL_Color & color2);
+	void drawLine(SDL_Surface * sur, const Point & from, const Point & dest, const SDL_Color & color1, const SDL_Color & color2, int width);
 	void drawLineDashed(SDL_Surface * sur, const Point & from, const Point & dest, const SDL_Color & color);
 
 	void drawBorder(SDL_Surface * sur, int x, int y, int w, int h, const SDL_Color & color, int depth = 1);
 	void drawBorder(SDL_Surface * sur, const Rect & r, const SDL_Color & color, int depth = 1);
-	void setPlayerColor(SDL_Surface * sur, const PlayerColor & player); //sets correct color of flags; -1 for neutral
 
-	SDL_Surface * newSurface(int w, int h, SDL_Surface * mod); //creates new surface, with flags/format same as in surface given
-	SDL_Surface * newSurface(int w, int h); //creates new surface, with flags/format same as in screen surface
+	SDL_Surface * newSurface(const Point & dimensions, SDL_Surface * mod); //creates new surface, with flags/format same as in surface given
+	SDL_Surface * newSurface(const Point & dimensions); //creates new surface, with flags/format same as in screen surface
 	SDL_Surface * copySurface(SDL_Surface * mod); //returns copy of given surface
 	template<int bpp>
 	SDL_Surface * createSurfaceWithBpp(int width, int height); //create surface with give bits per pixels value
 
-	//scale surface to required size.
-	//nearest neighbour algorithm
-	SDL_Surface * scaleSurfaceFast(SDL_Surface * surf, int width, int height);
-	// bilinear filtering. Uses fallback to scaleSurfaceFast in case of indexed surfaces
+	// bilinear filtering. Always returns rgba surface
 	SDL_Surface * scaleSurface(SDL_Surface * surf, int width, int height);
+	SDL_Surface * scaleSurfaceIntegerFactor(SDL_Surface * surf, int factor, EScalingAlgorithm scaler);
 
 	template<int bpp>
 	void convertToGrayscaleBpp(SDL_Surface * surf, const Rect & rect);
@@ -117,11 +118,13 @@
 		SDL_Surface * surf;
 		Rect oldRect;
 
+		int getScalingFactor() const;
+
 	public:
 		CClipRectGuard(SDL_Surface * surface, const Rect & rect): surf(surface)
 		{
 			CSDL_Ext::getClipRect(surf, oldRect);
-			CSDL_Ext::setClipRect(surf, rect);
+			CSDL_Ext::setClipRect(surf, rect * getScalingFactor());
 		}
 
 		~CClipRectGuard()
diff --color -urN vcmi-1.5.7/client/renderSDL/SDLImage.cpp vcmi/client/renderSDL/SDLImage.cpp
--- vcmi-1.5.7/client/renderSDL/SDLImage.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/renderSDL/SDLImage.cpp	2024-12-19 15:00:22.301123266 +0100
@@ -1,4 +1,4 @@
-/*
+/*
  * SDLImage.cpp, part of VCMI engine
  *
  * Authors: listed in file AUTHORS in main folder
@@ -14,16 +14,71 @@
 #include "SDL_Extensions.h"
 
 #include "../render/ColorFilter.h"
+#include "../render/Colors.h"
 #include "../render/CBitmapHandler.h"
 #include "../render/CDefFile.h"
 #include "../render/Graphics.h"
+#include "../xBRZ/xbrz.h"
 
-#include "../../lib/json/JsonNode.h"
-
+#include <tbb/parallel_for.h>
 #include <SDL_surface.h>
+#include <SDL_image.h>
 
 class SDLImageLoader;
 
+//First 8 colors in def palette used for transparency
+static constexpr std::array<SDL_Color, 8> sourcePalette = {{
+	{0,   255, 255, SDL_ALPHA_OPAQUE},
+	{255, 150, 255, SDL_ALPHA_OPAQUE},
+	{255, 100, 255, SDL_ALPHA_OPAQUE},
+	{255, 50,  255, SDL_ALPHA_OPAQUE},
+	{255, 0,   255, SDL_ALPHA_OPAQUE},
+	{255, 255, 0,   SDL_ALPHA_OPAQUE},
+	{180, 0,   255, SDL_ALPHA_OPAQUE},
+	{0,   255, 0,   SDL_ALPHA_OPAQUE}
+}};
+
+static constexpr std::array<ColorRGBA, 8> targetPalette = {{
+	{0, 0, 0, 0  }, // 0 - transparency                  ( used in most images )
+	{0, 0, 0, 64 }, // 1 - shadow border                 ( used in battle, adventure map def's )
+	{0, 0, 0, 64 }, // 2 - shadow border                 ( used in fog-of-war def's )
+	{0, 0, 0, 128}, // 3 - shadow body                   ( used in fog-of-war def's )
+	{0, 0, 0, 128}, // 4 - shadow body                   ( used in battle, adventure map def's )
+	{0, 0, 0, 0  }, // 5 - selection / owner flag        ( used in battle, adventure map def's )
+	{0, 0, 0, 128}, // 6 - shadow body   below selection ( used in battle def's )
+	{0, 0, 0, 64 }  // 7 - shadow border below selection ( used in battle def's )
+}};
+
+static ui8 mixChannels(ui8 c1, ui8 c2, ui8 a1, ui8 a2)
+{
+	return c1*a1 / 256 + c2*a2*(255 - a1) / 256 / 256;
+}
+
+static ColorRGBA addColors(const ColorRGBA & base, const ColorRGBA & over)
+{
+	return ColorRGBA(
+		mixChannels(over.r, base.r, over.a, base.a),
+		mixChannels(over.g, base.g, over.a, base.a),
+		mixChannels(over.b, base.b, over.a, base.a),
+		static_cast<ui8>(over.a + base.a * (255 - over.a) / 256)
+		);
+}
+
+static bool colorsSimilar (const SDL_Color & lhs, const SDL_Color & rhs)
+{
+	// it seems that H3 does not requires exact match to replace colors -> (255, 103, 255) gets interpreted as shadow
+	// exact logic is not clear and requires extensive testing with image editing
+	// potential reason is that H3 uses 16-bit color format (565 RGB bits), meaning that 3 least significant bits are lost in red and blue component
+	static const int threshold = 8;
+
+	int diffR = static_cast<int>(lhs.r) - rhs.r;
+	int diffG = static_cast<int>(lhs.g) - rhs.g;
+	int diffB = static_cast<int>(lhs.b) - rhs.b;
+	int diffA = static_cast<int>(lhs.a) - rhs.a;
+
+	return std::abs(diffR) < threshold && std::abs(diffG) < threshold && std::abs(diffB) < threshold && std::abs(diffA) < threshold;
+}
+
 int IImage::width() const
 {
 	return dimensions().x;
@@ -34,75 +89,43 @@
 	return dimensions().y;
 }
 
-SDLImage::SDLImage(CDefFile * data, size_t frame, size_t group)
+SDLImageShared::SDLImageShared(const CDefFile * data, size_t frame, size_t group, int preScaleFactor)
 	: surf(nullptr),
 	margins(0, 0),
 	fullSize(0, 0),
-	originalPalette(nullptr)
+	originalPalette(nullptr),
+	preScaleFactor(preScaleFactor)
 {
 	SDLImageLoader loader(this);
 	data->loadFrame(frame, group, loader);
 
 	savePalette();
-	setBlitMode(EImageBlitMode::ALPHA);
 }
 
-SDLImage::SDLImage(SDL_Surface * from, EImageBlitMode mode)
+SDLImageShared::SDLImageShared(SDL_Surface * from, int preScaleFactor)
 	: surf(nullptr),
 	margins(0, 0),
 	fullSize(0, 0),
-	originalPalette(nullptr)
+	originalPalette(nullptr),
+	preScaleFactor(preScaleFactor)
 {
 	surf = from;
 	if (surf == nullptr)
 		return;
 
 	savePalette();
-	setBlitMode(mode);
 
 	surf->refcount++;
 	fullSize.x = surf->w;
 	fullSize.y = surf->h;
 }
 
-SDLImage::SDLImage(const JsonNode & conf, EImageBlitMode mode)
-	: surf(nullptr),
-	margins(0, 0),
-	fullSize(0, 0),
-	originalPalette(nullptr)
-{
-	surf = BitmapHandler::loadBitmap(ImagePath::fromJson(conf["file"]));
-
-	if(surf == nullptr)
-		return;
-
-	savePalette();
-	setBlitMode(mode);
-
-	const JsonNode & jsonMargins = conf["margins"];
-
-	margins.x = static_cast<int>(jsonMargins["left"].Integer());
-	margins.y = static_cast<int>(jsonMargins["top"].Integer());
-
-	fullSize.x = static_cast<int>(conf["width"].Integer());
-	fullSize.y = static_cast<int>(conf["height"].Integer());
-
-	if(fullSize.x == 0)
-	{
-		fullSize.x = margins.x + surf->w + (int)jsonMargins["right"].Integer();
-	}
-
-	if(fullSize.y == 0)
-	{
-		fullSize.y = margins.y + surf->h + (int)jsonMargins["bottom"].Integer();
-	}
-}
-
-SDLImage::SDLImage(const ImagePath & filename, EImageBlitMode mode)
+SDLImageShared::SDLImageShared(const ImagePath & filename, int preScaleFactor)
 	: surf(nullptr),
 	margins(0, 0),
 	fullSize(0, 0),
-	originalPalette(nullptr)
+	originalPalette(nullptr),
+	preScaleFactor(preScaleFactor)
 {
 	surf = BitmapHandler::loadBitmap(filename);
 
@@ -114,22 +137,15 @@
 	else
 	{
 		savePalette();
-		setBlitMode(mode);
 		fullSize.x = surf->w;
 		fullSize.y = surf->h;
+
+		optimizeSurface();
 	}
 }
 
-void SDLImage::draw(SDL_Surface *where, int posX, int posY, const Rect *src) const
-{
-	if(!surf)
-		return;
-
-	Rect destRect(posX, posY, surf->w, surf->h);
-	draw(where, &destRect, src);
-}
 
-void SDLImage::draw(SDL_Surface* where, const Rect * dest, const Rect* src) const
+void SDLImageShared::draw(SDL_Surface * where, SDL_Palette * palette, const Point & dest, const Rect * src, const ColorRGBA & colorMultiplier, uint8_t alpha, EImageBlitMode mode) const
 {
 	if (!surf)
 		return;
@@ -153,29 +169,161 @@
 	else
 		destShift = margins;
 
-	if(dest)
-		destShift += dest->topLeft();
+	destShift += dest;
 
-	uint8_t perSurfaceAlpha;
-	if (SDL_GetSurfaceAlphaMod(surf, &perSurfaceAlpha) != 0)
-		logGlobal->error("SDL_GetSurfaceAlphaMod faied! %s", SDL_GetError());
+	SDL_SetSurfaceColorMod(surf, colorMultiplier.r, colorMultiplier.g, colorMultiplier.b);
+	SDL_SetSurfaceAlphaMod(surf, alpha);
 
-	if(surf->format->BitsPerPixel == 8 && perSurfaceAlpha == SDL_ALPHA_OPAQUE && blitMode == EImageBlitMode::ALPHA)
+	if (alpha != SDL_ALPHA_OPAQUE || (mode != EImageBlitMode::OPAQUE && surf->format->Amask != 0))
+		SDL_SetSurfaceBlendMode(surf, SDL_BLENDMODE_BLEND);
+	else
+		SDL_SetSurfaceBlendMode(surf, SDL_BLENDMODE_NONE);
+
+	if (palette && surf->format->palette)
+		SDL_SetSurfacePalette(surf, palette);
+
+	if(surf->format->palette && mode != EImageBlitMode::OPAQUE && mode != EImageBlitMode::COLORKEY)
 	{
-		CSDL_Ext::blit8bppAlphaTo24bpp(surf, sourceRect, where, destShift);
+		CSDL_Ext::blit8bppAlphaTo24bpp(surf, sourceRect, where, destShift, alpha);
 	}
 	else
 	{
 		CSDL_Ext::blitSurface(surf, sourceRect, where, destShift);
 	}
+
+	if (surf->format->palette)
+		SDL_SetSurfacePalette(surf, originalPalette);
+}
+
+void SDLImageShared::optimizeSurface()
+{
+	if (!surf)
+		return;
+
+	int left = surf->w;
+	int top = surf->h;
+	int right = 0;
+	int bottom = 0;
+
+	// locate fully-transparent area around image
+	// H3 hadles this on format level, but mods or images scaled in runtime do not
+	if (surf->format->palette)
+	{
+		for (int y = 0; y < surf->h; ++y)
+		{
+			const uint8_t * row = static_cast<uint8_t *>(surf->pixels) + y * surf->pitch;
+			for (int x = 0; x < surf->w; ++x)
+			{
+				if (row[x] != 0)
+				{
+					// opaque or can be opaque (e.g. disabled shadow)
+					top = std::min(top, y);
+					left = std::min(left, x);
+					right = std::max(right, x);
+					bottom = std::max(bottom, y);
+				}
+			}
+		}
+	}
+	else
+	{
+		for (int y = 0; y < surf->h; ++y)
+		{
+			for (int x = 0; x < surf->w; ++x)
+			{
+				ColorRGBA color;
+				SDL_GetRGBA(CSDL_Ext::getPixel(surf, x, y), surf->format, &color.r, &color.g, &color.b, &color.a);
+
+				if (color.a != SDL_ALPHA_TRANSPARENT)
+				{
+					 // opaque
+					top = std::min(top, y);
+					left = std::min(left, x);
+					right = std::max(right, x);
+					bottom = std::max(bottom, y);
+				}
+			}
+		}
+	}
+
+	if (left == surf->w)
+	{
+		// empty image - simply delete it
+		SDL_FreeSurface(surf);
+		surf = nullptr;
+		return;
+	}
+
+	if (left != 0 || top != 0 || right != surf->w - 1 || bottom != surf->h - 1)
+	{
+		// non-zero border found
+		Rect newDimensions(left, top, right - left + 1, bottom - top + 1);
+		SDL_Rect rectSDL = CSDL_Ext::toSDL(newDimensions);
+		auto newSurface = CSDL_Ext::newSurface(newDimensions.dimensions(), surf);
+		SDL_SetSurfaceBlendMode(surf, SDL_BLENDMODE_NONE);
+		SDL_BlitSurface(surf, &rectSDL, newSurface, nullptr);
+
+		if (SDL_HasColorKey(surf))
+		{
+			uint32_t colorKey;
+			SDL_GetColorKey(surf, &colorKey);
+			SDL_SetColorKey(newSurface, SDL_TRUE, colorKey);
+		}
+
+		SDL_FreeSurface(surf);
+		surf = newSurface;
+
+		margins.x += left;
+		margins.y += top;
+	}
+}
+
+std::shared_ptr<const ISharedImage> SDLImageShared::scaleInteger(int factor, SDL_Palette * palette) const
+{
+	if (factor <= 0)
+		throw std::runtime_error("Unable to scale by integer value of " + std::to_string(factor));
+
+	if (!surf)
+		return shared_from_this();
+
+	if (palette && surf->format->palette)
+		SDL_SetSurfacePalette(surf, palette);
+
+	SDL_Surface * scaled = nullptr;
+	if(preScaleFactor == factor)
+		return shared_from_this();
+	else if(preScaleFactor == 1)
+		scaled = CSDL_Ext::scaleSurfaceIntegerFactor(surf, factor, EScalingAlgorithm::XBRZ);
+	else
+		scaled = CSDL_Ext::scaleSurface(surf, (surf->w / preScaleFactor) * factor, (surf->h / preScaleFactor) * factor);
+
+	auto ret = std::make_shared<SDLImageShared>(scaled, preScaleFactor);
+
+	ret->fullSize.x = fullSize.x * factor;
+	ret->fullSize.y = fullSize.y * factor;
+
+	ret->margins.x = margins.x * factor;
+	ret->margins.y = margins.y * factor;
+	ret->optimizeSurface();
+
+	// erase our own reference
+	SDL_FreeSurface(scaled);
+
+	if (surf->format->palette)
+		SDL_SetSurfacePalette(surf, originalPalette);
+
+	return ret;
 }
 
-std::shared_ptr<IImage> SDLImage::scaleFast(const Point & size) const
+std::shared_ptr<const ISharedImage> SDLImageShared::scaleTo(const Point & size, SDL_Palette * palette) const
 {
-	float scaleX = float(size.x) / width();
-	float scaleY = float(size.y) / height();
+	float scaleX = static_cast<float>(size.x) / fullSize.x;
+	float scaleY = static_cast<float>(size.y) / fullSize.y;
+
+	if (palette && surf->format->palette)
+		SDL_SetSurfacePalette(surf, palette);
 
-	auto scaled = CSDL_Ext::scaleSurfaceFast(surf, (int)(surf->w * scaleX), (int)(surf->h * scaleY));
+	auto scaled = CSDL_Ext::scaleSurface(surf, (int)(surf->w * scaleX), (int)(surf->h * scaleY));
 
 	if (scaled->format && scaled->format->palette) // fix color keying, because SDL loses it at this point
 		CSDL_Ext::setColorKey(scaled, scaled->format->palette->colors[0]);
@@ -184,7 +332,7 @@
 	else
 		CSDL_Ext::setDefaultColorKey(scaled);//just in case
 
-	auto * ret = new SDLImage(scaled, EImageBlitMode::ALPHA);
+	auto ret = std::make_shared<SDLImageShared>(scaled, preScaleFactor);
 
 	ret->fullSize.x = (int) round((float)fullSize.x * scaleX);
 	ret->fullSize.y = (int) round((float)fullSize.y * scaleY);
@@ -195,167 +343,295 @@
 	// erase our own reference
 	SDL_FreeSurface(scaled);
 
-	return std::shared_ptr<IImage>(ret);
-}
+	if (surf->format->palette)
+		SDL_SetSurfacePalette(surf, originalPalette);
 
-void SDLImage::exportBitmap(const boost::filesystem::path& path) const
-{
-	SDL_SaveBMP(surf, path.string().c_str());
+	return ret;
 }
 
-void SDLImage::playerColored(PlayerColor player)
+void SDLImageShared::exportBitmap(const boost::filesystem::path& path, SDL_Palette * palette) const
 {
 	if (!surf)
 		return;
-	graphics->blueToPlayersAdv(surf, player);
-}
-
-void SDLImage::setAlpha(uint8_t value)
-{
-	CSDL_Ext::setAlpha (surf, value);
-	if (value != 255)
-		SDL_SetSurfaceBlendMode(surf, SDL_BLENDMODE_BLEND);
-}
 
-void SDLImage::setBlitMode(EImageBlitMode mode)
-{
-	blitMode = mode;
-
-	if (blitMode != EImageBlitMode::OPAQUE && surf->format->Amask != 0)
-		SDL_SetSurfaceBlendMode(surf, SDL_BLENDMODE_BLEND);
-	else
-		SDL_SetSurfaceBlendMode(surf, SDL_BLENDMODE_NONE);
+	if (palette && surf->format->palette)
+		SDL_SetSurfacePalette(surf, palette);
+	IMG_SavePNG(surf, path.string().c_str());
+	if (palette && surf->format->palette)
+		SDL_SetSurfacePalette(surf, originalPalette);
 }
 
-void SDLImage::setFlagColor(PlayerColor player)
+void SDLImageIndexed::playerColored(PlayerColor player)
 {
-	if(player.isValidPlayer() || player==PlayerColor::NEUTRAL)
-		CSDL_Ext::setPlayerColor(surf, player);
+	graphics->setPlayerPalette(currentPalette, player);
 }
 
-bool SDLImage::isTransparent(const Point & coords) const
+bool SDLImageShared::isTransparent(const Point & coords) const
 {
 	if (surf)
-		return CSDL_Ext::isTransparent(surf, coords.x, coords.y);
+		return CSDL_Ext::isTransparent(surf, coords.x - margins.x, coords.y	- margins.y);
 	else
 		return true;
 }
 
-Point SDLImage::dimensions() const
+Point SDLImageShared::dimensions() const
 {
-	return fullSize;
+	return fullSize / preScaleFactor;
 }
 
-void SDLImage::horizontalFlip()
+std::shared_ptr<IImage> SDLImageShared::createImageReference(EImageBlitMode mode) const
 {
-	margins.y = fullSize.y - surf->h - margins.y;
-
-	//todo: modify in-place
-	SDL_Surface * flipped = CSDL_Ext::horizontalFlip(surf);
-	SDL_FreeSurface(surf);
-	surf = flipped;
+	if (surf && surf->format->palette)
+		return std::make_shared<SDLImageIndexed>(shared_from_this(), originalPalette, mode);
+	else
+		return std::make_shared<SDLImageRGB>(shared_from_this(), mode);
 }
 
-void SDLImage::verticalFlip()
+std::shared_ptr<const ISharedImage> SDLImageShared::horizontalFlip() const
 {
-	margins.x = fullSize.x - surf->w - margins.x;
+	SDL_Surface * flipped = CSDL_Ext::horizontalFlip(surf);
+	auto ret = std::make_shared<SDLImageShared>(flipped, preScaleFactor);
+	ret->fullSize = fullSize;
+	ret->margins.x = margins.x;
+	ret->margins.y = fullSize.y - surf->h - margins.y;
+	ret->fullSize = fullSize;
 
-	//todo: modify in-place
-	SDL_Surface * flipped = CSDL_Ext::verticalFlip(surf);
-	SDL_FreeSurface(surf);
-	surf = flipped;
+	return ret;
 }
 
-void SDLImage::doubleFlip()
+std::shared_ptr<const ISharedImage> SDLImageShared::verticalFlip() const
 {
-	horizontalFlip();
-	verticalFlip();
+	SDL_Surface * flipped = CSDL_Ext::verticalFlip(surf);
+	auto ret = std::make_shared<SDLImageShared>(flipped, preScaleFactor);
+	ret->fullSize = fullSize;
+	ret->margins.x = fullSize.x - surf->w - margins.x;
+	ret->margins.y = margins.y;
+	ret->fullSize = fullSize;
+
+	return ret;
 }
 
 // Keep the original palette, in order to do color switching operation
-void SDLImage::savePalette()
+void SDLImageShared::savePalette()
 {
 	// For some images that don't have palette, skip this
 	if(surf->format->palette == nullptr)
 		return;
 
 	if(originalPalette == nullptr)
-		originalPalette = SDL_AllocPalette(DEFAULT_PALETTE_COLORS);
+		originalPalette = SDL_AllocPalette(surf->format->palette->ncolors);
 
-	SDL_SetPaletteColors(originalPalette, surf->format->palette->colors, 0, DEFAULT_PALETTE_COLORS);
+	SDL_SetPaletteColors(originalPalette, surf->format->palette->colors, 0, surf->format->palette->ncolors);
 }
 
-void SDLImage::shiftPalette(uint32_t firstColorID, uint32_t colorsToMove, uint32_t distanceToMove)
+void SDLImageIndexed::shiftPalette(uint32_t firstColorID, uint32_t colorsToMove, uint32_t distanceToMove)
 {
-	if(surf->format->palette)
-	{
-		std::vector<SDL_Color> shifterColors(colorsToMove);
+	std::vector<SDL_Color> shifterColors(colorsToMove);
 
-		for(uint32_t i=0; i<colorsToMove; ++i)
-		{
-			shifterColors[(i+distanceToMove)%colorsToMove] = originalPalette->colors[firstColorID + i];
-		}
-		CSDL_Ext::setColors(surf, shifterColors.data(), firstColorID, colorsToMove);
-	}
+	for(uint32_t i=0; i<colorsToMove; ++i)
+		shifterColors[(i+distanceToMove)%colorsToMove] = originalPalette->colors[firstColorID + i];
+
+	SDL_SetPaletteColors(currentPalette, shifterColors.data(), firstColorID, colorsToMove);
 }
 
-void SDLImage::adjustPalette(const ColorFilter & shifter, uint32_t colorsToSkipMask)
+void SDLImageIndexed::adjustPalette(const ColorFilter & shifter, uint32_t colorsToSkipMask)
 {
-	if(originalPalette == nullptr)
-		return;
-
-	SDL_Palette* palette = surf->format->palette;
+	// If shadow is enabled, following colors must be skipped unconditionally
+	if (blitMode == EImageBlitMode::WITH_SHADOW || blitMode == EImageBlitMode::WITH_SHADOW_AND_OVERLAY)
+		colorsToSkipMask |= (1 << 0) + (1 << 1) + (1 << 4);
 
 	// Note: here we skip first colors in the palette that are predefined in H3 images
-	for(int i = 0; i < palette->ncolors; i++)
+	for(int i = 0; i < currentPalette->ncolors; i++)
 	{
+		if (i < std::size(sourcePalette) && colorsSimilar(sourcePalette[i], originalPalette->colors[i]))
+			continue;
+
 		if(i < std::numeric_limits<uint32_t>::digits && ((colorsToSkipMask >> i) & 1) == 1)
 			continue;
 
-		palette->colors[i] = CSDL_Ext::toSDL(shifter.shiftColor(CSDL_Ext::fromSDL(originalPalette->colors[i])));
+		currentPalette->colors[i] = CSDL_Ext::toSDL(shifter.shiftColor(CSDL_Ext::fromSDL(originalPalette->colors[i])));
 	}
 }
 
-void SDLImage::resetPalette()
+SDLImageIndexed::SDLImageIndexed(const std::shared_ptr<const ISharedImage> & image, SDL_Palette * originalPalette, EImageBlitMode mode)
+	:SDLImageBase::SDLImageBase(image, mode)
+	,originalPalette(originalPalette)
 {
-	if(originalPalette == nullptr)
-		return;
-	
-	// Always keept the original palette not changed, copy a new palette to assign to surface
-	SDL_SetPaletteColors(surf->format->palette, originalPalette->colors, 0, originalPalette->ncolors);
+	currentPalette = SDL_AllocPalette(originalPalette->ncolors);
+	SDL_SetPaletteColors(currentPalette, originalPalette->colors, 0, originalPalette->ncolors);
+
+	preparePalette();
 }
 
-void SDLImage::resetPalette( int colorID )
+SDLImageIndexed::~SDLImageIndexed()
 {
-	if(originalPalette == nullptr)
-		return;
+	SDL_FreePalette(currentPalette);
+}
+
+void SDLImageIndexed::setShadowTransparency(float factor)
+{
+	ColorRGBA shadow50(0, 0, 0, 128 * factor);
+	ColorRGBA shadow25(0, 0, 0,  64 * factor);
+
+	std::array<SDL_Color, 5> colorsSDL = {
+		originalPalette->colors[0],
+		originalPalette->colors[1],
+		originalPalette->colors[2],
+		originalPalette->colors[3],
+		originalPalette->colors[4]
+	};
 
-	// Always keept the original palette not changed, copy a new palette to assign to surface
-	SDL_SetPaletteColors(surf->format->palette, originalPalette->colors + colorID, colorID, 1);
+	// seems to be used unconditionally
+	colorsSDL[0] = CSDL_Ext::toSDL(Colors::TRANSPARENCY);
+	colorsSDL[1] = CSDL_Ext::toSDL(shadow25);
+	colorsSDL[4] = CSDL_Ext::toSDL(shadow50);
+
+	// seems to be used only if color matches
+	if (colorsSimilar(originalPalette->colors[2], sourcePalette[2]))
+		colorsSDL[2] = CSDL_Ext::toSDL(shadow25);
+
+	if (colorsSimilar(originalPalette->colors[3], sourcePalette[3]))
+		colorsSDL[3] = CSDL_Ext::toSDL(shadow50);
+
+	SDL_SetPaletteColors(currentPalette, colorsSDL.data(), 0, colorsSDL.size());
 }
 
-void SDLImage::setSpecialPallete(const IImage::SpecialPalette & specialPalette, uint32_t colorsToSkipMask)
+void SDLImageIndexed::setOverlayColor(const ColorRGBA & color)
 {
-	if(surf->format->palette)
-	{
-		size_t last = std::min<size_t>(specialPalette.size(), surf->format->palette->ncolors);
+	currentPalette->colors[5] = CSDL_Ext::toSDL(addColors(targetPalette[5], color));
 
-		for (size_t i = 0; i < last; ++i)
-		{
-			if(i < std::numeric_limits<uint32_t>::digits && ((colorsToSkipMask >> i) & 1) == 1)
-				surf->format->palette->colors[i] = CSDL_Ext::toSDL(specialPalette[i]);
-		}
+	for (int i : {6,7})
+	{
+		if (colorsSimilar(originalPalette->colors[i], sourcePalette[i]))
+			currentPalette->colors[i] = CSDL_Ext::toSDL(addColors(targetPalette[i], color));
 	}
 }
 
-SDLImage::~SDLImage()
+void SDLImageIndexed::preparePalette()
 {
-	SDL_FreeSurface(surf);
+	switch(blitMode)
+	{
+		case EImageBlitMode::ONLY_SHADOW:
+		case EImageBlitMode::ONLY_OVERLAY:
+			adjustPalette(ColorFilter::genAlphaShifter(0), 0);
+			break;
+	}
 
-	if(originalPalette != nullptr)
+	switch(blitMode)
 	{
-		SDL_FreePalette(originalPalette);
-		originalPalette = nullptr;
+		case EImageBlitMode::SIMPLE:
+		case EImageBlitMode::WITH_SHADOW:
+		case EImageBlitMode::ONLY_SHADOW:
+		case EImageBlitMode::WITH_SHADOW_AND_OVERLAY:
+			setShadowTransparency(1.0);
+			break;
+		case EImageBlitMode::ONLY_BODY:
+		case EImageBlitMode::ONLY_BODY_IGNORE_OVERLAY:
+		case EImageBlitMode::ONLY_OVERLAY:
+			setShadowTransparency(0.0);
+			break;
 	}
+
+	switch(blitMode)
+	{
+		case EImageBlitMode::ONLY_OVERLAY:
+		case EImageBlitMode::WITH_SHADOW_AND_OVERLAY:
+			setOverlayColor(Colors::WHITE_TRUE);
+			break;
+		case EImageBlitMode::ONLY_SHADOW:
+		case EImageBlitMode::ONLY_BODY:
+			setOverlayColor(Colors::TRANSPARENCY);
+			break;
+	}
+}
+
+SDLImageShared::~SDLImageShared()
+{
+	SDL_FreeSurface(surf);
+	SDL_FreePalette(originalPalette);
 }
 
+SDLImageBase::SDLImageBase(const std::shared_ptr<const ISharedImage> & image, EImageBlitMode mode)
+	:image(image)
+	, alphaValue(SDL_ALPHA_OPAQUE)
+	, blitMode(mode)
+{}
+
+std::shared_ptr<const ISharedImage> SDLImageBase::getSharedImage() const
+{
+	return image;
+}
+
+void SDLImageRGB::draw(SDL_Surface * where, const Point & pos, const Rect * src) const
+{
+	image->draw(where, nullptr, pos, src, Colors::WHITE_TRUE, alphaValue, blitMode);
+}
+
+void SDLImageIndexed::draw(SDL_Surface * where, const Point & pos, const Rect * src) const
+{
+	image->draw(where, currentPalette, pos, src, Colors::WHITE_TRUE, alphaValue, blitMode);
+}
+
+void SDLImageIndexed::exportBitmap(const boost::filesystem::path & path) const
+{
+	image->exportBitmap(path, currentPalette);
+}
+
+void SDLImageIndexed::scaleTo(const Point & size)
+{
+	image = image->scaleTo(size, currentPalette);
+}
+
+void SDLImageRGB::scaleTo(const Point & size)
+{
+	image = image->scaleTo(size, nullptr);
+}
+
+void SDLImageIndexed::scaleInteger(int factor)
+{
+	image = image->scaleInteger(factor, currentPalette);
+}
+
+void SDLImageRGB::scaleInteger(int factor)
+{
+	image = image->scaleInteger(factor, nullptr);
+}
+
+void SDLImageRGB::exportBitmap(const boost::filesystem::path & path) const
+{
+	image->exportBitmap(path, nullptr);
+}
+
+bool SDLImageBase::isTransparent(const Point & coords) const
+{
+	return image->isTransparent(coords);
+}
+
+Point SDLImageBase::dimensions() const
+{
+	return image->dimensions();
+}
+
+void SDLImageBase::setAlpha(uint8_t value)
+{
+	alphaValue = value;
+}
+
+void SDLImageBase::setBlitMode(EImageBlitMode mode)
+{
+	blitMode = mode;
+}
+
+void SDLImageRGB::setOverlayColor(const ColorRGBA & color)
+{}
+
+void SDLImageRGB::playerColored(PlayerColor player)
+{}
+
+void SDLImageRGB::shiftPalette(uint32_t firstColorID, uint32_t colorsToMove, uint32_t distanceToMove)
+{}
+
+void SDLImageRGB::adjustPalette(const ColorFilter & shifter, uint32_t colorsToSkipMask)
+{}
+
+
diff --color -urN vcmi-1.5.7/client/renderSDL/SDLImage.h vcmi/client/renderSDL/SDLImage.h
--- vcmi-1.5.7/client/renderSDL/SDLImage.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/renderSDL/SDLImage.h	2024-12-19 15:00:22.302123307 +0100
@@ -24,60 +24,98 @@
 /*
  * Wrapper around SDL_Surface
  */
-class SDLImage : public IImage
+class SDLImageShared final : public ISharedImage, public std::enable_shared_from_this<SDLImageShared>, boost::noncopyable
 {
-public:
-	
-	const static int DEFAULT_PALETTE_COLORS = 256;
-	
 	//Surface without empty borders
 	SDL_Surface * surf;
+
+	SDL_Palette * originalPalette;
 	//size of left and top borders
 	Point margins;
 	//total size including borders
 	Point fullSize;
 
-	EImageBlitMode blitMode;
+	//pre scaled image
+	int preScaleFactor;
+
+	// Keep the original palette, in order to do color switching operation
+	void savePalette();
+
+	void optimizeSurface();
 
 public:
 	//Load image from def file
-	SDLImage(CDefFile *data, size_t frame, size_t group=0);
+	SDLImageShared(const CDefFile *data, size_t frame, size_t group=0, int preScaleFactor=1);
 	//Load from bitmap file
-	SDLImage(const ImagePath & filename, EImageBlitMode blitMode);
-
-	SDLImage(const JsonNode & conf, EImageBlitMode blitMode);
+	SDLImageShared(const ImagePath & filename, int preScaleFactor=1);
 	//Create using existing surface, extraRef will increase refcount on SDL_Surface
-	SDLImage(SDL_Surface * from, EImageBlitMode blitMode);
-	~SDLImage();
+	SDLImageShared(SDL_Surface * from, int preScaleFactor=1);
+	~SDLImageShared();
 
-	// Keep the original palette, in order to do color switching operation
-	void savePalette();
+	void draw(SDL_Surface * where, SDL_Palette * palette, const Point & dest, const Rect * src, const ColorRGBA & colorMultiplier, uint8_t alpha, EImageBlitMode mode) const override;
 
-	void draw(SDL_Surface * where, int posX=0, int posY=0, const Rect *src=nullptr) const override;
-	void draw(SDL_Surface * where, const Rect * dest, const Rect * src) const override;
-	std::shared_ptr<IImage> scaleFast(const Point & size) const override;
-	void exportBitmap(const boost::filesystem::path & path) const override;
-	void playerColored(PlayerColor player) override;
-	void setFlagColor(PlayerColor player) override;
-	bool isTransparent(const Point & coords) const override;
+	void exportBitmap(const boost::filesystem::path & path, SDL_Palette * palette) const override;
 	Point dimensions() const override;
+	bool isTransparent(const Point & coords) const override;
+	std::shared_ptr<IImage> createImageReference(EImageBlitMode mode) const override;
+	std::shared_ptr<const ISharedImage> horizontalFlip() const override;
+	std::shared_ptr<const ISharedImage> verticalFlip() const override;
+	std::shared_ptr<const ISharedImage> scaleInteger(int factor, SDL_Palette * palette) const override;
+	std::shared_ptr<const ISharedImage> scaleTo(const Point & size, SDL_Palette * palette) const override;
 
-	void horizontalFlip() override;
-	void verticalFlip() override;
-	void doubleFlip() override;
+	friend class SDLImageLoader;
+};
 
-	void shiftPalette(uint32_t firstColorID, uint32_t colorsToMove, uint32_t distanceToMove) override;
-	void adjustPalette(const ColorFilter & shifter, uint32_t colorsToSkipMask) override;
-	void resetPalette(int colorID) override;
-	void resetPalette() override;
+class SDLImageBase : public IImage, boost::noncopyable
+{
+protected:
+	std::shared_ptr<const ISharedImage> image;
+
+	uint8_t alphaValue;
+	EImageBlitMode blitMode;
 
+public:
+	SDLImageBase(const std::shared_ptr<const ISharedImage> & image, EImageBlitMode mode);
+
+	bool isTransparent(const Point & coords) const override;
+	Point dimensions() const override;
 	void setAlpha(uint8_t value) override;
 	void setBlitMode(EImageBlitMode mode) override;
+	std::shared_ptr<const ISharedImage> getSharedImage() const override;
+};
 
-	void setSpecialPallete(const SpecialPalette & SpecialPalette, uint32_t colorsToSkipMask) override;
+class SDLImageIndexed final : public SDLImageBase
+{
+	SDL_Palette * currentPalette = nullptr;
+	SDL_Palette * originalPalette = nullptr;
 
-	friend class SDLImageLoader;
+	void setShadowTransparency(float factor);
+	void preparePalette();
+public:
+	SDLImageIndexed(const std::shared_ptr<const ISharedImage> & image, SDL_Palette * palette, EImageBlitMode mode);
+	~SDLImageIndexed();
 
-private:
-	SDL_Palette * originalPalette;
+	void draw(SDL_Surface * where, const Point & pos, const Rect * src) const override;
+	void setOverlayColor(const ColorRGBA & color) override;
+	void playerColored(PlayerColor player) override;
+	void shiftPalette(uint32_t firstColorID, uint32_t colorsToMove, uint32_t distanceToMove) override;
+	void adjustPalette(const ColorFilter & shifter, uint32_t colorsToSkipMask) override;
+	void scaleInteger(int factor) override;
+	void scaleTo(const Point & size) override;
+	void exportBitmap(const boost::filesystem::path & path) const override;
+};
+
+class SDLImageRGB final : public SDLImageBase
+{
+public:
+	using SDLImageBase::SDLImageBase;
+
+	void draw(SDL_Surface * where, const Point & pos, const Rect * src) const override;
+	void setOverlayColor(const ColorRGBA & color) override;
+	void playerColored(PlayerColor player) override;
+	void shiftPalette(uint32_t firstColorID, uint32_t colorsToMove, uint32_t distanceToMove) override;
+	void adjustPalette(const ColorFilter & shifter, uint32_t colorsToSkipMask) override;
+	void scaleInteger(int factor) override;
+	void scaleTo(const Point & size) override;
+	void exportBitmap(const boost::filesystem::path & path) const override;
 };
diff --color -urN vcmi-1.5.7/client/renderSDL/SDLImageLoader.cpp vcmi/client/renderSDL/SDLImageLoader.cpp
--- vcmi-1.5.7/client/renderSDL/SDLImageLoader.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/renderSDL/SDLImageLoader.cpp	2024-12-19 15:00:22.302123307 +0100
@@ -17,7 +17,7 @@
 
 #include <SDL_surface.h>
 
-SDLImageLoader::SDLImageLoader(SDLImage * Img):
+SDLImageLoader::SDLImageLoader(SDLImageShared * Img):
 	image(Img),
 	lineStart(nullptr),
 	position(nullptr)
@@ -32,8 +32,8 @@
 	image->fullSize = FullSize;
 
 	//Prepare surface
-	SDL_Palette * p = SDL_AllocPalette(SDLImage::DEFAULT_PALETTE_COLORS);
-	SDL_SetPaletteColors(p, pal, 0, SDLImage::DEFAULT_PALETTE_COLORS);
+	SDL_Palette * p = SDL_AllocPalette(DEFAULT_PALETTE_COLORS);
+	SDL_SetPaletteColors(p, pal, 0, DEFAULT_PALETTE_COLORS);
 	SDL_SetSurfacePalette(image->surf, p);
 	SDL_FreePalette(p);
 
diff --color -urN vcmi-1.5.7/client/renderSDL/SDLImageLoader.h vcmi/client/renderSDL/SDLImageLoader.h
--- vcmi-1.5.7/client/renderSDL/SDLImageLoader.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/renderSDL/SDLImageLoader.h	2024-12-19 15:00:22.302123307 +0100
@@ -11,9 +11,13 @@
 
 #include "../render/IImageLoader.h"
 
+class SDLImageShared;
+
 class SDLImageLoader : public IImageLoader
 {
-	SDLImage * image;
+	static constexpr int DEFAULT_PALETTE_COLORS = 256;
+
+	SDLImageShared * image;
 	ui8 * lineStart;
 	ui8 * position;
 public:
@@ -25,7 +29,7 @@
 	//init image with these sizes and palette
 	void init(Point SpriteSize, Point Margins, Point FullSize, SDL_Color *pal);
 
-	SDLImageLoader(SDLImage * Img);
+	SDLImageLoader(SDLImageShared * Img);
 	~SDLImageLoader();
 };
 
diff --color -urN vcmi-1.5.7/client/renderSDL/SDL_PixelAccess.h vcmi/client/renderSDL/SDL_PixelAccess.h
--- vcmi-1.5.7/client/renderSDL/SDL_PixelAccess.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/renderSDL/SDL_PixelAccess.h	2024-12-19 15:00:22.306123473 +0100
@@ -109,58 +109,29 @@
 	};
 
 #endif
-
-	template<>
-	struct px<2>
-	{
-		static channel_subpx<5, 0xF800, 11> r;
-		static channel_subpx<6, 0x07E0, 5 > g;
-		static channel_subpx<5, 0x001F, 0 > b;
-		static channel_empty a;
-	};
 }
 
-template<int bpp, int incrementPtr>
+template<int bpp>
 struct ColorPutter
 {
 	static STRONG_INLINE void PutColor(uint8_t *&ptr, const uint8_t & R, const uint8_t & G, const uint8_t & B);
 	static STRONG_INLINE void PutColor(uint8_t *&ptr, const uint8_t & R, const uint8_t & G, const uint8_t & B, const uint8_t & A);
 	static STRONG_INLINE void PutColorAlphaSwitch(uint8_t *&ptr, const uint8_t & R, const uint8_t & G, const uint8_t & B, const uint8_t & A);
-	static STRONG_INLINE void PutColor(uint8_t *&ptr, const SDL_Color & Color);
 	static STRONG_INLINE void PutColorAlpha(uint8_t *&ptr, const SDL_Color & Color);
-	static STRONG_INLINE void PutColorRow(uint8_t *&ptr, const SDL_Color & Color, size_t count);
 };
 
-template <int incrementPtr>
-struct ColorPutter<2, incrementPtr>
-{
-	static STRONG_INLINE void PutColor(uint8_t *&ptr, const uint8_t & R, const uint8_t & G, const uint8_t & B);
-	static STRONG_INLINE void PutColor(uint8_t *&ptr, const uint8_t & R, const uint8_t & G, const uint8_t & B, const uint8_t & A);
-	static STRONG_INLINE void PutColorAlphaSwitch(uint8_t *&ptr, const uint8_t & R, const uint8_t & G, const uint8_t & B, const uint8_t & A);
-	static STRONG_INLINE void PutColor(uint8_t *&ptr, const SDL_Color & Color);
-	static STRONG_INLINE void PutColorAlpha(uint8_t *&ptr, const SDL_Color & Color);
-	static STRONG_INLINE void PutColorRow(uint8_t *&ptr, const SDL_Color & Color, size_t count);
-};
-
-template<int bpp, int incrementPtr>
-STRONG_INLINE void ColorPutter<bpp, incrementPtr>::PutColorAlpha(uint8_t *&ptr, const SDL_Color & Color)
+template<int bpp>
+STRONG_INLINE void ColorPutter<bpp>::PutColorAlpha(uint8_t *&ptr, const SDL_Color & Color)
 {
 	PutColor(ptr, Color.r, Color.g, Color.b, Color.a);
 }
 
-template<int bpp, int incrementPtr>
-STRONG_INLINE void ColorPutter<bpp, incrementPtr>::PutColor(uint8_t *&ptr, const SDL_Color & Color)
-{
-	PutColor(ptr, Color.r, Color.g, Color.b);
-}
-
-template<int bpp, int incrementPtr>
-STRONG_INLINE void ColorPutter<bpp, incrementPtr>::PutColorAlphaSwitch(uint8_t *&ptr, const uint8_t & R, const uint8_t & G, const uint8_t & B, const uint8_t & A)
+template<int bpp>
+STRONG_INLINE void ColorPutter<bpp>::PutColorAlphaSwitch(uint8_t *&ptr, const uint8_t & R, const uint8_t & G, const uint8_t & B, const uint8_t & A)
 {
 	switch (A)
 	{
 	case 0:
-		ptr += bpp * incrementPtr;
 		return;
 	case 255:
 		PutColor(ptr, R, G, B);
@@ -177,124 +148,19 @@
 	}
 }
 
-template<int bpp, int incrementPtr>
-STRONG_INLINE void ColorPutter<bpp, incrementPtr>::PutColor(uint8_t *&ptr, const uint8_t & R, const uint8_t & G, const uint8_t & B, const uint8_t & A)
+template<int bpp>
+STRONG_INLINE void ColorPutter<bpp>::PutColor(uint8_t *&ptr, const uint8_t & R, const uint8_t & G, const uint8_t & B, const uint8_t & A)
 {
 	PutColor(ptr, ((((uint32_t)R - (uint32_t)Channels::px<bpp>::r.get(ptr))*(uint32_t)A) >> 8 ) + (uint32_t)Channels::px<bpp>::r.get(ptr),
 				  ((((uint32_t)G - (uint32_t)Channels::px<bpp>::g.get(ptr))*(uint32_t)A) >> 8 ) + (uint32_t)Channels::px<bpp>::g.get(ptr),
 				  ((((uint32_t)B - (uint32_t)Channels::px<bpp>::b.get(ptr))*(uint32_t)A) >> 8 ) + (uint32_t)Channels::px<bpp>::b.get(ptr));
 }
 
-
-template<int bpp, int incrementPtr>
-STRONG_INLINE void ColorPutter<bpp, incrementPtr>::PutColor(uint8_t *&ptr, const uint8_t & R, const uint8_t & G, const uint8_t & B)
+template<int bpp>
+STRONG_INLINE void ColorPutter<bpp>::PutColor(uint8_t *&ptr, const uint8_t & R, const uint8_t & G, const uint8_t & B)
 {
-	static_assert(incrementPtr >= -1 && incrementPtr <= +1, "Invalid incrementPtr value!");
-
-	if (incrementPtr < 0)
-		ptr -= bpp;
-
 	Channels::px<bpp>::r.set(ptr, R);
 	Channels::px<bpp>::g.set(ptr, G);
 	Channels::px<bpp>::b.set(ptr, B);
 	Channels::px<bpp>::a.set(ptr, 255);
-
-	if (incrementPtr > 0)
-		ptr += bpp;
-
-}
-
-template<int bpp, int incrementPtr>
-STRONG_INLINE void ColorPutter<bpp, incrementPtr>::PutColorRow(uint8_t *&ptr, const SDL_Color & Color, size_t count)
-{
-	if (count)
-	{
-		uint8_t *pixel = ptr;
-		PutColor(ptr, Color.r, Color.g, Color.b);
-
-		for (size_t i=0; i<count-1; i++)
-		{
-			memcpy(ptr, pixel, bpp);
-			ptr += bpp * incrementPtr;
-		}
-	}
-}
-
-template <int incrementPtr>
-STRONG_INLINE void ColorPutter<2, incrementPtr>::PutColor(uint8_t *&ptr, const uint8_t & R, const uint8_t & G, const uint8_t & B)
-{
-	if(incrementPtr == -1)
-		ptr -= 2;
-
-	auto * const px = (uint16_t *)ptr;
-	*px = (B>>3) + ((G>>2) << 5) + ((R>>3) << 11); //drop least significant bits of 24 bpp encoded color
-
-	if(incrementPtr == 1)
-		ptr += 2; //bpp
-}
-
-template <int incrementPtr>
-STRONG_INLINE void ColorPutter<2, incrementPtr>::PutColorAlphaSwitch(uint8_t *&ptr, const uint8_t & R, const uint8_t & G, const uint8_t & B, const uint8_t & A)
-{
-	switch (A)
-	{
-	case 0:
-		ptr += 2 * incrementPtr;
-		return;
-	case 255:
-		PutColor(ptr, R, G, B);
-		return;
-	default:
-		PutColor(ptr, R, G, B, A);
-		return;
-	}
-}
-
-template <int incrementPtr>
-STRONG_INLINE void ColorPutter<2, incrementPtr>::PutColor(uint8_t *&ptr, const uint8_t & R, const uint8_t & G, const uint8_t & B, const uint8_t & A)
-{
-	const int rbit = 5, gbit = 6, bbit = 5; //bits per color
-	const int rmask = 0xF800, gmask = 0x7E0, bmask = 0x1F;
-	const int rshift = 11, gshift = 5, bshift = 0;
-
-	const uint8_t r5 = (*((uint16_t *)ptr) & rmask) >> rshift,
-		b5 = (*((uint16_t *)ptr) & bmask) >> bshift,
-		g5 = (*((uint16_t *)ptr) & gmask) >> gshift;
-
-	const uint32_t r8 = (r5 << (8 - rbit)) | (r5 >> (2*rbit - 8)),
-		g8 = (g5 << (8 - gbit)) | (g5 >> (2*gbit - 8)),
-		b8 = (b5 << (8 - bbit)) | (b5 >> (2*bbit - 8));
-
-	PutColor(ptr,
-		(((R-r8)*A) >> 8) + r8,
-		(((G-g8)*A) >> 8) + g8,
-		(((B-b8)*A) >> 8) + b8);
-}
-
-template <int incrementPtr>
-STRONG_INLINE void ColorPutter<2, incrementPtr>::PutColorAlpha(uint8_t *&ptr, const SDL_Color & Color)
-{
-	PutColor(ptr, Color.r, Color.g, Color.b, Color.a);
-}
-
-template <int incrementPtr>
-STRONG_INLINE void ColorPutter<2, incrementPtr>::PutColor(uint8_t *&ptr, const SDL_Color & Color)
-{
-	PutColor(ptr, Color.r, Color.g, Color.b);
-}
-
-template <int incrementPtr>
-STRONG_INLINE void ColorPutter<2, incrementPtr>::PutColorRow(uint8_t *&ptr, const SDL_Color & Color, size_t count)
-{
-	//drop least significant bits of 24 bpp encoded color
-	uint16_t pixel = (Color.b>>3) + ((Color.g>>2) << 5) + ((Color.r>>3) << 11);
-
-	for (size_t i=0; i<count; i++)
-	{
-		memcpy(ptr, &pixel, 2);
-		if(incrementPtr == -1)
-			ptr -= 2;
-		if(incrementPtr == 1)
-			ptr += 2;
-	}
 }
diff --color -urN vcmi-1.5.7/client/ServerRunner.cpp vcmi/client/ServerRunner.cpp
--- vcmi-1.5.7/client/ServerRunner.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/ServerRunner.cpp	2024-12-19 15:00:22.241120786 +0100
@@ -15,27 +15,48 @@
 #include "../lib/CThreadHelper.h"
 #include "../server/CVCMIServer.h"
 
-#ifndef VCMI_MOBILE
+#ifdef ENABLE_SERVER_PROCESS
+
+#if BOOST_VERSION >= 108600
+// TODO: upgrade code to use v2 API instead of deprecated v1
+#include <boost/process/v1/child.hpp>
+#include <boost/process/v1/io.hpp>
+#else
 #include <boost/process/child.hpp>
 #include <boost/process/io.hpp>
 #endif
 
+#endif
+
+#include <future>
+
 ServerThreadRunner::ServerThreadRunner() = default;
 ServerThreadRunner::~ServerThreadRunner() = default;
 
-void ServerThreadRunner::start(uint16_t port, bool connectToLobby, std::shared_ptr<StartInfo> startingInfo)
+uint16_t ServerThreadRunner::start(uint16_t cfgport, bool connectToLobby, std::shared_ptr<StartInfo> startingInfo)
 {
-	server = std::make_unique<CVCMIServer>(port, connectToLobby, true);
+	// cfgport may be 0 -- the real port is returned after calling prepare()
+	server = std::make_unique<CVCMIServer>(cfgport, true);
 
 	if (startingInfo)
 	{
 		server->si = startingInfo; //Else use default
 	}
 
-	threadRunLocalServer = boost::thread([this]{
+	std::promise<uint16_t> promise;
+
+	threadRunLocalServer = boost::thread([this, connectToLobby, &promise]{
 		setThreadName("runServer");
+		uint16_t port = server->prepare(connectToLobby);
+		promise.set_value(port);
 		server->run();
 	});
+
+	logNetwork->trace("Waiting for server port...");
+	auto srvport = promise.get_future().get();
+	logNetwork->debug("Server port: %d", srvport);
+
+	return srvport;
 }
 
 void ServerThreadRunner::shutdown()
@@ -53,7 +74,7 @@
 	return 0;
 }
 
-#ifndef VCMI_MOBILE
+#ifdef ENABLE_SERVER_PROCESS
 
 ServerProcessRunner::ServerProcessRunner() = default;
 ServerProcessRunner::~ServerProcessRunner() = default;
@@ -73,7 +94,7 @@
 	return child->exit_code();
 }
 
-void ServerProcessRunner::start(uint16_t port, bool connectToLobby, std::shared_ptr<StartInfo> startingInfo)
+uint16_t ServerProcessRunner::start(uint16_t port, bool connectToLobby, std::shared_ptr<StartInfo> startingInfo)
 {
 	boost::filesystem::path serverPath = VCMIDirs::get().serverPath();
 	boost::filesystem::path logPath = VCMIDirs::get().userLogsPath() / "server_log.txt";
@@ -88,6 +109,8 @@
 
 	if (ec)
 		throw std::runtime_error("Failed to start server! Reason: " + ec.message());
+
+	return port;
 }
 
 #endif
diff --color -urN vcmi-1.5.7/client/ServerRunner.h vcmi/client/ServerRunner.h
--- vcmi-1.5.7/client/ServerRunner.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/ServerRunner.h	2024-12-19 15:00:22.241120786 +0100
@@ -20,7 +20,7 @@
 class IServerRunner
 {
 public:
-	virtual void start(uint16_t port, bool connectToLobby, std::shared_ptr<StartInfo> startingInfo) = 0;
+	virtual uint16_t start(uint16_t port, bool connectToLobby, std::shared_ptr<StartInfo> startingInfo) = 0;
 	virtual void shutdown() = 0;
 	virtual void wait() = 0;
 	virtual int exitCode() = 0;
@@ -34,7 +34,7 @@
 	std::unique_ptr<CVCMIServer> server;
 	boost::thread threadRunLocalServer;
 public:
-	void start(uint16_t port, bool connectToLobby, std::shared_ptr<StartInfo> startingInfo) override;
+	uint16_t start(uint16_t port, bool connectToLobby, std::shared_ptr<StartInfo> startingInfo) override;
 	void shutdown() override;
 	void wait() override;
 	int exitCode() override;
@@ -44,10 +44,23 @@
 };
 
 #ifndef VCMI_MOBILE
+// Enable support for running vcmiserver as separate process. Unavailable on mobile systems
+#define ENABLE_SERVER_PROCESS
+#endif
 
+#ifdef ENABLE_SERVER_PROCESS
+
+#if BOOST_VERSION >= 108600
+namespace boost::process {
+inline namespace v1 {
+class child;
+}
+}
+#else
 namespace boost::process {
 class child;
 }
+#endif
 
 /// Class that runs server instance as a child process
 /// Available only on desktop systems where process management is allowed
@@ -56,7 +69,7 @@
 	std::unique_ptr<boost::process::child> child;
 
 public:
-	void start(uint16_t port, bool connectToLobby, std::shared_ptr<StartInfo> startingInfo) override;
+	uint16_t start(uint16_t port, bool connectToLobby, std::shared_ptr<StartInfo> startingInfo) override;
 	void shutdown() override;
 	void wait() override;
 	int exitCode() override;
diff --color -urN vcmi-1.5.7/client/VCMI_client.cbp vcmi/client/VCMI_client.cbp
--- vcmi-1.5.7/client/VCMI_client.cbp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/VCMI_client.cbp	1970-01-01 01:00:00.000000000 +0100
@@ -1,267 +0,0 @@
-<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
-<CodeBlocks_project_file>
-	<FileVersion major="1" minor="6" />
-	<Project>
-		<Option title="VCMI_client" />
-		<Option pch_mode="2" />
-		<Option default_target="Debug-win64" />
-		<Option compiler="gcc" />
-		<Build>
-			<Target title="Debug-win32">
-				<Option platforms="Windows;" />
-				<Option output="../VCMI_client" prefix_auto="1" extension_auto="1" />
-				<Option working_dir="../" />
-				<Option object_output="../obj/Client/Debug/x86" />
-				<Option type="1" />
-				<Option compiler="gcc" />
-				<Compiler>
-					<Add option="-Og" />
-					<Add option="-g" />
-				</Compiler>
-				<Linker>
-					<Add option="-lboost_program_options$(#boost.libsuffix32)" />
-					<Add option="-lboost_filesystem$(#boost.libsuffix32)" />
-					<Add option="-lboost_system$(#boost.libsuffix32)" />
-					<Add option="-lboost_thread$(#boost.libsuffix32)" />
-					<Add option="-lboost_chrono$(#boost.libsuffix32)" />
-					<Add option="-lVCMI_lib" />
-					<Add directory="$(#sdl2.lib)" />
-					<Add directory="$(#boost.lib32)" />
-					<Add directory="$(#ffmpeg.lib32)" />
-				</Linker>
-			</Target>
-			<Target title="Release-win32">
-				<Option platforms="Windows;" />
-				<Option output="../VCMI_client" prefix_auto="1" extension_auto="1" />
-				<Option working_dir="../" />
-				<Option object_output="../obj/Client/Release/x86" />
-				<Option type="1" />
-				<Option compiler="gcc" />
-				<Compiler>
-					<Add option="-fomit-frame-pointer" />
-					<Add option="-O2" />
-				</Compiler>
-				<Linker>
-					<Add option="-s" />
-					<Add option="-lboost_program_options$(#boost.libsuffix32)" />
-					<Add option="-lboost_filesystem$(#boost.libsuffix32)" />
-					<Add option="-lboost_system$(#boost.libsuffix32)" />
-					<Add option="-lboost_thread$(#boost.libsuffix32)" />
-					<Add option="-lboost_chrono$(#boost.libsuffix32)" />
-					<Add option="-lVCMI_lib" />
-					<Add directory="$(#sdl2.lib)" />
-					<Add directory="$(#boost.lib32)" />
-					<Add directory="$(#ffmpeg.lib32)" />
-				</Linker>
-			</Target>
-			<Target title="Debug-win64">
-				<Option platforms="Windows;" />
-				<Option output="../VCMI_client" prefix_auto="1" extension_auto="1" />
-				<Option working_dir="../" />
-				<Option object_output="../obj/Client/Debug/x64" />
-				<Option type="1" />
-				<Option compiler="gnu_gcc_compiler_x64" />
-				<Compiler>
-					<Add option="-Og" />
-					<Add option="-g" />
-				</Compiler>
-				<Linker>
-					<Add option="-lboost_program_options$(#boost.libsuffix64)" />
-					<Add option="-lboost_filesystem$(#boost.libsuffix64)" />
-					<Add option="-lboost_system$(#boost.libsuffix64)" />
-					<Add option="-lboost_thread$(#boost.libsuffix64)" />
-					<Add option="-lboost_chrono$(#boost.libsuffix64)" />
-					<Add option="-lVCMI_lib" />
-					<Add directory="$(#sdl2.lib64)" />
-					<Add directory="$(#boost.lib64)" />
-					<Add directory="$(#ffmpeg.lib64)" />
-				</Linker>
-			</Target>
-		</Build>
-		<Compiler>
-			<Add option="-Wextra" />
-			<Add option="-Wall" />
-			<Add option="-std=gnu++11" />
-			<Add option="-fexceptions" />
-			<Add option="-Wpointer-arith" />
-			<Add option="-Wno-switch" />
-			<Add option="-Wno-sign-compare" />
-			<Add option="-Wno-unused-parameter" />
-			<Add option="-Wno-overloaded-virtual" />
-			<Add option="-isystem $(#boost.include)" />
-			<Add option="-DBOOST_ALL_DYN_LINK" />
-			<Add option="-DBOOST_SYSTEM_NO_DEPRECATED" />
-			<Add option="-D_WIN32_WINNT=0x0600" />
-			<Add option="-D_WIN32" />
-			<Add option="-DBOOST_UUID_RANDOM_PROVIDER_FORCE_WINCRYPT" />
-			<Add directory="../client" />
-			<Add directory="$(#ffmpeg.include)" />
-			<Add directory="$(#sdl2.include)" />
-			<Add directory="../include" />
-		</Compiler>
-		<Linker>
-			<Add option="-lole32" />
-			<Add option="-loleaut32" />
-			<Add option="-lws2_32" />
-			<Add option="-ladvapi32" />
-			<Add option="-lavcodec.dll" />
-			<Add option="-lavformat.dll" />
-			<Add option="-lswscale.dll" />
-			<Add option="-lavutil.dll" />
-			<Add option="-lSDL2.dll" />
-			<Add option="-lSDL2_image.dll" />
-			<Add option="-lSDL2_mixer.dll" />
-			<Add option="-lSDL2_ttf.dll" />
-			<Add directory="../" />
-		</Linker>
-		<Unit filename="../CCallback.cpp" />
-		<Unit filename="../CCallback.h" />
-		<Unit filename="CBitmapHandler.cpp" />
-		<Unit filename="CBitmapHandler.h" />
-		<Unit filename="CGameInfo.cpp" />
-		<Unit filename="CGameInfo.h" />
-		<Unit filename="CMT.cpp" />
-		<Unit filename="CMT.h" />
-		<Unit filename="CMessage.cpp" />
-		<Unit filename="CMessage.h" />
-		<Unit filename="CMusicHandler.cpp" />
-		<Unit filename="CMusicHandler.h" />
-		<Unit filename="CPlayerInterface.cpp" />
-		<Unit filename="CPlayerInterface.h" />
-		<Unit filename="CServerHandler.cpp" />
-		<Unit filename="CServerHandler.h" />
-		<Unit filename="CVideoHandler.cpp" />
-		<Unit filename="CVideoHandler.h" />
-		<Unit filename="Client.cpp" />
-		<Unit filename="Client.h" />
-		<Unit filename="CreatureCostBox.cpp" />
-		<Unit filename="CreatureCostBox.h" />
-		<Unit filename="Graphics.cpp" />
-		<Unit filename="Graphics.h" />
-		<Unit filename="NetPacksClient.cpp" />
-		<Unit filename="NetPacksLobbyClient.cpp" />
-		<Unit filename="SDLMain.h" />
-		<Unit filename="SDLRWwrapper.cpp" />
-		<Unit filename="SDLRWwrapper.h" />
-		<Unit filename="StdInc.h">
-			<Option compile="1" />
-			<Option weight="0" />
-		</Unit>
-		<Unit filename="VCMI_client.rc">
-			<Option compilerVar="WINDRES" />
-		</Unit>
-		<Unit filename="battle/CBattleAnimations.cpp" />
-		<Unit filename="battle/CBattleAnimations.h" />
-		<Unit filename="battle/CBattleInterface.cpp" />
-		<Unit filename="battle/CBattleInterface.h" />
-		<Unit filename="battle/CBattleInterfaceClasses.cpp" />
-		<Unit filename="battle/CBattleInterfaceClasses.h" />
-		<Unit filename="battle/CCreatureAnimation.cpp" />
-		<Unit filename="battle/CCreatureAnimation.h" />
-		<Unit filename="gui/CAnimation.cpp" />
-		<Unit filename="gui/CAnimation.h" />
-		<Unit filename="gui/CCursorHandler.cpp" />
-		<Unit filename="gui/CCursorHandler.h" />
-		<Unit filename="gui/CGuiHandler.cpp" />
-		<Unit filename="gui/CGuiHandler.h" />
-		<Unit filename="gui/CIntObject.cpp" />
-		<Unit filename="gui/CIntObject.h" />
-		<Unit filename="gui/Fonts.cpp" />
-		<Unit filename="gui/Fonts.h" />
-		<Unit filename="gui/Geometries.cpp" />
-		<Unit filename="gui/Geometries.h" />
-		<Unit filename="gui/SDL_Compat.h" />
-		<Unit filename="gui/SDL_Extensions.cpp" />
-		<Unit filename="gui/SDL_Extensions.h" />
-		<Unit filename="gui/SDL_Pixels.h" />
-		<Unit filename="lobby/CBonusSelection.cpp" />
-		<Unit filename="lobby/CBonusSelection.h" />
-		<Unit filename="lobby/CLobbyScreen.cpp" />
-		<Unit filename="lobby/CLobbyScreen.h" />
-		<Unit filename="lobby/CSavingScreen.cpp" />
-		<Unit filename="lobby/CSavingScreen.h" />
-		<Unit filename="lobby/CScenarioInfoScreen.cpp" />
-		<Unit filename="lobby/CScenarioInfoScreen.h" />
-		<Unit filename="lobby/CSelectionBase.cpp" />
-		<Unit filename="lobby/CSelectionBase.h" />
-		<Unit filename="lobby/OptionsTab.cpp" />
-		<Unit filename="lobby/OptionsTab.h" />
-		<Unit filename="lobby/RandomMapTab.cpp" />
-		<Unit filename="lobby/RandomMapTab.h" />
-		<Unit filename="lobby/SelectionTab.cpp" />
-		<Unit filename="lobby/SelectionTab.h" />
-		<Unit filename="mainmenu/CCampaignScreen.cpp" />
-		<Unit filename="mainmenu/CCampaignScreen.h" />
-		<Unit filename="mainmenu/CMainMenu.cpp" />
-		<Unit filename="mainmenu/CMainMenu.h" />
-		<Unit filename="mainmenu/CPrologEpilogVideo.cpp" />
-		<Unit filename="mainmenu/CPrologEpilogVideo.h" />
-		<Unit filename="mainmenu/CreditsScreen.cpp" />
-		<Unit filename="mainmenu/CreditsScreen.h" />
-		<Unit filename="mainmenu/CHighScoreScreen.cpp" />
-		<Unit filename="mainmenu/CHighScoreScreen.h" />
-		<Unit filename="mapHandler.cpp" />
-		<Unit filename="mapHandler.h" />
-		<Unit filename="resource.h" />
-		<Unit filename="widgets/AdventureMapClasses.cpp" />
-		<Unit filename="widgets/AdventureMapClasses.h" />
-		<Unit filename="widgets/Buttons.cpp" />
-		<Unit filename="widgets/Buttons.h" />
-		<Unit filename="widgets/CArtifactHolder.cpp" />
-		<Unit filename="widgets/CArtifactHolder.h" />
-		<Unit filename="widgets/CComponent.cpp" />
-		<Unit filename="widgets/CComponent.h" />
-		<Unit filename="widgets/CGarrisonInt.cpp" />
-		<Unit filename="widgets/CGarrisonInt.h" />
-		<Unit filename="widgets/Images.cpp" />
-		<Unit filename="widgets/Images.h" />
-		<Unit filename="widgets/MiscWidgets.cpp" />
-		<Unit filename="widgets/MiscWidgets.h" />
-		<Unit filename="widgets/ObjectLists.cpp" />
-		<Unit filename="widgets/ObjectLists.h" />
-		<Unit filename="widgets/TextControls.cpp" />
-		<Unit filename="widgets/TextControls.h" />
-		<Unit filename="windows/CAdvmapInterface.cpp" />
-		<Unit filename="windows/CAdvmapInterface.h" />
-		<Unit filename="windows/CCastleInterface.cpp" />
-		<Unit filename="windows/CCastleInterface.h" />
-		<Unit filename="windows/CCreatureWindow.cpp" />
-		<Unit filename="windows/CCreatureWindow.h" />
-		<Unit filename="windows/CHeroOverview.cpp" />
-		<Unit filename="windows/CHeroOverview.h" />
-		<Unit filename="windows/CMapOverview.cpp" />
-		<Unit filename="windows/CMapOverview.h" />
-		<Unit filename="windows/CHeroWindow.cpp" />
-		<Unit filename="windows/CHeroWindow.h" />
-		<Unit filename="windows/CKingdomInterface.cpp" />
-		<Unit filename="windows/CKingdomInterface.h" />
-		<Unit filename="windows/CQuestLog.cpp" />
-		<Unit filename="windows/CQuestLog.h" />
-		<Unit filename="windows/CSpellWindow.cpp" />
-		<Unit filename="windows/CSpellWindow.h" />
-		<Unit filename="windows/CTradeWindow.cpp" />
-		<Unit filename="windows/CTradeWindow.h" />
-		<Unit filename="windows/CWindowObject.cpp" />
-		<Unit filename="windows/CWindowObject.h" />
-		<Unit filename="windows/CreaturePurchaseCard.cpp" />
-		<Unit filename="windows/CreaturePurchaseCard.h" />
-		<Unit filename="windows/GUIClasses.cpp" />
-		<Unit filename="windows/GUIClasses.h" />
-		<Unit filename="windows/InfoWindows.cpp" />
-		<Unit filename="windows/InfoWindows.h" />
-		<Unit filename="windows/QuickRecruitmentWindow.cpp" />
-		<Unit filename="windows/QuickRecruitmentWindow.h" />
-		<Extensions>
-			<DoxyBlocks>
-				<comment_style block="0" line="0" />
-				<doxyfile_project />
-				<doxyfile_build />
-				<doxyfile_warnings />
-				<doxyfile_output />
-				<doxyfile_dot />
-				<general />
-			</DoxyBlocks>
-			<lib_finder disable_auto="1" />
-		</Extensions>
-	</Project>
-</CodeBlocks_project_file>
diff --color -urN vcmi-1.5.7/client/VCMI_client.rc vcmi/client/VCMI_client.rc
--- vcmi-1.5.7/client/VCMI_client.rc	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/VCMI_client.rc	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-IDI_ICON1   ICON  "vcmi.ico"
\ No newline at end of file
diff --color -urN vcmi-1.5.7/client/VCMI_client.vcxproj vcmi/client/VCMI_client.vcxproj
--- vcmi-1.5.7/client/VCMI_client.vcxproj	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/VCMI_client.vcxproj	1970-01-01 01:00:00.000000000 +0100
@@ -1,333 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <ItemGroup Label="ProjectConfigurations">
-    <ProjectConfiguration Include="Debug|Win32">
-      <Configuration>Debug</Configuration>
-      <Platform>Win32</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Debug|x64">
-      <Configuration>Debug</Configuration>
-      <Platform>x64</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="RD|Win32">
-      <Configuration>RD</Configuration>
-      <Platform>Win32</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="RD|x64">
-      <Configuration>RD</Configuration>
-      <Platform>x64</Platform>
-    </ProjectConfiguration>
-  </ItemGroup>
-  <PropertyGroup Label="Globals">
-    <ProjectGuid>{8355EBA8-65C2-44A4-BC2D-78053E1BF2D6}</ProjectGuid>
-    <RootNamespace>VCMI_client</RootNamespace>
-    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
-  </PropertyGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='RD|Win32'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <CharacterSet>Unicode</CharacterSet>
-    <WholeProgramOptimization>true</WholeProgramOptimization>
-    <PlatformToolset>v142</PlatformToolset>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='RD|x64'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <CharacterSet>Unicode</CharacterSet>
-    <WholeProgramOptimization>true</WholeProgramOptimization>
-    <PlatformToolset>v140_xp</PlatformToolset>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <CharacterSet>Unicode</CharacterSet>
-    <PlatformToolset>v140_xp</PlatformToolset>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <CharacterSet>Unicode</CharacterSet>
-    <PlatformToolset>v140_xp</PlatformToolset>
-  </PropertyGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
-  <ImportGroup Label="ExtensionSettings">
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='RD|Win32'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-    <Import Project="..\VCMI_global_release.props" />
-    <Import Project="..\VCMI_global.props" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='RD|x64'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-    <Import Project="..\VCMI_global_release.props" />
-    <Import Project="..\VCMI_global.props" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-    <Import Project="..\VCMI_global_debug.props" />
-    <Import Project="..\VCMI_global.props" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-    <Import Project="..\VCMI_global_debug.props" />
-    <Import Project="..\VCMI_global.props" />
-  </ImportGroup>
-  <PropertyGroup Label="UserMacros" />
-  <PropertyGroup>
-    <_ProjectFileVersion>10.0.30128.1</_ProjectFileVersion>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..</OutDir>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(VCMI_Out)</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(Configuration)\</IntDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(Configuration)\</IntDir>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='RD|Win32'">$(VCMI_Out)</OutDir>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='RD|x64'">$(VCMI_Out)</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='RD|Win32'">$(Configuration)\</IntDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='RD|x64'">$(Configuration)\</IntDir>
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='RD|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='RD|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='RD|Win32'" />
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='RD|x64'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='RD|Win32'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='RD|x64'" />
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
-    <LibraryWPath />
-  </PropertyGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
-    <ClCompile>
-      <Optimization>
-      </Optimization>
-      <DisableSpecificWarnings>4251;%(DisableSpecificWarnings)</DisableSpecificWarnings>
-      <AssemblerOutput>NoListing</AssemblerOutput>
-      <PrecompiledHeader>Use</PrecompiledHeader>
-      <PrecompiledHeaderFile>StdInc.h</PrecompiledHeaderFile>
-      <AdditionalOptions>/MP4 /Zm150</AdditionalOptions>
-      <AdditionalIncludeDirectories>$(FFMPEGDIR);$(SDLDIR);$(BOOSTDIR);$(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-    </ClCompile>
-    <Link>
-      <AdditionalDependencies>avcodec.lib;avdevice.lib;avfilter.lib;avformat.lib;avutil.lib;postproc.lib;swresample.lib;swscale.lib;SDL.lib;zlib.lib;SDL_image.lib;SDL_ttf.lib;SDL_mixer.lib;VCMI_lib.lib;%(AdditionalDependencies)</AdditionalDependencies>
-      <ShowProgress>NotSet</ShowProgress>
-      <OptimizeReferences>true</OptimizeReferences>
-      <Profile>true</Profile>
-      <AdditionalLibraryDirectories>$(FFMPEGDIR)\lib;.;..\..\libs;..</AdditionalLibraryDirectories>
-    </Link>
-    <Manifest>
-      <AdditionalManifestFiles>$(ProjectDir)DPIaware.manifest;%(AdditionalManifestFiles)</AdditionalManifestFiles>
-    </Manifest>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
-    <ClCompile>
-      <PreprocessToFile>false</PreprocessToFile>
-      <PreprocessSuppressLineNumbers>false</PreprocessSuppressLineNumbers>
-      <DisableSpecificWarnings>4251;%(DisableSpecificWarnings)</DisableSpecificWarnings>
-      <AssemblerOutput>NoListing</AssemblerOutput>
-      <PrecompiledHeader>Use</PrecompiledHeader>
-      <PrecompiledHeaderFile>StdInc.h</PrecompiledHeaderFile>
-      <AdditionalOptions>/MP4 /Zm150</AdditionalOptions>
-    </ClCompile>
-    <Link>
-      <AdditionalDependencies>SDL.lib;zlib.lib;SDL_image.lib;SDL_ttf.lib;SDL_mixer.lib;VCMI_lib.lib;%(AdditionalDependencies)</AdditionalDependencies>
-      <ShowProgress>LinkVerbose</ShowProgress>
-      <OptimizeReferences>false</OptimizeReferences>
-      <Profile>true</Profile>
-    </Link>
-    <Manifest>
-      <AdditionalManifestFiles>$(ProjectDir)DPIaware.manifest;%(AdditionalManifestFiles)</AdditionalManifestFiles>
-    </Manifest>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='RD|Win32'">
-    <ClCompile>
-      <PrecompiledHeader>Use</PrecompiledHeader>
-      <PrecompiledHeaderFile>StdInc.h</PrecompiledHeaderFile>
-      <AdditionalOptions>
-      </AdditionalOptions>
-      <AdditionalIncludeDirectories>$(FFMPEGDIR);$(SDLDIR);$(BOOSTDIR);$(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <MultiProcessorCompilation>true</MultiProcessorCompilation>
-      <Optimization>Disabled</Optimization>
-    </ClCompile>
-    <Link>
-      <AdditionalDependencies>avcodec.lib;avdevice.lib;avfilter.lib;avformat.lib;avutil.lib;postproc.lib;swresample.lib;swscale.lib;zlib.lib;SDL2.lib;SDL2main.lib;VCMI_lib.lib;SDL2_mixer.lib;SDL2_image.lib;SDL2_ttf.lib;%(AdditionalDependencies)</AdditionalDependencies>
-      <Driver>NotSet</Driver>
-      <LinkTimeCodeGeneration>
-      </LinkTimeCodeGeneration>
-      <ShowProgress>NotSet</ShowProgress>
-      <AdditionalLibraryDirectories>$(VCMI_Out)</AdditionalLibraryDirectories>
-      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
-      <OptimizeReferences>true</OptimizeReferences>
-      <ForceFileOutput>MultiplyDefinedSymbolOnly</ForceFileOutput>
-      <AdditionalOptions>/LTCG /d2:-notypeopt %(AdditionalOptions)</AdditionalOptions>
-      <Profile>true</Profile>
-    </Link>
-    <CustomBuildStep>
-      <Command>
-      </Command>
-    </CustomBuildStep>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='RD|x64'">
-    <ClCompile>
-      <AdditionalOptions>/MP4 /Zm150</AdditionalOptions>
-      <PrecompiledHeader>Use</PrecompiledHeader>
-      <PrecompiledHeaderFile>StdInc.h</PrecompiledHeaderFile>
-    </ClCompile>
-    <Link>
-      <AdditionalDependencies>SDL.lib;zlib.lib;SDL_image.lib;SDL_ttf.lib;SDL_mixer.lib;VCMI_lib.lib;%(AdditionalDependencies)</AdditionalDependencies>
-      <Driver>NotSet</Driver>
-      <LinkTimeCodeGeneration>
-      </LinkTimeCodeGeneration>
-      <ShowProgress>NotSet</ShowProgress>
-      <Profile>true</Profile>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemGroup>
-    <ClCompile Include="..\CCallback.cpp" />
-    <ClCompile Include="battle\CBattleAnimations.cpp" />
-    <ClCompile Include="battle\CBattleInterface.cpp" />
-    <ClCompile Include="battle\CBattleInterfaceClasses.cpp" />
-    <ClCompile Include="battle\CCreatureAnimation.cpp" />
-    <ClCompile Include="CBitmapHandler.cpp" />
-    <ClCompile Include="CGameInfo.cpp" />
-    <ClCompile Include="Client.cpp" />
-    <ClCompile Include="CMessage.cpp" />
-    <ClCompile Include="CMT.cpp" />
-    <ClCompile Include="CMusicHandler.cpp" />
-    <ClCompile Include="CPlayerInterface.cpp" />
-    <ClCompile Include="CreatureCostBox.cpp" />
-    <ClCompile Include="CServerHandler.cpp" />
-    <ClCompile Include="CVideoHandler.cpp" />
-    <ClCompile Include="Graphics.cpp" />
-    <ClCompile Include="gui\CAnimation.cpp" />
-    <ClCompile Include="gui\CCursorHandler.cpp" />
-    <ClCompile Include="gui\CGuiHandler.cpp" />
-    <ClCompile Include="gui\CIntObject.cpp" />
-    <ClCompile Include="gui\Fonts.cpp" />
-    <ClCompile Include="gui\Geometries.cpp" />
-    <ClCompile Include="gui\SDL_Extensions.cpp" />
-    <ClCompile Include="lobby\CBonusSelection.cpp" />
-    <ClCompile Include="lobby\CLobbyScreen.cpp" />
-    <ClCompile Include="lobby\CSavingScreen.cpp" />
-    <ClCompile Include="lobby\CScenarioInfoScreen.cpp" />
-    <ClCompile Include="lobby\CSelectionBase.cpp" />
-    <ClCompile Include="lobby\OptionsTab.cpp" />
-    <ClCompile Include="lobby\RandomMapTab.cpp" />
-    <ClCompile Include="lobby\SelectionTab.cpp" />
-    <ClCompile Include="mainmenu\CCampaignScreen.cpp" />
-    <ClCompile Include="mainmenu\CMainMenu.cpp" />
-    <ClCompile Include="mainmenu\CPrologEpilogVideo.cpp" />
-    <ClCompile Include="mainmenu\CreditsScreen.cpp" />
-    <ClCompile Include="mainmenu\CHighScoreScreen.cpp" />
-    <ClCompile Include="mapHandler.cpp" />
-    <ClCompile Include="NetPacksClient.cpp" />
-    <ClCompile Include="NetPacksLobbyClient.cpp" />
-    <ClCompile Include="SDLRWwrapper.cpp" />
-    <ClCompile Include="StdInc.cpp">
-      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='RD|Win32'">Create</PrecompiledHeader>
-    </ClCompile>
-    <ClCompile Include="widgets\AdventureMapClasses.cpp" />
-    <ClCompile Include="widgets\Buttons.cpp" />
-    <ClCompile Include="widgets\CArtifactHolder.cpp" />
-    <ClCompile Include="widgets\CComponent.cpp" />
-    <ClCompile Include="widgets\CGarrisonInt.cpp" />
-    <ClCompile Include="widgets\Images.cpp" />
-    <ClCompile Include="widgets\MiscWidgets.cpp" />
-    <ClCompile Include="widgets\ObjectLists.cpp" />
-    <ClCompile Include="widgets\TextControls.cpp" />
-    <ClCompile Include="windows\CAdvmapInterface.cpp" />
-    <ClCompile Include="windows\CCastleInterface.cpp" />
-    <ClCompile Include="windows\CCreatureWindow.cpp" />
-    <ClCompile Include="windows\CHeroOverview.cpp" />
-    <ClCompile Include="windows\CMapOverview.cpp" />
-    <ClCompile Include="windows\CHeroWindow.cpp" />
-    <ClCompile Include="windows\CKingdomInterface.cpp" />
-    <ClCompile Include="windows\CQuestLog.cpp" />
-    <ClCompile Include="windows\CreaturePurchaseCard.cpp" />
-    <ClCompile Include="windows\CSpellWindow.cpp" />
-    <ClCompile Include="windows\CTradeWindow.cpp" />
-    <ClCompile Include="windows\CWindowObject.cpp" />
-    <ClCompile Include="windows\GUIClasses.cpp" />
-    <ClCompile Include="windows\InfoWindows.cpp" />
-    <ClCompile Include="windows\QuickRecruitmentWindow.cpp" />
-  </ItemGroup>
-  <ItemGroup>
-    <ClInclude Include="..\CCallback.h" />
-    <ClInclude Include="battle\CBattleAnimations.h" />
-    <ClInclude Include="battle\CBattleInterface.h" />
-    <ClInclude Include="battle\CBattleInterfaceClasses.h" />
-    <ClInclude Include="battle\CCreatureAnimation.h" />
-    <ClInclude Include="CBitmapHandler.h" />
-    <ClInclude Include="CGameInfo.h" />
-    <ClInclude Include="Client.h" />
-    <ClInclude Include="CMessage.h" />
-    <ClInclude Include="CMT.h" />
-    <ClInclude Include="CMusicHandler.h" />
-    <ClInclude Include="CPlayerInterface.h" />
-    <ClInclude Include="CreatureCostBox.h" />
-    <ClInclude Include="CServerHandler.h" />
-    <ClInclude Include="CVideoHandler.h" />
-    <ClInclude Include="Graphics.h" />
-    <ClInclude Include="gui\CAnimation.h" />
-    <ClInclude Include="gui\CCursorHandler.h" />
-    <ClInclude Include="gui\CGuiHandler.h" />
-    <ClInclude Include="gui\CIntObject.h" />
-    <ClInclude Include="gui\Fonts.h" />
-    <ClInclude Include="gui\Geometries.h" />
-    <ClInclude Include="gui\SDL_Compat.h" />
-    <ClInclude Include="gui\SDL_Extensions.h" />
-    <ClInclude Include="gui\SDL_Pixels.h" />
-    <ClInclude Include="lobby\CBonusSelection.h" />
-    <ClInclude Include="lobby\CLobbyScreen.h" />
-    <ClInclude Include="lobby\CSavingScreen.h" />
-    <ClInclude Include="lobby\CScenarioInfoScreen.h" />
-    <ClInclude Include="lobby\CSelectionBase.h" />
-    <ClInclude Include="lobby\OptionsTab.h" />
-    <ClInclude Include="lobby\RandomMapTab.h" />
-    <ClInclude Include="lobby\SelectionTab.h" />
-    <ClInclude Include="mainmenu\CCampaignScreen.h" />
-    <ClInclude Include="mainmenu\CMainMenu.h" />
-    <ClInclude Include="mainmenu\CPrologEpilogVideo.h" />
-    <ClInclude Include="mainmenu\CreditsScreen.h" />
-    <ClInclude Include="mainmenu\CHighScoreScreen.h" />
-    <ClInclude Include="mapHandler.h" />
-    <ClInclude Include="resource.h" />
-    <ClInclude Include="SDLRWwrapper.h" />
-    <ClInclude Include="StdInc.h" />
-    <ClInclude Include="widgets\AdventureMapClasses.h" />
-    <ClInclude Include="widgets\Buttons.h" />
-    <ClInclude Include="widgets\CArtifactHolder.h" />
-    <ClInclude Include="widgets\CComponent.h" />
-    <ClInclude Include="widgets\CGarrisonInt.h" />
-    <ClInclude Include="widgets\Images.h" />
-    <ClInclude Include="widgets\MiscWidgets.h" />
-    <ClInclude Include="widgets\ObjectLists.h" />
-    <ClInclude Include="widgets\TextControls.h" />
-    <ClInclude Include="windows\CAdvmapInterface.h" />
-    <ClInclude Include="windows\CCastleInterface.h" />
-    <ClInclude Include="windows\CCreatureWindow.h" />
-    <ClInclude Include="windows\CHeroOverview.h" />
-    <ClInclude Include="windows\CMapOverview.h" />
-    <ClInclude Include="windows\CHeroWindow.h" />
-    <ClInclude Include="windows\CKingdomInterface.h" />
-    <ClInclude Include="windows\CQuestLog.h" />
-    <ClInclude Include="windows\CreaturePurchaseCard.h" />
-    <ClInclude Include="windows\CSpellWindow.h" />
-    <ClInclude Include="windows\CTradeWindow.h" />
-    <ClInclude Include="windows\CWindowObject.h" />
-    <ClInclude Include="windows\GUIClasses.h" />
-    <ClInclude Include="windows\InfoWindows.h" />
-    <ClInclude Include="windows\QuickRecruitmentWindow.h" />
-  </ItemGroup>
-  <ItemGroup>
-    <None Include="vcmi.ico" />
-  </ItemGroup>
-  <ItemGroup>
-    <ResourceCompile Include="VCMI_client.rc" />
-  </ItemGroup>
-  <ItemGroup>
-    <ProjectReference Include="..\lib\VCMI_lib.vcxproj">
-      <Project>{b952ffc5-3039-4de1-9f08-90acda483d8f}</Project>
-    </ProjectReference>
-  </ItemGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
-</Project>
\ No newline at end of file
diff --color -urN vcmi-1.5.7/client/VCMI_client.vcxproj.filters vcmi/client/VCMI_client.vcxproj.filters
--- vcmi-1.5.7/client/VCMI_client.vcxproj.filters	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/VCMI_client.vcxproj.filters	1970-01-01 01:00:00.000000000 +0100
@@ -1,302 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <ItemGroup>
-    <ClCompile Include="CBitmapHandler.cpp" />
-    <ClCompile Include="CGameInfo.cpp" />
-    <ClCompile Include="Client.cpp" />
-    <ClCompile Include="CMessage.cpp" />
-    <ClCompile Include="CMT.cpp" />
-    <ClCompile Include="CMusicHandler.cpp" />
-    <ClCompile Include="CPlayerInterface.cpp" />
-    <ClCompile Include="CVideoHandler.cpp" />
-    <ClCompile Include="Graphics.cpp" />
-    <ClCompile Include="mapHandler.cpp" />
-    <ClCompile Include="NetPacksClient.cpp" />
-    <ClCompile Include="StdInc.cpp" />
-    <ClCompile Include="windows\CAdvmapInterface.cpp">
-      <Filter>windows</Filter>
-    </ClCompile>
-    <ClCompile Include="windows\CCastleInterface.cpp">
-      <Filter>windows</Filter>
-    </ClCompile>
-    <ClCompile Include="windows\CCreatureWindow.cpp">
-      <Filter>windows</Filter>
-    </ClCompile>
-    <ClCompile Include="windows\CHeroOverview.cpp">
-      <Filter>windows</Filter>
-    </ClCompile>
-    <ClCompile Include="windows\CMapOverview.cpp">
-      <Filter>windows</Filter>
-    </ClCompile>
-    <ClCompile Include="windows\CHeroWindow.cpp">
-      <Filter>windows</Filter>
-    </ClCompile>
-    <ClCompile Include="windows\CKingdomInterface.cpp">
-      <Filter>windows</Filter>
-    </ClCompile>
-    <ClCompile Include="windows\CQuestLog.cpp">
-      <Filter>windows</Filter>
-    </ClCompile>
-    <ClCompile Include="windows\CSpellWindow.cpp">
-      <Filter>windows</Filter>
-    </ClCompile>
-    <ClCompile Include="windows\CTradeWindow.cpp">
-      <Filter>windows</Filter>
-    </ClCompile>
-    <ClCompile Include="windows\CWindowObject.cpp">
-      <Filter>windows</Filter>
-    </ClCompile>
-    <ClCompile Include="windows\GUIClasses.cpp">
-      <Filter>windows</Filter>
-    </ClCompile>
-    <ClCompile Include="windows\InfoWindows.cpp">
-      <Filter>windows</Filter>
-    </ClCompile>
-    <ClCompile Include="widgets\AdventureMapClasses.cpp">
-      <Filter>widgets</Filter>
-    </ClCompile>
-    <ClCompile Include="widgets\Buttons.cpp">
-      <Filter>widgets</Filter>
-    </ClCompile>
-    <ClCompile Include="widgets\CArtifactHolder.cpp">
-      <Filter>widgets</Filter>
-    </ClCompile>
-    <ClCompile Include="widgets\CComponent.cpp">
-      <Filter>widgets</Filter>
-    </ClCompile>
-    <ClCompile Include="widgets\CGarrisonInt.cpp">
-      <Filter>widgets</Filter>
-    </ClCompile>
-    <ClCompile Include="widgets\Images.cpp">
-      <Filter>widgets</Filter>
-    </ClCompile>
-    <ClCompile Include="widgets\MiscWidgets.cpp">
-      <Filter>widgets</Filter>
-    </ClCompile>
-    <ClCompile Include="widgets\ObjectLists.cpp">
-      <Filter>widgets</Filter>
-    </ClCompile>
-    <ClCompile Include="widgets\TextControls.cpp">
-      <Filter>widgets</Filter>
-    </ClCompile>
-    <ClCompile Include="battle\CBattleAnimations.cpp">
-      <Filter>battle</Filter>
-    </ClCompile>
-    <ClCompile Include="battle\CBattleInterface.cpp">
-      <Filter>battle</Filter>
-    </ClCompile>
-    <ClCompile Include="battle\CBattleInterfaceClasses.cpp">
-      <Filter>battle</Filter>
-    </ClCompile>
-    <ClCompile Include="battle\CCreatureAnimation.cpp">
-      <Filter>battle</Filter>
-    </ClCompile>
-    <ClCompile Include="gui\CAnimation.cpp">
-      <Filter>gui</Filter>
-    </ClCompile>
-    <ClCompile Include="gui\CCursorHandler.cpp">
-      <Filter>gui</Filter>
-    </ClCompile>
-    <ClCompile Include="gui\CGuiHandler.cpp">
-      <Filter>gui</Filter>
-    </ClCompile>
-    <ClCompile Include="gui\CIntObject.cpp">
-      <Filter>gui</Filter>
-    </ClCompile>
-    <ClCompile Include="gui\Fonts.cpp">
-      <Filter>gui</Filter>
-    </ClCompile>
-    <ClCompile Include="gui\Geometries.cpp">
-      <Filter>gui</Filter>
-    </ClCompile>
-    <ClCompile Include="gui\SDL_Extensions.cpp">
-      <Filter>gui</Filter>
-    </ClCompile>
-    <ClCompile Include="..\CCallback.cpp" />
-    <ClCompile Include="SDLRWwrapper.cpp" />
-    <ClCompile Include="windows\QuickRecruitmentWindow.cpp">
-      <Filter>windows</Filter>
-    </ClCompile>
-    <ClCompile Include="windows\CreaturePurchaseCard.cpp">
-      <Filter>windows</Filter>
-    </ClCompile>
-    <ClCompile Include="CreatureCostBox.cpp" />
-    <ClCompile Include="CServerHandler.cpp" />
-    <ClCompile Include="NetPacksLobbyClient.cpp" />
-    <ClCompile Include="lobby\CBonusSelection.cpp" />
-    <ClCompile Include="lobby\CLobbyScreen.cpp" />
-    <ClCompile Include="lobby\CSavingScreen.cpp" />
-    <ClCompile Include="lobby\CScenarioInfoScreen.cpp" />
-    <ClCompile Include="lobby\CSelectionBase.cpp" />
-    <ClCompile Include="lobby\OptionsTab.cpp" />
-    <ClCompile Include="lobby\RandomMapTab.cpp" />
-    <ClCompile Include="lobby\SelectionTab.cpp" />
-    <ClCompile Include="mainmenu\CCampaignScreen.cpp" />
-    <ClCompile Include="mainmenu\CMainMenu.cpp" />
-    <ClCompile Include="mainmenu\CPrologEpilogVideo.cpp" />
-    <ClCompile Include="mainmenu\CreditsScreen.cpp" />
-    <ClCompile Include="mainmenu\CHighScoreScreen.cpp" />
-  </ItemGroup>
-  <ItemGroup>
-    <ResourceCompile Include="VCMI_client.rc" />
-  </ItemGroup>
-  <ItemGroup>
-    <None Include="vcmi.ico" />
-  </ItemGroup>
-  <ItemGroup>
-    <Filter Include="battle">
-      <UniqueIdentifier>{c25dc848-6e1b-4a9b-b6f2-517626e9a23d}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="gui">
-      <UniqueIdentifier>{cec5376d-0f32-475e-bf51-3dbae35c6b98}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="widgets">
-      <UniqueIdentifier>{2b5b57d6-28ba-4bcf-9691-0977171866d9}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="windows">
-      <UniqueIdentifier>{c9fcce39-f3af-4621-996c-0df7695134bd}</UniqueIdentifier>
-    </Filter>
-  </ItemGroup>
-  <ItemGroup>
-    <ClInclude Include="CBitmapHandler.h" />
-    <ClInclude Include="CGameInfo.h" />
-    <ClInclude Include="Client.h" />
-    <ClInclude Include="CMessage.h" />
-    <ClInclude Include="CMT.h" />
-    <ClInclude Include="CMusicHandler.h" />
-    <ClInclude Include="CPlayerInterface.h" />
-    <ClInclude Include="CVideoHandler.h" />
-    <ClInclude Include="Graphics.h" />
-    <ClInclude Include="mapHandler.h" />
-    <ClInclude Include="resource.h" />
-    <ClInclude Include="StdInc.h" />
-    <ClInclude Include="windows\CAdvmapInterface.h">
-      <Filter>windows</Filter>
-    </ClInclude>
-    <ClInclude Include="windows\CCastleInterface.h">
-      <Filter>windows</Filter>
-    </ClInclude>
-    <ClInclude Include="windows\CCreatureWindow.h">
-      <Filter>windows</Filter>
-    </ClInclude>
-    <ClInclude Include="windows\CHeroOverview.h">
-      <Filter>windows</Filter>
-    </ClInclude>
-    <ClInclude Include="windows\CMapOverview.h">
-      <Filter>windows</Filter>
-    </ClInclude>
-    <ClInclude Include="windows\CHeroWindow.h">
-      <Filter>windows</Filter>
-    </ClInclude>
-    <ClInclude Include="windows\CKingdomInterface.h">
-      <Filter>windows</Filter>
-    </ClInclude>
-    <ClInclude Include="windows\CQuestLog.h">
-      <Filter>windows</Filter>
-    </ClInclude>
-    <ClInclude Include="windows\CSpellWindow.h">
-      <Filter>windows</Filter>
-    </ClInclude>
-    <ClInclude Include="windows\CTradeWindow.h">
-      <Filter>windows</Filter>
-    </ClInclude>
-    <ClInclude Include="windows\CWindowObject.h">
-      <Filter>windows</Filter>
-    </ClInclude>
-    <ClInclude Include="windows\GUIClasses.h">
-      <Filter>windows</Filter>
-    </ClInclude>
-    <ClInclude Include="windows\InfoWindows.h">
-      <Filter>windows</Filter>
-    </ClInclude>
-    <ClInclude Include="widgets\AdventureMapClasses.h">
-      <Filter>widgets</Filter>
-    </ClInclude>
-    <ClInclude Include="widgets\Buttons.h">
-      <Filter>widgets</Filter>
-    </ClInclude>
-    <ClInclude Include="widgets\CArtifactHolder.h">
-      <Filter>widgets</Filter>
-    </ClInclude>
-    <ClInclude Include="widgets\CComponent.h">
-      <Filter>widgets</Filter>
-    </ClInclude>
-    <ClInclude Include="widgets\CGarrisonInt.h">
-      <Filter>widgets</Filter>
-    </ClInclude>
-    <ClInclude Include="widgets\Images.h">
-      <Filter>widgets</Filter>
-    </ClInclude>
-    <ClInclude Include="widgets\MiscWidgets.h">
-      <Filter>widgets</Filter>
-    </ClInclude>
-    <ClInclude Include="widgets\ObjectLists.h">
-      <Filter>widgets</Filter>
-    </ClInclude>
-    <ClInclude Include="widgets\TextControls.h">
-      <Filter>widgets</Filter>
-    </ClInclude>
-    <ClInclude Include="battle\CBattleAnimations.h">
-      <Filter>battle</Filter>
-    </ClInclude>
-    <ClInclude Include="battle\CBattleInterface.h">
-      <Filter>battle</Filter>
-    </ClInclude>
-    <ClInclude Include="battle\CBattleInterfaceClasses.h">
-      <Filter>battle</Filter>
-    </ClInclude>
-    <ClInclude Include="battle\CCreatureAnimation.h">
-      <Filter>battle</Filter>
-    </ClInclude>
-    <ClInclude Include="gui\CAnimation.h">
-      <Filter>gui</Filter>
-    </ClInclude>
-    <ClInclude Include="gui\CCursorHandler.h">
-      <Filter>gui</Filter>
-    </ClInclude>
-    <ClInclude Include="gui\CGuiHandler.h">
-      <Filter>gui</Filter>
-    </ClInclude>
-    <ClInclude Include="gui\CIntObject.h">
-      <Filter>gui</Filter>
-    </ClInclude>
-    <ClInclude Include="gui\Fonts.h">
-      <Filter>gui</Filter>
-    </ClInclude>
-    <ClInclude Include="gui\Geometries.h">
-      <Filter>gui</Filter>
-    </ClInclude>
-    <ClInclude Include="gui\SDL_Compat.h">
-      <Filter>gui</Filter>
-    </ClInclude>
-    <ClInclude Include="gui\SDL_Extensions.h">
-      <Filter>gui</Filter>
-    </ClInclude>
-    <ClInclude Include="gui\SDL_Pixels.h">
-      <Filter>gui</Filter>
-    </ClInclude>
-    <ClInclude Include="..\CCallback.h" />
-    <ClInclude Include="SDLRWwrapper.h" />
-    <ClInclude Include="windows\QuickRecruitmentWindow.h">
-      <Filter>windows</Filter>
-    </ClInclude>
-    <ClInclude Include="windows\CreaturePurchaseCard.h">
-      <Filter>windows</Filter>
-    </ClInclude>
-    <ClInclude Include="CreatureCostBox.h" />
-    <ClInclude Include="CServerHandler.h" />
-    <ClInclude Include="lobby\CBonusSelection.h" />
-    <ClInclude Include="lobby\CLobbyScreen.h" />
-    <ClInclude Include="lobby\CSavingScreen.h" />
-    <ClInclude Include="lobby\CScenarioInfoScreen.h" />
-    <ClInclude Include="lobby\CSelectionBase.h" />
-    <ClInclude Include="lobby\OptionsTab.h" />
-    <ClInclude Include="lobby\RandomMapTab.h" />
-    <ClInclude Include="lobby\SelectionTab.h" />
-    <ClInclude Include="mainmenu\CCampaignScreen.h" />
-    <ClInclude Include="mainmenu\CMainMenu.h" />
-    <ClInclude Include="mainmenu\CPrologEpilogVideo.h" />
-    <ClInclude Include="mainmenu\CreditsScreen.h" />
-    <ClInclude Include="mainmenu\CHighScoreScreen.h" />
-  </ItemGroup>
-</Project>
\ No newline at end of file
Binary files vcmi-1.5.7/client/vcmi.ico and vcmi/client/vcmi.ico differ
diff --color -urN vcmi-1.5.7/client/widgets/Buttons.cpp vcmi/client/widgets/Buttons.cpp
--- vcmi-1.5.7/client/widgets/Buttons.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/widgets/Buttons.cpp	2024-12-19 15:00:22.309123597 +0100
@@ -13,7 +13,6 @@
 #include "Images.h"
 #include "TextControls.h"
 
-#include "../CMusicHandler.h"
 #include "../CGameInfo.h"
 #include "../CPlayerInterface.h"
 #include "../battle/BattleInterface.h"
@@ -23,13 +22,13 @@
 #include "../gui/MouseButton.h"
 #include "../gui/Shortcut.h"
 #include "../gui/InterfaceObjectConfigurable.h"
+#include "../media/ISoundPlayer.h"
 #include "../windows/InfoWindows.h"
-#include "../render/CAnimation.h"
 #include "../render/Canvas.h"
 #include "../render/IRenderHandler.h"
 
 #include "../../lib/CConfigHandler.h"
-#include "../../lib/CGeneralTextHandler.h"
+#include "../../lib/texts/CGeneralTextHandler.h"
 #include "../../lib/filesystem/Filesystem.h"
 
 void ButtonBase::update()
@@ -50,7 +49,8 @@
 		// hero movement speed buttons: only three frames: normal, pressed and blocked/highlighted
 		if (state == EButtonState::HIGHLIGHTED && image->size() < 4)
 			image->setFrame(image->size()-1);
-		image->setFrame(stateToIndex[vstd::to_underlying(state)]);
+		else
+			image->setFrame(stateToIndex[vstd::to_underlying(state)]);
 	}
 
 	if (isActive())
@@ -67,9 +67,14 @@
 	this->callback += callback;
 }
 
+void CButton::addPopupCallback(const std::function<void()> & callback)
+{
+	this->callbackPopup += callback;
+}
+
 void ButtonBase::setTextOverlay(const std::string & Text, EFonts font, ColorRGBA color)
 {
-	OBJECT_CONSTRUCTION_CUSTOM_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	setOverlay(std::make_shared<CLabel>(pos.w/2, pos.h/2, font, ETextAlignment::CENTER, color, Text));
 	update();
 }
@@ -88,14 +93,14 @@
 
 void ButtonBase::setImage(const AnimationPath & defName, bool playerColoredButton)
 {
-	OBJECT_CONSTRUCTION_CUSTOM_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	configurable.reset();
 	image = std::make_shared<CAnimImage>(defName, vstd::to_underlying(getState()));
 	pos = image->pos;
 
 	if (playerColoredButton)
-		image->playerColored(LOCPLINT->playerID);
+		image->setPlayerColor(LOCPLINT->playerID);
 }
 
 const JsonNode & ButtonBase::getCurrentConfig() const
@@ -121,7 +126,7 @@
 
 void ButtonBase::setConfigurable(const JsonPath & jsonName, bool playerColoredButton)
 {
-	OBJECT_CONSTRUCTION_CUSTOM_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	config = std::make_unique<JsonNode>(jsonName);
 
@@ -130,7 +135,7 @@
 	pos = configurable->pos;
 
 	if (playerColoredButton)
-		image->playerColored(LOCPLINT->playerID);
+		image->setPlayerColor(LOCPLINT->playerID);
 }
 
 void CButton::addHoverText(EButtonState state, const std::string & text)
@@ -158,7 +163,7 @@
 
 	if (configurable)
 	{
-		OBJECT_CONSTRUCTION_CUSTOM_CAPTURING(255-DISPOSE);
+		OBJECT_CONSTRUCTION;
 		configurable = std::make_shared<InterfaceObjectConfigurable>(getCurrentConfig());
 		pos = configurable->pos;
 
@@ -289,6 +294,8 @@
 
 void CButton::showPopupWindow(const Point & cursorPosition)
 {
+	callbackPopup();
+
 	if(!helpBox.empty()) //there is no point to show window with nothing inside...
 		CRClickPopup::createAndPush(helpBox);
 }
@@ -350,7 +357,6 @@
 	hoverable(false),
 	soundDisabled(false)
 {
-	defActions = 255-DISPOSE;
 	addUsedEvents(LCLICK | SHOW_POPUP | HOVER | KEYBOARD);
 	hoverTexts[0] = help.first;
 }
@@ -358,7 +364,7 @@
 void ButtonBase::setPlayerColor(PlayerColor player)
 {
 	if (image && image->isPlayerColored())
-		image->playerColored(player);
+		image->setPlayerColor(player);
 }
 
 void CButton::showAll(Canvas & to)
@@ -441,10 +447,13 @@
 }
 
 CToggleButton::CToggleButton(Point position, const AnimationPath &defName, const std::pair<std::string, std::string> &help,
-							 CFunctionList<void(bool)> callback, EShortcut key, bool playerColoredButton):
+							 CFunctionList<void(bool)> callback, EShortcut key, bool playerColoredButton,
+				  			 CFunctionList<void()> callbackSelected):
   CButton(position, defName, help, 0, key, playerColoredButton),
-  CToggleBase(callback)
+  CToggleBase(callback),
+  callbackSelected(callbackSelected)
 {
+	addUsedEvents(DOUBLECLICK);
 }
 
 void CToggleButton::doSelect(bool on)
@@ -511,6 +520,12 @@
 	doSelect(isSelected());
 }
 
+void CToggleButton::clickDouble(const Point & cursorPosition)
+{
+	if(callbackSelected)
+		callbackSelected();
+}
+
 void CToggleGroup::addCallback(const std::function<void(int)> & callback)
 {
 	onChange += callback;
diff --color -urN vcmi-1.5.7/client/widgets/Buttons.h vcmi/client/widgets/Buttons.h
--- vcmi-1.5.7/client/widgets/Buttons.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/widgets/Buttons.h	2024-12-19 15:00:22.310123638 +0100
@@ -69,6 +69,7 @@
 class CButton : public ButtonBase
 {
 	CFunctionList<void()> callback;
+	CFunctionList<void()> callbackPopup;
 
 	std::array<std::string, 4> hoverTexts; //texts for statusbar, if empty - first entry will be used
 	std::optional<ColorRGBA> borderColor; // mapping of button state to border color
@@ -90,6 +91,7 @@
 
 	/// adds one more callback to on-click actions
 	void addCallback(const std::function<void()> & callback);
+	void addPopupCallback(const std::function<void()> & callback);
 
 	void addHoverText(EButtonState state, const std::string & text);
 
@@ -154,7 +156,7 @@
 
 	void addCallback(const std::function<void(bool)> & callback);
 
-	/// Set whether the toggle is currently enabled for user to use, this is only inplemented in ToggleButton, not for other toggles yet.
+	/// Set whether the toggle is currently enabled for user to use, this is only implemented in ToggleButton, not for other toggles yet.
 	virtual void setEnabled(bool enabled);
 };
 
@@ -164,13 +166,17 @@
 	void doSelect(bool on) override;
 	void setEnabled(bool enabled) override;
 
+	CFunctionList<void()> callbackSelected;
+
 public:
 	CToggleButton(Point position, const AnimationPath &defName, const std::pair<std::string, std::string> &help,
-				  CFunctionList<void(bool)> Callback = 0, EShortcut key = {}, bool playerColoredButton = false );
+				  CFunctionList<void(bool)> Callback = nullptr, EShortcut key = {}, bool playerColoredButton = false,
+				  CFunctionList<void()> CallbackSelected = nullptr );
 
 	void clickPressed(const Point & cursorPosition) override;
 	void clickReleased(const Point & cursorPosition) override;
 	void clickCancel(const Point & cursorPosition) override;
+	void clickDouble(const Point & cursorPosition) override;
 
 	// bring overrides into scope
 	//using CButton::addCallback;
diff --color -urN vcmi-1.5.7/client/widgets/CArtifactsOfHeroAltar.cpp vcmi/client/widgets/CArtifactsOfHeroAltar.cpp
--- vcmi-1.5.7/client/widgets/CArtifactsOfHeroAltar.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/widgets/CArtifactsOfHeroAltar.cpp	2024-12-19 15:00:22.311123679 +0100
@@ -21,12 +21,10 @@
 
 CArtifactsOfHeroAltar::CArtifactsOfHeroAltar(const Point & position)
 {
-	init(
-		std::bind(&CArtifactsOfHeroBase::clickPrassedArtPlace, this, _1, _2),
-		std::bind(&CArtifactsOfHeroBase::showPopupArtPlace, this, _1, _2),
-		position,
-		std::bind(&CArtifactsOfHeroBase::scrollBackpack, this, _1));
-
+	init(position, std::bind(&CArtifactsOfHeroBase::scrollBackpack, this, _1));
+	setClickPressedArtPlacesCallback(std::bind(&CArtifactsOfHeroBase::clickPressedArtPlace, this, _1, _2));
+	setShowPopupArtPlacesCallback(std::bind(&CArtifactsOfHeroBase::showPopupArtPlace, this, _1, _2));
+	enableGesture();
 	// The backpack is in the altar window above and to the right
 	for(auto & slot : backpack)
 		slot->moveBy(Point(2, -1));
diff --color -urN vcmi-1.5.7/client/widgets/CArtifactsOfHeroAltar.h vcmi/client/widgets/CArtifactsOfHeroAltar.h
--- vcmi-1.5.7/client/widgets/CArtifactsOfHeroAltar.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/widgets/CArtifactsOfHeroAltar.h	2024-12-19 15:00:22.312123721 +0100
@@ -16,6 +16,8 @@
 class CArtifactsOfHeroAltar : public CArtifactsOfHeroBase
 {
 public:
+	ObjectInstanceID altarId;
+
 	CArtifactsOfHeroAltar(const Point & position);
 	void deactivate() override;
 };
diff --color -urN vcmi-1.5.7/client/widgets/CArtifactsOfHeroBackpack.cpp vcmi/client/widgets/CArtifactsOfHeroBackpack.cpp
--- vcmi-1.5.7/client/widgets/CArtifactsOfHeroBackpack.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/widgets/CArtifactsOfHeroBackpack.cpp	2024-12-19 15:00:22.313123762 +0100
@@ -13,7 +13,7 @@
 #include "../gui/CGuiHandler.h"
 
 #include "Images.h"
-#include "GameSettings.h"
+#include "IGameSettings.h"
 #include "ObjectLists.h"
 
 #include "../CPlayerInterface.h"
@@ -34,12 +34,14 @@
 CArtifactsOfHeroBackpack::CArtifactsOfHeroBackpack()
 	: CArtifactsOfHeroBackpack(8, 8)
 {
-	const auto backpackCap = VLC->settings()->getInteger(EGameSettings::HEROES_BACKPACK_CAP);
+	const auto backpackCap = LOCPLINT->cb->getSettings().getInteger(EGameSettings::HEROES_BACKPACK_CAP);
 	auto visibleCapacityMax = slotsRowsMax * slotsColumnsMax;
 	if(backpackCap >= 0)
 		visibleCapacityMax = visibleCapacityMax > backpackCap ? backpackCap : visibleCapacityMax;
 
 	initAOHbackpack(visibleCapacityMax, backpackCap < 0 || visibleCapacityMax < backpackCap);
+	setClickPressedArtPlacesCallback(std::bind(&CArtifactsOfHeroBase::clickPressedArtPlace, this, _1, _2));
+	setShowPopupArtPlacesCallback(std::bind(&CArtifactsOfHeroBase::showPopupArtPlace, this, _1, _2));
 }
 
 void CArtifactsOfHeroBackpack::onSliderMoved(int newVal)
@@ -73,7 +75,7 @@
 
 void CArtifactsOfHeroBackpack::initAOHbackpack(size_t slots, bool slider)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255 - DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	backpack.resize(slots);
 	size_t artPlaceIdx = 0;
@@ -83,9 +85,7 @@
 			slotSizeWithMargin * (artPlaceIdx / slotsColumnsMax));
 		backpackSlotsBackgrounds.emplace_back(std::make_shared<CPicture>(ImagePath::builtin("heroWindow/artifactSlotEmpty"), pos));
 		artPlace = std::make_shared<CArtPlace>(pos);
-		artPlace->setArtifact(nullptr);
-		artPlace->setClickPressedCallback(std::bind(&CArtifactsOfHeroBase::clickPrassedArtPlace, this, _1, _2));
-		artPlace->setShowPopupCallback(std::bind(&CArtifactsOfHeroBase::showPopupArtPlace, this, _1, _2));
+		artPlace->setArtifact(ArtifactID(ArtifactID::NONE));
 		artPlaceIdx++;
 	}
 
@@ -126,12 +126,11 @@
 CArtifactsOfHeroQuickBackpack::CArtifactsOfHeroQuickBackpack(const ArtifactPosition filterBySlot)
 	: CArtifactsOfHeroBackpack(0, 0)
 {
-	assert(filterBySlot != ArtifactPosition::FIRST_AVAILABLE);
-
 	if(!ArtifactUtils::isSlotEquipment(filterBySlot))
 		return;
 
 	this->filterBySlot = filterBySlot;
+	setShowPopupArtPlacesCallback(std::bind(&CArtifactsOfHeroBase::showPopupArtPlace, this, _1, _2));
 }
 
 void CArtifactsOfHeroQuickBackpack::setHero(const CGHeroInstance * hero)
@@ -153,7 +152,7 @@
 		std::map<const ArtifactID, const CArtifactInstance*> filteredArts;
 		for(auto & slotInfo : curHero->artifactsInBackpack)
 			if(slotInfo.artifact->getTypeId() != artInSlotId &&	!slotInfo.artifact->isScroll() &&
-				slotInfo.artifact->artType->canBePutAt(curHero, filterBySlot, true))
+				slotInfo.artifact->getType()->canBePutAt(curHero, filterBySlot, true))
 			{
 				filteredArts.insert(std::pair(slotInfo.artifact->getTypeId(), slotInfo.artifact));
 			}
@@ -174,11 +173,12 @@
 		slotsColumnsMax = ceilf(sqrtf(requiredSlots));
 		slotsRowsMax = calcRows(requiredSlots);
 		initAOHbackpack(requiredSlots, false);
+		setClickPressedArtPlacesCallback(std::bind(&CArtifactsOfHeroBase::clickPressedArtPlace, this, _1, _2));
 		auto artPlace = backpack.begin();
 		for(auto & art : filteredArts)
-			setSlotData(*artPlace++, curHero->getSlotByInstance(art.second));
+			setSlotData(*artPlace++, curHero->getArtPos(art.second));
 		for(auto & art : filteredScrolls)
-			setSlotData(*artPlace++, curHero->getSlotByInstance(art.second));
+			setSlotData(*artPlace++, curHero->getArtPos(art.second));
 	}
 }
 
@@ -204,4 +204,4 @@
 		}
 	if(backpackLoc.slot != ArtifactPosition::PRE_FIRST && filterBySlot != ArtifactPosition::PRE_FIRST && curHero)
 		LOCPLINT->cb->swapArtifacts(backpackLoc, ArtifactLocation(curHero->id, filterBySlot));
-}
\ No newline at end of file
+}
diff --color -urN vcmi-1.5.7/client/widgets/CArtifactsOfHeroBase.cpp vcmi/client/widgets/CArtifactsOfHeroBase.cpp
--- vcmi-1.5.7/client/widgets/CArtifactsOfHeroBase.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/widgets/CArtifactsOfHeroBase.cpp	2024-12-19 15:00:22.316123886 +0100
@@ -32,9 +32,9 @@
 void CArtifactsOfHeroBase::putBackPickedArtifact()
 {
 	// Artifact located in artifactsTransitionPos should be returned
-	if(getPickedArtifact())
+	if(const auto art = getPickedArtifact())
 	{
-		auto slot = ArtifactUtils::getArtAnyPosition(curHero, curHero->artifactsTransitionPos.begin()->artifact->getTypeId());
+		auto slot = ArtifactUtils::getArtAnyPosition(curHero, art->getTypeId());
 		if(slot == ArtifactPosition::PRE_FIRST)
 		{
 			LOCPLINT->cb->eraseArtifactByClient(ArtifactLocation(curHero->id, ArtifactPosition::TRANSITION_POS));
@@ -47,13 +47,11 @@
 }
 
 void CArtifactsOfHeroBase::init(
-	const CArtPlace::ClickFunctor & onClickPressedCallback,
-	const CArtPlace::ClickFunctor & onShowPopupCallback,
 	const Point & position,
 	const BpackScrollFunctor & scrollCallback)
 {
-	// CArtifactsOfHeroBase::init may be transform to CArtifactsOfHeroBase::CArtifactsOfHeroBase if OBJECT_CONSTRUCTION_CAPTURING is removed
-	OBJECT_CONSTRUCTION_CAPTURING(255 - DISPOSE);
+	// CArtifactsOfHeroBase::init may be transform to CArtifactsOfHeroBase::CArtifactsOfHeroBase if OBJECT_CONSTRUCTION is removed
+	OBJECT_CONSTRUCTION;
 	pos += position;
 	for(int g = 0; g < ArtifactPosition::BACKPACK_START; g++)
 	{
@@ -65,18 +63,14 @@
 		auto artPlace = std::make_shared<CArtPlace>(Point(403 + 46 * s, 365));
 		backpack.push_back(artPlace);
 	}
-	for(auto artPlace : artWorn)
+	for(auto & artPlace : artWorn)
 	{
 		artPlace.second->slot = artPlace.first;
-		artPlace.second->setArtifact(nullptr);
-		artPlace.second->setClickPressedCallback(onClickPressedCallback);
-		artPlace.second->setShowPopupCallback(onShowPopupCallback);
-	}
-	for(auto artPlace : backpack)
-	{
-		artPlace->setArtifact(nullptr);
-		artPlace->setClickPressedCallback(onClickPressedCallback);
-		artPlace->setShowPopupCallback(onShowPopupCallback);
+		artPlace.second->setArtifact(ArtifactID(ArtifactID::NONE));
+	}
+	for(const auto & artPlace : backpack)
+	{
+		artPlace->setArtifact(ArtifactID(ArtifactID::NONE));
 	}
 	leftBackpackRoll = std::make_shared<CButton>(Point(379, 364), AnimationPath::builtin("hsbtns3.def"), CButton::tooltip(),
 		[scrollCallback](){scrollCallback(true);}, EShortcut::MOVE_LEFT);
@@ -91,27 +85,63 @@
 	setRedrawParent(true);
 }
 
-void CArtifactsOfHeroBase::clickPrassedArtPlace(CArtPlace & artPlace, const Point & cursorPosition)
+void CArtifactsOfHeroBase::setClickPressedArtPlacesCallback(const CArtPlace::ClickFunctor & callback) const
 {
-	if(clickPressedCallback)
-		clickPressedCallback(*this, artPlace, cursorPosition);
+	for(const auto & [slot, artPlace] : artWorn)
+		artPlace->setClickPressedCallback(callback);
+	for(const auto & artPlace : backpack)
+		artPlace->setClickPressedCallback(callback);
 }
 
-void CArtifactsOfHeroBase::showPopupArtPlace(CArtPlace & artPlace, const Point & cursorPosition)
+void CArtifactsOfHeroBase::setShowPopupArtPlacesCallback(const CArtPlace::ClickFunctor & callback) const
 {
-	if(showPopupCallback)
-		showPopupCallback(*this, artPlace, cursorPosition);
+	for(const auto & [slot, artPlace] : artWorn)
+		artPlace->setShowPopupCallback(callback);
+	for(const auto & artPlace : backpack)
+		artPlace->setShowPopupCallback(callback);
 }
 
-void CArtifactsOfHeroBase::gestureArtPlace(CArtPlace & artPlace, const Point & cursorPosition)
+void CArtifactsOfHeroBase::clickPressedArtPlace(CComponentHolder & artPlace, const Point & cursorPosition)
 {
-	if(gestureCallback)
-		gestureCallback(*this, artPlace, cursorPosition);
+	if(auto ownedPlace = getArtPlace(cursorPosition))
+	{
+		if(ownedPlace->isLocked())
+			return;
+
+		if(clickPressedCallback)
+			clickPressedCallback(*ownedPlace, cursorPosition);
+	}
+}
+
+void CArtifactsOfHeroBase::showPopupArtPlace(CComponentHolder & artPlace, const Point & cursorPosition)
+{
+	if(auto ownedPlace = getArtPlace(cursorPosition))
+	{
+		if(ownedPlace->isLocked())
+			return;
+
+		if(showPopupCallback)
+			showPopupCallback(*ownedPlace, cursorPosition);
+	}
+}
+
+void CArtifactsOfHeroBase::gestureArtPlace(CComponentHolder & artPlace, const Point & cursorPosition)
+{
+	if(auto ownedPlace = getArtPlace(cursorPosition))
+	{
+		if(ownedPlace->isLocked())
+			return;
+
+		if(gestureCallback)
+			gestureCallback(*ownedPlace, cursorPosition);
+	}
 }
 
 void CArtifactsOfHeroBase::setHero(const CGHeroInstance * hero)
 {
 	curHero = hero;
+	if (!hero)
+		return;
 
 	for(auto slot : artWorn)
 	{
@@ -130,9 +160,9 @@
 	LOCPLINT->cb->scrollBackpackArtifacts(curHero->id, left);
 }
 
-void CArtifactsOfHeroBase::markPossibleSlots(const CArtifactInstance * art, bool assumeDestRemoved)
+void CArtifactsOfHeroBase::markPossibleSlots(const CArtifact * art, bool assumeDestRemoved)
 {
-	for(auto artPlace : artWorn)
+	for(const auto & artPlace : artWorn)
 		artPlace.second->selectSlot(art->canBePutAt(curHero, artPlace.second->slot, assumeDestRemoved));
 }
 
@@ -147,26 +177,27 @@
 
 CArtifactsOfHeroBase::ArtPlacePtr CArtifactsOfHeroBase::getArtPlace(const ArtifactPosition & slot)
 {
-	if(ArtifactUtils::isSlotEquipment(slot))
-	{
-		if(artWorn.find(slot) == artWorn.end())
-		{
-			logGlobal->error("CArtifactsOfHero::getArtPlace: invalid slot %d", slot);
-			return nullptr;
-		}
+	if(ArtifactUtils::isSlotEquipment(slot) && artWorn.find(slot) != artWorn.end())
 		return artWorn[slot];
-	}
-	if(ArtifactUtils::isSlotBackpack(slot))
+	if(ArtifactUtils::isSlotBackpack(slot) && slot - ArtifactPosition::BACKPACK_START < backpack.size())
+		return(backpack[slot - ArtifactPosition::BACKPACK_START]);
+	logGlobal->error("CArtifactsOfHero::getArtPlace: invalid slot %d", slot);
+	return nullptr;
+}
+
+CArtifactsOfHeroBase::ArtPlacePtr CArtifactsOfHeroBase::getArtPlace(const Point & cursorPosition)
+{
+	for(const auto & [slot, artPlace] : artWorn)
 	{
-		for(ArtPlacePtr artPlace : backpack)
-			if(artPlace->slot == slot)
-				return artPlace;
-		return nullptr;
+		if(artPlace->pos.isInside(cursorPosition))
+			return artPlace;
 	}
-	else
+	for(const auto & artPlace : backpack)
 	{
-		return nullptr;
+		if(artPlace->pos.isInside(cursorPosition))
+			return artPlace;
 	}
+	return nullptr;
 }
 
 void CArtifactsOfHeroBase::updateWornSlots()
@@ -201,21 +232,31 @@
 const CArtifactInstance * CArtifactsOfHeroBase::getPickedArtifact()
 {
 	// Returns only the picked up artifact. Not just highlighted like in the trading window.
-	if(!curHero || curHero->artifactsTransitionPos.empty())
-		return nullptr;
-	else
+	if(curHero)
 		return curHero->getArt(ArtifactPosition::TRANSITION_POS);
+	else
+		return nullptr;
 }
 
-void CArtifactsOfHeroBase::addGestureCallback(CArtPlace::ClickFunctor callback)
+void CArtifactsOfHeroBase::enableGesture()
 {
 	for(auto & artPlace : artWorn)
 	{
-		artPlace.second->setGestureCallback(callback);
+		artPlace.second->setGestureCallback(std::bind(&CArtifactsOfHeroBase::gestureArtPlace, this, _1, _2));
 		artPlace.second->addUsedEvents(GESTURE);
 	}
 }
 
+const CArtifactInstance * CArtifactsOfHeroBase::getArt(const ArtifactPosition & slot) const
+{
+	return curHero ? curHero->getArt(slot) : nullptr;
+}
+
+void CArtifactsOfHeroBase::enableKeyboardShortcuts()
+{
+	addUsedEvents(AEventsReceiver::KEYBOARD);
+}
+
 void CArtifactsOfHeroBase::setSlotData(ArtPlacePtr artPlace, const ArtifactPosition & slot)
 {
 	// Spurious call from artifactMoved in attempt to update hidden backpack slot
@@ -228,26 +269,32 @@
 	if(auto slotInfo = curHero->getSlot(slot))
 	{
 		artPlace->lockSlot(slotInfo->locked);
-		artPlace->setArtifact(slotInfo->artifact);
+		artPlace->setArtifact(slotInfo->artifact->getTypeId(), slotInfo->artifact->getScrollSpellID());
 		if(slotInfo->locked || slotInfo->artifact->isCombined())
 			return;
 
 		// If the artifact is part of at least one combined artifact, add additional information
 		std::map<const ArtifactID, std::vector<ArtifactID>> arts;
-		for(const auto combinedArt : slotInfo->artifact->artType->getPartOf())
+		for(const auto combinedArt : slotInfo->artifact->getType()->getPartOf())
 		{
-			arts.try_emplace(combinedArt->getId(), std::vector<ArtifactID>{});
+			assert(combinedArt->isCombined());
+			arts.try_emplace(combinedArt->getId());
+			CArtifactFittingSet fittingSet(*curHero);
 			for(const auto part : combinedArt->getConstituents())
 			{
-				if(curHero->hasArt(part->getId(), false, false, false))
+				const auto partSlot = fittingSet.getArtPos(part->getId(), false, false);
+				if(partSlot != ArtifactPosition::PRE_FIRST)
+				{
 					arts.at(combinedArt->getId()).emplace_back(part->getId());
+					fittingSet.lockSlot(partSlot);
+				}
 			}
 		}
 		artPlace->addCombinedArtInfo(arts);
 	}
 	else
 	{
-		artPlace->setArtifact(nullptr);
+		artPlace->setArtifact(ArtifactID(ArtifactID::NONE));
 	}
 }
 
diff --color -urN vcmi-1.5.7/client/widgets/CArtifactsOfHeroBase.h vcmi/client/widgets/CArtifactsOfHeroBase.h
--- vcmi-1.5.7/client/widgets/CArtifactsOfHeroBase.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/widgets/CArtifactsOfHeroBase.h	2024-12-19 15:00:22.316123886 +0100
@@ -9,13 +9,15 @@
  */
 #pragma once
 
-#include "CArtPlace.h"
+#include "CComponentHolder.h"
 #include "Scrollable.h"
 
+#include "../gui/Shortcut.h"
+
 class CButton;
 class BackpackScroller;
 
-class CArtifactsOfHeroBase : virtual public CIntObject
+class CArtifactsOfHeroBase : virtual public CIntObject, public CKeyShortcut
 {
 protected:
 	using ArtPlacePtr = std::shared_ptr<CArtPlace>;
@@ -23,7 +25,7 @@
 
 public:
 	using ArtPlaceMap = std::map<ArtifactPosition, ArtPlacePtr>;
-	using ClickFunctor = std::function<void(CArtifactsOfHeroBase&, CArtPlace&, const Point&)>;
+	using ClickFunctor = std::function<void(CArtPlace&, const Point&)>;
 
 	ClickFunctor clickPressedCallback;
 	ClickFunctor showPopupCallback;
@@ -31,22 +33,26 @@
 	
 	CArtifactsOfHeroBase();
 	virtual void putBackPickedArtifact();
-	virtual void clickPrassedArtPlace(CArtPlace & artPlace, const Point & cursorPosition);
-	virtual void showPopupArtPlace(CArtPlace & artPlace, const Point & cursorPosition);
-	virtual void gestureArtPlace(CArtPlace & artPlace, const Point & cursorPosition);
+	virtual void clickPressedArtPlace(CComponentHolder & artPlace, const Point & cursorPosition);
+	virtual void showPopupArtPlace(CComponentHolder & artPlace, const Point & cursorPosition);
+	virtual void gestureArtPlace(CComponentHolder & artPlace, const Point & cursorPosition);
 	virtual void setHero(const CGHeroInstance * hero);
 	virtual const CGHeroInstance * getHero() const;
 	virtual void scrollBackpack(bool left);
-	virtual void markPossibleSlots(const CArtifactInstance * art, bool assumeDestRemoved = true);
+	virtual void markPossibleSlots(const CArtifact * art, bool assumeDestRemoved = true);
 	virtual void unmarkSlots();
 	virtual ArtPlacePtr getArtPlace(const ArtifactPosition & slot);
+	virtual ArtPlacePtr getArtPlace(const Point & cursorPosition);
 	virtual void updateWornSlots();
 	virtual void updateBackpackSlots();
 	virtual void updateSlot(const ArtifactPosition & slot);
 	virtual const CArtifactInstance * getPickedArtifact();
-	void addGestureCallback(CArtPlace::ClickFunctor callback);
+	void enableGesture();
+	const CArtifactInstance * getArt(const ArtifactPosition & slot) const;
+	void enableKeyboardShortcuts();
+	void setClickPressedArtPlacesCallback(const CArtPlace::ClickFunctor & callback) const;
+	void setShowPopupArtPlacesCallback(const CArtPlace::ClickFunctor & callback) const;
 
-protected:
 	const CGHeroInstance * curHero;
 	ArtPlaceMap artWorn;
 	std::vector<ArtPlacePtr> backpack;
@@ -65,8 +71,8 @@
 		Point(381,295) //18
 	};
 
-	virtual void init(const CArtPlace::ClickFunctor & lClickCallback, const CArtPlace::ClickFunctor & showPopupCallback,
-		const Point & position, const BpackScrollFunctor & scrollCallback);
+protected:
+	virtual void init(const Point & position, const BpackScrollFunctor & scrollCallback);
 	// Assigns an artifacts to an artifact place depending on it's new slot ID
 	virtual void setSlotData(ArtPlacePtr artPlace, const ArtifactPosition & slot);
 };
diff --color -urN vcmi-1.5.7/client/widgets/CArtifactsOfHeroKingdom.cpp vcmi/client/widgets/CArtifactsOfHeroKingdom.cpp
--- vcmi-1.5.7/client/widgets/CArtifactsOfHeroKingdom.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/widgets/CArtifactsOfHeroKingdom.cpp	2024-12-19 15:00:22.317123927 +0100
@@ -29,15 +29,15 @@
 	for(auto artPlace : artWorn)
 	{
 		artPlace.second->slot = artPlace.first;
-		artPlace.second->setArtifact(nullptr);
-		artPlace.second->setClickPressedCallback(std::bind(&CArtifactsOfHeroBase::clickPrassedArtPlace, this, _1, _2));
+		artPlace.second->setArtifact(ArtifactID(ArtifactID::NONE));
+		artPlace.second->setClickPressedCallback(std::bind(&CArtifactsOfHeroBase::clickPressedArtPlace, this, _1, _2));
 		artPlace.second->setShowPopupCallback(std::bind(&CArtifactsOfHeroBase::showPopupArtPlace, this, _1, _2));
 	}
-	addGestureCallback(std::bind(&CArtifactsOfHeroBase::gestureArtPlace, this, _1, _2));
+	enableGesture();
 	for(auto artPlace : backpack)
 	{
-		artPlace->setArtifact(nullptr);
-		artPlace->setClickPressedCallback(std::bind(&CArtifactsOfHeroBase::clickPrassedArtPlace, this, _1, _2));
+		artPlace->setArtifact(ArtifactID(ArtifactID::NONE));
+		artPlace->setClickPressedCallback(std::bind(&CArtifactsOfHeroBase::clickPressedArtPlace, this, _1, _2));
 		artPlace->setShowPopupCallback(std::bind(&CArtifactsOfHeroBase::showPopupArtPlace, this, _1, _2));
 	}
 	leftBackpackRoll->addCallback(std::bind(&CArtifactsOfHeroBase::scrollBackpack, this, -1));
diff --color -urN vcmi-1.5.7/client/widgets/CArtifactsOfHeroMain.cpp vcmi/client/widgets/CArtifactsOfHeroMain.cpp
--- vcmi-1.5.7/client/widgets/CArtifactsOfHeroMain.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/widgets/CArtifactsOfHeroMain.cpp	2024-12-19 15:00:22.318123968 +0100
@@ -20,22 +20,16 @@
 
 CArtifactsOfHeroMain::CArtifactsOfHeroMain(const Point & position)
 {
-	init(
-		std::bind(&CArtifactsOfHeroBase::clickPrassedArtPlace, this, _1, _2),
-		std::bind(&CArtifactsOfHeroBase::showPopupArtPlace, this, _1, _2),
-		position,
-		std::bind(&CArtifactsOfHeroBase::scrollBackpack, this, _1));
-	addGestureCallback(std::bind(&CArtifactsOfHeroBase::gestureArtPlace, this, _1, _2));
+	init(position, std::bind(&CArtifactsOfHeroBase::scrollBackpack, this, _1));
+	setClickPressedArtPlacesCallback(std::bind(&CArtifactsOfHeroBase::clickPressedArtPlace, this, _1, _2));
+	setShowPopupArtPlacesCallback(std::bind(&CArtifactsOfHeroBase::showPopupArtPlace, this, _1, _2));
+	enableGesture();
 }
 
 CArtifactsOfHeroMain::~CArtifactsOfHeroMain()
 {
-	CArtifactsOfHeroBase::putBackPickedArtifact();
-}
-
-void CArtifactsOfHeroMain::enableArtifactsCostumeSwitcher()
-{
-	addUsedEvents(AEventsReceiver::KEYBOARD);
+	if(curHero)
+		CArtifactsOfHeroBase::putBackPickedArtifact();
 }
 
 void CArtifactsOfHeroMain::keyPressed(EShortcut key)
diff --color -urN vcmi-1.5.7/client/widgets/CArtifactsOfHeroMain.h vcmi/client/widgets/CArtifactsOfHeroMain.h
--- vcmi-1.5.7/client/widgets/CArtifactsOfHeroMain.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/widgets/CArtifactsOfHeroMain.h	2024-12-19 15:00:22.318123968 +0100
@@ -11,14 +11,11 @@
 
 #include "CArtifactsOfHeroBase.h"
 
-#include "../gui/Shortcut.h"
-
-class CArtifactsOfHeroMain : public CArtifactsOfHeroBase, public CKeyShortcut
+class CArtifactsOfHeroMain : public CArtifactsOfHeroBase
 {
 public:
 	CArtifactsOfHeroMain(const Point & position);
 	~CArtifactsOfHeroMain() override;
-	void enableArtifactsCostumeSwitcher();
 	void keyPressed(EShortcut key) override;
 	void keyReleased(EShortcut key) override;
 
diff --color -urN vcmi-1.5.7/client/widgets/CArtifactsOfHeroMarket.cpp vcmi/client/widgets/CArtifactsOfHeroMarket.cpp
--- vcmi-1.5.7/client/widgets/CArtifactsOfHeroMarket.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/widgets/CArtifactsOfHeroMarket.cpp	2024-12-19 15:00:22.322124134 +0100
@@ -14,14 +14,34 @@
 
 CArtifactsOfHeroMarket::CArtifactsOfHeroMarket(const Point & position, const int selectionWidth)
 {
-	init(
-		std::bind(&CArtifactsOfHeroBase::clickPrassedArtPlace, this, _1, _2),
-		std::bind(&CArtifactsOfHeroBase::showPopupArtPlace, this, _1, _2),
-		position,
-		std::bind(&CArtifactsOfHeroBase::scrollBackpack, this, _1));
-
+	init(position, std::bind(&CArtifactsOfHeroBase::scrollBackpack, this, _1));
+	setClickPressedArtPlacesCallback(std::bind(&CArtifactsOfHeroBase::clickPressedArtPlace, this, _1, _2));
 	for(const auto & [slot, artPlace] : artWorn)
 		artPlace->setSelectionWidth(selectionWidth);
 	for(auto artPlace : backpack)
 		artPlace->setSelectionWidth(selectionWidth);
 };
+
+void CArtifactsOfHeroMarket::clickPressedArtPlace(CComponentHolder & artPlace, const Point & cursorPosition)
+{
+	if(auto ownedPlace = getArtPlace(cursorPosition))
+	{
+		if(ownedPlace->isLocked())
+			return;
+
+		if(const auto art = getArt(ownedPlace->slot))
+		{
+			if(onSelectArtCallback && art->getType()->isTradable())
+			{
+				unmarkSlots();
+				artPlace.selectSlot(true);
+				onSelectArtCallback(ownedPlace.get());
+			}
+			else
+			{
+				if(onClickNotTradableCallback)
+					onClickNotTradableCallback();
+			}
+		}
+	}
+}
diff --color -urN vcmi-1.5.7/client/widgets/CArtifactsOfHeroMarket.h vcmi/client/widgets/CArtifactsOfHeroMarket.h
--- vcmi-1.5.7/client/widgets/CArtifactsOfHeroMarket.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/widgets/CArtifactsOfHeroMarket.h	2024-12-19 15:00:22.322124134 +0100
@@ -14,7 +14,9 @@
 class CArtifactsOfHeroMarket : public CArtifactsOfHeroBase
 {
 public:
-	std::function<void(const CArtPlace*)> selectArtCallback;
+	std::function<void(const CArtPlace*)> onSelectArtCallback;
+	std::function<void()> onClickNotTradableCallback;
 
 	CArtifactsOfHeroMarket(const Point & position, const int selectionWidth);
+	void clickPressedArtPlace(CComponentHolder & artPlace, const Point & cursorPosition) override;
 };
diff --color -urN vcmi-1.5.7/client/widgets/CArtPlace.cpp vcmi/client/widgets/CArtPlace.cpp
--- vcmi-1.5.7/client/widgets/CArtPlace.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/widgets/CArtPlace.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,303 +0,0 @@
-/*
- * CArtPlace.cpp, part of VCMI engine
- *
- * Authors: listed in file AUTHORS in main folder
- *
- * License: GNU General Public License v2.0 or later
- * Full text of license available in license.txt file, in main folder
- *
- */
-#include "StdInc.h"
-#include "CArtPlace.h"
-
-#include "../gui/CGuiHandler.h"
-#include "../gui/Shortcut.h"
-
-#include "CComponent.h"
-
-#include "../windows/GUIClasses.h"
-#include "../render/Canvas.h"
-#include "../render/Colors.h"
-#include "../render/IRenderHandler.h"
-#include "../CPlayerInterface.h"
-#include "../CGameInfo.h"
-
-#include "../../CCallback.h"
-#include "../../lib/CGeneralTextHandler.h"
-#include "../../lib/ArtifactUtils.h"
-#include "../../lib/mapObjects/CGHeroInstance.h"
-#include "../../lib/networkPacks/ArtifactLocation.h"
-#include "../../lib/CConfigHandler.h"
-
-void CArtPlace::setInternals(const CArtifactInstance * artInst)
-{
-	ourArt = artInst;
-	if(!artInst)
-	{
-		image->disable();
-		text.clear();
-		hoverText = CGI->generaltexth->allTexts[507];
-		return;
-	}
-
-	imageIndex = artInst->artType->getIconIndex();
-	if(artInst->getTypeId() == ArtifactID::SPELL_SCROLL)
-	{
-		auto spellID = artInst->getScrollSpellID();
-		assert(spellID.num >= 0);
-
-		if(settings["general"]["enableUiEnhancements"].Bool())
-		{
-			imageIndex = spellID.num;
-			if(component.type != ComponentType::SPELL_SCROLL)
-			{
-				image->setScale(Point(pos.w, 34));
-				image->setAnimationPath(AnimationPath::builtin("spellscr"), imageIndex);
-				image->moveTo(Point(pos.x, pos.y + 4));
-			}
-		}
-		// Add spell component info (used to provide a pic in r-click popup)
-		component.type = ComponentType::SPELL_SCROLL;
-		component.subType = spellID;
-	}
-	else
-	{
-		if(settings["general"]["enableUiEnhancements"].Bool() && component.type != ComponentType::ARTIFACT)
-		{
-			image->setScale(Point());
-			image->setAnimationPath(AnimationPath::builtin("artifact"), imageIndex);
-			image->moveTo(Point(pos.x, pos.y));
-		}
-		component.type = ComponentType::ARTIFACT;
-		component.subType = artInst->getTypeId();
-	}
-	image->enable();
-	text = artInst->getDescription();
-}
-
-CArtPlace::CArtPlace(Point position, const CArtifactInstance * art)
-	: SelectableSlot(Rect(position, Point(44, 44)), Point(1, 1))
-	, ourArt(art)
-	, locked(false)
-{
-	OBJECT_CONSTRUCTION_CAPTURING(255 - DISPOSE);
-
-	imageIndex = 0;
-	if(locked)
-		imageIndex = ArtifactID::ART_LOCK;
-	else if(ourArt)
-		imageIndex = ourArt->artType->getIconIndex();
-
-	image = std::make_shared<CAnimImage>(AnimationPath::builtin("artifact"), imageIndex);
-	image->disable();
-}
-
-const CArtifactInstance * CArtPlace::getArt() const
-{
-	return ourArt;
-}
-
-CCommanderArtPlace::CCommanderArtPlace(Point position, const CGHeroInstance * commanderOwner, ArtifactPosition artSlot, const CArtifactInstance * art)
-	: CArtPlace(position, art),
-	commanderOwner(commanderOwner),
-	commanderSlotID(artSlot.num)
-{
-	setArtifact(art);
-}
-
-void CCommanderArtPlace::returnArtToHeroCallback()
-{
-	ArtifactPosition artifactPos = commanderSlotID;
-	ArtifactPosition freeSlot = ArtifactUtils::getArtBackpackPosition(commanderOwner, getArt()->getTypeId());
-	if(freeSlot == ArtifactPosition::PRE_FIRST)
-	{
-		LOCPLINT->showInfoDialog(CGI->generaltexth->translate("core.genrltxt.152"));
-	}
-	else
-	{
-		ArtifactLocation src(commanderOwner->id, artifactPos);
-		src.creature = SlotID::COMMANDER_SLOT_PLACEHOLDER;
-		ArtifactLocation dst(commanderOwner->id, freeSlot);
-
-		if(getArt()->canBePutAt(commanderOwner, freeSlot, true))
-		{
-			LOCPLINT->cb->swapArtifacts(src, dst);
-			setArtifact(nullptr);
-			parent->redraw();
-		}
-	}
-}
-
-void CCommanderArtPlace::clickPressed(const Point & cursorPosition)
-{
-	if(getArt() && text.size())
-		LOCPLINT->showYesNoDialog(CGI->generaltexth->translate("vcmi.commanderWindow.artifactMessage"), [this]() { returnArtToHeroCallback(); }, []() {});
-}
-
-void CCommanderArtPlace::showPopupWindow(const Point & cursorPosition)
-{
-	if(getArt() && text.size())
-		CArtPlace::showPopupWindow(cursorPosition);
-}
-
-void CArtPlace::lockSlot(bool on)
-{
-	if(locked == on)
-		return;
-
-	locked = on;
-
-	if(on)
-		image->setFrame(ArtifactID::ART_LOCK);
-	else if(ourArt)
-		image->setFrame(imageIndex);
-	else
-		image->setFrame(0);
-}
-
-bool CArtPlace::isLocked() const
-{
-	return locked;
-}
-
-void CArtPlace::clickPressed(const Point & cursorPosition)
-{
-	if(clickPressedCallback)
-		clickPressedCallback(*this, cursorPosition);
-}
-
-void CArtPlace::showPopupWindow(const Point & cursorPosition)
-{
-	if(showPopupCallback)
-		showPopupCallback(*this, cursorPosition);
-}
-
-void CArtPlace::gesture(bool on, const Point & initialPosition, const Point & finalPosition)
-{
-	if(!on)
-		return;
-
-	if(gestureCallback)
-		gestureCallback(*this, initialPosition);
-}
-
-void CArtPlace::setArtifact(const CArtifactInstance * art)
-{
-	setInternals(art);
-	if(art)
-	{
-		image->setFrame(locked ? static_cast<int>(ArtifactID::ART_LOCK) : imageIndex);
-
-		if(locked) // Locks should appear as empty.
-			hoverText = CGI->generaltexth->allTexts[507];
-		else
-			hoverText = boost::str(boost::format(CGI->generaltexth->heroscrn[1]) % ourArt->artType->getNameTranslated());
-	}
-	else
-	{
-		lockSlot(false);
-	}
-}
-
-void CArtPlace::setClickPressedCallback(const ClickFunctor & callback)
-{
-	clickPressedCallback = callback;
-}
-
-void CArtPlace::setShowPopupCallback(const ClickFunctor & callback)
-{
-	showPopupCallback = callback;
-}
-
-void CArtPlace::setGestureCallback(const ClickFunctor & callback)
-{
-	gestureCallback = callback;
-}
-
-void CArtPlace::addCombinedArtInfo(const std::map<const ArtifactID, std::vector<ArtifactID>> & arts)
-{
-	for(const auto & availableArts : arts)
-	{
-		const auto combinedArt = availableArts.first.toArtifact();
-		MetaString info;
-		info.appendEOL();
-		info.appendEOL();
-		info.appendRawString("{");
-		info.appendName(combinedArt->getId());
-		info.appendRawString("}");
-		info.appendRawString(" (%d/%d)");
-		info.replaceNumber(availableArts.second.size());
-		info.replaceNumber(combinedArt->getConstituents().size());
-		for(const auto part : combinedArt->getConstituents())
-		{
-			info.appendEOL();
-			if(vstd::contains(availableArts.second, part->getId()))
-			{
-				info.appendName(part->getId());
-			}
-			else
-			{
-				info.appendRawString("{#A9A9A9|");
-				info.appendName(part->getId());
-				info.appendRawString("}");
-			}
-		}
-		text += info.toString();
-	}
-}
-
-bool ArtifactUtilsClient::askToAssemble(const CGHeroInstance * hero, const ArtifactPosition & slot)
-{
-	assert(hero);
-	const auto art = hero->getArt(slot);
-	assert(art);
-
-	if(hero->tempOwner != LOCPLINT->playerID)
-		return false;
-
-	auto assemblyPossibilities = ArtifactUtils::assemblyPossibilities(hero, art->getTypeId());
-	if(!assemblyPossibilities.empty())
-	{
-		auto askThread = new boost::thread([hero, art, slot, assemblyPossibilities]() -> void
-			{
-				boost::mutex::scoped_lock interfaceLock(GH.interfaceMutex);
-				for(const auto combinedArt : assemblyPossibilities)
-				{
-					bool assembleConfirmed = false;
-					CFunctionList<void()> onYesHandlers([&assembleConfirmed]() -> void {assembleConfirmed = true; });
-					onYesHandlers += std::bind(&CCallback::assembleArtifacts, LOCPLINT->cb.get(), hero, slot, true, combinedArt->getId());
-
-					LOCPLINT->showArtifactAssemblyDialog(art->artType, combinedArt, onYesHandlers);
-					LOCPLINT->waitWhileDialog();
-					if(assembleConfirmed)
-						break;
-				}
-			});
-		askThread->detach();
-		return true;
-	}
-	return false;
-}
-
-bool ArtifactUtilsClient::askToDisassemble(const CGHeroInstance * hero, const ArtifactPosition & slot)
-{
-	assert(hero);
-	const auto art = hero->getArt(slot);
-	assert(art);
-
-	if(hero->tempOwner != LOCPLINT->playerID)
-		return false;
-
-	if(art->isCombined())
-	{
-		if(ArtifactUtils::isSlotBackpack(slot) && !ArtifactUtils::isBackpackFreeSlots(hero, art->artType->getConstituents().size() - 1))
-			return false;
-
-		LOCPLINT->showArtifactAssemblyDialog(
-			art->artType,
-			nullptr,
-			std::bind(&CCallback::assembleArtifacts, LOCPLINT->cb.get(), hero, slot, false, ArtifactID()));
-		return true;
-	}
-	return false;
-}
diff --color -urN vcmi-1.5.7/client/widgets/CArtPlace.h vcmi/client/widgets/CArtPlace.h
--- vcmi-1.5.7/client/widgets/CArtPlace.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/widgets/CArtPlace.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,67 +0,0 @@
-/*
- * CArtPlace.h, part of VCMI engine
- *
- * Authors: listed in file AUTHORS in main folder
- *
- * License: GNU General Public License v2.0 or later
- * Full text of license available in license.txt file, in main folder
- *
- */
-#pragma once
-
-#include "MiscWidgets.h"
-
-class CAnimImage;
-
-class CArtPlace : public SelectableSlot
-{
-public:
-	using ClickFunctor = std::function<void(CArtPlace&, const Point&)>;
-
-	ArtifactPosition slot;
-	
-	CArtPlace(Point position, const CArtifactInstance * art = nullptr);
-	const CArtifactInstance * getArt() const;
-	void lockSlot(bool on);
-	bool isLocked() const;
-	void setArtifact(const CArtifactInstance * art);
-	void setClickPressedCallback(const ClickFunctor & callback);
-	void setShowPopupCallback(const ClickFunctor & callback);
-	void setGestureCallback(const ClickFunctor & callback);
-	void clickPressed(const Point & cursorPosition) override;
-	void showPopupWindow(const Point & cursorPosition) override;
-	void gesture(bool on, const Point & initialPosition, const Point & finalPosition) override;
-	void addCombinedArtInfo(const std::map<const ArtifactID, std::vector<ArtifactID>> & arts);
-
-private:
-	const CArtifactInstance * ourArt;
-	bool locked;
-	int imageIndex;
-	std::shared_ptr<CAnimImage> image;
-	ClickFunctor clickPressedCallback;
-	ClickFunctor showPopupCallback;
-	ClickFunctor gestureCallback;
-
-protected:
-	void setInternals(const CArtifactInstance * artInst);
-};
-
-class CCommanderArtPlace : public CArtPlace
-{
-private:
-	const CGHeroInstance * commanderOwner;
-	ArtifactPosition commanderSlotID;
-
-	void returnArtToHeroCallback();
-
-public:
-	CCommanderArtPlace(Point position, const CGHeroInstance * commanderOwner, ArtifactPosition artSlot, const CArtifactInstance * art = nullptr);
-	void clickPressed(const Point & cursorPosition) override;
-	void showPopupWindow(const Point & cursorPosition) override;
-};
-
-namespace ArtifactUtilsClient
-{
-	bool askToAssemble(const CGHeroInstance * hero, const ArtifactPosition & slot);
-	bool askToDisassemble(const CGHeroInstance * hero, const ArtifactPosition & slot);
-}
diff --color -urN vcmi-1.5.7/client/widgets/CComponent.cpp vcmi/client/widgets/CComponent.cpp
--- vcmi-1.5.7/client/widgets/CComponent.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/widgets/CComponent.cpp	2024-12-19 15:00:22.323124175 +0100
@@ -12,15 +12,13 @@
 
 #include "Images.h"
 
-#include <vcmi/spells/Service.h>
-#include <vcmi/spells/Spell.h>
-
 #include "../gui/CGuiHandler.h"
 #include "../gui/CursorHandler.h"
 #include "../gui/TextAlignment.h"
 #include "../gui/Shortcut.h"
 #include "../render/Canvas.h"
 #include "../render/IFont.h"
+#include "../render/IRenderHandler.h"
 #include "../render/Graphics.h"
 #include "../windows/CMessage.h"
 #include "../windows/InfoWindows.h"
@@ -28,16 +26,23 @@
 #include "../CGameInfo.h"
 
 #include "../../lib/ArtifactUtils.h"
-#include "../../lib/CTownHandler.h"
-#include "../../lib/CHeroHandler.h"
+#include "../../lib/entities/building/CBuilding.h"
+#include "../../lib/entities/faction/CFaction.h"
+#include "../../lib/entities/faction/CTown.h"
+#include "../../lib/entities/faction/CTownHandler.h"
 #include "../../lib/networkPacks/Component.h"
 #include "../../lib/spells/CSpellHandler.h"
 #include "../../lib/CCreatureHandler.h"
 #include "../../lib/CSkillHandler.h"
-#include "../../lib/CGeneralTextHandler.h"
+#include "../../lib/texts/CGeneralTextHandler.h"
 #include "../../lib/CArtHandler.h"
 #include "../../lib/CArtifactInstance.h"
 
+#include <vcmi/spells/Service.h>
+#include <vcmi/spells/Spell.h>
+#include <vcmi/HeroTypeService.h>
+#include <vcmi/HeroType.h>
+
 CComponent::CComponent(ComponentType Type, ComponentSubType Subtype, std::optional<int32_t> Val, ESize imageSize, EFonts font)
 {
 	init(Type, Subtype, Val, imageSize, font, "");
@@ -55,7 +60,7 @@
 
 void CComponent::init(ComponentType Type, ComponentSubType Subtype, std::optional<int32_t> Val, ESize imageSize, EFonts fnt, const std::string & ValText)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	addUsedEvents(SHOW_POPUP);
 
@@ -66,6 +71,7 @@
 	customSubtitle = ValText;
 	size = imageSize;
 	font = fnt;
+	newLine = false;
 
 	assert(size < sizeInvalid);
 
@@ -92,9 +98,11 @@
 		max = 80;
 
 	std::vector<std::string> textLines = CMessage::breakText(getSubtitle(), std::max<int>(max, pos.w), font);
+	const auto & fontPtr = GH.renderHandler().loadFont(font);
+	const int height = static_cast<int>(fontPtr->getLineHeight());
+
 	for(auto & line : textLines)
 	{
-		int height = static_cast<int>(graphics->fonts[font]->getLineHeight());
 		auto label = std::make_shared<CLabel>(pos.w/2, pos.h + height/2, font, ETextAlignment::CENTER, Colors::WHITE, line);
 
 		pos.h += height;
@@ -222,15 +230,15 @@
 		case ComponentType::CREATURE:
 			return "";
 		case ComponentType::ARTIFACT:
-			return VLC->artifacts()->getById(data.subType.as<ArtifactID>())->getDescriptionTranslated();
+			return CGI->artifacts()->getById(data.subType.as<ArtifactID>())->getDescriptionTranslated();
 		case ComponentType::SPELL_SCROLL:
 		{
-			auto description = VLC->arth->objects[ArtifactID::SPELL_SCROLL]->getDescriptionTranslated();
+			auto description = ArtifactID(ArtifactID::SPELL_SCROLL).toEntity(CGI)->getDescriptionTranslated();
 			ArtifactUtils::insertScrrollSpellName(description, data.subType.as<SpellID>());
 			return description;
 		}
 		case ComponentType::SPELL:
-			return VLC->spells()->getById(data.subType.as<SpellID>())->getDescriptionTranslated(std::max(0, data.value.value_or(0)));
+			return CGI->spells()->getById(data.subType.as<SpellID>())->getDescriptionTranslated(std::max(0, data.value.value_or(0)));
 		case ComponentType::MORALE:
 			return CGI->generaltexth->heroscrn[ 4 - (data.value.value_or(0)>0) + (data.value.value_or(0)<0)];
 		case ComponentType::LUCK:
@@ -320,7 +328,7 @@
 
 void CComponent::setSurface(const AnimationPath & defName, int imgPos)
 {
-	OBJECT_CONSTRUCTION_CUSTOM_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	image = std::make_shared<CAnimImage>(defName, imgPos);
 }
 
@@ -431,7 +439,7 @@
 
 void CComponentBox::placeComponents(bool selectable)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	if (components.empty())
 		return;
 
@@ -439,7 +447,6 @@
 	for(auto & comp : components)
 	{
 		addChild(comp.get());
-		comp->recActions = defActions; //FIXME: for some reason, received component might have recActions set to 0
 		comp->moveTo(Point(pos.x, pos.y));
 	}
 
@@ -466,7 +473,8 @@
 
 		//start next row
 		if ((pos.w != 0 && rows.back().width + comp->pos.w + distance > pos.w) // row is full
-			|| rows.back().comps >= componentsInRow)
+			|| rows.back().comps >= componentsInRow
+			|| (prevComp && prevComp->newLine))
 		{
 			prevComp = nullptr;
 			rows.push_back (RowData (0,0,0));
diff --color -urN vcmi-1.5.7/client/widgets/CComponent.h vcmi/client/widgets/CComponent.h
--- vcmi-1.5.7/client/widgets/CComponent.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/widgets/CComponent.h	2024-12-19 15:00:22.324124217 +0100
@@ -52,6 +52,7 @@
 	std::string customSubtitle;
 	ESize size; //component size.
 	EFonts font; //Font size of label
+	bool newLine; //Line break after component
 
 	std::string getDescription() const;
 	std::string getSubtitle() const;
diff --color -urN vcmi-1.5.7/client/widgets/CComponentHolder.cpp vcmi/client/widgets/CComponentHolder.cpp
--- vcmi-1.5.7/client/widgets/CComponentHolder.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/client/widgets/CComponentHolder.cpp	2024-12-19 15:00:22.326124299 +0100
@@ -0,0 +1,314 @@
+/*
+ * CComponentHolder.cpp, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#include "StdInc.h"
+#include "CComponentHolder.h"
+
+#include "../gui/CGuiHandler.h"
+#include "../gui/Shortcut.h"
+
+#include "CComponent.h"
+#include "Images.h"
+
+#include "../render/Canvas.h"
+#include "../render/Colors.h"
+#include "../render/IRenderHandler.h"
+#include "../CPlayerInterface.h"
+#include "../CGameInfo.h"
+
+#include "../../CCallback.h"
+#include "../../lib/texts/CGeneralTextHandler.h"
+#include "../../lib/ArtifactUtils.h"
+#include "../../lib/mapObjects/CGHeroInstance.h"
+#include "../../lib/networkPacks/ArtifactLocation.h"
+#include "../../lib/CConfigHandler.h"
+#include "../../lib/CSkillHandler.h"
+
+CComponentHolder::CComponentHolder(const Rect & area, const Point & selectionOversize)
+	: SelectableSlot(area, selectionOversize)
+{
+	setClickPressedCallback([this](const CComponentHolder &, const Point & cursorPosition)
+		{
+			if(text.size())
+				LRClickableAreaWTextComp::clickPressed(cursorPosition);
+		});
+	setShowPopupCallback([this](const CComponentHolder &, const Point & cursorPosition)
+		{
+			if(text.size())
+				LRClickableAreaWTextComp::showPopupWindow(cursorPosition);
+		});
+}
+
+void CComponentHolder::setClickPressedCallback(const ClickFunctor & callback)
+{
+	clickPressedCallback = callback;
+}
+
+void CComponentHolder::setShowPopupCallback(const ClickFunctor & callback)
+{
+	showPopupCallback = callback;
+}
+
+void CComponentHolder::setGestureCallback(const ClickFunctor & callback)
+{
+	gestureCallback = callback;
+}
+
+void CComponentHolder::clickPressed(const Point & cursorPosition)
+{
+	if(clickPressedCallback)
+		clickPressedCallback(*this, cursorPosition);
+}
+
+void CComponentHolder::showPopupWindow(const Point & cursorPosition)
+{
+	if(showPopupCallback)
+		showPopupCallback(*this, cursorPosition);
+}
+
+void CComponentHolder::gesture(bool on, const Point & initialPosition, const Point & finalPosition)
+{
+	if(!on)
+		return;
+
+	if(gestureCallback)
+		gestureCallback(*this, initialPosition);
+}
+
+CArtPlace::CArtPlace(Point position, const ArtifactID & artId, const SpellID & spellId)
+	: CComponentHolder(Rect(position, Point(44, 44)), Point(1, 1))
+	, locked(false)
+	, imageIndex(0)
+{
+	OBJECT_CONSTRUCTION;
+
+	image = std::make_shared<CAnimImage>(AnimationPath::builtin("artifact"), 0);
+	setArtifact(artId, spellId);
+	moveSelectionForeground();
+}
+
+void CArtPlace::setArtifact(const SpellID & newSpellId)
+{
+	setArtifact(ArtifactID::SPELL_SCROLL, newSpellId);
+}
+
+void CArtPlace::setArtifact(const ArtifactID & newArtId, const SpellID & newSpellId)
+{
+	artId = newArtId;
+	if(artId == ArtifactID::NONE)
+	{
+		image->disable();
+		text.clear();
+		lockSlot(false);
+		return;
+	}
+
+	const auto artType = artId.toArtifact();
+	imageIndex = artType->getIconIndex();
+	if(artId == ArtifactID::SPELL_SCROLL)
+	{
+		spellId = newSpellId;
+		assert(spellId.num > 0);
+
+		if(settings["general"]["enableUiEnhancements"].Bool())
+		{
+			imageIndex = spellId.num;
+			if(component.type != ComponentType::SPELL_SCROLL)
+			{
+				image->setScale(Point(pos.w, 34));
+				image->setAnimationPath(AnimationPath::builtin("spellscr"), imageIndex);
+				image->moveTo(Point(pos.x, pos.y + 4));
+			}
+		}
+		// Add spell component info (used to provide a pic in r-click popup)
+		component.type = ComponentType::SPELL_SCROLL;
+		component.subType = spellId;
+	}
+	else
+	{
+		if(settings["general"]["enableUiEnhancements"].Bool() && component.type != ComponentType::ARTIFACT)
+		{
+			image->setScale(Point());
+			image->setAnimationPath(AnimationPath::builtin("artifact"), imageIndex);
+			image->moveTo(Point(pos.x, pos.y));
+		}
+		component.type = ComponentType::ARTIFACT;
+		component.subType = artId;
+	}
+	image->enable();
+	lockSlot(locked);
+
+	text = artType->getDescriptionTranslated();
+	if(artType->isScroll())
+		ArtifactUtils::insertScrrollSpellName(text, spellId);
+}
+
+ArtifactID CArtPlace::getArtifactId() const
+{
+	return artId;
+}
+
+CCommanderArtPlace::CCommanderArtPlace(Point position, const CGHeroInstance * commanderOwner, ArtifactPosition artSlot,
+	const ArtifactID & artId, const SpellID & spellId)
+	: CArtPlace(position, artId, spellId),
+	commanderOwner(commanderOwner),
+	commanderSlotID(artSlot.num)
+{
+}
+
+void CCommanderArtPlace::returnArtToHeroCallback()
+{
+	ArtifactPosition artifactPos = commanderSlotID;
+	ArtifactPosition freeSlot = ArtifactUtils::getArtBackpackPosition(commanderOwner, getArtifactId());
+	if(freeSlot == ArtifactPosition::PRE_FIRST)
+	{
+		LOCPLINT->showInfoDialog(CGI->generaltexth->translate("core.genrltxt.152"));
+	}
+	else
+	{
+		ArtifactLocation src(commanderOwner->id, artifactPos);
+		src.creature = SlotID::COMMANDER_SLOT_PLACEHOLDER;
+		ArtifactLocation dst(commanderOwner->id, freeSlot);
+
+		if(getArtifactId().toArtifact()->canBePutAt(commanderOwner, freeSlot, true))
+		{
+			LOCPLINT->cb->swapArtifacts(src, dst);
+			setArtifact(ArtifactID(ArtifactID::NONE));
+			parent->redraw();
+		}
+	}
+}
+
+void CCommanderArtPlace::clickPressed(const Point & cursorPosition)
+{
+	if(getArtifactId() != ArtifactID::NONE && text.size())
+		LOCPLINT->showYesNoDialog(CGI->generaltexth->translate("vcmi.commanderWindow.artifactMessage"), [this]() { returnArtToHeroCallback(); }, []() {});
+}
+
+void CCommanderArtPlace::showPopupWindow(const Point & cursorPosition)
+{
+	if(getArtifactId() != ArtifactID::NONE && text.size())
+		CArtPlace::showPopupWindow(cursorPosition);
+}
+
+void CArtPlace::lockSlot(bool on)
+{
+	locked = on;
+	if(on)
+	{
+		image->setFrame(ArtifactID::ART_LOCK);
+		hoverText = CGI->generaltexth->allTexts[507];
+	}
+	else if(artId != ArtifactID::NONE)
+	{
+		image->setFrame(imageIndex);
+		auto hoverText = MetaString::createFromRawString(CGI->generaltexth->heroscrn[1]);
+		hoverText.replaceName(artId);
+		this->hoverText = hoverText.toString();
+	}
+	else
+	{
+		hoverText = CGI->generaltexth->allTexts[507];
+	}
+}
+
+bool CArtPlace::isLocked() const
+{
+	return locked;
+}
+
+void CArtPlace::addCombinedArtInfo(const std::map<const ArtifactID, std::vector<ArtifactID>> & arts)
+{
+	for(auto [combinedId, availableArts] : arts)
+	{
+		const auto combinedArt = combinedId.toArtifact();
+		MetaString info;
+		info.appendEOL();
+		info.appendEOL();
+		info.appendRawString("{");
+		info.appendName(combinedArt->getId());
+		info.appendRawString("}");
+		info.appendRawString(" (%d/%d)");
+		info.replaceNumber(availableArts.size());
+		info.replaceNumber(combinedArt->getConstituents().size());
+		for(const auto part : combinedArt->getConstituents())
+		{
+			const auto found = std::find_if(availableArts.begin(), availableArts.end(), [part](const auto & availablePart) -> bool
+				{
+					return availablePart == part->getId() ? true : false;
+				});
+
+			info.appendEOL();
+			if(found < availableArts.end())
+			{
+				info.appendName(part->getId());
+				availableArts.erase(found);
+			}
+			else
+			{
+				info.appendRawString("{#A9A9A9|");
+				info.appendName(part->getId());
+				info.appendRawString("}");
+			}
+		}
+		text += info.toString();
+	}
+}
+
+CSecSkillPlace::CSecSkillPlace(const Point & position, const ImageSize & imageSize, const SecondarySkill & newSkillId, const uint8_t level)
+	: CComponentHolder(Rect(position, Point()), Point())
+{
+	OBJECT_CONSTRUCTION;
+
+	auto imagePath = AnimationPath::builtin("SECSK82");
+	if(imageSize == ImageSize::MEDIUM)
+		imagePath = AnimationPath::builtin("SECSKILL");
+	if(imageSize == ImageSize::SMALL)
+		imagePath = AnimationPath::builtin("SECSK32");
+
+	image = std::make_shared<CAnimImage>(imagePath, 0);
+	component.type = ComponentType::SEC_SKILL;
+	pos.w = image->pos.w;
+	pos.h = image->pos.h;
+	setSkill(newSkillId, level);
+}
+
+void CSecSkillPlace::setSkill(const SecondarySkill & newSkillId, const uint8_t level)
+{
+	skillId = newSkillId;
+	component.subType = newSkillId;
+	setLevel(level);
+}
+
+void CSecSkillPlace::setLevel(const uint8_t level)
+{
+	// 0 - none
+	// 1 - base
+	// 2 - advanced
+	// 3 - expert
+	assert(level <= 3);
+	if(skillId != SecondarySkill::NONE && level > 0)
+	{
+		const auto secSkill = skillId.toSkill();
+		image->setFrame(secSkill->getIconIndex(level - 1));
+		image->enable();
+		auto hoverText = MetaString::createFromRawString(CGI->generaltexth->heroscrn[21]);
+		hoverText.replaceRawString(CGI->generaltexth->levels[level - 1]);
+		hoverText.replaceTextID(secSkill->getNameTextID());
+		this->hoverText = hoverText.toString();
+		component.value = level;
+		text = secSkill->getDescriptionTranslated(level);
+	}
+	else
+	{
+		image->disable();
+		hoverText.clear();
+		text.clear();
+	}
+}
diff --color -urN vcmi-1.5.7/client/widgets/CComponentHolder.h vcmi/client/widgets/CComponentHolder.h
--- vcmi-1.5.7/client/widgets/CComponentHolder.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/client/widgets/CComponentHolder.h	2024-12-19 15:00:22.326124299 +0100
@@ -0,0 +1,86 @@
+/*
+ * CComponentHolder.h, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#pragma once
+
+#include "MiscWidgets.h"
+
+class CAnimImage;
+
+class CComponentHolder : public SelectableSlot
+{
+public:
+	using ClickFunctor = std::function<void(CComponentHolder&, const Point&)>;
+
+	ClickFunctor clickPressedCallback;
+	ClickFunctor showPopupCallback;
+	ClickFunctor gestureCallback;
+	std::shared_ptr<CAnimImage> image;
+
+	CComponentHolder(const Rect & area, const Point & selectionOversize);
+	void setClickPressedCallback(const ClickFunctor & callback);
+	void setShowPopupCallback(const ClickFunctor & callback);
+	void setGestureCallback(const ClickFunctor & callback);
+	void clickPressed(const Point & cursorPosition) override;
+	void showPopupWindow(const Point & cursorPosition) override;
+	void gesture(bool on, const Point & initialPosition, const Point & finalPosition) override;
+};
+
+class CArtPlace : public CComponentHolder
+{
+public:
+	ArtifactPosition slot;
+	
+	CArtPlace(Point position, const ArtifactID & newArtId = ArtifactID::NONE, const SpellID & newSpellId = SpellID::NONE);
+	void setArtifact(const SpellID & newSpellId);
+	void setArtifact(const ArtifactID & newArtId, const SpellID & newSpellId = SpellID::NONE);
+	ArtifactID getArtifactId() const;
+	void lockSlot(bool on);
+	bool isLocked() const;
+	void addCombinedArtInfo(const std::map<const ArtifactID, std::vector<ArtifactID>> & arts);
+
+private:
+	ArtifactID artId;
+	SpellID spellId;
+	bool locked;
+	int32_t imageIndex;
+};
+
+class CCommanderArtPlace : public CArtPlace
+{
+private:
+	const CGHeroInstance * commanderOwner;
+	ArtifactPosition commanderSlotID;
+
+	void returnArtToHeroCallback();
+
+public:
+	CCommanderArtPlace(Point position, const CGHeroInstance * commanderOwner, ArtifactPosition artSlot,
+		const ArtifactID & artId = ArtifactID::NONE, const SpellID & spellId = SpellID::NONE);
+	void clickPressed(const Point & cursorPosition) override;
+	void showPopupWindow(const Point & cursorPosition) override;
+};
+
+class CSecSkillPlace : public CComponentHolder
+{
+public:
+	enum class ImageSize
+	{
+		LARGE,
+		MEDIUM,
+		SMALL
+	};
+
+	CSecSkillPlace(const Point & position, const ImageSize & imageSize, const SecondarySkill & skillId = SecondarySkill::NONE, const uint8_t level = 0);
+	void setSkill(const SecondarySkill & newSkillId, const uint8_t level = 0);
+	void setLevel(const uint8_t level);
+
+private:
+	SecondarySkill skillId;
+};
diff --color -urN vcmi-1.5.7/client/widgets/CExchangeController.cpp vcmi/client/widgets/CExchangeController.cpp
--- vcmi-1.5.7/client/widgets/CExchangeController.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/widgets/CExchangeController.cpp	2024-12-19 15:00:22.327124340 +0100
@@ -79,6 +79,10 @@
 			});
 		heldSlot = weakestSlot->first;
 	}
+	
+	if (source->getCreature(heldSlot.value()) == nullptr)
+		return;
+
 	LOCPLINT->cb->bulkMoveArmy(source->id, target->id, heldSlot.value());
 }
 
diff --color -urN vcmi-1.5.7/client/widgets/CGarrisonInt.cpp vcmi/client/widgets/CGarrisonInt.cpp
--- vcmi-1.5.7/client/widgets/CGarrisonInt.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/widgets/CGarrisonInt.cpp	2024-12-19 15:00:22.329124423 +0100
@@ -17,7 +17,6 @@
 #include "../gui/CGuiHandler.h"
 #include "../gui/WindowHandler.h"
 #include "../render/IImage.h"
-#include "../render/Graphics.h"
 #include "../windows/CCreatureWindow.h"
 #include "../windows/CWindowWithArtifacts.h"
 #include "../windows/GUIClasses.h"
@@ -27,12 +26,12 @@
 #include "../../CCallback.h"
 
 #include "../../lib/ArtifactUtils.h"
-#include "../../lib/CGeneralTextHandler.h"
+#include "../../lib/texts/CGeneralTextHandler.h"
+#include "../../lib/texts/TextOperations.h"
 #include "../../lib/CCreatureHandler.h"
 #include "../../lib/CConfigHandler.h"
 #include "../../lib/mapObjects/CGHeroInstance.h"
 #include "../../lib/networkPacks/ArtifactLocation.h"
-#include "../../lib/TextOperations.h"
 #include "../../lib/gameState/CGameState.h"
 
 void CGarrisonSlot::setHighlight(bool on)
@@ -275,12 +274,12 @@
 	if (!LOCPLINT->makingTurn)
 		return true;
 
-	if (!creature || !selection->creature)
-		return false;
-
 	// Attempt to take creatures from ally (select theirs first)
 	if (!selection->our())
 		return true;
+	
+	if (!creature || !selection->creature)
+		return false;
 
 	// Attempt to swap creatures with ally (select ours first)
 	if (selection->creature != creature && withAlly)
@@ -371,10 +370,13 @@
 	if (!settings["input"]["radialWheelGarrisonSwipe"].Bool())
 		return;
 
+	if(GH.windows().topWindow<CIntObject>()->isPopupWindow())
+		return;
+
 	const auto * otherArmy = upg == EGarrisonType::UPPER ? owner->lowerArmy() : owner->upperArmy();
 
 	bool stackExists = myStack != nullptr;
-	bool hasSameUnit = stackExists && !owner->army(upg)->getCreatureSlots(myStack->type, ID).empty();
+	bool hasSameUnit = stackExists && !owner->army(upg)->getCreatureSlots(myStack->getCreature(), ID).empty();
 	bool hasOwnEmptySlots = stackExists && owner->army(upg)->getFreeSlot() != SlotID();
 	bool exchangeMode = stackExists && owner->upperArmy() && owner->lowerArmy();
 	bool hasOtherEmptySlots = exchangeMode && otherArmy->getFreeSlot() != SlotID();
@@ -399,7 +401,7 @@
 	{
 		addUsedEvents(LCLICK | SHOW_POPUP | GESTURE | HOVER);
 		myStack = getObj()->getStackPtr(ID);
-		creature = myStack ? myStack->type : nullptr;
+		creature = myStack ? myStack->getCreature() : nullptr;
 	}
 	else
 	{
@@ -427,20 +429,20 @@
 	: ID(IID),
 	owner(Owner),
 	myStack(creature_),
-	creature(creature_ ? creature_->type : nullptr),
+	creature(creature_ ? creature_->getCreature() : nullptr),
 	upg(Upg)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	pos.x += x;
 	pos.y += y;
 
 	AnimationPath imgName = AnimationPath::builtin(owner->smallIcons ? "cprsmall" : "TWCRPORT");
 
-	creatureImage = std::make_shared<CAnimImage>(graphics->getAnimation(imgName), 0);
+	creatureImage = std::make_shared<CAnimImage>(imgName, 0);
 	creatureImage->disable();
 
-	selectionImage = std::make_shared<CAnimImage>(graphics->getAnimation(imgName), 1);
+	selectionImage = std::make_shared<CAnimImage>(imgName, 1);
 	selectionImage->disable();
 	selectionImage->center(creatureImage->pos.center());
 
@@ -535,7 +537,6 @@
 void CGarrisonInt::addSplitBtn(std::shared_ptr<CButton> button)
 {
 	addChild(button.get());
-	button->recActions &= ~DISPOSE;
 	splitButtons.push_back(button);
 	button->block(getSelection() == nullptr);
 }
@@ -716,7 +717,7 @@
 	, removableUnits(_removableUnits)
 	, layout(_layout)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	setArmy(s1, EGarrisonType::UPPER);
 	setArmy(s2, EGarrisonType::LOWER);
diff --color -urN vcmi-1.5.7/client/widgets/CreatureCostBox.cpp vcmi/client/widgets/CreatureCostBox.cpp
--- vcmi-1.5.7/client/widgets/CreatureCostBox.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/widgets/CreatureCostBox.cpp	2024-12-19 15:00:22.333124588 +0100
@@ -15,7 +15,7 @@
 
 CreatureCostBox::CreatureCostBox(Rect position, std::string titleText)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	setRedrawParent(true);
 	pos = position + pos.topLeft();
@@ -33,7 +33,7 @@
 {
 	resources.clear();
 
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	TResources::nziterator iter(res);
 	while(iter.valid())
@@ -49,14 +49,15 @@
 	{
 		int curx = pos.w / 2;
 		int spacing = 48;
+		int resourcesCount = static_cast<int>(resources.size());
 		if (resources.size() > 2)
 		{
 			spacing = 32;
-			curx -= (15 + 16 * ((int)resources.size() - 1));
+			curx -= (15 + 16 * (resourcesCount - 1));
 		}
 		else
 		{
-			curx -= ((16 * (int)resources.size()) + (8 * ((int)resources.size() - 1)));
+			curx -= ((16 * resourcesCount) + (8 * (resourcesCount - 1)));
 		}
 		//reverse to display gold as first resource
 		for(auto & currentRes : boost::adaptors::reverse(resources))
diff --color -urN vcmi-1.5.7/client/widgets/CTextInput.cpp vcmi/client/widgets/CTextInput.cpp
--- vcmi-1.5.7/client/widgets/CTextInput.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/widgets/CTextInput.cpp	2024-12-19 15:00:22.331124506 +0100
@@ -17,8 +17,9 @@
 #include "../gui/Shortcut.h"
 #include "../render/Graphics.h"
 #include "../render/IFont.h"
+#include "../render/IRenderHandler.h"
 
-#include "../../lib/TextOperations.h"
+#include "../../lib/texts/TextOperations.h"
 
 std::list<CFocusable *> CFocusable::focusables;
 CFocusable * CFocusable::inputWithFocus;
@@ -30,12 +31,12 @@
 	pos.h = Pos.h;
 	pos.w = Pos.w;
 
-	addUsedEvents(LCLICK | KEYBOARD | TEXTINPUT);
+	addUsedEvents(LCLICK | SHOW_POPUP | KEYBOARD | TEXTINPUT);
 }
 
 void CTextInput::createLabel(bool giveFocusToInput)
 {
-	OBJ_CONSTRUCTION;
+	OBJECT_CONSTRUCTION;
 	label = std::make_shared<CLabel>();
 	label->pos = pos;
 	label->alignment = originalAlignment;
@@ -59,7 +60,7 @@
 CTextInput::CTextInput(const Rect & Pos, const Point & bgOffset, const ImagePath & bgName)
 	: CTextInput(Pos)
 {
-	OBJ_CONSTRUCTION;
+	OBJECT_CONSTRUCTION;
 	if (!bgName.empty())
 		background = std::make_shared<CPicture>(bgName, bgOffset.x, bgOffset.y);
 	else
@@ -71,7 +72,7 @@
 CTextInput::CTextInput(const Rect & Pos, std::shared_ptr<IImage> srf)
 	: CTextInput(Pos)
 {
-	OBJ_CONSTRUCTION;
+	OBJECT_CONSTRUCTION;
 	background = std::make_shared<CPicture>(srf, Pos);
 	pos.w = background->pos.w;
 	pos.h = background->pos.h;
@@ -106,6 +107,11 @@
 	onTextEdited = cb;
 }
 
+void CTextInput::setPopupCallback(const std::function<void()> & cb)
+{
+	callbackPopup = cb;
+}
+
 void CTextInput::setFilterFilename()
 {
 	assert(!onTextFiltering);
@@ -117,11 +123,17 @@
 	onTextFiltering = std::bind(&CTextInput::numberFilter, _1, _2, minValue, maxValue);
 }
 
-std::string CTextInput::getVisibleText()
+std::string CTextInput::getVisibleText() const
 {
 	return hasFocus() ? currentText + composedText + "_" : currentText;
 }
 
+void CTextInput::showPopupWindow(const Point & cursorPosition)
+{
+	if(callbackPopup)
+		callbackPopup();
+}
+
 void CTextInput::clickPressed(const Point & cursorPosition)
 {
 	// attempt to give focus unconditionally, even if we already have it
@@ -179,8 +191,9 @@
 	std::string visibleText = getVisibleText();
 
 	label->alignment = originalAlignment;
+	const auto & font = GH.renderHandler().loadFont(label->font);
 
-	while (graphics->fonts[label->font]->getStringWidth(visibleText) > pos.w)
+	while (font->getStringWidth(visibleText) > pos.w)
 	{
 		label->alignment = ETextAlignment::CENTERRIGHT;
 		visibleText = visibleText.substr(TextOperations::getUnicodeCharacterSize(visibleText[0]));
@@ -189,7 +202,7 @@
 	label->setText(visibleText);
 }
 
-void CTextInput::textInputed(const std::string & enteredText)
+void CTextInput::textInputted(const std::string & enteredText)
 {
 	if(!hasFocus())
 		return;
@@ -216,7 +229,6 @@
 
 	composedText = enteredText;
 	updateLabel();
-	//onTextEdited(currentText + composedText);
 }
 
 void CTextInput::filenameFilter(std::string & text, const std::string &oldText)
diff --color -urN vcmi-1.5.7/client/widgets/CTextInput.h vcmi/client/widgets/CTextInput.h
--- vcmi-1.5.7/client/widgets/CTextInput.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/widgets/CTextInput.h	2024-12-19 15:00:22.332124547 +0100
@@ -14,6 +14,7 @@
 #include "../render/EFont.h"
 
 #include "../../lib/filesystem/ResourcePath.h"
+#include "../../lib/FunctionList.h"
 
 class CLabel;
 class IImage;
@@ -49,7 +50,6 @@
 	using TextEditedCallback = std::function<void(const std::string &)>;
 	using TextFilterCallback = std::function<void(std::string &, const std::string &)>;
 
-private:
 	std::string currentText;
 	std::string composedText;
 	ETextAlignment originalAlignment;
@@ -59,6 +59,7 @@
 
 	TextEditedCallback onTextEdited;
 	TextFilterCallback onTextFiltering;
+	CFunctionList<void()> callbackPopup;
 
 	//Filter that will block all characters not allowed in filenames
 	static void filenameFilter(std::string & text, const std::string & oldText);
@@ -66,15 +67,16 @@
 	//min-max should be set via something like std::bind
 	static void numberFilter(std::string & text, const std::string & oldText, int minValue, int maxValue);
 
-	std::string getVisibleText();
+	std::string getVisibleText() const;
 	void createLabel(bool giveFocusToInput);
 	void updateLabel();
 
 	void clickPressed(const Point & cursorPosition) final;
-	void textInputed(const std::string & enteredText) final;
+	void textInputted(const std::string & enteredText) final;
 	void textEdited(const std::string & enteredText) final;
 	void onFocusGot() final;
 	void onFocusLost() final;
+	void showPopupWindow(const Point & cursorPosition) final;
 
 	CTextInput(const Rect & Pos);
 public:
@@ -90,6 +92,9 @@
 	/// Set callback that will be called whenever player enters new text
 	void setCallback(const TextEditedCallback & cb);
 
+	/// Set callback when player want to open popup
+	void setPopupCallback(const std::function<void()> & cb);
+
 	/// Enables filtering entered text that ensures that text is valid filename (existing or not)
 	void setFilterFilename();
 	/// Enable filtering entered text that ensures that text is valid number in provided range [min, max]
diff --color -urN vcmi-1.5.7/client/widgets/Images.cpp vcmi/client/widgets/Images.cpp
--- vcmi-1.5.7/client/widgets/Images.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/widgets/Images.cpp	2024-12-19 15:00:22.337124754 +0100
@@ -14,24 +14,24 @@
 
 #include "../gui/CGuiHandler.h"
 #include "../renderSDL/SDL_Extensions.h"
+#include "../render/AssetGenerator.h"
 #include "../render/IImage.h"
 #include "../render/IRenderHandler.h"
 #include "../render/CAnimation.h"
 #include "../render/Canvas.h"
 #include "../render/ColorFilter.h"
-#include "../render/Graphics.h"
+#include "../render/Colors.h"
 
 #include "../battle/BattleInterface.h"
 #include "../battle/BattleInterfaceClasses.h"
 
 #include "../CGameInfo.h"
 #include "../CPlayerInterface.h"
-#include "../CMusicHandler.h"
 
 #include "../../CCallback.h"
 
 #include "../../lib/CConfigHandler.h"
-#include "../../lib/CGeneralTextHandler.h" //for Unicode related stuff
+#include "../../lib/texts/CGeneralTextHandler.h" //for Unicode related stuff
 #include "../../lib/CRandomGenerator.h"
 
 CPicture::CPicture(std::shared_ptr<IImage> image, const Point & position)
@@ -41,6 +41,8 @@
 	pos += position;
 	pos.w = bg->width();
 	pos.h = bg->height();
+
+	addUsedEvents(SHOW_POPUP);
 }
 
 CPicture::CPicture( const ImagePath &bmpname, int x, int y )
@@ -52,7 +54,7 @@
 {}
 
 CPicture::CPicture( const ImagePath & bmpname, const Point & position )
-	: bg(GH.renderHandler().loadImage(bmpname))
+	: bg(GH.renderHandler().loadImage(bmpname, EImageBlitMode::COLORKEY))
 	, needRefresh(false)
 {
 	pos.x += position.x;
@@ -68,6 +70,18 @@
 	{
 		pos.w = pos.h = 0;
 	}
+
+	addUsedEvents(SHOW_POPUP);
+}
+
+CPicture::CPicture(const ImagePath & bmpname, const Rect &SrcRect, int x, int y)
+	: CPicture(bmpname, Point(x,y))
+{
+	srcRect = SrcRect;
+	pos.w = srcRect->w;
+	pos.h = srcRect->h;
+
+	addUsedEvents(SHOW_POPUP);
 }
 
 CPicture::CPicture(std::shared_ptr<IImage> image, const Rect &SrcRect, int x, int y)
@@ -76,6 +90,8 @@
 	srcRect = SrcRect;
 	pos.w = srcRect->w;
 	pos.h = srcRect->h;
+
+	addUsedEvents(SHOW_POPUP);
 }
 
 void CPicture::show(Canvas & to)
@@ -102,29 +118,40 @@
 
 void CPicture::scaleTo(Point size)
 {
-	bg = bg->scaleFast(size);
+	bg->scaleTo(size);
 
 	pos.w = bg->width();
 	pos.h = bg->height();
 }
 
-void CPicture::colorize(PlayerColor player)
+void CPicture::setPlayerColor(PlayerColor player)
 {
 	bg->playerColored(player);
 }
 
-CFilledTexture::CFilledTexture(const ImagePath & imageName, Rect position):
-    CIntObject(0, position.topLeft()),
-	texture(GH.renderHandler().loadImage(imageName))
+void CPicture::addRClickCallback(const std::function<void()> & callback)
+{
+	rCallback = callback;
+}
+
+void CPicture::showPopupWindow(const Point & cursorPosition)
+{
+	if(rCallback)
+		rCallback();
+}
+
+CFilledTexture::CFilledTexture(const ImagePath & imageName, Rect position)
+	: CIntObject(0, position.topLeft())
+	, texture(GH.renderHandler().loadImage(imageName, EImageBlitMode::COLORKEY))
 {
 	pos.w = position.w;
 	pos.h = position.h;
 	imageArea = Rect(Point(), texture->dimensions());
 }
 
-CFilledTexture::CFilledTexture(std::shared_ptr<IImage> image, Rect position, Rect imageArea)
+CFilledTexture::CFilledTexture(const ImagePath & imageName, Rect position, Rect imageArea)
 	: CIntObject(0, position.topLeft())
-	, texture(image)
+	, texture(GH.renderHandler().loadImage(imageName, EImageBlitMode::COLORKEY))
 	, imageArea(imageArea)
 {
 	pos.w = position.w;
@@ -142,59 +169,38 @@
 	}
 }
 
-FilledTexturePlayerColored::FilledTexturePlayerColored(const ImagePath & imageName, Rect position)
-	: CFilledTexture(imageName, position)
+void FilledTexturePlayerIndexed::setPlayerColor(PlayerColor player)
 {
+	texture->playerColored(player);
 }
 
-void FilledTexturePlayerColored::playerColored(PlayerColor player)
+FilledTexturePlayerColored::FilledTexturePlayerColored(Rect position)
+	:CFilledTexture(ImagePath::builtin("DiBoxBck"), position)
 {
-	// Color transform to make color of brown DIBOX.PCX texture match color of specified player
-	std::array<ColorFilter, PlayerColor::PLAYER_LIMIT_I> filters = {
-		ColorFilter::genRangeShifter(  0.25,  0,     0,     1.25, 0.00, 0.00 ), // red
-		ColorFilter::genRangeShifter(  0,     0,     0,     0.45, 1.20, 4.50 ), // blue
-		ColorFilter::genRangeShifter(  0.40,  0.27,  0.23,  1.10, 1.20, 1.15 ), // tan
-		ColorFilter::genRangeShifter( -0.27,  0.10, -0.27,  0.70, 1.70, 0.70 ), // green
-		ColorFilter::genRangeShifter(  0.47,  0.17, -0.27,  1.60, 1.20, 0.70 ), // orange
-		ColorFilter::genRangeShifter(  0.12, -0.1,   0.25,  1.15, 1.20, 2.20 ), // purple
-		ColorFilter::genRangeShifter( -0.13,  0.23,  0.23,  0.90, 1.20, 2.20 ), // teal
-		ColorFilter::genRangeShifter(  0.44,  0.15,  0.25,  1.00, 1.00, 1.75 )  // pink
-	};
-
-	assert(player.isValidPlayer());
-	if (!player.isValidPlayer())
-	{
-		logGlobal->error("Unable to colorize to invalid player color %d!", static_cast<int>(player.getNum()));
-		return;
-	}
-
-	texture->adjustPalette(filters[player.getNum()], 0);
 }
 
-CAnimImage::CAnimImage(const AnimationPath & name, size_t Frame, size_t Group, int x, int y, ui8 Flags):
-	frame(Frame),
-	group(Group),
-	flags(Flags)
+void FilledTexturePlayerColored::setPlayerColor(PlayerColor player)
 {
-	pos.x += x;
-	pos.y += y;
-	anim = graphics->getAnimation(name);
-	init();
+	AssetGenerator::createPlayerColoredBackground(player);
+
+	ImagePath imagePath = ImagePath::builtin("DialogBoxBackground_" + player.toString() + ".bmp");
+
+	texture = GH.renderHandler().loadImage(imagePath, EImageBlitMode::COLORKEY);
 }
 
-CAnimImage::CAnimImage(std::shared_ptr<CAnimation> Anim, size_t Frame, size_t Group, int x, int y, ui8 Flags):
-	anim(Anim),
+CAnimImage::CAnimImage(const AnimationPath & name, size_t Frame, size_t Group, int x, int y, ui8 Flags):
 	frame(Frame),
 	group(Group),
 	flags(Flags)
 {
 	pos.x += x;
 	pos.y += y;
+	anim = GH.renderHandler().loadAnimation(name, (Flags & CCreatureAnim::CREATURE_MODE) ? EImageBlitMode::WITH_SHADOW_AND_OVERLAY : EImageBlitMode::COLORKEY);
 	init();
 }
 
-CAnimImage::CAnimImage(std::shared_ptr<CAnimation> Anim, size_t Frame, Rect targetPos, size_t Group, ui8 Flags):
-	anim(Anim),
+CAnimImage::CAnimImage(const AnimationPath & name, size_t Frame, Rect targetPos, size_t Group, ui8 Flags):
+	anim(GH.renderHandler().loadAnimation(name, (Flags & CCreatureAnim::CREATURE_MODE) ? EImageBlitMode::WITH_SHADOW_AND_OVERLAY : EImageBlitMode::COLORKEY)),
 	frame(Frame),
 	group(Group),
 	flags(Flags),
@@ -234,10 +240,6 @@
 void CAnimImage::init()
 {
 	visible = true;
-	anim->load(frame, group);
-	if (flags & CShowableAnim::BASE)
-		anim->load(0,group);
-
 	auto img = anim->getImage(frame, group);
 	if (img)
 		setSizeFromImage(*img);
@@ -264,12 +266,9 @@
 		if(auto img = anim->getImage(targetFrame, group))
 		{
 			if(isScaled())
-			{
-				auto scaled = img->scaleFast(scaledSize);
-				to.draw(scaled, pos.topLeft());
-			}
-			else
-				to.draw(img, pos.topLeft());
+				img->scaleTo(scaledSize);
+
+			to.draw(img, pos.topLeft());
 		}
 	}
 }
@@ -277,7 +276,7 @@
 void CAnimImage::setAnimationPath(const AnimationPath & name, size_t frame)
 {
 	this->frame = frame;
-	anim = GH.renderHandler().loadAnimation(name);
+	anim = GH.renderHandler().loadAnimation(name, EImageBlitMode::COLORKEY);
 	init();
 }
 
@@ -292,7 +291,6 @@
 		return;
 	if (anim->size(Group) > Frame)
 	{
-		anim->load(Frame, Group);
 		frame = Frame;
 		group = Group;
 		if(auto img = anim->getImage(frame, group))
@@ -306,7 +304,7 @@
 		logGlobal->error("Error: accessing unavailable frame %d:%d in CAnimation!", Group, Frame);
 }
 
-void CAnimImage::playerColored(PlayerColor currPlayer)
+void CAnimImage::setPlayerColor(PlayerColor currPlayer)
 {
 	player = currPlayer;
 	anim->getImage(frame, group)->playerColored(*player);
@@ -320,7 +318,7 @@
 }
 
 CShowableAnim::CShowableAnim(int x, int y, const AnimationPath & name, ui8 Flags, ui32 frameTime, size_t Group, uint8_t alpha):
-	anim(GH.renderHandler().loadAnimation(name)),
+	anim(GH.renderHandler().loadAnimation(name, (Flags & CREATURE_MODE) ? EImageBlitMode::WITH_SHADOW_AND_OVERLAY : EImageBlitMode::COLORKEY)),
 	group(Group),
 	frame(0),
 	first(0),
@@ -331,7 +329,6 @@
 	yOffset(0),
 	alpha(alpha)
 {
-	anim->loadGroup(group);
 	last = anim->size(group);
 
 	auto image = anim->getImage(0, group);
@@ -346,11 +343,6 @@
 	addUsedEvents(TIME);
 }
 
-CShowableAnim::~CShowableAnim()
-{
-	anim->unloadGroup(group);
-}
-
 void CShowableAnim::setAlpha(ui32 alphaValue)
 {
 	alpha = std::min<ui32>(alphaValue, 255);
@@ -366,9 +358,6 @@
 	if (max < from || max == 0)
 		return false;
 
-	anim->unloadGroup(group);
-	anim->loadGroup(Group);
-
 	group = Group;
 	frame = first = from;
 	last = max;
@@ -382,9 +371,6 @@
 		return false;
 	if (group != Group)
 	{
-		anim->unloadGroup(group);
-		anim->loadGroup(Group);
-
 		first = 0;
 		group = Group;
 		last = anim->size(Group);
@@ -446,6 +432,7 @@
 	if(img)
 	{
 		img->setAlpha(alpha);
+		img->setOverlayColor(Colors::TRANSPARENCY);
 		to.draw(img, pos.topLeft(), src);
 	}
 }
@@ -465,7 +452,7 @@
 }
 
 CCreatureAnim::CCreatureAnim(int x, int y, const AnimationPath & name, ui8 flags, ECreatureAnimType type):
-	CShowableAnim(x, y, name, flags, 100, size_t(type)) // H3 uses 100 ms per frame, irregardless of battle speed settings
+	CShowableAnim(x, y, name, flags | CREATURE_MODE, 100, size_t(type)) // H3 uses 100 ms per frame, irregardless of battle speed settings
 {
 	xOffset = 0;
 	yOffset = 0;
diff --color -urN vcmi-1.5.7/client/widgets/Images.h vcmi/client/widgets/Images.h
--- vcmi-1.5.7/client/widgets/Images.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/widgets/Images.h	2024-12-19 15:00:22.338124795 +0100
@@ -26,12 +26,13 @@
 class CPicture : public CIntObject
 {
 	std::shared_ptr<IImage> bg;
+	std::function<void()> rCallback;
 
 public:
 	/// if set, only specified section of internal image will be rendered
 	std::optional<Rect> srcRect;
 
-	/// If set to true, iamge will be redrawn on each frame
+	/// If set to true, image will be redrawn on each frame
 	bool needRefresh;
 
 	std::shared_ptr<IImage> getSurface()
@@ -44,6 +45,7 @@
 
 	/// wrap section of an existing Image
 	CPicture(std::shared_ptr<IImage> image, const Rect &SrcRext, int x = 0, int y = 0); //wrap subrect of given surface
+	CPicture(const ImagePath & bmpname, const Rect &SrcRext, int x = 0, int y = 0); //wrap subrect of given surface
 
 	/// Loads image from specified file name
 	CPicture(const ImagePath & bmpname);
@@ -54,10 +56,13 @@
 	/// 0=transparent, 255=opaque
 	void setAlpha(uint8_t value);
 	void scaleTo(Point size);
-	void colorize(PlayerColor player);
+	void setPlayerColor(PlayerColor player);
+
+	void addRClickCallback(const std::function<void()> & callback);
 
 	void show(Canvas & to) override;
 	void showAll(Canvas & to) override;
+	void showPopupWindow(const Point & cursorPosition) override;
 };
 
 /// area filled with specific texture
@@ -68,18 +73,28 @@
 	Rect imageArea;
 
 public:
+	CFilledTexture(const ImagePath & imageName, Rect position, Rect imageArea);
 	CFilledTexture(const ImagePath & imageName, Rect position);
-	CFilledTexture(std::shared_ptr<IImage> image, Rect position, Rect imageArea);
 
 	void showAll(Canvas & to) override;
 };
 
+/// area filled with specific texture, colorized to player color if image is indexed
+class FilledTexturePlayerIndexed : public CFilledTexture
+{
+public:
+	using CFilledTexture::CFilledTexture;
+
+	void setPlayerColor(PlayerColor player);
+};
+
+/// area filled with specific texture, with applied color filter to colorize it to specific player
 class FilledTexturePlayerColored : public CFilledTexture
 {
 public:
-	FilledTexturePlayerColored(const ImagePath & imageName, Rect position);
+	FilledTexturePlayerColored(Rect position);
 
-	void playerColored(PlayerColor player);
+	void setPlayerColor(PlayerColor player);
 };
 
 /// Class for displaying one image from animation
@@ -103,8 +118,7 @@
 	bool visible;
 
 	CAnimImage(const AnimationPath & name, size_t Frame, size_t Group=0, int x=0, int y=0, ui8 Flags=0);
-	CAnimImage(std::shared_ptr<CAnimation> Anim, size_t Frame, size_t Group=0, int x=0, int y=0, ui8 Flags=0);
-	CAnimImage(std::shared_ptr<CAnimation> Anim, size_t Frame, Rect targetPos, size_t Group=0, ui8 Flags=0);
+	CAnimImage(const AnimationPath & name, size_t Frame, Rect targetPos, size_t Group=0, ui8 Flags=0);
 	~CAnimImage();
 
 	/// size of animation
@@ -114,7 +128,7 @@
 	void setFrame(size_t Frame, size_t Group=0);
 
 	/// makes image player-colored to specific player
-	void playerColored(PlayerColor player);
+	void setPlayerColor(PlayerColor player);
 
 	/// returns true if image has player-colored effect applied
 	bool isPlayerColored() const;
@@ -135,6 +149,7 @@
 		BASE=1,            //base frame will be blitted before current one
 		HORIZONTAL_FLIP=2, //TODO: will be displayed rotated
 		VERTICAL_FLIP=4,   //TODO: will be displayed rotated
+		CREATURE_MODE=8,   // use alpha channel for images with palette. Required for creatures in battle and map objects
 		PLAY_ONCE=32       //play animation only once and stop at last frame
 	};
 protected:
@@ -168,7 +183,6 @@
 	void setAlpha(ui32 alphaValue);
 
 	CShowableAnim(int x, int y, const AnimationPath & name, ui8 flags, ui32 frameTime, size_t Group=0, uint8_t alpha = UINT8_MAX);
-	~CShowableAnim();
 
 	//set animation to group or part of group
 	bool set(size_t Group);
diff --color -urN vcmi-1.5.7/client/widgets/IVideoHolder.h vcmi/client/widgets/IVideoHolder.h
--- vcmi-1.5.7/client/widgets/IVideoHolder.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/client/widgets/IVideoHolder.h	2024-12-19 15:00:22.336124712 +0100
@@ -0,0 +1,17 @@
+/*
+ * IVideoHolder.h, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#pragma once
+
+class IVideoHolder
+{
+public:
+	virtual ~IVideoHolder() = default;
+	virtual void onVideoPlaybackFinished() = 0;
+};
diff --color -urN vcmi-1.5.7/client/widgets/markets/CAltarArtifacts.cpp vcmi/client/widgets/markets/CAltarArtifacts.cpp
--- vcmi-1.5.7/client/widgets/markets/CAltarArtifacts.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/widgets/markets/CAltarArtifacts.cpp	2024-12-19 15:00:22.352125374 +0100
@@ -22,19 +22,17 @@
 #include "../../../CCallback.h"
 
 #include "../../../lib/networkPacks/ArtifactLocation.h"
-#include "../../../lib/CGeneralTextHandler.h"
+#include "../../../lib/texts/CGeneralTextHandler.h"
 #include "../../../lib/mapObjects/CGHeroInstance.h"
-#include "../../../lib/mapObjects/CGMarket.h"
+#include "../../../lib/mapObjects/IMarket.h"
 
 CAltarArtifacts::CAltarArtifacts(const IMarket * market, const CGHeroInstance * hero)
 	: CMarketBase(market, hero)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255 - DISPOSE);
+	OBJECT_CONSTRUCTION;
 
-	assert(dynamic_cast<const CGArtifactsAltar*>(market));
-	auto altarObj = dynamic_cast<const CGArtifactsAltar*>(market);
-	altarId = altarObj->id;
-	altarArtifacts = altarObj;
+	assert(market->getArtifactsStorage());
+	altarArtifactsStorage = market->getArtifactsStorage();
 
 	deal = std::make_shared<CButton>(Point(269, 520), AnimationPath::builtin("ALTSACR.DEF"),
 		CGI->generaltexth->zelp[585], [this]() {CAltarArtifacts::makeDeal(); }, EShortcut::MARKET_DEAL);
@@ -52,6 +50,7 @@
 	// Hero's artifacts
 	heroArts = std::make_shared<CArtifactsOfHeroAltar>(Point(-365, -11));
 	heroArts->setHero(hero);
+	heroArts->altarId = market->getObjInstanceID();
 
 	// Altar
 	offerTradePanel = std::make_shared<ArtifactsAltarPanel>([this](const std::shared_ptr<CTradeableItem> & altarSlot)
@@ -59,7 +58,7 @@
 			CAltarArtifacts::onSlotClickPressed(altarSlot, offerTradePanel);
 		});
 	offerTradePanel->updateSlotsCallback = std::bind(&CAltarArtifacts::updateAltarSlots, this);
-	offerTradePanel->moveTo(pos.topLeft() + Point(315, 52));
+	offerTradePanel->moveTo(pos.topLeft() + Point(315, 53));
 
 	CMarketBase::updateShowcases();
 	CAltarArtifacts::deselect();
@@ -104,18 +103,18 @@
 	{
 		positions.push_back(artInst->getId());
 	}
-	LOCPLINT->cb->trade(market, EMarketMode::ARTIFACT_EXP, positions, std::vector<TradeItemBuy>(), std::vector<ui32>(), hero);
+	LOCPLINT->cb->trade(market->getObjInstanceID(), EMarketMode::ARTIFACT_EXP, positions, std::vector<TradeItemBuy>(), std::vector<ui32>(), hero);
 	deselect();
 }
 
 void CAltarArtifacts::sacrificeAll()
 {
-	LOCPLINT->cb->bulkMoveArtifacts(heroArts->getHero()->id, altarId, false, true, true);
+	LOCPLINT->cb->bulkMoveArtifacts(heroArts->getHero()->id, heroArts->altarId, false, true, true);
 }
 
 void CAltarArtifacts::sacrificeBackpack()
 {
-	LOCPLINT->cb->bulkMoveArtifacts(heroArts->getHero()->id, altarId, false, false, true);
+	LOCPLINT->cb->bulkMoveArtifacts(heroArts->getHero()->id, heroArts->altarId, false, false, true);
 }
 
 std::shared_ptr<CArtifactsOfHeroAltar> CAltarArtifacts::getAOHset() const
@@ -125,7 +124,7 @@
 
 void CAltarArtifacts::updateAltarSlots()
 {
-	assert(altarArtifacts->artifactsInBackpack.size() <= GameConstants::ALTAR_ARTIFACTS_SLOTS);
+	assert(altarArtifactsStorage->artifactsInBackpack.size() <= GameConstants::ALTAR_ARTIFACTS_SLOTS);
 	assert(tradeSlotsMap.size() <= GameConstants::ALTAR_ARTIFACTS_SLOTS);
 	
 	auto tradeSlotsMapNewArts = tradeSlotsMap;
@@ -146,12 +145,12 @@
 	for(auto & tradeSlot : tradeSlotsMapNewArts)
 	{
 		assert(tradeSlot.first->id == -1);
-		assert(altarArtifacts->getSlotByInstance(tradeSlot.second) != ArtifactPosition::PRE_FIRST);
+		assert(altarArtifactsStorage->getArtPos(tradeSlot.second) != ArtifactPosition::PRE_FIRST);
 		tradeSlot.first->setID(tradeSlot.second->getTypeId().num);
 		tradeSlot.first->subtitle->setText(std::to_string(calcExpCost(tradeSlot.second->getTypeId())));
 	}
 
-	auto newArtsFromBulkMove = altarArtifacts->artifactsInBackpack;
+	auto newArtsFromBulkMove = altarArtifactsStorage->artifactsInBackpack;
 	for(const auto & [altarSlot, art] : tradeSlotsMap)
 	{
 		newArtsFromBulkMove.erase(std::remove_if(newArtsFromBulkMove.begin(), newArtsFromBulkMove.end(), [artForRemove = art](auto & slotInfo)
@@ -179,8 +178,8 @@
 {
 	// TODO: If the backpack capacity limit is enabled, artifacts may remain on the altar.
 	// Perhaps should be erased in CGameHandler::objectVisitEnded if id of visited object will be available
-	if(!altarArtifacts->artifactsInBackpack.empty())
-		LOCPLINT->cb->bulkMoveArtifacts(altarId, heroArts->getHero()->id, false, true, true);
+	if(!altarArtifactsStorage->artifactsInBackpack.empty())
+		LOCPLINT->cb->bulkMoveArtifacts(heroArts->altarId, heroArts->getHero()->id, false, true, true);
 }
 
 CMarketBase::MarketShowcasesParams CAltarArtifacts::getShowcasesParams() const
@@ -200,16 +199,16 @@
 
 	if(const auto pickedArtInst = heroArts->getPickedArtifact())
 	{
-		if(pickedArtInst->canBePutAt(altarArtifacts))
+		if(pickedArtInst->canBePutAt(altarArtifactsStorage))
 		{
-			if(pickedArtInst->artType->isTradable())
+			if(pickedArtInst->getType()->isTradable())
 			{
 				if(altarSlot->id == -1)
 					tradeSlotsMap.try_emplace(altarSlot, pickedArtInst);
 				deal->block(!LOCPLINT->makingTurn);
 
 				LOCPLINT->cb->swapArtifacts(ArtifactLocation(heroArts->getHero()->id, ArtifactPosition::TRANSITION_POS),
-					ArtifactLocation(altarId, ArtifactPosition::ALTAR));
+					ArtifactLocation(heroArts->altarId, ArtifactPosition::ALTAR));
 			}
 			else
 			{
@@ -221,9 +220,10 @@
 	else if(altarSlot->id != -1)
 	{
 		assert(tradeSlotsMap.at(altarSlot));
-		const auto slot = altarArtifacts->getSlotByInstance(tradeSlotsMap.at(altarSlot));
+		const auto slot = altarArtifactsStorage->getArtPos(tradeSlotsMap.at(altarSlot));
 		assert(slot != ArtifactPosition::PRE_FIRST);
-		LOCPLINT->cb->swapArtifacts(ArtifactLocation(altarId, slot), ArtifactLocation(hero->id, ArtifactPosition::TRANSITION_POS));
+		LOCPLINT->cb->swapArtifacts(ArtifactLocation(heroArts->altarId, slot),
+			ArtifactLocation(hero->id, GH.isKeyboardCtrlDown() ? ArtifactPosition::FIRST_AVAILABLE : ArtifactPosition::TRANSITION_POS));
 		tradeSlotsMap.erase(altarSlot);
 	}
 }
diff --color -urN vcmi-1.5.7/client/widgets/markets/CAltarArtifacts.h vcmi/client/widgets/markets/CAltarArtifacts.h
--- vcmi-1.5.7/client/widgets/markets/CAltarArtifacts.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/widgets/markets/CAltarArtifacts.h	2024-12-19 15:00:22.352125374 +0100
@@ -26,8 +26,7 @@
 	void putBackArtifacts();
 
 private:
-	ObjectInstanceID altarId;
-	const CArtifactSet * altarArtifacts;
+	const CArtifactSet * altarArtifactsStorage;
 	std::shared_ptr<CButton> sacrificeBackpackButton;
 	std::shared_ptr<CArtifactsOfHeroAltar> heroArts;
 	std::map<std::shared_ptr<CTradeableItem>, const CArtifactInstance*> tradeSlotsMap;
diff --color -urN vcmi-1.5.7/client/widgets/markets/CAltarCreatures.cpp vcmi/client/widgets/markets/CAltarCreatures.cpp
--- vcmi-1.5.7/client/widgets/markets/CAltarCreatures.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/widgets/markets/CAltarCreatures.cpp	2024-12-19 15:00:22.353125415 +0100
@@ -21,17 +21,16 @@
 
 #include "../../../CCallback.h"
 
-#include "../../../lib/CGeneralTextHandler.h"
+#include "../../../lib/texts/CGeneralTextHandler.h"
 #include "../../../lib/mapObjects/CGHeroInstance.h"
-#include "../../../lib/mapObjects/CGMarket.h"
-#include "../../../lib/MetaString.h"
+#include "../../../lib/mapObjects/IMarket.h"
 
 CAltarCreatures::CAltarCreatures(const IMarket * market, const CGHeroInstance * hero)
 	: CMarketBase(market, hero)
 	, CMarketSlider(std::bind(&CAltarCreatures::onOfferSliderMoved, this, _1))
 	, CMarketTraderText(Point(28, 31), FONT_MEDIUM, Colors::YELLOW)
 {
-	OBJECT_CONSTRUCTION_CUSTOM_CAPTURING(255 - DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	deal = std::make_shared<CButton>(dealButtonPosWithSlider, AnimationPath::builtin("ALTSACR.DEF"),
 		CGI->generaltexth->zelp[584], [this]() {CAltarCreatures::makeDeal();}, EShortcut::MARKET_DEAL);
@@ -158,14 +157,14 @@
 		}
 	}
 
-	LOCPLINT->cb->trade(market, EMarketMode::CREATURE_EXP, ids, {}, toSacrifice, hero);
+	LOCPLINT->cb->trade(market->getObjInstanceID(), EMarketMode::CREATURE_EXP, ids, {}, toSacrifice, hero);
 
 	for(int & units : unitsOnAltar)
 		units = 0;
 
-	for(auto heroSlot : offerTradePanel->slots)
+	for(const auto & heroSlot : offerTradePanel->slots)
 	{
-		heroSlot->setType(EType::CREATURE_PLACEHOLDER);
+		heroSlot->setID(CreatureID::NONE);
 		heroSlot->subtitle->clear();
 	}
 	deselect();
@@ -176,16 +175,16 @@
 	std::optional<ShowcaseParams> bidSelected = std::nullopt;
 	std::optional<ShowcaseParams> offerSelected = std::nullopt;
 	if(bidTradePanel->isHighlighted())
-		bidSelected = ShowcaseParams {std::to_string(offerSlider->getValue()), CGI->creatures()->getByIndex(bidTradePanel->getSelectedItemId())->getIconIndex()};
+		bidSelected = ShowcaseParams {std::to_string(offerSlider->getValue()), CGI->creatures()->getByIndex(bidTradePanel->getHighlightedItemId())->getIconIndex()};
 	if(offerTradePanel->isHighlighted() && offerSlider->getValue() > 0)
-		offerSelected = ShowcaseParams {offerTradePanel->highlightedSlot->subtitle->getText(), CGI->creatures()->getByIndex(offerTradePanel->getSelectedItemId())->getIconIndex()};
+		offerSelected = ShowcaseParams {offerTradePanel->highlightedSlot->subtitle->getText(), CGI->creatures()->getByIndex(offerTradePanel->getHighlightedItemId())->getIconIndex()};
 	return MarketShowcasesParams {bidSelected, offerSelected};
 }
 
 void CAltarCreatures::sacrificeAll()
 {
 	std::optional<SlotID> lastSlot;
-	for(auto heroSlot : bidTradePanel->slots)
+	for(const auto & heroSlot : bidTradePanel->slots)
 	{
 		auto stackCount = hero->getStackCount(SlotID(heroSlot->serial));
 		if(stackCount > unitsOnAltar[heroSlot->serial])
@@ -212,7 +211,8 @@
 void CAltarCreatures::updateAltarSlot(const std::shared_ptr<CTradeableItem> & slot)
 {
 	auto units = unitsOnAltar[slot->serial];
-	slot->setType(units > 0 ? EType::CREATURE : EType::CREATURE_PLACEHOLDER);
+	const auto [oppositeSlot, oppositePanel] = getOpposite(slot);
+	slot->setID(units > 0 ? oppositeSlot->id : CreatureID::NONE);
 	slot->subtitle->setText(units > 0 ?
 		boost::str(boost::format(CGI->generaltexth->allTexts[122]) % std::to_string(hero->calculateXp(units * expPerUnit[slot->serial]))) : "");
 }
@@ -235,21 +235,9 @@
 	if(newSlot == curPanel->highlightedSlot)
 		return;
 
-	auto oppositePanel = bidTradePanel;
 	curPanel->onSlotClickPressed(newSlot);
-	if(curPanel->highlightedSlot == bidTradePanel->highlightedSlot)
-	{
-		oppositePanel = offerTradePanel;
-	}
-	std::shared_ptr<CTradeableItem> oppositeNewSlot;
-	for(const auto & slot : oppositePanel->slots)
-		if(slot->serial == newSlot->serial)
-		{
-			oppositeNewSlot = slot;
-			break;
-		}
-	assert(oppositeNewSlot);
-	oppositePanel->onSlotClickPressed(oppositeNewSlot);
+	auto [oppositeSlot, oppositePanel] = getOpposite(newSlot);
+	oppositePanel->onSlotClickPressed(oppositeSlot);
 	highlightingChanged();
 	redraw();
 }
@@ -259,7 +247,7 @@
 	if(bidTradePanel->isHighlighted() && offerTradePanel->isHighlighted())
 	{
 		MetaString message = MetaString::createFromTextID("core.genrltxt.484");
-		message.replaceNamePlural(CreatureID(bidTradePanel->getSelectedItemId()));
+		message.replaceNamePlural(CreatureID(bidTradePanel->getHighlightedItemId()));
 		return message.toString();
 	}
 	else
@@ -267,3 +255,22 @@
 		return "";
 	}
 }
+
+std::tuple<const std::shared_ptr<CTradeableItem>, std::shared_ptr<TradePanelBase>> CAltarCreatures::getOpposite(
+	const std::shared_ptr<CTradeableItem> & curSlot)
+{
+	assert(curSlot);
+
+	auto oppositePanel = bidTradePanel;
+	if(vstd::contains(bidTradePanel->slots, curSlot))
+		oppositePanel = offerTradePanel;
+
+	std::shared_ptr<CTradeableItem> oppositeSlot;
+	for(const auto & slot : oppositePanel->slots)
+		if (slot->serial == curSlot->serial)
+		{
+			oppositeSlot = slot;
+			break;
+		}
+	return std::make_tuple(oppositeSlot, oppositePanel);
+}
diff --color -urN vcmi-1.5.7/client/widgets/markets/CAltarCreatures.h vcmi/client/widgets/markets/CAltarCreatures.h
--- vcmi-1.5.7/client/widgets/markets/CAltarCreatures.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/widgets/markets/CAltarCreatures.h	2024-12-19 15:00:22.353125415 +0100
@@ -33,4 +33,5 @@
 	void onOfferSliderMoved(int newVal) override;
 	void onSlotClickPressed(const std::shared_ptr<CTradeableItem> & newSlot, std::shared_ptr<TradePanelBase> & curPanel) override;
 	std::string getTraderText() override;
+	std::tuple<const std::shared_ptr<CTradeableItem>, std::shared_ptr<TradePanelBase>> getOpposite(const std::shared_ptr<CTradeableItem> & curSlot);
 };
diff --color -urN vcmi-1.5.7/client/widgets/markets/CArtifactsBuying.cpp vcmi/client/widgets/markets/CArtifactsBuying.cpp
--- vcmi-1.5.7/client/widgets/markets/CArtifactsBuying.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/widgets/markets/CArtifactsBuying.cpp	2024-12-19 15:00:22.354125456 +0100
@@ -11,7 +11,6 @@
 #include "StdInc.h"
 #include "CArtifactsBuying.h"
 
-#include "../../gui/CGuiHandler.h"
 #include "../../gui/Shortcut.h"
 #include "../../widgets/Buttons.h"
 #include "../../widgets/TextControls.h"
@@ -21,22 +20,16 @@
 
 #include "../../../CCallback.h"
 
-#include "../../../lib/CGeneralTextHandler.h"
 #include "../../../lib/mapObjects/CGHeroInstance.h"
-#include "../../../lib/mapObjects/CGMarket.h"
-#include "../../../lib/mapObjects/CGTownInstance.h"
+#include "../../../lib/mapObjects/IMarket.h"
+#include "../../../lib/texts/CGeneralTextHandler.h"
 
-CArtifactsBuying::CArtifactsBuying(const IMarket * market, const CGHeroInstance * hero)
+CArtifactsBuying::CArtifactsBuying(const IMarket * market, const CGHeroInstance * hero, const std::string & title)
 	: CMarketBase(market, hero)
 	, CResourcesSelling([this](const std::shared_ptr<CTradeableItem> & heroSlot){CArtifactsBuying::onSlotClickPressed(heroSlot, bidTradePanel);})
 {
-	OBJECT_CONSTRUCTION_CUSTOM_CAPTURING(255 - DISPOSE);
+	OBJECT_CONSTRUCTION;
 
-	std::string title;
-	if(auto townMarket = dynamic_cast<const CGTownInstance*>(market))
-		title = (*CGI->townh)[townMarket->getFaction()]->town->buildings[BuildingID::ARTIFACT_MERCHANT]->getNameTranslated();
-	else
-		title = CGI->generaltexth->allTexts[349];
 	labels.emplace_back(std::make_shared<CLabel>(titlePos.x, titlePos.y, FONT_BIG, ETextAlignment::CENTER, Colors::YELLOW, title));
 	deal = std::make_shared<CButton>(dealButtonPos, AnimationPath::builtin("TPMRKB.DEF"),
 		CGI->generaltexth->zelp[595], [this](){CArtifactsBuying::makeDeal();}, EShortcut::MARKET_DEAL);
@@ -53,7 +46,7 @@
 			CArtifactsBuying::onSlotClickPressed(newSlot, offerTradePanel);
 		}, [this]()
 		{
-			CMarketBase::updateSubtitlesForBid(EMarketMode::RESOURCE_ARTIFACT, bidTradePanel->getSelectedItemId());
+			CMarketBase::updateSubtitlesForBid(EMarketMode::RESOURCE_ARTIFACT, bidTradePanel->getHighlightedItemId());
 		}, market->availableItemsIds(EMarketMode::RESOURCE_ARTIFACT));
 	offerTradePanel->deleteSlotsCheck = [this](const std::shared_ptr<CTradeableItem> & slot)
 	{
@@ -73,10 +66,10 @@
 
 void CArtifactsBuying::makeDeal()
 {
-	if(ArtifactID(offerTradePanel->getSelectedItemId()).toArtifact()->canBePutAt(hero))
+	if(ArtifactID(offerTradePanel->getHighlightedItemId()).toArtifact()->canBePutAt(hero))
 	{
-		LOCPLINT->cb->trade(market, EMarketMode::RESOURCE_ARTIFACT, GameResID(bidTradePanel->getSelectedItemId()),
-			ArtifactID(offerTradePanel->getSelectedItemId()), offerQty, hero);
+		LOCPLINT->cb->trade(market->getObjInstanceID(), EMarketMode::RESOURCE_ARTIFACT, GameResID(bidTradePanel->getHighlightedItemId()),
+			ArtifactID(offerTradePanel->getHighlightedItemId()), offerQty, hero);
 		CMarketTraderText::makeDeal();
 		deselect();
 	}
@@ -91,8 +84,8 @@
 	if(bidTradePanel->isHighlighted() && offerTradePanel->isHighlighted())
 		return MarketShowcasesParams
 		{
-			ShowcaseParams {std::to_string(deal->isBlocked() ? 0 : bidQty), bidTradePanel->getSelectedItemId()},
-			ShowcaseParams {std::to_string(deal->isBlocked() ? 0 : offerQty), CGI->artifacts()->getByIndex(offerTradePanel->getSelectedItemId())->getIconIndex()}
+			ShowcaseParams {std::to_string(deal->isBlocked() ? 0 : bidQty), bidTradePanel->getHighlightedItemId()},
+			ShowcaseParams {std::to_string(deal->isBlocked() ? 0 : offerQty), CGI->artifacts()->getByIndex(offerTradePanel->getHighlightedItemId())->getIconIndex()}
 		};
 	else
 		return MarketShowcasesParams {std::nullopt, std::nullopt};
@@ -102,8 +95,8 @@
 {
 	if(bidTradePanel->isHighlighted() && offerTradePanel->isHighlighted())
 	{
-		market->getOffer(bidTradePanel->getSelectedItemId(), offerTradePanel->getSelectedItemId(), bidQty, offerQty, EMarketMode::RESOURCE_ARTIFACT);
-		deal->block(LOCPLINT->cb->getResourceAmount(GameResID(bidTradePanel->getSelectedItemId())) < bidQty || !LOCPLINT->makingTurn);
+		market->getOffer(bidTradePanel->getHighlightedItemId(), offerTradePanel->getHighlightedItemId(), bidQty, offerQty, EMarketMode::RESOURCE_ARTIFACT);
+		deal->block(LOCPLINT->cb->getResourceAmount(GameResID(bidTradePanel->getHighlightedItemId())) < bidQty || !LOCPLINT->makingTurn);
 	}
 	CMarketBase::highlightingChanged();
 	CMarketTraderText::highlightingChanged();
@@ -114,10 +107,10 @@
 	if(bidTradePanel->isHighlighted() && offerTradePanel->isHighlighted())
 	{
 		MetaString message = MetaString::createFromTextID("core.genrltxt.267");
-		message.replaceName(ArtifactID(offerTradePanel->getSelectedItemId()));
+		message.replaceName(ArtifactID(offerTradePanel->getHighlightedItemId()));
 		message.replaceNumber(bidQty);
 		message.replaceTextID(bidQty == 1 ? "core.genrltxt.161" : "core.genrltxt.160");
-		message.replaceName(GameResID(bidTradePanel->getSelectedItemId()));
+		message.replaceName(GameResID(bidTradePanel->getHighlightedItemId()));
 		return message.toString();
 	}
 	else
diff --color -urN vcmi-1.5.7/client/widgets/markets/CArtifactsBuying.h vcmi/client/widgets/markets/CArtifactsBuying.h
--- vcmi-1.5.7/client/widgets/markets/CArtifactsBuying.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/widgets/markets/CArtifactsBuying.h	2024-12-19 15:00:22.354125456 +0100
@@ -14,7 +14,7 @@
 class CArtifactsBuying : public CResourcesSelling, public CMarketTraderText
 {
 public:
-	CArtifactsBuying(const IMarket * market, const CGHeroInstance * hero);
+	CArtifactsBuying(const IMarket * market, const CGHeroInstance * hero, const std::string & title);
 	void deselect() override;
 	void makeDeal() override;
 
diff --color -urN vcmi-1.5.7/client/widgets/markets/CArtifactsSelling.cpp vcmi/client/widgets/markets/CArtifactsSelling.cpp
--- vcmi-1.5.7/client/widgets/markets/CArtifactsSelling.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/widgets/markets/CArtifactsSelling.cpp	2024-12-19 15:00:22.355125498 +0100
@@ -22,24 +22,17 @@
 #include "../../../CCallback.h"
 
 #include "../../../lib/CArtifactInstance.h"
-#include "../../../lib/CGeneralTextHandler.h"
 #include "../../../lib/mapObjects/CGHeroInstance.h"
-#include "../../../lib/mapObjects/CGMarket.h"
-#include "../../../lib/mapObjects/CGTownInstance.h"
+#include "../../../lib/mapObjects/IMarket.h"
+#include "../../../lib/texts/CGeneralTextHandler.h"
 
-CArtifactsSelling::CArtifactsSelling(const IMarket * market, const CGHeroInstance * hero)
+CArtifactsSelling::CArtifactsSelling(const IMarket * market, const CGHeroInstance * hero, const std::string & title)
 	: CMarketBase(market, hero)
 	, CResourcesBuying(
 		[this](const std::shared_ptr<CTradeableItem> & resSlot){CArtifactsSelling::onSlotClickPressed(resSlot, offerTradePanel);},
 		[this](){CArtifactsSelling::updateSubtitles();})
 {
-	OBJECT_CONSTRUCTION_CUSTOM_CAPTURING(255 - DISPOSE);
-
-	std::string title;
-	if(const auto townMarket = dynamic_cast<const CGTownInstance*>(market))
-		title = (*CGI->townh)[townMarket->getFaction()]->town->buildings[BuildingID::ARTIFACT_MERCHANT]->getNameTranslated();
-	else if(const auto mapMarket = dynamic_cast<const CGMarket*>(market))
-		title = mapMarket->title;
+	OBJECT_CONSTRUCTION;
 
 	labels.emplace_back(std::make_shared<CLabel>(titlePos.x, titlePos.y, FONT_BIG, ETextAlignment::CENTER, Colors::YELLOW, title));
 	labels.push_back(std::make_shared<CLabel>(155, 56, FONT_SMALL, ETextAlignment::CENTER, Colors::WHITE, boost::str(boost::format(CGI->generaltexth->allTexts[271]) % hero->getNameTranslated())));
@@ -56,14 +49,18 @@
 	// Hero's artifacts
 	heroArts = std::make_shared<CArtifactsOfHeroMarket>(Point(-361, 46), offerTradePanel->selectionWidth);
 	heroArts->setHero(hero);
-	heroArts->selectArtCallback = [this](const CArtPlace * artPlace)
+	heroArts->onSelectArtCallback = [this](const CArtPlace * artPlace)
 	{
 		assert(artPlace);
 		selectedHeroSlot = artPlace->slot;
 		CArtifactsSelling::highlightingChanged();
 		CIntObject::redraw();
 	};
-
+	heroArts->onClickNotTradableCallback = []()
+	{
+		// This item can't be traded
+		LOCPLINT->showInfoDialog(CGI->generaltexth->allTexts[21]);
+	};
 	CArtifactsSelling::updateShowcases();
 	CArtifactsSelling::deselect();
 }
@@ -81,7 +78,8 @@
 {
 	const auto art = hero->getArt(selectedHeroSlot);
 	assert(art);
-	LOCPLINT->cb->trade(market, EMarketMode::ARTIFACT_RESOURCE, art->getId(), GameResID(offerTradePanel->getSelectedItemId()), offerQty, hero);
+	LOCPLINT->cb->trade(market->getObjInstanceID(), EMarketMode::ARTIFACT_RESOURCE, art->getId(),
+		GameResID(offerTradePanel->getHighlightedItemId()), offerQty, hero);
 	CMarketTraderText::makeDeal();
 }
 
@@ -131,7 +129,7 @@
 		return MarketShowcasesParams
 		{
 			std::nullopt,
-			ShowcaseParams {std::to_string(offerQty), offerTradePanel->getSelectedItemId()}
+			ShowcaseParams {std::to_string(offerQty), offerTradePanel->getHighlightedItemId()}
 		};
 	else
 		return MarketShowcasesParams {std::nullopt, std::nullopt};
@@ -149,7 +147,7 @@
 	const auto art = hero->getArt(selectedHeroSlot);
 	if(art && offerTradePanel->isHighlighted())
 	{
-		market->getOffer(art->getTypeId(), offerTradePanel->getSelectedItemId(), bidQty, offerQty, EMarketMode::ARTIFACT_RESOURCE);
+		market->getOffer(art->getTypeId(), offerTradePanel->getHighlightedItemId(), bidQty, offerQty, EMarketMode::ARTIFACT_RESOURCE);
 		deal->block(!LOCPLINT->makingTurn);
 	}
 	CMarketBase::highlightingChanged();
@@ -164,7 +162,7 @@
 		MetaString message = MetaString::createFromTextID("core.genrltxt.268");
 		message.replaceNumber(offerQty);
 		message.replaceRawString(offerQty == 1 ? CGI->generaltexth->allTexts[161] : CGI->generaltexth->allTexts[160]);
-		message.replaceName(GameResID(offerTradePanel->getSelectedItemId()));
+		message.replaceName(GameResID(offerTradePanel->getHighlightedItemId()));
 		message.replaceName(art->getTypeId());
 		return message.toString();
 	}
diff --color -urN vcmi-1.5.7/client/widgets/markets/CArtifactsSelling.h vcmi/client/widgets/markets/CArtifactsSelling.h
--- vcmi-1.5.7/client/widgets/markets/CArtifactsSelling.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/widgets/markets/CArtifactsSelling.h	2024-12-19 15:00:22.355125498 +0100
@@ -15,7 +15,7 @@
 class CArtifactsSelling : public CResourcesBuying, public CMarketTraderText
 {
 public:
-	CArtifactsSelling(const IMarket * market, const CGHeroInstance * hero);
+	CArtifactsSelling(const IMarket * market, const CGHeroInstance * hero, const std::string & title);
 	void deselect() override;
 	void makeDeal() override;
 	void updateShowcases() override;
diff --color -urN vcmi-1.5.7/client/widgets/markets/CFreelancerGuild.cpp vcmi/client/widgets/markets/CFreelancerGuild.cpp
--- vcmi-1.5.7/client/widgets/markets/CFreelancerGuild.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/widgets/markets/CFreelancerGuild.cpp	2024-12-19 15:00:22.356125539 +0100
@@ -21,19 +21,18 @@
 
 #include "../../../CCallback.h"
 
-#include "../../../lib/CGeneralTextHandler.h"
-#include "../../../lib/MetaString.h"
+#include "../../../lib/texts/CGeneralTextHandler.h"
 #include "../../../lib/mapObjects/CGHeroInstance.h"
-#include "../../../lib/mapObjects/CGMarket.h"
+#include "../../../lib/mapObjects/IMarket.h"
 
 CFreelancerGuild::CFreelancerGuild(const IMarket * market, const CGHeroInstance * hero)
 	: CMarketBase(market, hero)
 	, CResourcesBuying(
 		[this](const std::shared_ptr<CTradeableItem> & heroSlot){CFreelancerGuild::onSlotClickPressed(heroSlot, offerTradePanel);},
-		[this](){CMarketBase::updateSubtitlesForBid(EMarketMode::CREATURE_RESOURCE, bidTradePanel->getSelectedItemId());})
+		[this](){CMarketBase::updateSubtitlesForBid(EMarketMode::CREATURE_RESOURCE, bidTradePanel->getHighlightedItemId());})
 	, CMarketSlider([this](int newVal){CMarketSlider::onOfferSliderMoved(newVal);})
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255 - DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	labels.emplace_back(std::make_shared<CLabel>(titlePos.x, titlePos.y, FONT_BIG, ETextAlignment::CENTER, Colors::YELLOW,
 		VLC->generaltexth->translate("object.core.freelancersGuild.name")));
@@ -70,7 +69,7 @@
 {
 	if(auto toTrade = offerSlider->getValue(); toTrade != 0)
 	{
-		LOCPLINT->cb->trade(market, EMarketMode::CREATURE_RESOURCE, SlotID(bidTradePanel->highlightedSlot->serial), GameResID(offerTradePanel->getSelectedItemId()), bidQty * toTrade, hero);
+		LOCPLINT->cb->trade(market->getObjInstanceID(), EMarketMode::CREATURE_RESOURCE, SlotID(bidTradePanel->highlightedSlot->serial), GameResID(offerTradePanel->getHighlightedItemId()), bidQty * toTrade, hero);
 		CMarketTraderText::makeDeal();
 		deselect();
 	}
@@ -81,8 +80,8 @@
 	if(bidTradePanel->isHighlighted() && offerTradePanel->isHighlighted())
 		return MarketShowcasesParams
 		{
-			ShowcaseParams {std::to_string(bidQty * offerSlider->getValue()), CGI->creatures()->getByIndex(bidTradePanel->getSelectedItemId())->getIconIndex()},
-			ShowcaseParams {std::to_string(offerQty * offerSlider->getValue()), offerTradePanel->getSelectedItemId()}
+			ShowcaseParams {std::to_string(bidQty * offerSlider->getValue()), CGI->creatures()->getByIndex(bidTradePanel->getHighlightedItemId())->getIconIndex()},
+			ShowcaseParams {std::to_string(offerQty * offerSlider->getValue()), offerTradePanel->getHighlightedItemId()}
 		};
 	else
 		return MarketShowcasesParams {std::nullopt, std::nullopt};
@@ -92,7 +91,7 @@
 {
 	if(bidTradePanel->isHighlighted() && offerTradePanel->isHighlighted())
 	{
-		market->getOffer(bidTradePanel->getSelectedItemId(), offerTradePanel->getSelectedItemId(), bidQty, offerQty, EMarketMode::CREATURE_RESOURCE);
+		market->getOffer(bidTradePanel->getHighlightedItemId(), offerTradePanel->getHighlightedItemId(), bidQty, offerQty, EMarketMode::CREATURE_RESOURCE);
 		offerSlider->setAmount((hero->getStackCount(SlotID(bidTradePanel->highlightedSlot->serial)) - (hero->stacksCount() == 1 && hero->needsLastStack() ? 1 : 0)) / bidQty);
 		offerSlider->scrollTo(0);
 		offerSlider->block(false);
@@ -110,12 +109,12 @@
 		MetaString message = MetaString::createFromTextID("core.genrltxt.269");
 		message.replaceNumber(offerQty);
 		message.replaceRawString(offerQty == 1 ? CGI->generaltexth->allTexts[161] : CGI->generaltexth->allTexts[160]);
-		message.replaceName(GameResID(offerTradePanel->getSelectedItemId()));
+		message.replaceName(GameResID(offerTradePanel->getHighlightedItemId()));
 		message.replaceNumber(bidQty);
 		if(bidQty == 1)
-			message.replaceNameSingular(bidTradePanel->getSelectedItemId());
+			message.replaceNameSingular(bidTradePanel->getHighlightedItemId());
 		else
-			message.replaceNamePlural(bidTradePanel->getSelectedItemId());
+			message.replaceNamePlural(bidTradePanel->getHighlightedItemId());
 		return message.toString();
 	}
 	else
diff --color -urN vcmi-1.5.7/client/widgets/markets/CMarketBase.cpp vcmi/client/widgets/markets/CMarketBase.cpp
--- vcmi-1.5.7/client/widgets/markets/CMarketBase.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/widgets/markets/CMarketBase.cpp	2024-12-19 15:00:22.357125580 +0100
@@ -23,9 +23,9 @@
 
 #include "../../../CCallback.h"
 
-#include "../../../lib/CGeneralTextHandler.h"
+#include "../../../lib/entities/hero/CHeroHandler.h"
+#include "../../../lib/texts/CGeneralTextHandler.h"
 #include "../../../lib/mapObjects/CGHeroInstance.h"
-#include "../../../lib/CHeroHandler.h"
 #include "../../../lib/mapObjects/CGMarket.h"
 
 CMarketBase::CMarketBase(const IMarket * market, const CGHeroInstance * hero)
@@ -93,7 +93,7 @@
 
 void CMarketBase::updateShowcases()
 {
-	const auto updateSelectedBody = [](const std::shared_ptr<TradePanelBase> & tradePanel, const std::optional<const ShowcaseParams> & params)
+	const auto updateShowcase = [](const std::shared_ptr<TradePanelBase> & tradePanel, const std::optional<const ShowcaseParams> & params)
 	{
 		if(params.has_value())
 		{
@@ -109,9 +109,9 @@
 
 	const auto params = getShowcasesParams();
 	if(bidTradePanel)
-		updateSelectedBody(bidTradePanel, params.bidParams);
+		updateShowcase(bidTradePanel, params.bidParams);
 	if(offerTradePanel)
-		updateSelectedBody(offerTradePanel, params.offerParams);
+		updateShowcase(offerTradePanel, params.offerParams);
 }
 
 void CMarketBase::highlightingChanged()
@@ -122,7 +122,7 @@
 
 CExperienceAltar::CExperienceAltar()
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255 - DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	// Experience needed to reach next level
 	texts.emplace_back(std::make_shared<CTextBox>(CGI->generaltexth->allTexts[475], Rect(15, 415, 125, 50), 0, FONT_SMALL, ETextAlignment::CENTER, Colors::YELLOW));
@@ -144,7 +144,7 @@
 
 CCreaturesSelling::CCreaturesSelling()
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255 - DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	assert(hero);
 	CreaturesPanel::slotsData slots;
@@ -171,7 +171,7 @@
 CResourcesBuying::CResourcesBuying(const CTradeableItem::ClickPressedFunctor & clickPressedCallback,
 	const TradePanelBase::UpdateSlotsFunctor & updSlotsCallback)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255 - DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	offerTradePanel = std::make_shared<ResourcesPanel>(clickPressedCallback, updSlotsCallback);
 	offerTradePanel->moveTo(pos.topLeft() + Point(327, 182));
@@ -180,7 +180,7 @@
 
 CResourcesSelling::CResourcesSelling(const CTradeableItem::ClickPressedFunctor & clickPressedCallback)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255 - DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	bidTradePanel = std::make_shared<ResourcesPanel>(clickPressedCallback, std::bind(&CResourcesSelling::updateSubtitles, this));
 	labels.emplace_back(std::make_shared<CLabel>(156, 148, FONT_SMALL, ETextAlignment::CENTER, Colors::WHITE, CGI->generaltexth->allTexts[270]));
@@ -194,7 +194,7 @@
 
 CMarketSlider::CMarketSlider(const CSlider::SliderMovingFunctor & movingCallback)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255 - DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	offerSlider = std::make_shared<CSlider>(Point(230, 489), 137, movingCallback, 0, 0, 0, Orientation::HORIZONTAL);
 	maxAmount = std::make_shared<CButton>(Point(228, 520), AnimationPath::builtin("IRCBTNS.DEF"), CGI->generaltexth->zelp[596],
@@ -224,7 +224,7 @@
 CMarketTraderText::CMarketTraderText(const Point & pos, const EFonts & font, const ColorRGBA & color)
 	: madeTransaction(false)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255 - DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	traderText = std::make_shared<CTextBox>("", Rect(pos, traderTextDimensions), 0, font, ETextAlignment::CENTER, color);
 }
diff --color -urN vcmi-1.5.7/client/widgets/markets/CMarketResources.cpp vcmi/client/widgets/markets/CMarketResources.cpp
--- vcmi-1.5.7/client/widgets/markets/CMarketResources.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/widgets/markets/CMarketResources.cpp	2024-12-19 15:00:22.358125622 +0100
@@ -21,9 +21,8 @@
 
 #include "../../../CCallback.h"
 
-#include "../../../lib/CGeneralTextHandler.h"
-#include "../../../lib/MetaString.h"
-#include "../../../lib/mapObjects/CGMarket.h"
+#include "../../../lib/texts/CGeneralTextHandler.h"
+#include "../../../lib/mapObjects/IMarket.h"
 
 CMarketResources::CMarketResources(const IMarket * market, const CGHeroInstance * hero)
 	: CMarketBase(market, hero)
@@ -33,7 +32,7 @@
 		[this](){CMarketResources::updateSubtitles();})
 	, CMarketSlider([this](int newVal){CMarketSlider::onOfferSliderMoved(newVal);})
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255 - DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	labels.emplace_back(std::make_shared<CLabel>(titlePos.x, titlePos.y, FONT_BIG, ETextAlignment::CENTER, Colors::YELLOW, CGI->generaltexth->allTexts[158]));
 	deal = std::make_shared<CButton>(dealButtonPosWithSlider, AnimationPath::builtin("TPMRKB.DEF"),
@@ -61,7 +60,7 @@
 {
 	if(auto toTrade = offerSlider->getValue(); toTrade != 0)
 	{
-		LOCPLINT->cb->trade(market, EMarketMode::RESOURCE_RESOURCE, GameResID(bidTradePanel->getSelectedItemId()),
+		LOCPLINT->cb->trade(market->getObjInstanceID(), EMarketMode::RESOURCE_RESOURCE, GameResID(bidTradePanel->getHighlightedItemId()),
 			GameResID(offerTradePanel->highlightedSlot->id), bidQty * toTrade, hero);
 		CMarketTraderText::makeDeal();
 		deselect();
@@ -70,11 +69,11 @@
 
 CMarketBase::MarketShowcasesParams CMarketResources::getShowcasesParams() const
 {
-	if(bidTradePanel->highlightedSlot && offerTradePanel->highlightedSlot && bidTradePanel->getSelectedItemId() != offerTradePanel->getSelectedItemId())
+	if(bidTradePanel->highlightedSlot && offerTradePanel->highlightedSlot && bidTradePanel->getHighlightedItemId() != offerTradePanel->getHighlightedItemId())
 		return MarketShowcasesParams
 		{
-			ShowcaseParams {std::to_string(bidQty * offerSlider->getValue()), bidTradePanel->getSelectedItemId()},
-			ShowcaseParams {std::to_string(offerQty * offerSlider->getValue()), offerTradePanel->getSelectedItemId()}
+			ShowcaseParams {std::to_string(bidQty * offerSlider->getValue()), bidTradePanel->getHighlightedItemId()},
+			ShowcaseParams {std::to_string(offerQty * offerSlider->getValue()), offerTradePanel->getHighlightedItemId()}
 		};
 	else
 		return MarketShowcasesParams {std::nullopt, std::nullopt};
@@ -84,10 +83,10 @@
 {
 	if(bidTradePanel->isHighlighted() && offerTradePanel->isHighlighted())
 	{
-		market->getOffer(bidTradePanel->getSelectedItemId(), offerTradePanel->getSelectedItemId(), bidQty, offerQty, EMarketMode::RESOURCE_RESOURCE);
-		offerSlider->setAmount(LOCPLINT->cb->getResourceAmount(GameResID(bidTradePanel->getSelectedItemId())) / bidQty);
+		market->getOffer(bidTradePanel->getHighlightedItemId(), offerTradePanel->getHighlightedItemId(), bidQty, offerQty, EMarketMode::RESOURCE_RESOURCE);
+		offerSlider->setAmount(LOCPLINT->cb->getResourceAmount(GameResID(bidTradePanel->getHighlightedItemId())) / bidQty);
 		offerSlider->scrollTo(0);
-		const bool isControlsBlocked = bidTradePanel->getSelectedItemId() != offerTradePanel->getSelectedItemId() ? false : true;
+		const bool isControlsBlocked = bidTradePanel->getHighlightedItemId() != offerTradePanel->getHighlightedItemId() ? false : true;
 		offerSlider->block(isControlsBlocked);
 		maxAmount->block(isControlsBlocked);
 		deal->block(isControlsBlocked || !LOCPLINT->makingTurn);
@@ -98,7 +97,7 @@
 
 void CMarketResources::updateSubtitles()
 {
-	CMarketBase::updateSubtitlesForBid(EMarketMode::RESOURCE_RESOURCE, bidTradePanel->getSelectedItemId());
+	CMarketBase::updateSubtitlesForBid(EMarketMode::RESOURCE_RESOURCE, bidTradePanel->getHighlightedItemId());
 	if(bidTradePanel->highlightedSlot)
 		offerTradePanel->slots[bidTradePanel->highlightedSlot->serial]->subtitle->setText(CGI->generaltexth->allTexts[164]); // n/a
 }
@@ -106,15 +105,15 @@
 std::string CMarketResources::getTraderText()
 {
 	if(bidTradePanel->isHighlighted() && offerTradePanel->isHighlighted() &&
-		bidTradePanel->getSelectedItemId() != offerTradePanel->getSelectedItemId())
+		bidTradePanel->getHighlightedItemId() != offerTradePanel->getHighlightedItemId())
 	{
 		MetaString message = MetaString::createFromTextID("core.genrltxt.157");
 		message.replaceNumber(offerQty);
 		message.replaceRawString(offerQty == 1 ? CGI->generaltexth->allTexts[161] : CGI->generaltexth->allTexts[160]);
-		message.replaceName(GameResID(bidTradePanel->getSelectedItemId()));
+		message.replaceName(GameResID(bidTradePanel->getHighlightedItemId()));
 		message.replaceNumber(bidQty);
 		message.replaceRawString(bidQty == 1 ? CGI->generaltexth->allTexts[161] : CGI->generaltexth->allTexts[160]);
-		message.replaceName(GameResID(offerTradePanel->getSelectedItemId()));
+		message.replaceName(GameResID(offerTradePanel->getHighlightedItemId()));
 		return message.toString();
 	}
 	else
diff --color -urN vcmi-1.5.7/client/widgets/markets/CTransferResources.cpp vcmi/client/widgets/markets/CTransferResources.cpp
--- vcmi-1.5.7/client/widgets/markets/CTransferResources.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/widgets/markets/CTransferResources.cpp	2024-12-19 15:00:22.358125622 +0100
@@ -21,8 +21,9 @@
 
 #include "../../../CCallback.h"
 
-#include "../../../lib/CGeneralTextHandler.h"
-#include "../../../lib/MetaString.h"
+#include "../../../lib/texts/CGeneralTextHandler.h"
+#include "../../../lib/mapObjects/IMarket.h"
+#include "../../../lib/texts/MetaString.h"
 
 CTransferResources::CTransferResources(const IMarket * market, const CGHeroInstance * hero)
 	: CMarketBase(market, hero)
@@ -30,7 +31,7 @@
 	, CMarketSlider([this](int newVal){CMarketSlider::onOfferSliderMoved(newVal);})
 	, CMarketTraderText(Point(28, 48))
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255 - DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	labels.emplace_back(std::make_shared<CLabel>(titlePos.x, titlePos.y, FONT_BIG, ETextAlignment::CENTER, Colors::YELLOW, CGI->generaltexth->allTexts[158]));
 	labels.emplace_back(std::make_shared<CLabel>(445, 56, FONT_SMALL, ETextAlignment::CENTER, Colors::WHITE, CGI->generaltexth->allTexts[169]));
@@ -63,8 +64,8 @@
 {
 	if(auto toTrade = offerSlider->getValue(); toTrade != 0)
 	{
-		LOCPLINT->cb->trade(market, EMarketMode::RESOURCE_PLAYER, GameResID(bidTradePanel->getSelectedItemId()),
-			PlayerColor(offerTradePanel->getSelectedItemId()), toTrade, hero);
+		LOCPLINT->cb->trade(market->getObjInstanceID(), EMarketMode::RESOURCE_PLAYER, GameResID(bidTradePanel->getHighlightedItemId()),
+			PlayerColor(offerTradePanel->getHighlightedItemId()), toTrade, hero);
 		CMarketTraderText::makeDeal();
 		deselect();
 	}
@@ -75,8 +76,8 @@
 	if(bidTradePanel->isHighlighted() && offerTradePanel->isHighlighted())
 		return MarketShowcasesParams
 		{
-			ShowcaseParams {std::to_string(offerSlider->getValue()), bidTradePanel->getSelectedItemId()},
-			ShowcaseParams {CGI->generaltexth->capColors[offerTradePanel->getSelectedItemId()], offerTradePanel->getSelectedItemId()}
+			ShowcaseParams {std::to_string(offerSlider->getValue()), bidTradePanel->getHighlightedItemId()},
+			ShowcaseParams {CGI->generaltexth->capColors[offerTradePanel->getHighlightedItemId()], offerTradePanel->getHighlightedItemId()}
 		};
 	else
 		return MarketShowcasesParams {std::nullopt, std::nullopt};
@@ -86,7 +87,7 @@
 {
 	if(bidTradePanel->isHighlighted() && offerTradePanel->isHighlighted())
 	{
-		offerSlider->setAmount(LOCPLINT->cb->getResourceAmount(GameResID(bidTradePanel->getSelectedItemId())));
+		offerSlider->setAmount(LOCPLINT->cb->getResourceAmount(GameResID(bidTradePanel->getHighlightedItemId())));
 		offerSlider->scrollTo(0);
 		offerSlider->block(false);
 		maxAmount->block(false);
@@ -101,8 +102,8 @@
 	if(bidTradePanel->isHighlighted() && offerTradePanel->isHighlighted())
 	{
 		MetaString message = MetaString::createFromTextID("core.genrltxt.165");
-		message.replaceName(GameResID(bidTradePanel->getSelectedItemId()));
-		message.replaceName(PlayerColor(offerTradePanel->getSelectedItemId()));
+		message.replaceName(GameResID(bidTradePanel->getHighlightedItemId()));
+		message.replaceName(PlayerColor(offerTradePanel->getHighlightedItemId()));
 		return message.toString();
 	}
 	else
diff --color -urN vcmi-1.5.7/client/widgets/markets/TradePanels.cpp vcmi/client/widgets/markets/TradePanels.cpp
--- vcmi-1.5.7/client/widgets/markets/TradePanels.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/widgets/markets/TradePanels.cpp	2024-12-19 15:00:22.360125704 +0100
@@ -20,16 +20,16 @@
 
 #include "../../../CCallback.h"
 
-#include "../../../lib/CGeneralTextHandler.h"
+#include "../../../lib/texts/CGeneralTextHandler.h"
 #include "../../../lib/mapObjects/CGHeroInstance.h"
 
-CTradeableItem::CTradeableItem(const Rect & area, EType Type, int ID, int Serial)
+CTradeableItem::CTradeableItem(const Rect & area, EType Type, int32_t ID, int32_t serial)
 	: SelectableSlot(area, Point(1, 1))
 	, type(EType(-1)) // set to invalid, will be corrected in setType
 	, id(ID)
-	, serial(Serial)
+	, serial(serial)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255 - DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	addUsedEvents(LCLICK);
 	addUsedEvents(HOVER);
@@ -46,7 +46,7 @@
 {
 	if(type != newType)
 	{
-		OBJECT_CONSTRUCTION_CUSTOM_CAPTURING(255 - DISPOSE);
+		OBJECT_CONSTRUCTION;
 		type = newType;
 
 		if(getIndex() < 0)
@@ -65,17 +65,14 @@
 			subtitle->moveTo(pos.topLeft() + Point(35, 55));
 			image->moveTo(pos.topLeft() + Point(19, 8));
 			break;
-		case EType::CREATURE_PLACEHOLDER:
 		case EType::CREATURE:
 			subtitle->moveTo(pos.topLeft() + Point(30, 77));
 			break;
 		case EType::PLAYER:
 			subtitle->moveTo(pos.topLeft() + Point(31, 76));
 			break;
-		case EType::ARTIFACT_PLACEHOLDER:
-		case EType::ARTIFACT_INSTANCE:
-			image->moveTo(pos.topLeft() + Point(0, 1));
-			subtitle->moveTo(pos.topLeft() + Point(21, 56));
+		case EType::ARTIFACT:
+			subtitle->moveTo(pos.topLeft() + Point(21, 55));
 			break;
 		case EType::ARTIFACT_TYPE:
 			subtitle->moveTo(pos.topLeft() + Point(35, 57));
@@ -85,14 +82,14 @@
 	}
 }
 
-void CTradeableItem::setID(int newID)
+void CTradeableItem::setID(int32_t newID)
 {
 	if(id != newID)
 	{
 		id = newID;
 		if(image)
 		{
-			int index = getIndex();
+			const auto index = getIndex();
 			if(index < 0)
 				image->disable();
 			else
@@ -121,8 +118,7 @@
 	case EType::PLAYER:
 		return AnimationPath::builtin("CREST58");
 	case EType::ARTIFACT_TYPE:
-	case EType::ARTIFACT_PLACEHOLDER:
-	case EType::ARTIFACT_INSTANCE:
+	case EType::ARTIFACT:
 		return AnimationPath::builtin("artifact");
 	case EType::CREATURE:
 		return AnimationPath::builtin("TWCRPORT");
@@ -142,8 +138,7 @@
 	case EType::PLAYER:
 		return id;
 	case EType::ARTIFACT_TYPE:
-	case EType::ARTIFACT_INSTANCE:
-	case EType::ARTIFACT_PLACEHOLDER:
+	case EType::ARTIFACT:
 		return CGI->artifacts()->getByIndex(id)->getIconIndex();
 	case EType::CREATURE:
 		return CGI->creatures()->getByIndex(id)->getIconIndex();
@@ -169,11 +164,10 @@
 	switch(type)
 	{
 	case EType::CREATURE:
-	case EType::CREATURE_PLACEHOLDER:
 		GH.statusbar()->write(boost::str(boost::format(CGI->generaltexth->allTexts[481]) % CGI->creh->objects[id]->getNamePluralTranslated()));
 		break;
 	case EType::ARTIFACT_TYPE:
-	case EType::ARTIFACT_PLACEHOLDER:
+	case EType::ARTIFACT:
 		if(id < 0)
 			GH.statusbar()->write(CGI->generaltexth->zelp[582].first);
 		else
@@ -193,11 +187,9 @@
 	switch(type)
 	{
 	case EType::CREATURE:
-	case EType::CREATURE_PLACEHOLDER:
 		break;
 	case EType::ARTIFACT_TYPE:
-	case EType::ARTIFACT_PLACEHOLDER:
-		//TODO: it's would be better for market to contain actual CArtifactInstance and not just ids of certain artifact type so we can use getEffectiveDescription.
+	case EType::ARTIFACT:
 		if (id >= 0)
 			CRClickPopup::createAndPush(CGI->artifacts()->getByIndex(id)->getDescriptionTranslated());
 		break;
@@ -241,7 +233,7 @@
 	showcaseSlot->subtitle->setText(text);
 }
 
-int TradePanelBase::getSelectedItemId() const
+int32_t TradePanelBase::getHighlightedItemId() const
 {
 	if(highlightedSlot)
 		return highlightedSlot->id;
@@ -263,14 +255,14 @@
 
 bool TradePanelBase::isHighlighted() const
 {
-	return getSelectedItemId() != -1;
+	return highlightedSlot != nullptr;
 }
 
 ResourcesPanel::ResourcesPanel(const CTradeableItem::ClickPressedFunctor & clickPressedCallback,
 	const UpdateSlotsFunctor & updateSubtitles)
 {
 	assert(resourcesForTrade.size() == slotsPos.size());
-	OBJECT_CONSTRUCTION_CUSTOM_CAPTURING(255 - DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	for(const auto & res : resourcesForTrade)
 	{
@@ -287,7 +279,7 @@
 {
 	assert(slotsForTrade == slotsPos.size());
 	assert(slotsForTrade == arts.size());
-	OBJECT_CONSTRUCTION_CUSTOM_CAPTURING(255 - DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	for(auto slotIdx = 0; slotIdx < slotsForTrade; slotIdx++)
 	{
@@ -308,7 +300,7 @@
 PlayersPanel::PlayersPanel(const CTradeableItem::ClickPressedFunctor & clickPressedCallback)
 {
 	assert(PlayerColor::PLAYER_LIMIT_I <= slotsPos.size() + 1);
-	OBJECT_CONSTRUCTION_CUSTOM_CAPTURING(255 - DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	std::vector<PlayerColor> players;
 	for(auto player = PlayerColor(0); player < PlayerColor::PLAYER_LIMIT_I; player++)
@@ -334,12 +326,12 @@
 {
 	assert(initialSlots.size() <= GameConstants::ARMY_SIZE);
 	assert(slotsPos.size() <= GameConstants::ARMY_SIZE);
-	OBJECT_CONSTRUCTION_CUSTOM_CAPTURING(255 - DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	for(const auto & [creatureId, slotId, creaturesNum] : initialSlots)
 	{
 		auto slot = slots.emplace_back(std::make_shared<CTradeableItem>(Rect(slotsPos[slotId.num], slotDimension),
-			creaturesNum == 0 ? EType::CREATURE_PLACEHOLDER : EType::CREATURE, creatureId.num, slotId));
+			EType::CREATURE, creaturesNum == 0 ? -1 : creatureId.num, slotId));
 		slot->clickPressedCallback = clickPressedCallback;
 		if(creaturesNum != 0)
 			slot->subtitle->setText(std::to_string(creaturesNum));
@@ -352,12 +344,12 @@
 	const std::vector<std::shared_ptr<CTradeableItem>> & srcSlots, bool emptySlots)
 {
 	assert(slots.size() <= GameConstants::ARMY_SIZE);
-	OBJECT_CONSTRUCTION_CUSTOM_CAPTURING(255 - DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	for(const auto & srcSlot : srcSlots)
 	{
 		auto slot = slots.emplace_back(std::make_shared<CTradeableItem>(Rect(slotsPos[srcSlot->serial], srcSlot->pos.dimensions()),
-			emptySlots ? EType::CREATURE_PLACEHOLDER : EType::CREATURE, srcSlot->id, srcSlot->serial));
+			EType::CREATURE, emptySlots ? -1 : srcSlot->id, srcSlot->serial));
 		slot->clickPressedCallback = clickPressedCallback;
 		slot->subtitle->setText(emptySlots ? "" : srcSlot->subtitle->getText());
 		slot->setSelectionWidth(selectionWidth);
@@ -367,12 +359,12 @@
 
 ArtifactsAltarPanel::ArtifactsAltarPanel(const CTradeableItem::ClickPressedFunctor & clickPressedCallback)
 {
-	OBJECT_CONSTRUCTION_CUSTOM_CAPTURING(255 - DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	int slotNum = 0;
 	for(auto & altarSlotPos : slotsPos)
 	{
-		auto slot = slots.emplace_back(std::make_shared<CTradeableItem>(Rect(altarSlotPos, Point(44, 44)), EType::ARTIFACT_PLACEHOLDER, -1, slotNum));
+		auto slot = slots.emplace_back(std::make_shared<CTradeableItem>(Rect(altarSlotPos, Point(44, 44)), EType::ARTIFACT, -1, slotNum));
 		slot->clickPressedCallback = clickPressedCallback;
 		slot->subtitle->clear();
 		slot->subtitle->moveBy(Point(0, -1));
diff --color -urN vcmi-1.5.7/client/widgets/markets/TradePanels.h vcmi/client/widgets/markets/TradePanels.h
--- vcmi-1.5.7/client/widgets/markets/TradePanels.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/widgets/markets/TradePanels.h	2024-12-19 15:00:22.360125704 +0100
@@ -16,7 +16,7 @@
 
 enum class EType
 {
-	RESOURCE, PLAYER, ARTIFACT_TYPE, CREATURE, CREATURE_PLACEHOLDER, ARTIFACT_PLACEHOLDER, ARTIFACT_INSTANCE
+	RESOURCE, PLAYER, ARTIFACT_TYPE, CREATURE, ARTIFACT
 };
 
 class CTradeableItem : public SelectableSlot, public std::enable_shared_from_this<CTradeableItem>
@@ -28,19 +28,19 @@
 	using ClickPressedFunctor = std::function<void(const std::shared_ptr<CTradeableItem>&)>;
 
 	EType type;
-	int id;
-	const int serial;
+	int32_t id;
+	const int32_t serial;
 	std::shared_ptr<CLabel> subtitle;
 	ClickPressedFunctor clickPressedCallback;
 
 	void setType(EType newType);
-	void setID(int newID);
+	void setID(int32_t newID);
 	void clear();
 
 	void showPopupWindow(const Point & cursorPosition) override;
 	void hover(bool on) override;
 	void clickPressed(const Point & cursorPosition) override;
-	CTradeableItem(const Rect & area, EType Type, int ID, int Serial);
+	CTradeableItem(const Rect & area, EType Type, int32_t ID, int32_t serial);
 };
 
 class TradePanelBase : public CIntObject
@@ -61,7 +61,7 @@
 	virtual void clearSubtitles();
 	void updateOffer(CTradeableItem & slot, int, int);
 	void setShowcaseSubtitle(const std::string & text);
-	int getSelectedItemId() const;
+	int32_t getHighlightedItemId() const;
 	void onSlotClickPressed(const std::shared_ptr<CTradeableItem> & newSlot);
 	bool isHighlighted() const;
 };
diff --color -urN vcmi-1.5.7/client/widgets/MiscWidgets.cpp vcmi/client/widgets/MiscWidgets.cpp
--- vcmi-1.5.7/client/widgets/MiscWidgets.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/widgets/MiscWidgets.cpp	2024-12-19 15:00:22.339124836 +0100
@@ -28,18 +28,18 @@
 #include "../windows/CCastleInterface.h"
 #include "../windows/InfoWindows.h"
 #include "../render/Canvas.h"
-#include "../render/Graphics.h"
 
 #include "../../CCallback.h"
 
 #include "../../lib/CConfigHandler.h"
+#include "../../lib/IGameSettings.h"
+#include "../../lib/entities/faction/CTownHandler.h"
 #include "../../lib/gameState/InfoAboutArmy.h"
-#include "../../lib/CGeneralTextHandler.h"
-#include "../../lib/GameSettings.h"
-#include "../../lib/TextOperations.h"
 #include "../../lib/mapObjects/CGCreature.h"
 #include "../../lib/mapObjects/CGHeroInstance.h"
 #include "../../lib/mapObjects/CGTownInstance.h"
+#include "../../lib/texts/CGeneralTextHandler.h"
+#include "../../lib/texts/TextOperations.h"
 
 void CHoverableArea::hover (bool on)
 {
@@ -128,7 +128,7 @@
 	clickFunctor(nullptr),
 	clickRFunctor(nullptr)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	pos.x += x;
 	pos.w = 58;
@@ -243,13 +243,13 @@
 
 CMinorResDataBar::CMinorResDataBar()
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	pos.x = 7;
 	pos.y = 575;
 
 	background = std::make_shared<CPicture>(ImagePath::builtin("KRESBAR.bmp"));
-	background->colorize(LOCPLINT->playerID);
+	background->setPlayerColor(LOCPLINT->playerID);
 
 	pos.w = background->pos.w;
 	pos.h = background->pos.h;
@@ -259,7 +259,7 @@
 
 void CArmyTooltip::init(const InfoAboutArmy &army)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	title = std::make_shared<CLabel>(66, 2, FONT_SMALL, ETextAlignment::TOPLEFT, Colors::WHITE, army.name);
 
@@ -280,7 +280,7 @@
 			continue;
 		}
 
-		icons.push_back(std::make_shared<CAnimImage>(AnimationPath::builtin("CPRSMALL"), slot.second.type->getIconIndex(), 0, slotsPos[slot.first.getNum()].x, slotsPos[slot.first.getNum()].y));
+		icons.push_back(std::make_shared<CAnimImage>(AnimationPath::builtin("CPRSMALL"), slot.second.getType()->getIconIndex(), 0, slotsPos[slot.first.getNum()].x, slotsPos[slot.first.getNum()].y));
 
 		std::string subtitle;
 		if(army.army.isDetailed)
@@ -322,7 +322,7 @@
 
 void CHeroTooltip::init(const InfoAboutHero & hero)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	portrait = std::make_shared<CAnimImage>(AnimationPath::builtin("PortraitsLarge"), hero.getIconIndex(), 0, 3, 2);
 
 	if(hero.details)
@@ -354,13 +354,13 @@
 {
 	init(InfoAboutHero(hero, InfoAboutHero::EInfoLevel::DETAILED));
 
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	garrison = std::make_shared<CGarrisonInt>(pos + Point(0, 73), 4, Point(0, 0), hero, nullptr, true, true, CGarrisonInt::ESlotsLayout::REVERSED_TWO_ROWS);
 }
 
 void CInteractableHeroTooltip::init(const InfoAboutHero & hero)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	portrait = std::make_shared<CAnimImage>(AnimationPath::builtin("PortraitsLarge"), hero.getIconIndex(), 0, 3, 2);
 	title = std::make_shared<CLabel>(66, 2, FONT_SMALL, ETextAlignment::TOPLEFT, Colors::WHITE, hero.name);
 
@@ -379,7 +379,7 @@
 
 void CTownTooltip::init(const InfoAboutTown & town)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	//order of icons in def: fort, citadel, castle, no fort
 	size_t fortIndex = town.fortLevel ? town.fortLevel - 1 : 3;
@@ -388,7 +388,7 @@
 
 	assert(town.tType);
 
-	size_t iconIndex = town.tType->clientInfo.icons[town.fortLevel > 0][town.built >= CGI->settings()->getInteger(EGameSettings::TOWNS_BUILDINGS_PER_TURN_CAP)];
+	size_t iconIndex = town.tType->clientInfo.icons[town.fortLevel > 0][town.built >= LOCPLINT->cb->getSettings().getInteger(EGameSettings::TOWNS_BUILDINGS_PER_TURN_CAP)];
 
 	build = std::make_shared<CAnimImage>(AnimationPath::builtin("itpt"), iconIndex, 0, 3, 2);
 
@@ -435,13 +435,13 @@
 {
 	init(town);
 
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	garrison = std::make_shared<CGarrisonInt>(pos + Point(0, 73), 4, Point(0, 0), town->getUpperArmy(), nullptr, true, true, CGarrisonInt::ESlotsLayout::REVERSED_TWO_ROWS);
 }
 
 void CInteractableTownTooltip::init(const CGTownInstance * town)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	const InfoAboutTown townInfo = InfoAboutTown(town, true);
 	int townId = town->id;
@@ -464,19 +464,19 @@
 		std::vector<const CGTownInstance*> towns = LOCPLINT->cb->getTownsInfo(true);
 		for(auto & town : towns)
 		{
-			if(town->id == townId && town->builtBuildings.count(BuildingID::TAVERN))
+			if(town->id == townId && town->hasBuilt(BuildingID::TAVERN))
 				LOCPLINT->showTavernWindow(town, nullptr, QueryID::NONE);
 		}
 	}, [town]{
-		if(!town->town->faction->getDescriptionTranslated().empty())
-			CRClickPopup::createAndPush(town->town->faction->getDescriptionTranslated());
+		if(!town->getFaction()->getDescriptionTranslated().empty())
+			CRClickPopup::createAndPush(town->getFaction()->getDescriptionTranslated());
 	});
 	fastMarket = std::make_shared<LRClickableArea>(Rect(143, 31, 30, 34), []()
 	{
 		std::vector<const CGTownInstance*> towns = LOCPLINT->cb->getTownsInfo(true);
 		for(auto & town : towns)
 		{
-			if(town->builtBuildings.count(BuildingID::MARKETPLACE))
+			if(town->hasBuilt(BuildingID::MARKETPLACE))
 			{
 				GH.windows().createAndPushWindow<CMarketWindow>(town, nullptr, nullptr, EMarketMode::RESOURCE_RESOURCE);
 				return;
@@ -487,7 +487,7 @@
 
 	assert(townInfo.tType);
 
-	size_t iconIndex = townInfo.tType->clientInfo.icons[townInfo.fortLevel > 0][townInfo.built >= CGI->settings()->getInteger(EGameSettings::TOWNS_BUILDINGS_PER_TURN_CAP)];
+	size_t iconIndex = townInfo.tType->clientInfo.icons[townInfo.fortLevel > 0][townInfo.built >= LOCPLINT->cb->getSettings().getInteger(EGameSettings::TOWNS_BUILDINGS_PER_TURN_CAP)];
 
 	build = std::make_shared<CAnimImage>(AnimationPath::builtin("itpt"), iconIndex, 0, 3, 2);
 	title = std::make_shared<CLabel>(66, 2, FONT_SMALL, ETextAlignment::TOPLEFT, Colors::WHITE, townInfo.name);
@@ -530,12 +530,11 @@
 
 CreatureTooltip::CreatureTooltip(Point pos, const CGCreature * creature)
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 
-	auto creatureID = creature->getCreature();
-	int32_t creatureIconIndex = CGI->creatures()->getById(creatureID)->getIconIndex();
+	int32_t creatureIconIndex = creature->getCreature()->getIconIndex();
 
-	creatureImage = std::make_shared<CAnimImage>(graphics->getAnimation(AnimationPath::builtin("TWCRPORT")), creatureIconIndex);
+	creatureImage = std::make_shared<CAnimImage>(AnimationPath::builtin("TWCRPORT"), creatureIconIndex);
 	creatureImage->center(Point(parent->pos.x + parent->pos.w / 2, parent->pos.y + creatureImage->pos.h / 2 + 11));
 
 	bool isHeroSelected = LOCPLINT->localState->getCurrentHero() != nullptr;
@@ -553,7 +552,7 @@
 
 void MoraleLuckBox::set(const AFactionMember * node)
 {
-	OBJECT_CONSTRUCTION_CUSTOM_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	const std::array textId = {62, 88}; //eg %s \n\n\n {Current Luck Modifiers:}
 	const int noneTxtId = 108; //Russian version uses same text for neutral morale\luck
@@ -574,7 +573,8 @@
 	boost::algorithm::replace_first(text,"%s",CGI->generaltexth->arraytxt[neutralDescr[morale]-mrlt]);
 
 	if (morale && node && (node->getBonusBearer()->hasBonusOfType(BonusType::UNDEAD)
-			|| node->getBonusBearer()->hasBonusOfType(BonusType::NON_LIVING)))
+			|| node->getBonusBearer()->hasBonusOfType(BonusType::NON_LIVING)
+			|| node->getBonusBearer()->hasBonusOfType(BonusType::MECHANICAL)))
 	{
 		text += CGI->generaltexth->arraytxt[113]; //unaffected by morale
 		component.value = 0;
@@ -582,13 +582,13 @@
 	else if(morale && node && node->getBonusBearer()->hasBonusOfType(BonusType::NO_MORALE))
 	{
 		auto noMorale = node->getBonusBearer()->getBonus(Selector::type()(BonusType::NO_MORALE));
-		text += "\n" + noMorale->Description();
+		text += "\n" + noMorale->Description(LOCPLINT->cb.get());
 		component.value = 0;
 	}
 	else if (!morale && node && node->getBonusBearer()->hasBonusOfType(BonusType::NO_LUCK))
 	{
 		auto noLuck = node->getBonusBearer()->getBonus(Selector::type()(BonusType::NO_LUCK));
-		text += "\n" + noLuck->Description();
+		text += "\n" + noLuck->Description(LOCPLINT->cb.get());
 		component.value = 0;
 	}
 	else
@@ -597,7 +597,7 @@
 		for(auto & bonus : * modifierList)
 		{
 			if(bonus->val) {
-				const std::string& description = bonus->Description();
+				const std::string& description = bonus->Description(LOCPLINT->cb.get());
 				//arraytxt already contains \n
 				if (description.size() && description[0] != '\n')
 					addInfo += '\n';
@@ -625,16 +625,15 @@
 	small(Small)
 {
 	pos = r + pos.topLeft();
-	defActions = 255-DISPOSE;
 }
 
 CCreaturePic::CCreaturePic(int x, int y, const CCreature * cre, bool Big, bool Animated)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	pos.x+=x;
 	pos.y+=y;
 
-	auto faction = cre->getFaction();
+	auto faction = cre->getFactionID();
 
 	assert(CGI->townh->size() > faction);
 
@@ -681,7 +680,7 @@
 	: LRClickableAreaWTextComp(area)
 	, selected(false)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	selection = std::make_shared<TransparentFilledRectangle>( Rect(-oversize, area.dimensions() + oversize * 2), Colors::TRANSPARENCY, Colors::YELLOW, width);
 	selectSlot(false);
@@ -710,7 +709,12 @@
 
 void SelectableSlot::setSelectionWidth(int width)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	selection = std::make_shared<TransparentFilledRectangle>( selection->pos - pos.topLeft(), Colors::TRANSPARENCY, Colors::YELLOW, width);
 	selectSlot(selected);
 }
+
+void SelectableSlot::moveSelectionForeground()
+{
+	moveChildForeground(selection.get());
+}
diff --color -urN vcmi-1.5.7/client/widgets/MiscWidgets.h vcmi/client/widgets/MiscWidgets.h
--- vcmi-1.5.7/client/widgets/MiscWidgets.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/widgets/MiscWidgets.h	2024-12-19 15:00:22.340124878 +0100
@@ -261,4 +261,5 @@
 	void selectSlot(bool on);
 	bool isSelected() const;
 	void setSelectionWidth(int width);
+	void moveSelectionForeground();
 };
diff --color -urN vcmi-1.5.7/client/widgets/ObjectLists.cpp vcmi/client/widgets/ObjectLists.cpp
--- vcmi-1.5.7/client/widgets/ObjectLists.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/widgets/ObjectLists.cpp	2024-12-19 15:00:22.341124919 +0100
@@ -28,12 +28,11 @@
 
 std::shared_ptr<CIntObject> CObjectList::createItem(size_t index)
 {
-	OBJECT_CONSTRUCTION_CUSTOM_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	std::shared_ptr<CIntObject> item = createObject(index);
 	if(!item)
 		item = std::make_shared<CIntObject>();
 
-	item->recActions = defActions;
 	addChild(item.get());
 	if (isActive())
 		item->activate();
@@ -45,7 +44,6 @@
 	activeTab(nullptr),
 	activeID(ActiveID)
 {
-	defActions &= ~DISPOSE;
 	pos += position;
 	reset();
 }
@@ -92,7 +90,7 @@
 
 	if(Slider & 1)
 	{
-		OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+		OBJECT_CONSTRUCTION;
 		slider = std::make_shared<CSlider>(
 			SliderPos.topLeft(),
 			SliderPos.w,
@@ -118,12 +116,12 @@
 		(elem)->moveTo(itemPos);
 		itemPos += itemOffset;
 	}
-	if (isActive())
+	if(slider)
 	{
-		redraw();
-		if (slider)
-			slider->scrollTo((int)first);
+		slider->scrollTo((int)first);
+		moveChildForeground(slider.get());
 	}
+	redraw();
 }
 
 void CListBox::reset()
diff --color -urN vcmi-1.5.7/client/widgets/ObjectLists.h vcmi/client/widgets/ObjectLists.h
--- vcmi-1.5.7/client/widgets/ObjectLists.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/widgets/ObjectLists.h	2024-12-19 15:00:22.342124960 +0100
@@ -18,7 +18,6 @@
 class CAnimImage;
 class CSlider;
 class CLabel;
-class CAnimation;
 
 /// Used as base for Tabs and List classes
 class CObjectList : public CIntObject
@@ -77,7 +76,7 @@
 	//ItemOffset - distance between items in the list
 	//VisibleSize - maximal number of displayable at once items
 	//TotalSize
-	//Slider - slider style, bit field: 1 = present(disabled), 2=horisontal(vertical), 4=blue(brown)
+	//Slider - slider style, bit field: 1 = present(disabled), 2=horizontal(vertical), 4=blue(brown)
 	//SliderPos - position of slider, if present
 	CListBox(CreateFunc create, Point Pos, Point ItemOffset, size_t VisibleSize,
 		size_t TotalSize, size_t InitialPos=0, int Slider=0, Rect SliderPos=Rect() );
diff --color -urN vcmi-1.5.7/client/widgets/RadialMenu.cpp vcmi/client/widgets/RadialMenu.cpp
--- vcmi-1.5.7/client/widgets/RadialMenu.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/widgets/RadialMenu.cpp	2024-12-19 15:00:22.342124960 +0100
@@ -19,13 +19,13 @@
 #include "../render/IImage.h"
 #include "../CGameInfo.h"
 
-#include "../../lib/CGeneralTextHandler.h"
+#include "../../lib/texts/CGeneralTextHandler.h"
 
 RadialMenuItem::RadialMenuItem(const std::string & imageName, const std::string & hoverText, const std::function<void()> & callback, bool alternativeLayout)
 	: callback(callback)
 	, hoverText(hoverText)
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 
 	inactiveImage = std::make_shared<CPicture>(ImagePath::builtin(alternativeLayout ? "radialMenu/itemInactiveAlt" : "radialMenu/itemInactive"), Point(0, 0));
 	selectedImage = std::make_shared<CPicture>(ImagePath::builtin(alternativeLayout ? "radialMenu/itemEmptyAlt" : "radialMenu/itemEmpty"), Point(0, 0));
@@ -45,7 +45,7 @@
 RadialMenu::RadialMenu(const Point & positionToCenter, const std::vector<RadialMenuConfig> & menuConfig, bool alternativeLayout):
 	centerPosition(positionToCenter), alternativeLayout(alternativeLayout)
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 	pos += positionToCenter;
 
 	Point itemSize = alternativeLayout ? Point(80, 70) : Point(70, 80);
diff --color -urN vcmi-1.5.7/client/widgets/Slider.cpp vcmi/client/widgets/Slider.cpp
--- vcmi-1.5.7/client/widgets/Slider.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/widgets/Slider.cpp	2024-12-19 15:00:22.347125167 +0100
@@ -183,7 +183,7 @@
 	value(Value),
 	moved(Moved)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	setAmount(amount);
 	vstd::amax(value, 0);
 	vstd::amin(value, positions);
diff --color -urN vcmi-1.5.7/client/widgets/TextControls.cpp vcmi/client/widgets/TextControls.cpp
--- vcmi-1.5.7/client/widgets/TextControls.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/widgets/TextControls.cpp	2024-12-19 15:00:22.349125250 +0100
@@ -22,8 +22,9 @@
 #include "../render/Canvas.h"
 #include "../render/Graphics.h"
 #include "../render/IFont.h"
+#include "../render/IRenderHandler.h"
 
-#include "../../lib/TextOperations.h"
+#include "../../lib/texts/TextOperations.h"
 
 #ifdef VCMI_ANDROID
 #include "lib/CAndroidVMHelper.h"
@@ -56,8 +57,9 @@
 
 	if(alignment == ETextAlignment::TOPLEFT) // causes issues for MIDDLE
 	{
-		pos.w = (int)graphics->fonts[font]->getStringWidth(visibleText().c_str());
-		pos.h = (int)graphics->fonts[font]->getLineHeight();
+		const auto & fontPtr = GH.renderHandler().loadFont(font);
+		pos.w = fontPtr->getStringWidth(visibleText().c_str());
+		pos.h = fontPtr->getLineHeight();
 	}
 }
 
@@ -114,8 +116,12 @@
 void CLabel::trimText()
 {
 	if(maxWidth > 0)
-		while ((int)graphics->fonts[font]->getStringWidth(visibleText().c_str()) > maxWidth)
+	{
+		const auto & fontPtr = GH.renderHandler().loadFont(font);
+
+		while (fontPtr->getStringWidth(visibleText().c_str()) > maxWidth)
 			TextOperations::trimRightUnicode(text);
+	}
 }
 
 void CLabel::setColor(const ColorRGBA & Color)
@@ -132,7 +138,8 @@
 
 size_t CLabel::getWidth()
 {
-	return graphics->fonts[font]->getStringWidth(visibleText());
+	const auto & fontPtr = GH.renderHandler().loadFont(font);
+	return fontPtr->getStringWidth(visibleText());
 }
 
 CMultiLineLabel::CMultiLineLabel(Rect position, EFonts Font, ETextAlignment Align, const ColorRGBA & Color, const std::string & Text) :
@@ -169,17 +176,22 @@
 	CLabel::setText(Txt);
 }
 
+std::vector<std::string> CMultiLineLabel::getLines()
+{
+	return lines;
+}
+
 void CTextContainer::blitLine(Canvas & to, Rect destRect, std::string what)
 {
-	const auto f = graphics->fonts[font];
+	const auto f = GH.renderHandler().loadFont(font);
 	Point where = destRect.topLeft();
-	const std::string delimeters = "{}";
-	auto delimitersCount = std::count_if(what.cbegin(), what.cend(), [&delimeters](char c)
+	const std::string delimiters = "{}";
+	auto delimitersCount = std::count_if(what.cbegin(), what.cend(), [&delimiters](char c)
 	{
-		return delimeters.find(c) != std::string::npos;
+		return delimiters.find(c) != std::string::npos;
 	});
 	//We should count delimiters length from string to correct centering later.
-	delimitersCount *= f->getStringWidth(delimeters)/2;
+	delimitersCount *= f->getStringWidth(delimiters)/2;
 
 	std::smatch match;
 	std::regex expr("\\{(.*?)\\|");
@@ -214,16 +226,16 @@
 		where.y += getBorderSize().y + destRect.h - static_cast<int>(f->getLineHeight());
 
 	size_t begin = 0;
-	size_t currDelimeter = 0;
+	size_t currDelimiter = 0;
 
 	do
 	{
-		size_t end = what.find_first_of(delimeters[currDelimeter % 2], begin);
+		size_t end = what.find_first_of(delimiters[currDelimiter % 2], begin);
 		if(begin != end)
 		{
 			std::string toPrint = what.substr(begin, end - begin);
 
-			if(currDelimeter % 2) // Enclosed in {} text - set to yellow or defined color
+			if(currDelimiter % 2) // Enclosed in {} text - set to yellow or defined color
 			{
 				std::smatch match;
    				std::regex expr("^(.*?)\\|");
@@ -249,7 +261,7 @@
 
 			where.x += (int)f->getStringWidth(toPrint);
 		}
-		currDelimeter++;
+		currDelimiter++;
 	} while(begin++ != std::string::npos);
 }
 
@@ -264,7 +276,7 @@
 {
 	CIntObject::showAll(to);
 
-	const auto f = graphics->fonts[font];
+	const auto & fontPtr = GH.renderHandler().loadFont(font);
 
 	// calculate which lines should be visible
 	int totalLines = static_cast<int>(lines.size());
@@ -274,17 +286,17 @@
 	if(beginLine < 0)
 		beginLine = 0;
 	else
-		beginLine /= (int)f->getLineHeight();
+		beginLine /= fontPtr->getLineHeight();
 
 	if(endLine < 0)
 		endLine = 0;
 	else
-		endLine /= (int)f->getLineHeight();
+		endLine /= fontPtr->getLineHeight();
 	endLine++;
 
 	// and where they should be displayed
-	Point lineStart = getTextLocation().topLeft() - visibleSize + Point(0, beginLine * (int)f->getLineHeight());
-	Point lineSize = Point(getTextLocation().w, (int)f->getLineHeight());
+	Point lineStart = getTextLocation().topLeft() - visibleSize + Point(0, beginLine * fontPtr->getLineHeight());
+	Point lineSize = Point(getTextLocation().w, fontPtr->getLineHeight());
 
 	CSDL_Ext::CClipRectGuard guard(to.getInternalSurface(), getTextLocation()); // to properly trim text that is too big to fit
 
@@ -293,7 +305,7 @@
 		if(!lines[i].empty()) //non-empty line
 			blitLine(to, Rect(lineStart, lineSize), lines[i]);
 
-		lineStart.y += (int)f->getLineHeight();
+		lineStart.y += fontPtr->getLineHeight();
 	}
 }
 
@@ -301,15 +313,15 @@
 {
 	lines.clear();
 
-	const auto f = graphics->fonts[font];
-	int lineHeight = static_cast<int>(f->getLineHeight());
+	const auto & fontPtr = GH.renderHandler().loadFont(font);
+	int lineHeight = fontPtr->getLineHeight();
 
 	lines = CMessage::breakText(Txt, pos.w, font);
 
 	textSize.y = lineHeight * (int)lines.size();
 	textSize.x = 0;
 	for(const std::string & line : lines)
-		vstd::amax(textSize.x, f->getStringWidth(line.c_str()));
+		vstd::amax(textSize.x, fontPtr->getStringWidth(line.c_str()));
 	if(redrawAfter)
 		redraw();
 }
@@ -322,15 +334,17 @@
 	if(pos.h <= textSize.y)
 		return pos;
 
-	Point textSize(pos.w, (int)graphics->fonts[font]->getLineHeight() * (int)lines.size());
-	Point textOffset(pos.w - textSize.x, pos.h - textSize.y);
+	const auto & fontPtr = GH.renderHandler().loadFont(font);
+	Point textSizeComputed(pos.w, fontPtr->getLineHeight() * lines.size()); //FIXME: how is this different from textSize member?
+	Point textOffset(pos.w - textSizeComputed.x, pos.h - textSizeComputed.y);
 
 	switch(alignment)
 	{
-	case ETextAlignment::TOPLEFT:     return Rect(pos.topLeft(), textSize);
-	case ETextAlignment::TOPCENTER:   return Rect(pos.topLeft(), textSize);
-	case ETextAlignment::CENTER:      return Rect(pos.topLeft() + textOffset / 2, textSize);
-	case ETextAlignment::BOTTOMRIGHT: return Rect(pos.topLeft() + textOffset, textSize);
+	case ETextAlignment::TOPLEFT:     return Rect(pos.topLeft(), textSizeComputed);
+	case ETextAlignment::TOPCENTER:   return Rect(pos.topLeft(), textSizeComputed);
+	case ETextAlignment::CENTER:      return Rect(pos.topLeft() + textOffset / 2, textSizeComputed);
+	case ETextAlignment::CENTERRIGHT: return Rect(pos.topLeft() + Point(textOffset.x, textOffset.y / 2), textSizeComputed);
+	case ETextAlignment::BOTTOMRIGHT: return Rect(pos.topLeft() + textOffset, textSizeComputed);
 	}
 	assert(0);
 	return Rect();
@@ -339,12 +353,11 @@
 CLabelGroup::CLabelGroup(EFonts Font, ETextAlignment Align, const ColorRGBA & Color)
 	: font(Font), align(Align), color(Color)
 {
-	defActions = 255 - DISPOSE;
 }
 
 void CLabelGroup::add(int x, int y, const std::string & text)
 {
-	OBJECT_CONSTRUCTION_CUSTOM_CAPTURING(255 - DISPOSE);
+	OBJECT_CONSTRUCTION;
 	labels.push_back(std::make_shared<CLabel>(x, y, font, align, color, text));
 }
 
@@ -357,7 +370,7 @@
 	sliderStyle(SliderStyle),
 	slider(nullptr)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255 - DISPOSE);
+	OBJECT_CONSTRUCTION;
 	label = std::make_shared<CMultiLineLabel>(rect, Font, Align, Color);
 
 	setRedrawParent(true);
@@ -421,11 +434,12 @@
 		label->pos.w = pos.w - 16;
 		assert(label->pos.w > 0);
 		label->setText(text);
+		const auto & fontPtr = GH.renderHandler().loadFont(label->font);
 
-		OBJECT_CONSTRUCTION_CUSTOM_CAPTURING(255 - DISPOSE);
+		OBJECT_CONSTRUCTION;
 		slider = std::make_shared<CSlider>(Point(pos.w - 16, 0), pos.h, std::bind(&CTextBox::sliderMoved, this, _1),
 			label->pos.h, label->textSize.y, 0, Orientation::VERTICAL, CSlider::EStyle(sliderStyle));
-		slider->setScrollStep((int)graphics->fonts[label->font]->getLineHeight());
+		slider->setScrollStep(fontPtr->getLineHeight());
 		slider->setPanningStep(1);
 		slider->setScrollBounds(pos - slider->pos.topLeft());
 	}
@@ -505,7 +519,7 @@
 {
 	addUsedEvents(LCLICK);
 
-	OBJECT_CONSTRUCTION_CAPTURING(255 - DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	auto backgroundImage = std::make_shared<CPicture>(name);
 	background = backgroundImage;
@@ -544,7 +558,6 @@
 
 void CGStatusBar::deactivate()
 {
-	assert(GH.statusbar().get() == this);
 	GH.setStatusbar(nullptr);
 
 	if (enteringText)
diff --color -urN vcmi-1.5.7/client/widgets/TextControls.h vcmi/client/widgets/TextControls.h
--- vcmi-1.5.7/client/widgets/TextControls.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/widgets/TextControls.h	2024-12-19 15:00:22.350125291 +0100
@@ -96,6 +96,7 @@
 	CMultiLineLabel(Rect position, EFonts Font = FONT_SMALL, ETextAlignment Align = ETextAlignment::TOPLEFT, const ColorRGBA & Color = Colors::WHITE, const std::string & Text = "");
 
 	void setText(const std::string & Txt) override;
+	std::vector<std::string> getLines();
 	void showAll(Canvas & to) override;
 
 	void setVisibleSize(Rect visibleSize, bool redrawElement = true);
diff --color -urN vcmi-1.5.7/client/widgets/VideoWidget.cpp vcmi/client/widgets/VideoWidget.cpp
--- vcmi-1.5.7/client/widgets/VideoWidget.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/client/widgets/VideoWidget.cpp	2024-12-19 15:00:22.350125291 +0100
@@ -0,0 +1,221 @@
+/*
+ * TextControls.cpp, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#include "StdInc.h"
+#include "VideoWidget.h"
+#include "TextControls.h"
+#include "IVideoHolder.h"
+
+#include "../CGameInfo.h"
+#include "../gui/CGuiHandler.h"
+#include "../media/ISoundPlayer.h"
+#include "../media/IVideoPlayer.h"
+#include "../render/Canvas.h"
+#include "../render/IScreenHandler.h"
+
+#include "../../lib/filesystem/Filesystem.h"
+
+VideoWidgetBase::VideoWidgetBase(const Point & position, const VideoPath & video, bool playAudio)
+	: VideoWidgetBase(position, video, playAudio, 1.0)
+{
+}
+
+VideoWidgetBase::VideoWidgetBase(const Point & position, const VideoPath & video, bool playAudio, float scaleFactor)
+	: playAudio(playAudio), scaleFactor(scaleFactor)
+{
+	addUsedEvents(TIME);
+	pos += position;
+	playVideo(video);
+}
+
+VideoWidgetBase::~VideoWidgetBase() = default;
+
+void VideoWidgetBase::playVideo(const VideoPath & fileToPlay)
+{
+	OBJECT_CONSTRUCTION;
+
+	JsonPath subTitlePath = fileToPlay.toType<EResType::JSON>();
+	JsonPath subTitlePathVideoDir = subTitlePath.addPrefix("VIDEO/");
+	if(CResourceHandler::get()->existsResource(subTitlePath))
+		subTitleData = JsonNode(subTitlePath);
+	else if(CResourceHandler::get()->existsResource(subTitlePathVideoDir))
+		subTitleData = JsonNode(subTitlePathVideoDir);
+
+	float preScaleFactor = 1;
+	VideoPath videoFile = fileToPlay;
+	if(GH.screenHandler().getScalingFactor() > 1)
+	{
+		std::vector<int> factorsToCheck = {GH.screenHandler().getScalingFactor(), 4, 3, 2};
+		for(auto factorToCheck : factorsToCheck)
+		{
+			std::string name = boost::algorithm::to_upper_copy(videoFile.getName());
+			boost::replace_all(name, "VIDEO/", std::string("VIDEO") + std::to_string(factorToCheck) + std::string("X/"));
+			auto p = VideoPath::builtin(name).addPrefix("VIDEO" + std::to_string(factorToCheck) + "X/");
+			if(CResourceHandler::get()->existsResource(p))
+			{
+				preScaleFactor = 1.0 / static_cast<float>(factorToCheck);
+				videoFile = p;
+				break;
+			}
+		}
+	}
+
+	videoInstance = CCS->videoh->open(videoFile, scaleFactor * preScaleFactor);
+	if (videoInstance)
+	{
+		pos.w = videoInstance->size().x;
+		pos.h = videoInstance->size().y;
+		if(!subTitleData.isNull())
+			subTitle = std::make_unique<CMultiLineLabel>(Rect(0, (pos.h / 5) * 4, pos.w, pos.h / 5), EFonts::FONT_HIGH_SCORE, ETextAlignment::CENTER, Colors::WHITE);
+	}
+
+	if (playAudio)
+	{
+		loadAudio(fileToPlay);
+		if (isActive())
+			startAudio();
+	}
+}
+
+void VideoWidgetBase::show(Canvas & to)
+{
+	if(videoInstance)
+		videoInstance->show(pos.topLeft(), to);
+	if(subTitle)
+		subTitle->showAll(to);
+}
+
+void VideoWidgetBase::loadAudio(const VideoPath & fileToPlay)
+{
+	if (!playAudio)
+		return;
+
+	audioData = CCS->videoh->getAudio(fileToPlay);
+}
+
+void VideoWidgetBase::startAudio()
+{
+	if(audioData.first == nullptr)
+		return;
+
+	audioHandle = CCS->soundh->playSound(audioData);
+
+	if(audioHandle != -1)
+	{
+		CCS->soundh->setCallback(
+			audioHandle,
+			[this]()
+			{
+				this->audioHandle = -1;
+			}
+		);
+	}
+}
+
+void VideoWidgetBase::stopAudio()
+{
+	if(audioHandle != -1)
+	{
+		CCS->soundh->resetCallback(audioHandle);
+		CCS->soundh->stopSound(audioHandle);
+		audioHandle = -1;
+	}
+}
+
+std::string VideoWidgetBase::getSubTitleLine(double timestamp)
+{
+	if(subTitleData.isNull())
+		return {};
+
+	for(auto & segment : subTitleData.Vector())
+		if(timestamp > segment["timeStart"].Float() && timestamp < segment["timeEnd"].Float())
+			return segment["text"].String();
+	
+	return {};
+}
+
+void VideoWidgetBase::activate()
+{
+	CIntObject::activate();
+	if(audioHandle != -1)
+		CCS->soundh->resumeSound(audioHandle);
+	else
+		startAudio();
+	if(videoInstance)
+		videoInstance->activate();
+}
+
+void VideoWidgetBase::deactivate()
+{
+	CIntObject::deactivate();
+	CCS->soundh->pauseSound(audioHandle);
+	if(videoInstance)
+		videoInstance->deactivate();
+}
+
+void VideoWidgetBase::showAll(Canvas & to)
+{
+	if(videoInstance)
+		videoInstance->show(pos.topLeft(), to);
+	if(subTitle)
+		subTitle->showAll(to);
+}
+
+void VideoWidgetBase::tick(uint32_t msPassed)
+{
+	if(videoInstance)
+	{
+		videoInstance->tick(msPassed);
+
+		if(subTitle)
+			subTitle->setText(getSubTitleLine(videoInstance->timeStamp()));
+
+		if(videoInstance->videoEnded())
+		{
+			videoInstance.reset();
+			stopAudio();
+			onPlaybackFinished();
+			// WARNING: onPlaybackFinished call may destoy `this`. Make sure that this is the very last operation in this method!
+		}
+	}
+}
+
+VideoWidget::VideoWidget(const Point & position, const VideoPath & prologue, const VideoPath & looped, bool playAudio)
+	: VideoWidgetBase(position, prologue, playAudio)
+	, loopedVideo(looped)
+{
+}
+
+VideoWidget::VideoWidget(const Point & position, const VideoPath & looped, bool playAudio)
+	: VideoWidgetBase(position, looped, playAudio)
+	, loopedVideo(looped)
+{
+}
+
+void VideoWidget::onPlaybackFinished()
+{
+	playVideo(loopedVideo);
+}
+
+VideoWidgetOnce::VideoWidgetOnce(const Point & position, const VideoPath & video, bool playAudio, IVideoHolder * owner)
+	: VideoWidgetBase(position, video, playAudio)
+	, owner(owner)
+{
+}
+
+VideoWidgetOnce::VideoWidgetOnce(const Point & position, const VideoPath & video, bool playAudio, float scaleFactor, IVideoHolder * owner)
+	: VideoWidgetBase(position, video, playAudio, scaleFactor)
+	, owner(owner)
+{
+}
+
+void VideoWidgetOnce::onPlaybackFinished()
+{
+	owner->onVideoPlaybackFinished();
+}
diff --color -urN vcmi-1.5.7/client/widgets/VideoWidget.h vcmi/client/widgets/VideoWidget.h
--- vcmi-1.5.7/client/widgets/VideoWidget.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/client/widgets/VideoWidget.h	2024-12-19 15:00:22.351125332 +0100
@@ -0,0 +1,74 @@
+/*
+ * VideoWidget.h, part of VCMI engine
+ *
+ * Authors: listed in file AUTHORS in main folder
+ *
+ * License: GNU General Public License v2.0 or later
+ * Full text of license available in license.txt file, in main folder
+ *
+ */
+#pragma once
+
+#include "../gui/CIntObject.h"
+
+#include "../lib/filesystem/ResourcePath.h"
+#include "../lib/json/JsonNode.h"
+
+class IVideoHolder;
+class IVideoInstance;
+class CMultiLineLabel;
+
+class VideoWidgetBase : public CIntObject
+{
+	std::unique_ptr<IVideoInstance> videoInstance;
+	std::unique_ptr<CMultiLineLabel> subTitle;
+
+	std::pair<std::unique_ptr<ui8[]>, si64> audioData = {nullptr, 0};
+	int audioHandle = -1;
+	bool playAudio = false;
+	float scaleFactor = 1.0;
+	JsonNode subTitleData;
+
+	void loadAudio(const VideoPath & file);
+	void startAudio();
+	void stopAudio();
+	std::string getSubTitleLine(double timestamp);
+
+protected:
+	VideoWidgetBase(const Point & position, const VideoPath & video, bool playAudio);
+	VideoWidgetBase(const Point & position, const VideoPath & video, bool playAudio, float scaleFactor);
+
+	virtual void onPlaybackFinished() = 0;
+	void playVideo(const VideoPath & video);
+
+public:
+	~VideoWidgetBase();
+
+	void activate() override;
+	void deactivate() override;
+	void show(Canvas & to) override;
+	void showAll(Canvas & to) override;
+	void tick(uint32_t msPassed) override;
+
+	void setPlaybackFinishedCallback(std::function<void()>);
+};
+
+class VideoWidget final: public VideoWidgetBase
+{
+	VideoPath loopedVideo;
+
+	void onPlaybackFinished() final;
+public:
+	VideoWidget(const Point & position, const VideoPath & prologue, const VideoPath & looped, bool playAudio);
+	VideoWidget(const Point & position, const VideoPath & looped, bool playAudio);
+};
+
+class VideoWidgetOnce final: public VideoWidgetBase
+{
+	IVideoHolder * owner;
+
+	void onPlaybackFinished() final;
+public:
+	VideoWidgetOnce(const Point & position, const VideoPath & video, bool playAudio, IVideoHolder * owner);
+	VideoWidgetOnce(const Point & position, const VideoPath & video, bool playAudio, float scaleFactor, IVideoHolder * owner);
+};
diff --color -urN vcmi-1.5.7/client/windows/CCastleInterface.cpp vcmi/client/windows/CCastleInterface.cpp
--- vcmi-1.5.7/client/windows/CCastleInterface.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/windows/CCastleInterface.cpp	2024-12-19 15:00:22.365125911 +0100
@@ -18,12 +18,12 @@
 #include "CCreatureWindow.h"
 
 #include "../CGameInfo.h"
-#include "../CMusicHandler.h"
 #include "../CPlayerInterface.h"
 #include "../PlayerLocalState.h"
 #include "../gui/CGuiHandler.h"
 #include "../gui/Shortcut.h"
 #include "../gui/WindowHandler.h"
+#include "../media/IMusicPlayer.h"
 #include "../widgets/MiscWidgets.h"
 #include "../widgets/CComponent.h"
 #include "../widgets/CGarrisonInt.h"
@@ -42,17 +42,19 @@
 
 #include "../../CCallback.h"
 #include "../../lib/CArtHandler.h"
-#include "../../lib/CBuildingHandler.h"
+#include "../../lib/CConfigHandler.h"
+#include "../../lib/CSoundBase.h"
 #include "../../lib/CCreatureHandler.h"
-#include "../../lib/CGeneralTextHandler.h"
-#include "../../lib/GameSettings.h"
+#include "../../lib/texts/CGeneralTextHandler.h"
+#include "../../lib/IGameSettings.h"
 #include "../../lib/spells/CSpellHandler.h"
-#include "../../lib/CTownHandler.h"
 #include "../../lib/GameConstants.h"
 #include "../../lib/StartInfo.h"
 #include "../../lib/campaign/CampaignState.h"
+#include "../../lib/entities/building/CBuilding.h"
 #include "../../lib/mapObjects/CGHeroInstance.h"
 #include "../../lib/mapObjects/CGTownInstance.h"
+#include "../../lib/mapObjects/TownBuildingInstance.h"
 
 
 static bool useCompactCreatureBox()
@@ -80,7 +82,7 @@
 
 	// special animation frame manipulation for castle shipyard with and without ship
 	// done due to .def used in special way, not to animate building - first image is for shipyard without citadel moat, 2nd image is for including moat
-	if(Town->town->faction->getId() == FactionID::CASTLE && Str->building &&
+	if(Town->getFactionID() == FactionID::CASTLE && Str->building &&
 		(Str->building->bid == BuildingID::SHIPYARD || Str->building->bid == BuildingID::SHIP))
 	{
 		if(Town->hasBuilt(BuildingID::CITADEL))
@@ -93,10 +95,10 @@
 	}
 
 	if(!str->borderName.empty())
-		border = GH.renderHandler().loadImage(str->borderName, EImageBlitMode::ALPHA);
+		border = GH.renderHandler().loadImage(str->borderName, EImageBlitMode::COLORKEY);
 
 	if(!str->areaName.empty())
-		area = GH.renderHandler().loadImage(str->areaName, EImageBlitMode::ALPHA);
+		area = GH.renderHandler().loadImage(str->areaName, EImageBlitMode::SIMPLE);
 }
 
 const CBuilding * CBuildingRect::getBuilding()
@@ -105,7 +107,7 @@
 		return nullptr;
 
 	if (str->hiddenUpgrade) // hidden upgrades, e.g. hordes - return base (dwelling for hordes)
-		return town->town->buildings.at(str->building->getBase());
+		return town->getTown()->buildings.at(str->building->getBase());
 
 	return str->building;
 }
@@ -144,7 +146,7 @@
 	if(getBuilding() && area && (parent->selectedBuilding==this))
 	{
 		auto building = getBuilding();
-		parent->buildingClicked(building->bid, building->subId, building->upgrade);
+		parent->buildingClicked(building->bid);
 	}
 }
 
@@ -154,7 +156,7 @@
 		return;
 
 	BuildingID bid = getBuilding()->bid;
-	const CBuilding *bld = town->town->buildings.at(bid);
+	const CBuilding *bld = town->getTown()->buildings.at(bid);
 	if (bid < BuildingID::DWELL_FIRST)
 	{
 		CRClickPopup::createAndPush(CInfoWindow::genText(bld->getNameTranslated(), bld->getDescriptionTranslated()),
@@ -162,7 +164,7 @@
 	}
 	else
 	{
-		int level = ( bid - BuildingID::DWELL_FIRST ) % GameConstants::CREATURES_PER_TOWN;
+		int level = BuildingID::getLevelFromDwelling(bid);
 		GH.windows().createAndPushWindow<CDwellingInfoBox>(parent->pos.x+parent->pos.w / 2, parent->pos.y+parent->pos.h  /2, town, level);
 	}
 }
@@ -232,11 +234,12 @@
 
 	int bid = getBuilding()->bid;
 
-	if (bid<30)//non-dwellings - only buiding name
-		return town->town->buildings.at(getBuilding()->bid)->getNameTranslated();
+	if (bid<30)//non-dwellings - only building name
+		return town->getTown()->buildings.at(getBuilding()->bid)->getNameTranslated();
 	else//dwellings - recruit %creature%
 	{
-		auto & availableCreatures = town->creatures[(bid-30)%GameConstants::CREATURES_PER_TOWN].second;
+		int level = BuildingID::getLevelFromDwelling(getBuilding()->bid);
+		auto & availableCreatures = town->creatures[level].second;
 		if(availableCreatures.size())
 		{
 			int creaID = availableCreatures.back();//taking last of available creatures
@@ -269,10 +272,10 @@
 CDwellingInfoBox::CDwellingInfoBox(int centerX, int centerY, const CGTownInstance * Town, int level)
 	: CWindowObject(RCLICK_POPUP, ImagePath::builtin("CRTOINFO"), Point(centerX, centerY))
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
-	background->colorize(Town->tempOwner);
+	OBJECT_CONSTRUCTION;
+	background->setPlayerColor(Town->tempOwner);
 
-	const CCreature * creature = CGI->creh->objects.at(Town->creatures.at(level).second.back());
+	const CCreature * creature = Town->creatures.at(level).second.back().toCreature();
 
 	title = std::make_shared<CLabel>(80, 30, FONT_SMALL, ETextAlignment::CENTER, Colors::WHITE, creature->getNamePluralTranslated());
 	animation = std::make_shared<CCreaturePic>(30, 44, creature, true, true);
@@ -305,7 +308,7 @@
 
 CHeroGSlot::CHeroGSlot(int x, int y, int updown, const CGHeroInstance * h, HeroSlots * Owner)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	owner = Owner;
 	pos.x += x;
@@ -453,7 +456,7 @@
 {
 	if(hero)
 	{
-		GH.windows().createAndPushWindow<CInfoBoxPopup>(Point(pos.x + 175, pos.y + 100), hero);
+		GH.windows().createAndPushWindow<CInfoBoxPopup>(pos.center(), hero);
 	}
 }
 
@@ -474,14 +477,14 @@
 
 	if(owner->garrisonedHero->hero && owner->visitingHero->hero) //two heroes in town
 	{
-		for(auto & elem : owner->garr->splitButtons) //splitting enabled when slot higlighted
+		for(auto & elem : owner->garr->splitButtons) //splitting enabled when slot highlighted
 			elem->block(!on);
 	}
 }
 
 void CHeroGSlot::set(const CGHeroInstance * newHero)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	hero = newHero;
 
@@ -506,7 +509,7 @@
 	town(Town),
 	garr(Garrison)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	garrisonedHero = std::make_shared<CHeroGSlot>(garrPos.x, garrPos.y, 0, town->garrisonHero, this);
 	visitingHero = std::make_shared<CHeroGSlot>(visitPos.x, visitPos.y, 1, town->visitingHero, this);
 }
@@ -526,7 +529,7 @@
 	//moving hero out of town - check if it is allowed
 	if (town->garrisonHero)
 	{
-		if (!town->visitingHero && LOCPLINT->cb->howManyHeroes(false) >= CGI->settings()->getInteger(EGameSettings::HEROES_PER_PLAYER_ON_MAP_CAP))
+		if (!town->visitingHero && LOCPLINT->cb->howManyHeroes(false) >= LOCPLINT->cb->getSettings().getInteger(EGameSettings::HEROES_PER_PLAYER_ON_MAP_CAP))
 		{
 			std::string text = CGI->generaltexth->translate("core.genrltxt.18"); //You already have %d adventuring heroes under your command.
 			boost::algorithm::replace_first(text,"%d",std::to_string(LOCPLINT->cb->howManyHeroes(false)));
@@ -562,9 +565,9 @@
 	town(Town),
 	selectedBuilding(nullptr)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 
-	background = std::make_shared<CPicture>(town->town->clientInfo.townBackground);
+	background = std::make_shared<CPicture>(town->getTown()->clientInfo.townBackground);
 	background->needRefresh = true;
 	background->getSurface()->setBlitMode(EImageBlitMode::OPAQUE);
 	pos.w = background->pos.w;
@@ -578,16 +581,16 @@
 void CCastleBuildings::recreate()
 {
 	selectedBuilding = nullptr;
-	OBJECT_CONSTRUCTION_CUSTOM_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	buildings.clear();
 	groups.clear();
 
 	//Generate buildings list
 
-	auto buildingsCopy = town->builtBuildings;// a bit modified copy of built buildings
+	auto buildingsCopy = town->getBuildings();// a bit modified copy of built buildings
 
-	if(vstd::contains(town->builtBuildings, BuildingID::SHIPYARD))
+	if(town->hasBuilt(BuildingID::SHIPYARD))
 	{
 		auto bayPos = town->bestLocation();
 		if(!bayPos.valid())
@@ -600,7 +603,7 @@
 		}
 	}
 
-	for(const CStructure * structure : town->town->clientInfo.structures)
+	for(const CStructure * structure : town->getTown()->clientInfo.structures)
 	{
 		if(!structure->building)
 		{
@@ -615,7 +618,7 @@
 
 	for(auto & entry : groups)
 	{
-		const CBuilding * build = town->town->buildings.at(entry.first);
+		const CBuilding * build = town->getTown()->buildings.at(entry.first);
 
 		const CStructure * toAdd = *boost::max_element(entry.second, [=](const CStructure * a, const CStructure * b)
 		{
@@ -646,7 +649,7 @@
 void CCastleBuildings::addBuilding(BuildingID building)
 {
 	//FIXME: implement faster method without complete recreation of town
-	BuildingID base = town->town->buildings.at(building)->getBase();
+	BuildingID base = town->getTown()->buildings.at(building)->getBase();
 
 	recreate();
 
@@ -680,18 +683,82 @@
 		return town->garrisonHero;
 }
 
-void CCastleBuildings::buildingClicked(BuildingID building, BuildingSubID::EBuildingSubID subID, BuildingID upgrades)
+void CCastleBuildings::buildingClicked(BuildingID building)
 {
-	logGlobal->trace("You've clicked on %d", (int)building.toEnum());
-	const CBuilding *b = town->town->buildings.find(building)->second;
+	BuildingID buildingToEnter = building;
+	for(;;)
+	{
+		const CBuilding *b = town->getTown()->buildings.find(buildingToEnter)->second;
+
+		if (buildingTryActivateCustomUI(buildingToEnter, building))
+			return;
+
+		if (!b->upgrade.hasValue())
+		{
+			enterBuilding(building);
+			return;
+		}
+
+		buildingToEnter = b->upgrade;
+	}
+}
+
+bool CCastleBuildings::buildingTryActivateCustomUI(BuildingID buildingToTest, BuildingID buildingTarget)
+{
+	logGlobal->trace("You've clicked on %d", (int)buildingToTest.toEnum());
+	const CBuilding *b = town->getTown()->buildings.at(buildingToTest);
+
+	if (town->getWarMachineInBuilding(buildingToTest).hasValue())
+	{
+		enterBlacksmith(buildingTarget, town->getWarMachineInBuilding(buildingToTest));
+		return true;
+	}
+
+	if (!b->marketModes.empty())
+	{
+		switch (*b->marketModes.begin())
+		{
+			case EMarketMode::CREATURE_UNDEAD:
+				GH.windows().createAndPushWindow<CTransformerWindow>(town, getHero(), nullptr);
+				return true;
 
-	if (building >= BuildingID::DWELL_FIRST)
+			case EMarketMode::RESOURCE_SKILL:
+				if (getHero())
+					GH.windows().createAndPushWindow<CUniversityWindow>(getHero(), buildingTarget, town, nullptr);
+				return true;
+
+			case EMarketMode::RESOURCE_RESOURCE:
+				// can't use allied marketplace
+				if (town->getOwner() == LOCPLINT->playerID)
+				{
+					GH.windows().createAndPushWindow<CMarketWindow>(town, getHero(), nullptr, *b->marketModes.begin());
+					return true;
+				}
+				else
+					return false;
+			default:
+				if(getHero())
+					GH.windows().createAndPushWindow<CMarketWindow>(town, getHero(), nullptr, *b->marketModes.begin());
+				else
+					LOCPLINT->showInfoDialog(boost::str(boost::format(CGI->generaltexth->allTexts[273]) % b->getNameTranslated())); //Only visiting heroes may use the %s.
+				return true;
+		}
+	}
+
+	if (town->rewardableBuildings.count(buildingToTest) && town->getTown()->buildings.at(buildingToTest)->manualHeroVisit)
 	{
-		enterDwelling((building-BuildingID::DWELL_FIRST)%GameConstants::CREATURES_PER_TOWN);
+		enterRewardable(buildingToTest);
+		return true;
+	}
+
+	if (buildingToTest >= BuildingID::DWELL_FIRST)
+	{
+		enterDwelling((BuildingID::getLevelFromDwelling(buildingToTest)));
+		return true;
 	}
 	else
 	{
-		switch(building)
+		switch(buildingToTest)
 		{
 		case BuildingID::MAGES_GUILD_1:
 		case BuildingID::MAGES_GUILD_2:
@@ -699,139 +766,110 @@
 		case BuildingID::MAGES_GUILD_4:
 		case BuildingID::MAGES_GUILD_5:
 				enterMagesGuild();
-				break;
+				return true;
 
 		case BuildingID::TAVERN:
 				LOCPLINT->showTavernWindow(town, nullptr, QueryID::NONE);
-				break;
+				return true;
 
 		case BuildingID::SHIPYARD:
 				if(town->shipyardStatus() == IBoatGenerator::GOOD)
+				{
 					LOCPLINT->showShipyardDialog(town);
+					return true;
+				}
 				else if(town->shipyardStatus() == IBoatGenerator::BOAT_ALREADY_BUILT)
+				{
 					LOCPLINT->showInfoDialog(CGI->generaltexth->allTexts[51]);
-				break;
+					return true;
+				}
+				return false;
 
 		case BuildingID::FORT:
 		case BuildingID::CITADEL:
 		case BuildingID::CASTLE:
 				GH.windows().createAndPushWindow<CFortScreen>(town);
-				break;
+				return true;
 
 		case BuildingID::VILLAGE_HALL:
 		case BuildingID::CITY_HALL:
 		case BuildingID::TOWN_HALL:
 		case BuildingID::CAPITOL:
 				enterTownHall();
-				break;
-
-		case BuildingID::MARKETPLACE:
-				// can't use allied marketplace
-				if (town->getOwner() == LOCPLINT->playerID)
-					GH.windows().createAndPushWindow<CMarketWindow>(town, town->visitingHero, nullptr, EMarketMode::RESOURCE_RESOURCE);
-				else
-					enterBuilding(building);
-				break;
-
-		case BuildingID::BLACKSMITH:
-				enterBlacksmith(town->town->warMachine);
-				break;
+				return true;
 
 		case BuildingID::SHIP:
 			LOCPLINT->showInfoDialog(CGI->generaltexth->allTexts[51]); //Cannot build another boat
-			break;
+			return true;
 
 		case BuildingID::SPECIAL_1:
 		case BuildingID::SPECIAL_2:
 		case BuildingID::SPECIAL_3:
 		case BuildingID::SPECIAL_4:
-				switch (subID)
+				switch (b->subId)
 				{
-				case BuildingSubID::NONE:
-						enterBuilding(building);
-						break;
-
 				case BuildingSubID::MYSTIC_POND:
-						enterFountain(building, subID, upgrades);
-						break;
-
-				case BuildingSubID::ARTIFACT_MERCHANT:
-						if(town->visitingHero)
-							GH.windows().createAndPushWindow<CMarketWindow>(town, town->visitingHero, nullptr, EMarketMode::RESOURCE_ARTIFACT);
-						else
-							LOCPLINT->showInfoDialog(boost::str(boost::format(CGI->generaltexth->allTexts[273]) % b->getNameTranslated())); //Only visiting heroes may use the %s.
-						break;
-
-				case BuildingSubID::FOUNTAIN_OF_FORTUNE:
-						enterFountain(building, subID, upgrades);
-					break;
-
-				case BuildingSubID::FREELANCERS_GUILD:
-						if(getHero())
-							GH.windows().createAndPushWindow<CMarketWindow>(town, getHero(), nullptr, EMarketMode::CREATURE_RESOURCE);
-						else
-							LOCPLINT->showInfoDialog(boost::str(boost::format(CGI->generaltexth->allTexts[273]) % b->getNameTranslated())); //Only visiting heroes may use the %s.
-						break;
-
-				case BuildingSubID::MAGIC_UNIVERSITY:
-						if (getHero())
-							GH.windows().createAndPushWindow<CUniversityWindow>(getHero(), town, nullptr);
-						else
-							enterBuilding(building);
-						break;
-
-				case BuildingSubID::BROTHERHOOD_OF_SWORD:
-						if(upgrades == BuildingID::TAVERN)
-							LOCPLINT->showTavernWindow(town, nullptr, QueryID::NONE);
-						else
-							enterBuilding(building);
-						break;
+						enterFountain(buildingToTest, b->subId, buildingTarget);
+						return true;
 
 				case BuildingSubID::CASTLE_GATE:
 						if (LOCPLINT->makingTurn)
+						{
 							enterCastleGate();
-						else
-							enterBuilding(building);
-						break;
-
-				case BuildingSubID::CREATURE_TRANSFORMER: //Skeleton Transformer
-						GH.windows().createAndPushWindow<CTransformerWindow>(town, getHero(), nullptr);
-						break;
+							return true;
+						}
+						return false;
 
 				case BuildingSubID::PORTAL_OF_SUMMONING:
-						if (town->creatures[GameConstants::CREATURES_PER_TOWN].second.empty())//No creatures
+						if (town->creatures[town->getTown()->creatures.size()].second.empty())//No creatures
 							LOCPLINT->showInfoDialog(CGI->generaltexth->tcommands[30]);
 						else
-							enterDwelling(GameConstants::CREATURES_PER_TOWN);
-						break;
-
-				case BuildingSubID::BALLISTA_YARD:
-						enterBlacksmith(ArtifactID::BALLISTA);
-						break;
+							enterDwelling(town->getTown()->creatures.size());
+						return true;
 
-				case BuildingSubID::THIEVES_GUILD:
-						enterAnyThievesGuild();
-						break;
-
-				default:
-						enterBuilding(building);
-						break;
+				case BuildingSubID::BANK:
+						enterBank(buildingTarget);
+						return true;
 				}
-				break;
+		}
+	}
 
-		default:
-				enterBuilding(building);
-				break;
+	for (auto const & bonus : b->buildingBonuses)
+	{
+		if (bonus->type == BonusType::THIEVES_GUILD_ACCESS)
+		{
+			enterAnyThievesGuild();
+			return true;
 		}
 	}
+	return false;
+}
+
+void CCastleBuildings::enterRewardable(BuildingID building)
+{
+	if (town->visitingHero == nullptr)
+	{
+		MetaString message;
+		message.appendTextID("core.genrltxt.273"); // only visiting heroes may visit %s
+		message.replaceTextID(town->getTown()->buildings.at(building)->getNameTextID());
+
+		LOCPLINT->showInfoDialog(message.toString());
+	}
+	else
+	{
+		if (town->rewardableBuildings.at(building)->wasVisited(town->visitingHero))
+			enterBuilding(building);
+		else
+			LOCPLINT->cb->visitTownBuilding(town, building);
+	}
 }
 
-void CCastleBuildings::enterBlacksmith(ArtifactID artifactID)
+void CCastleBuildings::enterBlacksmith(BuildingID building, ArtifactID artifactID)
 {
 	const CGHeroInstance *hero = town->visitingHero;
 	if(!hero)
 	{
-		LOCPLINT->showInfoDialog(boost::str(boost::format(CGI->generaltexth->allTexts[273]) % town->town->buildings.find(BuildingID::BLACKSMITH)->second->getNameTranslated()));
+		LOCPLINT->showInfoDialog(boost::str(boost::format(CGI->generaltexth->allTexts[273]) % town->getTown()->buildings.find(building)->second->getNameTranslated()));
 		return;
 	}
 	auto art = artifactID.toArtifact();
@@ -842,7 +880,7 @@
 	{
 		for(auto slot : art->getPossibleSlots().at(ArtBearer::HERO))
 		{
-			if(hero->getArt(slot) == nullptr)
+			if(hero->getArt(slot) == nullptr || hero->getArt(slot)->getTypeId() != artifactID)
 			{
 				possible = true;
 				break;
@@ -853,14 +891,15 @@
 			}
 		}
 	}
-	CreatureID cre = art->getWarMachine();
-	GH.windows().createAndPushWindow<CBlacksmithDialog>(possible, cre, artifactID, hero->id);
+
+	CreatureID creatureID = artifactID.toArtifact()->getWarMachine();
+	GH.windows().createAndPushWindow<CBlacksmithDialog>(possible, creatureID, artifactID, hero->id);
 }
 
 void CCastleBuildings::enterBuilding(BuildingID building)
 {
-	std::vector<std::shared_ptr<CComponent>> comps(1, std::make_shared<CComponent>(ComponentType::BUILDING, BuildingTypeUniqueID(town->getFaction(), building)));
-	LOCPLINT->showInfoDialog( town->town->buildings.find(building)->second->getDescriptionTranslated(), comps);
+	std::vector<std::shared_ptr<CComponent>> comps(1, std::make_shared<CComponent>(ComponentType::BUILDING, BuildingTypeUniqueID(town->getFactionID(), building)));
+	LOCPLINT->showInfoDialog( town->getTown()->buildings.find(building)->second->getDescriptionTranslated(), comps);
 }
 
 void CCastleBuildings::enterCastleGate()
@@ -877,20 +916,20 @@
 	{
 		const CGTownInstance *t = Town;
 		if (t->id != this->town->id && t->visitingHero == nullptr && //another town, empty and this is
-			t->town->faction->getId() == town->town->faction->getId() && //the town of the same faction
+			t->getFactionID() == town->getFactionID() && //the town of the same faction
 			t->hasBuilt(BuildingSubID::CASTLE_GATE)) //and the town has a castle gate
 		{
 			availableTowns.push_back(t->id.getNum());//add to the list
 			if(settings["general"]["enableUiEnhancements"].Bool())
 			{
-				std::shared_ptr<CAnimation> a = GH.renderHandler().loadAnimation(AnimationPath::builtin("ITPA"));
-				a->preload();
-				images.push_back(a->getImage(t->town->clientInfo.icons[t->hasFort()][false] + 2)->scaleFast(Point(35, 23)));
+				auto image = GH.renderHandler().loadImage(AnimationPath::builtin("ITPA"), t->getTown()->clientInfo.icons[t->hasFort()][false] + 2, 0, EImageBlitMode::OPAQUE);
+				image->scaleTo(Point(35, 23));
+				images.push_back(image);
 			}
 		}
 	}
 
-	auto gateIcon = std::make_shared<CAnimImage>(town->town->clientInfo.buildingsIcons, BuildingID::CASTLE_GATE);//will be deleted by selection window
+	auto gateIcon = std::make_shared<CAnimImage>(town->getTown()->clientInfo.buildingsIcons, BuildingID::CASTLE_GATE);//will be deleted by selection window
 	auto wnd = std::make_shared<CObjectListWindow>(availableTowns, gateIcon, CGI->generaltexth->jktexts[40],
 		CGI->generaltexth->jktexts[41], std::bind (&CCastleInterface::castleTeleport, LOCPLINT->castleInt, _1), 0, images);
 	wnd->onPopup = [availableTowns](int index) { CRClickPopup::createAndPush(LOCPLINT->cb->getObjInstance(ObjectInstanceID(availableTowns[index])), GH.getCursorPosition()); };
@@ -902,7 +941,7 @@
 	if (level < 0 || level >= town->creatures.size() || town->creatures[level].second.empty())
 	{
 		assert(0);
-		logGlobal->error("Attempt to enter into invalid dwelling of level %d in town %s (%s)", level, town->getNameTranslated(), town->town->faction->getNameTranslated());
+		logGlobal->error("Attempt to enter into invalid dwelling of level %d in town %s (%s)", level, town->getNameTranslated(), town->getFaction()->getNameTranslated());
 		return;
 	}
 
@@ -916,8 +955,8 @@
 void CCastleBuildings::enterToTheQuickRecruitmentWindow()
 {
 	const auto beginIt = town->creatures.cbegin();
-	const auto afterLastIt = town->creatures.size() > GameConstants::CREATURES_PER_TOWN
-		? std::next(beginIt, GameConstants::CREATURES_PER_TOWN)
+	const auto afterLastIt = town->creatures.size() > town->getTown()->creatures.size()
+		? std::next(beginIt, town->getTown()->creatures.size())
 		: town->creatures.cend();
 	const auto hasSomeoneToRecruit = std::any_of(beginIt, afterLastIt,
 		[](const auto & creatureInfo) { return creatureInfo.first > 0; });
@@ -929,32 +968,20 @@
 
 void CCastleBuildings::enterFountain(const BuildingID & building, BuildingSubID::EBuildingSubID subID, BuildingID upgrades)
 {
-	std::vector<std::shared_ptr<CComponent>> comps(1, std::make_shared<CComponent>(ComponentType::BUILDING, BuildingTypeUniqueID(town->getFaction(), building)));
-	std::string descr = town->town->buildings.find(building)->second->getDescriptionTranslated();
+	std::vector<std::shared_ptr<CComponent>> comps(1, std::make_shared<CComponent>(ComponentType::BUILDING, BuildingTypeUniqueID(town->getFactionID(), building)));
+	std::string descr = town->getTown()->buildings.find(building)->second->getDescriptionTranslated();
 	std::string hasNotProduced;
 	std::string hasProduced;
 
-	if(this->town->town->faction->getIndex() == ETownType::RAMPART)
-	{
-		hasNotProduced = CGI->generaltexth->allTexts[677];
-		hasProduced = CGI->generaltexth->allTexts[678];
-	}
-	else
-	{
-		auto buildingName = town->town->getSpecialBuilding(subID)->getNameTranslated();
-
-		hasNotProduced = std::string(CGI->generaltexth->translate("vcmi.townHall.hasNotProduced"));
-		hasProduced = std::string(CGI->generaltexth->translate("vcmi.townHall.hasProduced"));
-		boost::algorithm::replace_first(hasNotProduced, "%s", buildingName);
-		boost::algorithm::replace_first(hasProduced, "%s", buildingName);
-	}
+	hasNotProduced = CGI->generaltexth->allTexts[677];
+	hasProduced = CGI->generaltexth->allTexts[678];
 
 	bool isMysticPondOrItsUpgrade = subID == BuildingSubID::MYSTIC_POND
 		|| (upgrades != BuildingID::NONE
-			&& town->town->buildings.find(BuildingID(upgrades))->second->subId == BuildingSubID::MYSTIC_POND);
+			&& town->getTown()->buildings.find(BuildingID(upgrades))->second->subId == BuildingSubID::MYSTIC_POND);
 
 	if(upgrades != BuildingID::NONE)
-		descr += "\n\n"+town->town->buildings.find(BuildingID(upgrades))->second->getDescriptionTranslated();
+		descr += "\n\n"+town->getTown()->buildings.find(BuildingID(upgrades))->second->getDescriptionTranslated();
 
 	if(isMysticPondOrItsUpgrade) //for vanila Rampart like towns
 	{
@@ -1007,7 +1034,7 @@
 void CCastleBuildings::enterTownHall()
 {
 	if(town->visitingHero && town->visitingHero->hasArt(ArtifactID::GRAIL) &&
-		!vstd::contains(town->builtBuildings, BuildingID::GRAIL)) //hero has grail, but town does not have it
+		!town->hasBuilt(BuildingID::GRAIL)) //hero has grail, but town does not have it
 	{
 		if(!vstd::contains(town->forbiddenBuildings, BuildingID::GRAIL))
 		{
@@ -1030,7 +1057,7 @@
 
 void CCastleBuildings::openMagesGuild()
 {
-	auto mageGuildBackground = LOCPLINT->castleInt->town->town->clientInfo.guildBackground;
+	auto mageGuildBackground = LOCPLINT->castleInt->town->getTown()->clientInfo.guildBackground;
 	GH.windows().createAndPushWindow<CMageGuildScreen>(LOCPLINT->castleInt, mageGuildBackground);
 }
 
@@ -1042,20 +1069,35 @@
 void CCastleBuildings::enterAnyThievesGuild()
 {
 	std::vector<const CGTownInstance*> towns = LOCPLINT->cb->getTownsInfo(true);
-	for(auto & town : towns)
+	for(auto & ownedTown : towns)
 	{
-		if(town->builtBuildings.count(BuildingID::TAVERN))
+		if(ownedTown->hasBuilt(BuildingID::TAVERN))
 		{
-			LOCPLINT->showThievesGuildWindow(town);
+			LOCPLINT->showThievesGuildWindow(ownedTown);
 			return;
 		}
 	}
 	LOCPLINT->showInfoDialog(CGI->generaltexth->translate("vcmi.adventureMap.noTownWithTavern"));
 }
 
+void CCastleBuildings::enterBank(BuildingID building)
+{
+	std::vector<std::shared_ptr<CComponent>> components;
+	if(town->bonusValue.second > 0)
+	{
+		components.push_back(std::make_shared<CComponent>(ComponentType::RESOURCE_PER_DAY, GameResID(GameResID::GOLD), -500));
+		LOCPLINT->showInfoDialog(CGI->generaltexth->translate("vcmi.townStructure.bank.payBack"), components);
+	}
+	else{
+	
+		components.push_back(std::make_shared<CComponent>(ComponentType::RESOURCE, GameResID(GameResID::GOLD), 2500));
+		LOCPLINT->showYesNoDialog(CGI->generaltexth->translate("vcmi.townStructure.bank.borrow"), [this, building](){ LOCPLINT->cb->visitTownBuilding(town, building); }, nullptr, components);
+	}
+}
+
 void CCastleBuildings::enterAnyMarket()
 {
-	if(town->builtBuildings.count(BuildingID::MARKETPLACE))
+	if(town->hasBuilt(BuildingID::MARKETPLACE))
 	{
 		GH.windows().createAndPushWindow<CMarketWindow>(town, nullptr, nullptr, EMarketMode::RESOURCE_RESOURCE);
 		return;
@@ -1064,7 +1106,7 @@
 	std::vector<const CGTownInstance*> towns = LOCPLINT->cb->getTownsInfo(true);
 	for(auto & town : towns)
 	{
-		if(town->builtBuildings.count(BuildingID::MARKETPLACE))
+		if(town->hasBuilt(BuildingID::MARKETPLACE))
 		{
 			GH.windows().createAndPushWindow<CMarketWindow>(town, nullptr, nullptr, EMarketMode::RESOURCE_RESOURCE);
 			return;
@@ -1078,7 +1120,7 @@
 	level(Level),
 	showAvailable(_showAvailable)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	pos += position;
 
 	if(town->creatures.size() <= level || town->creatures[level].second.empty())
@@ -1088,10 +1130,9 @@
 	}
 	addUsedEvents(LCLICK | SHOW_POPUP | HOVER);
 
-	ui32 creatureID = town->creatures[level].second.back();
-	creature = CGI->creh->objects[creatureID];
+	creature = town->creatures[level].second.back();
 
-	picture = std::make_shared<CAnimImage>(AnimationPath::builtin("CPRSMALL"), creature->getIconIndex(), 0, 8, 0);
+	picture = std::make_shared<CAnimImage>(AnimationPath::builtin("CPRSMALL"), creature.toEntity(VLC)->getIconIndex(), 0, 8, 0);
 
 	std::string value;
 	if(showAvailable)
@@ -1131,16 +1172,17 @@
 
 void CCreaInfo::hover(bool on)
 {
-	std::string message = CGI->generaltexth->allTexts[588];
-	boost::algorithm::replace_first(message, "%s", creature->getNamePluralTranslated());
+	MetaString message;
+	message.appendTextID("core.genrltxt.588");
+	message.replaceNameSingular(creature);
 
 	if(on)
 	{
-		GH.statusbar()->write(message);
+		GH.statusbar()->write(message.toString());
 	}
 	else
 	{
-		GH.statusbar()->clearIfMatching(message);
+		GH.statusbar()->clearIfMatching(message.toString());
 	}
 }
 
@@ -1157,12 +1199,18 @@
 std::string CCreaInfo::genGrowthText()
 {
 	GrowthInfo gi = town->getGrowthInfo(level);
-	std::string descr = boost::str(boost::format(CGI->generaltexth->allTexts[589]) % creature->getNameSingularTranslated() % gi.totalGrowth());
+	MetaString descr;
+	descr.appendTextID("core.genrltxt.589");
+	descr.replaceNameSingular(creature);
+	descr.replaceNumber(gi.totalGrowth());
 
 	for(const GrowthInfo::Entry & entry : gi.entries)
-		descr +="\n" + entry.description;
+	{
+		descr.appendEOL();
+		descr.appendRawString(entry.description);
+	}
 
-	return descr;
+	return descr.toString();
 }
 
 void CCreaInfo::showPopupWindow(const Point & cursorPosition)
@@ -1170,7 +1218,7 @@
 	if (showAvailable)
 		GH.windows().createAndPushWindow<CDwellingInfoBox>(GH.screenDimensions().x / 2, GH.screenDimensions().y / 2, town, level);
 	else
-		CRClickPopup::createAndPush(genGrowthText(), std::make_shared<CComponent>(ComponentType::CREATURE, creature->getId()));
+		CRClickPopup::createAndPush(genGrowthText(), std::make_shared<CComponent>(ComponentType::CREATURE, creature));
 }
 
 bool CCreaInfo::getShowAvailable()
@@ -1182,7 +1230,7 @@
 	: town(Town),
 	building(nullptr)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	addUsedEvents(SHOW_POPUP | HOVER);
 	pos.x += posX;
 	pos.y += posY;
@@ -1200,7 +1248,7 @@
 			return;//FIXME: suspicious statement, fix or comment
 		picture = std::make_shared<CAnimImage>(AnimationPath::builtin("ITMCL.DEF"), town->fortLevel()-1);
 	}
-	building = town->town->buildings.at(BuildingID(buildID));
+	building = town->getTown()->buildings.at(BuildingID(buildID));
 	pos = picture->pos;
 }
 
@@ -1230,14 +1278,14 @@
 	CWindowObject(PLAYER_COLORED | BORDERED),
 	town(Town)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	LOCPLINT->castleInt = this;
 	addUsedEvents(KEYBOARD);
 
 	builds = std::make_shared<CCastleBuildings>(town);
 	panel = std::make_shared<CPicture>(ImagePath::builtin("TOWNSCRN"), 0, builds->pos.h);
-	panel->colorize(LOCPLINT->playerID);
+	panel->setPlayerColor(LOCPLINT->playerID);
 	pos.w = panel->pos.w;
 	pos.h = builds->pos.h + panel->pos.h;
 	center();
@@ -1275,7 +1323,7 @@
 	recreateIcons();
 	if (!from)
 		adventureInt->onAudioPaused();
-	CCS->musich->playMusic(town->town->clientInfo.musicTheme, true, false);
+	CCS->musich->playMusicFromSet("faction", town->getFaction()->getJsonKey(), true, false);
 }
 
 CCastleInterface::~CCastleInterface()
@@ -1355,8 +1403,8 @@
 
 void CCastleInterface::recreateIcons()
 {
-	OBJECT_CONSTRUCTION_CUSTOM_CAPTURING(255-DISPOSE);
-	size_t iconIndex = town->town->clientInfo.icons[town->hasFort()][town->builded >= CGI->settings()->getInteger(EGameSettings::TOWNS_BUILDINGS_PER_TURN_CAP)];
+	OBJECT_CONSTRUCTION;
+	size_t iconIndex = town->getTown()->clientInfo.icons[town->hasFort()][town->built >= LOCPLINT->cb->getSettings().getInteger(EGameSettings::TOWNS_BUILDINGS_PER_TURN_CAP)];
 
 	icon->setFrame(iconIndex);
 	TResources townIncome = town->dailyIncome();
@@ -1375,11 +1423,11 @@
 	fastMarket = std::make_shared<LRClickableArea>(Rect(163, 410, 64, 42), [this]() { builds->enterAnyMarket(); });
 	fastTavern = std::make_shared<LRClickableArea>(Rect(15, 387, 58, 64), [&]()
 	{
-		if(town->builtBuildings.count(BuildingID::TAVERN))
+		if(town->hasBuilt(BuildingID::TAVERN))
 			LOCPLINT->showTavernWindow(town, nullptr, QueryID::NONE);
 	}, [this]{
-		if(!town->town->faction->getDescriptionTranslated().empty())
-			CRClickPopup::createAndPush(town->town->faction->getDescriptionTranslated());
+		if(!town->getFaction()->getDescriptionTranslated().empty())
+			CRClickPopup::createAndPush(town->getFaction()->getDescriptionTranslated());
 	});
 
 	creainfo.clear();
@@ -1462,7 +1510,7 @@
 	town(Town),
 	building(Building)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	addUsedEvents(LCLICK | SHOW_POPUP | HOVER);
 	pos.x += x;
 	pos.y += y;
@@ -1480,7 +1528,7 @@
 		-1, -1, -1, 0, 0, 1, 2, -1, 1, 1, -1, -1
 	};
 
-	icon = std::make_shared<CAnimImage>(town->town->clientInfo.buildingsIcons, building->bid, 0, 2, 2);
+	icon = std::make_shared<CAnimImage>(town->getTown()->clientInfo.buildingsIcons, building->bid, 0, 2, 2);
 	header = std::make_shared<CAnimImage>(AnimationPath::builtin("TPTHBAR"), panelIndex[static_cast<int>(state)], 0, 1, 73);
 	if(iconIndex[static_cast<int>(state)] >=0)
 		mark = std::make_shared<CAnimImage>(AnimationPath::builtin("TPTHCHK"), iconIndex[static_cast<int>(state)], 0, 136, 56);
@@ -1522,10 +1570,10 @@
 }
 
 CHallInterface::CHallInterface(const CGTownInstance * Town):
-	CWindowObject(PLAYER_COLORED | BORDERED, Town->town->clientInfo.hallBackground),
+	CWindowObject(PLAYER_COLORED | BORDERED, Town->getTown()->clientInfo.hallBackground),
 	town(Town)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	resdatabar = std::make_shared<CMinorResDataBar>();
 	resdatabar->moveBy(pos.topLeft(), true);
@@ -1534,10 +1582,10 @@
 	auto statusbarBackground = std::make_shared<CPicture>(background->getSurface(), barRect, 5, 556);
 	statusbar = CGStatusBar::create(statusbarBackground);
 
-	title = std::make_shared<CLabel>(399, 12, FONT_MEDIUM, ETextAlignment::CENTER, Colors::WHITE, town->town->buildings.at(BuildingID(town->hallLevel()+BuildingID::VILLAGE_HALL))->getNameTranslated());
+	title = std::make_shared<CLabel>(399, 12, FONT_MEDIUM, ETextAlignment::CENTER, Colors::WHITE, town->getTown()->buildings.at(BuildingID(town->hallLevel()+BuildingID::VILLAGE_HALL))->getNameTranslated());
 	exit = std::make_shared<CButton>(Point(748, 556), AnimationPath::builtin("TPMAGE1.DEF"), CButton::tooltip(CGI->generaltexth->hcommands[8]), [&](){close();}, EShortcut::GLOBAL_RETURN);
 
-	auto & boxList = town->town->clientInfo.hallSlots;
+	auto & boxList = town->getTown()->clientInfo.hallSlots;
 	boxes.resize(boxList.size());
 	for(size_t row=0; row<boxList.size(); row++) //for each row
 	{
@@ -1548,12 +1596,12 @@
 			{
 				if (!buildingID.hasValue())
 				{
-					logMod->warn("Invalid building ID found in hallSlots of town '%s'", town->town->faction->getJsonKey() );
+					logMod->warn("Invalid building ID found in hallSlots of town '%s'", town->getFaction()->getJsonKey() );
 					continue;
 				}
 
-				const CBuilding * current = town->town->buildings.at(buildingID);
-				if(vstd::contains(town->builtBuildings, buildingID))
+				const CBuilding * current = town->getTown()->buildings.at(buildingID);
+				if(town->hasBuilt(buildingID))
 				{
 					building = current;
 				}
@@ -1580,9 +1628,9 @@
 	town(Town),
 	building(Building)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 
-	icon = std::make_shared<CAnimImage>(town->town->clientInfo.buildingsIcons, building->bid, 0, 125, 50);
+	icon = std::make_shared<CAnimImage>(town->getTown()->clientInfo.buildingsIcons, building->bid, 0, 125, 50);
 	auto statusbarBackground = std::make_shared<CPicture>(background->getSurface(), Rect(8, pos.h - 26, pos.w - 16, 19), 8, pos.h - 26);
 	statusbar = CGStatusBar::create(statusbarBackground);
 
@@ -1664,7 +1712,7 @@
 		{
 			auto toStr = [&](const BuildingID build) -> std::string
 			{
-				return town->town->buildings.at(build)->getNameTranslated();
+				return town->getTown()->buildings.at(build)->getNameTranslated();
 			};
 
 			ret = CGI->generaltexth->allTexts[52];
@@ -1674,7 +1722,7 @@
 	case EBuildingState::MISSING_BASE:
 		{
 			std::string msg = CGI->generaltexth->translate("vcmi.townHall.missingBase");
-			ret = boost::str(boost::format(msg) % town->town->buildings.at(building->upgrade)->getNameTranslated());
+			ret = boost::str(boost::format(msg) % town->getTown()->buildings.at(building->upgrade)->getNameTranslated());
 			break;
 		}
 	}
@@ -1683,7 +1731,7 @@
 
 LabeledValue::LabeledValue(Rect size, std::string name, std::string descr, int min, int max)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	pos.x+=size.x;
 	pos.y+=size.y;
 	pos.w = size.w;
@@ -1693,7 +1741,7 @@
 
 LabeledValue::LabeledValue(Rect size, std::string name, std::string descr, int val)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	pos.x+=size.x;
 	pos.y+=size.y;
 	pos.w = size.w;
@@ -1731,12 +1779,13 @@
 CFortScreen::CFortScreen(const CGTownInstance * town):
 	CWindowObject(PLAYER_COLORED | BORDERED, getBgName(town))
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	ui32 fortSize = static_cast<ui32>(town->creatures.size());
-	if(fortSize > GameConstants::CREATURES_PER_TOWN && town->creatures.back().second.empty())
+	if(fortSize > town->getTown()->creatures.size() && town->creatures.back().second.empty())
 		fortSize--;
+	fortSize = std::min(fortSize, static_cast<ui32>(GameConstants::CREATURES_PER_TOWN)); // for 8 creatures + portal of summoning
 
-	const CBuilding * fortBuilding = town->town->buildings.at(BuildingID(town->fortLevel()+6));
+	const CBuilding * fortBuilding = town->getTown()->buildings.at(BuildingID(town->fortLevel()+6));
 	title = std::make_shared<CLabel>(400, 12, FONT_BIG, ETextAlignment::CENTER, Colors::WHITE, fortBuilding->getNameTranslated());
 
 	std::string text = boost::str(boost::format(CGI->generaltexth->fcommands[6]) % fortBuilding->getNameTranslated());
@@ -1751,25 +1800,25 @@
 
 	if(fortSize == GameConstants::CREATURES_PER_TOWN)
 	{
-		positions.push_back(Point(206,421));
+		positions.push_back(Point(10, 421));
+		positions.push_back(Point(404,421));
 	}
 	else
 	{
-		positions.push_back(Point(10, 421));
-		positions.push_back(Point(404,421));
+		positions.push_back(Point(206,421));
 	}
 
 	for(ui32 i=0; i<fortSize; i++)
 	{
 		BuildingID buildingID;
-		if(fortSize == GameConstants::CREATURES_PER_TOWN)
+		if(fortSize == town->getTown()->creatures.size())
 		{
-			BuildingID dwelling = BuildingID::DWELL_UP_FIRST+i;
+			BuildingID dwelling = BuildingID::getDwellingFromLevel(i, 1);
 
-			if(vstd::contains(town->builtBuildings, dwelling))
-				buildingID = BuildingID(BuildingID::DWELL_UP_FIRST+i);
+			if(town->hasBuilt(dwelling))
+				buildingID = BuildingID(BuildingID::getDwellingFromLevel(i, 1));
 			else
-				buildingID = BuildingID(BuildingID::DWELL_FIRST+i);
+				buildingID = BuildingID(BuildingID::getDwellingFromLevel(i, 0));
 		}
 		else
 		{
@@ -1791,13 +1840,14 @@
 ImagePath CFortScreen::getBgName(const CGTownInstance * town)
 {
 	ui32 fortSize = static_cast<ui32>(town->creatures.size());
-	if(fortSize > GameConstants::CREATURES_PER_TOWN && town->creatures.back().second.empty())
+	if(fortSize > town->getTown()->creatures.size() && town->creatures.back().second.empty())
 		fortSize--;
+	fortSize = std::min(fortSize, static_cast<ui32>(GameConstants::CREATURES_PER_TOWN)); // for 8 creatures + portal of summoning
 
 	if(fortSize == GameConstants::CREATURES_PER_TOWN)
-		return ImagePath::builtin("TPCASTL7");
-	else
 		return ImagePath::builtin("TPCASTL8");
+	else
+		return ImagePath::builtin("TPCASTL7");
 }
 
 void CFortScreen::creaturesChangedEventHandler()
@@ -1813,7 +1863,7 @@
 	level(Level),
 	availableCount(nullptr)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	pos.x +=posX;
 	pos.y +=posY;
 	pos.w = 386;
@@ -1828,10 +1878,10 @@
 
 	if(getMyBuilding() != nullptr)
 	{
-		buildingIcon = std::make_shared<CAnimImage>(town->town->clientInfo.buildingsIcons, getMyBuilding()->bid, 0, 4, 21);
+		buildingIcon = std::make_shared<CAnimImage>(town->getTown()->clientInfo.buildingsIcons, getMyBuilding()->bid, 0, 4, 21);
 		buildingName = std::make_shared<CLabel>(78, 101, FONT_SMALL, ETextAlignment::CENTER, Colors::WHITE, getMyBuilding()->getNameTranslated(), 152);
 
-		if(vstd::contains(town->builtBuildings, getMyBuilding()->bid))
+		if(town->hasBuilt(getMyBuilding()->bid))
 		{
 			ui32 available = town->creatures[level].first;
 			std::string availableText = CGI->generaltexth->allTexts[217]+ std::to_string(available);
@@ -1863,29 +1913,30 @@
 const CCreature * CFortScreen::RecruitArea::getMyCreature()
 {
 	if(!town->creatures.at(level).second.empty()) // built
-		return VLC->creh->objects[town->creatures.at(level).second.back()];
-	if(!town->town->creatures.at(level).empty()) // there are creatures on this level
-		return VLC->creh->objects[town->town->creatures.at(level).front()];
+		return town->creatures.at(level).second.back().toCreature();
+	if(!town->getTown()->creatures.at(level).empty()) // there are creatures on this level
+		return town->getTown()->creatures.at(level).front().toCreature();
 	return nullptr;
 }
 
 const CBuilding * CFortScreen::RecruitArea::getMyBuilding()
 {
-	BuildingID myID = BuildingID(BuildingID::DWELL_FIRST + level);
+	BuildingID myID = BuildingID(BuildingID::getDwellingFromLevel(level, 0));
 
-	if (level == GameConstants::CREATURES_PER_TOWN)
-		return town->town->getSpecialBuilding(BuildingSubID::PORTAL_OF_SUMMONING);
+	if (level == town->getTown()->creatures.size())
+		return town->getTown()->getSpecialBuilding(BuildingSubID::PORTAL_OF_SUMMONING);
 
-	if (!town->town->buildings.count(myID))
+	if (!town->getTown()->buildings.count(myID))
 		return nullptr;
 
-	const CBuilding * build = town->town->buildings.at(myID);
-	while (town->town->buildings.count(myID))
+	const CBuilding * build = town->getTown()->buildings.at(myID);
+	while (town->getTown()->buildings.count(myID))
 	{
 		if (town->hasBuilt(myID))
-			build = town->town->buildings.at(myID);
-		myID.advance(GameConstants::CREATURES_PER_TOWN);
+			build = town->getTown()->buildings.at(myID);
+		BuildingID::advanceDwelling(myID);
 	}
+
 	return build;
 }
 
@@ -1918,11 +1969,11 @@
 }
 
 CMageGuildScreen::CMageGuildScreen(CCastleInterface * owner, const ImagePath & imagename)
-	: CWindowObject(BORDERED, imagename)
+	: CWindowObject(BORDERED, imagename), townId(owner->town->id)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 
-	window = std::make_shared<CPicture>(owner->town->town->clientInfo.guildWindow, 332, 76);
+	window = std::make_shared<CPicture>(owner->town->getTown()->clientInfo.guildWindow, 332, 76);
 
 	resdatabar = std::make_shared<CMinorResDataBar>();
 	resdatabar->moveBy(pos.topLeft(), true);
@@ -1934,6 +1985,15 @@
 
 	exit = std::make_shared<CButton>(Point(748, 556), AnimationPath::builtin("TPMAGE1.DEF"), CButton::tooltip(CGI->generaltexth->allTexts[593]), [&](){ close(); }, EShortcut::GLOBAL_RETURN);
 
+	updateSpells(townId);
+}
+
+void CMageGuildScreen::updateSpells(ObjectInstanceID tID)
+{
+	if(tID != townId)
+		return;
+
+	OBJECT_CONSTRUCTION;
 	static const std::vector<std::vector<Point> > positions =
 	{
 		{Point(222,445), Point(312,445), Point(402,445), Point(520,445), Point(610,445), Point(700,445)},
@@ -1943,23 +2003,30 @@
 		{Point(491,325), Point(591,325)}
 	};
 
-	for(size_t i=0; i<owner->town->town->mageLevel; i++)
+	spells.clear();
+	emptyScrolls.clear();
+
+	const CGTownInstance * town = LOCPLINT->cb->getTown(townId);
+
+	for(uint32_t i=0; i<town->getTown()->mageLevel; i++)
 	{
-		size_t spellCount = owner->town->spellsAtLevel((int)i+1,false); //spell at level with -1 hmmm?
-		for(size_t j=0; j<spellCount; j++)
+		uint32_t spellCount = town->spellsAtLevel(i+1,false); //spell at level with -1 hmmm?
+		for(uint32_t j=0; j<spellCount; j++)
 		{
-			if(i<owner->town->mageGuildLevel() && owner->town->spells[i].size()>j)
-				spells.push_back(std::make_shared<Scroll>(positions[i][j], CGI->spellh->objects[owner->town->spells[i][j]]));
+			if(i<town->mageGuildLevel() && town->spells[i].size()>j)
+				spells.push_back(std::make_shared<Scroll>(positions[i][j], town->spells[i][j].toSpell(), townId));
 			else
 				emptyScrolls.push_back(std::make_shared<CAnimImage>(AnimationPath::builtin("TPMAGES.DEF"), 1, 0, positions[i][j].x, positions[i][j].y));
 		}
 	}
+
+	redraw();
 }
 
-CMageGuildScreen::Scroll::Scroll(Point position, const CSpell *Spell)
-	: spell(Spell)
+CMageGuildScreen::Scroll::Scroll(Point position, const CSpell *Spell, ObjectInstanceID townId)
+	: spell(Spell), townId(townId)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	addUsedEvents(LCLICK | SHOW_POPUP | HOVER);
 	pos += position;
@@ -1969,7 +2036,64 @@
 
 void CMageGuildScreen::Scroll::clickPressed(const Point & cursorPosition)
 {
-	LOCPLINT->showInfoDialog(spell->getDescriptionTranslated(0), std::make_shared<CComponent>(ComponentType::SPELL, spell->id));
+	const CGTownInstance * town = LOCPLINT->cb->getTown(townId);
+	if(LOCPLINT->cb->getSettings().getBoolean(EGameSettings::TOWNS_SPELL_RESEARCH) && town->spellResearchAllowed)
+	{
+		int level = -1;
+		for(int i = 0; i < town->spells.size(); i++)
+			if(vstd::find_pos(town->spells[i], spell->id) != -1)
+				level = i;
+				
+		if(town->spellResearchCounterDay >= LOCPLINT->cb->getSettings().getValue(EGameSettings::TOWNS_SPELL_RESEARCH_PER_DAY).Vector()[level].Float())
+		{
+			LOCPLINT->showInfoDialog(CGI->generaltexth->translate("vcmi.spellResearch.comeAgain"));
+			return;
+		}
+
+		auto costBase = TResources(LOCPLINT->cb->getSettings().getValue(EGameSettings::TOWNS_SPELL_RESEARCH_COST).Vector()[level]);
+		auto costExponent = LOCPLINT->cb->getSettings().getValue(EGameSettings::TOWNS_SPELL_RESEARCH_COST_EXPONENT_PER_RESEARCH).Vector()[level].Float();
+		auto cost = costBase * std::pow(town->spellResearchAcceptedCounter + 1, costExponent);
+
+		std::vector<std::shared_ptr<CComponent>> resComps;
+
+		int index = town->spellsAtLevel(level, false);
+		if (index >= town->spells[level].size())
+		{
+			LOCPLINT->showInfoDialog(CGI->generaltexth->translate("vcmi.spellResearch.noMoreSpells"));
+			return;
+		}
+		auto newSpell = town->spells[level].at(index);
+		resComps.push_back(std::make_shared<CComponent>(ComponentType::SPELL, spell->id));
+		resComps.push_back(std::make_shared<CComponent>(ComponentType::SPELL, newSpell));
+		resComps.back()->newLine = true;
+		for(TResources::nziterator i(cost); i.valid(); i++)
+		{
+			resComps.push_back(std::make_shared<CComponent>(ComponentType::RESOURCE, i->resType, i->resVal, CComponent::ESize::medium));
+		}
+
+		std::vector<std::pair<AnimationPath, CFunctionList<void()>>> pom;
+		for(int i = 0; i < 3; i++)
+			pom.emplace_back(AnimationPath::builtin("settingsWindow/button80"), nullptr);
+
+		auto text = CGI->generaltexth->translate(LOCPLINT->cb->getResourceAmount().canAfford(cost) ? "vcmi.spellResearch.pay" : "vcmi.spellResearch.canNotAfford");
+		boost::replace_first(text, "%SPELL1", spell->id.toSpell()->getNameTranslated());
+		boost::replace_first(text, "%SPELL2", newSpell.toSpell()->getNameTranslated());
+		auto temp = std::make_shared<CInfoWindow>(text, LOCPLINT->playerID, resComps, pom);
+
+		temp->buttons[0]->setOverlay(std::make_shared<CPicture>(ImagePath::builtin("spellResearch/accept")));
+		temp->buttons[0]->addCallback([this, town](){ LOCPLINT->cb->spellResearch(town, spell->id, true); });
+		temp->buttons[0]->addPopupCallback([](){ CRClickPopup::createAndPush(CGI->generaltexth->translate("vcmi.spellResearch.research")); });
+		temp->buttons[0]->setEnabled(LOCPLINT->cb->getResourceAmount().canAfford(cost));
+		temp->buttons[1]->setOverlay(std::make_shared<CPicture>(ImagePath::builtin("spellResearch/reroll")));
+		temp->buttons[1]->addCallback([this, town](){ LOCPLINT->cb->spellResearch(town, spell->id, false); });
+		temp->buttons[1]->addPopupCallback([](){ CRClickPopup::createAndPush(CGI->generaltexth->translate("vcmi.spellResearch.skip")); });
+		temp->buttons[2]->setOverlay(std::make_shared<CPicture>(ImagePath::builtin("spellResearch/close")));
+		temp->buttons[2]->addPopupCallback([](){ CRClickPopup::createAndPush(CGI->generaltexth->translate("vcmi.spellResearch.abort")); });
+
+		GH.windows().pushWindow(temp);
+	}
+	else
+		LOCPLINT->showInfoDialog(spell->getDescriptionTranslated(0), std::make_shared<CComponent>(ComponentType::SPELL, spell->id));
 }
 
 void CMageGuildScreen::Scroll::showPopupWindow(const Point & cursorPosition)
@@ -1989,7 +2113,7 @@
 CBlacksmithDialog::CBlacksmithDialog(bool possible, CreatureID creMachineID, ArtifactID aid, ObjectInstanceID hid):
 	CWindowObject(PLAYER_COLORED, ImagePath::builtin("TPSMITH"))
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	Rect barRect(8, pos.h - 26, pos.w - 16, 19);
 
@@ -1999,7 +2123,7 @@
 	animBG = std::make_shared<CPicture>(ImagePath::builtin("TPSMITBK"), 64, 50);
 	animBG->needRefresh = true;
 
-	const CCreature * creature = CGI->creh->objects[creMachineID];
+	const CCreature * creature = creMachineID.toCreature();
 	anim = std::make_shared<CCreatureAnim>(64, 50, creature->animDefName);
 	anim->clipRect(113,125,200,150);
 
diff --color -urN vcmi-1.5.7/client/windows/CCastleInterface.h vcmi/client/windows/CCastleInterface.h
--- vcmi-1.5.7/client/windows/CCastleInterface.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/windows/CCastleInterface.h	2024-12-19 15:00:22.366125952 +0100
@@ -150,7 +150,7 @@
 
 	const CGHeroInstance* getHero();//Select hero for buildings usage
 
-	void enterBlacksmith(ArtifactID artifactID);//support for blacksmith + ballista yard
+	void enterBlacksmith(BuildingID building, ArtifactID artifactID);//support for blacksmith + ballista yard
 	void enterBuilding(BuildingID building);//for buildings with simple description + pic left-click messages
 	void enterCastleGate();
 	void enterFountain(const BuildingID & building, BuildingSubID::EBuildingSubID subID, BuildingID upgrades);//Rampart's fountains
@@ -167,12 +167,15 @@
 
 	void enterDwelling(int level);
 	void enterTownHall();
+	void enterRewardable(BuildingID building);
 	void enterMagesGuild();
 	void enterAnyMarket();
 	void enterAnyThievesGuild();
+	void enterBank(BuildingID building);
 	void enterToTheQuickRecruitmentWindow();
 
-	void buildingClicked(BuildingID building, BuildingSubID::EBuildingSubID subID = BuildingSubID::NONE, BuildingID upgrades = BuildingID::NONE);
+	bool buildingTryActivateCustomUI(BuildingID buildingToTest, BuildingID buildingTarget);
+	void buildingClicked(BuildingID building);
 	void addBuilding(BuildingID building);
 	void removeBuilding(BuildingID building);//FIXME: not tested!!!
 };
@@ -181,7 +184,7 @@
 class CCreaInfo : public CIntObject
 {
 	const CGTownInstance * town;
-	const CCreature * creature;
+	CreatureID creature;
 	int level;
 	bool showAvailable;
 
@@ -376,9 +379,10 @@
 	{
 		const CSpell * spell;
 		std::shared_ptr<CAnimImage> image;
+		ObjectInstanceID townId;
 
 	public:
-		Scroll(Point position, const CSpell *Spell);
+		Scroll(Point position, const CSpell *Spell, ObjectInstanceID townId);
 		void clickPressed(const Point & cursorPosition) override;
 		void showPopupWindow(const Point & cursorPosition) override;
 		void hover(bool on) override;
@@ -390,8 +394,11 @@
 
 	std::shared_ptr<CMinorResDataBar> resdatabar;
 
+	ObjectInstanceID townId;
+
 public:
 	CMageGuildScreen(CCastleInterface * owner, const ImagePath & image);
+	void updateSpells(ObjectInstanceID tID);
 };
 
 /// The blacksmith window where you can buy available in town war machine
diff --color -urN vcmi-1.5.7/client/windows/CCreatureWindow.cpp vcmi/client/windows/CCreatureWindow.cpp
--- vcmi-1.5.7/client/windows/CCreatureWindow.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/windows/CCreatureWindow.cpp	2024-12-19 15:00:22.368126035 +0100
@@ -17,25 +17,27 @@
 #include "../CPlayerInterface.h"
 #include "../render/Canvas.h"
 #include "../widgets/Buttons.h"
-#include "../widgets/CArtPlace.h"
 #include "../widgets/CComponent.h"
+#include "../widgets/CComponentHolder.h"
 #include "../widgets/Images.h"
 #include "../widgets/TextControls.h"
 #include "../widgets/ObjectLists.h"
+#include "../widgets/GraphicalPrimitiveCanvas.h"
 #include "../windows/InfoWindows.h"
 #include "../gui/CGuiHandler.h"
 #include "../gui/Shortcut.h"
+#include "../battle/BattleInterface.h"
 
 #include "../../CCallback.h"
 #include "../../lib/ArtifactUtils.h"
 #include "../../lib/CStack.h"
 #include "../../lib/CBonusTypeHandler.h"
-#include "../../lib/CGeneralTextHandler.h"
-#include "../../lib/GameSettings.h"
-#include "../../lib/CHeroHandler.h"
+#include "../../lib/IGameSettings.h"
+#include "../../lib/entities/hero/CHeroHandler.h"
 #include "../../lib/gameState/CGameState.h"
 #include "../../lib/networkPacks/ArtifactLocation.h"
-#include "../../lib/TextOperations.h"
+#include "../../lib/texts/CGeneralTextHandler.h"
+#include "../../lib/texts/TextOperations.h"
 
 class CCreatureArtifactInstance;
 class CSelectableSkill;
@@ -59,7 +61,7 @@
 		std::function<void(CreatureID)> callback;
 	};
 
-	// pointers to permament objects in game state
+	// pointers to permanent objects in game state
 	const CCreature * creature;
 	const CCommanderInstance * commander;
 	const CStackInstance * stackNode;
@@ -89,7 +91,7 @@
 	std::string getName() const
 	{
 		if(commander)
-			return commander->type->getNameSingularTranslated();
+			return commander->getType()->getNameSingularTranslated();
 		else
 			return creature->getNamePluralTranslated();
 	}
@@ -144,10 +146,10 @@
 
 static ImagePath skillToFile(int skill, int level, bool selected)
 {
-	// FIXME: is this a correct hadling?
+	// FIXME: is this a correct handling?
 	// level 0 = skill not present, use image with "no" suffix
 	// level 1-5 = skill available, mapped to images indexed as 0-4
-	// selecting skill means that it will appear one level higher (as if alredy upgraded)
+	// selecting skill means that it will appear one level higher (as if already upgraded)
 	std::string file = "zvs/Lib1.res/_";
 	switch (skill)
 	{
@@ -170,24 +172,24 @@
 			file += "MP";
 			break;
 	}
-	std::string sufix;
+	std::string suffix;
 	if (selected)
 		level++; // UI will display resulting level
 	if (level == 0)
-		sufix = "no"; //not avaliable - no number
+		suffix = "no"; //not available - no number
 	else
-		sufix = std::to_string(level-1);
+		suffix = std::to_string(level-1);
 	if (selected)
-		sufix += "="; //level-up highlight
+		suffix += "="; //level-up highlight
 
-	return ImagePath::builtin(file + sufix + ".bmp");
+	return ImagePath::builtin(file + suffix + ".bmp");
 }
 
 CStackWindow::CWindowSection::CWindowSection(CStackWindow * parent, const ImagePath & backgroundPath, int yOffset)
 	: parent(parent)
 {
 	pos.y += yOffset;
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	if(!backgroundPath.empty())
 	{
 		background = std::make_shared<CPicture>(backgroundPath);
@@ -202,7 +204,7 @@
 	static const Point firstPos(6, 2); // position of 1st spell box
 	static const Point offset(54, 0);  // offset of each spell box from previous
 
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	const CStack * battleStack = parent->info->stack;
 
@@ -241,7 +243,7 @@
 CStackWindow::BonusLineSection::BonusLineSection(CStackWindow * owner, size_t lineIndex)
 	: CWindowSection(owner, ImagePath::builtin("stackWindow/bonus-effects"), 0)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	static const std::array<Point, 2> offset =
 	{
@@ -249,6 +251,47 @@
 		Point(214, 4)
 	};
 
+	auto drawBonusSource = [this](int leftRight, Point p, BonusInfo & bi)
+	{
+		std::map<BonusSource, ColorRGBA> bonusColors = {
+			{BonusSource::ARTIFACT,          Colors::GREEN},
+			{BonusSource::ARTIFACT_INSTANCE, Colors::GREEN},
+			{BonusSource::CREATURE_ABILITY,  Colors::YELLOW},
+			{BonusSource::SPELL_EFFECT,      Colors::ORANGE},
+			{BonusSource::SECONDARY_SKILL,   Colors::PURPLE},
+			{BonusSource::HERO_SPECIAL,      Colors::PURPLE},
+			{BonusSource::STACK_EXPERIENCE,  Colors::CYAN},
+			{BonusSource::COMMANDER,         Colors::CYAN},
+		};
+		
+		std::map<BonusSource, std::string> bonusNames = {
+			{BonusSource::ARTIFACT,          CGI->generaltexth->translate("vcmi.bonusSource.artifact")},
+			{BonusSource::ARTIFACT_INSTANCE, CGI->generaltexth->translate("vcmi.bonusSource.artifact")},
+			{BonusSource::CREATURE_ABILITY,  CGI->generaltexth->translate("vcmi.bonusSource.creature")},
+			{BonusSource::SPELL_EFFECT,      CGI->generaltexth->translate("vcmi.bonusSource.spell")},
+			{BonusSource::SECONDARY_SKILL,   CGI->generaltexth->translate("vcmi.bonusSource.hero")},
+			{BonusSource::HERO_SPECIAL,      CGI->generaltexth->translate("vcmi.bonusSource.hero")},
+			{BonusSource::STACK_EXPERIENCE,  CGI->generaltexth->translate("vcmi.bonusSource.commander")},
+			{BonusSource::COMMANDER,         CGI->generaltexth->translate("vcmi.bonusSource.commander")},
+		};
+
+		auto c = bonusColors.count(bi.bonusSource) ? bonusColors[bi.bonusSource] : ColorRGBA(192, 192, 192);
+		std::string t = bonusNames.count(bi.bonusSource) ? bonusNames[bi.bonusSource] : CGI->generaltexth->translate("vcmi.bonusSource.other");
+		int maxLen = 50;
+		EFonts f = FONT_TINY;
+		Point pText = p + Point(4, 38);
+
+		// 1px Black border
+		bonusSource[leftRight].push_back(std::make_shared<CLabel>(pText.x - 1, pText.y, f, ETextAlignment::TOPLEFT, Colors::BLACK, t, maxLen));
+		bonusSource[leftRight].push_back(std::make_shared<CLabel>(pText.x + 1, pText.y, f, ETextAlignment::TOPLEFT, Colors::BLACK, t, maxLen));
+		bonusSource[leftRight].push_back(std::make_shared<CLabel>(pText.x, pText.y - 1, f, ETextAlignment::TOPLEFT, Colors::BLACK, t, maxLen));
+		bonusSource[leftRight].push_back(std::make_shared<CLabel>(pText.x, pText.y + 1, f, ETextAlignment::TOPLEFT, Colors::BLACK, t, maxLen));
+		bonusSource[leftRight].push_back(std::make_shared<CLabel>(pText.x, pText.y, f, ETextAlignment::TOPLEFT, c, t, maxLen));
+
+		frame[leftRight] = std::make_shared<GraphicalPrimitiveCanvas>(Rect(p.x, p.y, 52, 52));
+		frame[leftRight]->addRectangle(Point(0, 0), Point(52, 52), c);
+	};
+
 	for(size_t leftRight : {0, 1})
 	{
 		auto position = offset[leftRight];
@@ -258,8 +301,9 @@
 		{
 			BonusInfo & bi = parent->activeBonuses[bonusIndex];
 			icon[leftRight] = std::make_shared<CPicture>(bi.imagePath, position.x, position.y);
-			name[leftRight] = std::make_shared<CLabel>(position.x + 60, position.y + 2, FONT_SMALL, ETextAlignment::TOPLEFT, Colors::WHITE, bi.name);
-			description[leftRight] = std::make_shared<CMultiLineLabel>(Rect(position.x + 60, position.y + 17, 137, 30), FONT_SMALL, ETextAlignment::TOPLEFT, Colors::WHITE, bi.description);
+			name[leftRight] = std::make_shared<CLabel>(position.x + 60, position.y + 2, FONT_TINY, ETextAlignment::TOPLEFT, Colors::WHITE, bi.name, 137);
+			description[leftRight] = std::make_shared<CMultiLineLabel>(Rect(position.x + 60, position.y + 20, 137, 26), FONT_TINY, ETextAlignment::TOPLEFT, Colors::WHITE, bi.description);
+			drawBonusSource(leftRight, Point(position.x - 1, position.y - 1), bi);
 		}
 	}
 }
@@ -267,7 +311,7 @@
 CStackWindow::BonusesSection::BonusesSection(CStackWindow * owner, int yOffset, std::optional<size_t> preferredSize):
 	CWindowSection(owner, {}, yOffset)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	// size of single image for an item
 	static const int itemHeight = 59;
@@ -283,13 +327,13 @@
 		return std::make_shared<BonusLineSection>(owner, index);
 	};
 
-	lines = std::make_shared<CListBox>(onCreate, Point(0, 0), Point(0, itemHeight), visibleSize, totalSize, 0, 1, Rect(pos.w - 15, 0, pos.h, pos.h));
+	lines = std::make_shared<CListBox>(onCreate, Point(0, 0), Point(0, itemHeight), visibleSize, totalSize, 0, totalSize > 3 ? 1 : 0, Rect(pos.w - 15, 0, pos.h, pos.h));
 }
 
 CStackWindow::ButtonsSection::ButtonsSection(CStackWindow * owner, int yOffset)
 	: CWindowSection(owner, ImagePath::builtin("stackWindow/button-panel"), yOffset)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	if(parent->info->dismissInfo && parent->info->dismissInfo->callback)
 	{
@@ -343,7 +387,7 @@
 
 			upgradeBtn->setOverlay(std::make_shared<CAnimImage>(AnimationPath::builtin("CPRSMALL"), VLC->creh->objects[upgradeInfo.info.newID[buttonIndex]]->getIconIndex()));
 
-			if(buttonsToCreate == 1) // single upgrade avaialbe
+			if(buttonsToCreate == 1) // single upgrade available
 				upgradeBtn->assignedKey = EShortcut::RECRUITMENT_UPGRADE;
 
 			upgrade[buttonIndex] = upgradeBtn;
@@ -378,7 +422,7 @@
 CStackWindow::CommanderMainSection::CommanderMainSection(CStackWindow * owner, int yOffset)
 	: CWindowSection(owner, ImagePath::builtin("stackWindow/commander-bg"), yOffset)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	auto getSkillPos = [](int index)
 	{
@@ -393,7 +437,7 @@
 
 	auto getSkillDescription = [this](int skillIndex) -> std::string
 	{
-		return CGI->generaltexth->znpc00[152 + (12 * skillIndex) + (parent->info->commander->secondarySkills[skillIndex] * 2)];
+		return parent->getCommanderSkillDescription(skillIndex, parent->info->commander->secondarySkills[skillIndex]);
 	};
 
 	for(int index = ECommander::ATTACK; index <= ECommander::SPELL_POWER; ++index)
@@ -432,7 +476,9 @@
 	for(auto equippedArtifact : parent->info->commander->artifactsWorn)
 	{
 		Point artPos = getArtifactPos(equippedArtifact.first);
-		auto artPlace = std::make_shared<CCommanderArtPlace>(artPos, parent->info->owner, equippedArtifact.first, equippedArtifact.second.artifact);
+		const auto commanderArt = equippedArtifact.second.artifact;
+		assert(commanderArt);
+		auto artPlace = std::make_shared<CCommanderArtPlace>(artPos, parent->info->owner, equippedArtifact.first, commanderArt->getTypeId());
 		artifacts.push_back(artPlace);
 	}
 
@@ -489,7 +535,7 @@
 CStackWindow::MainSection::MainSection(CStackWindow * owner, int yOffset, bool showExp, bool showArt)
 	: CWindowSection(owner, getBackgroundName(showExp, showArt), yOffset)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	statNames =
 	{
@@ -523,22 +569,31 @@
 			CRClickPopup::createAndPush(parent->info->creature->getDescriptionTranslated());
 	});
 
+
 	if(parent->info->stackNode != nullptr && parent->info->commander == nullptr)
 	{
 		//normal stack, not a commander and not non-existing stack (e.g. recruitment dialog)
 		animation->setAmount(parent->info->creatureCount);
 	}
 
-	name = std::make_shared<CLabel>(215, 12, FONT_SMALL, ETextAlignment::CENTER, Colors::YELLOW, parent->info->getName());
+	name = std::make_shared<CLabel>(215, 13, FONT_SMALL, ETextAlignment::CENTER, Colors::YELLOW, parent->info->getName());
+
+	const BattleInterface* battleInterface = LOCPLINT->battleInt.get();
+	const CStack* battleStack = parent->info->stack;
 
 	int dmgMultiply = 1;
-	if(parent->info->owner && parent->info->stackNode->hasBonusOfType(BonusType::SIEGE_WEAPON))
-		dmgMultiply += parent->info->owner->getPrimSkillLevel(PrimarySkill::ATTACK);
+	if (battleInterface && battleInterface->getBattle() != nullptr && battleStack->hasBonusOfType(BonusType::SIEGE_WEAPON))
+	{
+		// Determine the relevant hero based on the unit side
+		const auto hero = (battleStack->unitSide() == BattleSide::ATTACKER)
+			? battleInterface->attackingHeroInstance
+			: battleInterface->defendingHeroInstance;
 
+		dmgMultiply += hero->getPrimSkillLevel(PrimarySkill::ATTACK);
+	}
+		
 	icons = std::make_shared<CPicture>(ImagePath::builtin("stackWindow/icons"), 117, 32);
 
-	const CStack * battleStack = parent->info->stack;
-
 	morale = std::make_shared<MoraleLuckBox>(true, Rect(Point(321, 110), Point(42, 42) ));
 	luck = std::make_shared<MoraleLuckBox>(false,  Rect(Point(375, 110), Point(42, 42) ));
 
@@ -566,7 +621,7 @@
 
 		addStatLabel(EStat::ATTACK, parent->info->creature->getAttack(shooter), parent->info->stackNode->getAttack(shooter));
 		addStatLabel(EStat::DEFENCE, parent->info->creature->getDefense(shooter), parent->info->stackNode->getDefense(shooter));
-		addStatLabel(EStat::DAMAGE, parent->info->stackNode->getMinDamage(shooter) * dmgMultiply, parent->info->stackNode->getMaxDamage(shooter) * dmgMultiply);
+		addStatLabel(EStat::DAMAGE, parent->info->stackNode->getMinDamage(shooter), parent->info->stackNode->getMaxDamage(shooter));
 		addStatLabel(EStat::HEALTH, parent->info->creature->getMaxHealth(), parent->info->stackNode->getMaxHealth());
 		addStatLabel(EStat::SPEED, parent->info->creature->getMovementRange(), parent->info->stackNode->getMovementRange());
 
@@ -616,10 +671,11 @@
 		auto art = parent->info->stackNode->getArt(ArtifactPosition::CREATURE_SLOT);
 		if(art)
 		{
-			parent->stackArtifactIcon = std::make_shared<CAnimImage>(AnimationPath::builtin("ARTIFACT"), art->artType->getIconIndex(), 0, pos.x, pos.y);
-			parent->stackArtifactHelp = std::make_shared<LRClickableAreaWTextComp>(Rect(pos, Point(44, 44)), ComponentType::ARTIFACT);
-			parent->stackArtifactHelp->component.subType = art->artType->getId();
-
+			parent->stackArtifact = std::make_shared<CArtPlace>(pos, art->getTypeId());
+			parent->stackArtifact->setShowPopupCallback([](CComponentHolder & artPlace, const Point & cursorPosition)
+				{
+					artPlace.LRClickableAreaWTextComp::showPopupWindow(cursorPosition);
+				});
 			if(parent->info->owner)
 			{
 				parent->stackArtifactButton = std::make_shared<CButton>(
@@ -692,7 +748,7 @@
 	info(new UnitView())
 {
 	info->stackNode = stack;
-	info->creature = stack->type;
+	info->creature = stack->getCreature();
 	info->creatureCount = stack->count;
 	info->popupWindow = popup;
 	info->owner = dynamic_cast<const CGHeroInstance *> (stack->armyObj);
@@ -704,7 +760,7 @@
 	info(new UnitView())
 {
 	info->stackNode = stack;
-	info->creature = stack->type;
+	info->creature = stack->getCreature();
 	info->creatureCount = stack->count;
 
 	info->upgradeInfo = std::make_optional(UnitView::StackUpgradeInfo());
@@ -721,7 +777,7 @@
 	info(new UnitView())
 {
 	info->stackNode = commander;
-	info->creature = commander->type;
+	info->creature = commander->getCreature();
 	info->commander = commander;
 	info->creatureCount = 1;
 	info->popupWindow = popup;
@@ -734,7 +790,7 @@
 	info(new UnitView())
 {
 	info->stackNode = commander;
-	info->creature = commander->type;
+	info->creature = commander->getCreature();
 	info->commander = commander;
 	info->creatureCount = 1;
 	info->levelupInfo = std::make_optional(UnitView::CommanderLevelInfo());
@@ -752,7 +808,7 @@
 
 void CStackWindow::init()
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	if(!info->stackNode)
 		info->stackNode = new CStackInstance(info->creature, 1, true);// FIXME: free data
@@ -773,6 +829,12 @@
 	BonusList output;
 	BonusList input;
 	input = *(info->stackNode->getBonuses(CSelector(Bonus::Permanent), Selector::all));
+	std::sort(input.begin(), input.end(), [this](std::shared_ptr<Bonus> v1, std::shared_ptr<Bonus> & v2){
+		if (v1->source != v2->source)
+			return v1->source == BonusSource::CREATURE_ABILITY || (v1->source < v2->source);
+		else
+			return  info->stackNode->bonusToString(v1, false) < info->stackNode->bonusToString(v2, false);
+	});
 
 	while(!input.empty())
 	{
@@ -788,6 +850,7 @@
 		bonusInfo.name = info->stackNode->bonusToString(b, false);
 		bonusInfo.description = info->stackNode->bonusToString(b, true);
 		bonusInfo.imagePath = info->stackNode->bonusToGraphics(b);
+		bonusInfo.bonusSource = b->source;
 
 		//if it's possible to give any description or image for this kind of bonus
 		//TODO: figure out why half of bonuses don't have proper description
@@ -798,10 +861,10 @@
 
 void CStackWindow::initSections()
 {
-	OBJECT_CONSTRUCTION_CUSTOM_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 
-	bool showArt = CGI->settings()->getBoolean(EGameSettings::MODULE_STACK_ARTIFACT) && info->commander == nullptr && info->stackNode;
-	bool showExp = (CGI->settings()->getBoolean(EGameSettings::MODULE_STACK_EXPERIENCE) || info->commander != nullptr) && info->stackNode;
+	bool showArt = LOCPLINT->cb->getSettings().getBoolean(EGameSettings::MODULE_STACK_ARTIFACT) && info->commander == nullptr && info->stackNode;
+	bool showExp = (LOCPLINT->cb->getSettings().getBoolean(EGameSettings::MODULE_STACK_EXPERIENCE) || info->commander != nullptr) && info->stackNode;
 
 	mainSection = std::make_shared<MainSection>(this, pos.h, showExp, showArt);
 
@@ -866,7 +929,7 @@
 	const CStackInstance * stack = info->stackNode;
 	const CCreature * creature = info->creature;
 
-	int tier = stack->type->getLevel();
+	int tier = stack->getType()->getLevel();
 	int rank = stack->getExpRank();
 	if (!vstd::iswithin(tier, 1, 7))
 		tier = 0;
@@ -904,14 +967,30 @@
 	return expText;
 }
 
+std::string CStackWindow::getCommanderSkillDescription(int skillIndex, int skillLevel)
+{
+	constexpr std::array skillNames = {
+		"attack",
+		"defence",
+		"health",
+		"damage",
+		"speed",
+		"magic"
+	};
+
+	std::string textID = TextIdentifier("vcmi", "commander", "skill", skillNames.at(skillIndex), skillLevel).get();
+
+	return CGI->generaltexth->translate(textID);
+}
+
 void CStackWindow::setSelection(si32 newSkill, std::shared_ptr<CCommanderSkillIcon> newIcon)
 {
 	auto getSkillDescription = [this](int skillIndex, bool selected) -> std::string
 	{
 		if(selected)
-			return CGI->generaltexth->znpc00[152 + (12 * skillIndex) + ((info->commander->secondarySkills[skillIndex] + 1) * 2)]; //upgrade description
+			return getCommanderSkillDescription(skillIndex, info->commander->secondarySkills[skillIndex] + 1); //upgrade description
 		else
-			return CGI->generaltexth->znpc00[152 + (12 * skillIndex) + (info->commander->secondarySkills[skillIndex] * 2)];
+			return getCommanderSkillDescription(skillIndex, info->commander->secondarySkills[skillIndex]);
 	};
 
 	auto getSkillImage = [this](int skillIndex)
@@ -920,7 +999,7 @@
 		return skillToFile(skillIndex, info->commander->secondarySkills[skillIndex], selected);
 	};
 
-	OBJECT_CONSTRUCTION_CUSTOM_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	int oldSelection = selectedSkill; // update selection
 	selectedSkill = newSkill;
 
@@ -986,8 +1065,7 @@
 		artLoc.creature = info->stackNode->armyObj->findStack(info->stackNode);
 		LOCPLINT->cb->swapArtifacts(artLoc, ArtifactLocation(info->owner->id, slot));
 		stackArtifactButton.reset();
-		stackArtifactHelp.reset();
-		stackArtifactIcon.reset();
+		stackArtifact.reset();
 		redraw();
 	}
 }
diff --color -urN vcmi-1.5.7/client/windows/CCreatureWindow.h vcmi/client/windows/CCreatureWindow.h
--- vcmi-1.5.7/client/windows/CCreatureWindow.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/windows/CCreatureWindow.h	2024-12-19 15:00:22.369126076 +0100
@@ -28,14 +28,16 @@
 class CButton;
 class CMultiLineLabel;
 class CListBox;
+class CArtPlace;
 class CCommanderArtPlace;
 class LRClickableArea;
+class GraphicalPrimitiveCanvas;
 
 class CCommanderSkillIcon : public LRClickableAreaWText //TODO: maybe bring commander skill button initialization logic inside?
 {
 	std::shared_ptr<CIntObject> object; // passive object that will be used to determine clickable area
 	bool isMasterAbility; // refers to WoG abilities obtainable via combining master skills (for example attack + speed unlocks shoot)
-	bool isSelected; // used only for programatically created border around selected "master abilities"
+	bool isSelected; // used only for programmatically created border around selected "master abilities"
 public:
 	CCommanderSkillIcon(std::shared_ptr<CIntObject> object_, bool isMasterAbility_, std::function<void()> callback);
 
@@ -57,6 +59,7 @@
 		std::string name;
 		std::string description;
 		ImagePath imagePath;
+		BonusSource bonusSource;
 	};
 
 	class CWindowSection : public CIntObject
@@ -83,6 +86,8 @@
 		std::array<std::shared_ptr<CPicture>, 2> icon;
 		std::array<std::shared_ptr<CLabel>, 2> name;
 		std::array<std::shared_ptr<CMultiLineLabel>, 2> description;
+		std::array<std::shared_ptr<GraphicalPrimitiveCanvas>, 2> frame;
+		std::array<std::vector<std::shared_ptr<CLabel>>, 2> bonusSource;
 	public:
 		BonusLineSection(CStackWindow * owner, size_t lineIndex);
 	};
@@ -156,8 +161,7 @@
 		MainSection(CStackWindow * owner, int yOffset, bool showExp, bool showArt);
 	};
 
-	std::shared_ptr<CAnimImage> stackArtifactIcon;
-	std::shared_ptr<LRClickableAreaWTextComp> stackArtifactHelp;
+	std::shared_ptr<CArtPlace> stackArtifact;
 	std::shared_ptr<CButton> stackArtifactButton;
 
 
@@ -189,6 +193,7 @@
 	void init();
 
 	std::string generateStackExpDescription();
+	std::string getCommanderSkillDescription(int skillIndex, int skillLevel);
 
 public:
 	// for battles
diff --color -urN vcmi-1.5.7/client/windows/CExchangeWindow.cpp vcmi/client/windows/CExchangeWindow.cpp
--- vcmi-1.5.7/client/windows/CExchangeWindow.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/windows/CExchangeWindow.cpp	2024-12-19 15:00:22.370126118 +0100
@@ -26,16 +26,15 @@
 #include "../widgets/TextControls.h"
 
 #include "../render/IRenderHandler.h"
-#include "../render/CAnimation.h"
 
 #include "../../CCallback.h"
 
-#include "../lib/mapObjects/CGHeroInstance.h"
-#include "../lib/CGeneralTextHandler.h"
-#include "../lib/CHeroHandler.h"
-#include "../lib/filesystem/Filesystem.h"
 #include "../lib/CSkillHandler.h"
-#include "../lib/TextOperations.h"
+#include "../lib/entities/hero/CHeroHandler.h"
+#include "../lib/filesystem/Filesystem.h"
+#include "../lib/mapObjects/CGHeroInstance.h"
+#include "../lib/texts/CGeneralTextHandler.h"
+#include "../lib/texts/TextOperations.h"
 
 static const std::string QUICK_EXCHANGE_BG = "quick-exchange/TRADEQE";
 
@@ -50,7 +49,7 @@
 {
 	const bool qeLayout = isQuickExchangeLayoutAvailable();
 
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	addUsedEvents(KEYBOARD);
 
 	heroInst[0] = LOCPLINT->cb->getHero(hero1);
@@ -66,17 +65,12 @@
 	titles[0] = std::make_shared<CLabel>(147, 25, FONT_SMALL, ETextAlignment::CENTER, Colors::WHITE, genTitle(heroInst[0]));
 	titles[1] = std::make_shared<CLabel>(653, 25, FONT_SMALL, ETextAlignment::CENTER, Colors::WHITE, genTitle(heroInst[1]));
 
-	auto PSKIL32 = GH.renderHandler().loadAnimation(AnimationPath::builtin("PSKIL32"));
-	PSKIL32->preload();
-
-	auto SECSK32 = GH.renderHandler().loadAnimation(AnimationPath::builtin("SECSK32"));
-
 	for(int g = 0; g < 4; ++g)
 	{
 		if (qeLayout)
-			primSkillImages.push_back(std::make_shared<CAnimImage>(PSKIL32, g, Rect(389, 12 + 26 * g, 22, 22)));
+			primSkillImages.push_back(std::make_shared<CAnimImage>(AnimationPath::builtin("PSKIL32"), g, Rect(389, 12 + 26 * g, 22, 22)));
 		else
-			primSkillImages.push_back(std::make_shared<CAnimImage>(PSKIL32, g, 0, 385, 19 + 36 * g));
+			primSkillImages.push_back(std::make_shared<CAnimImage>(AnimationPath::builtin("PSKIL32"), g, 0, 385, 19 + 36 * g));
 	}
 
 	for(int leftRight : {0, 1})
@@ -88,24 +82,32 @@
 
 
 		for(int m=0; m < hero->secSkills.size(); ++m)
-			secSkillIcons[leftRight].push_back(std::make_shared<CAnimImage>(SECSK32, 0, 0, 32 + 36 * m + 454 * leftRight, qeLayout ? 83 : 88));
+			secSkills[leftRight].push_back(std::make_shared<CSecSkillPlace>(Point(32 + 36 * m + 454 * leftRight, qeLayout ? 83 : 88), CSecSkillPlace::ImageSize::SMALL,
+				hero->secSkills[m].first, hero->secSkills[m].second));
 
-		specImages[leftRight] = std::make_shared<CAnimImage>(AnimationPath::builtin("UN32"), hero->type->imageIndex, 0, 67 + 490 * leftRight, qeLayout ? 41 : 45);
+		specImages[leftRight] = std::make_shared<CAnimImage>(AnimationPath::builtin("UN32"), hero->getHeroType()->imageIndex, 0, 67 + 490 * leftRight, qeLayout ? 41 : 45);
 
-		expImages[leftRight] = std::make_shared<CAnimImage>(PSKIL32, 4, 0, 103 + 490 * leftRight, qeLayout ? 41 : 45);
+		expImages[leftRight] = std::make_shared<CAnimImage>(AnimationPath::builtin("PSKIL32"), 4, 0, 103 + 490 * leftRight, qeLayout ? 41 : 45);
 		expValues[leftRight] = std::make_shared<CLabel>(119 + 490 * leftRight, qeLayout ? 66 : 71, FONT_SMALL, ETextAlignment::CENTER, Colors::WHITE);
 
-		manaImages[leftRight] = std::make_shared<CAnimImage>(PSKIL32, 5, 0, 139 + 490 * leftRight, qeLayout ? 41 : 45);
+		manaImages[leftRight] = std::make_shared<CAnimImage>(AnimationPath::builtin("PSKIL32"), 5, 0, 139 + 490 * leftRight, qeLayout ? 41 : 45);
 		manaValues[leftRight] = std::make_shared<CLabel>(155 + 490 * leftRight, qeLayout ? 66 : 71, FONT_SMALL, ETextAlignment::CENTER, Colors::WHITE);
 	}
 
 	artifs[0] = std::make_shared<CArtifactsOfHeroMain>(Point(-334, 151));
+	artifs[0]->clickPressedCallback = [this, hero = heroInst[0]](const CArtPlace & artPlace, const Point & cursorPosition){clickPressedOnArtPlace(hero, artPlace.slot, true, false, false, cursorPosition);};
+	artifs[0]->showPopupCallback = [this, heroArts = artifs[0]](CArtPlace & artPlace, const Point & cursorPosition){showArtifactAssembling(*heroArts, artPlace, cursorPosition);};
+	artifs[0]->gestureCallback = [this, hero = heroInst[0]](const CArtPlace & artPlace, const Point & cursorPosition){showQuickBackpackWindow(hero, artPlace.slot, cursorPosition);};
 	artifs[0]->setHero(heroInst[0]);
 	artifs[1] = std::make_shared<CArtifactsOfHeroMain>(Point(98, 151));
+	artifs[1]->clickPressedCallback = [this, hero = heroInst[1]](const CArtPlace & artPlace, const Point & cursorPosition){clickPressedOnArtPlace(hero, artPlace.slot, true, false, false, cursorPosition);};
+	artifs[1]->showPopupCallback = [this, heroArts = artifs[1]](CArtPlace & artPlace, const Point & cursorPosition){showArtifactAssembling(*heroArts, artPlace, cursorPosition);};
+	artifs[1]->gestureCallback = [this, hero = heroInst[1]](const CArtPlace & artPlace, const Point & cursorPosition){showQuickBackpackWindow(hero, artPlace.slot, cursorPosition);};
 	artifs[1]->setHero(heroInst[1]);
 
-	addSetAndCallbacks(artifs[0]);
-	addSetAndCallbacks(artifs[1]);
+
+	addSet(artifs[0]);
+	addSet(artifs[1]);
 
 	for(int g=0; g<4; ++g)
 	{
@@ -125,21 +127,6 @@
 	{
 		const CGHeroInstance * hero = heroInst.at(b);
 
-		//secondary skill's clickable areas
-		for(int g=0; g<hero->secSkills.size(); ++g)
-		{
-			SecondarySkill skill = hero->secSkills[g].first;
-			int level = hero->secSkills[g].second; // <1, 3>
-			secSkillAreas[b].push_back(std::make_shared<LRClickableAreaWTextComp>());
-			secSkillAreas[b][g]->pos = Rect(Point(pos.x + 32 + g * 36 + b * 454 , pos.y + (qeLayout ? 83 : 88)), Point(32, 32) );
-			secSkillAreas[b][g]->component = Component(ComponentType::SEC_SKILL, skill, level);
-			secSkillAreas[b][g]->text = CGI->skillh->getByIndex(skill)->getDescriptionTranslated(level);
-
-			secSkillAreas[b][g]->hoverText = CGI->generaltexth->heroscrn[21];
-			boost::algorithm::replace_first(secSkillAreas[b][g]->hoverText, "%s", CGI->generaltexth->levels[level - 1]);
-			boost::algorithm::replace_first(secSkillAreas[b][g]->hoverText, "%s", CGI->skillh->getByIndex(skill)->getNameTranslated());
-		}
-
 		heroAreas[b] = std::make_shared<CHeroArea>(257 + 228 * b, 13, hero);
 		heroAreas[b]->addClickCallback([this, hero]() -> void
 									   {
@@ -150,7 +137,7 @@
 		specialtyAreas[b] = std::make_shared<LRClickableAreaWText>();
 		specialtyAreas[b]->pos = Rect(Point(pos.x + 69 + 490 * b, pos.y + (qeLayout ? 41 : 45)), Point(32, 32));
 		specialtyAreas[b]->hoverText = CGI->generaltexth->heroscrn[27];
-		specialtyAreas[b]->text = hero->type->getSpecialtyDescriptionTranslated();
+		specialtyAreas[b]->text = hero->getHeroType()->getSpecialtyDescriptionTranslated();
 
 		experienceAreas[b] = std::make_shared<LRClickableAreaWText>();
 		experienceAreas[b]->pos = Rect(Point(pos.x + 105 + 490 * b, pos.y + (qeLayout ? 41 : 45)), Point(32, 32));
@@ -191,18 +178,52 @@
 
 	if(qeLayout)
 	{
-		buttonMoveUnitsFromLeftToRight = std::make_shared<CButton>(Point(325, 118), AnimationPath::builtin("quick-exchange/armRight.DEF"), CButton::tooltip(CGI->generaltexth->qeModCommands[1]), [this](){ this->moveUnitsShortcut(true); });
-		buttonMoveUnitsFromRightToLeft = std::make_shared<CButton>(Point(425, 118), AnimationPath::builtin("quick-exchange/armLeft.DEF"), CButton::tooltip(CGI->generaltexth->qeModCommands[1]), [this](){ this->moveUnitsShortcut(false); });
-		buttonMoveArtifactsFromLeftToRight = std::make_shared<CButton>(Point(325, 154), AnimationPath::builtin("quick-exchange/artRight.DEF"), CButton::tooltip(CGI->generaltexth->qeModCommands[3]), [this](){ this->moveArtifactsCallback(true);});
-		buttonMoveArtifactsFromRightToLeft = std::make_shared<CButton>(Point(425, 154), AnimationPath::builtin("quick-exchange/artLeft.DEF"), CButton::tooltip(CGI->generaltexth->qeModCommands[3]), [this](){ this->moveArtifactsCallback(false);});
-
-		exchangeUnitsButton = std::make_shared<CButton>(Point(377, 118), AnimationPath::builtin("quick-exchange/swapAll.DEF"), CButton::tooltip(CGI->generaltexth->qeModCommands[2]), [this](){ controller.swapArmy(); });
-		exchangeArtifactsButton  = std::make_shared<CButton>(Point(377, 154), AnimationPath::builtin("quick-exchange/swapAll.DEF"), CButton::tooltip(CGI->generaltexth->qeModCommands[4]), [this](){ this->swapArtifactsCallback(); });
-
-		backpackButtonLeft = std::make_shared<CButton>(Point(325, 518), AnimationPath::builtin("heroBackpack"), CButton::tooltipLocalized("vcmi.heroWindow.openBackpack"),
+		buttonMoveUnitsFromLeftToRight = std::make_shared<CButton>(
+			Point(325, 118),
+			AnimationPath::builtin("quick-exchange/armRight.DEF"),
+			CButton::tooltip(CGI->generaltexth->translate("vcmi.quickExchange.moveAllUnits")),
+			[this](){ this->moveUnitsShortcut(true); });
+
+		buttonMoveUnitsFromRightToLeft = std::make_shared<CButton>(
+			Point(425, 118),
+			AnimationPath::builtin("quick-exchange/armLeft.DEF"),
+			CButton::tooltip(CGI->generaltexth->translate("vcmi.quickExchange.moveAllUnits")),
+			[this](){ this->moveUnitsShortcut(false); });
+
+		buttonMoveArtifactsFromLeftToRight = std::make_shared<CButton>(
+			Point(325, 154), AnimationPath::builtin("quick-exchange/artRight.DEF"),
+			CButton::tooltip(CGI->generaltexth->translate("vcmi.quickExchange.moveAllArtifacts")),
+			[this](){ this->moveArtifactsCallback(true);});
+
+		buttonMoveArtifactsFromRightToLeft = std::make_shared<CButton>(
+			Point(425, 154), AnimationPath::builtin("quick-exchange/artLeft.DEF"),
+			CButton::tooltip(CGI->generaltexth->translate("vcmi.quickExchange.moveAllArtifacts")),
+			[this](){ this->moveArtifactsCallback(false);});
+
+		exchangeUnitsButton = std::make_shared<CButton>(
+			Point(377, 118),
+			AnimationPath::builtin("quick-exchange/swapAll.DEF"),
+			CButton::tooltip(CGI->generaltexth->translate("vcmi.quickExchange.swapAllUnits")),
+			[this](){ controller.swapArmy(); });
+
+		exchangeArtifactsButton  = std::make_shared<CButton>(
+			Point(377, 154),
+			AnimationPath::builtin("quick-exchange/swapAll.DEF"),
+			CButton::tooltip(CGI->generaltexth->translate("vcmi.quickExchange.swapAllArtifacts")),
+			[this](){ this->swapArtifactsCallback(); });
+
+		backpackButtonLeft = std::make_shared<CButton>(
+			Point(325, 518),
+			AnimationPath::builtin("heroBackpack"),
+			CButton::tooltipLocalized("vcmi.heroWindow.openBackpack"),
 			[this](){ this->backpackShortcut(true); });
-		backpackButtonRight = std::make_shared<CButton>(Point(419, 518), AnimationPath::builtin("heroBackpack"), CButton::tooltipLocalized("vcmi.heroWindow.openBackpack"),
+
+		backpackButtonRight = std::make_shared<CButton>(
+			Point(419, 518),
+			AnimationPath::builtin("heroBackpack"),
+			CButton::tooltipLocalized("vcmi.heroWindow.openBackpack"),
 			[this](){ this->backpackShortcut(false); });
+
 		backpackButtonLeft->setOverlay(std::make_shared<CPicture>(ImagePath::builtin("heroWindow/backpackButtonIcon")));
 		backpackButtonRight->setOverlay(std::make_shared<CPicture>(ImagePath::builtin("heroWindow/backpackButtonIcon")));
 
@@ -226,21 +247,29 @@
 				std::make_shared<CButton>(
 					Point(484 + 35 * i, 154),
 					AnimationPath::builtin("quick-exchange/unitLeft.DEF"),
-					CButton::tooltip(CGI->generaltexth->qeModCommands[1]),
-					std::bind(&CExchangeController::moveStack, &controller, false, SlotID(i))));
+					CButton::tooltip(CGI->generaltexth->translate("vcmi.quickExchange.moveUnit")),
+					[this, i]() { creatureArrowButtonCallback(false, SlotID(i)); }));
 			moveUnitFromRightToLeftButtons.back()->block(leftHeroBlock);
 
 			moveUnitFromLeftToRightButtons.push_back(
 				std::make_shared<CButton>(
 					Point(66 + 35 * i, 154),
 					AnimationPath::builtin("quick-exchange/unitRight.DEF"),
-					CButton::tooltip(CGI->generaltexth->qeModCommands[1]),
-					std::bind(&CExchangeController::moveStack, &controller, true, SlotID(i))));
+					CButton::tooltip(CGI->generaltexth->translate("vcmi.quickExchange.moveUnit")),
+					[this, i]() { creatureArrowButtonCallback(true, SlotID(i)); }));
 			moveUnitFromLeftToRightButtons.back()->block(rightHeroBlock);
 		}
 	}
 
-	updateWidgets();
+	CExchangeWindow::update();
+}
+
+void CExchangeWindow::creatureArrowButtonCallback(bool leftToRight, SlotID slotId)
+{
+	if (GH.isKeyboardAltDown())
+		controller.moveArmy(leftToRight, slotId);
+	else
+		controller.moveStack(leftToRight, slotId);
 }
 
 void CExchangeWindow::moveArtifactsCallback(bool leftToRight)
@@ -328,7 +357,7 @@
 {
 	garr->recreateSlots();
 
-	updateWidgets();
+	update();
 }
 
 bool CExchangeWindow::holdsGarrison(const CArmedInstance * army)
@@ -342,8 +371,10 @@
 	LOCPLINT->showQuestLog();
 }
 
-void CExchangeWindow::updateWidgets()
+void CExchangeWindow::update()
 {
+	CWindowWithArtifacts::update();
+
 	for(size_t leftRight : {0, 1})
 	{
 		const CGHeroInstance * hero = heroInst.at(leftRight);
@@ -359,7 +390,7 @@
 			int id = hero->secSkills[m].first;
 			int level = hero->secSkills[m].second;
 
-			secSkillIcons[leftRight][m]->setFrame(2 + id * 3 + level);
+			secSkills[leftRight][m]->setSkill(id, level);
 		}
 
 		expValues[leftRight]->setText(TextOperations::formatMetric(hero->exp, 3));
diff --color -urN vcmi-1.5.7/client/windows/CExchangeWindow.h vcmi/client/windows/CExchangeWindow.h
--- vcmi-1.5.7/client/windows/CExchangeWindow.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/windows/CExchangeWindow.h	2024-12-19 15:00:22.370126118 +0100
@@ -19,7 +19,6 @@
 	std::array<std::shared_ptr<CLabel>, 2> titles;
 	std::vector<std::shared_ptr<CAnimImage>> primSkillImages;//shared for both heroes
 	std::array<std::vector<std::shared_ptr<CLabel>>, 2> primSkillValues;
-	std::array<std::vector<std::shared_ptr<CAnimImage>>, 2> secSkillIcons;
 	std::array<std::shared_ptr<CAnimImage>, 2> specImages;
 	std::array<std::shared_ptr<CAnimImage>, 2> expImages;
 	std::array<std::shared_ptr<CLabel>, 2> expValues;
@@ -27,7 +26,7 @@
 	std::array<std::shared_ptr<CLabel>, 2> manaValues;
 
 	std::vector<std::shared_ptr<LRClickableAreaWTextComp>> primSkillAreas;
-	std::array<std::vector<std::shared_ptr<LRClickableAreaWTextComp>>, 2> secSkillAreas;
+	std::array<std::vector<std::shared_ptr<CSecSkillPlace>>, 2> secSkills;
 
 	std::array<std::shared_ptr<CHeroArea>, 2> heroAreas;
 	std::array<std::shared_ptr<LRClickableAreaWText>, 2> specialtyAreas;
@@ -55,6 +54,7 @@
 	std::shared_ptr<CButton> backpackButtonRight;
 	CExchangeController controller;
 
+	void creatureArrowButtonCallback(bool leftToRight, SlotID slotID);
 	void moveArtifactsCallback(bool leftToRight);
 	void swapArtifactsCallback();
 	void moveUnitsShortcut(bool leftToRight);
@@ -71,7 +71,7 @@
 
 	void keyPressed(EShortcut key) override;
 
-	void updateWidgets();
+	void update() override;
 
 	// IGarrisonHolder impl
 	void updateGarrisons() override;
diff --color -urN vcmi-1.5.7/client/windows/CHeroBackpackWindow.cpp vcmi/client/windows/CHeroBackpackWindow.cpp
--- vcmi-1.5.7/client/windows/CHeroBackpackWindow.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/windows/CHeroBackpackWindow.cpp	2024-12-19 15:00:22.371126159 +0100
@@ -20,28 +20,61 @@
 #include "render/Canvas.h"
 #include "CPlayerInterface.h"
 
+#include "../../CCallback.h"
+
+#include "../../lib/mapObjects/CGHeroInstance.h"
+#include "../../lib/networkPacks/ArtifactLocation.h"
+
 CHeroBackpackWindow::CHeroBackpackWindow(const CGHeroInstance * hero, const std::vector<CArtifactsOfHeroPtr> & artsSets)
 	: CWindowWithArtifacts(&artsSets)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255 - DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	stretchedBackground = std::make_shared<CFilledTexture>(ImagePath::builtin("DIBOXBCK"), Rect(0, 0, 0, 0));
 	arts = std::make_shared<CArtifactsOfHeroBackpack>();
 	arts->moveBy(Point(windowMargin, windowMargin));
-	addSetAndCallbacks(arts);
+	arts->clickPressedCallback = [this](const CArtPlace & artPlace, const Point & cursorPosition)
+	{
+		clickPressedOnArtPlace(arts->getHero(), artPlace.slot, true, false, true, cursorPosition);
+	};
+	arts->showPopupCallback = [this](CArtPlace & artPlace, const Point & cursorPosition)
+	{
+		showArtifactAssembling(*arts, artPlace, cursorPosition);
+	};
+	addSet(arts);
 	arts->setHero(hero);
-	addCloseCallback(std::bind(&CHeroBackpackWindow::close, this));
-	quitButton = std::make_shared<CButton>(Point(), AnimationPath::builtin("IOKAY32.def"), CButton::tooltip(""),
-		[this]() { WindowBase::close(); }, EShortcut::GLOBAL_RETURN);
+	
+	buttons.emplace_back(std::make_unique<CButton>(Point(), AnimationPath::builtin("ALTFILL.DEF"),
+		CButton::tooltipLocalized("vcmi.heroWindow.sortBackpackByCost"),
+		[hero]() { LOCPLINT->cb->sortBackpackArtifactsByCost(hero->id); }));
+	buttons.emplace_back(std::make_unique<CButton>(Point(), AnimationPath::builtin("ALTFILL.DEF"),
+		CButton::tooltipLocalized("vcmi.heroWindow.sortBackpackBySlot"),
+		[hero]() { LOCPLINT->cb->sortBackpackArtifactsBySlot(hero->id); }));
+	buttons.emplace_back(std::make_unique<CButton>(Point(), AnimationPath::builtin("ALTFILL.DEF"),
+		CButton::tooltipLocalized("vcmi.heroWindow.sortBackpackByClass"),
+		[hero]() { LOCPLINT->cb->sortBackpackArtifactsByClass(hero->id); }));
+
 	pos.w = stretchedBackground->pos.w = arts->pos.w + 2 * windowMargin;
-	pos.h = stretchedBackground->pos.h = arts->pos.h + quitButton->pos.h + 3 * windowMargin;
-	quitButton->moveTo(Point(pos.x + pos.w / 2 - quitButton->pos.w / 2, pos.y + arts->pos.h + 2 * windowMargin));
+	pos.h = stretchedBackground->pos.h = arts->pos.h + buttons.back()->pos.h + 3 * windowMargin;
+	
+	auto buttonPos = Point(pos.x + windowMargin, pos.y + arts->pos.h + 2 * windowMargin);
+	for(const auto & button : buttons)
+	{
+		button->moveTo(buttonPos);
+		buttonPos += Point(button->pos.w + 10, 0);
+	}
+
 	statusbar = CGStatusBar::create(0, pos.h, ImagePath::builtin("ADROLLVR.bmp"), pos.w);
 	pos.h += statusbar->pos.h;
-
+	addUsedEvents(LCLICK);
 	center();
 }
 
+void CHeroBackpackWindow::notFocusedClick()
+{
+	close();
+}
+
 void CHeroBackpackWindow::showAll(Canvas & to)
 {
 	CIntObject::showAll(to);
@@ -50,15 +83,20 @@
 
 CHeroQuickBackpackWindow::CHeroQuickBackpackWindow(const CGHeroInstance * hero, ArtifactPosition targetSlot)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255 - DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	stretchedBackground = std::make_shared<CFilledTexture>(ImagePath::builtin("DIBOXBCK"), Rect(0, 0, 0, 0));
 	arts = std::make_shared<CArtifactsOfHeroQuickBackpack>(targetSlot);
 	arts->moveBy(Point(windowMargin, windowMargin));
-	addSetAndCallbacks(static_cast<std::weak_ptr<CArtifactsOfHeroQuickBackpack>>(arts));
+	arts->clickPressedCallback = [this](const CArtPlace & artPlace, const Point & cursorPosition)
+	{
+		if(const auto curHero = arts->getHero())
+			swapArtifactAndClose(*arts, artPlace.slot, ArtifactLocation(curHero->id, arts->getFilterSlot()));
+	};
+	addSet(arts);
 	arts->setHero(hero);
-	addCloseCallback(std::bind(&CHeroQuickBackpackWindow::close, this));
 	addUsedEvents(GESTURE);
+	addUsedEvents(LCLICK);
 	pos.w = stretchedBackground->pos.w = arts->pos.w + 2 * windowMargin;
 	pos.h = stretchedBackground->pos.h = arts->pos.h + windowMargin;
 }
@@ -78,6 +116,11 @@
 	redraw();
 }
 
+void CHeroQuickBackpackWindow::notFocusedClick()
+{
+	close();
+}
+
 void CHeroQuickBackpackWindow::showAll(Canvas & to)
 {
 	if(arts->getSlotsNum() == 0)
diff --color -urN vcmi-1.5.7/client/windows/CHeroBackpackWindow.h vcmi/client/windows/CHeroBackpackWindow.h
--- vcmi-1.5.7/client/windows/CHeroBackpackWindow.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/windows/CHeroBackpackWindow.h	2024-12-19 15:00:22.371126159 +0100
@@ -17,10 +17,11 @@
 {
 public:
 	CHeroBackpackWindow(const CGHeroInstance * hero, const std::vector<CArtifactsOfHeroPtr> & artsSets);
+	void notFocusedClick() override;
 	
 protected:
 	std::shared_ptr<CArtifactsOfHeroBackpack> arts;
-	std::shared_ptr<CButton> quitButton;
+	std::vector<std::unique_ptr<CButton>> buttons;
 	std::shared_ptr<CFilledTexture> stretchedBackground;
 	const int windowMargin = 5;
 
@@ -33,6 +34,7 @@
 	CHeroQuickBackpackWindow(const CGHeroInstance * hero, ArtifactPosition targetSlot);
 	void gesture(bool on, const Point & initialPosition, const Point & finalPosition) override;
 	void gesturePanning(const Point & initialPosition, const Point & currentPosition, const Point & lastUpdateDistance) override;
+	void notFocusedClick() override;
 
 private:
 	std::shared_ptr<CArtifactsOfHeroQuickBackpack> arts;
diff --color -urN vcmi-1.5.7/client/windows/CHeroOverview.cpp vcmi/client/windows/CHeroOverview.cpp
--- vcmi-1.5.7/client/windows/CHeroOverview.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/windows/CHeroOverview.cpp	2024-12-19 15:00:22.372126200 +0100
@@ -10,29 +10,31 @@
 #include "StdInc.h"
 #include "CHeroOverview.h"
 
+#include "../CCallback.h"
 #include "../CGameInfo.h"
+#include "../CPlayerInterface.h"
 #include "../gui/CGuiHandler.h"
 #include "../render/Canvas.h"
 #include "../render/Colors.h"
-#include "../render/Graphics.h"
 #include "../render/IImage.h"
 #include "../renderSDL/RenderHandler.h"
-#include "../widgets/CComponent.h"
+#include "../widgets/CComponentHolder.h"
 #include "../widgets/Images.h"
 #include "../widgets/TextControls.h"
 #include "../widgets/GraphicalPrimitiveCanvas.h"
 
-#include "../../lib/GameSettings.h"
-#include "../../lib/CGeneralTextHandler.h"
+#include "../../lib/IGameSettings.h"
+#include "../../lib/entities/hero/CHeroHandler.h"
+#include "../../lib/entities/hero/CHeroClass.h"
+#include "../../lib/texts/CGeneralTextHandler.h"
 #include "../../lib/CCreatureHandler.h"
-#include "../../lib/CHeroHandler.h"
 #include "../../lib/CSkillHandler.h"
 #include "../../lib/spells/CSpellHandler.h"
 
 CHeroOverview::CHeroOverview(const HeroTypeID & h)
 	: CWindowObject(BORDERED | RCLICK_POPUP), hero { h }
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 
     heroIdx = hero.getNum();
 
@@ -124,7 +126,7 @@
     r = Rect(302, 3 * borderOffset + yOffset + 62, 292, 32);
     backgroundRectangles.push_back(std::make_shared<TransparentFilledRectangle>(r.resize(1), rectangleColor, borderColor));
 
-    auto stacksCountChances = VLC->settings()->getVector(EGameSettings::HEROES_STARTING_STACKS_CHANCES);
+    auto stacksCountChances = CGI->engineSettings()->getVector(EGameSettings::HEROES_STARTING_STACKS_CHANCES);
 
     // army
     int space = (260 - 7 * 32) / 6;
@@ -204,7 +206,8 @@
     i = 0;
     for(auto & skill : (*CGI->heroh)[heroIdx]->secSkillsInit)
     {
-        imageSecSkills.push_back(std::make_shared<CAnimImage>(AnimationPath::builtin("SECSK32"), (*CGI->skillh)[skill.first]->getIconIndex() * 3 + skill.second + 2, 0, 302, 7 * borderOffset + yOffset + 186 + i * (32 + borderOffset)));
+        secSkills.push_back(std::make_shared<CSecSkillPlace>(Point(302, 7 * borderOffset + yOffset + 186 + i * (32 + borderOffset)),
+            CSecSkillPlace::ImageSize::SMALL, skill.first, skill.second));
         labelSecSkillsNames.push_back(std::make_shared<CLabel>(334 + 2 * borderOffset, 8 * borderOffset + yOffset + 186 + i * (32 + borderOffset) - 5, FONT_SMALL, ETextAlignment::TOPLEFT, Colors::WHITE, CGI->generaltexth->levels[skill.second - 1]));
         labelSecSkillsNames.push_back(std::make_shared<CLabel>(334 + 2 * borderOffset, 8 * borderOffset + yOffset + 186 + i * (32 + borderOffset) + 10, FONT_SMALL, ETextAlignment::TOPLEFT, Colors::WHITE, (*CGI->skillh)[skill.first]->getNameTranslated()));
         i++;
@@ -225,12 +228,12 @@
         {
             if((*CGI->heroh)[heroIdx]->haveSpellBook)
             {
-                imageSpells.push_back(std::make_shared<CAnimImage>(GH.renderHandler().loadAnimation(AnimationPath::builtin("ARTIFACT")), 0, Rect(302 + (292 / 2) + 2 * borderOffset, 7 * borderOffset + yOffset + 186 + i * (32 + borderOffset), 32, 32), 0));
+                imageSpells.push_back(std::make_shared<CAnimImage>(AnimationPath::builtin("ARTIFACT"), 0, Rect(302 + (292 / 2) + 2 * borderOffset, 7 * borderOffset + yOffset + 186 + i * (32 + borderOffset), 32, 32), 0));
             }
             i++;
         }
 
-        imageSpells.push_back(std::make_shared<CAnimImage>(GH.renderHandler().loadAnimation(AnimationPath::builtin("SPELLBON")), (*CGI->spellh)[spell]->getIconIndex(), Rect(302 + (292 / 2) + 2 * borderOffset, 7 * borderOffset + yOffset + 186 + i * (32 + borderOffset), 32, 32), 0));
+        imageSpells.push_back(std::make_shared<CAnimImage>(AnimationPath::builtin("SPELLBON"), (*CGI->spellh)[spell]->getIconIndex(), Rect(302 + (292 / 2) + 2 * borderOffset, 7 * borderOffset + yOffset + 186 + i * (32 + borderOffset), 32, 32), 0));
         labelSpellsNames.push_back(std::make_shared<CLabel>(302 + (292 / 2) + 3 * borderOffset + 32 + borderOffset, 8 * borderOffset + yOffset + 186 + i * (32 + borderOffset) + 3, FONT_SMALL, ETextAlignment::TOPLEFT, Colors::WHITE, (*CGI->spellh)[spell]->getNameTranslated()));
         i++;
     }
diff --color -urN vcmi-1.5.7/client/windows/CHeroOverview.h vcmi/client/windows/CHeroOverview.h
--- vcmi-1.5.7/client/windows/CHeroOverview.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/windows/CHeroOverview.h	2024-12-19 15:00:22.372126200 +0100
@@ -19,6 +19,7 @@
 class CTextBox;
 class TransparentFilledRectangle;
 class SimpleLine;
+class CSecSkillPlace;
 
 class CHeroOverview : public CWindowObject
 {
@@ -60,7 +61,7 @@
     std::vector<std::shared_ptr<CLabel>> labelSpellsNames;
 
     std::shared_ptr<CLabel> labelSecSkillTitle;
-    std::vector<std::shared_ptr<CAnimImage>> imageSecSkills;
+    std::vector<std::shared_ptr<CSecSkillPlace>> secSkills;
     std::vector<std::shared_ptr<CLabel>> labelSecSkillsNames;
 
     void genBackground();
diff --color -urN vcmi-1.5.7/client/windows/CHeroWindow.cpp vcmi/client/windows/CHeroWindow.cpp
--- vcmi-1.5.7/client/windows/CHeroWindow.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/windows/CHeroWindow.cpp	2024-12-19 15:00:22.374126283 +0100
@@ -28,7 +28,6 @@
 #include "../widgets/CGarrisonInt.h"
 #include "../widgets/TextControls.h"
 #include "../widgets/Buttons.h"
-#include "../render/CAnimation.h"
 #include "../render/IRenderHandler.h"
 
 #include "../../CCallback.h"
@@ -36,18 +35,18 @@
 #include "../lib/ArtifactUtils.h"
 #include "../lib/CArtHandler.h"
 #include "../lib/CConfigHandler.h"
-#include "../lib/CGeneralTextHandler.h"
-#include "../lib/CHeroHandler.h"
+#include "../lib/entities/hero/CHeroHandler.h"
+#include "../lib/texts/CGeneralTextHandler.h"
 #include "../lib/CSkillHandler.h"
 #include "../lib/mapObjects/CGHeroInstance.h"
-#include "../../lib/networkPacks/ArtifactLocation.h"
+#include "../lib/networkPacks/ArtifactLocation.h"
 
 void CHeroSwitcher::clickPressed(const Point & cursorPosition)
 {
 	//TODO: do not recreate window
 	if (false)
 	{
-		owner->update(hero, true);
+		owner->update();
 	}
 	else
 	{
@@ -62,7 +61,7 @@
 	owner(owner_),
 	hero(hero_)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	pos += pos_;
 
 	image = std::make_shared<CAnimImage>(AnimationPath::builtin("PortraitsSmall"), hero->getIconIndex());
@@ -75,7 +74,7 @@
 {
 	auto & heroscrn = CGI->generaltexth->heroscrn;
 
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	curHero = hero;
 
 	banner = std::make_shared<CAnimImage>(AnimationPath::builtin("CREST58"), LOCPLINT->playerID.getNum(), 0, 606, 8);
@@ -131,14 +130,12 @@
 		primSkillValues.push_back(value);
 	}
 
-	auto primSkills = GH.renderHandler().loadAnimation(AnimationPath::builtin("PSKIL42"));
-	primSkills->preload();
-	primSkillImages.push_back(std::make_shared<CAnimImage>(primSkills, 0, 0, 32, 111));
-	primSkillImages.push_back(std::make_shared<CAnimImage>(primSkills, 1, 0, 102, 111));
-	primSkillImages.push_back(std::make_shared<CAnimImage>(primSkills, 2, 0, 172, 111));
-	primSkillImages.push_back(std::make_shared<CAnimImage>(primSkills, 3, 0, 162, 230));
-	primSkillImages.push_back(std::make_shared<CAnimImage>(primSkills, 4, 0, 20, 230));
-	primSkillImages.push_back(std::make_shared<CAnimImage>(primSkills, 5, 0, 242, 111));
+	primSkillImages.push_back(std::make_shared<CAnimImage>(AnimationPath::builtin("PSKIL42"), 0, 0, 32, 111));
+	primSkillImages.push_back(std::make_shared<CAnimImage>(AnimationPath::builtin("PSKIL42"), 1, 0, 102, 111));
+	primSkillImages.push_back(std::make_shared<CAnimImage>(AnimationPath::builtin("PSKIL42"), 2, 0, 172, 111));
+	primSkillImages.push_back(std::make_shared<CAnimImage>(AnimationPath::builtin("PSKIL42"), 3, 0, 162, 230));
+	primSkillImages.push_back(std::make_shared<CAnimImage>(AnimationPath::builtin("PSKIL42"), 4, 0, 20, 230));
+	primSkillImages.push_back(std::make_shared<CAnimImage>(AnimationPath::builtin("PSKIL42"), 5, 0, 242, 111));
 
 	specImage = std::make_shared<CAnimImage>(AnimationPath::builtin("UN44"), 0, 0, 18, 180);
 	specArea = std::make_shared<LRClickableAreaWText>(Rect(18, 180, 136, 42), CGI->generaltexth->heroscrn[27]);
@@ -152,12 +149,10 @@
 	expValue = std::make_shared<CLabel>(68, 252);
 	manaValue = std::make_shared<CLabel>(211, 252);
 
-	auto secSkills = GH.renderHandler().loadAnimation(AnimationPath::builtin("SECSKILL"));
 	for(int i = 0; i < std::min<size_t>(hero->secSkills.size(), 8u); ++i)
 	{
 		Rect r = Rect(i%2 == 0  ?  18  :  162,  276 + 48 * (i/2),  136,  42);
-		secSkillAreas.push_back(std::make_shared<LRClickableAreaWTextComp>(r, ComponentType::SEC_SKILL));
-		secSkillImages.push_back(std::make_shared<CAnimImage>(secSkills, 0, 0, r.x, r.y));
+		secSkills.emplace_back(std::make_shared<CSecSkillPlace>(r.topLeft(), CSecSkillPlace::ImageSize::MEDIUM));
 
 		int x = (i % 2) ? 212 : 68;
 		int y = 280 + 48 * (i/2);
@@ -176,27 +171,21 @@
 	labels.push_back(std::make_shared<CLabel>(69, 232, FONT_SMALL, ETextAlignment::TOPLEFT, Colors::YELLOW, CGI->generaltexth->jktexts[6]));
 	labels.push_back(std::make_shared<CLabel>(213, 232, FONT_SMALL, ETextAlignment::TOPLEFT, Colors::YELLOW, CGI->generaltexth->jktexts[7]));
 
-	update(hero);
+	CHeroWindow::update();
 }
 
-void CHeroWindow::update(const CGHeroInstance * hero, bool redrawNeeded)
+void CHeroWindow::update()
 {
+	CWindowWithArtifacts::update();
 	auto & heroscrn = CGI->generaltexth->heroscrn;
-
-	if(!hero) //something strange... no hero? it shouldn't happen
-	{
-		logGlobal->error("Set nullptr hero? no way...");
-		return;
-	}
-
-	assert(hero == curHero);
+	assert(curHero);
 
 	name->setText(curHero->getNameTranslated());
 	title->setText((boost::format(CGI->generaltexth->allTexts[342]) % curHero->level % curHero->getClassNameTranslated()).str());
 
-	specArea->text = curHero->type->getSpecialtyDescriptionTranslated();
-	specImage->setFrame(curHero->type->imageIndex);
-	specName->setText(curHero->type->getSpecialtyNameTranslated());
+	specArea->text = curHero->getHeroType()->getSpecialtyDescriptionTranslated();
+	specImage->setFrame(curHero->getHeroType()->imageIndex);
+	specName->setText(curHero->getHeroType()->getSpecialtyNameTranslated());
 
 	tacticsButton = std::make_shared<CToggleButton>(Point(539, 483), AnimationPath::builtin("hsbtns8.def"), std::make_pair(heroscrn[26], heroscrn[31]), 0, EShortcut::HERO_TOGGLE_TACTICS);
 	tacticsButton->addHoverText(EButtonState::HIGHLIGHTED, CGI->generaltexth->heroscrn[25]);
@@ -207,22 +196,26 @@
 	portraitImage->setFrame(curHero->getIconIndex());
 
 	{
-		OBJECT_CONSTRUCTION_CUSTOM_CAPTURING(255-DISPOSE);
+		OBJECT_CONSTRUCTION;
 		if(!garr)
 		{
+			bool removableTroops = curHero->getOwner() == LOCPLINT->playerID;
 			std::string helpBox = heroscrn[32];
 			boost::algorithm::replace_first(helpBox, "%s", CGI->generaltexth->allTexts[43]);
 
-			garr = std::make_shared<CGarrisonInt>(Point(15, 485), 8, Point(), curHero);
-			auto split = std::make_shared<CButton>(Point(539, 519), AnimationPath::builtin("hsbtns9.def"), CButton::tooltip(CGI->generaltexth->allTexts[256], helpBox), [&](){ garr->splitClick(); }, EShortcut::HERO_ARMY_SPLIT);
+			garr = std::make_shared<CGarrisonInt>(Point(15, 485), 8, Point(), curHero, nullptr, removableTroops);
+			auto split = std::make_shared<CButton>(Point(539, 519), AnimationPath::builtin("hsbtns9.def"), CButton::tooltip(CGI->generaltexth->allTexts[256], helpBox), [this](){ garr->splitClick(); }, EShortcut::HERO_ARMY_SPLIT);
 			garr->addSplitBtn(split);
 		}
 		if(!arts)
 		{
 			arts = std::make_shared<CArtifactsOfHeroMain>(Point(-65, -8));
+			arts->clickPressedCallback = [this](const CArtPlace & artPlace, const Point & cursorPosition){clickPressedOnArtPlace(curHero, artPlace.slot, true, false, false, cursorPosition);};
+			arts->showPopupCallback = [this](CArtPlace & artPlace, const Point & cursorPosition){showArtifactAssembling(*arts, artPlace, cursorPosition);};
+			arts->gestureCallback = [this](const CArtPlace & artPlace, const Point & cursorPosition){showQuickBackpackWindow(curHero, artPlace.slot, cursorPosition);};
 			arts->setHero(curHero);
-			addSetAndCallbacks(arts);
-			enableArtifactsCostumeSwitcher();
+			addSet(arts);
+			enableKeyboardShortcuts();
 		}
 
 		int serial = LOCPLINT->cb->getHeroSerial(curHero, false);
@@ -241,20 +234,16 @@
 	}
 
 	//secondary skills support
-	for(size_t g=0; g< secSkillAreas.size(); ++g)
+	for(size_t g=0; g< secSkills.size(); ++g)
 	{
 		SecondarySkill skill = curHero->secSkills[g].first;
 		int	level = curHero->getSecSkillLevel(skill);
 		std::string skillName = CGI->skillh->getByIndex(skill)->getNameTranslated();
 		std::string skillValue = CGI->generaltexth->levels[level-1];
 
-		secSkillAreas[g]->component.subType = skill;
-		secSkillAreas[g]->component.value = level;
-		secSkillAreas[g]->text = CGI->skillh->getByIndex(skill)->getDescriptionTranslated(level);
-		secSkillAreas[g]->hoverText = boost::str(boost::format(heroscrn[21]) % skillValue % skillName);
-		secSkillImages[g]->setFrame(skill*3 + level + 2);
 		secSkillNames[g]->setText(skillName);
 		secSkillValues[g]->setText(skillValue);
+		secSkills[g]->setSkill(skill, level);
 	}
 
 	std::ostringstream expstr;
@@ -313,8 +302,7 @@
 	morale->set(curHero);
 	luck->set(curHero);
 
-	if(redrawNeeded)
-		redraw();
+	redraw();
 }
 
 void CHeroWindow::dismissCurrent()
@@ -324,6 +312,7 @@
 			arts->putBackPickedArtifact();
 			close();
 			LOCPLINT->cb->dismissHero(curHero);
+			arts->setHero(nullptr);
 		}, nullptr);
 }
 
diff --color -urN vcmi-1.5.7/client/windows/CHeroWindow.h vcmi/client/windows/CHeroWindow.h
--- vcmi-1.5.7/client/windows/CHeroWindow.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/windows/CHeroWindow.h	2024-12-19 15:00:22.375126324 +0100
@@ -74,8 +74,7 @@
 	std::shared_ptr<CLabel> specName;
 	std::shared_ptr<MoraleLuckBox> morale;
 	std::shared_ptr<MoraleLuckBox> luck;
-	std::vector<std::shared_ptr<LRClickableAreaWTextComp>> secSkillAreas;
-	std::vector<std::shared_ptr<CAnimImage>> secSkillImages;
+	std::vector< std::shared_ptr<CSecSkillPlace>> secSkills;
 	std::vector<std::shared_ptr<CLabel>> secSkillNames;
 	std::vector<std::shared_ptr<CLabel>> secSkillValues;
 
@@ -100,9 +99,9 @@
 
 	CHeroWindow(const CGHeroInstance * hero);
 
-	void update(const CGHeroInstance * hero, bool redrawNeeded = false); //sets main displayed hero
+	void update() override;
 
-	void dismissCurrent(); //dissmissed currently displayed hero (curHero)
+	void dismissCurrent(); //dismissed currently displayed hero (curHero)
 	void commanderWindow();
 	void switchHero(); //changes displayed hero
 	void updateGarrisons() override;
diff --color -urN vcmi-1.5.7/client/windows/CKingdomInterface.cpp vcmi/client/windows/CKingdomInterface.cpp
--- vcmi-1.5.7/client/windows/CKingdomInterface.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/windows/CKingdomInterface.cpp	2024-12-19 15:00:22.377126407 +0100
@@ -33,11 +33,11 @@
 
 #include "../../lib/CConfigHandler.h"
 #include "../../lib/CCreatureHandler.h"
-#include "../../lib/CGeneralTextHandler.h"
-#include "../../lib/CHeroHandler.h"
-#include "../../lib/GameSettings.h"
+#include "../../lib/entities/hero/CHeroHandler.h"
+#include "../../lib/texts/CGeneralTextHandler.h"
+#include "../../lib/IGameSettings.h"
 #include "../../lib/CSkillHandler.h"
-#include "../../lib/CTownHandler.h"
+#include "../../lib/StartInfo.h"
 #include "../../lib/mapObjects/CGHeroInstance.h"
 #include "../../lib/mapObjects/CGTownInstance.h"
 #include "../../lib/mapObjects/MiscObjects.h"
@@ -56,7 +56,7 @@
 	addUsedEvents(LCLICK | SHOW_POPUP);
 	EFonts font = (size < SIZE_MEDIUM)? FONT_SMALL: FONT_MEDIUM;
 
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	pos+=position;
 
 	image = std::make_shared<CAnimImage>(data->getImageName(size), data->getImageIndex());
@@ -300,7 +300,7 @@
 		else
 			return 0;
 	case HERO_SPECIAL:
-		return hero->type->getIndex();
+		return hero->getHeroTypeID().getNum();
 	case HERO_MANA:
 	case HERO_EXPERIENCE:
 		return 0;
@@ -462,7 +462,7 @@
 CKingdomInterface::CKingdomInterface()
 	: CWindowObject(PLAYER_COLORED | BORDERED, ImagePath::builtin(OVERVIEW_BACKGROUND))
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	ui32 footerPos = OVERVIEW_SIZE * 116;
 
 	tabArea = std::make_shared<CTabbedInt>(std::bind(&CKingdomInterface::createMainTab, this, _1), Point(4,4));
@@ -473,7 +473,7 @@
 	generateButtons();
 
 	statusbar = CGStatusBar::create(std::make_shared<CPicture>(ImagePath::builtin("KSTATBAR"), 10,pos.h - 45));
-	resdatabar = std::make_shared<CResDataBar>(ImagePath::builtin("KRESBAR"), 7, 111+footerPos, 29, 5, 76, 81);
+	resdatabar = std::make_shared<CResDataBar>(ImagePath::builtin("KRESBAR"), 7, 111+footerPos, 29, 3, 76, 81);
 
 	activateTab(persistentStorage["gui"]["lastKindomInterface"].Integer());
 }
@@ -550,7 +550,19 @@
 	case 0:
 		return std::make_shared<CKingdHeroList>(size, [this](const CWindowWithArtifacts::CArtifactsOfHeroPtr & newHeroSet)
 			{
-				addSetAndCallbacks(newHeroSet);
+				newHeroSet->clickPressedCallback = [this, newHeroSet](const CArtPlace & artPlace, const Point & cursorPosition)
+				{
+					clickPressedOnArtPlace(newHeroSet->getHero(), artPlace.slot, false, false, false, cursorPosition);
+				};
+				newHeroSet->showPopupCallback = [this, newHeroSet](CArtPlace & artPlace, const Point & cursorPosition)
+				{
+					showArtifactAssembling(*newHeroSet, artPlace, cursorPosition);
+				};
+				newHeroSet->gestureCallback = [this, newHeroSet](const CArtPlace & artPlace, const Point & cursorPosition)
+				{
+					showQuickBackpackWindow(newHeroSet->getHero(), artPlace.slot, cursorPosition);
+				};
+				addSet(newHeroSet);
 			});
 	case 1:
 		return std::make_shared<CKingdTownList>(size);
@@ -571,31 +583,18 @@
 		if(object->ID == Obj::MINE || object->ID == Obj::ABANDONED_MINE)
 		{
 			const CGMine * mine = dynamic_cast<const CGMine *>(object);
-			assert(mine);
 			minesCount[mine->producedResource]++;
-
-			if (mine->producedResource == EGameResID::GOLD)
-				totalIncome += mine->producedQuantity;
 		}
 	}
 
-	//Heroes can produce gold as well - skill, specialty or arts
-	std::vector<const CGHeroInstance*> heroes = LOCPLINT->cb->getHeroesInfo(true);
-	for(auto & hero : heroes)
-	{
-		totalIncome += hero->valOfBonuses(Selector::typeSubtype(BonusType::GENERATE_RESOURCE, BonusSubtypeID(GameResID(EGameResID::GOLD))));
-	}
-
-	//Add town income of all towns
-	std::vector<const CGTownInstance*> towns = LOCPLINT->cb->getTownsInfo(true);
-	for(auto & town : towns)
-	{
-		totalIncome += town->dailyIncome()[EGameResID::GOLD];
-	}
+	for(auto & mapObject : ownedObjects)
+		totalIncome += mapObject->asOwnable()->dailyIncome()[EGameResID::GOLD];
 
 	//if player has some modded boosts we want to show that as well
-	totalIncome += LOCPLINT->cb->getPlayerState(LOCPLINT->playerID)->valOfBonuses(BonusType::RESOURCES_CONSTANT_BOOST, BonusSubtypeID(GameResID(EGameResID::GOLD)));
-	totalIncome += LOCPLINT->cb->getPlayerState(LOCPLINT->playerID)->valOfBonuses(BonusType::RESOURCES_TOWN_MULTIPLYING_BOOST, BonusSubtypeID(GameResID(EGameResID::GOLD))) * towns.size();
+	const auto * playerSettings = LOCPLINT->cb->getPlayerSettings(LOCPLINT->playerID);
+	const auto & towns = LOCPLINT->cb->getTownsInfo(true);
+	totalIncome += LOCPLINT->cb->getPlayerState(LOCPLINT->playerID)->valOfBonuses(BonusType::RESOURCES_CONSTANT_BOOST, BonusSubtypeID(GameResID(EGameResID::GOLD))) * playerSettings->handicap.percentIncome / 100;
+	totalIncome += LOCPLINT->cb->getPlayerState(LOCPLINT->playerID)->valOfBonuses(BonusType::RESOURCES_TOWN_MULTIPLYING_BOOST, BonusSubtypeID(GameResID(EGameResID::GOLD))) * towns.size() * playerSettings->handicap.percentIncome / 100;
 
 	for(int i=0; i<7; i++)
 	{
@@ -678,9 +677,9 @@
 
 CKingdHeroList::CKingdHeroList(size_t maxSize, const CreateHeroItemFunctor & onCreateHeroItemCallback)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	title = std::make_shared<CPicture>(ImagePath::builtin("OVTITLE"),16,0);
-	title->colorize(LOCPLINT->playerID);
+	title->setPlayerColor(LOCPLINT->playerID);
 	heroLabel = std::make_shared<CLabel>(150, 10, FONT_MEDIUM, ETextAlignment::CENTER, Colors::WHITE, CGI->generaltexth->overview[0]);
 	skillsLabel = std::make_shared<CLabel>(500, 10, FONT_MEDIUM, ETextAlignment::CENTER, Colors::WHITE, CGI->generaltexth->overview[1]);
 
@@ -722,9 +721,9 @@
 
 CKingdTownList::CKingdTownList(size_t maxSize)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	title = std::make_shared<CPicture>(ImagePath::builtin("OVTITLE"), 16, 0);
-	title->colorize(LOCPLINT->playerID);
+	title->setPlayerColor(LOCPLINT->playerID);
 	townLabel = std::make_shared<CLabel>(146, 10,FONT_MEDIUM, ETextAlignment::CENTER, Colors::WHITE, CGI->generaltexth->overview[3]);
 	garrHeroLabel = std::make_shared<CLabel>(375, 10, FONT_MEDIUM, ETextAlignment::CENTER, Colors::WHITE, CGI->generaltexth->overview[4]);
 	visitHeroLabel = std::make_shared<CLabel>(608, 10, FONT_MEDIUM, ETextAlignment::CENTER, Colors::WHITE, CGI->generaltexth->overview[5]);
@@ -778,7 +777,7 @@
 CTownItem::CTownItem(const CGTownInstance * Town)
 	: town(Town)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	background = std::make_shared<CAnimImage>(AnimationPath::builtin("OVSLOT"), 6);
 	name = std::make_shared<CLabel>(74, 8, FONT_SMALL, ETextAlignment::TOPLEFT, Colors::WHITE, town->getNameTranslated());
 
@@ -789,12 +788,12 @@
 	garr = std::make_shared<CGarrisonInt>(Point(313, 3), 4, Point(232,0), town->getUpperArmy(), town->visitingHero, true, true, CGarrisonInt::ESlotsLayout::TWO_ROWS);
 	heroes = std::make_shared<HeroSlots>(town, Point(244,6), Point(475,6), garr, false);
 
-	size_t iconIndex = town->town->clientInfo.icons[town->hasFort()][town->builded >= CGI->settings()->getInteger(EGameSettings::TOWNS_BUILDINGS_PER_TURN_CAP)];
+	size_t iconIndex = town->getTown()->clientInfo.icons[town->hasFort()][town->built >= LOCPLINT->cb->getSettings().getInteger(EGameSettings::TOWNS_BUILDINGS_PER_TURN_CAP)];
 
 	picture = std::make_shared<CAnimImage>(AnimationPath::builtin("ITPT"), iconIndex, 0, 5, 6);
 	openTown = std::make_shared<LRClickableAreaOpenTown>(Rect(5, 6, 58, 64), town);
 
-	for(size_t i=0; i<town->creatures.size(); i++)
+	for(size_t i=0; i<town->creatures.size() && i<GameConstants::CREATURES_PER_TOWN; i++)
 	{
 		growth.push_back(std::make_shared<CCreaInfo>(Point(401+37*(int)i, 78), town, (int)i, true, true));
 		available.push_back(std::make_shared<CCreaInfo>(Point(48+37*(int)i, 78), town, (int)i, true, false));
@@ -809,18 +808,18 @@
 
 	fastTavern = std::make_shared<LRClickableArea>(Rect(5, 6, 58, 64), [&]()
 	{
-		if(town->builtBuildings.count(BuildingID::TAVERN))
+		if(town->hasBuilt(BuildingID::TAVERN))
 			LOCPLINT->showTavernWindow(town, nullptr, QueryID::NONE);
 	}, [&]{
-		if(!town->town->faction->getDescriptionTranslated().empty())
-			CRClickPopup::createAndPush(town->town->faction->getDescriptionTranslated());
+		if(!town->getTown()->faction->getDescriptionTranslated().empty())
+			CRClickPopup::createAndPush(town->getFaction()->getDescriptionTranslated());
 	});
 	fastMarket = std::make_shared<LRClickableArea>(Rect(153, 6, 65, 64), []()
 	{
 		std::vector<const CGTownInstance*> towns = LOCPLINT->cb->getTownsInfo(true);
 		for(auto & town : towns)
 		{
-			if(town->builtBuildings.count(BuildingID::MARKETPLACE))
+			if(town->hasBuilt(BuildingID::MARKETPLACE))
 			{
 				GH.windows().createAndPushWindow<CMarketWindow>(town, nullptr, nullptr, EMarketMode::RESOURCE_RESOURCE);
 				return;
@@ -855,7 +854,7 @@
 
 	heroes->update();
 
-	for (size_t i=0; i<town->creatures.size(); i++)
+	for (size_t i=0; i<std::min(static_cast<int>(town->creatures.size()), GameConstants::CREATURES_PER_TOWN); i++)
 	{
 		growth[i]->update();
 		available[i]->update();
@@ -868,9 +867,9 @@
 	std::shared_ptr<CAnimImage> background;
 	std::vector<std::shared_ptr<CArtPlace>> arts;
 
-	ArtSlotsTab()
+	ArtSlotsTab(CIntObject * parent)
 	{
-		OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+		OBJECT_CONSTRUCTION_TARGETED(parent);
 		background = std::make_shared<CAnimImage>(AnimationPath::builtin("OVSLOT"), 4);
 		pos = background->pos;
 		for(int i=0; i<9; i++)
@@ -886,9 +885,9 @@
 	std::shared_ptr<CButton> btnLeft;
 	std::shared_ptr<CButton> btnRight;
 
-	BackpackTab()
+	BackpackTab(CIntObject * parent)
 	{
-		OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+		OBJECT_CONSTRUCTION_TARGETED(parent);
 		background = std::make_shared<CAnimImage>(AnimationPath::builtin("OVSLOT"), 5);
 		pos = background->pos;
 		btnLeft = std::make_shared<CButton>(Point(269, 66), AnimationPath::builtin("HSBTNS3"), CButton::tooltip(), 0);
@@ -901,12 +900,12 @@
 CHeroItem::CHeroItem(const CGHeroInstance * Hero)
 	: hero(Hero)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	artTabs.resize(3);
-	auto arts1 = std::make_shared<ArtSlotsTab>();
-	auto arts2 = std::make_shared<ArtSlotsTab>();
-	auto backpack = std::make_shared<BackpackTab>();
+	auto arts1 = std::make_shared<ArtSlotsTab>(this);
+	auto arts2 = std::make_shared<ArtSlotsTab>(this);
+	auto backpack = std::make_shared<BackpackTab>(this);
 	artTabs[0] = arts1;
 	artTabs[1] = arts2;
 	artTabs[2] = backpack;
diff --color -urN vcmi-1.5.7/client/windows/CMapOverview.cpp vcmi/client/windows/CMapOverview.cpp
--- vcmi-1.5.7/client/windows/CMapOverview.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/windows/CMapOverview.cpp	2024-12-19 15:00:22.378126448 +0100
@@ -20,14 +20,11 @@
 #include "../widgets/TextControls.h"
 #include "../windows/GUIClasses.h"
 #include "../windows/InfoWindows.h"
-#include "../render/CAnimation.h"
 #include "../render/Canvas.h"
 #include "../render/IImage.h"
 #include "../render/IRenderHandler.h"
 #include "../render/Graphics.h"
 
-#include "../../lib/CGeneralTextHandler.h"
-#include "../../lib/TextOperations.h"
 #include "../../lib/CConfigHandler.h"
 #include "../../lib/campaign/CampaignState.h"
 #include "../../lib/mapping/CMap.h"
@@ -38,16 +35,17 @@
 #include "../../lib/TerrainHandler.h"
 #include "../../lib/filesystem/Filesystem.h"
 
-#include "../../lib/serializer/CLoadFile.h"
 #include "../../lib/StartInfo.h"
 #include "../../lib/rmg/CMapGenOptions.h"
-#include "../../lib/Languages.h"
+#include "../../lib/serializer/CLoadFile.h"
+#include "../../lib/texts/CGeneralTextHandler.h"
+#include "../../lib/texts/TextOperations.h"
 
-CMapOverview::CMapOverview(std::string mapName, std::string fileName, std::string date, ResourcePath resource, ESelectionScreen tabType)
-	: CWindowObject(BORDERED | RCLICK_POPUP), resource(resource), mapName(mapName), fileName(fileName), date(date), tabType(tabType)
+CMapOverview::CMapOverview(const std::string & mapName, const std::string & fileName, const std::string & date, const std::string & author, const std::string & version, const ResourcePath & resource, ESelectionScreen tabType)
+	: CWindowObject(BORDERED | RCLICK_POPUP), resource(resource), mapName(mapName), fileName(fileName), date(date), author(author), version(version), tabType(tabType)
 {
 
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 
 	widget = std::make_shared<CMapOverviewWidget>(*this);
 
@@ -62,16 +60,16 @@
 
 Canvas CMapOverviewWidget::createMinimapForLayer(std::unique_ptr<CMap> & map, int layer) const
 {
-	Canvas canvas = Canvas(Point(map->width, map->height));
+	Canvas canvas = Canvas(Point(map->width, map->height), CanvasScalingPolicy::IGNORE);
 
 	for (int y = 0; y < map->height; ++y)
 		for (int x = 0; x < map->width; ++x)
 		{
 			TerrainTile & tile = map->getTile(int3(x, y, layer));
 
-			ColorRGBA color = tile.terType->minimapUnblocked;
-			if (tile.blocked && (!tile.visitable))
-				color = tile.terType->minimapBlocked;
+			ColorRGBA color = tile.getTerrain()->minimapUnblocked;
+			if (tile.blocked() && !tile.visitable())
+				color = tile.getTerrain()->minimapBlocked;
 
 			if(drawPlayerElements)
 				// if object at tile is owned - it will be colored as its owner
@@ -136,12 +134,12 @@
 		return nullptr;
 
 	Rect minimapRect = minimaps[id].getRenderArea();
-	double maxSideLenghtSrc = std::max(minimapRect.w, minimapRect.h);
-	double maxSideLenghtDst = std::max(rect.w, rect.h);
-	double resize = maxSideLenghtSrc / maxSideLenghtDst;
+	double maxSideLengthSrc = std::max(minimapRect.w, minimapRect.h);
+	double maxSideLengthDst = std::max(rect.w, rect.h);
+	double resize = maxSideLengthSrc / maxSideLengthDst;
 	Point newMinimapSize = Point(minimapRect.w / resize, minimapRect.h / resize);
 
-	Canvas canvasScaled = Canvas(Point(rect.w, rect.h));
+	Canvas canvasScaled = Canvas(Point(rect.w, rect.h), CanvasScalingPolicy::AUTO);
 	canvasScaled.drawScaled(minimaps[id], Point((rect.w - newMinimapSize.x) / 2, (rect.h - newMinimapSize.y) / 2), newMinimapSize);
 	std::shared_ptr<IImage> img = GH.renderHandler().createImage(canvasScaled.getInternalSurface());
 
@@ -204,6 +202,14 @@
 		else
 			w->setText(p.date);
 	}
+	if(auto w = widget<CLabel>("author"))
+	{
+		w->setText(p.author.empty() ? "-" : p.author);
+	}
+	if(auto w = widget<CLabel>("version"))
+	{
+		w->setText(p.version);
+	}
 	if(auto w = widget<CLabel>("noUnderground"))
 	{
 		if(minimaps.size() == 0)
diff --color -urN vcmi-1.5.7/client/windows/CMapOverview.h vcmi/client/windows/CMapOverview.h
--- vcmi-1.5.7/client/windows/CMapOverview.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/windows/CMapOverview.h	2024-12-19 15:00:22.379126489 +0100
@@ -53,7 +53,9 @@
 	const std::string mapName;
 	const std::string fileName;
 	const std::string date;
+	const std::string author;
+	const std::string version;
 	const ESelectionScreen tabType;
 
-	CMapOverview(std::string mapName, std::string fileName, std::string date, ResourcePath resource, ESelectionScreen tabType);
+	CMapOverview(const std::string & mapName, const std::string & fileName, const std::string & date, const std::string & author, const std::string & version, const ResourcePath & resource, ESelectionScreen tabType);
 };
diff --color -urN vcmi-1.5.7/client/windows/CMarketWindow.cpp vcmi/client/windows/CMarketWindow.cpp
--- vcmi-1.5.7/client/windows/CMarketWindow.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/windows/CMarketWindow.cpp	2024-12-19 15:00:22.380126531 +0100
@@ -27,11 +27,14 @@
 #include "../CGameInfo.h"
 #include "../CPlayerInterface.h"
 
-#include "../../lib/CGeneralTextHandler.h"
+#include "../../lib/entities/building/CBuilding.h"
+#include "../../lib/texts/CGeneralTextHandler.h"
 #include "../../lib/mapObjects/CGTownInstance.h"
 #include "../../lib/mapObjects/CGMarket.h"
 #include "../../lib/mapObjects/CGHeroInstance.h"
 
+#include "../../CCallback.h"
+
 CMarketWindow::CMarketWindow(const IMarket * market, const CGHeroInstance * hero, const std::function<void()> & onWindowClosed, EMarketMode mode)
 	: CWindowObject(PLAYER_COLORED)
 	, windowClosedCallback(onWindowClosed)
@@ -40,7 +43,7 @@
 		mode == EMarketMode::RESOURCE_ARTIFACT || mode == EMarketMode::ARTIFACT_RESOURCE || mode == EMarketMode::ARTIFACT_EXP ||
 		mode == EMarketMode::CREATURE_EXP);
 	
-	OBJECT_CONSTRUCTION_CUSTOM_CAPTURING(255 - DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	if(mode == EMarketMode::RESOURCE_RESOURCE)
 		createMarketResources(market, hero);
@@ -62,24 +65,27 @@
 
 void CMarketWindow::updateArtifacts()
 {
-	assert(marketWidget);
-	marketWidget->update();
+	update();
 }
 
 void CMarketWindow::updateGarrisons()
 {
-	assert(marketWidget);
-	marketWidget->update();
+	update();
 }
 
-void CMarketWindow::updateResource()
+void CMarketWindow::updateResources()
 {
-	assert(marketWidget);
-	marketWidget->update();
+	update();
+}
+
+void CMarketWindow::updateExperience()
+{
+	update();
 }
 
-void CMarketWindow::updateHero()
+void CMarketWindow::update()
 {
+	CWindowWithArtifacts::update();
 	assert(marketWidget);
 	marketWidget->update();
 }
@@ -98,21 +104,6 @@
 	return marketWidget->hero == army;
 }
 
-void CMarketWindow::artifactRemoved(const ArtifactLocation & artLoc)
-{
-	marketWidget->update();
-	CWindowWithArtifacts::artifactRemoved(artLoc);
-}
-
-void CMarketWindow::artifactMoved(const ArtifactLocation & srcLoc, const ArtifactLocation & destLoc, bool withRedraw)
-{
-	if(!getState().has_value())
-		return;
-	CWindowWithArtifacts::artifactMoved(srcLoc, destLoc, withRedraw);
-	assert(marketWidget);
-	marketWidget->update();
-}
-
 void CMarketWindow::createChangeModeButtons(EMarketMode currentMode, const IMarket * market, const CGHeroInstance * hero)
 {
 	auto isButtonVisible = [currentMode, market, hero](EMarketMode modeButton) -> bool
@@ -123,6 +114,11 @@
 		if(!market->allowsTrade(modeButton))
 			return false;
 
+		if(currentMode == EMarketMode::ARTIFACT_EXP && modeButton != EMarketMode::CREATURE_EXP)
+			return false;
+		if(currentMode == EMarketMode::CREATURE_EXP && modeButton != EMarketMode::ARTIFACT_EXP)
+			return false;
+
 		if(modeButton == EMarketMode::RESOURCE_RESOURCE || modeButton == EMarketMode::RESOURCE_PLAYER)
 		{
 			if(const auto town = dynamic_cast<const CGTownInstance*>(market))
@@ -187,33 +183,50 @@
 	redraw();
 }
 
+std::string CMarketWindow::getMarketTitle(const ObjectInstanceID marketId, const EMarketMode mode) const
+{
+	assert(LOCPLINT->cb->getMarket(marketId));
+	assert(vstd::contains(LOCPLINT->cb->getMarket(marketId)->availableModes(), mode));
+
+	if(const auto town = LOCPLINT->cb->getTown(marketId))
+	{
+		for(const auto & buildingId : town->getBuildings())
+		{
+			if(const auto building = town->getTown()->buildings.at(buildingId); vstd::contains(building->marketModes, mode))
+				return building->getNameTranslated();
+		}
+	}
+	return LOCPLINT->cb->getObj(marketId)->getObjectName();
+}
+
 void CMarketWindow::createArtifactsBuying(const IMarket * market, const CGHeroInstance * hero)
 {
-	OBJECT_CONSTRUCTION_CUSTOM_CAPTURING(255 - DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	background = createBg(ImagePath::builtin("TPMRKABS.bmp"), PLAYER_COLORED);
-	marketWidget = std::make_shared<CArtifactsBuying>(market, hero);
+	marketWidget = std::make_shared<CArtifactsBuying>(market, hero, getMarketTitle(market->getObjInstanceID(), EMarketMode::RESOURCE_ARTIFACT));
 	initWidgetInternals(EMarketMode::RESOURCE_ARTIFACT, CGI->generaltexth->zelp[600]);
 }
 
 void CMarketWindow::createArtifactsSelling(const IMarket * market, const CGHeroInstance * hero)
 {
-	OBJECT_CONSTRUCTION_CUSTOM_CAPTURING(255 - DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	background = createBg(ImagePath::builtin("TPMRKASS.bmp"), PLAYER_COLORED);
 	// Create image that copies part of background containing slot MISC_1 into position of slot MISC_5
 	artSlotBack = std::make_shared<CPicture>(background->getSurface(), Rect(20, 187, 47, 47), 0, 0);
 	artSlotBack->moveTo(pos.topLeft() + Point(18, 339));
-	auto artsSellingMarket = std::make_shared<CArtifactsSelling>(market, hero);
+	auto artsSellingMarket = std::make_shared<CArtifactsSelling>(market, hero, getMarketTitle(market->getObjInstanceID(), EMarketMode::ARTIFACT_RESOURCE));
 	artSets.clear();
-	addSetAndCallbacks(artsSellingMarket->getAOHset());
+	const auto heroArts = artsSellingMarket->getAOHset();
+	addSet(heroArts);
 	marketWidget = artsSellingMarket;
-	initWidgetInternals(EMarketMode::ARTIFACT_RESOURCE, CGI->generaltexth->zelp[600]);	
+	initWidgetInternals(EMarketMode::ARTIFACT_RESOURCE, CGI->generaltexth->zelp[600]);
 }
 
 void CMarketWindow::createMarketResources(const IMarket * market, const CGHeroInstance * hero)
 {
-	OBJECT_CONSTRUCTION_CUSTOM_CAPTURING(255 - DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	background = createBg(ImagePath::builtin("TPMRKRES.bmp"), PLAYER_COLORED);
 	marketWidget = std::make_shared<CMarketResources>(market, hero);
@@ -222,7 +235,7 @@
 
 void CMarketWindow::createFreelancersGuild(const IMarket * market, const CGHeroInstance * hero)
 {
-	OBJECT_CONSTRUCTION_CUSTOM_CAPTURING(255 - DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	background = createBg(ImagePath::builtin("TPMRKCRS.bmp"), PLAYER_COLORED);
 	marketWidget = std::make_shared<CFreelancerGuild>(market, hero);
@@ -231,7 +244,7 @@
 
 void CMarketWindow::createTransferResources(const IMarket * market, const CGHeroInstance * hero)
 {
-	OBJECT_CONSTRUCTION_CUSTOM_CAPTURING(255 - DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	background = createBg(ImagePath::builtin("TPMRKPTS.bmp"), PLAYER_COLORED);
 	marketWidget = std::make_shared<CTransferResources>(market, hero);
@@ -240,24 +253,37 @@
 
 void CMarketWindow::createAltarArtifacts(const IMarket * market, const CGHeroInstance * hero)
 {
-	OBJECT_CONSTRUCTION_CUSTOM_CAPTURING(255 - DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	background = createBg(ImagePath::builtin("ALTRART2.bmp"), PLAYER_COLORED);
-	auto altarArtifacts = std::make_shared<CAltarArtifacts>(market, hero);
-	marketWidget = altarArtifacts;
+	auto altarArtifactsStorage = std::make_shared<CAltarArtifacts>(market, hero);
+	marketWidget = altarArtifactsStorage;
 	artSets.clear();
-	addSetAndCallbacks(altarArtifacts->getAOHset());
+	const auto heroArts = altarArtifactsStorage->getAOHset();
+	heroArts->clickPressedCallback = [this, heroArts](const CArtPlace & artPlace, const Point & cursorPosition)
+	{
+		clickPressedOnArtPlace(heroArts->getHero(), artPlace.slot, true, true, false, cursorPosition);
+	};
+	heroArts->showPopupCallback = [this, heroArts](CArtPlace & artPlace, const Point & cursorPosition)
+	{
+		showArtifactAssembling(*heroArts, artPlace, cursorPosition);
+	};
+	heroArts->gestureCallback = [this, heroArts](const CArtPlace & artPlace, const Point & cursorPosition)
+	{
+		showQuickBackpackWindow(heroArts->getHero(), artPlace.slot, cursorPosition);
+	};
+	addSet(heroArts);
 	initWidgetInternals(EMarketMode::ARTIFACT_EXP, CGI->generaltexth->zelp[568]);
-	updateHero();
-	quitButton->addCallback([altarArtifacts](){altarArtifacts->putBackArtifacts();});
+	updateExperience();
+	quitButton->addCallback([altarArtifactsStorage](){altarArtifactsStorage->putBackArtifacts();});
 }
 
 void CMarketWindow::createAltarCreatures(const IMarket * market, const CGHeroInstance * hero)
 {
-	OBJECT_CONSTRUCTION_CUSTOM_CAPTURING(255 - DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	background = createBg(ImagePath::builtin("ALTARMON.bmp"), PLAYER_COLORED);
 	marketWidget = std::make_shared<CAltarCreatures>(market, hero);
 	initWidgetInternals(EMarketMode::CREATURE_EXP, CGI->generaltexth->zelp[568]);
-	updateHero();
+	updateExperience();
 }
diff --color -urN vcmi-1.5.7/client/windows/CMarketWindow.h vcmi/client/windows/CMarketWindow.h
--- vcmi-1.5.7/client/windows/CMarketWindow.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/windows/CMarketWindow.h	2024-12-19 15:00:22.381126572 +0100
@@ -12,22 +12,22 @@
 #include "../widgets/markets/CMarketBase.h"
 #include "CWindowWithArtifacts.h"
 
-class CMarketWindow : public CStatusbarWindow, public CWindowWithArtifacts, public IGarrisonHolder
+class CMarketWindow final : public CStatusbarWindow, public CWindowWithArtifacts, public IGarrisonHolder, public IMarketHolder
 {
 public:
 	CMarketWindow(const IMarket * market, const CGHeroInstance * hero, const std::function<void()> & onWindowClosed, EMarketMode mode);
-	void updateResource();
-	void updateArtifacts();
+	void updateResources() override;
+	void updateArtifacts() override;
 	void updateGarrisons() override;
-	void updateHero();
+	void updateExperience() override;
+	void update() override;
 	void close() override;
 	bool holdsGarrison(const CArmedInstance * army) override;
-	void artifactRemoved(const ArtifactLocation & artLoc) override;
-	void artifactMoved(const ArtifactLocation & srcLoc, const ArtifactLocation & destLoc, bool withRedraw) override;
 
 private:
 	void createChangeModeButtons(EMarketMode currentMode, const IMarket * market, const CGHeroInstance * hero);
 	void initWidgetInternals(const EMarketMode mode, const std::pair<std::string, std::string> & quitButtonHelpContainer);
+	std::string getMarketTitle(const ObjectInstanceID marketId, const EMarketMode mode) const;
 
 	void createArtifactsBuying(const IMarket * market, const CGHeroInstance * hero);
 	void createArtifactsSelling(const IMarket * market, const CGHeroInstance * hero);
diff --color -urN vcmi-1.5.7/client/windows/CMessage.cpp vcmi/client/windows/CMessage.cpp
--- vcmi-1.5.7/client/windows/CMessage.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/windows/CMessage.cpp	2024-12-19 15:00:22.381126572 +0100
@@ -11,8 +11,6 @@
 #include "StdInc.h"
 #include "CMessage.h"
 
-#include "../../lib/TextOperations.h"
-
 #include "../gui/CGuiHandler.h"
 #include "../render/CAnimation.h"
 #include "../render/Canvas.h"
@@ -27,6 +25,8 @@
 #include "../widgets/TextControls.h"
 #include "../windows/InfoWindows.h"
 
+#include "../../lib/texts/TextOperations.h"
+
 constexpr int RIGHT_CLICK_POPUP_MIN_SIZE = 100;
 constexpr int SIDE_MARGIN = 11;
 constexpr int TOP_MARGIN = 20;
@@ -41,8 +41,7 @@
 {
 	for(int i = 0; i < PlayerColor::PLAYER_LIMIT_I; i++)
 	{
-		dialogBorders[i] = GH.renderHandler().loadAnimation(AnimationPath::builtin("DIALGBOX"));
-		dialogBorders[i]->preload();
+		dialogBorders[i] = GH.renderHandler().loadAnimation(AnimationPath::builtin("DIALGBOX"), EImageBlitMode::COLORKEY);
 
 		for(int j = 0; j < dialogBorders[i]->size(0); j++)
 		{
@@ -71,23 +70,24 @@
 
 	boost::algorithm::trim_right_if(text, boost::algorithm::is_any_of(std::string(" ")));
 
+	const auto & fontPtr = GH.renderHandler().loadFont(font);
+
 	// each iteration generates one output line
 	while(text.length())
 	{
-		ui32 lineWidth = 0; //in characters or given char metric
 		ui32 wordBreak = -1; //last position for line break (last space character)
 		ui32 currPos = 0; //current position in text
 		bool opened = false; //set to true when opening brace is found
 		std::string color; //color found
 
 		size_t symbolSize = 0; // width of character, in bytes
-		size_t glyphWidth = 0; // width of printable glyph, pixels
+
+		std::string printableString;
 
 		// loops till line is full or end of text reached
-		while(currPos < text.length() && text[currPos] != 0x0a && lineWidth < maxLineWidth)
+		while(currPos < text.length() && text[currPos] != 0x0a && fontPtr->getStringWidth(printableString) <= maxLineWidth)
 		{
 			symbolSize = TextOperations::getUnicodeCharacterSize(text[currPos]);
-			glyphWidth = graphics->fonts[font]->getGlyphWidth(text.data() + currPos);
 
 			// candidate for line break
 			if(ui8(text[currPos]) <= ui8(' '))
@@ -117,15 +117,23 @@
 				color = "";
 			}
 			else
-				lineWidth += glyphWidth;
+				printableString.append(text.data() + currPos, symbolSize);
 			currPos += symbolSize;
 		}
 
-		// long line, create line break
+		// not all line has been processed - it turned out to be too long, so erase everything after last word break
+		// if string consists from a single word (or this is Chinese/Korean) - erase only last symbol to bring line back to allowed length
 		if(currPos < text.length() && (text[currPos] != 0x0a))
 		{
 			if(wordBreak != ui32(-1))
+			{
 				currPos = wordBreak;
+				if(boost::count(text.substr(0, currPos), '{') == boost::count(text.substr(0, currPos), '}'))
+				{
+					opened = false;
+					color = "";
+				}
+			}
 			else
 				currPos -= symbolSize;
 		}
@@ -176,9 +184,9 @@
 std::string CMessage::guessHeader(const std::string & msg)
 {
 	size_t begin = 0;
-	std::string delimeters = "{}";
-	size_t start = msg.find_first_of(delimeters[0], begin);
-	size_t end = msg.find_first_of(delimeters[1], start);
+	std::string delimiters = "{}";
+	size_t start = msg.find_first_of(delimiters[0], begin);
+	size_t end = msg.find_first_of(delimiters[1], start);
 	if(start > msg.size() || end > msg.size())
 		return "";
 	return msg.substr(begin, end);
@@ -186,9 +194,9 @@
 
 int CMessage::guessHeight(const std::string & txt, int width, EFonts font)
 {
-	const auto f = graphics->fonts[font];
+	const auto & fontPtr = GH.renderHandler().loadFont(font);
 	const auto lines = CMessage::breakText(txt, width, font);
-	size_t lineHeight = f->getLineHeight();
+	size_t lineHeight = fontPtr->getLineHeight();
 	return lineHeight * lines.size();
 }
 
diff --color -urN vcmi-1.5.7/client/windows/CPuzzleWindow.cpp vcmi/client/windows/CPuzzleWindow.cpp
--- vcmi-1.5.7/client/windows/CPuzzleWindow.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/windows/CPuzzleWindow.cpp	2024-12-19 15:00:22.383126655 +0100
@@ -11,20 +11,21 @@
 #include "CPuzzleWindow.h"
 
 #include "../CGameInfo.h"
-#include "../CMusicHandler.h"
 #include "../CPlayerInterface.h"
 #include "../adventureMap/CResDataBar.h"
 #include "../gui/CGuiHandler.h"
 #include "../gui/TextAlignment.h"
 #include "../gui/Shortcut.h"
 #include "../mapView/MapView.h"
+#include "../media/ISoundPlayer.h"
 #include "../widgets/Buttons.h"
 #include "../widgets/Images.h"
 #include "../widgets/TextControls.h"
 
 #include "../../CCallback.h"
-#include "../../lib/CGeneralTextHandler.h"
-#include "../../lib/CTownHandler.h"
+#include "../../lib/entities/faction/CFaction.h"
+#include "../../lib/entities/faction/CTownHandler.h"
+#include "../../lib/texts/CGeneralTextHandler.h"
 #include "../../lib/StartInfo.h"
 
 CPuzzleWindow::CPuzzleWindow(const int3 & GrailPos, double discoveredRatio)
@@ -32,7 +33,7 @@
 	grailPos(GrailPos),
 	currentAlpha(ColorRGBA::ALPHA_OPAQUE)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	CCS->soundh->playSound(soundBase::OBELISK);
 
@@ -53,7 +54,7 @@
 	{
 		const SPuzzleInfo & info = elem;
 
-		auto piece = std::make_shared<CPicture>(info.filename, info.x, info.y);
+		auto piece = std::make_shared<CPicture>(info.filename, info.position.x, info.position.y);
 
 		//piece that will slowly disappear
 		if(info.whenUncovered <= GameConstants::PUZZLE_MAP_PIECES * discoveredRatio)
diff --color -urN vcmi-1.5.7/client/windows/CQuestLog.cpp vcmi/client/windows/CQuestLog.cpp
--- vcmi-1.5.7/client/windows/CQuestLog.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/windows/CQuestLog.cpp	2024-12-19 15:00:22.384126696 +0100
@@ -27,8 +27,7 @@
 #include "../../lib/CArtHandler.h"
 #include "../../lib/CConfigHandler.h"
 #include "../../lib/gameState/QuestInfo.h"
-#include "../../lib/CGeneralTextHandler.h"
-#include "../../lib/MetaString.h"
+#include "../../lib/texts/CGeneralTextHandler.h"
 #include "../../lib/mapObjects/CQuest.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
@@ -74,12 +73,12 @@
 
 void CQuestMinimap::addQuestMarks (const QuestInfo * q)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	icons.clear();
 
 	int3 tile;
 	if (q->obj)
-		tile = q->obj->pos;
+		tile = q->obj->visitablePos();
 	else
 		tile = q->tile;
 
@@ -105,7 +104,7 @@
 void CQuestMinimap::iconClicked()
 {
 	if(currentQuest->obj)
-		adventureInt->centerOnTile(currentQuest->obj->pos);
+		adventureInt->centerOnTile(currentQuest->obj->visitablePos());
 	//moveAdvMapSelection();
 }
 
@@ -123,13 +122,13 @@
 	hideComplete(false),
 	quests(Quests)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	minimap = std::make_shared<CQuestMinimap>(Rect(12, 12, 169, 169));
 	// TextBox have it's own 4 pixel padding from top at least for English. To achieve 10px from both left and top only add 6px margin
 	description = std::make_shared<CTextBox>("", Rect(205, 18, 385, DESCRIPTION_HEIGHT_MAX), CSlider::BROWN, FONT_MEDIUM, ETextAlignment::TOPLEFT, Colors::WHITE);
 	ok = std::make_shared<CButton>(Point(539, 398), AnimationPath::builtin("IOKAY.DEF"), CGI->generaltexth->zelp[445], std::bind(&CQuestLog::close, this), EShortcut::GLOBAL_RETURN);
-	// Both button and lable are shifted to -2px by x and y to not make them actually look like they're on same line with quests list and ok button
+	// Both button and label are shifted to -2px by x and y to not make them actually look like they're on same line with quests list and ok button
 	hideCompleteButton = std::make_shared<CToggleButton>(Point(10, 396), AnimationPath::builtin("sysopchk.def"), CButton::tooltipLocalized("vcmi.questLog.hideComplete"), std::bind(&CQuestLog::toggleComplete, this, _1));
 	hideCompleteLabel = std::make_shared<CLabel>(46, 398, FONT_MEDIUM, ETextAlignment::TOPLEFT, Colors::WHITE, CGI->generaltexth->translate("vcmi.questLog.hideComplete.hover"));
 	slider = std::make_shared<CSlider>(Point(166, 195), 191, std::bind(&CQuestLog::sliderMoved, this, _1), QUEST_COUNT, 0, 0, Orientation::VERTICAL, CSlider::BROWN);
@@ -141,7 +140,7 @@
 
 void CQuestLog::recreateLabelList()
 {
-	OBJECT_CONSTRUCTION_CUSTOM_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	labels.clear();
 
 	bool completeMissing = true;
@@ -293,7 +292,7 @@
 				break;
 		}*/
 
-		OBJECT_CONSTRUCTION_CUSTOM_CAPTURING(255-DISPOSE);
+		OBJECT_CONSTRUCTION;
 
 		std::vector<std::shared_ptr<CComponent>> comps;
 		for(auto & component : components)
diff --color -urN vcmi-1.5.7/client/windows/CreaturePurchaseCard.cpp vcmi/client/windows/CreaturePurchaseCard.cpp
--- vcmi-1.5.7/client/windows/CreaturePurchaseCard.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/windows/CreaturePurchaseCard.cpp	2024-12-19 15:00:22.390126944 +0100
@@ -50,12 +50,12 @@
 
 void CreaturePurchaseCard::switchCreatureLevel()
 {
-	OBJECT_CONSTRUCTION_CAPTURING(ACTIVATE + DEACTIVATE + UPDATE + SHOWALL + SHARE_POS);
+	OBJECT_CONSTRUCTION;
 	auto index = vstd::find_pos(upgradesID, creatureOnTheCard->getId());
 	auto nextCreatureId = vstd::circularAt(upgradesID, ++index);
 	creatureOnTheCard = nextCreatureId.toCreature();
-	picture = std::make_shared<CCreaturePic>(parent->pos.x, parent->pos.y, creatureOnTheCard);
-	creatureClickArea = std::make_shared<CCreatureClickArea>(Point(parent->pos.x, parent->pos.y), picture, creatureOnTheCard);
+	picture = std::make_shared<CCreaturePic>(picture->pos.x - pos.x, picture->pos.y - pos.y, creatureOnTheCard);
+	creatureClickArea = std::make_shared<CCreatureClickArea>(Point(picture->pos.x - pos.x, picture->pos.y - pos.y), picture, creatureOnTheCard);
 	parent->updateAllSliders();
 	cost->set(creatureOnTheCard->getFullRecruitCost() * slider->getValue());
 }
diff --color -urN vcmi-1.5.7/client/windows/CreaturePurchaseCard.h vcmi/client/windows/CreaturePurchaseCard.h
--- vcmi-1.5.7/client/windows/CreaturePurchaseCard.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/windows/CreaturePurchaseCard.h	2024-12-19 15:00:22.391126985 +0100
@@ -44,7 +44,7 @@
 	void initCostBox();
 
 	// This just wraps a clickeable area. There's a weird layout scheme in the file and
-	// it's easier to just add a separate invisble box on top
+	// it's easier to just add a separate invisible box on top
 	class CCreatureClickArea : public CIntObject
 	{
 	public:
diff --color -urN vcmi-1.5.7/client/windows/CSpellWindow.cpp vcmi/client/windows/CSpellWindow.cpp
--- vcmi-1.5.7/client/windows/CSpellWindow.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/windows/CSpellWindow.cpp	2024-12-19 15:00:22.386126779 +0100
@@ -19,27 +19,25 @@
 #include "../CGameInfo.h"
 #include "../CPlayerInterface.h"
 #include "../PlayerLocalState.h"
-#include "../CVideoHandler.h"
 
 #include "../battle/BattleInterface.h"
 #include "../gui/CGuiHandler.h"
 #include "../gui/Shortcut.h"
 #include "../gui/WindowHandler.h"
+#include "../media/IVideoPlayer.h"
 #include "../widgets/GraphicalPrimitiveCanvas.h"
 #include "../widgets/CComponent.h"
 #include "../widgets/CTextInput.h"
 #include "../widgets/TextControls.h"
+#include "../widgets/Buttons.h"
+#include "../widgets/VideoWidget.h"
 #include "../adventureMap/AdventureMapInterface.h"
-#include "../render/CAnimation.h"
-#include "../render/IRenderHandler.h"
-#include "../render/IImage.h"
-#include "../render/IImageLoader.h"
-#include "../render/Canvas.h"
+#include "../render/AssetGenerator.h"
 
 #include "../../CCallback.h"
 
 #include "../../lib/CConfigHandler.h"
-#include "../../lib/CGeneralTextHandler.h"
+#include "../../lib/texts/CGeneralTextHandler.h"
 #include "../../lib/spells/CSpellHandler.h"
 #include "../../lib/spells/ISpellMechanics.h"
 #include "../../lib/spells/Problem.h"
@@ -98,13 +96,15 @@
 	}
 };
 
-CSpellWindow::CSpellWindow(const CGHeroInstance * _myHero, CPlayerInterface * _myInt, bool openOnBattleSpells):
+CSpellWindow::CSpellWindow(const CGHeroInstance * _myHero, CPlayerInterface * _myInt, bool openOnBattleSpells, const std::function<void(SpellID)> & onSpellSelect):
 	CWindowObject(PLAYER_COLORED | (settings["gameTweaks"]["enableLargeSpellbook"].Bool() ? BORDERED : 0)),
 	battleSpellsOnly(openOnBattleSpells),
 	selectedTab(4),
 	currentPage(0),
 	myHero(_myHero),
 	myInt(_myInt),
+	openOnBattleSpells(openOnBattleSpells),
+	onSpellSelect(onSpellSelect),
 	isBigSpellbook(settings["gameTweaks"]["enableLargeSpellbook"].Bool()),
 	spellsPerPage(24),
 	offL(-11),
@@ -113,11 +113,12 @@
 	offT(-37),
 	offB(56)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	if(isBigSpellbook)
 	{
-		background = std::make_shared<CPicture>(createBigSpellBook(), Point(0, 0));
+		AssetGenerator::createBigSpellBook();
+		background = std::make_shared<CPicture>(ImagePath::builtin("SpellBookLarge"), 0, 0);
 		updateShadow();
 	}
 	else
@@ -129,9 +130,9 @@
 
 	pos = background->center(Point(pos.w/2 + pos.x, pos.h/2 + pos.y));
 
+	Rect r(90, isBigSpellbook ? 480 : 420, isBigSpellbook ? 160 : 110, 16);
 	if(settings["general"]["enableUiEnhancements"].Bool())
 	{
-		Rect r(90, isBigSpellbook ? 480 : 420, isBigSpellbook ? 160 : 110, 16);
 		const ColorRGBA rectangleColor = ColorRGBA(0, 0, 0, 75);
 		const ColorRGBA borderColor = ColorRGBA(128, 100, 75);
 		const ColorRGBA grayedColor = ColorRGBA(158, 130, 105);
@@ -142,6 +143,13 @@
 		searchBox->setCallback(std::bind(&CSpellWindow::searchInput, this));
 	}
 
+	if(onSpellSelect)
+	{
+		Point boxPos = r.bottomLeft() + Point(-2, 5);
+		showAllSpells = std::make_shared<CToggleButton>(boxPos, AnimationPath::builtin("sysopchk.def"), CButton::tooltip(CGI->generaltexth->translate("core.help.458.hover"), CGI->generaltexth->translate("core.help.458.hover")), [this](bool state){ searchInput(); });
+		showAllSpellsDescription = std::make_shared<CLabel>(boxPos.x + 40, boxPos.y + 12, FONT_SMALL, ETextAlignment::CENTERLEFT, Colors::WHITE, CGI->generaltexth->translate("core.help.458.hover"));
+	}
+
 	processSpells();
 
 	//numbers of spell pages computed
@@ -149,18 +157,9 @@
 	leftCorner = std::make_shared<CPicture>(ImagePath::builtin("SpelTrnL.bmp"), 97 + offL, 77 + offT);
 	rightCorner = std::make_shared<CPicture>(ImagePath::builtin("SpelTrnR.bmp"), 487 + offR, 72 + offT);
 
-	spellIcons = GH.renderHandler().loadAnimation(AnimationPath::builtin("Spells"));
-
 	schoolTab = std::make_shared<CAnimImage>(AnimationPath::builtin("SpelTab"), selectedTab, 0, 524 + offR, 88);
 	schoolPicture = std::make_shared<CAnimImage>(AnimationPath::builtin("Schools"), 0, 0, 117 + offL, 74 + offT);
 
-	schoolBorders[0] = GH.renderHandler().loadAnimation(AnimationPath::builtin("SplevA.def"));
-	schoolBorders[1] = GH.renderHandler().loadAnimation(AnimationPath::builtin("SplevF.def"));
-	schoolBorders[2] = GH.renderHandler().loadAnimation(AnimationPath::builtin("SplevW.def"));
-	schoolBorders[3] = GH.renderHandler().loadAnimation(AnimationPath::builtin("SplevE.def"));
-
-	for(auto item : schoolBorders)
-		item->preload();
 	mana = std::make_shared<CLabel>(435 + (isBigSpellbook ? 159 : 0), 426 + offB, FONT_SMALL, ETextAlignment::CENTER, Colors::YELLOW, std::to_string(myHero->mana));
 
 	if(isBigSpellbook)
@@ -207,9 +206,9 @@
 		}
 	}
 
-	selectedTab = battleSpellsOnly ? myInt->localState->spellbookSettings.spellbookLastTabBattle : myInt->localState->spellbookSettings.spellbookLastTabAdvmap;
+	selectedTab = battleSpellsOnly ? myInt->localState->getSpellbookSettings().spellbookLastTabBattle : myInt->localState->getSpellbookSettings().spellbookLastTabAdvmap;
 	schoolTab->setFrame(selectedTab, 0);
-	int cp = battleSpellsOnly ? myInt->localState->spellbookSettings.spellbookLastPageBattle : myInt->localState->spellbookSettings.spellbookLastPageAdvmap;
+	int cp = battleSpellsOnly ? myInt->localState->getSpellbookSettings().spellbookLastPageBattle : myInt->localState->getSpellbookSettings().spellbookLastPageAdvmap;
 	// spellbook last page battle index is not reset after battle, so this needs to stay here
 	vstd::abetween(cp, 0, std::max(0, pagesWithinCurrentTab() - 1));
 	setCurrentPage(cp);
@@ -221,55 +220,6 @@
 {
 }
 
-std::shared_ptr<IImage> CSpellWindow::createBigSpellBook()
-{
-	std::shared_ptr<IImage> img = GH.renderHandler().loadImage(ImagePath::builtin("SpelBack"));
-	Canvas canvas = Canvas(Point(800, 600));
-	// edges
-	canvas.draw(img, Point(0, 0), Rect(15, 38, 90, 45));
-	canvas.draw(img, Point(0, 460), Rect(15, 400, 90, 141));
-	canvas.draw(img, Point(705, 0), Rect(509, 38, 95, 45));
-	canvas.draw(img, Point(705, 460), Rect(509, 400, 95, 141));
-	// left / right
-	Canvas tmp1 = Canvas(Point(90, 355 - 45));
-	tmp1.draw(img, Point(0, 0), Rect(15, 38 + 45, 90, 355 - 45));
-	canvas.drawScaled(tmp1, Point(0, 45), Point(90, 415));
-	Canvas tmp2 = Canvas(Point(95, 355 - 45));
-	tmp2.draw(img, Point(0, 0), Rect(509, 38 + 45, 95, 355 - 45));
-	canvas.drawScaled(tmp2, Point(705, 45), Point(95, 415));
-	// top / bottom
-	Canvas tmp3 = Canvas(Point(409, 45));
-	tmp3.draw(img, Point(0, 0), Rect(100, 38, 409, 45));
-	canvas.drawScaled(tmp3, Point(90, 0), Point(615, 45));
-	Canvas tmp4 = Canvas(Point(409, 141));
-	tmp4.draw(img, Point(0, 0), Rect(100, 400, 409, 141));
-	canvas.drawScaled(tmp4, Point(90, 460), Point(615, 141));
-	// middle
-	Canvas tmp5 = Canvas(Point(409, 141));
-	tmp5.draw(img, Point(0, 0), Rect(100, 38 + 45, 509 - 15, 400 - 38));
-	canvas.drawScaled(tmp5, Point(90, 45), Point(615, 415));
-	// carpet
-	Canvas tmp6 = Canvas(Point(590, 59));
-	tmp6.draw(img, Point(0, 0), Rect(15, 484, 590, 59));
-	canvas.drawScaled(tmp6, Point(0, 545), Point(800, 59));
-	// remove bookmarks
-	for (int i = 0; i < 56; i++)
-		canvas.draw(Canvas(canvas, Rect(i < 30 ? 268 : 327, 464, 1, 46)), Point(269 + i, 464));
-	for (int i = 0; i < 56; i++)
-		canvas.draw(Canvas(canvas, Rect(469, 464, 1, 42)), Point(470 + i, 464));
-	for (int i = 0; i < 57; i++)
-		canvas.draw(Canvas(canvas, Rect(i < 30 ? 564 : 630, 464, 1, 44)), Point(565 + i, 464));
-	for (int i = 0; i < 56; i++)
-		canvas.draw(Canvas(canvas, Rect(656, 464, 1, 47)), Point(657 + i, 464));
-	// draw bookmarks
-	canvas.draw(img, Point(278, 464), Rect(220, 405, 37, 47));
-	canvas.draw(img, Point(481, 465), Rect(354, 406, 37, 41));
-	canvas.draw(img, Point(575, 465), Rect(417, 406, 37, 45));
-	canvas.draw(img, Point(667, 465), Rect(478, 406, 37, 47));
-
-	return GH.renderHandler().createImage(canvas.getInternalSurface());
-}
-
 void CSpellWindow::searchInput()
 {
 	if(searchBox)
@@ -290,11 +240,19 @@
 
 	//initializing castable spells
 	mySpells.reserve(CGI->spellh->objects.size());
-	for(const CSpell * spell : CGI->spellh->objects)
+	for(auto const & spell : CGI->spellh->objects)
 	{
 		bool searchTextFound = !searchBox || boost::algorithm::contains(boost::algorithm::to_lower_copy(spell->getNameTranslated()), boost::algorithm::to_lower_copy(searchBox->getText()));
-		if(!spell->isCreatureAbility() && myHero->canCastThisSpell(spell) && searchTextFound)
-			mySpells.push_back(spell);
+
+		if(onSpellSelect)
+		{
+			if(spell->isCombat() == openOnBattleSpells && !spell->isSpecial() && !spell->isCreatureAbility() && searchTextFound && (showAllSpells->isSelected() || myHero->canCastThisSpell(spell.get())))
+				mySpells.push_back(spell.get());
+			continue;
+		}
+
+		if(!spell->isCreatureAbility() && myHero->canCastThisSpell(spell.get()) && searchTextFound)
+			mySpells.push_back(spell.get());
 	}
 
 	SpellbookSpellSorter spellsorter;
@@ -356,8 +314,21 @@
 
 void CSpellWindow::fexitb()
 {
-	(myInt->battleInt ? myInt->localState->spellbookSettings.spellbookLastTabBattle : myInt->localState->spellbookSettings.spellbookLastTabAdvmap) = selectedTab;
-	(myInt->battleInt ? myInt->localState->spellbookSettings.spellbookLastPageBattle : myInt->localState->spellbookSettings.spellbookLastPageAdvmap) = currentPage;
+	auto spellBookState = myInt->localState->getSpellbookSettings();
+	if(myInt->battleInt)
+	{
+		spellBookState.spellbookLastTabBattle = selectedTab;
+		spellBookState.spellbookLastPageBattle = currentPage;
+	}
+	else
+	{
+		spellBookState.spellbookLastTabAdvmap = selectedTab;
+		spellBookState.spellbookLastPageAdvmap = currentPage;
+	}
+	myInt->localState->setSpellbookSettings(spellBookState);
+
+	if(onSpellSelect)
+		onSpellSelect(SpellID::NONE);
 
 	close();
 }
@@ -425,6 +396,8 @@
 
 void CSpellWindow::show(Canvas & to)
 {
+	if(video)
+		video->show(to);
 	statusBar->show(to);
 }
 
@@ -523,14 +496,22 @@
 
 void CSpellWindow::turnPageLeft()
 {
+	OBJECT_CONSTRUCTION;
 	if(settings["video"]["spellbookAnimation"].Bool() && !isBigSpellbook)
-		CCS->videoh->openAndPlayVideo(VideoPath::builtin("PGTRNLFT.SMK"), pos.x+13, pos.y+15, EVideoType::SPELLBOOK);
+		video = std::make_shared<VideoWidgetOnce>(Point(13, 14), VideoPath::builtin("PGTRNLFT.SMK"), false, this);
 }
 
 void CSpellWindow::turnPageRight()
 {
+	OBJECT_CONSTRUCTION;
 	if(settings["video"]["spellbookAnimation"].Bool() && !isBigSpellbook)
-		CCS->videoh->openAndPlayVideo(VideoPath::builtin("PGTRNRGH.SMK"), pos.x+13, pos.y+15, EVideoType::SPELLBOOK);
+		video = std::make_shared<VideoWidgetOnce>(Point(13, 14), VideoPath::builtin("PGTRNRGH.SMK"), false, this);
+}
+
+void CSpellWindow::onVideoPlaybackFinished()
+{
+	video.reset();
+	redraw();
 }
 
 void CSpellWindow::keyPressed(EShortcut key)
@@ -583,9 +564,9 @@
 	schoolLevel = -1;
 	mySpell = nullptr;
 
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 
-	image = std::make_shared<CAnimImage>(owner->spellIcons, 0, 0);
+	image = std::make_shared<CAnimImage>(AnimationPath::builtin("Spells"), 0, 0);
 	image->visible = false;
 
 	name = std::make_shared<CLabel>(39, 70, FONT_TINY, ETextAlignment::CENTER);
@@ -602,6 +583,13 @@
 {
 	if(mySpell)
 	{
+		if(owner->onSpellSelect)
+		{
+			owner->onSpellSelect(mySpell->id);
+			owner->close();
+			return;
+		}
+
 		auto spellCost = owner->myInt->cb->getSpellCost(mySpell, owner->myHero);
 		if(spellCost > owner->myHero->mana) //insufficient mana
 		{
@@ -652,8 +640,10 @@
 
 			auto guard = vstd::makeScopeGuard([this]()
 			{
-				owner->myInt->localState->spellbookSettings.spellbookLastTabAdvmap = owner->selectedTab;
-				owner->myInt->localState->spellbookSettings.spellbookLastPageAdvmap = owner->currentPage;
+				auto spellBookState = owner->myInt->localState->getSpellbookSettings();
+				spellBookState.spellbookLastTabAdvmap = owner->selectedTab;
+				spellBookState.spellbookLastPageAdvmap = owner->currentPage;
+				owner->myInt->localState->setSpellbookSettings(spellBookState);
 			});
 
 			spells::detail::ProblemImpl problem;
@@ -726,19 +716,27 @@
 		image->visible = true;
 
 		{
-			OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+			OBJECT_CONSTRUCTION;
+
+			static const std::array schoolBorders = {
+				AnimationPath::builtin("SplevA.def"),
+				AnimationPath::builtin("SplevF.def"),
+				AnimationPath::builtin("SplevW.def"),
+				AnimationPath::builtin("SplevE.def")
+			};
+
 			schoolBorder.reset();
 			if (owner->selectedTab >= 4)
 			{
 				if (whichSchool.getNum() != SpellSchool())
-					schoolBorder = std::make_shared<CAnimImage>(owner->schoolBorders.at(whichSchool.getNum()), schoolLevel);
+					schoolBorder = std::make_shared<CAnimImage>(schoolBorders.at(whichSchool.getNum()), schoolLevel);
 			}
 			else
-				schoolBorder = std::make_shared<CAnimImage>(owner->schoolBorders.at(owner->selectedTab), schoolLevel);
+				schoolBorder = std::make_shared<CAnimImage>(schoolBorders.at(owner->selectedTab), schoolLevel);
 		}
 
 		ColorRGBA firstLineColor, secondLineColor;
-		if(spellCost > owner->myHero->mana) //hero cannot cast this spell
+		if(spellCost > owner->myHero->mana && !owner->onSpellSelect) //hero cannot cast this spell
 		{
 			firstLineColor = Colors::WHITE;
 			secondLineColor = Colors::ORANGE;
diff --color -urN vcmi-1.5.7/client/windows/CSpellWindow.h vcmi/client/windows/CSpellWindow.h
--- vcmi-1.5.7/client/windows/CSpellWindow.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/windows/CSpellWindow.h	2024-12-19 15:00:22.387126820 +0100
@@ -10,6 +10,7 @@
 #pragma once
 
 #include "CWindowObject.h"
+#include "../widgets/IVideoHolder.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
@@ -19,7 +20,6 @@
 VCMI_LIB_NAMESPACE_END
 
 class IImage;
-class CAnimation;
 class CAnimImage;
 class CPicture;
 class CLabel;
@@ -28,9 +28,11 @@
 class CSpellWindow;
 class CTextInput;
 class TransparentFilledRectangle;
+class CToggleButton;
+class VideoWidgetOnce;
 
 /// The spell window
-class CSpellWindow : public CWindowObject
+class CSpellWindow : public CWindowObject, public IVideoHolder
 {
 	class SpellArea : public CIntObject
 	{
@@ -67,9 +69,6 @@
 		InteractiveArea(const Rect &myRect, std::function<void()> funcL, int helpTextId, CSpellWindow * _owner);
 	};
 
-	std::shared_ptr<CAnimation> spellIcons;
-	std::array<std::shared_ptr<CAnimation>, 4> schoolBorders; //[0]: air, [1]: fire, [2]: water, [3]: earth
-
 	std::shared_ptr<CPicture> leftCorner;
 	std::shared_ptr<CPicture> rightCorner;
 
@@ -86,6 +85,11 @@
 	std::shared_ptr<TransparentFilledRectangle> searchBoxRectangle;
 	std::shared_ptr<CLabel> searchBoxDescription;
 
+	std::shared_ptr<CToggleButton> showAllSpells;
+	std::shared_ptr<CLabel> showAllSpellsDescription;
+
+	std::shared_ptr<VideoWidgetOnce> video;
+
 	bool isBigSpellbook;
 	int spellsPerPage;
 	int offL;
@@ -113,10 +117,13 @@
 	void turnPageLeft();
 	void turnPageRight();
 
-	std::shared_ptr<IImage> createBigSpellBook();
+	void onVideoPlaybackFinished() override;
+
+	bool openOnBattleSpells;
+	std::function<void(SpellID)> onSpellSelect; //external processing of selected spell
 
 public:
-	CSpellWindow(const CGHeroInstance * _myHero, CPlayerInterface * _myInt, bool openOnBattleSpells = true);
+	CSpellWindow(const CGHeroInstance * _myHero, CPlayerInterface * _myInt, bool openOnBattleSpells = true, const std::function<void(SpellID)> & onSpellSelect = nullptr);
 	~CSpellWindow();
 
 	void fexitb();
diff --color -urN vcmi-1.5.7/client/windows/CTutorialWindow.cpp vcmi/client/windows/CTutorialWindow.cpp
--- vcmi-1.5.7/client/windows/CTutorialWindow.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/windows/CTutorialWindow.cpp	2024-12-19 15:00:22.387126820 +0100
@@ -13,10 +13,9 @@
 #include "../eventsSDL/InputHandler.h"
 #include "../../lib/CConfigHandler.h"
 #include "../ConditionalWait.h"
-#include "../../lib/CGeneralTextHandler.h"
+#include "../../lib/texts/CGeneralTextHandler.h"
 #include "../CPlayerInterface.h"
 #include "../CGameInfo.h"
-#include "../CVideoHandler.h"
 
 #include "../gui/CGuiHandler.h"
 #include "../gui/Shortcut.h"
@@ -24,12 +23,13 @@
 #include "../widgets/Images.h"
 #include "../widgets/Buttons.h"
 #include "../widgets/TextControls.h"
+#include "../widgets/VideoWidget.h"
 #include "../render/Canvas.h"
 
 CTutorialWindow::CTutorialWindow(const TutorialMode & m)
 	: CWindowObject(BORDERED, ImagePath::builtin("DIBOXBCK")), mode { m }, page { 0 }
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 
 	pos = Rect(pos.x, pos.y, 380, 400); //video: 320x240
 	background = std::make_shared<CFilledTexture>(ImagePath::builtin("DIBOXBCK"), Rect(0, 0, pos.w, pos.h));
@@ -54,7 +54,10 @@
 
 void CTutorialWindow::setContent()
 {
-	video = "tutorial/" + videos[page];
+	OBJECT_CONSTRUCTION;
+	auto video = VideoPath::builtin("tutorial/" + videos[page]);
+
+	videoPlayer = std::make_shared<VideoWidget>(Point(30, 120), video, false);
 
 	buttonLeft->block(page<1);
 	buttonRight->block(page>videos.size() - 2);
@@ -64,7 +67,7 @@
 
 void CTutorialWindow::openWindowFirstTime(const TutorialMode & m)
 {
-	if(GH.input().hasTouchInputDevice() && !persistentStorage["gui"]["tutorialCompleted" + std::to_string(m)].Bool())
+	if(GH.input().getCurrentInputMode() == InputMode::TOUCH && !persistentStorage["gui"]["tutorialCompleted" + std::to_string(m)].Bool())
 	{
 		if(LOCPLINT)
 			LOCPLINT->showingDialog->setBusy();
@@ -98,26 +101,3 @@
 	deactivate();
 	activate();
 }
-
-void CTutorialWindow::show(Canvas & to)
-{
-	CCS->videoh->update(pos.x + 30, pos.y + 120, to.getInternalSurface(), true, false,
-	[&]()
-	{
-		CCS->videoh->close();
-		CCS->videoh->open(VideoPath::builtin(video));
-	});
-
-	CIntObject::show(to);
-}
-
-void CTutorialWindow::activate()
-{
-	CCS->videoh->open(VideoPath::builtin(video));
-	CIntObject::activate();
-}
-
-void CTutorialWindow::deactivate()
-{
-	CCS->videoh->close();
-}
diff --color -urN vcmi-1.5.7/client/windows/CTutorialWindow.h vcmi/client/windows/CTutorialWindow.h
--- vcmi-1.5.7/client/windows/CTutorialWindow.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/windows/CTutorialWindow.h	2024-12-19 15:00:22.387126820 +0100
@@ -15,6 +15,7 @@
 class CButton;
 class CLabel;
 class CMultiLineLabel;
+class VideoWidget;
 
 enum TutorialMode
 {
@@ -33,8 +34,8 @@
 
 	std::shared_ptr<CLabel> labelTitle;
 	std::shared_ptr<CMultiLineLabel> labelInformation;
+	std::shared_ptr<VideoWidget> videoPlayer;
 
-	std::string video;
 	std::vector<std::string> videos;
 
 	int page;
@@ -47,8 +48,4 @@
 public:
 	CTutorialWindow(const TutorialMode & m);
 	static void openWindowFirstTime(const TutorialMode & m);	
-
-	void show(Canvas & to) override;
-	void activate() override;
-	void deactivate() override;
 };
diff --color -urN vcmi-1.5.7/client/windows/CWindowObject.cpp vcmi/client/windows/CWindowObject.cpp
--- vcmi-1.5.7/client/windows/CWindowObject.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/windows/CWindowObject.cpp	2024-12-19 15:00:22.388126861 +0100
@@ -20,17 +20,17 @@
 #include "../windows/CMessage.h"
 #include "../renderSDL/SDL_PixelAccess.h"
 #include "../render/IImage.h"
+#include "../render/IScreenHandler.h"
 #include "../render/IRenderHandler.h"
 #include "../render/Canvas.h"
 
 #include "../CGameInfo.h"
 #include "../CPlayerInterface.h"
-#include "../CMusicHandler.h"
 
 #include "../../CCallback.h"
 
 #include "../../lib/CConfigHandler.h"
-#include "../../lib/CGeneralTextHandler.h" //for Unicode related stuff
+#include "../../lib/texts/CGeneralTextHandler.h" //for Unicode related stuff
 
 #include <SDL_surface.h>
 
@@ -42,8 +42,6 @@
 	if(!(options & NEEDS_ANIMATED_BACKGROUND)) //currently workaround for highscores (currently uses window as normal control, because otherwise videos are not played in background yet)
 		assert(parent == nullptr); //Safe to remove, but windows should not have parent
 
-	defActions = 255-DISPOSE;
-
 	if (options & RCLICK_POPUP)
 		CCS->curh->hide();
 
@@ -64,8 +62,6 @@
 	if(!(options & NEEDS_ANIMATED_BACKGROUND)) //currently workaround for highscores (currently uses window as normal control, because otherwise videos are not played in background yet)
 		assert(parent == nullptr); //Safe to remove, but windows should not have parent
 
-	defActions = 255-DISPOSE;
-
 	if(options & RCLICK_POPUP)
 		CCS->curh->hide();
 
@@ -86,7 +82,7 @@
 
 std::shared_ptr<CPicture> CWindowObject::createBg(const ImagePath & imageName, bool playerColored)
 {
-	OBJECT_CONSTRUCTION_CUSTOM_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	if(imageName.empty())
 		return nullptr;
@@ -94,13 +90,13 @@
 	auto image = std::make_shared<CPicture>(imageName);
 	image->getSurface()->setBlitMode(EImageBlitMode::OPAQUE);
 	if(playerColored)
-		image->colorize(LOCPLINT->playerID);
+		image->setPlayerColor(LOCPLINT->playerID);
 	return image;
 }
 
 void CWindowObject::setBackground(const ImagePath & filename)
 {
-	OBJECT_CONSTRUCTION_CUSTOM_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	background = createBg(filename, options & PLAYER_COLORED);
 
@@ -120,7 +116,8 @@
 void CWindowObject::setShadow(bool on)
 {
 	//size of shadow
-	static const int size = 8;
+	int sizeOriginal = 8;
+	int size = sizeOriginal * GH.screenHandler().getScalingFactor();
 
 	if(on == !shadowParts.empty())
 		return;
@@ -185,9 +182,9 @@
 		//FIXME: do something with this points
 		Point shadowStart;
 		if (options & BORDERED)
-			shadowStart = Point(size - 14, size - 14);
+			shadowStart = Point(sizeOriginal - 14, sizeOriginal - 14);
 		else
-			shadowStart = Point(size, size);
+			shadowStart = Point(sizeOriginal, sizeOriginal);
 
 		Point shadowPos;
 		if (options & BORDERED)
@@ -203,15 +200,15 @@
 
 		//create base 8x8 piece of shadow
 		SDL_Surface * shadowCorner = CSDL_Ext::copySurface(shadowCornerTempl);
-		SDL_Surface * shadowBottom = CSDL_Ext::scaleSurfaceFast(shadowBottomTempl, fullsize.x - size, size);
-		SDL_Surface * shadowRight  = CSDL_Ext::scaleSurfaceFast(shadowRightTempl,  size, fullsize.y - size);
+		SDL_Surface * shadowBottom = CSDL_Ext::scaleSurface(shadowBottomTempl, (fullsize.x - sizeOriginal) * GH.screenHandler().getScalingFactor(), size);
+		SDL_Surface * shadowRight  = CSDL_Ext::scaleSurface(shadowRightTempl,  size, (fullsize.y - sizeOriginal) * GH.screenHandler().getScalingFactor());
 
 		blitAlphaCol(shadowBottom, 0);
 		blitAlphaRow(shadowRight, 0);
 
 		//generate "shadow" object with these 3 pieces in it
 		{
-			OBJECT_CONSTRUCTION_CUSTOM_CAPTURING(255-DISPOSE);
+			OBJECT_CONSTRUCTION;
 
 			shadowParts.push_back(std::make_shared<CPicture>( GH.renderHandler().createImage(shadowCorner), Point(shadowPos.x,   shadowPos.y)));
 			shadowParts.push_back(std::make_shared<CPicture>( GH.renderHandler().createImage(shadowRight ),  Point(shadowPos.x,   shadowStart.y)));
diff --color -urN vcmi-1.5.7/client/windows/CWindowObject.h vcmi/client/windows/CWindowObject.h
--- vcmi-1.5.7/client/windows/CWindowObject.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/windows/CWindowObject.h	2024-12-19 15:00:22.388126861 +0100
@@ -42,7 +42,7 @@
 	};
 
 	/*
-	 * options - EOpions enum
+	 * options - EOptions enum
 	 * imageName - name for background image, can be empty
 	 * centerAt - position of window center. Default - center of the screen
 	*/
diff --color -urN vcmi-1.5.7/client/windows/CWindowWithArtifacts.cpp vcmi/client/windows/CWindowWithArtifacts.cpp
--- vcmi-1.5.7/client/windows/CWindowWithArtifacts.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/windows/CWindowWithArtifacts.cpp	2024-12-19 15:00:22.389126903 +0100
@@ -29,7 +29,7 @@
 #include "../CGameInfo.h"
 
 #include "../../lib/ArtifactUtils.h"
-#include "../../lib/CGeneralTextHandler.h"
+#include "../../lib/texts/CGeneralTextHandler.h"
 #include "../../lib/mapObjects/CGHeroInstance.h"
 #include "../../lib/networkPacks/ArtifactLocation.h"
 #include "../../lib/CConfigHandler.h"
@@ -42,302 +42,113 @@
 		this->artSets.insert(this->artSets.end(), artSets->begin(), artSets->end());
 }
 
-void CWindowWithArtifacts::addSet(CArtifactsOfHeroPtr newArtSet)
+void CWindowWithArtifacts::addSet(const std::shared_ptr<CArtifactsOfHeroBase> & newArtSet)
 {
 	artSets.emplace_back(newArtSet);
 }
 
-void CWindowWithArtifacts::addSetAndCallbacks(CArtifactsOfHeroPtr newArtSet)
+const CGHeroInstance * CWindowWithArtifacts::getHeroPickedArtifact() const
 {
-	addSet(newArtSet);
-	std::visit([this](auto artSetWeak)
-		{
-			auto artSet = artSetWeak.lock();
-			artSet->clickPressedCallback = std::bind(&CWindowWithArtifacts::clickPressedArtPlaceHero, this, _1, _2, _3);
-			artSet->showPopupCallback = std::bind(&CWindowWithArtifacts::showPopupArtPlaceHero, this, _1, _2, _3);
-			artSet->gestureCallback = std::bind(&CWindowWithArtifacts::gestureArtPlaceHero, this, _1, _2, _3);
-		}, newArtSet);
-}
-
-void CWindowWithArtifacts::addCloseCallback(const CloseCallback & callback)
-{
-	closeCallback = callback;
-}
+	const CGHeroInstance * hero = nullptr;
 
-const CGHeroInstance * CWindowWithArtifacts::getHeroPickedArtifact()
-{
-	auto res = getState();
-	if(res.has_value())
-		return std::get<const CGHeroInstance*>(res.value());
-	else
-		return nullptr;
+	for(const auto & artSet : artSets)
+		if(const auto pickedArt = artSet->getHero()->getArt(ArtifactPosition::TRANSITION_POS))
+		{
+			hero = artSet->getHero();
+			break;
+		}
+	return hero;
 }
 
-const CArtifactInstance * CWindowWithArtifacts::getPickedArtifact()
+const CArtifactInstance * CWindowWithArtifacts::getPickedArtifact() const
 {
-	auto res = getState();
-	if(res.has_value())
-		return std::get<const CArtifactInstance*>(res.value());
-	else
-		return nullptr;
+	for(const auto & artSet : artSets)
+		if(const auto pickedArt = artSet->getHero()->getArt(ArtifactPosition::TRANSITION_POS))
+		{
+			return pickedArt;
+		}
+	return nullptr;
 }
 
-void CWindowWithArtifacts::clickPressedArtPlaceHero(const CArtifactsOfHeroBase & artsInst, CArtPlace & artPlace, const Point & cursorPosition)
+void CWindowWithArtifacts::clickPressedOnArtPlace(const CGHeroInstance * hero, const ArtifactPosition & slot,
+	bool allowExchange, bool altarTrading, bool closeWindow, const Point & cursorPosition)
 {
-	const auto currentArtSet = findAOHbyRef(artsInst);
-	assert(currentArtSet.has_value());
-
-	if(artPlace.isLocked())
+	if(!LOCPLINT->makingTurn)
 		return;
-
-	if (!LOCPLINT->makingTurn)
+	if(hero == nullptr)
 		return;
 
-	std::visit(
-		[this, &artPlace](auto artSetWeak) -> void
+	if(const auto heroArtOwner = getHeroPickedArtifact())
+	{
+		if(allowExchange || hero->id == heroArtOwner->id)
+			putPickedArtifact(*hero, slot);
+	}
+	else if(GH.isKeyboardShiftDown())
+	{
+		showQuickBackpackWindow(hero, slot, cursorPosition);
+	}
+	else if(auto art = hero->getArt(slot))
+	{
+		if(hero->getOwner() == LOCPLINT->playerID)
 		{
-			const auto artSetPtr = artSetWeak.lock();
-
-			// Hero(Main, Exchange) window, Kingdom window, Altar window, Backpack window left click handler
-			if constexpr(
-				std::is_same_v<decltype(artSetWeak), std::weak_ptr<CArtifactsOfHeroMain>> || 
-				std::is_same_v<decltype(artSetWeak), std::weak_ptr<CArtifactsOfHeroKingdom>> ||
-				std::is_same_v<decltype(artSetWeak), std::weak_ptr<CArtifactsOfHeroAltar>> ||
-				std::is_same_v<decltype(artSetWeak), std::weak_ptr<CArtifactsOfHeroBackpack>>)
-			{
-				const auto pickedArtInst = getPickedArtifact();
-				const auto heroPickedArt = getHeroPickedArtifact();
-				const auto hero = artSetPtr->getHero();
-				auto isTransferAllowed = false;
-				std::string msg;
-
-				if(pickedArtInst)
-				{
-					auto srcLoc = ArtifactLocation(heroPickedArt->id, ArtifactPosition::TRANSITION_POS);
-					auto dstLoc = ArtifactLocation(hero->id, artPlace.slot);
-
-					if(ArtifactUtils::isSlotBackpack(artPlace.slot))
-					{
-						if(pickedArtInst->artType->isBig())
-						{
-							// War machines cannot go to backpack
-							msg = boost::str(boost::format(CGI->generaltexth->allTexts[153]) % pickedArtInst->artType->getNameTranslated());
-						}
-						else
-						{
-							if(ArtifactUtils::isBackpackFreeSlots(heroPickedArt))
-								isTransferAllowed = true;
-							else
-								msg = CGI->generaltexth->translate("core.genrltxt.152");
-						}
-					}
-					// Check if artifact transfer is possible
-					else if(pickedArtInst->canBePutAt(hero, artPlace.slot, true) && (!artPlace.getArt() || hero->tempOwner == LOCPLINT->playerID))
-					{
-						isTransferAllowed = true;
-					}
-					if constexpr(std::is_same_v<decltype(artSetWeak), std::weak_ptr<CArtifactsOfHeroKingdom>>)
-					{
-						if(hero != heroPickedArt)
-							isTransferAllowed = false;
-					}
-					if(isTransferAllowed)
-						LOCPLINT->cb->swapArtifacts(srcLoc, dstLoc);
-				}
-				else if(auto art = artPlace.getArt())
-				{
-					if(artSetPtr->getHero()->getOwner() == LOCPLINT->playerID)
-					{
-						if(checkSpecialArts(*art, hero, std::is_same_v<decltype(artSetWeak), std::weak_ptr<CArtifactsOfHeroAltar>> ? true : false))
-						{
-							assert(artSetPtr->getHero()->getSlotByInstance(art) != ArtifactPosition::PRE_FIRST);
-
-							if(GH.isKeyboardCmdDown())
-							{
-								std::shared_ptr<CArtifactsOfHeroMain> anotherHeroEquipmentPointer = nullptr;
-
-								for(auto set : artSets)
-								{
-									if(std::holds_alternative<std::weak_ptr<CArtifactsOfHeroMain>>(set))
-									{
-										std::shared_ptr<CArtifactsOfHeroMain> heroEquipmentPointer = std::get<std::weak_ptr<CArtifactsOfHeroMain>>(set).lock();
-										if(heroEquipmentPointer->getHero()->id != artSetPtr->getHero()->id)
-										{
-											anotherHeroEquipmentPointer = heroEquipmentPointer;
-											break;
-										}
-									}
-								}
-
-								if(anotherHeroEquipmentPointer != nullptr)
-								{
-									ArtifactPosition availablePosition = ArtifactUtils::getArtAnyPosition(anotherHeroEquipmentPointer->getHero(), art->getTypeId());
-									if(availablePosition != ArtifactPosition::PRE_FIRST)
-									{
-										LOCPLINT->cb->swapArtifacts(ArtifactLocation(artSetPtr->getHero()->id, artSetPtr->getHero()->getSlotByInstance(art)),
-										ArtifactLocation(anotherHeroEquipmentPointer->getHero()->id, availablePosition));
-									}
-								}
-							}
-							else if(GH.isKeyboardAltDown())
-							{
-								ArtifactPosition destinationPosition = ArtifactPosition::PRE_FIRST;
-
-								if(ArtifactUtils::isSlotEquipment(artPlace.slot))
-								{
-									ArtifactPosition availablePosition = ArtifactUtils::getArtBackpackPosition(artSetPtr->getHero(), art->getTypeId());
-									if(availablePosition != ArtifactPosition::PRE_FIRST)
-									{
-										destinationPosition = availablePosition;
-									}
-								}
-								else if(ArtifactUtils::isSlotBackpack(artPlace.slot))
-								{
-									ArtifactPosition availablePosition = ArtifactUtils::getArtAnyPosition(artSetPtr->getHero(), art->getTypeId());
-									if(availablePosition != ArtifactPosition::PRE_FIRST && availablePosition != ArtifactPosition::BACKPACK_START)
-									{
-										destinationPosition = availablePosition;
-									}
-								}
-
-								if(destinationPosition != ArtifactPosition::PRE_FIRST)
-								{
-									LOCPLINT->cb->swapArtifacts(ArtifactLocation(artSetPtr->getHero()->id, artPlace.slot),
-										ArtifactLocation(artSetPtr->getHero()->id, destinationPosition));
-								}
-							}
-							else
-							{
-								LOCPLINT->cb->swapArtifacts(ArtifactLocation(artSetPtr->getHero()->id, artPlace.slot),
-									ArtifactLocation(artSetPtr->getHero()->id, ArtifactPosition::TRANSITION_POS));
-							}
-						}
-					}
-					else
-					{
-						for(const auto artSlot : ArtifactUtils::unmovableSlots())
-							if(artPlace.slot == artSlot)
-							{
-								msg = CGI->generaltexth->allTexts[21];
-								break;
-							}
-					}
-				}
-
-				if constexpr(std::is_same_v<decltype(artSetWeak), std::weak_ptr<CArtifactsOfHeroBackpack>>)
-				{
-					if(!isTransferAllowed && artPlace.getArt() && closeCallback)
-						closeCallback();
-				}
-				else
-				{
-					if(!msg.empty())
-						LOCPLINT->showInfoDialog(msg);
-				}
-			}
-			// Market window left click handler
-			else if constexpr(std::is_same_v<decltype(artSetWeak), std::weak_ptr<CArtifactsOfHeroMarket>>)
-			{
-				if(artSetPtr->selectArtCallback && artPlace.getArt())
+			if(checkSpecialArts(*art, *hero, altarTrading))
+				onClickPressedCommonArtifact(*hero, slot, closeWindow);
+		}
+		else
+		{
+			for(const auto & artSlot : ArtifactUtils::unmovableSlots())
+				if(slot == artSlot)
 				{
-					if(artPlace.getArt()->artType->isTradable())
-					{
-						artSetPtr->unmarkSlots();
-						artPlace.selectSlot(true);
-						artSetPtr->selectArtCallback(&artPlace);
-					}
-					else
-					{
-						// This item can't be traded
-						LOCPLINT->showInfoDialog(CGI->generaltexth->allTexts[21]);
-					}
+					LOCPLINT->showInfoDialog(CGI->generaltexth->allTexts[21]);
+					break;
 				}
-			}
-			else if constexpr(std::is_same_v<decltype(artSetWeak), std::weak_ptr<CArtifactsOfHeroQuickBackpack>>)
-			{
-				const auto hero = artSetPtr->getHero();
-				LOCPLINT->cb->swapArtifacts(ArtifactLocation(hero->id, artPlace.slot), ArtifactLocation(hero->id, artSetPtr->getFilterSlot()));
-				if(closeCallback)
-					closeCallback();
-			}
-		}, currentArtSet.value());
+		}
+	}
 }
 
-void CWindowWithArtifacts::showPopupArtPlaceHero(const CArtifactsOfHeroBase & artsInst, CArtPlace & artPlace, const Point & cursorPosition)
+void CWindowWithArtifacts::swapArtifactAndClose(const CArtifactsOfHeroBase & artsInst, const ArtifactPosition & slot,
+	const ArtifactLocation & dstLoc)
 {
-	const auto currentArtSet = findAOHbyRef(artsInst);
-	assert(currentArtSet.has_value());
-
-	if(artPlace.isLocked())
-		return;
-
-	std::visit(
-		[&artPlace, &cursorPosition](auto artSetWeak) -> void
-		{
-			const auto artSetPtr = artSetWeak.lock();
+	LOCPLINT->cb->swapArtifacts(ArtifactLocation(artsInst.getHero()->id, slot), dstLoc);
+	close();
+}
 
-			// Hero (Main, Exchange) window, Kingdom window, Backpack window right click handler
-			if constexpr(
-				std::is_same_v<decltype(artSetWeak), std::weak_ptr<CArtifactsOfHeroAltar>> ||
-				std::is_same_v<decltype(artSetWeak), std::weak_ptr<CArtifactsOfHeroMain>> ||
-				std::is_same_v<decltype(artSetWeak), std::weak_ptr<CArtifactsOfHeroKingdom>> ||
-				std::is_same_v<decltype(artSetWeak), std::weak_ptr<CArtifactsOfHeroBackpack>>)
-			{
-				if(artPlace.getArt())
-				{
-					if(ArtifactUtilsClient::askToDisassemble(artSetPtr->getHero(), artPlace.slot))
-					{
-						return;
-					}
-					if(ArtifactUtilsClient::askToAssemble(artSetPtr->getHero(), artPlace.slot))
-					{
-						return;
-					}
-					if(artPlace.text.size())
-						artPlace.LRClickableAreaWTextComp::showPopupWindow(cursorPosition);
-				}
-			}
-			// Altar window, Market window right click handler
-			else if constexpr(
-				std::is_same_v<decltype(artSetWeak), std::weak_ptr<CArtifactsOfHeroMarket>> ||
-				std::is_same_v<decltype(artSetWeak), std::weak_ptr<CArtifactsOfHeroQuickBackpack>>)
-			{
-				if(artPlace.getArt() && artPlace.text.size())
-					artPlace.LRClickableAreaWTextComp::showPopupWindow(cursorPosition);
-			}
-		}, currentArtSet.value());
+void CWindowWithArtifacts::showArtifactAssembling(const CArtifactsOfHeroBase & artsInst, CArtPlace & artPlace,
+	const Point & cursorPosition) const
+{
+	if(artsInst.getArt(artPlace.slot))
+	{
+		if(LOCPLINT->artifactController->askToDisassemble(artsInst.getHero(), artPlace.slot))
+			return;
+		if(LOCPLINT->artifactController->askToAssemble(artsInst.getHero(), artPlace.slot))
+			return;
+		if(artPlace.text.size())
+			artPlace.LRClickableAreaWTextComp::showPopupWindow(cursorPosition);
+	}
 }
 
-void CWindowWithArtifacts::gestureArtPlaceHero(const CArtifactsOfHeroBase & artsInst, CArtPlace & artPlace, const Point & cursorPosition)
+void CWindowWithArtifacts::showQuickBackpackWindow(const CGHeroInstance * hero, const ArtifactPosition & slot,
+	const Point & cursorPosition) const
 {
-	const auto currentArtSet = findAOHbyRef(artsInst);
-	assert(currentArtSet.has_value());
-	if(artPlace.isLocked())
+	if(!settings["general"]["enableUiEnhancements"].Bool())
 		return;
 
-	std::visit(
-		[&artPlace, cursorPosition](auto artSetWeak) -> void
-		{
-			const auto artSetPtr = artSetWeak.lock();
-			if constexpr(
-				std::is_same_v<decltype(artSetWeak), std::weak_ptr<CArtifactsOfHeroMain>> ||
-				std::is_same_v<decltype(artSetWeak), std::weak_ptr<CArtifactsOfHeroKingdom>>)
-			{
-				if(!settings["general"]["enableUiEnhancements"].Bool())
-					return;
+	if(!ArtifactUtils::isSlotEquipment(slot))
+		return;
 
-				GH.windows().createAndPushWindow<CHeroQuickBackpackWindow>(artSetPtr->getHero(), artPlace.slot);
-				auto backpackWindow = GH.windows().topWindow<CHeroQuickBackpackWindow>();
-				backpackWindow->moveTo(cursorPosition - Point(1, 1));
-				backpackWindow->fitToScreen(15);
-			}
-		}, currentArtSet.value());
+	GH.windows().createAndPushWindow<CHeroQuickBackpackWindow>(hero, slot);
+	auto backpackWindow = GH.windows().topWindow<CHeroQuickBackpackWindow>();
+	backpackWindow->moveTo(cursorPosition - Point(1, 1));
+	backpackWindow->fitToScreen(15);
 }
 
 void CWindowWithArtifacts::activate()
 {
 	if(const auto art = getPickedArtifact())
+	{
+		markPossibleSlots();
 		setCursorAnimation(*art);
+	}
 	CWindowObject::activate();
 }
 
@@ -347,191 +158,60 @@
 	CWindowObject::deactivate();
 }
 
-void CWindowWithArtifacts::enableArtifactsCostumeSwitcher() const
-{
-	for(auto artSet : artSets)
-		std::visit(
-			[](auto artSetWeak)
-			{
-				if constexpr(std::is_same_v<decltype(artSetWeak), std::weak_ptr<CArtifactsOfHeroMain>>)
-				{
-					const auto artSetPtr = artSetWeak.lock();
-					artSetPtr->enableArtifactsCostumeSwitcher();
-				}
-			}, artSet);
-}
-
-void CWindowWithArtifacts::artifactRemoved(const ArtifactLocation & artLoc)
+void CWindowWithArtifacts::enableKeyboardShortcuts() const
 {
-	update();
+	for(auto & artSet : artSets)
+		artSet->enableKeyboardShortcuts();
 }
 
-void CWindowWithArtifacts::artifactMoved(const ArtifactLocation & srcLoc, const ArtifactLocation & destLoc, bool withRedraw)
+void CWindowWithArtifacts::update()
 {
-	auto curState = getState();
-	if(!curState.has_value())
-		// Transition state. Nothing to do here. Just skip. Need to wait for final state.
-		return;
-
-	auto pickedArtInst = std::get<const CArtifactInstance*>(curState.value());
-	auto artifactMovedBody = [this, withRedraw, &destLoc, &pickedArtInst](auto artSetWeak) -> void
+	for(const auto & artSet : artSets)
 	{
-		auto artSetPtr = artSetWeak.lock();
-		if(artSetPtr)
-		{
-			const auto hero = artSetPtr->getHero();
-			if(pickedArtInst)
-			{
-				setCursorAnimation(*pickedArtInst);
-			}
-			else
-			{
-				artSetPtr->unmarkSlots();
-				CCS->curh->dragAndDropCursor(nullptr);
-			}
-			if(withRedraw)
-			{
-				artSetPtr->updateWornSlots();
-				artSetPtr->updateBackpackSlots();
-
-				// Update arts bonuses on window.
-				// TODO rework this part when CHeroWindow and CExchangeWindow are reworked
-				if(auto * chw = dynamic_cast<CHeroWindow*>(this))
-				{
-					chw->update(hero, true);
-				}
-				else if(auto * cew = dynamic_cast<CExchangeWindow*>(this))
-				{
-					cew->updateWidgets();
-				}
-				artSetPtr->redraw();
-			}
-
-			// Make sure the status bar is updated so it does not display old text
-			if(destLoc.artHolder == hero->id)
-			{
-				if(auto artPlace = artSetPtr->getArtPlace(destLoc.slot))
-					artPlace->hover(true);
-			}
-		}
-	};
-
-	for(auto artSetWeak : artSets)
-		std::visit(artifactMovedBody, artSetWeak);
-}
-
-void CWindowWithArtifacts::artifactDisassembled(const ArtifactLocation & artLoc)
-{
-	update();
-}
-
-void CWindowWithArtifacts::artifactAssembled(const ArtifactLocation & artLoc)
-{
-	markPossibleSlots();
-	update();
-}
+		artSet->updateWornSlots();
+		artSet->updateBackpackSlots();
 
-void CWindowWithArtifacts::update() const
-{
-	auto updateSlotBody = [](auto artSetWeak) -> void
-	{
-		if(const auto artSetPtr = artSetWeak.lock())
+		if(const auto pickedArtInst = getPickedArtifact())
 		{
-			artSetPtr->updateWornSlots();
-			artSetPtr->updateBackpackSlots();
-			artSetPtr->redraw();
+			markPossibleSlots();
+			setCursorAnimation(*pickedArtInst);
 		}
-	};
-
-	for(auto artSetWeak : artSets)
-		std::visit(updateSlotBody, artSetWeak);
-}
-
-std::optional<std::tuple<const CGHeroInstance*, const CArtifactInstance*>> CWindowWithArtifacts::getState()
-{
-	const CArtifactInstance * artInst = nullptr;
-	std::map<const CGHeroInstance*, size_t> pickedCnt;
-
-	auto getHeroArtBody = [&artInst, &pickedCnt](auto artSetWeak) -> void
-	{
-		auto artSetPtr = artSetWeak.lock();
-		if(artSetPtr)
+		else
 		{
-			if(const auto art = artSetPtr->getPickedArtifact())
-			{
-				const auto hero = artSetPtr->getHero();
-				if(pickedCnt.count(hero) == 0)
-				{
-					pickedCnt.insert({ hero, hero->artifactsTransitionPos.size() });
-					artInst = art;
-				}
-			}
+			artSet->unmarkSlots();
+			CCS->curh->dragAndDropCursor(nullptr);
 		}
-	};
-	for(auto artSetWeak : artSets)
-		std::visit(getHeroArtBody, artSetWeak);
-
-	// The state is possible when the hero has placed an artifact in the ArtifactPosition::TRANSITION_POS,
-	// and the previous artifact has not yet removed from the ArtifactPosition::TRANSITION_POS.
-	// This is a transitional state. Then return nullopt.
-	if(std::accumulate(std::begin(pickedCnt), std::end(pickedCnt), 0, [](size_t accum, const auto & value)
-		{
-			return accum + value.second;
-		}) > 1)
-		return std::nullopt;
-	else
-		return std::make_tuple(pickedCnt.begin()->first, artInst);
-}
-
-std::optional<CWindowWithArtifacts::CArtifactsOfHeroPtr> CWindowWithArtifacts::findAOHbyRef(const CArtifactsOfHeroBase & artsInst)
-{
-	std::optional<CArtifactsOfHeroPtr> res;
-
-	auto findAOHBody = [&res, &artsInst](auto & artSetWeak) -> void
-	{
-		if(&artsInst == artSetWeak.lock().get())
-			res = artSetWeak;
-	};
 
-	for(auto artSetWeak : artSets)
-	{
-		std::visit(findAOHBody, artSetWeak);
-		if(res.has_value())
-			return res;
+		// Make sure the status bar is updated so it does not display old text
+		if(auto artPlace = artSet->getArtPlace(GH.getCursorPosition()))
+			artPlace->hover(true);
 	}
-	return res;
+	redraw();
 }
 
-void CWindowWithArtifacts::markPossibleSlots()
+void CWindowWithArtifacts::markPossibleSlots() const
 {
 	if(const auto pickedArtInst = getPickedArtifact())
 	{
-		const auto heroArtOwner = getHeroPickedArtifact();
-		auto artifactAssembledBody = [&pickedArtInst, &heroArtOwner](auto artSetWeak) -> void
+		for(const auto & artSet : artSets)
 		{
-			if(auto artSetPtr = artSetWeak.lock())
-			{
-				if(artSetPtr->isActive())
-				{
-					const auto hero = artSetPtr->getHero();
-					if(heroArtOwner == hero || !std::is_same_v<decltype(artSetWeak), std::weak_ptr<CArtifactsOfHeroKingdom>>)
-						artSetPtr->markPossibleSlots(pickedArtInst, hero->tempOwner == LOCPLINT->playerID);
-				}
-			}
-		};
+			const auto hero = artSet->getHero();
+			if(hero == nullptr || !artSet->isActive())
+				continue;
 
-		for(auto artSetWeak : artSets)
-			std::visit(artifactAssembledBody, artSetWeak);
+			if(getHeroPickedArtifact() == hero || !std::dynamic_pointer_cast<CArtifactsOfHeroKingdom>(artSet))
+				artSet->markPossibleSlots(pickedArtInst->getType(), hero->tempOwner == LOCPLINT->playerID);
+		}
 	}
 }
 
-bool CWindowWithArtifacts::checkSpecialArts(const CArtifactInstance & artInst, const CGHeroInstance * hero, bool isTrade) const
+bool CWindowWithArtifacts::checkSpecialArts(const CArtifactInstance & artInst, const CGHeroInstance & hero, bool isTrade) const
 {
 	const auto artId = artInst.getTypeId();
 	
 	if(artId == ArtifactID::SPELLBOOK)
 	{
-		GH.windows().createAndPushWindow<CSpellWindow>(hero, LOCPLINT, LOCPLINT->battleInt.get());
+		GH.windows().createAndPushWindow<CSpellWindow>(&hero, LOCPLINT, LOCPLINT->battleInt.get());
 		return false;
 	}
 	if(artId == ArtifactID::CATAPULT)
@@ -541,7 +221,7 @@
 			std::vector<std::shared_ptr<CComponent>>(1, std::make_shared<CComponent>(ComponentType::ARTIFACT, ArtifactID(ArtifactID::CATAPULT))));
 		return false;
 	}
-	if(isTrade && !artInst.artType->isTradable())
+	if(isTrade && !artInst.getType()->isTradable())
 	{
 		LOCPLINT->showInfoDialog(CGI->generaltexth->allTexts[21],
 			std::vector<std::shared_ptr<CComponent>>(1, std::make_shared<CComponent>(ComponentType::ARTIFACT, artId)));
@@ -550,18 +230,87 @@
 	return true;
 }
 
-void CWindowWithArtifacts::setCursorAnimation(const CArtifactInstance & artInst)
+void CWindowWithArtifacts::setCursorAnimation(const CArtifactInstance & artInst) const
 {
-	markPossibleSlots();
 	if(artInst.isScroll() && settings["general"]["enableUiEnhancements"].Bool())
 	{
 		assert(artInst.getScrollSpellID().num >= 0);
-		const auto animation = GH.renderHandler().loadAnimation(AnimationPath::builtin("spellscr"));
-		animation->load(artInst.getScrollSpellID().num);
-		CCS->curh->dragAndDropCursor(animation->getImage(artInst.getScrollSpellID().num)->scaleFast(Point(44, 34)));
+		auto image = GH.renderHandler().loadImage(AnimationPath::builtin("spellscr"), artInst.getScrollSpellID().num, 0, EImageBlitMode::COLORKEY);
+		image->scaleTo(Point(44,34));
+
+		CCS->curh->dragAndDropCursor(image);
 	}
 	else
 	{
-		CCS->curh->dragAndDropCursor(AnimationPath::builtin("artifact"), artInst.artType->getIconIndex());
+		CCS->curh->dragAndDropCursor(AnimationPath::builtin("artifact"), artInst.getType()->getIconIndex());
+	}
+}
+
+void CWindowWithArtifacts::putPickedArtifact(const CGHeroInstance & curHero, const ArtifactPosition & targetSlot) const
+{
+	const auto heroArtOwner = getHeroPickedArtifact();
+	const auto pickedArt = getPickedArtifact();
+	auto srcLoc = ArtifactLocation(heroArtOwner->id, ArtifactPosition::TRANSITION_POS);
+	auto dstLoc = ArtifactLocation(curHero.id, targetSlot);
+
+	if(ArtifactUtils::isSlotBackpack(dstLoc.slot))
+	{
+		if(pickedArt->getType()->isBig())
+		{
+			// War machines cannot go to backpack
+			LOCPLINT->showInfoDialog(boost::str(boost::format(CGI->generaltexth->allTexts[153]) % pickedArt->getType()->getNameTranslated()));
+		}
+		else
+		{
+			if(ArtifactUtils::isBackpackFreeSlots(heroArtOwner))
+				LOCPLINT->cb->swapArtifacts(srcLoc, dstLoc);
+			else
+				LOCPLINT->showInfoDialog(CGI->generaltexth->translate("core.genrltxt.152"));
+		}
+	}
+	// Check if artifact transfer is possible
+	else if(pickedArt->canBePutAt(&curHero, dstLoc.slot, true) && (!curHero.getArt(targetSlot) || curHero.tempOwner == LOCPLINT->playerID))
+	{
+		LOCPLINT->cb->swapArtifacts(srcLoc, dstLoc);
+	}
+}
+
+void CWindowWithArtifacts::onClickPressedCommonArtifact(const CGHeroInstance & curHero, const ArtifactPosition & slot, bool closeWindow)
+{
+	assert(curHero.getArt(slot));
+	auto srcLoc = ArtifactLocation(curHero.id, slot);
+	auto dstLoc = ArtifactLocation(curHero.id, ArtifactPosition::TRANSITION_POS);
+
+	if(GH.isKeyboardCmdDown())
+	{
+		for(const auto & anotherSet : artSets)
+		{
+			if(std::dynamic_pointer_cast<CArtifactsOfHeroMain>(anotherSet) && curHero.id != anotherSet->getHero()->id)
+			{
+				dstLoc.slot = ArtifactPosition::FIRST_AVAILABLE;
+				dstLoc.artHolder = anotherSet->getHero()->id;
+				break;
+			}
+			if(const auto heroSetAltar = std::dynamic_pointer_cast<CArtifactsOfHeroAltar>(anotherSet))
+			{
+				dstLoc.slot = ArtifactPosition::FIRST_AVAILABLE;
+				dstLoc.artHolder = heroSetAltar->altarId;
+				break;
+			}
+		}
+	}
+	else if(GH.isKeyboardAltDown())
+	{
+		const auto artId = curHero.getArt(slot)->getTypeId();
+		if(ArtifactUtils::isSlotEquipment(slot))
+			dstLoc.slot = ArtifactUtils::getArtBackpackPosition(&curHero, artId);
+		else if(ArtifactUtils::isSlotBackpack(slot))
+			dstLoc.slot = ArtifactUtils::getArtEquippedPosition(&curHero, artId);
+	}
+	else if(closeWindow)
+	{
+		close();
 	}
+	if(dstLoc.slot != ArtifactPosition::PRE_FIRST)
+		LOCPLINT->cb->swapArtifacts(srcLoc, dstLoc);
 }
diff --color -urN vcmi-1.5.7/client/windows/CWindowWithArtifacts.h vcmi/client/windows/CWindowWithArtifacts.h
--- vcmi-1.5.7/client/windows/CWindowWithArtifacts.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/windows/CWindowWithArtifacts.h	2024-12-19 15:00:22.390126944 +0100
@@ -19,41 +19,29 @@
 class CWindowWithArtifacts : virtual public CWindowObject
 {
 public:
-	using CArtifactsOfHeroPtr = std::variant<
-		std::weak_ptr<CArtifactsOfHeroMarket>,
-		std::weak_ptr<CArtifactsOfHeroAltar>,
-		std::weak_ptr<CArtifactsOfHeroKingdom>,
-		std::weak_ptr<CArtifactsOfHeroMain>,
-		std::weak_ptr<CArtifactsOfHeroBackpack>,
-		std::weak_ptr<CArtifactsOfHeroQuickBackpack>>;
-	using CloseCallback = std::function<void()>;
+	using CArtifactsOfHeroPtr = std::shared_ptr<CArtifactsOfHeroBase>;
 
 	std::vector<CArtifactsOfHeroPtr> artSets;
-	CloseCallback closeCallback;
 
 	explicit CWindowWithArtifacts(const std::vector<CArtifactsOfHeroPtr> * artSets = nullptr);
-	void addSet(CArtifactsOfHeroPtr newArtSet);
-	void addSetAndCallbacks(CArtifactsOfHeroPtr newArtSet);
-	void addCloseCallback(const CloseCallback & callback);
-	const CGHeroInstance * getHeroPickedArtifact();
-	const CArtifactInstance * getPickedArtifact();
-	void clickPressedArtPlaceHero(const CArtifactsOfHeroBase & artsInst, CArtPlace & artPlace, const Point & cursorPosition);
-	void showPopupArtPlaceHero(const CArtifactsOfHeroBase & artsInst, CArtPlace & artPlace, const Point & cursorPosition);
-	void gestureArtPlaceHero(const CArtifactsOfHeroBase & artsInst, CArtPlace & artPlace, const Point & cursorPosition);
+	void addSet(const std::shared_ptr<CArtifactsOfHeroBase> & newArtSet);
+	const CGHeroInstance * getHeroPickedArtifact() const;
+	const CArtifactInstance * getPickedArtifact() const;
+	void clickPressedOnArtPlace(const CGHeroInstance * hero, const ArtifactPosition & slot,
+		bool allowExchange, bool altarTrading, bool closeWindow, const Point & cursorPosition);
+	void swapArtifactAndClose(const CArtifactsOfHeroBase & artsInst, const ArtifactPosition & slot, const ArtifactLocation & dstLoc);
+	void showArtifactAssembling(const CArtifactsOfHeroBase & artsInst, CArtPlace & artPlace, const Point & cursorPosition) const;
+	void showQuickBackpackWindow(const CGHeroInstance * hero, const ArtifactPosition & slot, const Point & cursorPosition) const;
 	void activate() override;
 	void deactivate() override;
-	void enableArtifactsCostumeSwitcher() const;
+	void enableKeyboardShortcuts() const;
 
-	virtual void artifactRemoved(const ArtifactLocation & artLoc);
-	virtual void artifactMoved(const ArtifactLocation & srcLoc, const ArtifactLocation & destLoc, bool withRedraw);
-	virtual void artifactDisassembled(const ArtifactLocation & artLoc);
-	virtual void artifactAssembled(const ArtifactLocation & artLoc);
+	virtual void update();
 
 protected:
-	void update() const;
-	std::optional<std::tuple<const CGHeroInstance*, const CArtifactInstance*>> getState();
-	std::optional<CArtifactsOfHeroPtr> findAOHbyRef(const CArtifactsOfHeroBase & artsInst);
-	void markPossibleSlots();
-	bool checkSpecialArts(const CArtifactInstance & artInst, const CGHeroInstance * hero, bool isTrade) const;
-	void setCursorAnimation(const CArtifactInstance & artInst);
+	void markPossibleSlots() const;
+	bool checkSpecialArts(const CArtifactInstance & artInst, const CGHeroInstance & hero, bool isTrade) const;
+	void setCursorAnimation(const CArtifactInstance & artInst) const;
+	void putPickedArtifact(const CGHeroInstance & curHero, const ArtifactPosition & targetSlot) const;
+	void onClickPressedCommonArtifact(const CGHeroInstance & curHero, const ArtifactPosition & slot, bool closeWindow);
 };
diff --color -urN vcmi-1.5.7/client/windows/GUIClasses.cpp vcmi/client/windows/GUIClasses.cpp
--- vcmi-1.5.7/client/windows/GUIClasses.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/windows/GUIClasses.cpp	2024-12-19 15:00:22.393127068 +0100
@@ -18,9 +18,7 @@
 #include "../CGameInfo.h"
 #include "../CServerHandler.h"
 #include "../Client.h"
-#include "../CMusicHandler.h"
 #include "../CPlayerInterface.h"
-#include "../CVideoHandler.h"
 
 #include "../gui/CGuiHandler.h"
 #include "../gui/CursorHandler.h"
@@ -35,14 +33,18 @@
 #include "../widgets/Slider.h"
 #include "../widgets/TextControls.h"
 #include "../widgets/ObjectLists.h"
+#include "../widgets/VideoWidget.h"
+#include "../widgets/GraphicalPrimitiveCanvas.h"
 
 #include "../render/Canvas.h"
-#include "../render/CAnimation.h"
 #include "../render/IRenderHandler.h"
 #include "../render/IImage.h"
 
 #include "../../CCallback.h"
 
+#include "../lib/entities/building/CBuilding.h"
+#include "../lib/entities/faction/CTownHandler.h"
+#include "../lib/entities/hero/CHeroHandler.h"
 #include "../lib/mapObjectConstructors/CObjectClassesHandler.h"
 #include "../lib/mapObjectConstructors/CommonConstructors.h"
 #include "../lib/mapObjects/CGHeroInstance.h"
@@ -51,11 +53,12 @@
 #include "../lib/gameState/CGameState.h"
 #include "../lib/gameState/SThievesGuildInfo.h"
 #include "../lib/gameState/TavernHeroesPool.h"
-#include "../lib/CGeneralTextHandler.h"
-#include "../lib/CHeroHandler.h"
-#include "../lib/GameSettings.h"
+#include "../lib/texts/CGeneralTextHandler.h"
+#include "../lib/IGameSettings.h"
 #include "ConditionalWait.h"
+#include "../lib/CRandomGenerator.h"
 #include "../lib/CSkillHandler.h"
+#include "../lib/CSoundBase.h"
 
 CRecruitmentWindow::CCreatureCard::CCreatureCard(CRecruitmentWindow * window, const CCreature * crea, int totalAmount)
 	: CIntObject(LCLICK | SHOW_POPUP),
@@ -64,7 +67,7 @@
 	creature(crea),
 	amount(totalAmount)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	animation = std::make_shared<CCreaturePic>(1, 1, creature, true, true);
 	// 1 + 1 px for borders
 	pos.w = animation->pos.w + 2;
@@ -151,9 +154,9 @@
 	if(!dstslot.validSlot() && (selected->creature->warMachine == ArtifactID::NONE)) //no available slot
 	{
 		std::pair<SlotID, SlotID> toMerge;
-		bool allowMerge = CGI->settings()->getBoolean(EGameSettings::DWELLINGS_ACCUMULATE_WHEN_OWNED);
+		bool allowMerge = LOCPLINT->cb->getSettings().getBoolean(EGameSettings::DWELLINGS_ACCUMULATE_WHEN_OWNED);
 
-		if (allowMerge && dst->mergableStacks(toMerge))
+		if (allowMerge && dst->mergeableStacks(toMerge))
 		{
 			LOCPLINT->cb->mergeStacks( dst, dst, toMerge.first, toMerge.second);
 		}
@@ -211,7 +214,7 @@
 {
 	moveBy(Point(0, y_offset));
 
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	statusbar = CGStatusBar::create(std::make_shared<CPicture>(background->getSurface(), Rect(8, pos.h - 26, pos.w - 16, 19), 8, pos.h - 26));
 
@@ -236,7 +239,7 @@
 
 void CRecruitmentWindow::availableCreaturesChanged()
 {
-	OBJECT_CONSTRUCTION_CUSTOM_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	size_t selectedIndex = 0;
 
@@ -257,7 +260,7 @@
 
 		//create new cards
 		for(auto & creature : boost::adaptors::reverse(dwelling->creatures[i].second))
-			cards.push_back(std::make_shared<CCreatureCard>(this, CGI->creh->objects[creature], amount));
+			cards.push_back(std::make_shared<CCreatureCard>(this, creature.toCreature(), amount));
 	}
 
 	const int creatureWidth = 102;
@@ -314,7 +317,7 @@
 	leftMin(leftMin_),
 	rightMin(rightMin_)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	int total = leftAmount + rightAmount;
 	int leftMax = total - rightMin;
@@ -396,7 +399,7 @@
 	: CWindowObject(PLAYER_COLORED, ImagePath::builtin("LVLUPBKG")),
 	cb(callback)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	LOCPLINT->showingDialog->setBusy();
 
@@ -451,7 +454,7 @@
 	tavernObj(TavernObj),
 	heroToInvite(nullptr)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	std::vector<const CGHeroInstance*> h = LOCPLINT->cb->getAvailableHeroes(TavernObj);
 	if(h.size() < 2)
@@ -489,7 +492,7 @@
 		recruit->addHoverText(EButtonState::NORMAL, CGI->generaltexth->tavernInfo[0]); //Cannot afford a Hero
 		recruit->block(true);
 	}
-	else if(LOCPLINT->cb->howManyHeroes(true) >= CGI->settings()->getInteger(EGameSettings::HEROES_PER_PLAYER_TOTAL_CAP))
+	else if(LOCPLINT->cb->howManyHeroes(true) >= LOCPLINT->cb->getSettings().getInteger(EGameSettings::HEROES_PER_PLAYER_TOTAL_CAP))
 	{
 		MetaString message;
 		message.appendTextID("core.tvrninfo.1");
@@ -499,7 +502,7 @@
 		recruit->addHoverText(EButtonState::NORMAL, message.toString());
 		recruit->block(true);
 	}
-	else if(LOCPLINT->cb->howManyHeroes(false) >= CGI->settings()->getInteger(EGameSettings::HEROES_PER_PLAYER_ON_MAP_CAP))
+	else if(LOCPLINT->cb->howManyHeroes(false) >= LOCPLINT->cb->getSettings().getInteger(EGameSettings::HEROES_PER_PLAYER_ON_MAP_CAP))
 	{
 		MetaString message;
 		message.appendTextID("core.tvrninfo.1");
@@ -519,20 +522,20 @@
 			recruit->block(true);
 	}
 	if(LOCPLINT->castleInt)
-		CCS->videoh->open(LOCPLINT->castleInt->town->town->clientInfo.tavernVideo);
+		videoPlayer = std::make_shared<VideoWidget>(Point(70, 56), LOCPLINT->castleInt->town->getTown()->clientInfo.tavernVideo, false);
 	else if(const auto * townObj = dynamic_cast<const CGTownInstance *>(TavernObj))
-		CCS->videoh->open(townObj->town->clientInfo.tavernVideo);
+		videoPlayer = std::make_shared<VideoWidget>(Point(70, 56), townObj->getTown()->clientInfo.tavernVideo, false);
 	else
-		CCS->videoh->open(VideoPath::builtin("TAVERN.BIK"));
+		videoPlayer = std::make_shared<VideoWidget>(Point(70, 56), VideoPath::builtin("TAVERN.BIK"), false);
 
 	addInvite();
 }
 
 void CTavernWindow::addInvite()
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 
-	if(!VLC->settings()->getBoolean(EGameSettings::HEROES_TAVERN_INVITE))
+	if(!LOCPLINT->cb->getSettings().getBoolean(EGameSettings::HEROES_TAVERN_INVITE))
 		return;
 
 	const auto & heroesPool = CSH->client->gameState()->heroesPool;
@@ -545,11 +548,12 @@
 
 	if(!inviteableHeroes.empty())
 	{
+		int imageIndex = heroToInvite ? heroToInvite->getIconIndex() : 156; // 156 => special id for random
 		if(!heroToInvite)
 			heroToInvite = (*RandomGeneratorUtil::nextItem(inviteableHeroes, CRandomGenerator::getDefault())).second;
 
 		inviteHero = std::make_shared<CLabel>(170, 444, EFonts::FONT_MEDIUM, ETextAlignment::CENTER, Colors::WHITE, CGI->generaltexth->translate("vcmi.tavernWindow.inviteHero"));
-		inviteHeroImage = std::make_shared<CAnimImage>(AnimationPath::builtin("PortraitsSmall"), (*CGI->heroh)[heroToInvite->getHeroType()]->imageIndex, 0, 245, 428);
+		inviteHeroImage = std::make_shared<CAnimImage>(AnimationPath::builtin("PortraitsSmall"), imageIndex, 0, 245, 428);
 		inviteHeroImageArea = std::make_shared<LRClickableArea>(Rect(245, 428, 48, 32), [this](){ GH.windows().createAndPushWindow<HeroSelector>(inviteableHeroes, [this](CGHeroInstance* h){ heroToInvite = h; addInvite(); }); }, [this](){ GH.windows().createAndPushWindow<CRClickPopupInt>(std::make_shared<CHeroWindow>(heroToInvite)); });
 	}
 }
@@ -559,7 +563,7 @@
 	const CGHeroInstance *toBuy = (selected ? h2 : h1)->h;
 	const CGObjectInstance *obj = tavernObj;
 
-	LOCPLINT->cb->recruitHero(obj, toBuy, heroToInvite ? heroToInvite->getHeroType() : HeroTypeID::NONE);
+	LOCPLINT->cb->recruitHero(obj, toBuy, heroToInvite ? heroToInvite->getHeroTypeID() : HeroTypeID::NONE);
 	close();
 }
 
@@ -576,11 +580,6 @@
 	CStatusbarWindow::close();
 }
 
-CTavernWindow::~CTavernWindow()
-{
-	CCS->videoh->close();
-}
-
 void CTavernWindow::show(Canvas & to)
 {
 	CWindowObject::show(to);
@@ -604,8 +603,6 @@
 
 		to.drawBorder(Rect::createAround(sel->pos, 2), Colors::BRIGHT_YELLOW, 2);
 	}
-
-	CCS->videoh->update(pos.x+70, pos.y+56, to.getInternalSurface(), true, false);
 }
 
 void CTavernWindow::HeroPortrait::clickPressed(const Point & cursorPosition)
@@ -635,7 +632,7 @@
 	: CIntObject(LCLICK | DOUBLECLICK | SHOW_POPUP | HOVER),
 	h(H), _sel(&sel), _id(id), onChoose(OnChoose)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	h = H;
 	pos.x += x;
 	pos.y += y;
@@ -674,17 +671,52 @@
 CTavernWindow::HeroSelector::HeroSelector(std::map<HeroTypeID, CGHeroInstance*> InviteableHeroes, std::function<void(CGHeroInstance*)> OnChoose)
 	: CWindowObject(BORDERED), inviteableHeroes(InviteableHeroes), onChoose(OnChoose)
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 
-	pos = Rect(0, 0, 16 * 48, (inviteableHeroes.size() / 16 + (inviteableHeroes.size() % 16 != 0)) * 32);
+	pos = Rect(
+		pos.x,
+		pos.y,
+		ELEM_PER_LINES * 48,
+		std::min((int)(inviteableHeroes.size() / ELEM_PER_LINES + (inviteableHeroes.size() % ELEM_PER_LINES != 0)), MAX_LINES) * 32
+	);
 	background = std::make_shared<CFilledTexture>(ImagePath::builtin("DIBOXBCK"), Rect(0, 0, pos.w, pos.h));
 
+	if(inviteableHeroes.size() / ELEM_PER_LINES > MAX_LINES)
+	{
+		pos.w += 16;
+		slider = std::make_shared<CSlider>(Point(pos.w - 16, 0), pos.h, std::bind(&CTavernWindow::HeroSelector::sliderMove, this, _1), MAX_LINES, std::ceil((double)inviteableHeroes.size() / ELEM_PER_LINES), 0, Orientation::VERTICAL, CSlider::BROWN);
+		slider->setPanningStep(32);
+		slider->setScrollBounds(Rect(-pos.w + slider->pos.w, 0, pos.w, pos.h));
+	}
+
+	recreate();
+	center();
+}
+
+void CTavernWindow::HeroSelector::sliderMove(int slidPos)
+{
+	if(!slider)
+		return; // ignore spurious call when slider is being created
+	recreate();
+	redraw();
+}
+
+void CTavernWindow::HeroSelector::recreate()
+{
+	OBJECT_CONSTRUCTION;
+
+	int sliderLine = slider ? slider->getValue() : 0;
 	int x = 0;
-	int y = 0;
+	int y = -sliderLine;
+	portraits.clear();
+	portraitAreas.clear();
 	for(auto & h : inviteableHeroes)
 	{
-		portraits.push_back(std::make_shared<CAnimImage>(AnimationPath::builtin("PortraitsSmall"), (*CGI->heroh)[h.first]->imageIndex, 0, x * 48, y * 32));
-		portraitAreas.push_back(std::make_shared<LRClickableArea>(Rect(x * 48, y * 32, 48, 32), [this, h](){ close(); onChoose(inviteableHeroes[h.first]); }, [this, h](){ GH.windows().createAndPushWindow<CRClickPopupInt>(std::make_shared<CHeroWindow>(inviteableHeroes[h.first])); }));
+		if(y >= 0 && y <= MAX_LINES - 1)
+		{
+			portraits.push_back(std::make_shared<CAnimImage>(AnimationPath::builtin("PortraitsSmall"), (*CGI->heroh)[h.first]->imageIndex, 0, x * 48, y * 32));
+			portraitAreas.push_back(std::make_shared<LRClickableArea>(Rect(x * 48, y * 32, 48, 32), [this, h](){ close(); onChoose(inviteableHeroes[h.first]); }, [this, h](){ GH.windows().createAndPushWindow<CRClickPopupInt>(std::make_shared<CHeroWindow>(inviteableHeroes[h.first])); }));
+		}
 
 		if(x > 0 && x % 15 == 0)
 		{
@@ -694,14 +726,12 @@
 		else
 			x++;
 	}
-
-	center();
 }
 
 CShipyardWindow::CShipyardWindow(const TResources & cost, int state, BoatId boatType, const std::function<void()> & onBuy)
 	: CWindowObject(PLAYER_COLORED, ImagePath::builtin("TPSHIP"))
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	bgWater = std::make_shared<CPicture>(ImagePath::builtin("TPSHIPBK"), 100, 69);
 
@@ -716,8 +746,9 @@
 		AnimationPath boatFilename = boatConstructor->getBoatAnimationName();
 
 		Point waterCenter = Point(bgWater->pos.x+bgWater->pos.w/2, bgWater->pos.y+bgWater->pos.h/2);
-		bgShip = std::make_shared<CAnimImage>(boatFilename, 0, 7, 120, 96, 0);
+		bgShip = std::make_shared<CShowableAnim>(120, 96, boatFilename, CShowableAnim::CREATURE_MODE, 100, 7);
 		bgShip->center(waterCenter);
+		bgWater->needRefresh = true;
 	}
 
 	// Create resource icons and costs.
@@ -775,7 +806,7 @@
 	size(size_),
 	parent(parent_)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	left = true;
 	pos.w = 58;
 	pos.h = 64;
@@ -791,7 +822,7 @@
 	for(auto & elem : items)
 	{
 		if(!elem->left)
-			LOCPLINT->cb->trade(market, EMarketMode::CREATURE_UNDEAD, SlotID(elem->id), {}, {}, hero);
+			LOCPLINT->cb->trade(market->getObjInstanceID(), EMarketMode::CREATURE_UNDEAD, SlotID(elem->id), {}, {}, hero);
 	}
 }
 
@@ -822,7 +853,7 @@
 	onWindowClosed(onWindowClosed),
 	market(_market)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	if(hero)
 		army = hero;
 	else
@@ -861,88 +892,67 @@
 	ID(_ID),
 	parent(_parent)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	pos.x += X;
 	pos.y += Y;
 
-	topBar = std::make_shared<CAnimImage>(parent->bars, 0, 0, -28, -22);
-	bottomBar = std::make_shared<CAnimImage>(parent->bars, 0, 0, -28, 48);
-
-	icon = std::make_shared<CAnimImage>(AnimationPath::builtin("SECSKILL"), _ID * 3 + 3, 0);
-
-	name = std::make_shared<CLabel>(22, -13, FONT_SMALL, ETextAlignment::CENTER, Colors::WHITE, CGI->skillh->getByIndex(ID)->getNameTranslated());
-	level = std::make_shared<CLabel>(22, 57, FONT_SMALL, ETextAlignment::CENTER, Colors::WHITE, CGI->generaltexth->levels[0]);
+	skill = std::make_shared<CSecSkillPlace>(Point(), CSecSkillPlace::ImageSize::MEDIUM, _ID, 1);
+	skill->setClickPressedCallback([this](const CComponentHolder&, const Point& cursorPosition)
+		{
+			bool skillKnown = parent->hero->getSecSkillLevel(ID);
+			bool canLearn = parent->hero->canLearnSkill(ID);
 
-	pos.h = icon->pos.h;
-	pos.w = icon->pos.w;
+			if(!skillKnown && canLearn)
+				GH.windows().createAndPushWindow<CUnivConfirmWindow>(parent, ID, LOCPLINT->cb->getResourceAmount(EGameResID::GOLD) >= 2000);
+		});
+	update();
 }
 
-void CUniversityWindow::CItem::clickPressed(const Point & cursorPosition)
+void CUniversityWindow::CItem::update()
 {
-	if(state() == 2)
-		GH.windows().createAndPushWindow<CUnivConfirmWindow>(parent, ID, LOCPLINT->cb->getResourceAmount(EGameResID::GOLD) >= 2000);
-}
+	bool skillKnown = parent->hero->getSecSkillLevel(ID);
+	bool canLearn =	parent->hero->canLearnSkill(ID);
 
-void CUniversityWindow::CItem::showPopupWindow(const Point & cursorPosition)
-{
-	CRClickPopup::createAndPush(CGI->skillh->getByIndex(ID)->getDescriptionTranslated(1), std::make_shared<CComponent>(ComponentType::SEC_SKILL, ID, 1));
-}
+	ImagePath image;
 
-void CUniversityWindow::CItem::hover(bool on)
-{
-	if(on)
-		GH.statusbar()->write(CGI->skillh->getByIndex(ID)->getNameTranslated());
+	if (skillKnown)
+		image = ImagePath::builtin("UNIVGOLD");
+	else if (canLearn)
+		image = ImagePath::builtin("UNIVGREN");
 	else
-		GH.statusbar()->clear();
-}
+		image = ImagePath::builtin("UNIVRED");
 
-int CUniversityWindow::CItem::state()
-{
-	if(parent->hero->getSecSkillLevel(SecondarySkill(ID)))//hero know this skill
-		return 1;
-	if(!parent->hero->canLearnSkill(SecondarySkill(ID)))//can't learn more skills
-		return 0;
-	return 2;
-}
-
-void CUniversityWindow::CItem::showAll(Canvas & to)
-{
-	//TODO: update when state actually changes
-	auto stateIndex = state();
-	topBar->setFrame(stateIndex);
-	bottomBar->setFrame(stateIndex);
+	OBJECT_CONSTRUCTION;
+	topBar = std::make_shared<CPicture>(image, Point(-28, -22));
+	bottomBar = std::make_shared<CPicture>(image, Point(-28, 48));
 
-	CIntObject::showAll(to);
+	// needs to be on top of background bars
+	name = std::make_shared<CLabel>(22, -13, FONT_SMALL, ETextAlignment::CENTER, Colors::WHITE, ID.toEntity(VLC)->getNameTranslated());
+	level = std::make_shared<CLabel>(22, 57, FONT_SMALL, ETextAlignment::CENTER, Colors::WHITE, CGI->generaltexth->levels[0]);
 }
 
-CUniversityWindow::CUniversityWindow(const CGHeroInstance * _hero, const IMarket * _market, const std::function<void()> & onWindowClosed)
+CUniversityWindow::CUniversityWindow(const CGHeroInstance * _hero, BuildingID building, const IMarket * _market, const std::function<void()> & onWindowClosed)
 	: CWindowObject(PLAYER_COLORED, ImagePath::builtin("UNIVERS1")),
 	hero(_hero),
 	onWindowClosed(onWindowClosed),
 	market(_market)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
+
 
-	bars = GH.renderHandler().createAnimation();
-	bars->setCustom("UNIVRED", 0, 0);
-	bars->setCustom("UNIVGOLD", 1, 0);
-	bars->setCustom("UNIVGREN", 2, 0);
-	bars->preload();
-	
 	std::string titleStr = CGI->generaltexth->allTexts[602];
 	std::string speechStr = CGI->generaltexth->allTexts[603];
 
 	if(auto town = dynamic_cast<const CGTownInstance *>(_market))
 	{
-		auto faction = town->town->faction->getId();
-		auto bid = town->town->getSpecialBuilding(BuildingSubID::MAGIC_UNIVERSITY)->bid;
-		titlePic = std::make_shared<CAnimImage>((*CGI->townh)[faction]->town->clientInfo.buildingsIcons, bid);
+		auto faction = town->getTown()->faction->getId();
+		titlePic = std::make_shared<CAnimImage>((*CGI->townh)[faction]->town->clientInfo.buildingsIcons, building);
 	}
 	else if(auto uni = dynamic_cast<const CGUniversity *>(_market); uni->appearance)
 	{
-		titlePic = std::make_shared<CAnimImage>(uni->appearance->animationFile, 0);
-		titleStr = uni->title;
-		speechStr = uni->speech;
+		titlePic = std::make_shared<CAnimImage>(uni->appearance->animationFile, 0, 0, 0, 0, CShowableAnim::CREATURE_MODE);
+		titleStr = uni->getObjectName();
+		speechStr = uni->getSpeechTranslated();
 	}
 	else
 	{
@@ -971,17 +981,22 @@
 	CStatusbarWindow::close();
 }
 
-void CUniversityWindow::makeDeal(SecondarySkill skill)
+void CUniversityWindow::updateSecondarySkills()
 {
-	LOCPLINT->cb->trade(market, EMarketMode::RESOURCE_SKILL, GameResID(GameResID::GOLD), skill, 1, hero);
+	for (auto const & item : items)
+		item->update();
 }
 
+void CUniversityWindow::makeDeal(SecondarySkill skill)
+{
+	LOCPLINT->cb->trade(market->getObjInstanceID(), EMarketMode::RESOURCE_SKILL, GameResID(GameResID::GOLD), skill, 1, hero);
+}
 
 CUnivConfirmWindow::CUnivConfirmWindow(CUniversityWindow * owner_, SecondarySkill SKILL, bool available)
 	: CWindowObject(PLAYER_COLORED, ImagePath::builtin("UNIVERS2.PCX")),
 	owner(owner_)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	std::string text = CGI->generaltexth->allTexts[608];
 	boost::replace_first(text, "%s", CGI->generaltexth->levels[0]);
@@ -1021,14 +1036,14 @@
 CGarrisonWindow::CGarrisonWindow(const CArmedInstance * up, const CGHeroInstance * down, bool removableUnits)
 	: CWindowObject(PLAYER_COLORED, ImagePath::builtin("GARRISON"))
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	garr = std::make_shared<CGarrisonInt>(Point(92, 127), 4, Point(0,96), up, down, removableUnits);
 	{
-		auto split = std::make_shared<CButton>(Point(88, 314), AnimationPath::builtin("IDV6432.DEF"), CButton::tooltip(CGI->generaltexth->tcommands[3], ""), [&](){ garr->splitClick(); }, EShortcut::HERO_ARMY_SPLIT );
+		auto split = std::make_shared<CButton>(Point(88, 314), AnimationPath::builtin("IDV6432.DEF"), CButton::tooltip(CGI->generaltexth->tcommands[3], ""), [this](){ garr->splitClick(); }, EShortcut::HERO_ARMY_SPLIT );
 		garr->addSplitBtn(split);
 	}
-	quit = std::make_shared<CButton>(Point(399, 314), AnimationPath::builtin("IOK6432.DEF"), CButton::tooltip(CGI->generaltexth->tcommands[8], ""), [&](){ close(); }, EShortcut::GLOBAL_ACCEPT);
+	quit = std::make_shared<CButton>(Point(399, 314), AnimationPath::builtin("IOK6432.DEF"), CButton::tooltip(CGI->generaltexth->tcommands[8], ""), [this](){ close(); }, EShortcut::GLOBAL_ACCEPT);
 
 	std::string titleText;
 	if(down->tempOwner == up->tempOwner)
@@ -1041,7 +1056,7 @@
 		if(up->Slots().size() > 0)
 		{
 			titleText = CGI->generaltexth->allTexts[35];
-			boost::algorithm::replace_first(titleText, "%s", up->Slots().begin()->second->type->getNamePluralTranslated());
+			boost::algorithm::replace_first(titleText, "%s", up->Slots().begin()->second->getType()->getNamePluralTranslated());
 		}
 		else
 		{
@@ -1069,7 +1084,7 @@
 	fort(object),
 	hero(visitor)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	title = std::make_shared<CLabel>(325, 32, FONT_BIG, ETextAlignment::CENTER, Colors::YELLOW, fort->getObjectName());
 
@@ -1098,6 +1113,9 @@
 	statusbar = CGStatusBar::create(std::make_shared<CPicture>(background->getSurface(), Rect(8, pos.h - 26, pos.w - 16, 19), 8, pos.h - 26));
 
 	garr = std::make_shared<CGarrisonInt>(Point(108, 60), 18, Point(), hero, nullptr);
+
+	statusbar->write(VLC->generaltexth->translate(dynamic_cast<const HillFort *>(fort)->getDescriptionToolTip()));
+
 	updateGarrisons();
 }
 
@@ -1115,45 +1133,59 @@
 
 	TResources totalSum; // totalSum[resource ID] = value
 
+	auto getImgIdx = [](CHillFortWindow::State st) -> std::size_t
+	{
+		switch (st)
+		{
+		case State::EMPTY:
+			return 0;
+		case State::UNAVAILABLE:
+		case State::ALREADY_UPGRADED:
+			return 1;
+		default:
+			return static_cast<std::size_t>(st);
+		}
+	};
+
 	for(int i=0; i<slotsCount; i++)
 	{
 		std::fill(costs[i].begin(), costs[i].end(), 0);
-		int newState = getState(SlotID(i));
-		if(newState != -1)
+		State newState = getState(SlotID(i));
+		if(newState != State::EMPTY)
 		{
 			UpgradeInfo info;
 			LOCPLINT->cb->fillUpgradeInfo(hero, SlotID(i), info);
 			if(info.newID.size())//we have upgrades here - update costs
 			{
-				costs[i] = info.cost[0] * hero->getStackCount(SlotID(i));
+				costs[i] = info.cost.back() * hero->getStackCount(SlotID(i));
 				totalSum += costs[i];
 			}
 		}
 
 		currState[i] = newState;
-		upgrade[i]->setImage(AnimationPath::builtin(currState[i] == -1 ? slotImages[0] : slotImages[currState[i]]));
-		upgrade[i]->block(currState[i] == -1);
+		upgrade[i]->setImage(AnimationPath::builtin(slotImages[getImgIdx(currState[i])]));
+		upgrade[i]->block(currState[i] == State::EMPTY);
 		upgrade[i]->addHoverText(EButtonState::NORMAL, getTextForSlot(SlotID(i)));
 	}
 
 	//"Upgrade all" slot
-	int newState = 2;
+	State newState = State::MAKE_UPGRADE;
 	{
 		TResources myRes = LOCPLINT->cb->getResourceAmount();
 
 		bool allUpgraded = true;//All creatures are upgraded?
 		for(int i=0; i<slotsCount; i++)
-			allUpgraded &= currState[i] == 1 || currState[i] == -1;
+			allUpgraded &= currState[i] == State::ALREADY_UPGRADED || currState[i] == State::EMPTY || currState[i] == State::UNAVAILABLE;
 
-		if(allUpgraded)
-			newState = 1;
+		if (allUpgraded)
+			newState = State::ALREADY_UPGRADED;
 
 		if(!totalSum.canBeAfforded(myRes))
-			newState = 0;
+			newState = State::UNAFFORDABLE;
 	}
 
 	currState[slotsCount] = newState;
-	upgradeAll->setImage(AnimationPath::builtin(allImages[newState]));
+	upgradeAll->setImage(AnimationPath::builtin(allImages[static_cast<std::size_t>(newState)]));
 
 	garr->recreateSlots();
 
@@ -1166,7 +1198,7 @@
 			slotLabels[i][j]->setText("");
 		}
 		//if can upgrade or can not afford, draw cost
-		if(currState[i] == 0 || currState[i] == 2)
+		if(currState[i] == State::UNAFFORDABLE || currState[i] == State::MAKE_UPGRADE)
 		{
 			if(costs[i].nonZero())
 			{
@@ -1211,24 +1243,30 @@
 
 void CHillFortWindow::makeDeal(SlotID slot)
 {
-	assert(slot.getNum()>=0);
-	int offset = (slot.getNum() == slotsCount)?2:0;
+	assert(slot.getNum() >= 0);
+	int offset = (slot.getNum() == slotsCount) ? 2 : 0;
 	switch(currState[slot.getNum()])
 	{
-		case 0:
+		case State::ALREADY_UPGRADED:
+			LOCPLINT->showInfoDialog(CGI->generaltexth->allTexts[313 + offset], std::vector<std::shared_ptr<CComponent>>(), soundBase::sound_todo);
+			break;
+		case State::UNAFFORDABLE:
 			LOCPLINT->showInfoDialog(CGI->generaltexth->allTexts[314 + offset], std::vector<std::shared_ptr<CComponent>>(), soundBase::sound_todo);
 			break;
-		case 1:
-			LOCPLINT->showInfoDialog(CGI->generaltexth->allTexts[313 + offset], std::vector<std::shared_ptr<CComponent>>(), soundBase::sound_todo);
+		case State::UNAVAILABLE:
+		{
+			std::string message = VLC->generaltexth->translate(dynamic_cast<const HillFort *>(fort)->getUnavailableUpgradeMessage());
+			LOCPLINT->showInfoDialog(message, std::vector<std::shared_ptr<CComponent>>(), soundBase::sound_todo);
 			break;
-		case 2:
-			for(int i=0; i<slotsCount; i++)
+		}
+		case State::MAKE_UPGRADE:
+			for(int i = 0; i < slotsCount; i++)
 			{
-				if(slot.getNum() ==i || ( slot.getNum() == slotsCount && currState[i] == 2 ))//this is activated slot or "upgrade all"
+				if(slot.getNum() == i || ( slot.getNum() == slotsCount && currState[i] == State::MAKE_UPGRADE ))//this is activated slot or "upgrade all"
 				{
 					UpgradeInfo info;
 					LOCPLINT->cb->fillUpgradeInfo(hero, SlotID(i), info);
-					LOCPLINT->cb->upgradeCreature(hero, SlotID(i), info.newID[0]);
+					LOCPLINT->cb->upgradeCreature(hero, SlotID(i), info.newID.back());
 				}
 			}
 			break;
@@ -1250,29 +1288,35 @@
 	return str;
 }
 
-int CHillFortWindow::getState(SlotID slot)
+CHillFortWindow::State CHillFortWindow::getState(SlotID slot)
 {
 	TResources myRes = LOCPLINT->cb->getResourceAmount();
 
-	if(hero->slotEmpty(slot))//no creature here
-		return -1;
+	if(hero->slotEmpty(slot))
+		return State::EMPTY;
 
 	UpgradeInfo info;
 	LOCPLINT->cb->fillUpgradeInfo(hero, slot, info);
-	if(!info.newID.size())//already upgraded
-		return 1;
+	if (info.newID.empty())
+	{
+		// Hill Fort may limit level of upgradeable creatures, e.g. mini Hill Fort from HOTA
+		if (hero->getCreature(slot)->hasUpgrades())
+			return State::UNAVAILABLE;
 
-	if(!(info.cost[0] * hero->getStackCount(slot)).canBeAfforded(myRes))
-		return 0;
+		return State::ALREADY_UPGRADED;
+	}
 
-	return 2;//can upgrade
+	if(!(info.cost.back() * hero->getStackCount(slot)).canBeAfforded(myRes))
+		return State::UNAFFORDABLE;
+
+	return State::MAKE_UPGRADE;
 }
 
 CThievesGuildWindow::CThievesGuildWindow(const CGObjectInstance * _owner):
 	CWindowObject(PLAYER_COLORED | BORDERED, ImagePath::builtin("TpRank")),
 	owner(_owner)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	SThievesGuildInfo tgi; //info to be displayed
 	LOCPLINT->cb->getThievesGuildInfo(tgi, owner);
@@ -1304,18 +1348,12 @@
 		rowHeaders.push_back(std::make_shared<CLabel>(135, y, FONT_MEDIUM, ETextAlignment::CENTER, Colors::YELLOW, text));
 	}
 
-	auto PRSTRIPS = GH.renderHandler().loadAnimation(AnimationPath::builtin("PRSTRIPS"));
-	PRSTRIPS->preload();
-
 	for(int g=1; g<tgi.playerColors.size(); ++g)
-		columnBackgrounds.push_back(std::make_shared<CAnimImage>(PRSTRIPS, g-1, 0, 250 + 66*g, 7));
+		columnBackgrounds.push_back(std::make_shared<CAnimImage>(AnimationPath::builtin("PRSTRIPS"), g-1, 0, 250 + 66*g, 7));
 
 	for(int g=0; g<tgi.playerColors.size(); ++g)
 		columnHeaders.push_back(std::make_shared<CLabel>(283 + 66*g, 24, FONT_BIG, ETextAlignment::CENTER, Colors::YELLOW, CGI->generaltexth->jktexts[16+g]));
 
-	auto itgflags = GH.renderHandler().loadAnimation(AnimationPath::builtin("itgflags"));
-	itgflags->preload();
-
 	//printing flags
 	for(int g = 0; g < std::size(fields); ++g) //by lines
 	{
@@ -1339,7 +1377,7 @@
 				int rowStartY = ypos + (j ? 4 : 0);
 
 				for(size_t i=0; i < rowLength[j]; i++)
-					cells.push_back(std::make_shared<CAnimImage>(itgflags, players[i + j*4].getNum(), 0, rowStartX + (int)i*12, rowStartY));
+					cells.push_back(std::make_shared<CAnimImage>(AnimationPath::builtin("itgflags"), players[i + j*4].getNum(), 0, rowStartX + (int)i*12, rowStartY));
 			}
 		}
 	}
@@ -1406,7 +1444,7 @@
 	parent(_parent),
 	index(_id)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
 	if(parent->images.size() > index)
 		icon = std::make_shared<CPicture>(parent->images[index], Point(1, 1));
 	border = std::make_shared<CPicture>(ImagePath::builtin("TPGATES"));
@@ -1453,39 +1491,47 @@
 		parent->onPopup(index);
 }
 
-CObjectListWindow::CObjectListWindow(const std::vector<int> & _items, std::shared_ptr<CIntObject> titleWidget_, std::string _title, std::string _descr, std::function<void(int)> Callback, size_t initialSelection, std::vector<std::shared_ptr<IImage>> images)
+CObjectListWindow::CObjectListWindow(const std::vector<int> & _items, std::shared_ptr<CIntObject> titleWidget_, std::string _title, std::string _descr, std::function<void(int)> Callback, size_t initialSelection, std::vector<std::shared_ptr<IImage>> images, bool searchBoxEnabled)
 	: CWindowObject(PLAYER_COLORED, ImagePath::builtin("TPGATE")),
 	onSelect(Callback),
 	selected(initialSelection),
 	images(images)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
+
+	addUsedEvents(KEYBOARD);
+
 	items.reserve(_items.size());
 
 	for(int id : _items)
-	{
 		items.push_back(std::make_pair(id, LOCPLINT->cb->getObjInstance(ObjectInstanceID(id))->getObjectName()));
-	}
+	itemsVisible = items;
 
-	init(titleWidget_, _title, _descr);
+	init(titleWidget_, _title, _descr, searchBoxEnabled);
+	list->scrollTo(std::min(static_cast<int>(initialSelection + 4), static_cast<int>(items.size() - 1))); // 4 is for centering (list have 9 elements)
 }
 
-CObjectListWindow::CObjectListWindow(const std::vector<std::string> & _items, std::shared_ptr<CIntObject> titleWidget_, std::string _title, std::string _descr, std::function<void(int)> Callback, size_t initialSelection, std::vector<std::shared_ptr<IImage>> images)
+CObjectListWindow::CObjectListWindow(const std::vector<std::string> & _items, std::shared_ptr<CIntObject> titleWidget_, std::string _title, std::string _descr, std::function<void(int)> Callback, size_t initialSelection, std::vector<std::shared_ptr<IImage>> images, bool searchBoxEnabled)
 	: CWindowObject(PLAYER_COLORED, ImagePath::builtin("TPGATE")),
 	onSelect(Callback),
 	selected(initialSelection),
 	images(images)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255-DISPOSE);
+	OBJECT_CONSTRUCTION;
+
+	addUsedEvents(KEYBOARD);
+
 	items.reserve(_items.size());
 
 	for(size_t i=0; i<_items.size(); i++)
 		items.push_back(std::make_pair(int(i), _items[i]));
+	itemsVisible = items;
 
-	init(titleWidget_, _title, _descr);
+	init(titleWidget_, _title, _descr, searchBoxEnabled);
+	list->scrollTo(std::min(static_cast<int>(initialSelection + 4), static_cast<int>(items.size() - 1))); // 4 is for centering (list have 9 elements)
 }
 
-void CObjectListWindow::init(std::shared_ptr<CIntObject> titleWidget_, std::string _title, std::string _descr)
+void CObjectListWindow::init(std::shared_ptr<CIntObject> titleWidget_, std::string _title, std::string _descr, bool searchBoxEnabled)
 {
 	titleWidget = titleWidget_;
 
@@ -1496,29 +1542,55 @@
 	if(titleWidget)
 	{
 		addChild(titleWidget.get());
-		titleWidget->recActions = 255-DISPOSE;
 		titleWidget->pos.x = pos.w/2 + pos.x - titleWidget->pos.w/2;
 		titleWidget->pos.y =75 + pos.y - titleWidget->pos.h/2;
 	}
 	list = std::make_shared<CListBox>(std::bind(&CObjectListWindow::genItem, this, _1),
-		Point(14, 151), Point(0, 25), 9, items.size(), 0, 1, Rect(262, -32, 256, 256) );
+		Point(14, 151), Point(0, 25), 9, itemsVisible.size(), 0, 1, Rect(262, -32, 256, 256) );
 	list->setRedrawParent(true);
 
 	ok = std::make_shared<CButton>(Point(15, 402), AnimationPath::builtin("IOKAY.DEF"), CButton::tooltip(), std::bind(&CObjectListWindow::elementSelected, this), EShortcut::GLOBAL_ACCEPT);
 	ok->block(!list->size());
+
+	if(!searchBoxEnabled)
+		return;
+
+	Rect r(50, 90, pos.w - 100, 16);
+	const ColorRGBA rectangleColor = ColorRGBA(0, 0, 0, 75);
+	const ColorRGBA borderColor = ColorRGBA(128, 100, 75);
+	const ColorRGBA grayedColor = ColorRGBA(158, 130, 105);
+	searchBoxRectangle = std::make_shared<TransparentFilledRectangle>(r.resize(1), rectangleColor, borderColor);
+	searchBoxDescription = std::make_shared<CLabel>(r.center().x, r.center().y, FONT_SMALL, ETextAlignment::CENTER, grayedColor, CGI->generaltexth->translate("vcmi.spellBook.search"));
+
+	searchBox = std::make_shared<CTextInput>(r, FONT_SMALL, ETextAlignment::CENTER, true);
+	searchBox->setCallback([this](const std::string & text){
+		searchBoxDescription->setEnabled(text.empty());
+
+		itemsVisible.clear();
+		for(auto & item : items)
+			if(boost::algorithm::contains(boost::algorithm::to_lower_copy(item.second), boost::algorithm::to_lower_copy(text)))
+				itemsVisible.push_back(item);
+
+		selected = 0;
+		list->resize(itemsVisible.size());
+		list->scrollTo(0);
+		ok->block(!itemsVisible.size());
+
+		redraw();
+	});
 }
 
 std::shared_ptr<CIntObject> CObjectListWindow::genItem(size_t index)
 {
-	if(index < items.size())
-		return std::make_shared<CItem>(this, index, items[index].second);
+	if(index < itemsVisible.size())
+		return std::make_shared<CItem>(this, index, itemsVisible[index].second);
 	return std::shared_ptr<CIntObject>();
 }
 
 void CObjectListWindow::elementSelected()
 {
 	std::function<void(int)> toCall = onSelect;//save
-	int where = items[selected].first;      //required variables
+	int where = itemsVisible[selected].first;      //required variables
 	close();//then destroy window
 	toCall(where);//and send selected object
 }
@@ -1574,13 +1646,69 @@
 		sel = 0;
 
 	break; case EShortcut::MOVE_LAST:
-		sel = static_cast<int>(items.size());
+		sel = static_cast<int>(itemsVisible.size());
 
 	break; default:
 		return;
 	}
 
-	vstd::abetween<int>(sel, 0, items.size()-1);
+	vstd::abetween<int>(sel, 0, itemsVisible.size()-1);
 	list->scrollTo(sel);
 	changeSelection(sel);
 }
+
+VideoWindow::VideoWindow(const VideoPath & video, const ImagePath & rim, bool showBackground, float scaleFactor, const std::function<void(bool skipped)> & closeCb)
+	: CWindowObject(BORDERED | SHADOW_DISABLED | NEEDS_ANIMATED_BACKGROUND), closeCb(closeCb)
+{
+	OBJECT_CONSTRUCTION;
+
+	addUsedEvents(LCLICK | KEYBOARD);
+
+	if(showBackground)
+		backgroundAroundWindow = std::make_shared<CFilledTexture>(ImagePath::builtin("DIBOXBCK"), Rect(0, 0, GH.screenDimensions().x, GH.screenDimensions().y));
+	
+	if(!rim.empty())
+	{
+		setBackground(rim);
+		videoPlayer = std::make_shared<VideoWidgetOnce>(Point(80, 186), video, true, this);
+		pos = center(Rect(0, 0, 800, 600));
+	}
+	else
+	{
+		blackBackground = std::make_shared<GraphicalPrimitiveCanvas>(Rect(0, 0, GH.screenDimensions().x, GH.screenDimensions().y));
+		videoPlayer = std::make_shared<VideoWidgetOnce>(Point(0, 0), video, true, scaleFactor, this);
+		pos = center(Rect(0, 0, videoPlayer->pos.w, videoPlayer->pos.h));
+		blackBackground->addBox(Point(0, 0), Point(pos.x, pos.y), Colors::BLACK);
+	}
+
+	if(backgroundAroundWindow)
+		backgroundAroundWindow->pos.moveTo(Point(0, 0));
+}
+
+void VideoWindow::onVideoPlaybackFinished()
+{
+	exit(false);
+}
+
+
+void VideoWindow::exit(bool skipped)
+{
+	close();
+	if(closeCb)
+		closeCb(skipped);
+}
+
+void VideoWindow::clickPressed(const Point & cursorPosition)
+{
+	exit(true);
+}
+
+void VideoWindow::keyPressed(EShortcut key)
+{
+	exit(true);
+}
+
+void VideoWindow::notFocusedClick()
+{
+	exit(true);
+}
diff --color -urN vcmi-1.5.7/client/windows/GUIClasses.h vcmi/client/windows/GUIClasses.h
--- vcmi-1.5.7/client/windows/GUIClasses.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/windows/GUIClasses.h	2024-12-19 15:00:22.394127109 +0100
@@ -12,6 +12,7 @@
 #include "CWindowObject.h"
 #include "../lib/ResourceSet.h"
 #include "../widgets/Images.h"
+#include "../widgets/IVideoHolder.h"
 
 VCMI_LIB_NAMESPACE_BEGIN
 
@@ -42,6 +43,11 @@
 class CAnimImage;
 class CFilledTexture;
 class IImage;
+class VideoWidget;
+class VideoWidgetOnce;
+class GraphicalPrimitiveCanvas;
+class TransparentFilledRectangle;
+class CSecSkillPlace;
 
 enum class EUserEvent;
 
@@ -183,9 +189,14 @@
 	std::shared_ptr<CButton> ok;
 	std::shared_ptr<CButton> exit;
 
-	std::vector< std::pair<int, std::string> > items;//all items present in list
+	std::shared_ptr<CTextInput> searchBox;
+	std::shared_ptr<TransparentFilledRectangle> searchBoxRectangle;
+	std::shared_ptr<CLabel> searchBoxDescription;
 
-	void init(std::shared_ptr<CIntObject> titleWidget_, std::string _title, std::string _descr);
+	std::vector< std::pair<int, std::string> > items; //all items present in list
+	std::vector< std::pair<int, std::string> > itemsVisible; //visible items present in list
+
+	void init(std::shared_ptr<CIntObject> titleWidget_, std::string _title, std::string _descr, bool searchBoxEnabled);
 	void exitPressed();
 public:
 	size_t selected;//index of currently selected item
@@ -197,8 +208,8 @@
 	/// Callback will be called when OK button is pressed, returns id of selected item. initState = initially selected item
 	/// Image can be nullptr
 	///item names will be taken from map objects
-	CObjectListWindow(const std::vector<int> &_items, std::shared_ptr<CIntObject> titleWidget_, std::string _title, std::string _descr, std::function<void(int)> Callback, size_t initialSelection = 0, std::vector<std::shared_ptr<IImage>> images = {});
-	CObjectListWindow(const std::vector<std::string> &_items, std::shared_ptr<CIntObject> titleWidget_, std::string _title, std::string _descr, std::function<void(int)> Callback, size_t initialSelection = 0, std::vector<std::shared_ptr<IImage>> images = {});
+	CObjectListWindow(const std::vector<int> &_items, std::shared_ptr<CIntObject> titleWidget_, std::string _title, std::string _descr, std::function<void(int)> Callback, size_t initialSelection = 0, std::vector<std::shared_ptr<IImage>> images = {}, bool searchBoxEnabled = false);
+	CObjectListWindow(const std::vector<std::string> &_items, std::shared_ptr<CIntObject> titleWidget_, std::string _title, std::string _descr, std::function<void(int)> Callback, size_t initialSelection = 0, std::vector<std::shared_ptr<IImage>> images = {}, bool searchBoxEnabled = false);
 
 	std::shared_ptr<CIntObject> genItem(size_t index);
 	void elementSelected();//call callback and close this window
@@ -237,6 +248,10 @@
 	{
 	public:
 		std::shared_ptr<CFilledTexture> background;
+		std::shared_ptr<CSlider> slider;
+
+		const int MAX_LINES = 18;
+		const int ELEM_PER_LINES = 16;
 
 		HeroSelector(std::map<HeroTypeID, CGHeroInstance*> InviteableHeroes, std::function<void(CGHeroInstance*)> OnChoose);
 
@@ -246,6 +261,9 @@
 
 		std::vector<std::shared_ptr<CAnimImage>> portraits;
 		std::vector<std::shared_ptr<LRClickableArea>> portraitAreas;
+
+		void recreate();
+		void sliderMove(int slidPos);
 	};
 
 	//recruitable heroes
@@ -265,6 +283,7 @@
 	std::shared_ptr<CLabel> cost;
 	std::shared_ptr<CLabel> heroesForHire;
 	std::shared_ptr<CTextBox> heroDescription;
+	std::shared_ptr<VideoWidget> videoPlayer;
 
 	std::shared_ptr<CTextBox> rumor;
 	
@@ -276,7 +295,6 @@
 	void addInvite();
 
 	CTavernWindow(const CGObjectInstance * TavernObj, const std::function<void()> & onWindowClosed);
-	~CTavernWindow();
 
 	void close() override;
 	void recruitb();
@@ -288,7 +306,7 @@
 class CShipyardWindow : public CStatusbarWindow
 {
 	std::shared_ptr<CPicture> bgWater;
-	std::shared_ptr<CAnimImage> bgShip;
+	std::shared_ptr<CShowableAnim> bgShip;
 
 	std::shared_ptr<CLabel> title;
 	std::shared_ptr<CLabel> costLabel;
@@ -350,32 +368,26 @@
 	CTransformerWindow(const IMarket * _market, const CGHeroInstance * _hero, const std::function<void()> & onWindowClosed);
 };
 
-class CUniversityWindow : public CStatusbarWindow
+class CUniversityWindow final : public CStatusbarWindow, public IMarketHolder
 {
-	class CItem : public CIntObject
+	class CItem final : public CIntObject
 	{
-		std::shared_ptr<CAnimImage> icon;
-		std::shared_ptr<CAnimImage> topBar;
-		std::shared_ptr<CAnimImage> bottomBar;
+		std::shared_ptr<CSecSkillPlace> skill;
+		std::shared_ptr<CPicture> topBar;
+		std::shared_ptr<CPicture> bottomBar;
 		std::shared_ptr<CLabel> name;
 		std::shared_ptr<CLabel> level;
 	public:
 		SecondarySkill ID;//id of selected skill
 		CUniversityWindow * parent;
 
-		void showAll(Canvas & to) override;
-		void clickPressed(const Point & cursorPosition) override;
-		void showPopupWindow(const Point & cursorPosition) override;
-		void hover(bool on) override;
-		int state();//0=can't learn, 1=learned, 2=can learn
+		void update();
 		CItem(CUniversityWindow * _parent, int _ID, int X, int Y);
 	};
 
 	const CGHeroInstance * hero;
 	const IMarket * market;
 
-	std::shared_ptr<CAnimation> bars;
-
 	std::vector<std::shared_ptr<CItem>> items;
 
 	std::shared_ptr<CButton> cancel;
@@ -386,14 +398,17 @@
 	std::function<void()> onWindowClosed;
 
 public:
-	CUniversityWindow(const CGHeroInstance * _hero, const IMarket * _market, const std::function<void()> & onWindowClosed);
+	CUniversityWindow(const CGHeroInstance * _hero, BuildingID building, const IMarket * _market, const std::function<void()> & onWindowClosed);
 
 	void makeDeal(SecondarySkill skill);
-	void close();
+	void close() override;
+
+	// IMarketHolder impl
+	void updateSecondarySkills() override;
 };
 
 /// Confirmation window for University
-class CUnivConfirmWindow : public CStatusbarWindow
+class CUnivConfirmWindow final : public CStatusbarWindow
 {
 	std::shared_ptr<CTextBox> clerkSpeech;
 	std::shared_ptr<CLabel> name;
@@ -435,9 +450,11 @@
 class CHillFortWindow : public CStatusbarWindow, public IGarrisonHolder
 {
 private:
-	static const int slotsCount = 7;
+
+	enum class State { UNAFFORDABLE, ALREADY_UPGRADED, MAKE_UPGRADE, EMPTY, UNAVAILABLE };
+	static constexpr std::size_t slotsCount = 7;
 	//todo: mithril support
-	static const int resCount = 7;
+	static constexpr std::size_t resCount = 7;
 
 	const CGObjectInstance * fort;
 	const CGHeroInstance * hero;
@@ -449,7 +466,7 @@
 	std::array<std::shared_ptr<CLabel>, resCount> totalLabels;
 
 	std::array<std::shared_ptr<CButton>, slotsCount> upgrade;//upgrade single creature
-	std::array<int, slotsCount + 1> currState;//current state of slot - to avoid calls to getState or updating buttons
+	std::array<State, slotsCount + 1> currState;//current state of slot - to avoid calls to getState or updating buttons
 
 	//there is a place for only 2 resources per slot
 	std::array< std::array<std::shared_ptr<CAnimImage>, 2>, slotsCount> slotIcons;
@@ -464,7 +481,7 @@
 	std::string getTextForSlot(SlotID slot);
 
 	void makeDeal(SlotID slot);//-1 for upgrading all creatures
-	int getState(SlotID slot); //-1 = no creature 0=can't upgrade, 1=upgraded, 2=can upgrade
+	State getState(SlotID slot);
 public:
 	CHillFortWindow(const CGHeroInstance * visitor, const CGObjectInstance * object);
 	void updateGarrisons() override;//update buttons after garrison changes
@@ -493,3 +510,20 @@
 	CThievesGuildWindow(const CGObjectInstance * _owner);
 };
 
+class VideoWindow : public CWindowObject, public IVideoHolder
+{
+	std::shared_ptr<VideoWidgetOnce> videoPlayer;
+	std::shared_ptr<CFilledTexture> backgroundAroundWindow;
+	std::shared_ptr<GraphicalPrimitiveCanvas> blackBackground;
+
+	std::function<void(bool)> closeCb;
+
+	void onVideoPlaybackFinished() override;
+	void exit(bool skipped);
+public:
+	VideoWindow(const VideoPath & video, const ImagePath & rim, bool showBackground, float scaleFactor, const std::function<void(bool)> & closeCb);
+
+	void clickPressed(const Point & cursorPosition) override;
+	void keyPressed(EShortcut key) override;
+	void notFocusedClick() override;
+};
diff --color -urN vcmi-1.5.7/client/windows/InfoWindows.cpp vcmi/client/windows/InfoWindows.cpp
--- vcmi-1.5.7/client/windows/InfoWindows.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/windows/InfoWindows.cpp	2024-12-19 15:00:22.397127233 +0100
@@ -38,7 +38,7 @@
 
 CSelWindow::CSelWindow( const std::string & Text, PlayerColor player, int charperline, const std::vector<std::shared_ptr<CSelectableComponent>> & comps, const std::vector<std::pair<AnimationPath, CFunctionList<void()>>> & Buttons, QueryID askID)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255 - DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	backgroundTexture = std::make_shared<CFilledTexture>(ImagePath::builtin("DiBoxBck"), pos);
 
@@ -94,7 +94,7 @@
 
 CInfoWindow::CInfoWindow(const std::string & Text, PlayerColor player, const TCompsInfo & comps, const TButtonsInfo & Buttons)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255 - DISPOSE);
+	OBJECT_CONSTRUCTION;
 
 	backgroundTexture = std::make_shared<CFilledTexture>(ImagePath::builtin("DiBoxBck"), pos);
 
@@ -187,11 +187,6 @@
 	return true;
 }
 
-void CRClickPopup::close()
-{
-	WindowBase::close();
-}
-
 void CRClickPopup::createAndPush(const std::string & txt, const CInfoWindow::TCompsInfo & comps)
 {
 	PlayerColor player = LOCPLINT ? LOCPLINT->playerID : PlayerColor(1); //if no player, then use blue
@@ -245,11 +240,12 @@
 	}
 }
 
-CRClickPopupInt::CRClickPopupInt(const std::shared_ptr<CIntObject> & our)
+CRClickPopupInt::CRClickPopupInt(const std::shared_ptr<CIntObject> & our) :
+	dragDistance(Point(0, 0))
 {
+	addUsedEvents(DRAG_POPUP);
+
 	CCS->curh->hide();
-	defActions = SHOWALL | UPDATE;
-	our->recActions = defActions;
 	inner = our;
 	addChild(our.get(), false);
 }
@@ -259,51 +255,80 @@
 	CCS->curh->show();
 }
 
-Point CInfoBoxPopup::toScreen(Point p)
+void CRClickPopupInt::mouseDraggedPopup(const Point & cursorPosition, const Point & lastUpdateDistance)
 {
-	auto bounds = adventureInt->terrainAreaPixels();
-
-	vstd::abetween(p.x, bounds.top() + 100, bounds.bottom() - 100);
-	vstd::abetween(p.y, bounds.left() + 100, bounds.right() - 100);
+	if(!settings["adventure"]["rightButtonDrag"].Bool())
+		return;
+	
+	dragDistance += lastUpdateDistance;
+	
+	if(dragDistance.length() > 16)
+		close();
+}
 
-	return p;
+void CInfoBoxPopup::mouseDraggedPopup(const Point & cursorPosition, const Point & lastUpdateDistance)
+{
+	if(!settings["adventure"]["rightButtonDrag"].Bool())
+		return;
+	
+	dragDistance += lastUpdateDistance;
+	
+	if(dragDistance.length() > 16)
+		close();
 }
 
+
 CInfoBoxPopup::CInfoBoxPopup(Point position, const CGTownInstance * town)
-	: CWindowObject(RCLICK_POPUP | PLAYER_COLORED, ImagePath::builtin("TOWNQVBK"), toScreen(position))
+	: CWindowObject(RCLICK_POPUP | PLAYER_COLORED, ImagePath::builtin("TOWNQVBK"), position)
 {
 	InfoAboutTown iah;
-	LOCPLINT->cb->getTownInfo(town, iah, LOCPLINT->localState->getCurrentTown()); //todo: should this be nearest hero?
+	LOCPLINT->cb->getTownInfo(town, iah, LOCPLINT->localState->getCurrentArmy()); //todo: should this be nearest hero?
 
-	OBJECT_CONSTRUCTION_CAPTURING(255 - DISPOSE);
+	OBJECT_CONSTRUCTION;
 	tooltip = std::make_shared<CTownTooltip>(Point(9, 10), iah);
+
+	addUsedEvents(DRAG_POPUP);
+
+	fitToScreen(10);
 }
 
 CInfoBoxPopup::CInfoBoxPopup(Point position, const CGHeroInstance * hero)
-	: CWindowObject(RCLICK_POPUP | PLAYER_COLORED, ImagePath::builtin("HEROQVBK"), toScreen(position))
+	: CWindowObject(RCLICK_POPUP | PLAYER_COLORED, ImagePath::builtin("HEROQVBK"), position)
 {
 	InfoAboutHero iah;
-	LOCPLINT->cb->getHeroInfo(hero, iah, LOCPLINT->localState->getCurrentHero()); //todo: should this be nearest hero?
+	LOCPLINT->cb->getHeroInfo(hero, iah, LOCPLINT->localState->getCurrentArmy()); //todo: should this be nearest hero?
 
-	OBJECT_CONSTRUCTION_CAPTURING(255 - DISPOSE);
+	OBJECT_CONSTRUCTION;
 	tooltip = std::make_shared<CHeroTooltip>(Point(9, 10), iah);
+	
+	addUsedEvents(DRAG_POPUP);
+
+	fitToScreen(10);
 }
 
 CInfoBoxPopup::CInfoBoxPopup(Point position, const CGGarrison * garr)
-	: CWindowObject(RCLICK_POPUP | PLAYER_COLORED, ImagePath::builtin("TOWNQVBK"), toScreen(position))
+	: CWindowObject(RCLICK_POPUP | PLAYER_COLORED, ImagePath::builtin("TOWNQVBK"), position)
 {
 	InfoAboutTown iah;
 	LOCPLINT->cb->getTownInfo(garr, iah);
 
-	OBJECT_CONSTRUCTION_CAPTURING(255 - DISPOSE);
+	OBJECT_CONSTRUCTION;
 	tooltip = std::make_shared<CArmyTooltip>(Point(9, 10), iah);
+	
+	addUsedEvents(DRAG_POPUP);
+
+	fitToScreen(10);
 }
 
 CInfoBoxPopup::CInfoBoxPopup(Point position, const CGCreature * creature)
-	: CWindowObject(RCLICK_POPUP | BORDERED, ImagePath::builtin("DIBOXBCK"), toScreen(position))
+	: CWindowObject(RCLICK_POPUP | BORDERED, ImagePath::builtin("DIBOXBCK"), position)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(255 - DISPOSE);
+	OBJECT_CONSTRUCTION;
 	tooltip = std::make_shared<CreatureTooltip>(Point(9, 10), creature);
+	
+	addUsedEvents(DRAG_POPUP);
+
+	fitToScreen(10);
 }
 
 std::shared_ptr<WindowBase>
diff --color -urN vcmi-1.5.7/client/windows/InfoWindows.h vcmi/client/windows/InfoWindows.h
--- vcmi-1.5.7/client/windows/InfoWindows.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/windows/InfoWindows.h	2024-12-19 15:00:22.397127233 +0100
@@ -64,7 +64,6 @@
 class CRClickPopup : public WindowBase
 {
 public:
-	void close() override;
 	bool isPopupWindow() const override;
 
 	static std::shared_ptr<WindowBase> createCustomInfoWindow(Point position, const CGObjectInstance * specific);
@@ -78,22 +77,29 @@
 {
 	std::shared_ptr<CIntObject> inner;
 
+	Point dragDistance;
+
 public:
 	CRClickPopupInt(const std::shared_ptr<CIntObject> & our);
 	~CRClickPopupInt();
+
+	void mouseDraggedPopup(const Point & cursorPosition, const Point & lastUpdateDistance) override;
 };
 
 /// popup on adventure map for town\hero and other objects with customized popup content
 class CInfoBoxPopup : public CWindowObject
 {
 	std::shared_ptr<CIntObject> tooltip;
-	Point toScreen(Point pos);
+
+	Point dragDistance;
 
 public:
 	CInfoBoxPopup(Point position, const CGTownInstance * town);
 	CInfoBoxPopup(Point position, const CGHeroInstance * hero);
 	CInfoBoxPopup(Point position, const CGGarrison * garr);
 	CInfoBoxPopup(Point position, const CGCreature * creature);
+
+	void mouseDraggedPopup(const Point & cursorPosition, const Point & lastUpdateDistance) override;
 };
 
 /// component selection window
diff --color -urN vcmi-1.5.7/client/windows/QuickRecruitmentWindow.cpp vcmi/client/windows/QuickRecruitmentWindow.cpp
--- vcmi-1.5.7/client/windows/QuickRecruitmentWindow.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/windows/QuickRecruitmentWindow.cpp	2024-12-19 15:00:22.398127275 +0100
@@ -51,9 +51,9 @@
 {
 	int availableAmount = getAvailableCreatures();
 	Point position = Point((pos.w - 100*availableAmount - 8*(availableAmount-1))/2,64);
-	for (int i = 0; i < GameConstants::CREATURES_PER_TOWN; i++)
+	for (int i = 0; i < town->getTown()->creatures.size(); i++)
 	{
-		if(!town->town->creatures.at(i).empty() && !town->creatures.at(i).second.empty() && town->creatures[i].first)
+		if(!town->getTown()->creatures.at(i).empty() && !town->creatures.at(i).second.empty() && town->creatures[i].first)
 		{
 			cards.push_back(std::make_shared<CreaturePurchaseCard>(town->creatures[i].second, position, town->creatures[i].first, this));
 			position.x += 108;
@@ -106,7 +106,16 @@
 	{
 		if(selected->slider->getValue())
 		{
-			auto onRecruit = [=](CreatureID id, int count){ LOCPLINT->cb->recruitCreatures(town, town->getUpperArmy(), id, count, selected->creatureOnTheCard->getLevel()-1); };
+			int level = 0;
+			int i = 0;
+			for(auto c : town->getTown()->creatures)
+			{
+				for(auto c2 : c)
+					if(c2 == selected->creatureOnTheCard->getId())
+						level = i;
+				i++;
+			}
+			auto onRecruit = [=](CreatureID id, int count){ LOCPLINT->cb->recruitCreatures(town, town->getUpperArmy(), id, count, level); };
 			CreatureID crid =  selected->creatureOnTheCard->getId();
 			SlotID dstslot = town -> getSlotFor(crid);
 			if(!dstslot.validSlot())
@@ -120,8 +129,8 @@
 int QuickRecruitmentWindow::getAvailableCreatures()
 {
 	int creaturesAmount = 0;
-	for (int i=0; i< GameConstants::CREATURES_PER_TOWN; i++)
-		if(!town->town->creatures.at(i).empty() && !town->creatures.at(i).second.empty() && town->creatures[i].first)
+	for (int i=0; i< town->getTown()->creatures.size(); i++)
+		if(!town->getTown()->creatures.at(i).empty() && !town->creatures.at(i).second.empty() && town->creatures[i].first)
 			creaturesAmount++;
 	return creaturesAmount;
 }
@@ -151,10 +160,12 @@
 	: CWindowObject(PLAYER_COLORED | BORDERED),
 	town(townd)
 {
-	OBJECT_CONSTRUCTION_CAPTURING(ACTIVATE + DEACTIVATE + UPDATE + SHOWALL);
+	OBJECT_CONSTRUCTION;
 
 	initWindow(startupPosition);
 	setButtons();
 	setCreaturePurchaseCards();
 	maxAllCards(cards);
+
+	center();
 }
diff --color -urN vcmi-1.5.7/client/windows/settings/AdventureOptionsTab.cpp vcmi/client/windows/settings/AdventureOptionsTab.cpp
--- vcmi-1.5.7/client/windows/settings/AdventureOptionsTab.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/windows/settings/AdventureOptionsTab.cpp	2024-12-19 15:00:22.399127316 +0100
@@ -11,6 +11,7 @@
 
 #include "AdventureOptionsTab.h"
 
+#include "../../eventsSDL/InputHandler.h"
 #include "../../../lib/filesystem/ResourcePath.h"
 #include "../../gui/CGuiHandler.h"
 #include "../../widgets/Buttons.h"
@@ -33,9 +34,12 @@
 AdventureOptionsTab::AdventureOptionsTab()
 		: InterfaceObjectConfigurable()
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 	setRedrawParent(true);
 
+	addConditional("touchscreen", GH.input().getCurrentInputMode() == InputMode::TOUCH);
+	addConditional("keyboardMouse", GH.input().getCurrentInputMode() == InputMode::KEYBOARD_AND_MOUSE);
+	addConditional("controller", GH.input().getCurrentInputMode() == InputMode::CONTROLLER);
 #ifdef VCMI_MOBILE
 	addConditional("mobile", true);
 	addConditional("desktop", false);
@@ -126,6 +130,10 @@
 	{
 		return setBoolSetting("adventure", "leftButtonDrag", value);
 	});
+	addCallback("rightButtonDragChanged", [](bool value)
+	{
+		return setBoolSetting("adventure", "rightButtonDrag", value);
+	});
 	addCallback("smoothDraggingChanged", [](bool value)
 	{
 		return setBoolSetting("adventure", "smoothDragging", value);
@@ -177,6 +185,10 @@
 	if (leftButtonDragCheckbox)
 		leftButtonDragCheckbox->setSelected(settings["adventure"]["leftButtonDrag"].Bool());
 
+	std::shared_ptr<CToggleButton> rightButtonDragCheckbox = widget<CToggleButton>("rightButtonDragCheckbox");
+	if (rightButtonDragCheckbox)
+		rightButtonDragCheckbox->setSelected(settings["adventure"]["rightButtonDrag"].Bool());
+
 	std::shared_ptr<CToggleButton> smoothDraggingCheckbox = widget<CToggleButton>("smoothDraggingCheckbox");
 	if (smoothDraggingCheckbox)
 		smoothDraggingCheckbox->setSelected(settings["adventure"]["smoothDragging"].Bool());
diff --color -urN vcmi-1.5.7/client/windows/settings/BattleOptionsTab.cpp vcmi/client/windows/settings/BattleOptionsTab.cpp
--- vcmi-1.5.7/client/windows/settings/BattleOptionsTab.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/windows/settings/BattleOptionsTab.cpp	2024-12-19 15:00:22.401127399 +0100
@@ -14,13 +14,13 @@
 #include "../../gui/CGuiHandler.h"
 #include "../../../lib/CConfigHandler.h"
 #include "../../../lib/filesystem/ResourcePath.h"
-#include "../../../lib/CGeneralTextHandler.h"
+#include "../../../lib/texts/CGeneralTextHandler.h"
 #include "../../widgets/Buttons.h"
 #include "../../widgets/TextControls.h"
 
 BattleOptionsTab::BattleOptionsTab(BattleInterface * owner)
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 	setRedrawParent(true);
 
 	const JsonNode config(JsonPath::builtin("config/widgets/settings/battleOptionsTab.json"));
@@ -64,6 +64,10 @@
 	{
 		showStickyHeroWindowsChangedCallback(value, owner);
 	});
+	addCallback("showQuickSpellChanged", [this, owner](bool value)
+	{
+		showQuickSpellChangedCallback(value, owner);
+	});
 	addCallback("enableAutocombatSpellsChanged", [this](bool value)
 	{
 		enableAutocombatSpellsChangedCallback(value);
@@ -95,6 +99,9 @@
 	std::shared_ptr<CToggleButton> showStickyHeroInfoWindowsCheckbox = widget<CToggleButton>("showStickyHeroInfoWindowsCheckbox");
 	showStickyHeroInfoWindowsCheckbox->setSelected(settings["battle"]["stickyHeroInfoWindows"].Bool());
 
+	std::shared_ptr<CToggleButton> showQuickSpellCheckbox = widget<CToggleButton>("showQuickSpellCheckbox");
+	showQuickSpellCheckbox->setSelected(settings["battle"]["enableQuickSpellPanel"].Bool());
+
 	std::shared_ptr<CToggleButton> mouseShadowCheckbox = widget<CToggleButton>("mouseShadowCheckbox");
 	mouseShadowCheckbox->setSelected(settings["battle"]["mouseShadow"].Bool());
 
@@ -228,6 +235,19 @@
 	}
 }
 
+void BattleOptionsTab::showQuickSpellChangedCallback(bool value, BattleInterface * parentBattleInterface)
+{
+	if(!parentBattleInterface)
+	{
+		Settings showQuickSpell = settings.write["battle"]["enableQuickSpellPanel"];
+		showQuickSpell->Bool() = value;
+	}
+	else
+	{
+		parentBattleInterface->setStickyQuickSpellWindowVisibility(value);
+	}
+}
+
 void BattleOptionsTab::queueSizeChangedCallback(int value, BattleInterface * parentBattleInterface)
 {
 	if (value == -1)
diff --color -urN vcmi-1.5.7/client/windows/settings/BattleOptionsTab.h vcmi/client/windows/settings/BattleOptionsTab.h
--- vcmi-1.5.7/client/windows/settings/BattleOptionsTab.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/windows/settings/BattleOptionsTab.h	2024-12-19 15:00:22.402127440 +0100
@@ -32,6 +32,7 @@
 	void queueSizeChangedCallback(int value, BattleInterface * parentBattleInterface);
 	void skipBattleIntroMusicChangedCallback(bool value);
 	void showStickyHeroWindowsChangedCallback(bool value, BattleInterface * parentBattleInterface);
+	void showQuickSpellChangedCallback(bool value, BattleInterface * parentBattleInterface);
 	void enableAutocombatSpellsChangedCallback(bool value);
 	void endWithAutocombatChangedCallback(bool value);
 public:
diff --color -urN vcmi-1.5.7/client/windows/settings/GeneralOptionsTab.cpp vcmi/client/windows/settings/GeneralOptionsTab.cpp
--- vcmi-1.5.7/client/windows/settings/GeneralOptionsTab.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/windows/settings/GeneralOptionsTab.cpp	2024-12-19 15:00:22.403127481 +0100
@@ -11,9 +11,10 @@
 #include "GeneralOptionsTab.h"
 
 #include "CGameInfo.h"
-#include "CMusicHandler.h"
 #include "CPlayerInterface.h"
 #include "CServerHandler.h"
+#include "media/IMusicPlayer.h"
+#include "media/ISoundPlayer.h"
 #include "render/IScreenHandler.h"
 #include "windows/GUIClasses.h"
 
@@ -25,7 +26,7 @@
 #include "../../widgets/Slider.h"
 #include "../../widgets/TextControls.h"
 
-#include "../../../lib/CGeneralTextHandler.h"
+#include "../../../lib/texts/CGeneralTextHandler.h"
 #include "../../../lib/filesystem/ResourcePath.h"
 
 static void setIntSetting(std::string group, std::string field, int value)
@@ -93,10 +94,12 @@
 		: InterfaceObjectConfigurable(),
 		  onFullscreenChanged(settings.listen["video"]["fullscreen"])
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 	setRedrawParent(true);
 
-	addConditional("touchscreen", GH.input().hasTouchInputDevice());
+	addConditional("touchscreen", GH.input().getCurrentInputMode() == InputMode::TOUCH);
+	addConditional("keyboardMouse", GH.input().getCurrentInputMode() == InputMode::KEYBOARD_AND_MOUSE);
+	addConditional("controller", GH.input().getCurrentInputMode() == InputMode::CONTROLLER);
 #ifdef VCMI_MOBILE
 	addConditional("mobile", true);
 	addConditional("desktop", false);
@@ -191,10 +194,8 @@
 
 	build(config);
 
-	const auto & currentResolution = settings["video"]["resolution"];
-
 	std::shared_ptr<CLabel> scalingLabel = widget<CLabel>("scalingLabel");
-	scalingLabel->setText(scalingToLabelString(currentResolution["scaling"].Integer()));
+	scalingLabel->setText(scalingToLabelString(GH.screenHandler().getInterfaceScalingPercentage()));
 
 	std::shared_ptr<CLabel> longTouchLabel = widget<CLabel>("longTouchLabel");
 	if (longTouchLabel)
diff --color -urN vcmi-1.5.7/client/windows/settings/OtherOptionsTab.cpp vcmi/client/windows/settings/OtherOptionsTab.cpp
--- vcmi-1.5.7/client/windows/settings/OtherOptionsTab.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/windows/settings/OtherOptionsTab.cpp	2024-12-19 15:00:22.403127481 +0100
@@ -24,7 +24,7 @@
 
 OtherOptionsTab::OtherOptionsTab() : InterfaceObjectConfigurable()
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 
 	const JsonNode config(JsonPath::builtin("config/widgets/settings/otherOptionsTab.json"));
 	addCallback("availableCreaturesAsDwellingLabelChanged", [](bool value)
diff --color -urN vcmi-1.5.7/client/windows/settings/SettingsMainWindow.cpp vcmi/client/windows/settings/SettingsMainWindow.cpp
--- vcmi-1.5.7/client/windows/settings/SettingsMainWindow.cpp	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/windows/settings/SettingsMainWindow.cpp	2024-12-19 15:00:22.405127564 +0100
@@ -18,7 +18,7 @@
 
 #include "CMT.h"
 #include "CGameInfo.h"
-#include "CGeneralTextHandler.h"
+#include "texts/CGeneralTextHandler.h"
 #include "CPlayerInterface.h"
 #include "CServerHandler.h"
 #include "filesystem/ResourcePath.h"
@@ -33,7 +33,7 @@
 
 SettingsMainWindow::SettingsMainWindow(BattleInterface * parentBattleUi) : InterfaceObjectConfigurable()
 {
-	OBJ_CONSTRUCTION_CAPTURING_ALL_NO_DISPOSE;
+	OBJECT_CONSTRUCTION;
 
 	const JsonNode config(JsonPath::builtin("config/widgets/settings/settingsMainContainer.json"));
 	addCallback("activateSettingsTab", [this](int tabId) { openTab(tabId); });
@@ -45,6 +45,8 @@
 	addCallback("closeWindow", [this](int) { backButtonCallback(); });
 	build(config);
 
+	addUsedEvents(INPUT_MODE_CHANGE);
+
 	std::shared_ptr<CIntObject> background = widget<CIntObject>("background");
 	pos.w = background->pos.w;
 	pos.h = background->pos.h;
@@ -144,7 +146,6 @@
 		{
 			close();
 			CSH->endGameplay();
-			GH.defActionsDef = 63;
 			CMM->menu->switchToTab("main");
 		},
 		0
@@ -197,3 +198,8 @@
 	if (tab)
 		tab->updateResolutionSelector();
 }
+
+void SettingsMainWindow::inputModeChanged(InputMode mode)
+{
+	tabContentArea->reset();
+}
diff --color -urN vcmi-1.5.7/client/windows/settings/SettingsMainWindow.h vcmi/client/windows/settings/SettingsMainWindow.h
--- vcmi-1.5.7/client/windows/settings/SettingsMainWindow.h	2024-08-25 23:27:47.000000000 +0200
+++ vcmi/client/windows/settings/SettingsMainWindow.h	2024-12-19 15:00:22.405127564 +0100
@@ -42,5 +42,6 @@
 
 	void showAll(Canvas & to) override;
 	void onScreenResize() override;
+	void inputModeChanged(InputMode mode) override;
 };
 
diff --color -urN vcmi-1.5.7/client/xBRZ/Changelog.txt vcmi/client/xBRZ/Changelog.txt
--- vcmi-1.5.7/client/xBRZ/Changelog.txt	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/client/xBRZ/Changelog.txt	2024-12-19 15:00:22.406127605 +0100
@@ -0,0 +1,66 @@
+xBRZ 1.8 [2019-11-28]
+---------------------
+Consider ARGB outside area as transparent
+Fixed ARGB scaling issue on image borders
+
+
+xBRZ 1.7 [2019-07-04]
+---------------------
+Fixed asymmetric color distance
+New parameter: "Center direction bias"
+
+
+xBRZ 1.6 [2018-02-27]
+---------------------
+Added bilinear scaling
+Option to skip color buffer creation
+Updated license info
+
+
+xBRZ 1.5 [2017-08-07]
+---------------------
+Added RGB conversion routines
+
+
+xBRZ 1.4 [2015-07-25]
+---------------------
+Added 6xBRZ scaler
+Create color distance buffer lazily
+
+
+xBRZ 1.3 [2015-04-03]
+---------------------
+Improved ARGB performance by 15%
+Fixed alpha channel gradient bug
+
+
+xBRZ 1.2 [2014-11-21]
+---------------------
+Further improved performance by over 30%
+
+
+xBRZ 1.1 [2014-11-02]
+---------------------
+Support images with alpha channel
+Improved color analysis
+
+
+xBRZ 1.0 [2013-02-11]
+---------------------
+Fixed xBRZ scaler compiler issues for GCC
+
+ 
+xBRZ 0.2 [2012-12-11]
+---------------------
+Added 5xBRZ scaler
+Optimized xBRZ scaler performance by factor 3
+Further improved image quality of xBRZ scaler
+
+
+xBRZ 0.1 [2012-09-26]
+---------------------
+Initial release:
+- scale while preserving small image features
+- support multithreading
+- support 64-bit architectures
+- support processing image slices
diff --color -urN vcmi-1.5.7/client/xBRZ/License.txt vcmi/client/xBRZ/License.txt
--- vcmi-1.5.7/client/xBRZ/License.txt	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/client/xBRZ/License.txt	2024-12-19 15:00:22.408127688 +0100
@@ -0,0 +1,621 @@
+                    GNU GENERAL PUBLIC LICENSE
+                       Version 3, 29 June 2007
+
+ Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+                            Preamble
+
+  The GNU General Public License is a free, copyleft license for
+software and other kinds of works.
+
+  The licenses for most software and other practical works are designed
+to take away your freedom to share and change the works.  By contrast,
+the GNU General Public License is intended to guarantee your freedom to
+share and change all versions of a program--to make sure it remains free
+software for all its users.  We, the Free Software Foundation, use the
+GNU General Public License for most of our software; it applies also to
+any other work released this way by its authors.  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+them if you wish), that you receive source code or can get it if you
+want it, that you can change the software or use pieces of it in new
+free programs, and that you know you can do these things.
+
+  To protect your rights, we need to prevent others from denying you
+these rights or asking you to surrender the rights.  Therefore, you have
+certain responsibilities if you distribute copies of the software, or if
+you modify it: responsibilities to respect the freedom of others.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must pass on to the recipients the same
+freedoms that you received.  You must make sure that they, too, receive
+or can get the source code.  And you must show them these terms so they
+know their rights.
+
+  Developers that use the GNU GPL protect your rights with two steps:
+(1) assert copyright on the software, and (2) offer you this License
+giving you legal permission to copy, distribute and/or modify it.
+
+  For the developers' and authors' protection, the GPL clearly explains
+that there is no warranty for this free software.  For both users' and
+authors' sake, the GPL requires that modified versions be marked as
+changed, so that their problems will not be attributed erroneously to
+authors of previous versions.
+
+  Some devices are designed to deny users access to install or run
+modified versions of the software inside them, although the manufacturer
+can do so.  This is fundamentally incompatible with the aim of
+protecting users' freedom to change the software.  The systematic
+pattern of such abuse occurs in the area of products for individuals to
+use, which is precisely where it is most unacceptable.  Therefore, we
+have designed this version of the GPL to prohibit the practice for those
+products.  If such problems arise substantially in other domains, we
+stand ready to extend this provision to those domains in future versions
+of the GPL, as needed to protect the freedom of users.
+
+  Finally, every program is threatened constantly by software patents.
+States should not allow patents to restrict development and use of
+software on general-purpose computers, but in those that do, we wish to
+avoid the special danger that patents applied to a free program could
+make it effectively proprietary.  To prevent this, the GPL assures that
+patents cannot be used to render the program non-free.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+                       TERMS AND CONDITIONS
+
+  0. Definitions.
+
+  "This License" refers to version 3 of the GNU General Public License.
+
+  "Copyright" also means copyright-like laws that apply to other kinds of
+works, such as semiconductor masks.
+
+  "The Program" refers to any copyrightable work licensed under this
+License.  Each licensee is addressed as "you".  "Licensees" and
+"recipients" may be individuals or organizations.
+
+  To "modify" a work means to copy from or adapt all or part of the work
+in a fashion requiring copyright permission, other than the making of an
+exact copy.  The resulting work is called a "modified version" of the
+earlier work or a work "based on" the earlier work.
+
+  A "covered work" means either the unmodified Program or a work based
+on the Program.
+
+  To "propagate" a work means to do anything with it that, without
+permission, would make you directly or secondarily liable for
+infringement under applicable copyright law, except executing it on a
+computer or modifying a private copy.  Propagation includes copying,
+distribution (with or without modification), making available to the
+public, and in some countries other activities as well.
+
+  To "convey" a work means any kind of propagation that enables other
+parties to make or receive copies.  Mere interaction with a user through
+a computer network, with no transfer of a copy, is not conveying.
+
+  An interactive user interface displays "Appropriate Legal Notices"
+to the extent that it includes a convenient and prominently visible
+feature that (1) displays an appropriate copyright notice, and (2)
+tells the user that there is no warranty for the work (except to the
+extent that warranties are provided), that licensees may convey the
+work under this License, and how to view a copy of this License.  If
+the interface presents a list of user commands or options, such as a
+menu, a prominent item in the list meets this criterion.
+
+  1. Source Code.
+
+  The "source code" for a work means the preferred form of the work
+for making modifications to it.  "Object code" means any non-source
+form of a work.
+
+  A "Standard Interface" means an interface that either is an official
+standard defined by a recognized standards body, or, in the case of
+interfaces specified for a particular programming language, one that
+is widely used among developers working in that language.
+
+  The "System Libraries" of an executable work include anything, other
+than the work as a whole, that (a) is included in the normal form of
+packaging a Major Component, but which is not part of that Major
+Component, and (b) serves only to enable use of the work with that
+Major Component, or to implement a Standard Interface for which an
+implementation is available to the public in source code form.  A
+"Major Component", in this context, means a major essential component
+(kernel, window system, and so on) of the specific operating system
+(if any) on which the executable work runs, or a compiler used to
+produce the work, or an object code interpreter used to run it.
+
+  The "Corresponding Source" for a work in object code form means all
+the source code needed to generate, install, and (for an executable
+work) run the object code and to modify the work, including scripts to
+control those activities.  However, it does not include the work's
+System Libraries, or general-purpose tools or generally available free
+programs which are used unmodified in performing those activities but
+which are not part of the work.  For example, Corresponding Source
+includes interface definition files associated with source files for
+the work, and the source code for shared libraries and dynamically
+linked subprograms that the work is specifically designed to require,
+such as by intimate data communication or control flow between those
+subprograms and other parts of the work.
+
+  The Corresponding Source need not include anything that users
+can regenerate automatically from other parts of the Corresponding
+Source.
+
+  The Corresponding Source for a work in source code form is that
+same work.
+
+  2. Basic Permissions.
+
+  All rights granted under this License are granted for the term of
+copyright on the Program, and are irrevocable provided the stated
+conditions are met.  This License explicitly affirms your unlimited
+permission to run the unmodified Program.  The output from running a
+covered work is covered by this License only if the output, given its
+content, constitutes a covered work.  This License acknowledges your
+rights of fair use or other equivalent, as provided by copyright law.
+
+  You may make, run and propagate covered works that you do not
+convey, without conditions so long as your license otherwise remains
+in force.  You may convey covered works to others for the sole purpose
+of having them make modifications exclusively for you, or provide you
+with facilities for running those works, provided that you comply with
+the terms of this License in conveying all material for which you do
+not control copyright.  Those thus making or running the covered works
+for you must do so exclusively on your behalf, under your direction
+and control, on terms that prohibit them from making any copies of
+your copyrighted material outside their relationship with you.
+
+  Conveying under any other circumstances is permitted solely under
+the conditions stated below.  Sublicensing is not allowed; section 10
+makes it unnecessary.
+
+  3. Protecting Users' Legal Rights From Anti-Circumvention Law.
+
+  No covered work shall be deemed part of an effective technological
+measure under any applicable law fulfilling obligations under article
+11 of the WIPO copyright treaty adopted on 20 December 1996, or
+similar laws prohibiting or restricting circumvention of such
+measures.
+
+  When you convey a covered work, you waive any legal power to forbid
+circumvention of technological measures to the extent such circumvention
+is effected by exercising rights under this License with respect to
+the covered work, and you disclaim any intention to limit operation or
+modification of the work as a means of enforcing, against the work's
+users, your or third parties' legal rights to forbid circumvention of
+technological measures.
+
+  4. Conveying Verbatim Copies.
+
+  You may convey verbatim copies of the Program's source code as you
+receive it, in any medium, provided that you conspicuously and
+appropriately publish on each copy an appropriate copyright notice;
+keep intact all notices stating that this License and any
+non-permissive terms added in accord with section 7 apply to the code;
+keep intact all notices of the absence of any warranty; and give all
+recipients a copy of this License along with the Program.
+
+  You may charge any price or no price for each copy that you convey,
+and you may offer support or warranty protection for a fee.
+
+  5. Conveying Modified Source Versions.
+
+  You may convey a work based on the Program, or the modifications to
+produce it from the Program, in the form of source code under the
+terms of section 4, provided that you also meet all of these conditions:
+
+    a) The work must carry prominent notices stating that you modified
+    it, and giving a relevant date.
+
+    b) The work must carry prominent notices stating that it is
+    released under this License and any conditions added under section
+    7.  This requirement modifies the requirement in section 4 to
+    "keep intact all notices".
+
+    c) You must license the entire work, as a whole, under this
+    License to anyone who comes into possession of a copy.  This
+    License will therefore apply, along with any applicable section 7
+    additional terms, to the whole of the work, and all its parts,
+    regardless of how they are packaged.  This License gives no
+    permission to license the work in any other way, but it does not
+    invalidate such permission if you have separately received it.
+
+    d) If the work has interactive user interfaces, each must display
+    Appropriate Legal Notices; however, if the Program has interactive
+    interfaces that do not display Appropriate Legal Notices, your
+    work need not make them do so.
+
+  A compilation of a covered work with other separate and independent
+works, which are not by their nature extensions of the covered work,
+and which are not combined with it such as to form a larger program,
+in or on a volume of a storage or distribution medium, is called an
+"aggregate" if the compilation and its resulting copyright are not
+used to limit the access or legal rights of the compilation's users
+beyond what the individual works permit.  Inclusion of a covered work
+in an aggregate does not cause this License to apply to the other
+parts of the aggregate.
+
+  6. Conveying Non-Source Forms.
+
+  You may convey a covered work in object code form under the terms
+of sections 4 and 5, provided that you also convey the
+machine-readable Corresponding Source under the terms of this License,
+in one of these ways:
+
+    a) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by the
+    Corresponding Source fixed on a durable physical medium
+    customarily used for software interchange.
+
+    b) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by a
+    written offer, valid for at least three years and valid for as
+    long as you offer spare parts or customer support for that product
+    model, to give anyone who possesses the object code either (1) a
+    copy of the Corresponding Source for all the software in the
+    product that is covered by this License, on a durable physical
+    medium customarily used for software interchange, for a price no
+    more than your reasonable cost of physically performing this
+    conveying of source, or (2) access to copy the
+    Corresponding Source from a network server at no charge.
+
+    c) Convey individual copies of the object code with a copy of the
+    written offer to provide the Corresponding Source.  This
+    alternative is allowed only occasionally and noncommercially, and
+    only if you received the object code with such an offer, in accord
+    with subsection 6b.
+
+    d) Convey the object code by offering access from a designated
+    place (gratis or for a charge), and offer equivalent access to the
+    Corresponding Source in the same way through the same place at no
+    further charge.  You need not require recipients to copy the
+    Corresponding Source along with the object code.  If the place to
+    copy the object code is a network server, the Corresponding Source
+    may be on a different server (operated by you or a third party)
+    that supports equivalent copying facilities, provided you maintain
+    clear directions next to the object code saying where to find the
+    Corresponding Source.  Regardless of what server hosts the
+    Corresponding Source, you remain obligated to ensure that it is
+    available for as long as needed to satisfy these requirements.
+
+    e) Convey the object code using peer-to-peer transmission, provided
+    you inform other peers where the object code and Corresponding
+    Source of the work are being offered to the general public at no
+    charge under subsection 6d.
+
+  A separable portion of the object code, whose source code is excluded
+from the Corresponding Source as a System Library, need not be
+included in conveying the object code work.
+
+  A "User Product" is either (1) a "consumer product", which means any
+tangible personal property which is normally used for personal, family,
+or household purposes, or (2) anything designed or sold for incorporation
+into a dwelling.  In determining whether a product is a consumer product,
+doubtful cases shall be resolved in favor of coverage.  For a particular
+product received by a particular user, "normally used" refers to a
+typical or common use of that class of product, regardless of the status
+of the particular user or of the way in which the particular user
+actually uses, or expects or is expected to use, the product.  A product
+is a consumer product regardless of whether the product has substantial
+commercial, industrial or non-consumer uses, unless such uses represent
+the only significant mode of use of the product.
+
+  "Installation Information" for a User Product means any methods,
+procedures, authorization keys, or other information required to install
+and execute modified versions of a covered work in that User Product from
+a modified version of its Corresponding Source.  The information must
+suffice to ensure that the continued functioning of the modified object
+code is in no case prevented or interfered with solely because
+modification has been made.
+
+  If you convey an object code work under this section in, or with, or
+specifically for use in, a User Product, and the conveying occurs as
+part of a transaction in which the right of possession and use of the
+User Product is transferred to the recipient in perpetuity or for a
+fixed term (regardless of how the transaction is characterized), the
+Corresponding Source conveyed under this section must be accompanied
+by the Installation Information.  But this requirement does not apply
+if neither you nor any third party retains the ability to install
+modified object code on the User Product (for example, the work has
+been installed in ROM).
+
+  The requirement to provide Installation Information does not include a
+requirement to continue to provide support service, warranty, or updates
+for a work that has been modified or installed by the recipient, or for
+the User Product in which it has been modified or installed.  Access to a
+network may be denied when the modification itself materially and
+adversely affects the operation of the network or violates the rules and
+protocols for communication across the network.
+
+  Corresponding Source conveyed, and Installation Information provided,
+in accord with this section must be in a format that is publicly
+documented (and with an implementation available to the public in
+source code form), and must require no special password or key for
+unpacking, reading or copying.
+
+  7. Additional Terms.
+
+  "Additional permissions" are terms that supplement the terms of this
+License by making exceptions from one or more of its conditions.
+Additional permissions that are applicable to the entire Program shall
+be treated as though they were included in this License, to the extent
+that they are valid under applicable law.  If additional permissions
+apply only to part of the Program, that part may be used separately
+under those permissions, but the entire Program remains governed by
+this License without regard to the additional permissions.
+
+  When you convey a copy of a covered work, you may at your option
+remove any additional permissions from that copy, or from any part of
+it.  (Additional permissions may be written to require their own
+removal in certain cases when you modify the work.)  You may place
+additional permissions on material, added by you to a covered work,
+for which you have or can give appropriate copyright permission.
+
+  Notwithstanding any other provision of this License, for material you
+add to a covered work, you may (if authorized by the copyright holders of
+that material) supplement the terms of this License with terms:
+
+    a) Disclaiming warranty or limiting liability differently from the
+    terms of sections 15 and 16 of this License; or
+
+    b) Requiring preservation of specified reasonable legal notices or
+    author attributions in that material or in the Appropriate Legal
+    Notices displayed by works containing it; or
+
+    c) Prohibiting misrepresentation of the origin of that material, or
+    requiring that modified versions of such material be marked in
+    reasonable ways as different from the original version; or
+
+    d) Limiting the use for publicity purposes of names of licensors or
+    authors of the material; or
+
+    e) Declining to grant rights under trademark law for use of some
+    trade names, trademarks, or service marks; or
+
+    f) Requiring indemnification of licensors and authors of that
+    material by anyone who conveys the material (or modified versions of
+    it) with contractual assumptions of liability to the recipient, for
+    any liability that these contractual assumptions directly impose on
+    those licensors and authors.
+
+  All other non-permissive additional terms are considered "further
+restrictions" within the meaning of section 10.  If the Program as you
+received it, or any part of it, contains a notice stating that it is
+governed by this License along with a term that is a further
+restriction, you may remove that term.  If a license document contains
+a further restriction but permits relicensing or conveying under this
+License, you may add to a covered work material governed by the terms
+of that license document, provided that the further restriction does
+not survive such relicensing or conveying.
+
+  If you add terms to a covered work in accord with this section, you
+must place, in the relevant source files, a statement of the
+additional terms that apply to those files, or a notice indicating
+where to find the applicable terms.
+
+  Additional terms, permissive or non-permissive, may be stated in the
+form of a separately written license, or stated as exceptions;
+the above requirements apply either way.
+
+  8. Termination.
+
+  You may not propagate or modify a covered work except as expressly
+provided under this License.  Any attempt otherwise to propagate or
+modify it is void, and will automatically terminate your rights under
+this License (including any patent licenses granted under the third
+paragraph of section 11).
+
+  However, if you cease all violation of this License, then your
+license from a particular copyright holder is reinstated (a)
+provisionally, unless and until the copyright holder explicitly and
+finally terminates your license, and (b) permanently, if the copyright
+holder fails to notify you of the violation by some reasonable means
+prior to 60 days after the cessation.
+
+  Moreover, your license from a particular copyright holder is
+reinstated permanently if the copyright holder notifies you of the
+violation by some reasonable means, this is the first time you have
+received notice of violation of this License (for any work) from that
+copyright holder, and you cure the violation prior to 30 days after
+your receipt of the notice.
+
+  Termination of your rights under this section does not terminate the
+licenses of parties who have received copies or rights from you under
+this License.  If your rights have been terminated and not permanently
+reinstated, you do not qualify to receive new licenses for the same
+material under section 10.
+
+  9. Acceptance Not Required for Having Copies.
+
+  You are not required to accept this License in order to receive or
+run a copy of the Program.  Ancillary propagation of a covered work
+occurring solely as a consequence of using peer-to-peer transmission
+to receive a copy likewise does not require acceptance.  However,
+nothing other than this License grants you permission to propagate or
+modify any covered work.  These actions infringe copyright if you do
+not accept this License.  Therefore, by modifying or propagating a
+covered work, you indicate your acceptance of this License to do so.
+
+  10. Automatic Licensing of Downstream Recipients.
+
+  Each time you convey a covered work, the recipient automatically
+receives a license from the original licensors, to run, modify and
+propagate that work, subject to this License.  You are not responsible
+for enforcing compliance by third parties with this License.
+
+  An "entity transaction" is a transaction transferring control of an
+organization, or substantially all assets of one, or subdividing an
+organization, or merging organizations.  If propagation of a covered
+work results from an entity transaction, each party to that
+transaction who receives a copy of the work also receives whatever
+licenses to the work the party's predecessor in interest had or could
+give under the previous paragraph, plus a right to possession of the
+Corresponding Source of the work from the predecessor in interest, if
+the predecessor has it or can get it with reasonable efforts.
+
+  You may not impose any further restrictions on the exercise of the
+rights granted or affirmed under this License.  For example, you may
+not impose a license fee, royalty, or other charge for exercise of
+rights granted under this License, and you may not initiate litigation
+(including a cross-claim or counterclaim in a lawsuit) alleging that
+any patent claim is infringed by making, using, selling, offering for
+sale, or importing the Program or any portion of it.
+
+  11. Patents.
+
+  A "contributor" is a copyright holder who authorizes use under this
+License of the Program or a work on which the Program is based.  The
+work thus licensed is called the contributor's "contributor version".
+
+  A contributor's "essential patent claims" are all patent claims
+owned or controlled by the contributor, whether already acquired or
+hereafter acquired, that would be infringed by some manner, permitted
+by this License, of making, using, or selling its contributor version,
+but do not include claims that would be infringed only as a
+consequence of further modification of the contributor version.  For
+purposes of this definition, "control" includes the right to grant
+patent sublicenses in a manner consistent with the requirements of
+this License.
+
+  Each contributor grants you a non-exclusive, worldwide, royalty-free
+patent license under the contributor's essential patent claims, to
+make, use, sell, offer for sale, import and otherwise run, modify and
+propagate the contents of its contributor version.
+
+  In the following three paragraphs, a "patent license" is any express
+agreement or commitment, however denominated, not to enforce a patent
+(such as an express permission to practice a patent or covenant not to
+sue for patent infringement).  To "grant" such a patent license to a
+party means to make such an agreement or commitment not to enforce a
+patent against the party.
+
+  If you convey a covered work, knowingly relying on a patent license,
+and the Corresponding Source of the work is not available for anyone
+to copy, free of charge and under the terms of this License, through a
+publicly available network server or other readily accessible means,
+then you must either (1) cause the Corresponding Source to be so
+available, or (2) arrange to deprive yourself of the benefit of the
+patent license for this particular work, or (3) arrange, in a manner
+consistent with the requirements of this License, to extend the patent
+license to downstream recipients.  "Knowingly relying" means you have
+actual knowledge that, but for the patent license, your conveying the
+covered work in a country, or your recipient's use of the covered work
+in a country, would infringe one or more identifiable patents in that
+country that you have reason to believe are valid.
+
+  If, pursuant to or in connection with a single transaction or
+arrangement, you convey, or propagate by procuring conveyance of, a
+covered work, and grant a patent license to some of the parties
+receiving the covered work authorizing them to use, propagate, modify
+or convey a specific copy of the covered work, then the patent license
+you grant is automatically extended to all recipients of the covered
+work and works based on it.
+
+  A patent license is "discriminatory" if it does not include within
+the scope of its coverage, prohibits the exercise of, or is
+conditioned on the non-exercise of one or more of the rights that are
+specifically granted under this License.  You may not convey a covered
+work if you are a party to an arrangement with a third party that is
+in the business of distributing software, under which you make payment
+to the third party based on the extent of your activity of conveying
+the work, and under which the third party grants, to any of the
+parties who would receive the covered work from you, a discriminatory
+patent license (a) in connection with copies of the covered work
+conveyed by you (or copies made from those copies), or (b) primarily
+for and in connection with specific products or compilations that
+contain the covered work, unless you entered into that arrangement,
+or that patent license was granted, prior to 28 March 2007.
+
+  Nothing in this License shall be construed as excluding or limiting
+any implied license or other defenses to infringement that may
+otherwise be available to you under applicable patent law.
+
+  12. No Surrender of Others' Freedom.
+
+  If conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot convey a
+covered work so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you may
+not convey it at all.  For example, if you agree to terms that obligate you
+to collect a royalty for further conveying from those to whom you convey
+the Program, the only way you could satisfy both those terms and this
+License would be to refrain entirely from conveying the Program.
+
+  13. Use with the GNU Affero General Public License.
+
+  Notwithstanding any other provision of this License, you have
+permission to link or combine any covered work with a work licensed
+under version 3 of the GNU Affero General Public License into a single
+combined work, and to convey the resulting work.  The terms of this
+License will continue to apply to the part which is the covered work,
+but the special requirements of the GNU Affero General Public License,
+section 13, concerning interaction through a network will apply to the
+combination as such.
+
+  14. Revised Versions of this License.
+
+  The Free Software Foundation may publish revised and/or new versions of
+the GNU General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+  Each version is given a distinguishing version number.  If the
+Program specifies that a certain numbered version of the GNU General
+Public License "or any later version" applies to it, you have the
+option of following the terms and conditions either of that numbered
+version or of any later version published by the Free Software
+Foundation.  If the Program does not specify a version number of the
+GNU General Public License, you may choose any version ever published
+by the Free Software Foundation.
+
+  If the Program specifies that a proxy can decide which future
+versions of the GNU General Public License can be used, that proxy's
+public statement of acceptance of a version permanently authorizes you
+to choose that version for the Program.
+
+  Later license versions may give you additional or different
+permissions.  However, no additional obligations are imposed on any
+author or copyright holder as a result of your choosing to follow a
+later version.
+
+  15. Disclaimer of Warranty.
+
+  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
+APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
+HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
+OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
+IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
+ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. Limitation of Liability.
+
+  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
+THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
+GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
+USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
+DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
+PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
+EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
+SUCH DAMAGES.
+
+  17. Interpretation of Sections 15 and 16.
+
+  If the disclaimer of warranty and limitation of liability provided
+above cannot be given local legal effect according to their terms,
+reviewing courts shall apply local law that most closely approximates
+an absolute waiver of all civil liability in connection with the
+Program, unless a warranty or assumption of liability accompanies a
+copy of the Program in return for a fee.
+
+                     END OF TERMS AND CONDITIONS
diff --color -urN vcmi-1.5.7/client/xBRZ/xbrz_config.h vcmi/client/xBRZ/xbrz_config.h
--- vcmi-1.5.7/client/xBRZ/xbrz_config.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/client/xBRZ/xbrz_config.h	2024-12-19 15:00:22.412127853 +0100
@@ -0,0 +1,35 @@
+// ****************************************************************************
+// * This file is part of the xBRZ project. It is distributed under           *
+// * GNU General Public License: https://www.gnu.org/licenses/gpl-3.0         *
+// * Copyright (C) Zenju (zenju AT gmx DOT de) - All Rights Reserved          *
+// *                                                                          *
+// * Additionally and as a special exception, the author gives permission     *
+// * to link the code of this program with the following libraries            *
+// * (or with modified versions that use the same licenses), and distribute   *
+// * linked combinations including the two: MAME, FreeFileSync, Snes9x, ePSXe *
+// * You must obey the GNU General Public License in all respects for all of  *
+// * the code used other than MAME, FreeFileSync, Snes9x, ePSXe.              *
+// * If you modify this file, you may extend this exception to your version   *
+// * of the file, but you are not obligated to do so. If you do not wish to   *
+// * do so, delete this exception statement from your version.                *
+// ****************************************************************************
+
+#ifndef XBRZ_CONFIG_HEADER_284578425345
+#define XBRZ_CONFIG_HEADER_284578425345
+
+//do NOT include any headers here! used by xBRZ_dll!!!
+
+namespace xbrz
+{
+struct ScalerCfg
+{
+    double luminanceWeight            = 1;
+    double equalColorTolerance        = 30;
+    double centerDirectionBias        = 4;
+    double dominantDirectionThreshold = 3.6;
+    double steepDirectionThreshold    = 2.2;
+    double newTestAttribute           = 0; //unused; test new parameters
+};
+}
+
+#endif
diff --color -urN vcmi-1.5.7/client/xBRZ/xbrz.cpp vcmi/client/xBRZ/xbrz.cpp
--- vcmi-1.5.7/client/xBRZ/xbrz.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/client/xBRZ/xbrz.cpp	2024-12-19 15:00:22.411127812 +0100
@@ -0,0 +1,1367 @@
+// ****************************************************************************
+// * This file is part of the xBRZ project. It is distributed under           *
+// * GNU General Public License: https://www.gnu.org/licenses/gpl-3.0         *
+// * Copyright (C) Zenju (zenju AT gmx DOT de) - All Rights Reserved          *
+// *                                                                          *
+// * Additionally and as a special exception, the author gives permission     *
+// * to link the code of this program with the following libraries            *
+// * (or with modified versions that use the same licenses), and distribute   *
+// * linked combinations including the two: MAME, FreeFileSync, Snes9x, ePSXe *
+// * You must obey the GNU General Public License in all respects for all of  *
+// * the code used other than MAME, FreeFileSync, Snes9x, ePSXe.              *
+// * If you modify this file, you may extend this exception to your version   *
+// * of the file, but you are not obligated to do so. If you do not wish to   *
+// * do so, delete this exception statement from your version.                *
+// ****************************************************************************
+
+#include "xbrz.h"
+#include <cassert>
+#include <vector>
+#include <algorithm>
+#include <cmath> //std::sqrt
+#include "xbrz_tools.h"
+
+#if defined _MSC_VER
+#pragma warning(disable:5051)
+#endif
+
+using namespace xbrz;
+
+
+namespace
+{
+template <unsigned int M, unsigned int N> inline
+uint32_t gradientRGB(uint32_t pixFront, uint32_t pixBack) //blend front color with opacity M / N over opaque background: https://en.wikipedia.org/wiki/Alpha_compositing#Alpha_blending
+{
+    static_assert(0 < M && M < N && N <= 1000);
+
+    auto calcColor = [](unsigned char colFront, unsigned char colBack) -> unsigned char { return (colFront * M + colBack * (N - M)) / N; };
+
+    return makePixel(calcColor(getRed  (pixFront), getRed  (pixBack)),
+                     calcColor(getGreen(pixFront), getGreen(pixBack)),
+                     calcColor(getBlue (pixFront), getBlue (pixBack)));
+}
+
+
+template <unsigned int M, unsigned int N> inline
+uint32_t gradientARGB(uint32_t pixFront, uint32_t pixBack) //find intermediate color between two colors with alpha channels (=> NO alpha blending!!!)
+{
+    static_assert(0 < M && M < N && N <= 1000);
+
+    const unsigned int weightFront = getAlpha(pixFront) * M;
+    const unsigned int weightBack  = getAlpha(pixBack) * (N - M);
+    const unsigned int weightSum   = weightFront + weightBack;
+    if (weightSum == 0)
+        return 0;
+
+    auto calcColor = [=](unsigned char colFront, unsigned char colBack)
+    {
+        return static_cast<unsigned char>((colFront * weightFront + colBack * weightBack) / weightSum);
+    };
+
+    return makePixel(static_cast<unsigned char>(weightSum / N),
+                     calcColor(getRed  (pixFront), getRed  (pixBack)),
+                     calcColor(getGreen(pixFront), getGreen(pixBack)),
+                     calcColor(getBlue (pixFront), getBlue (pixBack)));
+}
+
+
+//inline
+//double fastSqrt(double n)
+//{
+//    __asm //speeds up xBRZ by about 9% compared to std::sqrt which internally uses the same assembler instructions but adds some "fluff"
+//    {
+//        fld n
+//        fsqrt
+//    }
+//}
+//
+
+
+#ifdef _MSC_VER
+    #define FORCE_INLINE __forceinline
+#elif defined __GNUC__
+    #define FORCE_INLINE __attribute__((always_inline)) inline
+#else
+    #define FORCE_INLINE inline
+#endif
+
+
+enum RotationDegree //clock-wise
+{
+    ROT_0,
+    ROT_90,
+    ROT_180,
+    ROT_270
+};
+
+//calculate input matrix coordinates after rotation at compile time
+template <RotationDegree rotDeg, size_t I, size_t J, size_t N>
+struct MatrixRotation;
+
+template <size_t I, size_t J, size_t N>
+struct MatrixRotation<ROT_0, I, J, N>
+{
+    static const size_t I_old = I;
+    static const size_t J_old = J;
+};
+
+template <RotationDegree rotDeg, size_t I, size_t J, size_t N> //(i, j) = (row, col) indices, N = size of (square) matrix
+struct MatrixRotation
+{
+    static const size_t I_old = N - 1 - MatrixRotation<static_cast<RotationDegree>(rotDeg - 1), I, J, N>::J_old; //old coordinates before rotation!
+    static const size_t J_old =         MatrixRotation<static_cast<RotationDegree>(rotDeg - 1), I, J, N>::I_old; //
+};
+
+
+template <size_t N, RotationDegree rotDeg>
+class OutputMatrix
+{
+public:
+    OutputMatrix(uint32_t* out, int outWidth) : //access matrix area, top-left at position "out" for image with given width
+        out_(out),
+        outWidth_(outWidth) {}
+
+    template <size_t I, size_t J>
+    uint32_t& ref() const
+    {
+        static const size_t I_old = MatrixRotation<rotDeg, I, J, N>::I_old;
+        static const size_t J_old = MatrixRotation<rotDeg, I, J, N>::J_old;
+        return *(out_ + J_old + I_old * outWidth_);
+    }
+
+private:
+    uint32_t* out_;
+    const int outWidth_;
+};
+
+
+template <class T> inline
+T square(T value) { return value * value; }
+
+
+#if 0
+inline
+double distRGB(uint32_t pix1, uint32_t pix2)
+{
+    const double r_diff = static_cast<int>(getRed  (pix1)) - getRed  (pix2);
+    const double g_diff = static_cast<int>(getGreen(pix1)) - getGreen(pix2);
+    const double b_diff = static_cast<int>(getBlue (pix1)) - getBlue (pix2);
+
+    //euklidean RGB distance
+    return std::sqrt(square(r_diff) + square(g_diff) + square(b_diff));
+}
+#endif
+
+
+inline
+double distYCbCr(uint32_t pix1, uint32_t pix2, double lumaWeight)
+{
+    //https://en.wikipedia.org/wiki/YCbCr#ITU-R_BT.601_conversion
+    //YCbCr conversion is a matrix multiplication => take advantage of linearity by subtracting first!
+    const int r_diff = static_cast<int>(getRed  (pix1)) - getRed  (pix2); //we may delay division by 255 to after matrix multiplication
+    const int g_diff = static_cast<int>(getGreen(pix1)) - getGreen(pix2); //
+    const int b_diff = static_cast<int>(getBlue (pix1)) - getBlue (pix2); //substraction for int is noticeable faster than for double!
+
+    //const double k_b = 0.0722; //ITU-R BT.709 conversion
+    //const double k_r = 0.2126; //
+    const double k_b = 0.0593; //ITU-R BT.2020 conversion
+    const double k_r = 0.2627; //
+    const double k_g = 1 - k_b - k_r;
+
+    const double scale_b = 0.5 / (1 - k_b);
+    const double scale_r = 0.5 / (1 - k_r);
+
+    const double y   = k_r * r_diff + k_g * g_diff + k_b * b_diff; //[!], analog YCbCr!
+    const double c_b = scale_b * (b_diff - y);
+    const double c_r = scale_r * (r_diff - y);
+
+    //we skip division by 255 to have similar range like other distance functions
+    return std::sqrt(square(lumaWeight * y) + square(c_b) + square(c_r));
+}
+
+
+inline
+double distYCbCrBuffered(uint32_t pix1, uint32_t pix2)
+{
+    //30% perf boost compared to plain distYCbCr()!
+    //consumes 64 MB memory; using double is only 2% faster, but takes 128 MB
+    static const std::vector<float> diffToDist = []
+    {
+        std::vector<float> tmp;
+
+        for (uint32_t i = 0; i < 256 * 256 * 256; ++i) //startup time: 114 ms on Intel Core i5 (four cores)
+        {
+            const int r_diff = static_cast<signed char>(getByte<2>(i)) * 2;
+            const int g_diff = static_cast<signed char>(getByte<1>(i)) * 2;
+            const int b_diff = static_cast<signed char>(getByte<0>(i)) * 2;
+
+            const double k_b = 0.0593; //ITU-R BT.2020 conversion
+            const double k_r = 0.2627; //
+            const double k_g = 1 - k_b - k_r;
+
+            const double scale_b = 0.5 / (1 - k_b);
+            const double scale_r = 0.5 / (1 - k_r);
+
+            const double y   = k_r * r_diff + k_g * g_diff + k_b * b_diff; //[!], analog YCbCr!
+            const double c_b = scale_b * (b_diff - y);
+            const double c_r = scale_r * (r_diff - y);
+
+            tmp.push_back(static_cast<float>(std::sqrt(square(y) + square(c_b) + square(c_r))));
+        }
+        return tmp;
+    }();
+
+    //if (pix1 == pix2) -> 8% perf degradation!
+    //    return 0;
+    //if (pix1 < pix2)
+    //    std::swap(pix1, pix2); -> 30% perf degradation!!!
+
+    const int r_diff = static_cast<int>(getRed  (pix1)) - getRed  (pix2);
+    const int g_diff = static_cast<int>(getGreen(pix1)) - getGreen(pix2);
+    const int b_diff = static_cast<int>(getBlue (pix1)) - getBlue (pix2);
+
+    const size_t index = (static_cast<unsigned char>(r_diff / 2) << 16) | //slightly reduce precision (division by 2) to squeeze value into single byte
+                         (static_cast<unsigned char>(g_diff / 2) <<  8) |
+                         (static_cast<unsigned char>(b_diff / 2));
+
+#if 0 //attention: the following calculation creates an asymmetric color distance!!! (e.g. r_diff=46 will be unpacked as 45, but r_diff=-46 unpacks to -47
+    const size_t index = (((r_diff + 0xFF) / 2) << 16) | //slightly reduce precision (division by 2) to squeeze value into single byte
+                         (((g_diff + 0xFF) / 2) <<  8) |
+                         (( b_diff + 0xFF) / 2);
+#endif
+    return diffToDist[index];
+}
+
+
+#if defined _MSC_VER && !defined NDEBUG
+    const int debugPixelX = -1;
+    const int debugPixelY = 58;
+
+    thread_local bool breakIntoDebugger = false;
+#endif
+
+
+enum BlendType
+{
+    BLEND_NONE = 0,
+    BLEND_NORMAL,   //a normal indication to blend
+    BLEND_DOMINANT, //a strong indication to blend
+    //attention: BlendType must fit into the value range of 2 bit!!!
+};
+
+struct BlendResult
+{
+    BlendType
+    /**/blend_f, blend_g,
+    /**/blend_j, blend_k;
+};
+
+
+struct Kernel_3x3
+{
+    uint32_t
+    a, b, c,
+    d, e, f,
+    g, h, i;
+};
+
+struct Kernel_4x4 //kernel for preprocessing step
+{
+    uint32_t
+    a, b, c, //
+    e, f, g, // support reinterpret_cast from Kernel_4x4 => Kernel_3x3
+    i, j, k, //
+    m, n, o,
+    d, h, l, p;
+};
+
+/* input kernel area naming convention:
+-----------------
+| A | B | C | D |
+|---|---|---|---|
+| E | F | G | H |   evaluate the four corners between F, G, J, K
+|---|---|---|---|   input pixel is at position F
+| I | J | K | L |
+|---|---|---|---|
+| M | N | O | P |
+-----------------
+*/
+template <class ColorDistance>
+FORCE_INLINE //detect blend direction
+BlendResult preProcessCorners(const Kernel_4x4& ker, const xbrz::ScalerCfg& cfg) //result: F, G, J, K corners of "GradientType"
+{
+#if defined _MSC_VER && !defined NDEBUG
+    if (breakIntoDebugger)
+        __debugbreak(); //__asm int 3;
+#endif
+
+    BlendResult result = {};
+
+    if ((ker.f == ker.g &&
+         ker.j == ker.k) ||
+        (ker.f == ker.j &&
+         ker.g == ker.k))
+        return result;
+
+    auto dist = [&](uint32_t pix1, uint32_t pix2) { return ColorDistance::dist(pix1, pix2, cfg.luminanceWeight); };
+
+    double jg = dist(ker.i, ker.f) + dist(ker.f, ker.c) + dist(ker.n, ker.k) + dist(ker.k, ker.h) + cfg.centerDirectionBias * dist(ker.j, ker.g);
+    double fk = dist(ker.e, ker.j) + dist(ker.j, ker.o) + dist(ker.b, ker.g) + dist(ker.g, ker.l) + cfg.centerDirectionBias * dist(ker.f, ker.k);
+
+    if (jg < fk) //test sample: 70% of values max(jg, fk) / min(jg, fk) are between 1.1 and 3.7 with median being 1.8
+    {
+        const bool dominantGradient = cfg.dominantDirectionThreshold * jg < fk;
+        if (ker.f != ker.g && ker.f != ker.j)
+            result.blend_f = dominantGradient ? BLEND_DOMINANT : BLEND_NORMAL;
+
+        if (ker.k != ker.j && ker.k != ker.g)
+            result.blend_k = dominantGradient ? BLEND_DOMINANT : BLEND_NORMAL;
+    }
+    else if (fk < jg)
+    {
+        const bool dominantGradient = cfg.dominantDirectionThreshold * fk < jg;
+        if (ker.j != ker.f && ker.j != ker.k)
+            result.blend_j = dominantGradient ? BLEND_DOMINANT : BLEND_NORMAL;
+
+        if (ker.g != ker.f && ker.g != ker.k)
+            result.blend_g = dominantGradient ? BLEND_DOMINANT : BLEND_NORMAL;
+    }
+    return result;
+}
+
+#define DEF_GETTER(x) template <RotationDegree rotDeg> uint32_t inline get_##x(const Kernel_3x3& ker) { return ker.x; }
+//we cannot and NEED NOT write "ker.##x" since ## concatenates preprocessor tokens but "." is not a token
+DEF_GETTER(a) DEF_GETTER(b) DEF_GETTER(c)
+DEF_GETTER(d) DEF_GETTER(e) DEF_GETTER(f)
+DEF_GETTER(g) DEF_GETTER(h) DEF_GETTER(i)
+#undef DEF_GETTER
+
+#define DEF_GETTER(x, y)  template <> [[maybe_unused]] inline uint32_t get_##x<ROT_90>(const Kernel_3x3& ker) { return ker.y; }
+DEF_GETTER(a, g) DEF_GETTER(b, d) DEF_GETTER(c, a)
+DEF_GETTER(d, h) DEF_GETTER(e, e) DEF_GETTER(f, b)
+DEF_GETTER(g, i) DEF_GETTER(h, f) DEF_GETTER(i, c)
+#undef DEF_GETTER
+
+#define DEF_GETTER(x, y) template <> [[maybe_unused]] inline uint32_t get_##x<ROT_180>(const Kernel_3x3& ker) { return ker.y; }
+DEF_GETTER(a, i) DEF_GETTER(b, h) DEF_GETTER(c, g)
+DEF_GETTER(d, f) DEF_GETTER(e, e) DEF_GETTER(f, d)
+DEF_GETTER(g, c) DEF_GETTER(h, b) DEF_GETTER(i, a)
+#undef DEF_GETTER
+
+#define DEF_GETTER(x, y) template <> [[maybe_unused]] inline uint32_t get_##x<ROT_270>(const Kernel_3x3& ker) { return ker.y; }
+DEF_GETTER(a, c) DEF_GETTER(b, f) DEF_GETTER(c, i)
+DEF_GETTER(d, b) DEF_GETTER(e, e) DEF_GETTER(f, h)
+DEF_GETTER(g, a) DEF_GETTER(h, d) DEF_GETTER(i, g)
+#undef DEF_GETTER
+
+
+//compress four blend types into a single byte
+//inline BlendType getTopL   (unsigned char b) { return static_cast<BlendType>(0x3 & b); }
+inline BlendType getTopR   (unsigned char b) { return static_cast<BlendType>(0x3 & (b >> 2)); }
+inline BlendType getBottomR(unsigned char b) { return static_cast<BlendType>(0x3 & (b >> 4)); }
+inline BlendType getBottomL(unsigned char b) { return static_cast<BlendType>(0x3 & (b >> 6)); }
+
+inline void clearAddTopL(unsigned char& b, BlendType bt) { b = static_cast<unsigned char>(bt); }
+inline void addTopR     (unsigned char& b, BlendType bt) { b |= (bt << 2); } //buffer is assumed to be initialized before preprocessing!
+inline void addBottomR  (unsigned char& b, BlendType bt) { b |= (bt << 4); } //e.g. via clearAddTopL()
+inline void addBottomL  (unsigned char& b, BlendType bt) { b |= (bt << 6); } //
+
+inline bool blendingNeeded(unsigned char b)
+{
+    static_assert(BLEND_NONE == 0);
+    return b != 0;
+}
+
+template <RotationDegree rotDeg> inline
+unsigned char rotateBlendInfo(unsigned char b) { return b; }
+template <> inline unsigned char rotateBlendInfo<ROT_90 >(unsigned char b) { return ((b << 2) | (b >> 6)) & 0xff; }
+template <> inline unsigned char rotateBlendInfo<ROT_180>(unsigned char b) { return ((b << 4) | (b >> 4)) & 0xff; }
+template <> inline unsigned char rotateBlendInfo<ROT_270>(unsigned char b) { return ((b << 6) | (b >> 2)) & 0xff; }
+
+
+/* input kernel area naming convention:
+-------------
+| A | B | C |
+|---|---|---|
+| D | E | F | input pixel is at position E
+|---|---|---|
+| G | H | I |
+-------------
+*/
+template <class Scaler, class ColorDistance, RotationDegree rotDeg>
+FORCE_INLINE //perf: quite worth it!
+void blendPixel(const Kernel_3x3& ker,
+                uint32_t* target, int trgWidth,
+                unsigned char blendInfo, //result of preprocessing all four corners of pixel "e"
+                const xbrz::ScalerCfg& cfg)
+{
+    //#define a get_a<rotDeg>(ker)
+#define b get_b<rotDeg>(ker)
+#define c get_c<rotDeg>(ker)
+#define d get_d<rotDeg>(ker)
+#define e get_e<rotDeg>(ker)
+#define f get_f<rotDeg>(ker)
+#define g get_g<rotDeg>(ker)
+#define h get_h<rotDeg>(ker)
+#define i get_i<rotDeg>(ker)
+
+#if defined _MSC_VER && !defined NDEBUG
+    if (breakIntoDebugger)
+        __debugbreak(); //__asm int 3;
+#endif
+
+    const unsigned char blend = rotateBlendInfo<rotDeg>(blendInfo);
+
+    if (getBottomR(blend) >= BLEND_NORMAL)
+    {
+        auto eq   = [&](uint32_t pix1, uint32_t pix2) { return ColorDistance::dist(pix1, pix2, cfg.luminanceWeight) < cfg.equalColorTolerance; };
+        auto dist = [&](uint32_t pix1, uint32_t pix2) { return ColorDistance::dist(pix1, pix2, cfg.luminanceWeight); };
+
+        const bool doLineBlend = [&]() -> bool
+        {
+            if (getBottomR(blend) >= BLEND_DOMINANT)
+                return true;
+
+            //make sure there is no second blending in an adjacent rotation for this pixel: handles insular pixels, mario eyes
+            if (getTopR(blend) != BLEND_NONE && !eq(e, g)) //but support double-blending for 90 corners
+                return false;
+            if (getBottomL(blend) != BLEND_NONE && !eq(e, c))
+                return false;
+
+            //no full blending for L-shapes; blend corner only (handles "mario mushroom eyes")
+            if (!eq(e, i) && eq(g, h) && eq(h, i) && eq(i, f) && eq(f, c))
+                return false;
+
+            return true;
+        }();
+
+        const uint32_t px = dist(e, f) <= dist(e, h) ? f : h; //choose most similar color
+
+        OutputMatrix<Scaler::scale, rotDeg> out(target, trgWidth);
+
+        if (doLineBlend)
+        {
+            const double fg = dist(f, g); //test sample: 70% of values max(fg, hc) / min(fg, hc) are between 1.1 and 3.7 with median being 1.9
+            const double hc = dist(h, c); //
+
+            const bool haveShallowLine = cfg.steepDirectionThreshold * fg <= hc && e != g && d != g;
+            const bool haveSteepLine   = cfg.steepDirectionThreshold * hc <= fg && e != c && b != c;
+
+            if (haveShallowLine)
+            {
+                if (haveSteepLine)
+                    Scaler::blendLineSteepAndShallow(px, out);
+                else
+                    Scaler::blendLineShallow(px, out);
+            }
+            else
+            {
+                if (haveSteepLine)
+                    Scaler::blendLineSteep(px, out);
+                else
+                    Scaler::blendLineDiagonal(px, out);
+            }
+        }
+        else
+            Scaler::blendCorner(px, out);
+    }
+
+    //#undef a
+#undef b
+#undef c
+#undef d
+#undef e
+#undef f
+#undef g
+#undef h
+#undef i
+}
+
+
+class OobReaderTransparent
+{
+public:
+    OobReaderTransparent(const uint32_t* src, int srcWidth, int srcHeight, int y) :
+        s_m1(0 <= y - 1 && y - 1 < srcHeight ? src + srcWidth * (y - 1) : nullptr),
+        s_0 (0 <= y     && y     < srcHeight ? src + srcWidth *  y      : nullptr),
+        s_p1(0 <= y + 1 && y + 1 < srcHeight ? src + srcWidth * (y + 1) : nullptr),
+        s_p2(0 <= y + 2 && y + 2 < srcHeight ? src + srcWidth * (y + 2) : nullptr),
+        srcWidth_(srcWidth) {}
+
+    void readDhlp(Kernel_4x4& ker, int x) const //(x, y) is at kernel position F
+    {
+        [[likely]] if (const int x_p2 = x + 2; 0 <= x_p2 && x_p2 < srcWidth_)
+        {
+            ker.d = s_m1 ? s_m1[x_p2] : 0;
+            ker.h = s_0  ? s_0 [x_p2] : 0;
+            ker.l = s_p1 ? s_p1[x_p2] : 0;
+            ker.p = s_p2 ? s_p2[x_p2] : 0;
+        }
+        else
+        {
+            ker.d = 0;
+            ker.h = 0;
+            ker.l = 0;
+            ker.p = 0;
+        }
+    }
+
+private:
+    const uint32_t* const s_m1;
+    const uint32_t* const s_0;
+    const uint32_t* const s_p1;
+    const uint32_t* const s_p2;
+    const int srcWidth_;
+};
+
+
+class OobReaderDuplicate
+{
+public:
+    OobReaderDuplicate(const uint32_t* src, int srcWidth, int srcHeight, int y) :
+        s_m1(src + srcWidth * std::clamp(y - 1, 0, srcHeight - 1)),
+        s_0 (src + srcWidth * std::clamp(y,     0, srcHeight - 1)),
+        s_p1(src + srcWidth * std::clamp(y + 1, 0, srcHeight - 1)),
+        s_p2(src + srcWidth * std::clamp(y + 2, 0, srcHeight - 1)),
+        srcWidth_(srcWidth) {}
+
+    void readDhlp(Kernel_4x4& ker, int x) const //(x, y) is at kernel position F
+    {
+        const int x_p2 = std::clamp(x + 2, 0, srcWidth_ - 1);
+        ker.d = s_m1[x_p2];
+        ker.h = s_0 [x_p2];
+        ker.l = s_p1[x_p2];
+        ker.p = s_p2[x_p2];
+    }
+
+private:
+    const uint32_t* const s_m1;
+    const uint32_t* const s_0;
+    const uint32_t* const s_p1;
+    const uint32_t* const s_p2;
+    const int srcWidth_;
+};
+
+
+template <class Scaler, class ColorDistance, class OobReader> //scaler policy: see "Scaler2x" reference implementation
+void scaleImage(const uint32_t* src, uint32_t* trg, int srcWidth, int srcHeight, const xbrz::ScalerCfg& cfg, int yFirst, int yLast)
+{
+    yFirst = std::max(yFirst, 0);
+    yLast  = std::min(yLast, srcHeight);
+    if (yFirst >= yLast || srcWidth <= 0)
+        return;
+
+    const int trgWidth = srcWidth * Scaler::scale;
+
+    //(ab)use space of "sizeof(uint32_t) * srcWidth * Scaler::scale" at the end of the image as temporary
+    //buffer for "on the fly preprocessing" without risk of accidental overwriting before accessing
+    unsigned char* const preProcBuf = reinterpret_cast<unsigned char*>(trg + yLast * Scaler::scale * trgWidth) - srcWidth;
+
+    //initialize preprocessing buffer for first row of current stripe: detect upper left and right corner blending
+    //this cannot be optimized for adjacent processing stripes; we must not allow for a memory race condition!
+    {
+        const OobReader oobReader(src, srcWidth, srcHeight, yFirst - 1);
+
+        //initialize at position x = -1
+        Kernel_4x4 ker4 = {};
+        oobReader.readDhlp(ker4, -4); //hack: read a, e, i, m at x = -1
+        ker4.a = ker4.d;
+        ker4.e = ker4.h;
+        ker4.i = ker4.l;
+        ker4.m = ker4.p;
+
+        oobReader.readDhlp(ker4, -3);
+        ker4.b = ker4.d;
+        ker4.f = ker4.h;
+        ker4.j = ker4.l;
+        ker4.n = ker4.p;
+
+        oobReader.readDhlp(ker4, -2);
+        ker4.c = ker4.d;
+        ker4.g = ker4.h;
+        ker4.k = ker4.l;
+        ker4.o = ker4.p;
+
+        oobReader.readDhlp(ker4, -1);
+
+        {
+            const BlendResult res = preProcessCorners<ColorDistance>(ker4, cfg);
+            clearAddTopL(preProcBuf[0], res.blend_k); //set 1st known corner for (0, yFirst)
+        }
+
+        for (int x = 0; x < srcWidth; ++x)
+        {
+            ker4.a = ker4.b;    //shift previous kernel to the left
+            ker4.e = ker4.f;    // -----------------
+            ker4.i = ker4.j;    // | A | B | C | D |
+            ker4.m = ker4.n;    // |---|---|---|---|
+            /**/                // | E | F | G | H | (x, yFirst - 1) is at position F
+            ker4.b = ker4.c;    // |---|---|---|---|
+            ker4.f = ker4.g;    // | I | J | K | L |
+            ker4.j = ker4.k;    // |---|---|---|---|
+            ker4.n = ker4.o;    // | M | N | O | P |
+            /**/                // -----------------
+            ker4.c = ker4.d;
+            ker4.g = ker4.h;
+            ker4.k = ker4.l;
+            ker4.o = ker4.p;
+
+            oobReader.readDhlp(ker4, x);
+
+            /*  preprocessing blend result:
+                ---------
+                | F | G |   evaluate corner between F, G, J, K
+                |---+---|   current input pixel is at position F
+                | J | K |
+                ---------                                        */
+            const BlendResult res = preProcessCorners<ColorDistance>(ker4, cfg);
+            addTopR(preProcBuf[x], res.blend_j); //set 2nd known corner for (x, yFirst)
+
+            if (x + 1 < srcWidth)
+                clearAddTopL(preProcBuf[x + 1], res.blend_k); //set 1st known corner for (x + 1, yFirst)
+        }
+    }
+    //------------------------------------------------------------------------------------
+
+    for (int y = yFirst; y < yLast; ++y)
+    {
+        uint32_t* out = trg + Scaler::scale * y * trgWidth; //consider MT "striped" access
+
+        const OobReader oobReader(src, srcWidth, srcHeight, y);
+
+        //initialize at position x = -1
+        Kernel_4x4 ker4 = {};
+        oobReader.readDhlp(ker4, -4); //hack: read a, e, i, m at x = -1
+        ker4.a = ker4.d;
+        ker4.e = ker4.h;
+        ker4.i = ker4.l;
+        ker4.m = ker4.p;
+
+        oobReader.readDhlp(ker4, -3);
+        ker4.b = ker4.d;
+        ker4.f = ker4.h;
+        ker4.j = ker4.l;
+        ker4.n = ker4.p;
+
+        oobReader.readDhlp(ker4, -2);
+        ker4.c = ker4.d;
+        ker4.g = ker4.h;
+        ker4.k = ker4.l;
+        ker4.o = ker4.p;
+
+        oobReader.readDhlp(ker4, -1);
+
+        unsigned char blend_xy1 = 0; //corner blending for current (x, y + 1) position
+        {
+            const BlendResult res = preProcessCorners<ColorDistance>(ker4, cfg);
+            clearAddTopL(blend_xy1, res.blend_k); //set 1st known corner for (0, y + 1) and buffer for use on next column
+
+            addBottomL(preProcBuf[0], res.blend_g); //set 3rd known corner for (0, y)
+        }
+
+        for (int x = 0; x < srcWidth; ++x, out += Scaler::scale)
+        {
+#if defined _MSC_VER && !defined NDEBUG
+            breakIntoDebugger = debugPixelX == x && debugPixelY == y;
+#endif
+            ker4.a = ker4.b;    //shift previous kernel to the left
+            ker4.e = ker4.f;    // -----------------
+            ker4.i = ker4.j;    // | A | B | C | D |
+            ker4.m = ker4.n;    // |---|---|---|---|
+            /**/                // | E | F | G | H | (x, y) is at position F
+            ker4.b = ker4.c;    // |---|---|---|---|
+            ker4.f = ker4.g;    // | I | J | K | L |
+            ker4.j = ker4.k;    // |---|---|---|---|
+            ker4.n = ker4.o;    // | M | N | O | P |
+            /**/                // -----------------
+            ker4.c = ker4.d;
+            ker4.g = ker4.h;
+            ker4.k = ker4.l;
+            ker4.o = ker4.p;
+
+            oobReader.readDhlp(ker4, x);
+
+            //evaluate the four corners on bottom-right of current pixel
+            unsigned char blend_xy = preProcBuf[x]; //for current (x, y) position
+            {
+                /*  preprocessing blend result:
+                    ---------
+                    | F | G |   evaluate corner between F, G, J, K
+                    |---+---|   current input pixel is at position F
+                    | J | K |
+                    ---------                                        */
+                const BlendResult res = preProcessCorners<ColorDistance>(ker4, cfg);
+                addBottomR(blend_xy, res.blend_f); //all four corners of (x, y) have been determined at this point due to processing sequence!
+
+                addTopR(blend_xy1, res.blend_j); //set 2nd known corner for (x, y + 1)
+                preProcBuf[x] = blend_xy1; //store on current buffer position for use on next row
+
+                [[likely]] if (x + 1 < srcWidth)
+                {
+                    //blend_xy1 -> blend_x1y1
+                    clearAddTopL(blend_xy1, res.blend_k); //set 1st known corner for (x + 1, y + 1) and buffer for use on next column
+
+                    addBottomL(preProcBuf[x + 1], res.blend_g); //set 3rd known corner for (x + 1, y)
+                }
+            }
+
+            //fill block of size scale * scale with the given color
+            fillBlock(out, trgWidth * sizeof(uint32_t), ker4.f, Scaler::scale, Scaler::scale);
+            //place *after* preprocessing step, to not overwrite the results while processing the last pixel!
+
+            //blend all four corners of current pixel
+            if (blendingNeeded(blend_xy))
+            {
+#ifndef _MSC_VER
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wstrict-aliasing"
+#endif
+                const auto& ker3 = reinterpret_cast<const Kernel_3x3&>(ker4); //"The Things We Do for Perf"
+                blendPixel<Scaler, ColorDistance, ROT_0  >(ker3, out, trgWidth, blend_xy, cfg);
+                blendPixel<Scaler, ColorDistance, ROT_90 >(ker3, out, trgWidth, blend_xy, cfg);
+                blendPixel<Scaler, ColorDistance, ROT_180>(ker3, out, trgWidth, blend_xy, cfg);
+                blendPixel<Scaler, ColorDistance, ROT_270>(ker3, out, trgWidth, blend_xy, cfg);
+#ifndef _MSC_VER
+#pragma GCC diagnostic pop
+#endif
+            }
+        }
+    }
+}
+
+//------------------------------------------------------------------------------------
+
+template <class ColorGradient>
+struct Scaler2x : public ColorGradient
+{
+    static const int scale = 2;
+
+    template <unsigned int M, unsigned int N> //bring template function into scope for GCC
+    static void alphaGrad(uint32_t& pixBack, uint32_t pixFront) { ColorGradient::template alphaGrad<M, N>(pixBack, pixFront); }
+
+
+    template <class OutputMatrix>
+    static void blendLineShallow(uint32_t col, OutputMatrix& out)
+    {
+        alphaGrad<1, 4>(out.template ref<scale - 1, 0>(), col);
+        alphaGrad<3, 4>(out.template ref<scale - 1, 1>(), col);
+    }
+
+    template <class OutputMatrix>
+    static void blendLineSteep(uint32_t col, OutputMatrix& out)
+    {
+        alphaGrad<1, 4>(out.template ref<0, scale - 1>(), col);
+        alphaGrad<3, 4>(out.template ref<1, scale - 1>(), col);
+    }
+
+    template <class OutputMatrix>
+    static void blendLineSteepAndShallow(uint32_t col, OutputMatrix& out)
+    {
+        alphaGrad<1, 4>(out.template ref<1, 0>(), col);
+        alphaGrad<1, 4>(out.template ref<0, 1>(), col);
+        alphaGrad<5, 6>(out.template ref<1, 1>(), col); //[!] fixes 7/8 used in xBR
+    }
+
+    template <class OutputMatrix>
+    static void blendLineDiagonal(uint32_t col, OutputMatrix& out)
+    {
+        alphaGrad<1, 2>(out.template ref<1, 1>(), col);
+    }
+
+    template <class OutputMatrix>
+    static void blendCorner(uint32_t col, OutputMatrix& out)
+    {
+        //model a round corner
+        alphaGrad<21, 100>(out.template ref<1, 1>(), col); //exact: 1 - pi/4 = 0.2146018366
+    }
+};
+
+
+template <class ColorGradient>
+struct Scaler3x : public ColorGradient
+{
+    static const int scale = 3;
+
+    template <unsigned int M, unsigned int N> //bring template function into scope for GCC
+    static void alphaGrad(uint32_t& pixBack, uint32_t pixFront) { ColorGradient::template alphaGrad<M, N>(pixBack, pixFront); }
+
+
+    template <class OutputMatrix>
+    static void blendLineShallow(uint32_t col, OutputMatrix& out)
+    {
+        alphaGrad<1, 4>(out.template ref<scale - 1, 0>(), col);
+        alphaGrad<1, 4>(out.template ref<scale - 2, 2>(), col);
+
+        alphaGrad<3, 4>(out.template ref<scale - 1, 1>(), col);
+        out.template ref<scale - 1, 2>() = col;
+    }
+
+    template <class OutputMatrix>
+    static void blendLineSteep(uint32_t col, OutputMatrix& out)
+    {
+        alphaGrad<1, 4>(out.template ref<0, scale - 1>(), col);
+        alphaGrad<1, 4>(out.template ref<2, scale - 2>(), col);
+
+        alphaGrad<3, 4>(out.template ref<1, scale - 1>(), col);
+        out.template ref<2, scale - 1>() = col;
+    }
+
+    template <class OutputMatrix>
+    static void blendLineSteepAndShallow(uint32_t col, OutputMatrix& out)
+    {
+        alphaGrad<1, 4>(out.template ref<2, 0>(), col);
+        alphaGrad<1, 4>(out.template ref<0, 2>(), col);
+        alphaGrad<3, 4>(out.template ref<2, 1>(), col);
+        alphaGrad<3, 4>(out.template ref<1, 2>(), col);
+        out.template ref<2, 2>() = col;
+    }
+
+    template <class OutputMatrix>
+    static void blendLineDiagonal(uint32_t col, OutputMatrix& out)
+    {
+        alphaGrad<1, 8>(out.template ref<1, 2>(), col); //conflict with other rotations for this odd scale
+        alphaGrad<1, 8>(out.template ref<2, 1>(), col);
+        alphaGrad<7, 8>(out.template ref<2, 2>(), col); //
+    }
+
+    template <class OutputMatrix>
+    static void blendCorner(uint32_t col, OutputMatrix& out)
+    {
+        //model a round corner
+        alphaGrad<45, 100>(out.template ref<2, 2>(), col); //exact: 0.4545939598
+        //alphaGrad<7, 256>(out.template ref<2, 1>(), col); //0.02826017254 -> negligible + avoid conflicts with other rotations for this odd scale
+        //alphaGrad<7, 256>(out.template ref<1, 2>(), col); //0.02826017254
+    }
+};
+
+
+template <class ColorGradient>
+struct Scaler4x : public ColorGradient
+{
+    static const int scale = 4;
+
+    template <unsigned int M, unsigned int N> //bring template function into scope for GCC
+    static void alphaGrad(uint32_t& pixBack, uint32_t pixFront) { ColorGradient::template alphaGrad<M, N>(pixBack, pixFront); }
+
+
+    template <class OutputMatrix>
+    static void blendLineShallow(uint32_t col, OutputMatrix& out)
+    {
+        alphaGrad<1, 4>(out.template ref<scale - 1, 0>(), col);
+        alphaGrad<1, 4>(out.template ref<scale - 2, 2>(), col);
+
+        alphaGrad<3, 4>(out.template ref<scale - 1, 1>(), col);
+        alphaGrad<3, 4>(out.template ref<scale - 2, 3>(), col);
+
+        out.template ref<scale - 1, 2>() = col;
+        out.template ref<scale - 1, 3>() = col;
+    }
+
+    template <class OutputMatrix>
+    static void blendLineSteep(uint32_t col, OutputMatrix& out)
+    {
+        alphaGrad<1, 4>(out.template ref<0, scale - 1>(), col);
+        alphaGrad<1, 4>(out.template ref<2, scale - 2>(), col);
+
+        alphaGrad<3, 4>(out.template ref<1, scale - 1>(), col);
+        alphaGrad<3, 4>(out.template ref<3, scale - 2>(), col);
+
+        out.template ref<2, scale - 1>() = col;
+        out.template ref<3, scale - 1>() = col;
+    }
+
+    template <class OutputMatrix>
+    static void blendLineSteepAndShallow(uint32_t col, OutputMatrix& out)
+    {
+        alphaGrad<3, 4>(out.template ref<3, 1>(), col);
+        alphaGrad<3, 4>(out.template ref<1, 3>(), col);
+        alphaGrad<1, 4>(out.template ref<3, 0>(), col);
+        alphaGrad<1, 4>(out.template ref<0, 3>(), col);
+
+        alphaGrad<1, 3>(out.template ref<2, 2>(), col); //[!] fixes 1/4 used in xBR
+
+        out.template ref<3, 3>() = col;
+        out.template ref<3, 2>() = col;
+        out.template ref<2, 3>() = col;
+    }
+
+    template <class OutputMatrix>
+    static void blendLineDiagonal(uint32_t col, OutputMatrix& out)
+    {
+        alphaGrad<1, 2>(out.template ref<scale - 1, scale / 2    >(), col);
+        alphaGrad<1, 2>(out.template ref<scale - 2, scale / 2 + 1>(), col);
+        out.template ref<scale - 1, scale - 1>() = col;
+    }
+
+    template <class OutputMatrix>
+    static void blendCorner(uint32_t col, OutputMatrix& out)
+    {
+        //model a round corner
+        alphaGrad<68, 100>(out.template ref<3, 3>(), col); //exact: 0.6848532563
+        alphaGrad< 9, 100>(out.template ref<3, 2>(), col); //0.08677704501
+        alphaGrad< 9, 100>(out.template ref<2, 3>(), col); //0.08677704501
+    }
+};
+
+
+template <class ColorGradient>
+struct Scaler5x : public ColorGradient
+{
+    static const int scale = 5;
+
+    template <unsigned int M, unsigned int N> //bring template function into scope for GCC
+    static void alphaGrad(uint32_t& pixBack, uint32_t pixFront) { ColorGradient::template alphaGrad<M, N>(pixBack, pixFront); }
+
+
+    template <class OutputMatrix>
+    static void blendLineShallow(uint32_t col, OutputMatrix& out)
+    {
+        alphaGrad<1, 4>(out.template ref<scale - 1, 0>(), col);
+        alphaGrad<1, 4>(out.template ref<scale - 2, 2>(), col);
+        alphaGrad<1, 4>(out.template ref<scale - 3, 4>(), col);
+
+        alphaGrad<3, 4>(out.template ref<scale - 1, 1>(), col);
+        alphaGrad<3, 4>(out.template ref<scale - 2, 3>(), col);
+
+        out.template ref<scale - 1, 2>() = col;
+        out.template ref<scale - 1, 3>() = col;
+        out.template ref<scale - 1, 4>() = col;
+        out.template ref<scale - 2, 4>() = col;
+    }
+
+    template <class OutputMatrix>
+    static void blendLineSteep(uint32_t col, OutputMatrix& out)
+    {
+        alphaGrad<1, 4>(out.template ref<0, scale - 1>(), col);
+        alphaGrad<1, 4>(out.template ref<2, scale - 2>(), col);
+        alphaGrad<1, 4>(out.template ref<4, scale - 3>(), col);
+
+        alphaGrad<3, 4>(out.template ref<1, scale - 1>(), col);
+        alphaGrad<3, 4>(out.template ref<3, scale - 2>(), col);
+
+        out.template ref<2, scale - 1>() = col;
+        out.template ref<3, scale - 1>() = col;
+        out.template ref<4, scale - 1>() = col;
+        out.template ref<4, scale - 2>() = col;
+    }
+
+    template <class OutputMatrix>
+    static void blendLineSteepAndShallow(uint32_t col, OutputMatrix& out)
+    {
+        alphaGrad<1, 4>(out.template ref<0, scale - 1>(), col);
+        alphaGrad<1, 4>(out.template ref<2, scale - 2>(), col);
+        alphaGrad<3, 4>(out.template ref<1, scale - 1>(), col);
+
+        alphaGrad<1, 4>(out.template ref<scale - 1, 0>(), col);
+        alphaGrad<1, 4>(out.template ref<scale - 2, 2>(), col);
+        alphaGrad<3, 4>(out.template ref<scale - 1, 1>(), col);
+
+        alphaGrad<2, 3>(out.template ref<3, 3>(), col);
+
+        out.template ref<2, scale - 1>() = col;
+        out.template ref<3, scale - 1>() = col;
+        out.template ref<4, scale - 1>() = col;
+
+        out.template ref<scale - 1, 2>() = col;
+        out.template ref<scale - 1, 3>() = col;
+    }
+
+    template <class OutputMatrix>
+    static void blendLineDiagonal(uint32_t col, OutputMatrix& out)
+    {
+        alphaGrad<1, 8>(out.template ref<scale - 1, scale / 2    >(), col); //conflict with other rotations for this odd scale
+        alphaGrad<1, 8>(out.template ref<scale - 2, scale / 2 + 1>(), col);
+        alphaGrad<1, 8>(out.template ref<scale - 3, scale / 2 + 2>(), col); //
+
+        alphaGrad<7, 8>(out.template ref<4, 3>(), col);
+        alphaGrad<7, 8>(out.template ref<3, 4>(), col);
+
+        out.template ref<4, 4>() = col;
+    }
+
+    template <class OutputMatrix>
+    static void blendCorner(uint32_t col, OutputMatrix& out)
+    {
+        //model a round corner
+        alphaGrad<86, 100>(out.template ref<4, 4>(), col); //exact: 0.8631434088
+        alphaGrad<23, 100>(out.template ref<4, 3>(), col); //0.2306749731
+        alphaGrad<23, 100>(out.template ref<3, 4>(), col); //0.2306749731
+        //alphaGrad<1, 64>(out.template ref<4, 2>(), col); //0.01676812367 -> negligible + avoid conflicts with other rotations for this odd scale
+        //alphaGrad<1, 64>(out.template ref<2, 4>(), col); //0.01676812367
+    }
+};
+
+
+template <class ColorGradient>
+struct Scaler6x : public ColorGradient
+{
+    static const int scale = 6;
+
+    template <unsigned int M, unsigned int N> //bring template function into scope for GCC
+    static void alphaGrad(uint32_t& pixBack, uint32_t pixFront) { ColorGradient::template alphaGrad<M, N>(pixBack, pixFront); }
+
+
+    template <class OutputMatrix>
+    static void blendLineShallow(uint32_t col, OutputMatrix& out)
+    {
+        alphaGrad<1, 4>(out.template ref<scale - 1, 0>(), col);
+        alphaGrad<1, 4>(out.template ref<scale - 2, 2>(), col);
+        alphaGrad<1, 4>(out.template ref<scale - 3, 4>(), col);
+
+        alphaGrad<3, 4>(out.template ref<scale - 1, 1>(), col);
+        alphaGrad<3, 4>(out.template ref<scale - 2, 3>(), col);
+        alphaGrad<3, 4>(out.template ref<scale - 3, 5>(), col);
+
+        out.template ref<scale - 1, 2>() = col;
+        out.template ref<scale - 1, 3>() = col;
+        out.template ref<scale - 1, 4>() = col;
+        out.template ref<scale - 1, 5>() = col;
+
+        out.template ref<scale - 2, 4>() = col;
+        out.template ref<scale - 2, 5>() = col;
+    }
+
+    template <class OutputMatrix>
+    static void blendLineSteep(uint32_t col, OutputMatrix& out)
+    {
+        alphaGrad<1, 4>(out.template ref<0, scale - 1>(), col);
+        alphaGrad<1, 4>(out.template ref<2, scale - 2>(), col);
+        alphaGrad<1, 4>(out.template ref<4, scale - 3>(), col);
+
+        alphaGrad<3, 4>(out.template ref<1, scale - 1>(), col);
+        alphaGrad<3, 4>(out.template ref<3, scale - 2>(), col);
+        alphaGrad<3, 4>(out.template ref<5, scale - 3>(), col);
+
+        out.template ref<2, scale - 1>() = col;
+        out.template ref<3, scale - 1>() = col;
+        out.template ref<4, scale - 1>() = col;
+        out.template ref<5, scale - 1>() = col;
+
+        out.template ref<4, scale - 2>() = col;
+        out.template ref<5, scale - 2>() = col;
+    }
+
+    template <class OutputMatrix>
+    static void blendLineSteepAndShallow(uint32_t col, OutputMatrix& out)
+    {
+        alphaGrad<1, 4>(out.template ref<0, scale - 1>(), col);
+        alphaGrad<1, 4>(out.template ref<2, scale - 2>(), col);
+        alphaGrad<3, 4>(out.template ref<1, scale - 1>(), col);
+        alphaGrad<3, 4>(out.template ref<3, scale - 2>(), col);
+
+        alphaGrad<1, 4>(out.template ref<scale - 1, 0>(), col);
+        alphaGrad<1, 4>(out.template ref<scale - 2, 2>(), col);
+        alphaGrad<3, 4>(out.template ref<scale - 1, 1>(), col);
+        alphaGrad<3, 4>(out.template ref<scale - 2, 3>(), col);
+
+        out.template ref<2, scale - 1>() = col;
+        out.template ref<3, scale - 1>() = col;
+        out.template ref<4, scale - 1>() = col;
+        out.template ref<5, scale - 1>() = col;
+
+        out.template ref<4, scale - 2>() = col;
+        out.template ref<5, scale - 2>() = col;
+
+        out.template ref<scale - 1, 2>() = col;
+        out.template ref<scale - 1, 3>() = col;
+    }
+
+    template <class OutputMatrix>
+    static void blendLineDiagonal(uint32_t col, OutputMatrix& out)
+    {
+        alphaGrad<1, 2>(out.template ref<scale - 1, scale / 2    >(), col);
+        alphaGrad<1, 2>(out.template ref<scale - 2, scale / 2 + 1>(), col);
+        alphaGrad<1, 2>(out.template ref<scale - 3, scale / 2 + 2>(), col);
+
+        out.template ref<scale - 2, scale - 1>() = col;
+        out.template ref<scale - 1, scale - 1>() = col;
+        out.template ref<scale - 1, scale - 2>() = col;
+    }
+
+    template <class OutputMatrix>
+    static void blendCorner(uint32_t col, OutputMatrix& out)
+    {
+        //model a round corner
+        alphaGrad<97, 100>(out.template ref<5, 5>(), col); //exact: 0.9711013910
+        alphaGrad<42, 100>(out.template ref<4, 5>(), col); //0.4236372243
+        alphaGrad<42, 100>(out.template ref<5, 4>(), col); //0.4236372243
+        alphaGrad< 6, 100>(out.template ref<5, 3>(), col); //0.05652034508
+        alphaGrad< 6, 100>(out.template ref<3, 5>(), col); //0.05652034508
+    }
+};
+
+//------------------------------------------------------------------------------------
+
+struct ColorDistanceRGB
+{
+    static double dist(uint32_t pix1, uint32_t pix2, double luminanceWeight)
+    {
+        return distYCbCrBuffered(pix1, pix2);
+
+        //if (pix1 == pix2) //about 4% perf boost
+        //    return 0;
+        //return distYCbCr(pix1, pix2, luminanceWeight);
+    }
+};
+
+struct ColorDistanceARGB
+{
+    static double dist(uint32_t pix1, uint32_t pix2, double luminanceWeight)
+    {
+        const double a1 = getAlpha(pix1) / 255.0 ;
+        const double a2 = getAlpha(pix2) / 255.0 ;
+        /*
+        Requirements for a color distance handling alpha channel: with a1, a2 in [0, 1]
+
+            1. if a1 = a2, distance should be: a1 * distYCbCr()
+            2. if a1 = 0,  distance should be: a2 * distYCbCr(black, white) = a2 * 255
+            3. if a1 = 1,  ??? maybe: 255 * (1 - a2) + a2 * distYCbCr()
+        */
+
+        //return std::min(a1, a2) * distYCbCrBuffered(pix1, pix2) + 255 * abs(a1 - a2);
+        //=> following code is 15% faster:
+        const double d = distYCbCrBuffered(pix1, pix2);
+        if (a1 < a2)
+            return a1 * d + 255 * (a2 - a1);
+        else
+            return a2 * d + 255 * (a1 - a2);
+
+        //alternative? return std::sqrt(a1 * a2 * square(distYCbCrBuffered(pix1, pix2)) + square(255 * (a1 - a2)));
+    }
+};
+
+
+struct ColorDistanceUnbufferedARGB
+{
+    static double dist(uint32_t pix1, uint32_t pix2, double luminanceWeight)
+    {
+        const double a1 = getAlpha(pix1) / 255.0 ;
+        const double a2 = getAlpha(pix2) / 255.0 ;
+
+        const double d = distYCbCr(pix1, pix2, luminanceWeight);
+        if (a1 < a2)
+            return a1 * d + 255 * (a2 - a1);
+        else
+            return a2 * d + 255 * (a1 - a2);
+    }
+};
+
+
+struct ColorGradientRGB
+{
+    template <unsigned int M, unsigned int N>
+    static void alphaGrad(uint32_t& pixBack, uint32_t pixFront)
+    {
+        pixBack = gradientRGB<M, N>(pixFront, pixBack);
+    }
+};
+
+struct ColorGradientARGB
+{
+    template <unsigned int M, unsigned int N>
+    static void alphaGrad(uint32_t& pixBack, uint32_t pixFront)
+    {
+        pixBack = gradientARGB<M, N>(pixFront, pixBack);
+    }
+};
+}
+
+
+void xbrz::scale(size_t factor, const uint32_t* src, uint32_t* trg, int srcWidth, int srcHeight, ColorFormat colFmt, const xbrz::ScalerCfg& cfg, int yFirst, int yLast)
+{
+    if (factor == 1)
+    {
+        std::copy(src + yFirst * srcWidth, src + yLast * srcWidth, trg);
+        return;
+    }
+
+    static_assert(SCALE_FACTOR_MAX == 6);
+    switch (colFmt)
+    {
+        case ColorFormat::RGB:
+            switch (factor)
+            {
+                case 2:
+                    return scaleImage<Scaler2x<ColorGradientRGB>, ColorDistanceRGB, OobReaderDuplicate>(src, trg, srcWidth, srcHeight, cfg, yFirst, yLast);
+                case 3:
+                    return scaleImage<Scaler3x<ColorGradientRGB>, ColorDistanceRGB, OobReaderDuplicate>(src, trg, srcWidth, srcHeight, cfg, yFirst, yLast);
+                case 4:
+                    return scaleImage<Scaler4x<ColorGradientRGB>, ColorDistanceRGB, OobReaderDuplicate>(src, trg, srcWidth, srcHeight, cfg, yFirst, yLast);
+                case 5:
+                    return scaleImage<Scaler5x<ColorGradientRGB>, ColorDistanceRGB, OobReaderDuplicate>(src, trg, srcWidth, srcHeight, cfg, yFirst, yLast);
+                case 6:
+                    return scaleImage<Scaler6x<ColorGradientRGB>, ColorDistanceRGB, OobReaderDuplicate>(src, trg, srcWidth, srcHeight, cfg, yFirst, yLast);
+            }
+            break;
+
+        case ColorFormat::ARGB:
+            switch (factor)
+            {
+                case 2:
+                    return scaleImage<Scaler2x<ColorGradientARGB>, ColorDistanceARGB, OobReaderTransparent>(src, trg, srcWidth, srcHeight, cfg, yFirst, yLast);
+                case 3:
+                    return scaleImage<Scaler3x<ColorGradientARGB>, ColorDistanceARGB, OobReaderTransparent>(src, trg, srcWidth, srcHeight, cfg, yFirst, yLast);
+                case 4:
+                    return scaleImage<Scaler4x<ColorGradientARGB>, ColorDistanceARGB, OobReaderTransparent>(src, trg, srcWidth, srcHeight, cfg, yFirst, yLast);
+                case 5:
+                    return scaleImage<Scaler5x<ColorGradientARGB>, ColorDistanceARGB, OobReaderTransparent>(src, trg, srcWidth, srcHeight, cfg, yFirst, yLast);
+                case 6:
+                    return scaleImage<Scaler6x<ColorGradientARGB>, ColorDistanceARGB, OobReaderTransparent>(src, trg, srcWidth, srcHeight, cfg, yFirst, yLast);
+            }
+            break;
+
+        case ColorFormat::ARGB_UNBUFFERED:
+            switch (factor)
+            {
+                case 2:
+                    return scaleImage<Scaler2x<ColorGradientARGB>, ColorDistanceUnbufferedARGB, OobReaderTransparent>(src, trg, srcWidth, srcHeight, cfg, yFirst, yLast);
+                case 3:
+                    return scaleImage<Scaler3x<ColorGradientARGB>, ColorDistanceUnbufferedARGB, OobReaderTransparent>(src, trg, srcWidth, srcHeight, cfg, yFirst, yLast);
+                case 4:
+                    return scaleImage<Scaler4x<ColorGradientARGB>, ColorDistanceUnbufferedARGB, OobReaderTransparent>(src, trg, srcWidth, srcHeight, cfg, yFirst, yLast);
+                case 5:
+                    return scaleImage<Scaler5x<ColorGradientARGB>, ColorDistanceUnbufferedARGB, OobReaderTransparent>(src, trg, srcWidth, srcHeight, cfg, yFirst, yLast);
+                case 6:
+                    return scaleImage<Scaler6x<ColorGradientARGB>, ColorDistanceUnbufferedARGB, OobReaderTransparent>(src, trg, srcWidth, srcHeight, cfg, yFirst, yLast);
+            }
+            break;
+    }
+    assert(false);
+}
+
+
+bool xbrz::equalColorTest(uint32_t col1, uint32_t col2, ColorFormat colFmt, double luminanceWeight, double equalColorTolerance)
+{
+    switch (colFmt)
+    {
+        case ColorFormat::RGB:
+            return ColorDistanceRGB::dist(col1, col2, luminanceWeight) < equalColorTolerance;
+        case ColorFormat::ARGB:
+            return ColorDistanceARGB::dist(col1, col2, luminanceWeight) < equalColorTolerance;
+        case ColorFormat::ARGB_UNBUFFERED:
+            return ColorDistanceUnbufferedARGB::dist(col1, col2, luminanceWeight) < equalColorTolerance;
+    }
+    assert(false);
+    return false;
+}
+
+
+void xbrz::bilinearScale(const uint32_t* src, int srcWidth, int srcHeight,
+                         /**/  uint32_t* trg, int trgWidth, int trgHeight)
+{
+    bilinearScale(src, srcWidth, srcHeight, srcWidth * sizeof(uint32_t),
+                  trg, trgWidth, trgHeight, trgWidth * sizeof(uint32_t),
+    0, trgHeight, [](uint32_t pix) { return pix; });
+}
+
+
+void xbrz::nearestNeighborScale(const uint32_t* src, int srcWidth, int srcHeight,
+                                /**/  uint32_t* trg, int trgWidth, int trgHeight)
+{
+    nearestNeighborScale(src, srcWidth, srcHeight, srcWidth * sizeof(uint32_t),
+                         trg, trgWidth, trgHeight, trgWidth * sizeof(uint32_t),
+    0, trgHeight, [](uint32_t pix) { return pix; });
+}
+
+
+#if 0
+//#include <ppl.h>
+void bilinearScaleCpu(const uint32_t* src, int srcWidth, int srcHeight,
+                      /**/  uint32_t* trg, int trgWidth, int trgHeight)
+{
+    const int TASK_GRANULARITY = 16;
+
+    concurrency::task_group tg;
+
+    for (int i = 0; i < trgHeight; i += TASK_GRANULARITY)
+        tg.run([=]
+    {
+        const int iLast = std::min(i + TASK_GRANULARITY, trgHeight);
+        xbrz::bilinearScale(src, srcWidth, srcHeight, srcWidth * sizeof(uint32_t),
+                            trg, trgWidth, trgHeight, trgWidth * sizeof(uint32_t),
+        i, iLast, [](uint32_t pix) { return pix; });
+    });
+    tg.wait();
+}
+
+
+//Perf: AMP vs CPU: merely ~10% shorter runtime (scaling 1280x800 -> 1920x1080)
+//#include <amp.h>
+void bilinearScaleAmp(const uint32_t* src, int srcWidth, int srcHeight, //throw concurrency::runtime_exception
+                      /**/  uint32_t* trg, int trgWidth, int trgHeight)
+{
+    //C++ AMP reference:       https://msdn.microsoft.com/en-us/library/hh289390.aspx
+    //introduction to C++ AMP: https://msdn.microsoft.com/en-us/magazine/hh882446.aspx
+    using namespace concurrency;
+    //TODO: pitch
+
+    if (srcHeight <= 0 || srcWidth <= 0) return;
+
+    const float scaleX = static_cast<float>(trgWidth ) / srcWidth;
+    const float scaleY = static_cast<float>(trgHeight) / srcHeight;
+
+    array_view<const uint32_t, 2> srcView(srcHeight, srcWidth, src);
+    array_view<      uint32_t, 2> trgView(trgHeight, trgWidth, trg);
+    trgView.discard_data();
+
+    parallel_for_each(trgView.extent, [=](index<2> idx) restrict(amp) //throw ?
+    {
+        const int y = idx[0];
+        const int x = idx[1];
+        //Perf notes:
+        //    -> float-based calculation is (almost) 2x as fas as double!
+        //    -> no noticeable improvement via tiling: https://msdn.microsoft.com/en-us/magazine/hh882447.aspx
+        //    -> no noticeable improvement with restrict(amp,cpu)
+        //    -> iterating over y-axis only is significantly slower!
+        //    -> pre-calculating x,y-dependent variables in a buffer + array_view<> is ~ 20 % slower!
+        const int y1 = srcHeight * y / trgHeight;
+        int y2 = y1 + 1;
+        if (y2 == srcHeight) --y2;
+
+        const float yy1 = y / scaleY - y1;
+        const float y2y = 1 - yy1;
+        //-------------------------------------
+        const int x1 = srcWidth * x / trgWidth;
+        int x2 = x1 + 1;
+        if (x2 == srcWidth) --x2;
+
+        const float xx1 = x / scaleX - x1;
+        const float x2x = 1 - xx1;
+        //-------------------------------------
+        const float x2xy2y = x2x * y2y;
+        const float xx1y2y = xx1 * y2y;
+        const float x2xyy1 = x2x * yy1;
+        const float xx1yy1 = xx1 * yy1;
+
+        auto interpolate = [=](int offset)
+        {
+            /*
+                https://en.wikipedia.org/wiki/Bilinear_interpolation
+                (c11(x2 - x) + c21(x - x1)) * (y2 - y ) +
+                (c12(x2 - x) + c22(x - x1)) * (y  - y1)
+            */
+            const auto c11 = (srcView(y1, x1) >> (8 * offset)) & 0xff;
+            const auto c21 = (srcView(y1, x2) >> (8 * offset)) & 0xff;
+            const auto c12 = (srcView(y2, x1) >> (8 * offset)) & 0xff;
+            const auto c22 = (srcView(y2, x2) >> (8 * offset)) & 0xff;
+
+            return c11 * x2xy2y + c21 * xx1y2y +
+                   c12 * x2xyy1 + c22 * xx1yy1;
+        };
+
+        const float bi = interpolate(0);
+        const float gi = interpolate(1);
+        const float ri = interpolate(2);
+        const float ai = interpolate(3);
+
+        const auto b = static_cast<uint32_t>(bi + 0.5f);
+        const auto g = static_cast<uint32_t>(gi + 0.5f);
+        const auto r = static_cast<uint32_t>(ri + 0.5f);
+        const auto a = static_cast<uint32_t>(ai + 0.5f);
+
+        trgView(y, x) = (a << 24) | (r << 16) | (g << 8) | b;
+    });
+    trgView.synchronize(); //throw ?
+}
+#endif
diff --color -urN vcmi-1.5.7/client/xBRZ/xbrz.h vcmi/client/xBRZ/xbrz.h
--- vcmi-1.5.7/client/xBRZ/xbrz.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/client/xBRZ/xbrz.h	2024-12-19 15:00:22.412127853 +0100
@@ -0,0 +1,79 @@
+// ****************************************************************************
+// * This file is part of the xBRZ project. It is distributed under           *
+// * GNU General Public License: https://www.gnu.org/licenses/gpl-3.0         *
+// * Copyright (C) Zenju (zenju AT gmx DOT de) - All Rights Reserved          *
+// *                                                                          *
+// * Additionally and as a special exception, the author gives permission     *
+// * to link the code of this program with the following libraries            *
+// * (or with modified versions that use the same licenses), and distribute   *
+// * linked combinations including the two: MAME, FreeFileSync, Snes9x, ePSXe *
+// * You must obey the GNU General Public License in all respects for all of  *
+// * the code used other than MAME, FreeFileSync, Snes9x, ePSXe.              *
+// * If you modify this file, you may extend this exception to your version   *
+// * of the file, but you are not obligated to do so. If you do not wish to   *
+// * do so, delete this exception statement from your version.                *
+// ****************************************************************************
+
+#ifndef XBRZ_HEADER_3847894708239054
+#define XBRZ_HEADER_3847894708239054
+
+#include <cstddef> //size_t
+#include <cstdint> //uint32_t
+#include <limits>
+#include "xbrz_config.h"
+
+
+namespace xbrz
+{
+/*
+-------------------------------------------------------------------------
+| xBRZ: "Scale by rules" - high quality image upscaling filter by Zenju |
+-------------------------------------------------------------------------
+using a modified approach of xBR:
+http://board.byuu.org/viewtopic.php?f=10&t=2248
+- new rule set preserving small image features
+- highly optimized for performance
+- support alpha channel
+- support multithreading
+- support 64-bit architectures
+- support processing image slices
+- support scaling up to 6xBRZ
+*/
+
+enum class ColorFormat //from high bits -> low bits, 8 bit per channel
+{
+    RGB,  //8 bit for each red, green, blue, upper 8 bits unused
+    ARGB, //including alpha channel, BGRA byte order on little-endian machines
+    ARGB_UNBUFFERED, //like ARGB, but without the one-time buffer creation overhead (ca. 100 - 300 ms) at the expense of a slightly slower scaling time
+};
+
+const int SCALE_FACTOR_MAX = 6;
+
+/*
+-> map source (srcWidth * srcHeight) to target (scale * width x scale * height) image, optionally processing a half-open slice of rows [yFirst, yLast) only
+-> if your emulator changes only a few image slices during each cycle (e.g. DOSBox) then there's no need to run xBRZ on the complete image:
+   Just make sure you enlarge the source image slice by 2 rows on top and 2 on bottom (this is the additional range the xBRZ algorithm is using during analysis)
+   CAVEAT: If there are multiple changed slices, make sure they do not overlap after adding these additional rows in order to avoid a memory race condition
+   in the target image data if you are using multiple threads for processing each enlarged slice!
+
+THREAD-SAFETY: - parts of the same image may be scaled by multiple threads as long as the [yFirst, yLast) ranges do not overlap!
+               - there is a minor inefficiency for the first row of a slice, so avoid processing single rows only; suggestion: process at least 8-16 rows
+*/
+void scale(size_t factor, //valid range: 2 - SCALE_FACTOR_MAX
+           const uint32_t* src, uint32_t* trg, int srcWidth, int srcHeight,
+           ColorFormat colFmt,
+           const ScalerCfg& cfg = ScalerCfg(),
+           int yFirst = 0, int yLast = std::numeric_limits<int>::max()); //slice of source image
+
+void bilinearScale(const uint32_t* src, int srcWidth, int srcHeight,
+                   /**/  uint32_t* trg, int trgWidth, int trgHeight);
+
+void nearestNeighborScale(const uint32_t* src, int srcWidth, int srcHeight,
+                          /**/  uint32_t* trg, int trgWidth, int trgHeight);
+
+
+//parameter tuning
+bool equalColorTest(uint32_t col1, uint32_t col2, ColorFormat colFmt, double luminanceWeight, double equalColorTolerance);
+}
+
+#endif
diff --color -urN vcmi-1.5.7/client/xBRZ/xbrz_tools.h vcmi/client/xBRZ/xbrz_tools.h
--- vcmi-1.5.7/client/xBRZ/xbrz_tools.h	1970-01-01 01:00:00.000000000 +0100
+++ vcmi/client/xBRZ/xbrz_tools.h	2024-12-19 15:00:22.413127894 +0100
@@ -0,0 +1,266 @@
+// ****************************************************************************
+// * This file is part of the xBRZ project. It is distributed under           *
+// * GNU General Public License: https://www.gnu.org/licenses/gpl-3.0         *
+// * Copyright (C) Zenju (zenju AT gmx DOT de) - All Rights Reserved          *
+// *                                                                          *
+// * Additionally and as a special exception, the author gives permission     *
+// * to link the code of this program with the following libraries            *
+// * (or with modified versions that use the same licenses), and distribute   *
+// * linked combinations including the two: MAME, FreeFileSync, Snes9x, ePSXe *
+// * You must obey the GNU General Public License in all respects for all of  *
+// * the code used other than MAME, FreeFileSync, Snes9x, ePSXe.              *
+// * If you modify this file, you may extend this exception to your version   *
+// * of the file, but you are not obligated to do so. If you do not wish to   *
+// * do so, delete this exception statement from your version.                *
+// ****************************************************************************
+
+#ifndef XBRZ_TOOLS_H_825480175091875
+#define XBRZ_TOOLS_H_825480175091875
+
+#include <cassert>
+#include <algorithm>
+#include <type_traits>
+
+
+namespace xbrz
+{
+template <uint32_t N> inline
+unsigned char getByte(uint32_t val) { return static_cast<unsigned char>((val >> (8 * N)) & 0xff); }
+
+inline unsigned char getAlpha(uint32_t pix) { return getByte<3>(pix); }
+inline unsigned char getRed  (uint32_t pix) { return getByte<2>(pix); }
+inline unsigned char getGreen(uint32_t pix) { return getByte<1>(pix); }
+inline unsigned char getBlue (uint32_t pix) { return getByte<0>(pix); }
+
+inline uint32_t makePixel(unsigned char a, unsigned char r, unsigned char g, unsigned char b) { return (a << 24) | (r << 16) | (g << 8) | b; }
+inline uint32_t makePixel(                 unsigned char r, unsigned char g, unsigned char b) { return             (r << 16) | (g << 8) | b; }
+
+inline uint32_t rgb555to888(uint16_t pix) { return ((pix & 0x7C00) << 9) | ((pix & 0x03E0) << 6) | ((pix & 0x001F) << 3); }
+inline uint32_t rgb565to888(uint16_t pix) { return ((pix & 0xF800) << 8) | ((pix & 0x07E0) << 5) | ((pix & 0x001F) << 3); }
+
+inline uint16_t rgb888to555(uint32_t pix) { return static_cast<uint16_t>(((pix & 0xF80000) >> 9) | ((pix & 0x00F800) >> 6) | ((pix & 0x0000F8) >> 3)); }
+inline uint16_t rgb888to565(uint32_t pix) { return static_cast<uint16_t>(((pix & 0xF80000) >> 8) | ((pix & 0x00FC00) >> 5) | ((pix & 0x0000F8) >> 3)); }
+
+
+template <class Pix> inline
+Pix* byteAdvance(Pix* ptr, int bytes)
+{
+    using PixNonConst = typename std::remove_cv<Pix>::type;
+    using PixByte     = typename std::conditional<std::is_same<Pix, PixNonConst>::value, char, const char>::type;
+
+    static_assert(std::is_integral<PixNonConst>::value, "Pix* is expected to be cast-able to char*");
+
+    return reinterpret_cast<Pix*>(reinterpret_cast<PixByte*>(ptr) + bytes);
+}
+
+
+//fill block  with the given color
+template <class Pix> inline
+void fillBlock(Pix* trg, int pitch /*[bytes]*/, Pix col, int blockWidth, int blockHeight)
+{
+    //for (int y = 0; y < blockHeight; ++y, trg = byteAdvance(trg, pitch))
+    //    std::fill(trg, trg + blockWidth, col);
+
+    for (int y = 0; y < blockHeight; ++y, trg = byteAdvance(trg, pitch))
+        for (int x = 0; x < blockWidth; ++x)
+            trg[x] = col;
+}
+
+
+//nearest-neighbor (going over target image - slow for upscaling, since source is read multiple times missing out on cache! Fast for similar image sizes!)
+template <class PixSrc, class PixTrg, class PixConverter>
+void nearestNeighborScale(const PixSrc* src, int srcWidth, int srcHeight, int srcPitch /*[bytes]*/,
+                          /**/  PixTrg* trg, int trgWidth, int trgHeight, int trgPitch /*[bytes]*/,
+                          int yFirst, int yLast, PixConverter pixCvrt /*convert PixSrc to PixTrg*/)
+{
+    static_assert(std::is_integral<PixSrc>::value, "PixSrc* is expected to be cast-able to char*");
+    static_assert(std::is_integral<PixTrg>::value, "PixTrg* is expected to be cast-able to char*");
+
+    static_assert(std::is_same<decltype(pixCvrt(PixSrc())), PixTrg>::value, "PixConverter returning wrong pixel format");
+
+    if (srcPitch < srcWidth * static_cast<int>(sizeof(PixSrc))  ||
+        trgPitch < trgWidth * static_cast<int>(sizeof(PixTrg)))
+    {
+        assert(false);
+        return;
+    }
+
+    yFirst = std::max(yFirst, 0);
+    yLast  = std::min(yLast, trgHeight);
+    if (yFirst >= yLast || srcHeight <= 0 || srcWidth <= 0) return;
+
+    for (int y = yFirst; y < yLast; ++y)
+    {
+        const int ySrc = srcHeight * y / trgHeight;
+        const PixSrc* const srcLine = byteAdvance(src, ySrc * srcPitch);
+        PixTrg*       const trgLine = byteAdvance(trg, y    * trgPitch);
+
+        for (int x = 0; x < trgWidth; ++x)
+        {
+            const int xSrc = srcWidth * x / trgWidth;
+            trgLine[x] = pixCvrt(srcLine[xSrc]);
+        }
+    }
+}
+
+
+//nearest-neighbor (going over source image - fast for upscaling, since source is read only once
+template <class PixSrc, class PixTrg, class PixConverter>
+void nearestNeighborScaleOverSource(const PixSrc* src, int srcWidth, int srcHeight, int srcPitch /*[bytes]*/,
+                                    /**/  PixTrg* trg, int trgWidth, int trgHeight, int trgPitch /*[bytes]*/,
+                                    int yFirst, int yLast, PixConverter pixCvrt /*convert PixSrc to PixTrg*/)
+{
+    static_assert(std::is_integral<PixSrc>::value, "PixSrc* is expected to be cast-able to char*");
+    static_assert(std::is_integral<PixTrg>::value, "PixTrg* is expected to be cast-able to char*");
+
+    static_assert(std::is_same<decltype(pixCvrt(PixSrc())), PixTrg>::value, "PixConverter returning wrong pixel format");
+
+    if (srcPitch < srcWidth * static_cast<int>(sizeof(PixSrc))  ||
+        trgPitch < trgWidth * static_cast<int>(sizeof(PixTrg)))
+    {
+        assert(false);
+        return;
+    }
+
+    yFirst = std::max(yFirst, 0);
+    yLast  = std::min(yLast, srcHeight);
+    if (yFirst >= yLast || trgWidth <= 0 || trgHeight <= 0) return;
+
+    for (int y = yFirst; y < yLast; ++y)
+    {
+        //mathematically: ySrc = floor(srcHeight * yTrg / trgHeight)
+        // => search for integers in: [ySrc, ySrc + 1) * trgHeight / srcHeight
+
+        //keep within for loop to support MT input slices!
+        const int yTrgFirst = ( y      * trgHeight + srcHeight - 1) / srcHeight; //=ceil(y * trgHeight / srcHeight)
+        const int yTrgLast  = ((y + 1) * trgHeight + srcHeight - 1) / srcHeight; //=ceil(((y + 1) * trgHeight) / srcHeight)
+        const int blockHeight = yTrgLast - yTrgFirst;
+
+        if (blockHeight > 0)
+        {
+            const PixSrc* srcLine = byteAdvance(src, y         * srcPitch);
+            /**/  PixTrg* trgLine = byteAdvance(trg, yTrgFirst * trgPitch);
+            int xTrgFirst = 0;
+
+            for (int x = 0; x < srcWidth; ++x)
+            {
+                const int xTrgLast = ((x + 1) * trgWidth + srcWidth - 1) / srcWidth;
+                const int blockWidth = xTrgLast - xTrgFirst;
+                if (blockWidth > 0)
+                {
+                    xTrgFirst = xTrgLast;
+
+                    const auto trgPix = pixCvrt(srcLine[x]);
+                    fillBlock(trgLine, trgPitch, trgPix, blockWidth, blockHeight);
+                    trgLine += blockWidth;
+                }
+            }
+        }
+    }
+}
+
+
+template <class PixTrg, class PixConverter>
+void bilinearScale(const uint32_t* src, int srcWidth, int srcHeight, int srcPitch,
+                   /**/    PixTrg* trg, int trgWidth, int trgHeight, int trgPitch,
+                   int yFirst, int yLast, PixConverter pixCvrt /*convert uint32_t to PixTrg*/)
+{
+    static_assert(std::is_integral<PixTrg>::value,                            "PixTrg* is expected to be cast-able to char*");
+    static_assert(std::is_same<decltype(pixCvrt(uint32_t())), PixTrg>::value, "PixConverter returning wrong pixel format");
+
+    if (srcPitch < srcWidth * static_cast<int>(sizeof(uint32_t)) ||
+        trgPitch < trgWidth * static_cast<int>(sizeof(PixTrg)))
+    {
+        assert(false);
+        return;
+    }
+
+    yFirst = std::max(yFirst, 0);
+    yLast  = std::min(yLast, trgHeight);
+    if (yFirst >= yLast || srcHeight <= 0 || srcWidth <= 0) return;
+
+    const double scaleX = static_cast<double>(trgWidth ) / srcWidth;
+    const double scaleY = static_cast<double>(trgHeight) / srcHeight;
+
+    //perf notes:
+    //    -> double-based calculation is (slightly) faster than float
+    //    -> pre-calculation gives significant boost; std::vector<> memory allocation is negligible!
+    struct CoeffsX
+    {
+        int     x1 = 0;
+        int     x2 = 0;
+        double xx1 = 0;
+        double x2x = 0;
+    };
+    std::vector<CoeffsX> buf(trgWidth);
+    for (int x = 0; x < trgWidth; ++x)
+    {
+        const int x1 = srcWidth * x / trgWidth;
+        int x2 = x1 + 1;
+        if (x2 == srcWidth) --x2;
+
+        const double xx1 = x / scaleX - x1;
+        const double x2x = 1 - xx1;
+
+        buf[x] = { x1, x2, xx1, x2x };
+    }
+
+    for (int y = yFirst; y < yLast; ++y)
+    {
+        const int y1 = srcHeight * y / trgHeight;
+        int y2 = y1 + 1;
+        if (y2 == srcHeight) --y2;
+
+        const double yy1 = y / scaleY - y1;
+        const double y2y = 1 - yy1;
+
+        const uint32_t* const srcLine     = byteAdvance(src, y1 * srcPitch);
+        const uint32_t* const srcLineNext = byteAdvance(src, y2 * srcPitch);
+        PixTrg*         const trgLine     = byteAdvance(trg, y  * trgPitch);
+
+        for (int x = 0; x < trgWidth; ++x)
+        {
+            //perf: do NOT "simplify" the variable layout without measurement!
+            const int     x1 = buf[x].x1;
+            const int     x2 = buf[x].x2;
+            const double xx1 = buf[x].xx1;
+            const double x2x = buf[x].x2x;
+
+            const double x2xy2y = x2x * y2y;
+            const double xx1y2y = xx1 * y2y;
+            const double x2xyy1 = x2x * yy1;
+            const double xx1yy1 = xx1 * yy1;
+
+            auto interpolate = [=](int offset)
+            {
+                /* https://en.wikipedia.org/wiki/Bilinear_interpolation
+                     (c11(x2 - x) + c21(x - x1)) * (y2 - y ) +
+                     (c12(x2 - x) + c22(x - x1)) * (y  - y1)                          */
+                const auto c11 = (srcLine    [x1] >> (8 * offset)) & 0xff;
+                const auto c21 = (srcLine    [x2] >> (8 * offset)) & 0xff;
+                const auto c12 = (srcLineNext[x1] >> (8 * offset)) & 0xff;
+                const auto c22 = (srcLineNext[x2] >> (8 * offset)) & 0xff;
+
+                return c11 * x2xy2y + c21 * xx1y2y +
+                       c12 * x2xyy1 + c22 * xx1yy1;
+            };
+
+            const double bi = interpolate(0);
+            const double gi = interpolate(1);
+            const double ri = interpolate(2);
+            const double ai = interpolate(3);
+
+            const auto b = static_cast<uint32_t>(bi + 0.5);
+            const auto g = static_cast<uint32_t>(gi + 0.5);
+            const auto r = static_cast<uint32_t>(ri + 0.5);
+            const auto a = static_cast<uint32_t>(ai + 0.5);
+
+            const uint32_t trgPix = (a << 24) | (r << 16) | (g << 8) | b;
+
+            trgLine[x] = pixCvrt(trgPix);
+        }
+    }
+}
+}
+
+#endif //XBRZ_TOOLS_H_825480175091875
